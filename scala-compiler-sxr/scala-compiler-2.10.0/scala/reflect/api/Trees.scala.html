<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/reflect/api/Trees.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
/* NSC -- new Scala compiler
 * Copyright 2005-2013 LAMP/EPFL
 * @author  Martin Odersky
 */
<span class="keyword">package</span> scala.reflect
<span class="keyword">package</span> api

/**
 * &lt;span class=&quot;badge badge-red&quot; style=&quot;float: right;&quot;&gt;EXPERIMENTAL&lt;/span&gt;
 *
 * This trait defines the node types used in Scala abstract syntax trees (AST) and operations on them.
 *
 * Trees are the basis for Scala's abstract syntax that is used to represent programs. They are also called
 * abstract syntax trees and commonly abbreviated as ASTs.
 *
 * In Scala reflection, APIs that produce or use `Tree`s are:
 *
 *   - '''Annotations''' which use trees to represent their arguments, exposed in [[scala.reflect.api.Annotations#scalaArgs Annotation.scalaArgs]].
 *   - '''[[scala.reflect.api.Universe#reify reify]]''', a special method on [[scala.reflect.api.Universe]] that takes an expression and returns an AST which represents the expression.
 *   - '''Macros and runtime compilation with toolboxes''' which both use trees as their program representation medium.
 *
 *  Trees are immutable, except for three fields
 *  [[Trees#TreeApi.pos pos]], [[Trees#TreeApi.symbol symbol]], and [[Trees#TreeApi.tpe tpe]], which are assigned when a tree is typechecked
 *  to attribute it with the information gathered by the typechecker.
 *
 *  === Examples ===
 *
 *  The following creates an AST representing a literal 5 in Scala source code:
 *  {{{
 *    Literal(Constant(5))
 *  }}}
 *
 *  The following creates an AST representing `print(&quot;Hello World&quot;)`:
 *  {{{
 *    Apply(Select(Select(This(newTypeName(&quot;scala&quot;)), newTermName(&quot;Predef&quot;)), newTermName(&quot;print&quot;)), List(Literal(Constant(&quot;Hello World&quot;))))
 *  }}}
 *
 *  The following creates an AST from a literal 5, and then uses `showRaw` to print it in a readable format.
 *  {{{
 *    import scala.reflect.runtime.universe.{ reify, showRaw }
 *    print( showRaw( reify{5}.tree ) )` // prints Literal(Constant(5))
 *  }}}
 *
 *  For more information about `Tree`s, see the [[http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html Reflection Guide: Symbols, Trees, Types]].
 *
 *  @groupname Traversal Tree Traversal and Transformation
 *  @groupprio Traversal 1
 *  @groupprio Factories 1
 *  @groupname Copying   Tree Copying
 *  @groupprio Copying   1
 *
 *  @contentDiagram hideNodes &quot;*Api&quot;
 *  @group ReflectionAPI
 */
<span class="keyword">trait</span> <a title="trait Trees extends Object" id="18021">Trees</a> <a href="../../Unit.scala.html#1515" title="Unit" class="delimiter">{</a> self: Universe =&gt;

  /** The type of Scala abstract syntax trees.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TreeApi" id="56186">Tree</a> &gt;: Null &lt;: TreeApi

  /** A tag that preserves the identity of the `Tree` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Tree]" id="56187">TreeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Tree]">ClassTag</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

  /** The API that all trees support.
   *  The main source of information about trees is the [[scala.reflect.api.Trees]] page.
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait TreeApi extends AnyRef with Product" id="56188">TreeApi</a> <a href="../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="../../Product.scala.html#186" title="Product">Product</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Tree =&gt;
    /** Does this tree represent a definition? (of a method, of a class, etc) */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402616">isDef</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Is this tree one of the empty trees?
     *  Empty trees are: the `EmptyTree` null object, `TypeTree` instances that don't carry a type
     *  and the special `emptyValDef` singleton.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402617">isEmpty</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** The canonical way to test if a Tree represents a term.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402618">isTerm</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** The canonical way to test if a Tree represents a type.
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402619">isType</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Position of the tree. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Position" id="402620">pos</a>: <a href="Positions.scala.html#56514" title="Trees.this.Position">Position</a>

    /** Type of the tree.
     *
     *  Upon creation most trees have their `tpe` set to `null`.
     *  Types are typically assigned to trees during typechecking.
     *  Some node factory methods set `tpe` immediately after creation.
     *
     *  When the typechecker encounters a tree with a non-null tpe,
     *  it will assume it to be correct and not check it again. This means one has
     *  to be careful not to erase the `tpe` field of subtrees.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Type" id="402621">tpe</a>: <a href="Types.scala.html#56063" title="Trees.this.Type">Type</a>

    /** Symbol of the tree.
     *
     *  For most trees symbol is `null`. In `SymTree`s,
     *  it is overridden and implemented with a var, initialized to `NoSymbol`.
     *
     *  Trees which are not `SymTree`s but which carry symbols do so by
     *  overriding `def symbol` to forward it elsewhere.  Examples:
     *
     *    - `Super(qual, _)`              has `qual`'s symbol,
     *    - `Apply(fun, args)`            has `fun`'s symbol,
     *    - `TypeApply(fun, args)`        has `fun`'s symbol,
     *    - `AppliedTypeTree(tpt, args)`  has `tpt`'s symbol,
     *    - `TypeTree(tpe)`               has `tpe`'s `typeSymbol`, if `tpe != null`.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Symbol" id="402622">symbol</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>

    /** Provides an alternate if tree is empty
     *  @param  alt  The alternate tree
     *  @return If this tree is non empty, this tree, otherwise `alt`.
     */
    <span class="keyword">def</span> <a title="(alt: =&gt; Trees.this.Tree)Trees.this.Tree" id="402623">orElse</a><span class="delimiter">(</span><a title="=&gt; Trees.this.Tree" id="404563">alt</a>: =&gt; Tree<span class="delimiter">)</span>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** Apply `f` to each subtree */
    <span class="keyword">def</span> <a title="(f: Trees.this.Tree =&gt; Unit)Unit" id="402624">foreach</a><span class="delimiter">(</span><a title="Trees.this.Tree =&gt; Unit" id="404565">f</a>: Tree =&gt; Unit<span class="delimiter">)</span>: <a href="../../Unit.scala.html#1515" title="Unit">Unit</a>

    /** Find all subtrees matching predicate `p`. Same as `filter` */
    <span class="keyword">def</span> <a title="(f: Trees.this.Tree =&gt; Boolean)List[Trees.this.Tree]" id="402625">withFilter</a><span class="delimiter">(</span><a title="Trees.this.Tree =&gt; Boolean" id="404567">f</a>: Tree =&gt; Boolean<span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

    /** Find all subtrees matching predicate `p`. Same as `withFilter` */
    <span class="keyword">def</span> <a title="(f: Trees.this.Tree =&gt; Boolean)List[Trees.this.Tree]" id="402626">filter</a><span class="delimiter">(</span><a title="Trees.this.Tree =&gt; Boolean" id="404569">f</a>: Tree =&gt; Boolean<span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

    /** Apply `pf' to each subtree on which the function is defined and collect the results.
     */
    <span class="keyword">def</span> <a title="[T](pf: PartialFunction[Trees.this.Tree,T])List[T]" id="402627">collect</a><span class="delimiter">[</span><a title="" id="402629">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[Trees.this.Tree,T]" id="404571">pf</a>: <a href="../../PartialFunction.scala.html#129" title="PartialFunction[Trees.this.Tree,T]">PartialFunction</a><span class="delimiter">[</span>Tree, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#11952" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

    /** Returns optionally first tree (in a preorder traversal) which satisfies predicate `p`,
     *  or None if none exists.
     */
    <span class="keyword">def</span> <a title="(p: Trees.this.Tree =&gt; Boolean)Option[Trees.this.Tree]" id="402630">find</a><span class="delimiter">(</span><a title="Trees.this.Tree =&gt; Boolean" id="404574">p</a>: Tree =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[Trees.this.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

    /** Is there exists a part of this tree which satisfies predicate `p`? */
    <span class="keyword">def</span> <a title="(p: Trees.this.Tree =&gt; Boolean)Boolean" id="402631">exists</a><span class="delimiter">(</span><a title="Trees.this.Tree =&gt; Boolean" id="404576">p</a>: Tree =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Do all parts of this tree satisfy predicate `p`? */
    <span class="keyword">def</span> <a title="(p: Trees.this.Tree =&gt; Boolean)Boolean" id="402632">forAll</a><span class="delimiter">(</span><a title="Trees.this.Tree =&gt; Boolean" id="404578">p</a>: Tree =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Tests whether two trees are structurall equal.
     *  Note that `==` on trees is reference equality.
     */
    <span class="keyword">def</span> <a title="(that: Trees.this.Tree)Boolean" id="402633">equalsStructure</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="404580">that</a> : <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** The direct child trees of this tree.
     *  EmptyTrees are always omitted.  Lists are flattened.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.Tree]" id="402634">children</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

    /** Extracts free term symbols from a tree that is reified or contains reified subtrees.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.FreeTermSymbol]" id="402635">freeTerms</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.FreeTermSymbol]">List</a><span class="delimiter">[</span>FreeTermSymbol<span class="delimiter">]</span>

    /** Extracts free type symbols from a tree that is reified or contains reified subtrees.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.FreeTypeSymbol]" id="402636">freeTypes</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.FreeTypeSymbol]">List</a><span class="delimiter">[</span>FreeTypeSymbol<span class="delimiter">]</span>

    /** Substitute symbols in `to` for corresponding occurrences of references to
     *  symbols `from` in this type.
     */
    <span class="keyword">def</span> <a title="(from: List[Trees.this.Symbol], to: List[Trees.this.Symbol])Trees.this.Tree" id="402637">substituteSymbols</a><span class="delimiter">(</span><a title="List[Trees.this.Symbol]" id="404588">from</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Trees.this.Symbol]" id="404589">to</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** Substitute types in `to` for corresponding occurrences of references to
     *  symbols `from` in this tree.
     */
    <span class="keyword">def</span> <a title="(from: List[Trees.this.Symbol], to: List[Trees.this.Type])Trees.this.Tree" id="402638">substituteTypes</a><span class="delimiter">(</span><a title="List[Trees.this.Symbol]" id="404591">from</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Trees.this.Type]" id="404592">to</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** Substitute given tree `to` for occurrences of nodes that represent
     *  `C.this`, where `C` referes to the given class `clazz`.
     */
    <span class="keyword">def</span> <a title="(clazz: Trees.this.Symbol, to: Trees.this.Tree)Trees.this.Tree" id="402639">substituteThis</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="404594">clazz</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Tree" id="404595">to</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** Make a copy of this tree, keeping all attributes,
     *  except that all positions are focused (so nothing
     *  in this tree will be found when searching by position).
     */
    <span class="keyword">def</span> <a title="=&gt; TreeApi.this.type" id="402640">duplicate</a>: <span class="keyword">this</span>.<span class="keyword">type</span>

    /** Obtains string representation of a tree */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="402641">toString</a>: <span title="String">String</span> = <a href="Printers.scala.html#56605" title="(tree: Trees.this.Tree)String">treeToString</a><span class="delimiter">(</span><a href="#56188" title="Trees.this.Tree" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Obtains string representation of a tree
   *  @group Trees
   */
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(tree: Trees.this.Tree)String" id="56189">treeToString</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="404602">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <span title="String">String</span>

  /** The empty tree
   *  @group Trees
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.Tree" id="56190">EmptyTree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

  /** A tree for a term.  Not all trees representing terms are TermTrees; use isTerm
   *  to reliably identify terms.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.Tree with Trees.this.TermTreeApi" id="56191">TermTree</a> &gt;: Null &lt;: AnyRef <span class="keyword">with</span> Tree <span class="keyword">with</span> TermTreeApi

  /** A tag that preserves the identity of the `TermTree` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.TermTree]" id="56192">TermTreeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.TermTree]">ClassTag</a><span class="delimiter">[</span>TermTree<span class="delimiter">]</span>

  /** The API that all term trees support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait TermTreeApi extends AnyRef with Trees.this.TreeApi" id="56193">TermTreeApi</a> <span class="keyword">extends</span> <a href="#56188" title="Trees.this.TreeApi">TreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: TermTree =&gt;
  <span class="delimiter">}</span>

  /** A tree for a type. Not all trees representing types are TypTrees; use isType
   *  to reliably identify types.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.Tree with Trees.this.TypTreeApi" id="56194">TypTree</a> &gt;: Null &lt;: AnyRef <span class="keyword">with</span> Tree <span class="keyword">with</span> TypTreeApi

  /** A tag that preserves the identity of the `TypTree` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.TypTree]" id="56195">TypTreeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.TypTree]">ClassTag</a><span class="delimiter">[</span>TypTree<span class="delimiter">]</span>

  /** The API that all typ trees support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait TypTreeApi extends AnyRef with Trees.this.TreeApi" id="56196">TypTreeApi</a> <span class="keyword">extends</span> <a href="#56188" title="Trees.this.TreeApi">TreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: TypTree =&gt;
  <span class="delimiter">}</span>

  /** A tree with a mutable symbol field, initialized to NoSymbol.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.Tree with Trees.this.SymTreeApi" id="56197">SymTree</a> &gt;: Null &lt;: AnyRef <span class="keyword">with</span> Tree <span class="keyword">with</span> SymTreeApi

  /** A tag that preserves the identity of the `SymTree` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.SymTree]" id="56198">SymTreeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.SymTree]">ClassTag</a><span class="delimiter">[</span>SymTree<span class="delimiter">]</span>

  /** The API that all sym trees support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait SymTreeApi extends AnyRef with Trees.this.TreeApi" id="56199">SymTreeApi</a> <span class="keyword">extends</span> <a href="#56188" title="Trees.this.TreeApi">TreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: SymTree =&gt;
    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Symbol" id="402643">symbol</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>
  <span class="delimiter">}</span>

  /** A tree with a name - effectively, a DefTree or RefTree.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.Tree with Trees.this.NameTreeApi" id="56200">NameTree</a> &gt;: Null &lt;: AnyRef <span class="keyword">with</span> Tree <span class="keyword">with</span> NameTreeApi

  /** A tag that preserves the identity of the `NameTree` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.NameTree]" id="56201">NameTreeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.NameTree]">ClassTag</a><span class="delimiter">[</span>NameTree<span class="delimiter">]</span>

  /** The API that all name trees support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait NameTreeApi extends AnyRef with Trees.this.TreeApi" id="56202">NameTreeApi</a> <span class="keyword">extends</span> <a href="#56188" title="Trees.this.TreeApi">TreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: NameTree =&gt;
    /** The underlying name.
     *  For example, the `&lt;List&gt;` part of `Ident(&quot;List&quot;: TermName)`.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Name" id="402646">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>
  <span class="delimiter">}</span>

  /** A tree which references a symbol-carrying entity.
   *  References one, as opposed to defining one; definitions
   *  are in DefTrees.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.SymTree with Trees.this.NameTree with Trees.this.RefTreeApi" id="56203">RefTree</a> &gt;: Null &lt;: SymTree <span class="keyword">with</span> NameTree <span class="keyword">with</span> RefTreeApi

  /** A tag that preserves the identity of the `RefTree` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.RefTree]" id="56204">RefTreeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.RefTree]">ClassTag</a><span class="delimiter">[</span>RefTree<span class="delimiter">]</span>

  /** The API that all ref trees support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait RefTreeApi extends AnyRef with Trees.this.SymTreeApi with Trees.this.NameTreeApi" id="56205">RefTreeApi</a> <span class="keyword">extends</span> <a href="#56199" title="Trees.this.SymTreeApi">SymTreeApi</a> <span class="keyword">with</span> <a href="#56202" title="Trees.this.NameTreeApi">NameTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: RefTree =&gt;
    /** The qualifier of the reference.
     *  For example, the `&lt;scala&gt;` part of `Select(&quot;scala&quot;: TermName, &quot;List&quot;: TermName)`.
     *  `EmptyTree` for `Ident` instances.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="402672">qualifier</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Name" id="402673">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>
  <span class="delimiter">}</span>

  /** A tree which defines a symbol-carrying entity.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.SymTree with Trees.this.NameTree with Trees.this.DefTreeApi" id="56206">DefTree</a> &gt;: Null &lt;: SymTree <span class="keyword">with</span> NameTree <span class="keyword">with</span> DefTreeApi

  /** A tag that preserves the identity of the `DefTree` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.DefTree]" id="56207">DefTreeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.DefTree]">ClassTag</a><span class="delimiter">[</span>DefTree<span class="delimiter">]</span>

  /** The API that all def trees support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait DefTreeApi extends AnyRef with Trees.this.SymTreeApi with Trees.this.NameTreeApi" id="56208">DefTreeApi</a> <span class="keyword">extends</span> <a href="#56199" title="Trees.this.SymTreeApi">SymTreeApi</a> <span class="keyword">with</span> <a href="#56202" title="Trees.this.NameTreeApi">NameTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: DefTree =&gt;
    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Name" id="402648">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>
  <span class="delimiter">}</span>

  /** Common base class for all member definitions: types, classes,
   *  objects, packages, vals and vars, defs.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.DefTree with Trees.this.MemberDefApi" id="56209">MemberDef</a> &gt;: Null &lt;: DefTree <span class="keyword">with</span> MemberDefApi

  /** A tag that preserves the identity of the `MemberDef` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.MemberDef]" id="56210">MemberDefTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.MemberDef]">ClassTag</a><span class="delimiter">[</span>MemberDef<span class="delimiter">]</span>

  /** The API that all member defs support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait MemberDefApi extends AnyRef with Trees.this.DefTreeApi" id="56211">MemberDefApi</a> <span class="keyword">extends</span> <a href="#56208" title="Trees.this.DefTreeApi">DefTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: MemberDef =&gt;
    /** Modifiers of the declared member. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Modifiers" id="402650">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>
  <span class="delimiter">}</span>

  /** A packaging, such as `package pid { stats }`
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.MemberDef with Trees.this.PackageDefApi" id="56212">PackageDef</a> &gt;: Null &lt;: MemberDef <span class="keyword">with</span> PackageDefApi

  /** A tag that preserves the identity of the `PackageDef` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.PackageDef]" id="56213">PackageDefTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.PackageDef]">ClassTag</a><span class="delimiter">[</span>PackageDef<span class="delimiter">]</span>

  /** The constructor/extractor for `PackageDef` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.PackageDefExtractor" id="56214">PackageDef</a>: <a href="#56215" title="Trees.this.PackageDefExtractor">PackageDefExtractor</a>

  /** An extractor class to create and pattern match with syntax `PackageDef(pid, stats)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `package` pid { stats }
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class PackageDefExtractor extends Object" id="56215">PackageDefExtractor</a> <a href="#56215" title="Trees.this.PackageDefExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(pid: Trees.this.RefTree, stats: List[Trees.this.Tree])Trees.this.PackageDef" id="404636">apply</a><span class="delimiter">(</span><a title="Trees.this.RefTree" id="404639">pid</a>: <a href="#56203" title="Trees.this.RefTree">RefTree</a>, <a title="List[Trees.this.Tree]" id="404640">stats</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56212" title="Trees.this.PackageDef">PackageDef</a>
    <span class="keyword">def</span> <a title="(packageDef: Trees.this.PackageDef)Option[(Trees.this.RefTree, List[Trees.this.Tree])]" id="404637">unapply</a><span class="delimiter">(</span><a title="Trees.this.PackageDef" id="404641">packageDef</a>: <a href="#56212" title="Trees.this.PackageDef">PackageDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.RefTree, List[Trees.this.Tree])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>RefTree, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all package defs support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait PackageDefApi extends AnyRef with Trees.this.MemberDefApi" id="56216">PackageDefApi</a> <span class="keyword">extends</span> <a href="#56211" title="Trees.this.MemberDefApi">MemberDefApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: PackageDef =&gt;
    /** The (possibly, fully-qualified) name of the package. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.RefTree" id="404633">pid</a>: <a href="#56203" title="Trees.this.RefTree">RefTree</a>

    /** Body of the package definition. */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.Tree]" id="404634">stats</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** A common base class for class and object definitions.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.MemberDef with Trees.this.ImplDefApi" id="56217">ImplDef</a> &gt;: Null &lt;: MemberDef <span class="keyword">with</span> ImplDefApi

  /** A tag that preserves the identity of the `ImplDef` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.ImplDef]" id="56218">ImplDefTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.ImplDef]">ClassTag</a><span class="delimiter">[</span>ImplDef<span class="delimiter">]</span>

  /** The API that all impl defs support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ImplDefApi extends AnyRef with Trees.this.MemberDefApi" id="56219">ImplDefApi</a> <span class="keyword">extends</span> <a href="#56211" title="Trees.this.MemberDefApi">MemberDefApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: ImplDef =&gt;
    /** The body of the definition. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Template" id="404649">impl</a>: <a href="#56263" title="Trees.this.Template">Template</a>
  <span class="delimiter">}</span>

  /** A class definition.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.ImplDef with Trees.this.ClassDefApi" id="56220">ClassDef</a> &gt;: Null &lt;: ImplDef <span class="keyword">with</span> ClassDefApi

  /** A tag that preserves the identity of the `ClassDef` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.ClassDef]" id="56221">ClassDefTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.ClassDef]">ClassTag</a><span class="delimiter">[</span>ClassDef<span class="delimiter">]</span>

  /** The constructor/extractor for `ClassDef` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.ClassDefExtractor" id="56222">ClassDef</a>: <a href="#56223" title="Trees.this.ClassDefExtractor">ClassDefExtractor</a>

  /** An extractor class to create and pattern match with syntax `ClassDef(mods, name, tparams, impl)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    mods `class` name [tparams] impl
   *
   *  Where impl stands for:
   *
   *    `extends` parents { defs }
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ClassDefExtractor extends Object" id="56223">ClassDefExtractor</a> <a href="#56223" title="Trees.this.ClassDefExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(mods: Trees.this.Modifiers, name: Trees.this.TypeName, tparams: List[Trees.this.TypeDef], impl: Trees.this.Template)Trees.this.ClassDef" id="404665">apply</a><span class="delimiter">(</span><a title="Trees.this.Modifiers" id="404668">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.TypeName" id="404669">name</a>: <a href="Names.scala.html#56177" title="Trees.this.TypeName">TypeName</a>, <a title="List[Trees.this.TypeDef]" id="404670">tparams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, <a title="Trees.this.Template" id="404671">impl</a>: <a href="#56263" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#56220" title="Trees.this.ClassDef">ClassDef</a>
    <span class="keyword">def</span> <a title="(classDef: Trees.this.ClassDef)Option[(Trees.this.Modifiers, Trees.this.TypeName, List[Trees.this.TypeDef], Trees.this.Template)]" id="404666">unapply</a><span class="delimiter">(</span><a title="Trees.this.ClassDef" id="404672">classDef</a>: <a href="#56220" title="Trees.this.ClassDef">ClassDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Modifiers, Trees.this.TypeName, List[Trees.this.TypeDef], Trees.this.Template)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Modifiers, TypeName, List<span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, Template<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all class defs support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ClassDefApi extends AnyRef with Trees.this.ImplDefApi" id="56224">ClassDefApi</a> <span class="keyword">extends</span> <a href="#56219" title="Trees.this.ImplDefApi">ImplDefApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: ClassDef =&gt;
    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Modifiers" id="404660">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>

    /** The name of the class. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.TypeName" id="404661">name</a>: <a href="Names.scala.html#56177" title="Trees.this.TypeName">TypeName</a>

    /** The type parameters of the class. */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.TypeDef]" id="404662">tparams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>

    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Template" id="404663">impl</a>: <a href="#56263" title="Trees.this.Template">Template</a>
  <span class="delimiter">}</span>

  /** An object definition, e.g. `object Foo`.  Internally, objects are
   *  quite frequently called modules to reduce ambiguity.
   *  Eliminated by compiler phase refcheck.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.ImplDef with Trees.this.ModuleDefApi" id="56225">ModuleDef</a> &gt;: Null &lt;: ImplDef <span class="keyword">with</span> ModuleDefApi

  /** A tag that preserves the identity of the `ModuleDef` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.ModuleDef]" id="56226">ModuleDefTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.ModuleDef]">ClassTag</a><span class="delimiter">[</span>ModuleDef<span class="delimiter">]</span>

  /** The constructor/extractor for `ModuleDef` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.ModuleDefExtractor" id="56227">ModuleDef</a>: <a href="#56228" title="Trees.this.ModuleDefExtractor">ModuleDefExtractor</a>

  /** An extractor class to create and pattern match with syntax `ModuleDef(mods, name, impl)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    mods `object` name impl
   *
   *  Where impl stands for:
   *
   *    `extends` parents { defs }
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ModuleDefExtractor extends Object" id="56228">ModuleDefExtractor</a> <a href="#56228" title="Trees.this.ModuleDefExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(mods: Trees.this.Modifiers, name: Trees.this.TermName, impl: Trees.this.Template)Trees.this.ModuleDef" id="404688">apply</a><span class="delimiter">(</span><a title="Trees.this.Modifiers" id="404691">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.TermName" id="404692">name</a>: <a href="Names.scala.html#56179" title="Trees.this.TermName">TermName</a>, <a title="Trees.this.Template" id="404693">impl</a>: <a href="#56263" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#56225" title="Trees.this.ModuleDef">ModuleDef</a>
    <span class="keyword">def</span> <a title="(moduleDef: Trees.this.ModuleDef)Option[(Trees.this.Modifiers, Trees.this.TermName, Trees.this.Template)]" id="404689">unapply</a><span class="delimiter">(</span><a title="Trees.this.ModuleDef" id="404694">moduleDef</a>: <a href="#56225" title="Trees.this.ModuleDef">ModuleDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Modifiers, Trees.this.TermName, Trees.this.Template)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Modifiers, TermName, Template<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all module defs support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ModuleDefApi extends AnyRef with Trees.this.ImplDefApi" id="56229">ModuleDefApi</a> <span class="keyword">extends</span> <a href="#56219" title="Trees.this.ImplDefApi">ImplDefApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: ModuleDef =&gt;
    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Modifiers" id="404684">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>

    /** The name of the module. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.TermName" id="404685">name</a>: <a href="Names.scala.html#56179" title="Trees.this.TermName">TermName</a>

    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Template" id="404686">impl</a>: <a href="#56263" title="Trees.this.Template">Template</a>
  <span class="delimiter">}</span>

  /** A common base class for ValDefs and DefDefs.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.MemberDef with Trees.this.ValOrDefDefApi" id="56230">ValOrDefDef</a> &gt;: Null &lt;: MemberDef <span class="keyword">with</span> ValOrDefDefApi

  /** A tag that preserves the identity of the `ValOrDefDef` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.ValOrDefDef]" id="56231">ValOrDefDefTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.ValOrDefDef]">ClassTag</a><span class="delimiter">[</span>ValOrDefDef<span class="delimiter">]</span>

  /** The API that all val defs and def defs support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ValOrDefDefApi extends AnyRef with Trees.this.MemberDefApi" id="56232">ValOrDefDefApi</a> <span class="keyword">extends</span> <a href="#56211" title="Trees.this.MemberDefApi">MemberDefApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: ValOrDefDef =&gt;
    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Name" id="402652">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a> // can't be a TermName because macros can be type names.

    /** The type ascribed to the definition.
     *  An empty `TypeTree` if the type hasn't been specified explicitly
     *  and is supposed to be inferred.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="402653">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The body of the definition.
     *  The `EmptyTree` is the body is empty (e.g. for abstract members).
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="402654">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Broadly speaking, a value definition.  All these are encoded as ValDefs:
   *
   *   - immutable values, e.g. &quot;val x&quot;
   *   - mutable values, e.g. &quot;var x&quot; - the MUTABLE flag set in mods
   *   - lazy values, e.g. &quot;lazy val x&quot; - the LAZY flag set in mods
   *   - method parameters, see vparamss in [[scala.reflect.api.Trees#DefDef]] - the PARAM flag is set in mods
   *   - explicit self-types, e.g. class A { self: Bar =&gt; }
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.ValOrDefDef with Trees.this.ValDefApi" id="56233">ValDef</a> &gt;: Null &lt;: ValOrDefDef <span class="keyword">with</span> ValDefApi

  /** A tag that preserves the identity of the `ValDef` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.ValDef]" id="56234">ValDefTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.ValDef]">ClassTag</a><span class="delimiter">[</span>ValDef<span class="delimiter">]</span>

  /** The constructor/extractor for `ValDef` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.ValDefExtractor" id="56235">ValDef</a>: <a href="#56236" title="Trees.this.ValDefExtractor">ValDefExtractor</a>

  /** An extractor class to create and pattern match with syntax `ValDef(mods, name, tpt, rhs)`.
   *  This AST node corresponds to any of the following Scala code:
   *
   *    mods `val` name: tpt = rhs
   *
   *    mods `var` name: tpt = rhs
   *
   *    mods name: tpt = rhs        // in signatures of function and method definitions
   *
   *    self: Bar =&gt;                // self-types
   *
   *  If the type of a value is not specified explicitly (i.e. is meant to be inferred),
   *  this is expressed by having `tpt` set to `TypeTree()` (but not to an `EmptyTree`!).
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ValDefExtractor extends Object" id="56236">ValDefExtractor</a> <a href="#56236" title="Trees.this.ValDefExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(mods: Trees.this.Modifiers, name: Trees.this.TermName, tpt: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.ValDef" id="404710">apply</a><span class="delimiter">(</span><a title="Trees.this.Modifiers" id="404713">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.TermName" id="404714">name</a>: <a href="Names.scala.html#56179" title="Trees.this.TermName">TermName</a>, <a title="Trees.this.Tree" id="404715">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="404716">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56233" title="Trees.this.ValDef">ValDef</a>
    <span class="keyword">def</span> <a title="(valDef: Trees.this.ValDef)Option[(Trees.this.Modifiers, Trees.this.TermName, Trees.this.Tree, Trees.this.Tree)]" id="404711">unapply</a><span class="delimiter">(</span><a title="Trees.this.ValDef" id="404717">valDef</a>: <a href="#56233" title="Trees.this.ValDef">ValDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Modifiers, Trees.this.TermName, Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Modifiers, TermName, Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all val defs support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ValDefApi extends AnyRef with Trees.this.ValOrDefDefApi" id="56237">ValDefApi</a> <span class="keyword">extends</span> <a href="#56232" title="Trees.this.ValOrDefDefApi">ValOrDefDefApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: ValDef =&gt;
    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Modifiers" id="402656">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>

    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.TermName" id="402657">name</a>: <a href="Names.scala.html#56179" title="Trees.this.TermName">TermName</a>

    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="402658">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="402659">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** A method or macro definition.
   *  @param name   The name of the method or macro. Can be a type name in case this is a type macro
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.ValOrDefDef with Trees.this.DefDefApi" id="56238">DefDef</a> &gt;: Null &lt;: ValOrDefDef <span class="keyword">with</span> DefDefApi

  /** A tag that preserves the identity of the `DefDef` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.DefDef]" id="56239">DefDefTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.DefDef]">ClassTag</a><span class="delimiter">[</span>DefDef<span class="delimiter">]</span>

  /** The constructor/extractor for `DefDef` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.DefDefExtractor" id="56240">DefDef</a>: <a href="#56241" title="Trees.this.DefDefExtractor">DefDefExtractor</a>

  /** An extractor class to create and pattern match with syntax `DefDef(mods, name, tparams, vparamss, tpt, rhs)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    mods `def` name[tparams](vparams_1)...(vparams_n): tpt = rhs
   *
   *  If the return type is not specified explicitly (i.e. is meant to be inferred),
   *  this is expressed by having `tpt` set to `TypeTree()` (but not to an `EmptyTree`!).
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class DefDefExtractor extends Object" id="56241">DefDefExtractor</a> <a href="#56241" title="Trees.this.DefDefExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(mods: Trees.this.Modifiers, name: Trees.this.Name, tparams: List[Trees.this.TypeDef], vparamss: List[List[Trees.this.ValDef]], tpt: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.DefDef" id="404736">apply</a><span class="delimiter">(</span><a title="Trees.this.Modifiers" id="404739">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.Name" id="404740">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>, <a title="List[Trees.this.TypeDef]" id="404741">tparams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, <a title="List[List[Trees.this.ValDef]]" id="404742">vparamss</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[List[Trees.this.ValDef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Trees.this.Tree" id="404743">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="404744">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56238" title="Trees.this.DefDef">DefDef</a>
    <span class="keyword">def</span> <a title="(defDef: Trees.this.DefDef)Option[(Trees.this.Modifiers, Trees.this.Name, List[Trees.this.TypeDef], List[List[Trees.this.ValDef]], Trees.this.Tree, Trees.this.Tree)]" id="404737">unapply</a><span class="delimiter">(</span><a title="Trees.this.DefDef" id="404745">defDef</a>: <a href="#56238" title="Trees.this.DefDef">DefDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Modifiers, Trees.this.Name, List[Trees.this.TypeDef], List[List[Trees.this.ValDef]], Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Modifiers, Name, List<span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, List<span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span>, Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all def defs support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait DefDefApi extends AnyRef with Trees.this.ValOrDefDefApi" id="56242">DefDefApi</a> <span class="keyword">extends</span> <a href="#56232" title="Trees.this.ValOrDefDefApi">ValOrDefDefApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: DefDef =&gt;
    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Modifiers" id="404729">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>

    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Name" id="404730">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>

    /** The type parameters of the method. */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.TypeDef]" id="404731">tparams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>

    /** The parameter lists of the method. */
    <span class="keyword">def</span> <a title="=&gt; List[List[Trees.this.ValDef]]" id="404732">vparamss</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[List[Trees.this.ValDef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span>

    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404733">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404734">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** An abstract type, a type parameter, or a type alias.
   *  Eliminated by erasure.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.MemberDef with Trees.this.TypeDefApi" id="56243">TypeDef</a> &gt;: Null &lt;: MemberDef <span class="keyword">with</span> TypeDefApi

  /** A tag that preserves the identity of the `TypeDef` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.TypeDef]" id="56244">TypeDefTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.TypeDef]">ClassTag</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>

  /** The constructor/extractor for `TypeDef` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.TypeDefExtractor" id="56245">TypeDef</a>: <a href="#56246" title="Trees.this.TypeDefExtractor">TypeDefExtractor</a>

  /** An extractor class to create and pattern match with syntax `TypeDef(mods, name, tparams, rhs)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    mods `type` name[tparams] = rhs
   *
   *    mods `type` name[tparams] &gt;: lo &lt;: hi
   *
   *  First usage illustrates `TypeDefs` representing type aliases and type parameters.
   *  Second usage illustrates `TypeDefs` representing abstract types,
   *  where lo and hi are both `TypeBoundsTrees` and `Modifier.deferred` is set in mods.
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeDefExtractor extends Object" id="56246">TypeDefExtractor</a> <a href="#56246" title="Trees.this.TypeDefExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(mods: Trees.this.Modifiers, name: Trees.this.TypeName, tparams: List[Trees.this.TypeDef], rhs: Trees.this.Tree)Trees.this.TypeDef" id="404766">apply</a><span class="delimiter">(</span><a title="Trees.this.Modifiers" id="404769">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.TypeName" id="404770">name</a>: <a href="Names.scala.html#56177" title="Trees.this.TypeName">TypeName</a>, <a title="List[Trees.this.TypeDef]" id="404771">tparams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="404772">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56243" title="Trees.this.TypeDef">TypeDef</a>
    <span class="keyword">def</span> <a title="(typeDef: Trees.this.TypeDef)Option[(Trees.this.Modifiers, Trees.this.TypeName, List[Trees.this.TypeDef], Trees.this.Tree)]" id="404767">unapply</a><span class="delimiter">(</span><a title="Trees.this.TypeDef" id="404773">typeDef</a>: <a href="#56243" title="Trees.this.TypeDef">TypeDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Modifiers, Trees.this.TypeName, List[Trees.this.TypeDef], Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Modifiers, TypeName, List<span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all type defs support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait TypeDefApi extends AnyRef with Trees.this.MemberDefApi" id="56247">TypeDefApi</a> <span class="keyword">extends</span> <a href="#56211" title="Trees.this.MemberDefApi">MemberDefApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: TypeDef =&gt;
    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Modifiers" id="404761">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>

    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.TypeName" id="404762">name</a>: <a href="Names.scala.html#56177" title="Trees.this.TypeName">TypeName</a>

    /** The type parameters of this type definition. */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.TypeDef]" id="404763">tparams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>

    /** The body of the definition.
     *  The `EmptyTree` is the body is empty (e.g. for abstract type members).
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404764">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** A labelled expression.  Not expressible in language syntax, but
   *  generated by the compiler to simulate while/do-while loops, and
   *  also by the pattern matcher.
   *
   *  The label acts much like a nested function, where `params` represents
   *  the incoming parameters.  The symbol given to the LabelDef should have
   *  a MethodType, as if it were a nested function.
   *
   *  Jumps are apply nodes attributed with a label's symbol.  The
   *  arguments from the apply node will be passed to the label and
   *  assigned to the Idents.
   *
   *  Forward jumps within a block are allowed.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.DefTree with Trees.this.TermTree with Trees.this.LabelDefApi" id="56248">LabelDef</a> &gt;: Null &lt;: DefTree <span class="keyword">with</span> TermTree <span class="keyword">with</span> LabelDefApi

  /** A tag that preserves the identity of the `LabelDef` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.LabelDef]" id="56249">LabelDefTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.LabelDef]">ClassTag</a><span class="delimiter">[</span>LabelDef<span class="delimiter">]</span>

  /** The constructor/extractor for `LabelDef` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.LabelDefExtractor" id="56250">LabelDef</a>: <a href="#56251" title="Trees.this.LabelDefExtractor">LabelDefExtractor</a>

  /** An extractor class to create and pattern match with syntax `LabelDef(name, params, rhs)`.
   *
   *  This AST node does not have direct correspondence to Scala code.
   *  It is used for tailcalls and like.
   *  For example, while/do are desugared to label defs as follows:
   *  {{{
   *    while (cond) body ==&gt; LabelDef(\$L, List(), if (cond) { body; L\$() } else ())
   *  }}}
   *  {{{
   *    do body while (cond) ==&gt; LabelDef(\$L, List(), body; if (cond) L\$() else ())
   *  }}}
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class LabelDefExtractor extends Object" id="56251">LabelDefExtractor</a> <a href="#56251" title="Trees.this.LabelDefExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(name: Trees.this.TermName, params: List[Trees.this.Ident], rhs: Trees.this.Tree)Trees.this.LabelDef" id="404789">apply</a><span class="delimiter">(</span><a title="Trees.this.TermName" id="404792">name</a>: <a href="Names.scala.html#56179" title="Trees.this.TermName">TermName</a>, <a title="List[Trees.this.Ident]" id="404793">params</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Ident]">List</a><span class="delimiter">[</span>Ident<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="404794">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56248" title="Trees.this.LabelDef">LabelDef</a>
    <span class="keyword">def</span> <a title="(labelDef: Trees.this.LabelDef)Option[(Trees.this.TermName, List[Trees.this.Ident], Trees.this.Tree)]" id="404790">unapply</a><span class="delimiter">(</span><a title="Trees.this.LabelDef" id="404795">labelDef</a>: <a href="#56248" title="Trees.this.LabelDef">LabelDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.TermName, List[Trees.this.Ident], Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>TermName, List<span class="delimiter">[</span>Ident<span class="delimiter">]</span>, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all label defs support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait LabelDefApi extends AnyRef with Trees.this.DefTreeApi with Trees.this.TermTreeApi" id="56252">LabelDefApi</a> <span class="keyword">extends</span> <a href="#56208" title="Trees.this.DefTreeApi">DefTreeApi</a> <span class="keyword">with</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: LabelDef =&gt;
    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.TermName" id="404785">name</a>: <a href="Names.scala.html#56179" title="Trees.this.TermName">TermName</a>

    /** Label's parameters - names that can be used in the body of the label.
     *  See the example for [[scala.reflect.api.Trees#LabelDefExtractor]].
     */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.Ident]" id="404786">params</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Ident]">List</a><span class="delimiter">[</span>Ident<span class="delimiter">]</span>

    /** The body of the label.
     *  See the example for [[scala.reflect.api.Trees#LabelDefExtractor]].
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404787">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Import selector
   *
   *  Representation of an imported name its optional rename and their optional positions
   *
   *  Eliminated by typecheck.
   *
   * @param name      the imported name
   * @param namePos   its position or -1 if undefined
   * @param rename    the name the import is renamed to (== name if no renaming)
   * @param renamePos the position of the rename or -1 if undefined
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.ImportSelectorApi" id="56253">ImportSelector</a> &gt;: Null &lt;: AnyRef <span class="keyword">with</span> ImportSelectorApi

  /** A tag that preserves the identity of the `ImportSelector` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.ImportSelector]" id="56254">ImportSelectorTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.ImportSelector]">ClassTag</a><span class="delimiter">[</span>ImportSelector<span class="delimiter">]</span>

  /** The constructor/extractor for `ImportSelector` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.ImportSelectorExtractor" id="56255">ImportSelector</a>: <a href="#56256" title="Trees.this.ImportSelectorExtractor">ImportSelectorExtractor</a>

  /** An extractor class to create and pattern match with syntax `ImportSelector(name:, namePos, rename, renamePos)`.
   *  This is not an AST node, it is used as a part of the `Import` node.
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ImportSelectorExtractor extends Object" id="56256">ImportSelectorExtractor</a> <a href="#56256" title="Trees.this.ImportSelectorExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(name: Trees.this.Name, namePos: Int, rename: Trees.this.Name, renamePos: Int)Trees.this.ImportSelector" id="404810">apply</a><span class="delimiter">(</span><a title="Trees.this.Name" id="404813">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>, <a title="Int" id="404814">namePos</a>: <a href="../../Int.scala.html#321" title="Int">Int</a>, <a title="Trees.this.Name" id="404815">rename</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>, <a title="Int" id="404816">renamePos</a>: <a href="../../Int.scala.html#321" title="Int">Int</a><span class="delimiter">)</span>: <a href="#56253" title="Trees.this.ImportSelector">ImportSelector</a>
    <span class="keyword">def</span> <a title="(importSelector: Trees.this.ImportSelector)Option[(Trees.this.Name, Int, Trees.this.Name, Int)]" id="404811">unapply</a><span class="delimiter">(</span><a title="Trees.this.ImportSelector" id="404817">importSelector</a>: <a href="#56253" title="Trees.this.ImportSelector">ImportSelector</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Name, Int, Trees.this.Name, Int)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Name, Int, Name, Int<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all import selectors support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ImportSelectorApi extends Object" id="56257">ImportSelectorApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: ImportSelector =&gt;
    /** The imported name. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Name" id="404805">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>

    /** Offset of the position of the importing part of the selector in the source file.
     *  Is equal to -1 is the position is unknown.
     */
    <span class="keyword">def</span> <a title="=&gt; Int" id="404806">namePos</a>: <a href="../../Int.scala.html#321" title="Int">Int</a>

    /** The name the import is renamed to.
     *  Is equal to `name` if it's not a renaming import.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Name" id="404807">rename</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>

    /** Offset of the position of the renaming part of the selector in the source file.
     *  Is equal to -1 is the position is unknown.
     */
    <span class="keyword">def</span> <a title="=&gt; Int" id="404808">renamePos</a>: <a href="../../Int.scala.html#321" title="Int">Int</a>
  <span class="delimiter">}</span>

  /** Import clause
   *
   *  @param expr
   *  @param selectors
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.SymTree with Trees.this.ImportApi" id="56258">Import</a> &gt;: Null &lt;: SymTree <span class="keyword">with</span> ImportApi

  /** A tag that preserves the identity of the `Import` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Import]" id="56259">ImportTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Import]">ClassTag</a><span class="delimiter">[</span>Import<span class="delimiter">]</span>

  /** The constructor/extractor for `Import` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.ImportExtractor" id="56260">Import</a>: <a href="#56261" title="Trees.this.ImportExtractor">ImportExtractor</a>

  /** An extractor class to create and pattern match with syntax `Import(expr, selectors)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    import expr.{selectors}
   *
   *  Selectors are a list of ImportSelectors, which conceptually are pairs of names (from, to).
   *  The last (and maybe only name) may be a nme.WILDCARD. For instance:
   *
   *    import qual.{x, y =&gt; z, _}
   *
   *  Would be represented as:
   *
   *    Import(qual, List((&quot;x&quot;, &quot;x&quot;), (&quot;y&quot;, &quot;z&quot;), (WILDCARD, null)))
   *
   *  The symbol of an `Import` is an import symbol @see Symbol.newImport.
   *  It's used primarily as a marker to check that the import has been typechecked.
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ImportExtractor extends Object" id="56261">ImportExtractor</a> <a href="#56261" title="Trees.this.ImportExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(expr: Trees.this.Tree, selectors: List[Trees.this.ImportSelector])Trees.this.Import" id="404824">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="404827">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.ImportSelector]" id="404828">selectors</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.ImportSelector]">List</a><span class="delimiter">[</span>ImportSelector<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56258" title="Trees.this.Import">Import</a>
    <span class="keyword">def</span> <a title="(import_: Trees.this.Import)Option[(Trees.this.Tree, List[Trees.this.ImportSelector])]" id="404825">unapply</a><span class="delimiter">(</span><a title="Trees.this.Import" id="404829">import_</a> : <a href="#56258" title="Trees.this.Import">Import</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, List[Trees.this.ImportSelector])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>ImportSelector<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all imports support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ImportApi extends AnyRef with Trees.this.SymTreeApi" id="56262">ImportApi</a> <span class="keyword">extends</span> <a href="#56199" title="Trees.this.SymTreeApi">SymTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Import =&gt;
    /** The qualifier of the import.
     *  See the example for [[scala.reflect.api.Trees#ImportExtractor]].
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404821">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The selectors of the import.
     *  See the example for [[scala.reflect.api.Trees#ImportExtractor]].
     */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.ImportSelector]" id="404822">selectors</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.ImportSelector]">List</a><span class="delimiter">[</span>ImportSelector<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** Instantiation template of a class or trait
   *
   *  @param parents
   *  @param body
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.SymTree with Trees.this.TemplateApi" id="56263">Template</a> &gt;: Null &lt;: SymTree <span class="keyword">with</span> TemplateApi

  /** A tag that preserves the identity of the `Template` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Template]" id="56264">TemplateTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Template]">ClassTag</a><span class="delimiter">[</span>Template<span class="delimiter">]</span>

  /** The constructor/extractor for `Template` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.TemplateExtractor" id="56265">Template</a>: <a href="#56266" title="Trees.this.TemplateExtractor">TemplateExtractor</a>

  /** An extractor class to create and pattern match with syntax `Template(parents, self, body)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `extends` parents { self =&gt; body }
   *
   *  In case when the self-type annotation is missing, it is represented as
   *  an empty value definition with nme.WILDCARD as name and NoType as type.
   *
   *  The symbol of a template is a local dummy. @see Symbol.newLocalDummy
   *  The owner of the local dummy is the enclosing trait or class.
   *  The local dummy is itself the owner of any local blocks. For example:
   *
   *    class C {
   *      def foo { // owner is C
   *        def bar  // owner is local dummy
   *      }
   *    }
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TemplateExtractor extends Object" id="56266">TemplateExtractor</a> <a href="#56266" title="Trees.this.TemplateExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(parents: List[Trees.this.Tree], self: Trees.this.ValDef, body: List[Trees.this.Tree])Trees.this.Template" id="404836">apply</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="404839">parents</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="Trees.this.ValDef" id="404840">self</a>: <a href="#56233" title="Trees.this.ValDef">ValDef</a>, <a title="List[Trees.this.Tree]" id="404841">body</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56263" title="Trees.this.Template">Template</a>
    <span class="keyword">def</span> <a title="(template: Trees.this.Template)Option[(List[Trees.this.Tree], Trees.this.ValDef, List[Trees.this.Tree])]" id="404837">unapply</a><span class="delimiter">(</span><a title="Trees.this.Template" id="404842">template</a>: <a href="#56263" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(List[Trees.this.Tree], Trees.this.ValDef, List[Trees.this.Tree])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span>, ValDef, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all templates support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait TemplateApi extends AnyRef with Trees.this.SymTreeApi" id="56267">TemplateApi</a> <span class="keyword">extends</span> <a href="#56199" title="Trees.this.SymTreeApi">SymTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Template =&gt;
    /** Superclasses of the template. */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.Tree]" id="404655">parents</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

    /** Self type of the template.
     *  Is equal to `emptyValDef` if the self type is not specified.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.ValDef" id="404656">self</a>: <a href="#56233" title="Trees.this.ValDef">ValDef</a>

    /** Body of the template.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.Tree]" id="404657">body</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** Block of expressions (semicolon separated expressions)
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.BlockApi" id="56268">Block</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> BlockApi

  /** A tag that preserves the identity of the `Block` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Block]" id="56269">BlockTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Block]">ClassTag</a><span class="delimiter">[</span>Block<span class="delimiter">]</span>

  /** The constructor/extractor for `Block` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.BlockExtractor" id="56270">Block</a>: <a href="#56271" title="Trees.this.BlockExtractor">BlockExtractor</a>

  /** An extractor class to create and pattern match with syntax `Block(stats, expr)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    { stats; expr }
   *
   *  If the block is empty, the `expr` is set to `Literal(Constant(()))`.
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class BlockExtractor extends Object" id="56271">BlockExtractor</a> <a href="#56271" title="Trees.this.BlockExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(stats: List[Trees.this.Tree], expr: Trees.this.Tree)Trees.this.Block" id="404855">apply</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="404858">stats</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="404859">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56268" title="Trees.this.Block">Block</a>
    <span class="keyword">def</span> <a title="(block: Trees.this.Block)Option[(List[Trees.this.Tree], Trees.this.Tree)]" id="404856">unapply</a><span class="delimiter">(</span><a title="Trees.this.Block" id="404860">block</a>: <a href="#56268" title="Trees.this.Block">Block</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(List[Trees.this.Tree], Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span>, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all blocks support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait BlockApi extends AnyRef with Trees.this.TermTreeApi" id="56272">BlockApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Block =&gt;
    /** All, but the last, expressions in the block.
     *  Can very well be an empty list.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.Tree]" id="404852">stats</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

    /** The last expression in the block. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404853">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Case clause in a pattern match.
   *  (except for occurrences in switch statements).
   *  Eliminated by compiler phases patmat (in the new pattern matcher of 2.10) or explicitouter (in the old pre-2.10 pattern matcher)
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.Tree with Trees.this.CaseDefApi" id="56273">CaseDef</a> &gt;: Null &lt;: AnyRef <span class="keyword">with</span> Tree <span class="keyword">with</span> CaseDefApi

  /** A tag that preserves the identity of the `CaseDef` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.CaseDef]" id="56274">CaseDefTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.CaseDef]">ClassTag</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span>

  /** The constructor/extractor for `CaseDef` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.CaseDefExtractor" id="56275">CaseDef</a>: <a href="#56276" title="Trees.this.CaseDefExtractor">CaseDefExtractor</a>

  /** An extractor class to create and pattern match with syntax `CaseDef(pat, guard, body)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `case` pat `if` guard =&gt; body
   *
   *  If the guard is not present, the `guard` is set to `EmptyTree`.
   *  If the body is not specified, the `body` is set to `Literal(Constant())`
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class CaseDefExtractor extends Object" id="56276">CaseDefExtractor</a> <a href="#56276" title="Trees.this.CaseDefExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(pat: Trees.this.Tree, guard: Trees.this.Tree, body: Trees.this.Tree)Trees.this.CaseDef" id="404872">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="404875">pat</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="404876">guard</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="404877">body</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56273" title="Trees.this.CaseDef">CaseDef</a>
    <span class="keyword">def</span> <a title="(caseDef: Trees.this.CaseDef)Option[(Trees.this.Tree, Trees.this.Tree, Trees.this.Tree)]" id="404873">unapply</a><span class="delimiter">(</span><a title="Trees.this.CaseDef" id="404878">caseDef</a>: <a href="#56273" title="Trees.this.CaseDef">CaseDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all case defs support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait CaseDefApi extends AnyRef with Trees.this.TreeApi" id="56277">CaseDefApi</a> <span class="keyword">extends</span> <a href="#56188" title="Trees.this.TreeApi">TreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: CaseDef =&gt;
    /** The pattern of the pattern matching clause. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404868">pat</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The guard of the pattern matching clause.
     *  Is equal to `EmptyTree` if the guard is not specified.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404869">guard</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The body of the pattern matching clause.
     *  Is equal to `Literal(Constant())` if the body is not specified.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404870">body</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Alternatives of patterns.
   *
   * Eliminated by compiler phases Eliminated by compiler phases patmat (in the new pattern matcher of 2.10) or explicitouter (in the old pre-2.10 pattern matcher),
   * except for
   *  occurrences in encoded Switch stmt (i.e. remaining Match(CaseDef(...)))
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.AlternativeApi" id="56278">Alternative</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> AlternativeApi

  /** A tag that preserves the identity of the `Alternative` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Alternative]" id="56279">AlternativeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Alternative]">ClassTag</a><span class="delimiter">[</span>Alternative<span class="delimiter">]</span>

  /** The constructor/extractor for `Alternative` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.AlternativeExtractor" id="56280">Alternative</a>: <a href="#56281" title="Trees.this.AlternativeExtractor">AlternativeExtractor</a>

  /** An extractor class to create and pattern match with syntax `Alternative(trees)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    pat1 | ... | patn
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AlternativeExtractor extends Object" id="56281">AlternativeExtractor</a> <a href="#56281" title="Trees.this.AlternativeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(trees: List[Trees.this.Tree])Trees.this.Alternative" id="404890">apply</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="404893">trees</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56278" title="Trees.this.Alternative">Alternative</a>
    <span class="keyword">def</span> <a title="(alternative: Trees.this.Alternative)Option[List[Trees.this.Tree]]" id="404891">unapply</a><span class="delimiter">(</span><a title="Trees.this.Alternative" id="404894">alternative</a>: <a href="#56278" title="Trees.this.Alternative">Alternative</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[List[Trees.this.Tree]]">Option</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all alternatives support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait AlternativeApi extends AnyRef with Trees.this.TermTreeApi" id="56282">AlternativeApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Alternative =&gt;
    /** Alternatives of the pattern matching clause. */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.Tree]" id="404888">trees</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** Repetition of pattern.
   *
   *  Eliminated by compiler phases patmat (in the new pattern matcher of 2.10) or explicitouter (in the old pre-2.10 pattern matcher).
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.StarApi" id="56283">Star</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> StarApi

  /** A tag that preserves the identity of the `Star` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Star]" id="56284">StarTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Star]">ClassTag</a><span class="delimiter">[</span>Star<span class="delimiter">]</span>

  /** The constructor/extractor for `Star` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.StarExtractor" id="56285">Star</a>: <a href="#56286" title="Trees.this.StarExtractor">StarExtractor</a>

  /** An extractor class to create and pattern match with syntax `Star(elem)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    pat*
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class StarExtractor extends Object" id="56286">StarExtractor</a> <a href="#56286" title="Trees.this.StarExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(elem: Trees.this.Tree)Trees.this.Star" id="404902">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="404905">elem</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56283" title="Trees.this.Star">Star</a>
    <span class="keyword">def</span> <a title="(star: Trees.this.Star)Option[Trees.this.Tree]" id="404903">unapply</a><span class="delimiter">(</span><a title="Trees.this.Star" id="404906">star</a>: <a href="#56283" title="Trees.this.Star">Star</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[Trees.this.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all stars support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait StarApi extends AnyRef with Trees.this.TermTreeApi" id="56287">StarApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Star =&gt;
    /** The quantified pattern. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404900">elem</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Bind a variable to a rhs pattern.
   *
   * Eliminated by compiler phases patmat (in the new pattern matcher of 2.10) or explicitouter (in the old pre-2.10 pattern matcher).
   *
   *  @param name
   *  @param body
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.DefTree with Trees.this.BindApi" id="56288">Bind</a> &gt;: Null &lt;: DefTree <span class="keyword">with</span> BindApi

  /** A tag that preserves the identity of the `Bind` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Bind]" id="56289">BindTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Bind]">ClassTag</a><span class="delimiter">[</span>Bind<span class="delimiter">]</span>

  /** The constructor/extractor for `Bind` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.BindExtractor" id="56290">Bind</a>: <a href="#56291" title="Trees.this.BindExtractor">BindExtractor</a>

  /** An extractor class to create and pattern match with syntax `Bind(name, body)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    pat*
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class BindExtractor extends Object" id="56291">BindExtractor</a> <a href="#56291" title="Trees.this.BindExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(name: Trees.this.Name, body: Trees.this.Tree)Trees.this.Bind" id="404915">apply</a><span class="delimiter">(</span><a title="Trees.this.Name" id="404918">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>, <a title="Trees.this.Tree" id="404919">body</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56288" title="Trees.this.Bind">Bind</a>
    <span class="keyword">def</span> <a title="(bind: Trees.this.Bind)Option[(Trees.this.Name, Trees.this.Tree)]" id="404916">unapply</a><span class="delimiter">(</span><a title="Trees.this.Bind" id="404920">bind</a>: <a href="#56288" title="Trees.this.Bind">Bind</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Name, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Name, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all binds support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait BindApi extends AnyRef with Trees.this.DefTreeApi" id="56292">BindApi</a> <span class="keyword">extends</span> <a href="#56208" title="Trees.this.DefTreeApi">DefTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Bind =&gt;
    /** The name that can be used to refer to this fragment of the matched expression.
     *  The `list` part of the `list @ List(x, y)`.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Name" id="404912">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>

    /** The pattern that represents this fragment of the matched expression.
     *  The `List(x, y)` part of the `list @ List(x, y)`.
     *  Is equal to `EmptyTree` if the pattern is not specified as in `case x =&gt; x`.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404913">body</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /**
   * Used to represent `unapply` methods in pattern matching.
   *
   *  For example:
   *  {{{
   *    2 match { case Foo(x) =&gt; x }
   *  }}}
   *
   *  Is represented as:
   *  {{{
   *    Match(
   *      Literal(Constant(2)),
   *      List(
   *        CaseDef(
   *          UnApply(
   *            // a dummy node that carries the type of unapplication to patmat
   *            // the &lt;unapply-selector&gt; here doesn't have an underlying symbol
   *            // it only has a type assigned, therefore after `resetAllAttrs` this tree is no longer typeable
   *            Apply(Select(Ident(Foo), newTermName(&quot;unapply&quot;)), List(Ident(newTermName(&quot;&lt;unapply-selector&gt;&quot;)))),
   *            // arguments of the unapply =&gt; nothing synthetic here
   *            List(Bind(newTermName(&quot;x&quot;), Ident(nme.WILDCARD)))),
   *          EmptyTree,
   *          Ident(newTermName(&quot;x&quot;)))))
   *  }}}
   *
   * Introduced by typer. Eliminated by compiler phases patmat (in the new pattern matcher of 2.10) or explicitouter (in the old pre-2.10 pattern matcher).
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.UnApplyApi" id="56293">UnApply</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> UnApplyApi

  /** A tag that preserves the identity of the `UnApply` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.UnApply]" id="56294">UnApplyTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.UnApply]">ClassTag</a><span class="delimiter">[</span>UnApply<span class="delimiter">]</span>

  /** The constructor/extractor for `UnApply` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.UnApplyExtractor" id="56295">UnApply</a>: <a href="#56296" title="Trees.this.UnApplyExtractor">UnApplyExtractor</a>

  /** An extractor class to create and pattern match with syntax `UnApply(fun, args)`.
   *  This AST node does not have direct correspondence to Scala code,
   *  and is introduced when typechecking pattern matches and `try` blocks.
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class UnApplyExtractor extends Object" id="56296">UnApplyExtractor</a> <a href="#56296" title="Trees.this.UnApplyExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(fun: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.UnApply" id="404931">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="404934">fun</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="404935">args</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56293" title="Trees.this.UnApply">UnApply</a>
    <span class="keyword">def</span> <a title="(unApply: Trees.this.UnApply)Option[(Trees.this.Tree, List[Trees.this.Tree])]" id="404932">unapply</a><span class="delimiter">(</span><a title="Trees.this.UnApply" id="404936">unApply</a>: <a href="#56293" title="Trees.this.UnApply">UnApply</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, List[Trees.this.Tree])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all unapplies support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait UnApplyApi extends AnyRef with Trees.this.TermTreeApi" id="56297">UnApplyApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: UnApply =&gt;
    /** A dummy node that carries the type of unapplication.
     *  See the example for [[scala.reflect.api.Trees#UnApplyExtractor]].
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404928">fun</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The arguments of the unapplication.
     *  See the example for [[scala.reflect.api.Trees#UnApplyExtractor]].
     */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.Tree]" id="404929">args</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** Anonymous function, eliminated by compiler phase lambdalift
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.SymTree with Trees.this.FunctionApi" id="56298">Function</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> SymTree <span class="keyword">with</span> FunctionApi

  /** A tag that preserves the identity of the `Function` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Function]" id="56299">FunctionTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Function]">ClassTag</a><span class="delimiter">[</span>Function<span class="delimiter">]</span>

  /** The constructor/extractor for `Function` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.FunctionExtractor" id="56300">Function</a>: <a href="#56301" title="Trees.this.FunctionExtractor">FunctionExtractor</a>

  /** An extractor class to create and pattern match with syntax `Function(vparams, body)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    vparams =&gt; body
   *
   *  The symbol of a Function is a synthetic TermSymbol.
   *  It is the owner of the function's parameters.
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class FunctionExtractor extends Object" id="56301">FunctionExtractor</a> <a href="#56301" title="Trees.this.FunctionExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(vparams: List[Trees.this.ValDef], body: Trees.this.Tree)Trees.this.Function" id="404947">apply</a><span class="delimiter">(</span><a title="List[Trees.this.ValDef]" id="404950">vparams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.ValDef]">List</a><span class="delimiter">[</span>ValDef<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="404951">body</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56298" title="Trees.this.Function">Function</a>
    <span class="keyword">def</span> <a title="(function: Trees.this.Function)Option[(List[Trees.this.ValDef], Trees.this.Tree)]" id="404948">unapply</a><span class="delimiter">(</span><a title="Trees.this.Function" id="404952">function</a>: <a href="#56298" title="Trees.this.Function">Function</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(List[Trees.this.ValDef], Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span>, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all functions support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait FunctionApi extends AnyRef with Trees.this.TermTreeApi with Trees.this.SymTreeApi" id="56302">FunctionApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="keyword">with</span> <a href="#56199" title="Trees.this.SymTreeApi">SymTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Function =&gt;
    /** The list of parameters of the function.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.ValDef]" id="404944">vparams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.ValDef]">List</a><span class="delimiter">[</span>ValDef<span class="delimiter">]</span>

    /** The body of the function.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404945">body</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Assignment
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.AssignApi" id="56303">Assign</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> AssignApi

  /** A tag that preserves the identity of the `Assign` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Assign]" id="56304">AssignTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Assign]">ClassTag</a><span class="delimiter">[</span>Assign<span class="delimiter">]</span>

  /** The constructor/extractor for `Assign` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.AssignExtractor" id="56305">Assign</a>: <a href="#56306" title="Trees.this.AssignExtractor">AssignExtractor</a>

  /** An extractor class to create and pattern match with syntax `Assign(lhs, rhs)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    lhs = rhs
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AssignExtractor extends Object" id="56306">AssignExtractor</a> <a href="#56306" title="Trees.this.AssignExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(lhs: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.Assign" id="404963">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="404966">lhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="404967">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56303" title="Trees.this.Assign">Assign</a>
    <span class="keyword">def</span> <a title="(assign: Trees.this.Assign)Option[(Trees.this.Tree, Trees.this.Tree)]" id="404964">unapply</a><span class="delimiter">(</span><a title="Trees.this.Assign" id="404968">assign</a>: <a href="#56303" title="Trees.this.Assign">Assign</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all assigns support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait AssignApi extends AnyRef with Trees.this.TermTreeApi" id="56307">AssignApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Assign =&gt;
    /** The left-hand side of the assignment.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404960">lhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The right-hand side of the assignment.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404961">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Either an assignment or a named argument. Only appears in argument lists,
   *  eliminated by compiler phase typecheck (doTypedApply), resurrected by reifier.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.AssignOrNamedArgApi" id="56308">AssignOrNamedArg</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> AssignOrNamedArgApi

  /** A tag that preserves the identity of the `AssignOrNamedArg` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.AssignOrNamedArg]" id="56309">AssignOrNamedArgTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.AssignOrNamedArg]">ClassTag</a><span class="delimiter">[</span>AssignOrNamedArg<span class="delimiter">]</span>

  /** The constructor/extractor for `AssignOrNamedArg` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.AssignOrNamedArgExtractor" id="56310">AssignOrNamedArg</a>: <a href="#56311" title="Trees.this.AssignOrNamedArgExtractor">AssignOrNamedArgExtractor</a>

  /** An extractor class to create and pattern match with syntax `AssignOrNamedArg(lhs, rhs)`.
   *  This AST node corresponds to the following Scala code:
   *
   *  {{{
   *    m.f(lhs = rhs)
   *  }}}
   *  {{{
   *    @annotation(lhs = rhs)
   *  }}}
   *
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AssignOrNamedArgExtractor extends Object" id="56311">AssignOrNamedArgExtractor</a> <a href="#56311" title="Trees.this.AssignOrNamedArgExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(lhs: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.AssignOrNamedArg" id="404979">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="404982">lhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="404983">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56308" title="Trees.this.AssignOrNamedArg">AssignOrNamedArg</a>
    <span class="keyword">def</span> <a title="(assignOrNamedArg: Trees.this.AssignOrNamedArg)Option[(Trees.this.Tree, Trees.this.Tree)]" id="404980">unapply</a><span class="delimiter">(</span><a title="Trees.this.AssignOrNamedArg" id="404984">assignOrNamedArg</a>: <a href="#56308" title="Trees.this.AssignOrNamedArg">AssignOrNamedArg</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all assigns support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait AssignOrNamedArgApi extends AnyRef with Trees.this.TermTreeApi" id="56312">AssignOrNamedArgApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: AssignOrNamedArg =&gt;
    /** The left-hand side of the expression.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404976">lhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The right-hand side of the expression.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404977">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Conditional expression
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.IfApi" id="56313">If</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> IfApi

  /** A tag that preserves the identity of the `If` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.If]" id="56314">IfTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.If]">ClassTag</a><span class="delimiter">[</span>If<span class="delimiter">]</span>

  /** The constructor/extractor for `If` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.IfExtractor" id="56315">If</a>: <a href="#56316" title="Trees.this.IfExtractor">IfExtractor</a>

  /** An extractor class to create and pattern match with syntax `If(cond, thenp, elsep)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `if` (cond) thenp `else` elsep
   *
   *  If the alternative is not present, the `elsep` is set to `Literal(Constant(()))`.
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class IfExtractor extends Object" id="56316">IfExtractor</a> <a href="#56316" title="Trees.this.IfExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(cond: Trees.this.Tree, thenp: Trees.this.Tree, elsep: Trees.this.Tree)Trees.this.If" id="404996">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="404999">cond</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405000">thenp</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405001">elsep</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56313" title="Trees.this.If">If</a>
    <span class="keyword">def</span> <a title="(if_: Trees.this.If)Option[(Trees.this.Tree, Trees.this.Tree, Trees.this.Tree)]" id="404997">unapply</a><span class="delimiter">(</span><a title="Trees.this.If" id="405002">if_</a> : <a href="#56313" title="Trees.this.If">If</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all ifs support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait IfApi extends AnyRef with Trees.this.TermTreeApi" id="56317">IfApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: If =&gt;
    /** The condition of the if.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404992">cond</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The main branch of the if.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404993">thenp</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The alternative of the if.
     *  Is equal to `Literal(Constant(()))` if not specified.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="404994">elsep</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** - Pattern matching expression  (before compiler phase explicitouter before 2.10 / patmat from 2.10)
   *  - Switch statements            (after compiler phase explicitouter before 2.10 / patmat from 2.10)
   *
   *  After compiler phase explicitouter before 2.10 / patmat from 2.10, cases will satisfy the following constraints:
   *
   *  - all guards are `EmptyTree`,
   *  - all patterns will be either `Literal(Constant(x:Int))`
   *    or `Alternative(lit|...|lit)`
   *  - except for an &quot;otherwise&quot; branch, which has pattern
   *    `Ident(nme.WILDCARD)`
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.MatchApi" id="56318">Match</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> MatchApi

  /** A tag that preserves the identity of the `Match` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Match]" id="56319">MatchTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Match]">ClassTag</a><span class="delimiter">[</span>Match<span class="delimiter">]</span>

  /** The constructor/extractor for `Match` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.MatchExtractor" id="56320">Match</a>: <a href="#56321" title="Trees.this.MatchExtractor">MatchExtractor</a>

  /** An extractor class to create and pattern match with syntax `Match(selector, cases)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    selector `match` { cases }
   *
   * `Match` is also used in pattern matching assignments like `val (foo, bar) = baz`.
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class MatchExtractor extends Object" id="56321">MatchExtractor</a> <a href="#56321" title="Trees.this.MatchExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(selector: Trees.this.Tree, cases: List[Trees.this.CaseDef])Trees.this.Match" id="405015">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405018">selector</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.CaseDef]" id="405019">cases</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56318" title="Trees.this.Match">Match</a>
    <span class="keyword">def</span> <a title="(match_: Trees.this.Match)Option[(Trees.this.Tree, List[Trees.this.CaseDef])]" id="405016">unapply</a><span class="delimiter">(</span><a title="Trees.this.Match" id="405020">match_</a> : <a href="#56318" title="Trees.this.Match">Match</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, List[Trees.this.CaseDef])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all matches support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait MatchApi extends AnyRef with Trees.this.TermTreeApi" id="56322">MatchApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Match =&gt;
    /** The scrutinee of the pattern match. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405012">selector</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The arms of the pattern match. */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.CaseDef]" id="405013">cases</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** Return expression
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.SymTree with Trees.this.ReturnApi" id="56323">Return</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> SymTree <span class="keyword">with</span> ReturnApi

  /** A tag that preserves the identity of the `Return` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Return]" id="56324">ReturnTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Return]">ClassTag</a><span class="delimiter">[</span>Return<span class="delimiter">]</span>

  /** The constructor/extractor for `Return` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.ReturnExtractor" id="56325">Return</a>: <a href="#56326" title="Trees.this.ReturnExtractor">ReturnExtractor</a>

  /** An extractor class to create and pattern match with syntax `Return(expr)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `return` expr
   *
   *  The symbol of a Return node is the enclosing method.
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ReturnExtractor extends Object" id="56326">ReturnExtractor</a> <a href="#56326" title="Trees.this.ReturnExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(expr: Trees.this.Tree)Trees.this.Return" id="405030">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405033">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56323" title="Trees.this.Return">Return</a>
    <span class="keyword">def</span> <a title="(return_: Trees.this.Return)Option[Trees.this.Tree]" id="405031">unapply</a><span class="delimiter">(</span><a title="Trees.this.Return" id="405034">return_</a> : <a href="#56323" title="Trees.this.Return">Return</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[Trees.this.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all returns support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ReturnApi extends AnyRef with Trees.this.TermTreeApi" id="56327">ReturnApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Return =&gt;
    /** The returned expression. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405028">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Try catch node
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.TryApi" id="56328">Try</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> TryApi

  /** A tag that preserves the identity of the `Try` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Try]" id="56329">TryTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Try]">ClassTag</a><span class="delimiter">[</span>Try<span class="delimiter">]</span>

  /** The constructor/extractor for `Try` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.TryExtractor" id="56330">Try</a>: <a href="#56331" title="Trees.this.TryExtractor">TryExtractor</a>

  /** An extractor class to create and pattern match with syntax `Try(block, catches, finalizer)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `try` block `catch` { catches } `finally` finalizer
   *
   *  If the finalizer is not present, the `finalizer` is set to `EmptyTree`.
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TryExtractor extends Object" id="56331">TryExtractor</a> <a href="#56331" title="Trees.this.TryExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(block: Trees.this.Tree, catches: List[Trees.this.CaseDef], finalizer: Trees.this.Tree)Trees.this.Try" id="405044">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405047">block</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.CaseDef]" id="405048">catches</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="405049">finalizer</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56328" title="Trees.this.Try">Try</a>
    <span class="keyword">def</span> <a title="(try_: Trees.this.Try)Option[(Trees.this.Tree, List[Trees.this.CaseDef], Trees.this.Tree)]" id="405045">unapply</a><span class="delimiter">(</span><a title="Trees.this.Try" id="405050">try_</a> : <a href="#56328" title="Trees.this.Try">Try</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, List[Trees.this.CaseDef], Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>CaseDef<span class="delimiter">]</span>, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all tries support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait TryApi extends AnyRef with Trees.this.TermTreeApi" id="56332">TryApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Try =&gt;
    /** The protected block. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405040">block</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The `catch` pattern-matching clauses of the try. */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.CaseDef]" id="405041">catches</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span>

    /** The `finally` part of the try. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405042">finalizer</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Throw expression
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.ThrowApi" id="56333">Throw</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> ThrowApi

  /** A tag that preserves the identity of the `Throw` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Throw]" id="56334">ThrowTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Throw]">ClassTag</a><span class="delimiter">[</span>Throw<span class="delimiter">]</span>

  /** The constructor/extractor for `Throw` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.ThrowExtractor" id="56335">Throw</a>: <a href="#56336" title="Trees.this.ThrowExtractor">ThrowExtractor</a>

  /** An extractor class to create and pattern match with syntax `Throw(expr)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `throw` expr
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ThrowExtractor extends Object" id="56336">ThrowExtractor</a> <a href="#56336" title="Trees.this.ThrowExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(expr: Trees.this.Tree)Trees.this.Throw" id="405062">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405065">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56333" title="Trees.this.Throw">Throw</a>
    <span class="keyword">def</span> <a title="(throw_: Trees.this.Throw)Option[Trees.this.Tree]" id="405063">unapply</a><span class="delimiter">(</span><a title="Trees.this.Throw" id="405066">throw_</a> : <a href="#56333" title="Trees.this.Throw">Throw</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[Trees.this.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all tries support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ThrowApi extends AnyRef with Trees.this.TermTreeApi" id="56337">ThrowApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Throw =&gt;
    /** The thrown expression. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405060">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Object instantiation
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.NewApi" id="56338">New</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> NewApi

  /** A tag that preserves the identity of the `New` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.New]" id="56339">NewTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.New]">ClassTag</a><span class="delimiter">[</span>New<span class="delimiter">]</span>

  /** The constructor/extractor for `New` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.NewExtractor" id="56340">New</a>: <a href="#56341" title="Trees.this.NewExtractor">NewExtractor</a>

  /** An extractor class to create and pattern match with syntax `New(tpt)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `new` T
   *
   *  This node always occurs in the following context:
   *
   *    (`new` tpt).&lt;init&gt;[targs](args)
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class NewExtractor extends Object" id="56341">NewExtractor</a> <a href="#56341" title="Trees.this.NewExtractor" class="delimiter">{</a>
    /** A user level `new`.
     *  One should always use this factory method to build a user level `new`.
     *
     *  @param tpt    a class type
     */
    <span class="keyword">def</span> <a title="(tpt: Trees.this.Tree)Trees.this.New" id="405074">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405077">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56338" title="Trees.this.New">New</a>
    <span class="keyword">def</span> <a title="(new_: Trees.this.New)Option[Trees.this.Tree]" id="405075">unapply</a><span class="delimiter">(</span><a title="Trees.this.New" id="405078">new_</a> : <a href="#56338" title="Trees.this.New">New</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[Trees.this.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all news support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait NewApi extends AnyRef with Trees.this.TermTreeApi" id="56342">NewApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: New =&gt;
    /** The tree that represents the type being instantiated.
     *  See the example for [[scala.reflect.api.Trees#NewExtractor]].
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405072">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Type annotation, eliminated by compiler phase cleanup
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.TypedApi" id="56343">Typed</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> TypedApi

  /** A tag that preserves the identity of the `Typed` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Typed]" id="56344">TypedTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Typed]">ClassTag</a><span class="delimiter">[</span>Typed<span class="delimiter">]</span>

  /** The constructor/extractor for `Typed` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.TypedExtractor" id="56345">Typed</a>: <a href="#56346" title="Trees.this.TypedExtractor">TypedExtractor</a>

  /** An extractor class to create and pattern match with syntax `Typed(expr, tpt)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    expr: tpt
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypedExtractor extends Object" id="56346">TypedExtractor</a> <a href="#56346" title="Trees.this.TypedExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(expr: Trees.this.Tree, tpt: Trees.this.Tree)Trees.this.Typed" id="405087">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405090">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405091">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56343" title="Trees.this.Typed">Typed</a>
    <span class="keyword">def</span> <a title="(typed: Trees.this.Typed)Option[(Trees.this.Tree, Trees.this.Tree)]" id="405088">unapply</a><span class="delimiter">(</span><a title="Trees.this.Typed" id="405092">typed</a>: <a href="#56343" title="Trees.this.Typed">Typed</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all typeds support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait TypedApi extends AnyRef with Trees.this.TermTreeApi" id="56347">TypedApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Typed =&gt;
    /** The expression being ascribed with the type. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405084">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The type being ascribed to the expression. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405085">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Common base class for Apply and TypeApply.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.GenericApplyApi" id="56348">GenericApply</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> GenericApplyApi

  /** A tag that preserves the identity of the `GenericApply` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.GenericApply]" id="56349">GenericApplyTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.GenericApply]">ClassTag</a><span class="delimiter">[</span>GenericApply<span class="delimiter">]</span>

  /** The API that all applies support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait GenericApplyApi extends AnyRef with Trees.this.TermTreeApi" id="56350">GenericApplyApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: GenericApply =&gt;
    /** The target of the application. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405100">fun</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The arguments of the application. */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.Tree]" id="405101">args</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /* @PP: All signs point toward it being a requirement that args.nonEmpty,
   *  but I can't find that explicitly stated anywhere.  Unless your last name
   *  is odersky, you should probably treat it as true.
   */
  /** Explicit type application.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.GenericApply with Trees.this.TypeApplyApi" id="56351">TypeApply</a> &gt;: Null &lt;: GenericApply <span class="keyword">with</span> TypeApplyApi

  /** A tag that preserves the identity of the `TypeApply` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.TypeApply]" id="56352">TypeApplyTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.TypeApply]">ClassTag</a><span class="delimiter">[</span>TypeApply<span class="delimiter">]</span>

  /** The constructor/extractor for `TypeApply` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.TypeApplyExtractor" id="56353">TypeApply</a>: <a href="#56354" title="Trees.this.TypeApplyExtractor">TypeApplyExtractor</a>

  /** An extractor class to create and pattern match with syntax `TypeApply(fun, args)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    fun[args]
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeApplyExtractor extends Object" id="56354">TypeApplyExtractor</a> <a href="#56354" title="Trees.this.TypeApplyExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(fun: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.TypeApply" id="405110">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405113">fun</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="405114">args</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56351" title="Trees.this.TypeApply">TypeApply</a>
    <span class="keyword">def</span> <a title="(typeApply: Trees.this.TypeApply)Option[(Trees.this.Tree, List[Trees.this.Tree])]" id="405111">unapply</a><span class="delimiter">(</span><a title="Trees.this.TypeApply" id="405115">typeApply</a>: <a href="#56351" title="Trees.this.TypeApply">TypeApply</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, List[Trees.this.Tree])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all type applies support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait TypeApplyApi extends AnyRef with Trees.this.GenericApplyApi" id="56355">TypeApplyApi</a> <span class="keyword">extends</span> <a href="#56350" title="Trees.this.GenericApplyApi">GenericApplyApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: TypeApply =&gt;
  <span class="delimiter">}</span>

  /** Value application
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.GenericApply with Trees.this.ApplyApi" id="56356">Apply</a> &gt;: Null &lt;: GenericApply <span class="keyword">with</span> ApplyApi

  /** A tag that preserves the identity of the `Apply` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Apply]" id="56357">ApplyTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Apply]">ClassTag</a><span class="delimiter">[</span>Apply<span class="delimiter">]</span>

  /** The constructor/extractor for `Apply` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.ApplyExtractor" id="56358">Apply</a>: <a href="#56359" title="Trees.this.ApplyExtractor">ApplyExtractor</a>

  /** An extractor class to create and pattern match with syntax `Apply(fun, args)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    fun(args)
   *
   *  For instance:
   *
   *    fun[targs](args)
   *
   *  Is expressed as:
   *
   *    Apply(TypeApply(fun, targs), args)
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ApplyExtractor extends Object" id="56359">ApplyExtractor</a> <a href="#56359" title="Trees.this.ApplyExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(fun: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.Apply" id="405120">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405123">fun</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="405124">args</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56356" title="Trees.this.Apply">Apply</a>
    <span class="keyword">def</span> <a title="(apply: Trees.this.Apply)Option[(Trees.this.Tree, List[Trees.this.Tree])]" id="405121">unapply</a><span class="delimiter">(</span><a title="Trees.this.Apply" id="405125">apply</a>: <a href="#56356" title="Trees.this.Apply">Apply</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, List[Trees.this.Tree])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all applies support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ApplyApi extends AnyRef with Trees.this.GenericApplyApi" id="56360">ApplyApi</a> <span class="keyword">extends</span> <a href="#56350" title="Trees.this.GenericApplyApi">GenericApplyApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Apply =&gt;
  <span class="delimiter">}</span>

  /** Super reference, where `qual` is the corresponding `this` reference.
   *  A super reference `C.super[M]` is represented as `Super(This(C), M)`.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.SuperApi" id="56361">Super</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> SuperApi

  /** A tag that preserves the identity of the `Super` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Super]" id="56362">SuperTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Super]">ClassTag</a><span class="delimiter">[</span>Super<span class="delimiter">]</span>

  /** The constructor/extractor for `Super` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.SuperExtractor" id="56363">Super</a>: <a href="#56364" title="Trees.this.SuperExtractor">SuperExtractor</a>

  /** An extractor class to create and pattern match with syntax `Super(qual, mix)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    C.super[M]
   *
   *  Which is represented as:
   *
   *    Super(This(C), M)
   *
   *  If `mix` is empty, it is tpnme.EMPTY.
   *
   *  The symbol of a Super is the class _from_ which the super reference is made.
   *  For instance in C.super(...), it would be C.
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SuperExtractor extends Object" id="56364">SuperExtractor</a> <a href="#56364" title="Trees.this.SuperExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(qual: Trees.this.Tree, mix: Trees.this.TypeName)Trees.this.Super" id="405132">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405135">qual</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.TypeName" id="405136">mix</a>: <a href="Names.scala.html#56177" title="Trees.this.TypeName">TypeName</a><span class="delimiter">)</span>: <a href="#56361" title="Trees.this.Super">Super</a>
    <span class="keyword">def</span> <a title="(super_: Trees.this.Super)Option[(Trees.this.Tree, Trees.this.TypeName)]" id="405133">unapply</a><span class="delimiter">(</span><a title="Trees.this.Super" id="405137">super_</a> : <a href="#56361" title="Trees.this.Super">Super</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, Trees.this.TypeName)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, TypeName<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all supers support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait SuperApi extends AnyRef with Trees.this.TermTreeApi" id="56365">SuperApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Super =&gt;
    /** The qualifier of the `super` expression.
     *  See the example for [[scala.reflect.api.Trees#SuperExtractor]].
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405129">qual</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The selector of the `super` expression.
     *  See the example for [[scala.reflect.api.Trees#SuperExtractor]].
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.TypeName" id="405130">mix</a>: <a href="Names.scala.html#56177" title="Trees.this.TypeName">TypeName</a>
  <span class="delimiter">}</span>

  /** Self reference
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.SymTree with Trees.this.ThisApi" id="56366">This</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> SymTree <span class="keyword">with</span> ThisApi

  /** A tag that preserves the identity of the `This` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.This]" id="56367">ThisTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.This]">ClassTag</a><span class="delimiter">[</span>This<span class="delimiter">]</span>

  /** The constructor/extractor for `This` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.ThisExtractor" id="56368">This</a>: <a href="#56369" title="Trees.this.ThisExtractor">ThisExtractor</a>

  /** An extractor class to create and pattern match with syntax `This(qual)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    qual.this
   *
   *  The symbol of a This is the class to which the this refers.
   *  For instance in C.this, it would be C.
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ThisExtractor extends Object" id="56369">ThisExtractor</a> <a href="#56369" title="Trees.this.ThisExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(qual: Trees.this.TypeName)Trees.this.This" id="405147">apply</a><span class="delimiter">(</span><a title="Trees.this.TypeName" id="405150">qual</a>: <a href="Names.scala.html#56177" title="Trees.this.TypeName">TypeName</a><span class="delimiter">)</span>: <a href="#56366" title="Trees.this.This">This</a>
    <span class="keyword">def</span> <a title="(this_: Trees.this.This)Option[Trees.this.TypeName]" id="405148">unapply</a><span class="delimiter">(</span><a title="Trees.this.This" id="405151">this_</a> : <a href="#56366" title="Trees.this.This">This</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[Trees.this.TypeName]">Option</a><span class="delimiter">[</span>TypeName<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all thises support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ThisApi extends AnyRef with Trees.this.TermTreeApi with Trees.this.SymTreeApi" id="56370">ThisApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="keyword">with</span> <a href="#56199" title="Trees.this.SymTreeApi">SymTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: This =&gt;
    /** The qualifier of the `this` expression.
     *  For an unqualified `this` refers to the enclosing class.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.TypeName" id="405145">qual</a>: <a href="Names.scala.html#56177" title="Trees.this.TypeName">TypeName</a>
  <span class="delimiter">}</span>

  /** A member selection &lt;qualifier&gt; . &lt;name&gt;
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.RefTree with Trees.this.SelectApi" id="56371">Select</a> &gt;: Null &lt;: RefTree <span class="keyword">with</span> SelectApi

  /** A tag that preserves the identity of the `Select` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Select]" id="56372">SelectTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Select]">ClassTag</a><span class="delimiter">[</span>Select<span class="delimiter">]</span>

  /** The constructor/extractor for `Select` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.SelectExtractor" id="56373">Select</a>: <a href="#56374" title="Trees.this.SelectExtractor">SelectExtractor</a>

  /** An extractor class to create and pattern match with syntax `Select(qual, name)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    qualifier.selector
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SelectExtractor extends Object" id="56374">SelectExtractor</a> <a href="#56374" title="Trees.this.SelectExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(qualifier: Trees.this.Tree, name: Trees.this.Name)Trees.this.Select" id="405156">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405159">qualifier</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="405160">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#56371" title="Trees.this.Select">Select</a>
    <span class="keyword">def</span> <a title="(select: Trees.this.Select)Option[(Trees.this.Tree, Trees.this.Name)]" id="405157">unapply</a><span class="delimiter">(</span><a title="Trees.this.Select" id="405161">select</a>: <a href="#56371" title="Trees.this.Select">Select</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, Trees.this.Name)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Name<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all selects support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait SelectApi extends AnyRef with Trees.this.RefTreeApi" id="56375">SelectApi</a> <span class="keyword">extends</span> <a href="#56205" title="Trees.this.RefTreeApi">RefTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Select =&gt;
    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="402675">qualifier</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Name" id="402676">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>
  <span class="delimiter">}</span>

  /** A reference to identifier `name`.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.RefTree with Trees.this.IdentApi" id="56376">Ident</a> &gt;: Null &lt;: RefTree <span class="keyword">with</span> IdentApi

  /** A tag that preserves the identity of the `Ident` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Ident]" id="56377">IdentTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Ident]">ClassTag</a><span class="delimiter">[</span>Ident<span class="delimiter">]</span>

  /** The constructor/extractor for `Ident` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.IdentExtractor" id="56378">Ident</a>: <a href="#56379" title="Trees.this.IdentExtractor">IdentExtractor</a>

  /** An extractor class to create and pattern match with syntax `Ident(qual, name)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    name
   *
   *  Type checker converts idents that refer to enclosing fields or methods to selects.
   *  For example, name ==&gt; this.name
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class IdentExtractor extends Object" id="56379">IdentExtractor</a> <a href="#56379" title="Trees.this.IdentExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(name: Trees.this.Name)Trees.this.Ident" id="405168">apply</a><span class="delimiter">(</span><a title="Trees.this.Name" id="405171">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#56376" title="Trees.this.Ident">Ident</a>
    <span class="keyword">def</span> <a title="(ident: Trees.this.Ident)Option[Trees.this.Name]" id="405169">unapply</a><span class="delimiter">(</span><a title="Trees.this.Ident" id="405172">ident</a>: <a href="#56376" title="Trees.this.Ident">Ident</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[Trees.this.Name]">Option</a><span class="delimiter">[</span>Name<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all idents support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait IdentApi extends AnyRef with Trees.this.RefTreeApi" id="56380">IdentApi</a> <span class="keyword">extends</span> <a href="#56205" title="Trees.this.RefTreeApi">RefTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Ident =&gt;
    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Name" id="402684">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>
  <span class="delimiter">}</span>

  /** Marks underlying reference to id as boxed.
   *
   *  &lt;b&gt;Precondition:&lt;\b&gt; id must refer to a captured variable
   *  A reference such marked will refer to the boxed entity, no dereferencing
   *  with `.elem` is done on it.
   *  This tree node can be emitted by macros such as reify that call referenceCapturedVariable.
   *  It is eliminated in LambdaLift, where the boxing conversion takes place.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.ReferenceToBoxedApi" id="56381">ReferenceToBoxed</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> ReferenceToBoxedApi

  /** A tag that preserves the identity of the `ReferenceToBoxed` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.ReferenceToBoxed]" id="56382">ReferenceToBoxedTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.ReferenceToBoxed]">ClassTag</a><span class="delimiter">[</span>ReferenceToBoxed<span class="delimiter">]</span>

  /** The constructor/extractor for `ReferenceToBoxed` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.ReferenceToBoxedExtractor" id="56383">ReferenceToBoxed</a>: <a href="#56384" title="Trees.this.ReferenceToBoxedExtractor">ReferenceToBoxedExtractor</a>

  /** An extractor class to create and pattern match with syntax `ReferenceToBoxed(ident)`.
   *  This AST node does not have direct correspondence to Scala code,
   *  and is emitted by macros to reference capture vars directly without going through `elem`.
   *
   *  For example:
   *
   *    var x = ...
   *    fun { x }
   *
   *  Will emit:
   *
   *    Ident(x)
   *
   *  Which gets transformed to:
   *
   *    Select(Ident(x), &quot;elem&quot;)
   *
   *  If `ReferenceToBoxed` were used instead of Ident, no transformation would be performed.
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ReferenceToBoxedExtractor extends Object" id="56384">ReferenceToBoxedExtractor</a> <a href="#56384" title="Trees.this.ReferenceToBoxedExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(ident: Trees.this.Ident)Trees.this.ReferenceToBoxed" id="405180">apply</a><span class="delimiter">(</span><a title="Trees.this.Ident" id="405183">ident</a>: <a href="#56376" title="Trees.this.Ident">Ident</a><span class="delimiter">)</span>: <a href="#56381" title="Trees.this.ReferenceToBoxed">ReferenceToBoxed</a>
    <span class="keyword">def</span> <a title="(referenceToBoxed: Trees.this.ReferenceToBoxed)Option[Trees.this.Ident]" id="405181">unapply</a><span class="delimiter">(</span><a title="Trees.this.ReferenceToBoxed" id="405184">referenceToBoxed</a>: <a href="#56381" title="Trees.this.ReferenceToBoxed">ReferenceToBoxed</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[Trees.this.Ident]">Option</a><span class="delimiter">[</span>Ident<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all references support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ReferenceToBoxedApi extends AnyRef with Trees.this.TermTreeApi" id="56385">ReferenceToBoxedApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: ReferenceToBoxed =&gt;
    /** The underlying reference. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405178">ident</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Literal
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TermTree with Trees.this.LiteralApi" id="56386">Literal</a> &gt;: Null &lt;: TermTree <span class="keyword">with</span> LiteralApi

  /** A tag that preserves the identity of the `Literal` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Literal]" id="56387">LiteralTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Literal]">ClassTag</a><span class="delimiter">[</span>Literal<span class="delimiter">]</span>

  /** The constructor/extractor for `Literal` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.LiteralExtractor" id="56388">Literal</a>: <a href="#56389" title="Trees.this.LiteralExtractor">LiteralExtractor</a>

  /** An extractor class to create and pattern match with syntax `Literal(value)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    value
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class LiteralExtractor extends Object" id="56389">LiteralExtractor</a> <a href="#56389" title="Trees.this.LiteralExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(value: Trees.this.Constant)Trees.this.Literal" id="405192">apply</a><span class="delimiter">(</span><a title="Trees.this.Constant" id="405195">value</a>: <a href="Constants.scala.html#56484" title="Trees.this.Constant">Constant</a><span class="delimiter">)</span>: <a href="#56386" title="Trees.this.Literal">Literal</a>
    <span class="keyword">def</span> <a title="(literal: Trees.this.Literal)Option[Trees.this.Constant]" id="405193">unapply</a><span class="delimiter">(</span><a title="Trees.this.Literal" id="405197">literal</a>: <a href="#56386" title="Trees.this.Literal">Literal</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[Trees.this.Constant]">Option</a><span class="delimiter">[</span>Constant<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all literals support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait LiteralApi extends AnyRef with Trees.this.TermTreeApi" id="56390">LiteralApi</a> <span class="keyword">extends</span> <a href="#56193" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Literal =&gt;
    /** The compile-time constant underlying the literal. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Constant" id="405190">value</a>: <a href="Constants.scala.html#56484" title="Trees.this.Constant">Constant</a>
  <span class="delimiter">}</span>

  /** A tree that has an annotation attached to it. Only used for annotated types and
   *  annotation ascriptions, annotations on definitions are stored in the Modifiers.
   *  Eliminated by typechecker (typedAnnotated), the annotations are then stored in
   *  an AnnotatedType.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.Tree with Trees.this.AnnotatedApi" id="56391">Annotated</a> &gt;: Null &lt;: AnyRef <span class="keyword">with</span> Tree <span class="keyword">with</span> AnnotatedApi

  /** A tag that preserves the identity of the `Annotated` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Annotated]" id="56392">AnnotatedTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Annotated]">ClassTag</a><span class="delimiter">[</span>Annotated<span class="delimiter">]</span>

  /** The constructor/extractor for `Annotated` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.AnnotatedExtractor" id="56393">Annotated</a>: <a href="#56394" title="Trees.this.AnnotatedExtractor">AnnotatedExtractor</a>

  /** An extractor class to create and pattern match with syntax `Annotated(annot, arg)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    arg @annot    // for types
   *    arg: @annot   // for exprs
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AnnotatedExtractor extends Object" id="56394">AnnotatedExtractor</a> <a href="#56394" title="Trees.this.AnnotatedExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(annot: Trees.this.Tree, arg: Trees.this.Tree)Trees.this.Annotated" id="405207">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405210">annot</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405211">arg</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56391" title="Trees.this.Annotated">Annotated</a>
    <span class="keyword">def</span> <a title="(annotated: Trees.this.Annotated)Option[(Trees.this.Tree, Trees.this.Tree)]" id="405208">unapply</a><span class="delimiter">(</span><a title="Trees.this.Annotated" id="405212">annotated</a>: <a href="#56391" title="Trees.this.Annotated">Annotated</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all annotateds support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait AnnotatedApi extends AnyRef with Trees.this.TreeApi" id="56395">AnnotatedApi</a> <span class="keyword">extends</span> <a href="#56188" title="Trees.this.TreeApi">TreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: Annotated =&gt;
    /** The annotation. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405204">annot</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The annotee. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405205">arg</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Singleton type, eliminated by RefCheck
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TypTree with Trees.this.SingletonTypeTreeApi" id="56396">SingletonTypeTree</a> &gt;: Null &lt;: TypTree <span class="keyword">with</span> SingletonTypeTreeApi

  /** A tag that preserves the identity of the `SingletonTypeTree` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.SingletonTypeTree]" id="56397">SingletonTypeTreeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.SingletonTypeTree]">ClassTag</a><span class="delimiter">[</span>SingletonTypeTree<span class="delimiter">]</span>

  /** The constructor/extractor for `SingletonTypeTree` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.SingletonTypeTreeExtractor" id="56398">SingletonTypeTree</a>: <a href="#56399" title="Trees.this.SingletonTypeTreeExtractor">SingletonTypeTreeExtractor</a>

  /** An extractor class to create and pattern match with syntax `SingletonTypeTree(ref)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    ref.type
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SingletonTypeTreeExtractor extends Object" id="56399">SingletonTypeTreeExtractor</a> <a href="#56399" title="Trees.this.SingletonTypeTreeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(ref: Trees.this.Tree)Trees.this.SingletonTypeTree" id="405222">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405225">ref</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56396" title="Trees.this.SingletonTypeTree">SingletonTypeTree</a>
    <span class="keyword">def</span> <a title="(singletonTypeTree: Trees.this.SingletonTypeTree)Option[Trees.this.Tree]" id="405223">unapply</a><span class="delimiter">(</span><a title="Trees.this.SingletonTypeTree" id="405226">singletonTypeTree</a>: <a href="#56396" title="Trees.this.SingletonTypeTree">SingletonTypeTree</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[Trees.this.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all singleton type trees support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait SingletonTypeTreeApi extends AnyRef with Trees.this.TypTreeApi" id="56400">SingletonTypeTreeApi</a> <span class="keyword">extends</span> <a href="#56196" title="Trees.this.TypTreeApi">TypTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: SingletonTypeTree =&gt;
    /** The underlying reference. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405220">ref</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Type selection &lt;qualifier&gt; # &lt;name&gt;, eliminated by RefCheck
   *  @group Trees
   *  @template
   */
  // [Eugene++] don't see why we need it, when we have Select
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TypTree with Trees.this.RefTree with Trees.this.SelectFromTypeTreeApi" id="56401">SelectFromTypeTree</a> &gt;: Null &lt;: TypTree <span class="keyword">with</span> RefTree <span class="keyword">with</span> SelectFromTypeTreeApi

  /** A tag that preserves the identity of the `SelectFromTypeTree` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.SelectFromTypeTree]" id="56402">SelectFromTypeTreeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.SelectFromTypeTree]">ClassTag</a><span class="delimiter">[</span>SelectFromTypeTree<span class="delimiter">]</span>

  /** The constructor/extractor for `SelectFromTypeTree` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.SelectFromTypeTreeExtractor" id="56403">SelectFromTypeTree</a>: <a href="#56404" title="Trees.this.SelectFromTypeTreeExtractor">SelectFromTypeTreeExtractor</a>

  /** An extractor class to create and pattern match with syntax `SelectFromTypeTree(qualifier, name)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    qualifier # selector
   *
   *  Note: a path-dependent type p.T is expressed as p.type # T
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SelectFromTypeTreeExtractor extends Object" id="56404">SelectFromTypeTreeExtractor</a> <a href="#56404" title="Trees.this.SelectFromTypeTreeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(qualifier: Trees.this.Tree, name: Trees.this.TypeName)Trees.this.SelectFromTypeTree" id="405235">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405238">qualifier</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.TypeName" id="405239">name</a>: <a href="Names.scala.html#56177" title="Trees.this.TypeName">TypeName</a><span class="delimiter">)</span>: <a href="#56401" title="Trees.this.SelectFromTypeTree">SelectFromTypeTree</a>
    <span class="keyword">def</span> <a title="(selectFromTypeTree: Trees.this.SelectFromTypeTree)Option[(Trees.this.Tree, Trees.this.TypeName)]" id="405236">unapply</a><span class="delimiter">(</span><a title="Trees.this.SelectFromTypeTree" id="405240">selectFromTypeTree</a>: <a href="#56401" title="Trees.this.SelectFromTypeTree">SelectFromTypeTree</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, Trees.this.TypeName)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, TypeName<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all selects from type trees support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait SelectFromTypeTreeApi extends AnyRef with Trees.this.TypTreeApi with Trees.this.RefTreeApi" id="56405">SelectFromTypeTreeApi</a> <span class="keyword">extends</span> <a href="#56196" title="Trees.this.TypTreeApi">TypTreeApi</a> <span class="keyword">with</span> <a href="#56205" title="Trees.this.RefTreeApi">RefTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: SelectFromTypeTree =&gt;
    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405232">qualifier</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** @inheritdoc */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.TypeName" id="405233">name</a>: <a href="Names.scala.html#56177" title="Trees.this.TypeName">TypeName</a>
  <span class="delimiter">}</span>

  /** Intersection type &lt;parent1&gt; with ... with &lt;parentN&gt; { &lt;decls&gt; }, eliminated by RefCheck
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TypTree with Trees.this.CompoundTypeTreeApi" id="56406">CompoundTypeTree</a> &gt;: Null &lt;: TypTree <span class="keyword">with</span> CompoundTypeTreeApi

  /** A tag that preserves the identity of the `CompoundTypeTree` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.CompoundTypeTree]" id="56407">CompoundTypeTreeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.CompoundTypeTree]">ClassTag</a><span class="delimiter">[</span>CompoundTypeTree<span class="delimiter">]</span>

  /** The constructor/extractor for `CompoundTypeTree` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.CompoundTypeTreeExtractor" id="56408">CompoundTypeTree</a>: <a href="#56409" title="Trees.this.CompoundTypeTreeExtractor">CompoundTypeTreeExtractor</a>

  /** An extractor class to create and pattern match with syntax `CompoundTypeTree(templ)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    parent1 with ... with parentN { refinement }
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class CompoundTypeTreeExtractor extends Object" id="56409">CompoundTypeTreeExtractor</a> <a href="#56409" title="Trees.this.CompoundTypeTreeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(templ: Trees.this.Template)Trees.this.CompoundTypeTree" id="405250">apply</a><span class="delimiter">(</span><a title="Trees.this.Template" id="405253">templ</a>: <a href="#56263" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#56406" title="Trees.this.CompoundTypeTree">CompoundTypeTree</a>
    <span class="keyword">def</span> <a title="(compoundTypeTree: Trees.this.CompoundTypeTree)Option[Trees.this.Template]" id="405251">unapply</a><span class="delimiter">(</span><a title="Trees.this.CompoundTypeTree" id="405254">compoundTypeTree</a>: <a href="#56406" title="Trees.this.CompoundTypeTree">CompoundTypeTree</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[Trees.this.Template]">Option</a><span class="delimiter">[</span>Template<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all compound type trees support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait CompoundTypeTreeApi extends AnyRef with Trees.this.TypTreeApi" id="56410">CompoundTypeTreeApi</a> <span class="keyword">extends</span> <a href="#56196" title="Trees.this.TypTreeApi">TypTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: CompoundTypeTree =&gt;
    /** The template of the compound type - represents the parents, the optional self-type and the optional definitions. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Template" id="405248">templ</a>: <a href="#56263" title="Trees.this.Template">Template</a>
  <span class="delimiter">}</span>

  /** Applied type &lt;tpt&gt; [ &lt;args&gt; ], eliminated by RefCheck
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TypTree with Trees.this.AppliedTypeTreeApi" id="56411">AppliedTypeTree</a> &gt;: Null &lt;: TypTree <span class="keyword">with</span> AppliedTypeTreeApi

  /** A tag that preserves the identity of the `AppliedTypeTree` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.AppliedTypeTree]" id="56412">AppliedTypeTreeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.AppliedTypeTree]">ClassTag</a><span class="delimiter">[</span>AppliedTypeTree<span class="delimiter">]</span>

  /** The constructor/extractor for `AppliedTypeTree` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.AppliedTypeTreeExtractor" id="56413">AppliedTypeTree</a>: <a href="#56414" title="Trees.this.AppliedTypeTreeExtractor">AppliedTypeTreeExtractor</a>

  /** An extractor class to create and pattern match with syntax `AppliedTypeTree(tpt, args)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    tpt[args]
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AppliedTypeTreeExtractor extends Object" id="56414">AppliedTypeTreeExtractor</a> <a href="#56414" title="Trees.this.AppliedTypeTreeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(tpt: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.AppliedTypeTree" id="405263">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405266">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="405267">args</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56411" title="Trees.this.AppliedTypeTree">AppliedTypeTree</a>
    <span class="keyword">def</span> <a title="(appliedTypeTree: Trees.this.AppliedTypeTree)Option[(Trees.this.Tree, List[Trees.this.Tree])]" id="405264">unapply</a><span class="delimiter">(</span><a title="Trees.this.AppliedTypeTree" id="405268">appliedTypeTree</a>: <a href="#56411" title="Trees.this.AppliedTypeTree">AppliedTypeTree</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, List[Trees.this.Tree])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all applied type trees support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait AppliedTypeTreeApi extends AnyRef with Trees.this.TypTreeApi" id="56415">AppliedTypeTreeApi</a> <span class="keyword">extends</span> <a href="#56196" title="Trees.this.TypTreeApi">TypTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: AppliedTypeTree =&gt;
    /** The target of the application. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405260">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The arguments of the application. */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.Tree]" id="405261">args</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** Type bounds tree node
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TypTree with Trees.this.TypeBoundsTreeApi" id="56416">TypeBoundsTree</a> &gt;: Null &lt;: TypTree <span class="keyword">with</span> TypeBoundsTreeApi

  /** A tag that preserves the identity of the `TypeBoundsTree` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.TypeBoundsTree]" id="56417">TypeBoundsTreeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.TypeBoundsTree]">ClassTag</a><span class="delimiter">[</span>TypeBoundsTree<span class="delimiter">]</span>

  /** The constructor/extractor for `TypeBoundsTree` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.TypeBoundsTreeExtractor" id="56418">TypeBoundsTree</a>: <a href="#56419" title="Trees.this.TypeBoundsTreeExtractor">TypeBoundsTreeExtractor</a>

  /** An extractor class to create and pattern match with syntax `TypeBoundsTree(lo, hi)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    &gt;: lo &lt;: hi
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeBoundsTreeExtractor extends Object" id="56419">TypeBoundsTreeExtractor</a> <a href="#56419" title="Trees.this.TypeBoundsTreeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(lo: Trees.this.Tree, hi: Trees.this.Tree)Trees.this.TypeBoundsTree" id="405279">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405282">lo</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405283">hi</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56416" title="Trees.this.TypeBoundsTree">TypeBoundsTree</a>
    <span class="keyword">def</span> <a title="(typeBoundsTree: Trees.this.TypeBoundsTree)Option[(Trees.this.Tree, Trees.this.Tree)]" id="405280">unapply</a><span class="delimiter">(</span><a title="Trees.this.TypeBoundsTree" id="405284">typeBoundsTree</a>: <a href="#56416" title="Trees.this.TypeBoundsTree">TypeBoundsTree</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all type bound trees support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait TypeBoundsTreeApi extends AnyRef with Trees.this.TypTreeApi" id="56420">TypeBoundsTreeApi</a> <span class="keyword">extends</span> <a href="#56196" title="Trees.this.TypTreeApi">TypTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: TypeBoundsTree =&gt;
    /** The lower bound.
     *  Is equal to `Ident(&lt;scala.Nothing&gt;)` if not specified explicitly.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405276">lo</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The upper bound.
     *  Is equal to `Ident(&lt;scala.Any&gt;)` if not specified explicitly.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405277">hi</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** Existential type tree node
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TypTree with Trees.this.ExistentialTypeTreeApi" id="56421">ExistentialTypeTree</a> &gt;: Null &lt;: TypTree <span class="keyword">with</span> ExistentialTypeTreeApi

  /** A tag that preserves the identity of the `ExistentialTypeTree` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.ExistentialTypeTree]" id="56422">ExistentialTypeTreeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.ExistentialTypeTree]">ClassTag</a><span class="delimiter">[</span>ExistentialTypeTree<span class="delimiter">]</span>

  /** The constructor/extractor for `ExistentialTypeTree` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.ExistentialTypeTreeExtractor" id="56423">ExistentialTypeTree</a>: <a href="#56424" title="Trees.this.ExistentialTypeTreeExtractor">ExistentialTypeTreeExtractor</a>

  /** An extractor class to create and pattern match with syntax `ExistentialTypeTree(tpt, whereClauses)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    tpt forSome { whereClauses }
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ExistentialTypeTreeExtractor extends Object" id="56424">ExistentialTypeTreeExtractor</a> <a href="#56424" title="Trees.this.ExistentialTypeTreeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="(tpt: Trees.this.Tree, whereClauses: List[Trees.this.Tree])Trees.this.ExistentialTypeTree" id="405295">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405298">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="405299">whereClauses</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56421" title="Trees.this.ExistentialTypeTree">ExistentialTypeTree</a>
    <span class="keyword">def</span> <a title="(existentialTypeTree: Trees.this.ExistentialTypeTree)Option[(Trees.this.Tree, List[Trees.this.Tree])]" id="405296">unapply</a><span class="delimiter">(</span><a title="Trees.this.ExistentialTypeTree" id="405300">existentialTypeTree</a>: <a href="#56421" title="Trees.this.ExistentialTypeTree">ExistentialTypeTree</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#978" title="Option[(Trees.this.Tree, List[Trees.this.Tree])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API that all existential type trees support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ExistentialTypeTreeApi extends AnyRef with Trees.this.TypTreeApi" id="56425">ExistentialTypeTreeApi</a> <span class="keyword">extends</span> <a href="#56196" title="Trees.this.TypTreeApi">TypTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: ExistentialTypeTree =&gt;
    /** The underlying type of the existential type. */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="405292">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>

    /** The clauses of the definition of the existential type. */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.Tree]" id="405293">whereClauses</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** A synthetic tree holding an arbitrary type.  Not to be confused with
   *  with TypTree, the trait for trees that are only used for type trees.
   *  TypeTree's are inserted in several places, but most notably in
   *  `RefCheck`, where the arbitrary type trees are all replaced by
   *  TypeTree's.
   *  @group Trees
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.TypTree with Trees.this.TypeTreeApi" id="56426">TypeTree</a> &gt;: Null &lt;: TypTree <span class="keyword">with</span> TypeTreeApi

  /** A tag that preserves the identity of the `TypeTree` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.TypeTree]" id="56427">TypeTreeTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.TypeTree]">ClassTag</a><span class="delimiter">[</span>TypeTree<span class="delimiter">]</span>

  /** The constructor/extractor for `TypeTree` instances.
   *  @group Extractors
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.TypeTreeExtractor" id="56428">TypeTree</a>: <a href="#56429" title="Trees.this.TypeTreeExtractor">TypeTreeExtractor</a>

  /** An extractor class to create and pattern match with syntax `TypeTree()`.
   *  This AST node does not have direct correspondence to Scala code,
   *  and is emitted by everywhere when we want to wrap a `Type` in a `Tree`.
   *  @group Extractors
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TypeTreeExtractor extends Object" id="56429">TypeTreeExtractor</a> <a href="#56429" title="Trees.this.TypeTreeExtractor" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="()Trees.this.TypeTree" id="405307">apply</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#56426" title="Trees.this.TypeTree">TypeTree</a>
    <span class="keyword">def</span> <a title="(typeTree: Trees.this.TypeTree)Boolean" id="405308">unapply</a><span class="delimiter">(</span><a title="Trees.this.TypeTree" id="405310">typeTree</a>: <a href="#56426" title="Trees.this.TypeTree">TypeTree</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>
  <span class="delimiter">}</span>

  /** The API that all type trees support
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait TypeTreeApi extends AnyRef with Trees.this.TypTreeApi" id="56430">TypeTreeApi</a> <span class="keyword">extends</span> <a href="#56196" title="Trees.this.TypTreeApi">TypTreeApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: TypeTree =&gt;
    /** The precursor of this tree.
     *  Is equal to `EmptyTree` if this type tree doesn't have precursors.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Tree" id="402694">original</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  /** An empty deferred value definition corresponding to:
   *    val _: _
   *  This is used as a placeholder in the `self` parameter Template if there is
   *  no definition of a self value of self type.
   *  @group Trees
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.ValDef" id="56431">emptyValDef</a>: <a href="#56233" title="Trees.this.ValDef">ValDef</a>

// ---------------------- factories ----------------------------------------------

  /** A factory method for `ClassDef` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol, impl: Trees.this.Template)Trees.this.ClassDef" id="56432">ClassDef</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405314">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Template" id="405315">impl</a>: <a href="#56263" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#56220" title="Trees.this.ClassDef">ClassDef</a>

  /** A factory method for `ModuleDef` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol, impl: Trees.this.Template)Trees.this.ModuleDef" id="56433">ModuleDef</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405316">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Template" id="405317">impl</a>: <a href="#56263" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#56225" title="Trees.this.ModuleDef">ModuleDef</a>

  /** A factory method for `ValDef` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol, rhs: Trees.this.Tree)Trees.this.ValDef" id="56434">ValDef</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405318">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Tree" id="405319">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56233" title="Trees.this.ValDef">ValDef</a>

  /** A factory method for `ValDef` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol)Trees.this.ValDef" id="56435">ValDef</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405320">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#56233" title="Trees.this.ValDef">ValDef</a>

  /** A factory method for `ValDef` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol, mods: Trees.this.Modifiers, vparamss: List[List[Trees.this.ValDef]], rhs: Trees.this.Tree)Trees.this.DefDef" id="56436">DefDef</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405321">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Modifiers" id="405322">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>, <a title="List[List[Trees.this.ValDef]]" id="405323">vparamss</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[List[Trees.this.ValDef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Trees.this.Tree" id="405324">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56238" title="Trees.this.DefDef">DefDef</a>

  /** A factory method for `ValDef` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol, vparamss: List[List[Trees.this.ValDef]], rhs: Trees.this.Tree)Trees.this.DefDef" id="56437">DefDef</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405325">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="List[List[Trees.this.ValDef]]" id="405326">vparamss</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[List[Trees.this.ValDef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Trees.this.Tree" id="405327">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56238" title="Trees.this.DefDef">DefDef</a>

  /** A factory method for `ValDef` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol, mods: Trees.this.Modifiers, rhs: Trees.this.Tree)Trees.this.DefDef" id="56438">DefDef</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405328">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Modifiers" id="405329">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.Tree" id="405330">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56238" title="Trees.this.DefDef">DefDef</a>

  /** A factory method for `ValDef` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol, rhs: Trees.this.Tree)Trees.this.DefDef" id="56439">DefDef</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405331">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Tree" id="405332">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56238" title="Trees.this.DefDef">DefDef</a>

  /** A factory method for `ValDef` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol, rhs: List[List[Trees.this.Symbol]] =&gt; Trees.this.Tree)Trees.this.DefDef" id="56440">DefDef</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405333">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="List[List[Trees.this.Symbol]] =&gt; Trees.this.Tree" id="405334">rhs</a>: List<span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> =&gt; Tree<span class="delimiter">)</span>: <a href="#56238" title="Trees.this.DefDef">DefDef</a>

  /** A factory method for `TypeDef` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol, rhs: Trees.this.Tree)Trees.this.TypeDef" id="56441">TypeDef</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405335">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Tree" id="405336">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56243" title="Trees.this.TypeDef">TypeDef</a>

  /** A factory method for `TypeDef` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol)Trees.this.TypeDef" id="56442">TypeDef</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405337">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#56243" title="Trees.this.TypeDef">TypeDef</a>

  /** A factory method for `LabelDef` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol, params: List[Trees.this.Symbol], rhs: Trees.this.Tree)Trees.this.LabelDef" id="56443">LabelDef</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405338">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="List[Trees.this.Symbol]" id="405339">params</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="405340">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56248" title="Trees.this.LabelDef">LabelDef</a>

  /** A factory method for `Block` nodes.
   *  Flattens directly nested blocks.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(stats: Trees.this.Tree*)Trees.this.Block" id="56444">Block</a><span class="delimiter">(</span><a title="Trees.this.Tree*" id="405341">stats</a>: <span title="Trees.this.Tree*">Tree</span>*<span class="delimiter">)</span>: <a href="#56268" title="Trees.this.Block">Block</a>

  /** A factory method for `CaseDef` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(pat: Trees.this.Tree, body: Trees.this.Tree)Trees.this.CaseDef" id="56445">CaseDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405342">pat</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405343">body</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56273" title="Trees.this.CaseDef">CaseDef</a>

  /** A factory method for `Bind` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol, body: Trees.this.Tree)Trees.this.Bind" id="56446">Bind</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405344">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Tree" id="405345">body</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56288" title="Trees.this.Bind">Bind</a>

  /** A factory method for `Try` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(body: Trees.this.Tree, cases: (Trees.this.Tree, Trees.this.Tree)*)Trees.this.Try" id="56447">Try</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405346">body</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="(Trees.this.Tree, Trees.this.Tree)*" id="405347">cases</a>: <span title="(Trees.this.Tree, Trees.this.Tree)*" class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span>*<span class="delimiter">)</span>: <a href="#56328" title="Trees.this.Try">Try</a>

  /** A factory method for `Throw` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(tpe: Trees.this.Type, args: Trees.this.Tree*)Trees.this.Throw" id="56448">Throw</a><span class="delimiter">(</span><a title="Trees.this.Type" id="405348">tpe</a>: <a href="Types.scala.html#56063" title="Trees.this.Type">Type</a>, <a title="Trees.this.Tree*" id="405349">args</a>: <span title="Trees.this.Tree*">Tree</span>*<span class="delimiter">)</span>: <a href="#56333" title="Trees.this.Throw">Throw</a>

  /** Factory method for object creation `new tpt(args_1)...(args_n)`
   *  A `New(t, as)` is expanded to: `(new t).&lt;init&gt;(as)`
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(tpt: Trees.this.Tree, argss: List[List[Trees.this.Tree]])Trees.this.Tree" id="56449">New</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405350">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[List[Trees.this.Tree]]" id="405351">argss</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[List[Trees.this.Tree]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56186" title="Trees.this.Tree">Tree</a>

  /** 0-1 argument list new, based on a type.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(tpe: Trees.this.Type, args: Trees.this.Tree*)Trees.this.Tree" id="56450">New</a><span class="delimiter">(</span><a title="Trees.this.Type" id="405352">tpe</a>: <a href="Types.scala.html#56063" title="Trees.this.Type">Type</a>, <a title="Trees.this.Tree*" id="405353">args</a>: <span title="Trees.this.Tree*">Tree</span>*<span class="delimiter">)</span>: <a href="#56186" title="Trees.this.Tree">Tree</a>

  /** 0-1 argument list new, based on a symbol.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol, args: Trees.this.Tree*)Trees.this.Tree" id="56451">New</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405354">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Tree*" id="405355">args</a>: <span title="Trees.this.Tree*">Tree</span>*<span class="delimiter">)</span>: <a href="#56186" title="Trees.this.Tree">Tree</a>

  /** A factory method for `Apply` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol, args: Trees.this.Tree*)Trees.this.Tree" id="56452">Apply</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405356">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Tree*" id="405357">args</a>: <span title="Trees.this.Tree*">Tree</span>*<span class="delimiter">)</span>: <a href="#56186" title="Trees.this.Tree">Tree</a>

  /** 0-1 argument list new, based on a type tree.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(tpt: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.Tree" id="56453">ApplyConstructor</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405358">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="405359">args</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56186" title="Trees.this.Tree">Tree</a>

  /** A factory method for `Super` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol, mix: Trees.this.TypeName)Trees.this.Tree" id="56454">Super</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405360">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.TypeName" id="405361">mix</a>: <a href="Names.scala.html#56177" title="Trees.this.TypeName">TypeName</a><span class="delimiter">)</span>: <a href="#56186" title="Trees.this.Tree">Tree</a>

  /** A factory method for `This` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol)Trees.this.Tree" id="56455">This</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405362">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#56186" title="Trees.this.Tree">Tree</a>

  /** A factory method for `Select` nodes.
   *  The string `name` argument is assumed to represent a [[scala.reflect.api.Names#TermName `TermName`]].
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(qualifier: Trees.this.Tree, name: String)Trees.this.Select" id="56456">Select</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405363">qualifier</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="String" id="405364">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#56371" title="Trees.this.Select">Select</a>

  /** A factory method for `Select` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(qualifier: Trees.this.Tree, sym: Trees.this.Symbol)Trees.this.Select" id="56457">Select</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405365">qualifier</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Symbol" id="405366">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#56371" title="Trees.this.Select">Select</a>

  /** A factory method for `Ident` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(name: String)Trees.this.Ident" id="56458">Ident</a><span class="delimiter">(</span><a title="String" id="405367">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#56376" title="Trees.this.Ident">Ident</a>

  /** A factory method for `Ident` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol)Trees.this.Ident" id="56459">Ident</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405368">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#56376" title="Trees.this.Ident">Ident</a>

  /** A factory method for `TypeTree` nodes.
   *  @group Factories
   */
  <span class="keyword">def</span> <a title="(tp: Trees.this.Type)Trees.this.TypeTree" id="56460">TypeTree</a><span class="delimiter">(</span><a title="Trees.this.Type" id="405369">tp</a>: <a href="Types.scala.html#56063" title="Trees.this.Type">Type</a><span class="delimiter">)</span>: <a href="#56426" title="Trees.this.TypeTree">TypeTree</a>

// ---------------------- copying ------------------------------------------------

  /** The type of standard (lazy) tree copiers.
   *  @template
   *  @group Copying
   */
  <span class="keyword">type</span> <a title=" &lt;: Trees.this.TreeCopierOps" id="56461">TreeCopier</a> &lt;: TreeCopierOps

  /** The standard (lazy) tree copier.
   *  @group Copying
   */
  <span class="keyword">val</span> <a title="Trees.this.TreeCopier" id="56462">treeCopy</a>: <a href="#56461" title="Trees.this.TreeCopier">TreeCopier</a> = <a href="#56465" title="=&gt; Trees.this.TreeCopier">newLazyTreeCopier</a>

  /** Creates a strict tree copier.
   *  @group Copying
   */
  <span class="keyword">def</span> <a title="=&gt; Trees.this.TreeCopier" id="56464">newStrictTreeCopier</a>: <a href="#56461" title="Trees.this.TreeCopier">TreeCopier</a>

  /** Creates a lazy tree copier.
   *  @group Copying
   */
  <span class="keyword">def</span> <a title="=&gt; Trees.this.TreeCopier" id="56465">newLazyTreeCopier</a>: <a href="#56461" title="Trees.this.TreeCopier">TreeCopier</a>

  /** The API of a tree copier.
   *  @group API
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TreeCopierOps extends Object" id="56466">TreeCopierOps</a> <a href="#56466" title="Trees.this.TreeCopierOps" class="delimiter">{</a>
    /** Creates a `ClassDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, mods: Trees.this.Modifiers, name: Trees.this.Name, tparams: List[Trees.this.TypeDef], impl: Trees.this.Template)Trees.this.ClassDef" id="405371">ClassDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405413">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Modifiers" id="405414">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.Name" id="405415">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>, <a title="List[Trees.this.TypeDef]" id="405416">tparams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, <a title="Trees.this.Template" id="405417">impl</a>: <a href="#56263" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#56220" title="Trees.this.ClassDef">ClassDef</a>

    /** Creates a `PackageDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, pid: Trees.this.RefTree, stats: List[Trees.this.Tree])Trees.this.PackageDef" id="405372">PackageDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405418">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.RefTree" id="405419">pid</a>: <a href="#56203" title="Trees.this.RefTree">RefTree</a>, <a title="List[Trees.this.Tree]" id="405420">stats</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56212" title="Trees.this.PackageDef">PackageDef</a>

    /** Creates a `ModuleDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, mods: Trees.this.Modifiers, name: Trees.this.Name, impl: Trees.this.Template)Trees.this.ModuleDef" id="405373">ModuleDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405421">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Modifiers" id="405422">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.Name" id="405423">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>, <a title="Trees.this.Template" id="405424">impl</a>: <a href="#56263" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#56225" title="Trees.this.ModuleDef">ModuleDef</a>

    /** Creates a `ValDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, mods: Trees.this.Modifiers, name: Trees.this.Name, tpt: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.ValDef" id="405374">ValDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405425">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Modifiers" id="405426">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.Name" id="405427">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>, <a title="Trees.this.Tree" id="405428">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405429">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56233" title="Trees.this.ValDef">ValDef</a>

    /** Creates a `DefDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, mods: Trees.this.Modifiers, name: Trees.this.Name, tparams: List[Trees.this.TypeDef], vparamss: List[List[Trees.this.ValDef]], tpt: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.DefDef" id="405375">DefDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405430">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Modifiers" id="405431">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.Name" id="405432">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>, <a title="List[Trees.this.TypeDef]" id="405433">tparams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, <a title="List[List[Trees.this.ValDef]]" id="405434">vparamss</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[List[Trees.this.ValDef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Trees.this.Tree" id="405435">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405436">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56238" title="Trees.this.DefDef">DefDef</a>

    /** Creates a `TypeDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, mods: Trees.this.Modifiers, name: Trees.this.Name, tparams: List[Trees.this.TypeDef], rhs: Trees.this.Tree)Trees.this.TypeDef" id="405376">TypeDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405437">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Modifiers" id="405438">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.Name" id="405439">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>, <a title="List[Trees.this.TypeDef]" id="405440">tparams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="405441">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56243" title="Trees.this.TypeDef">TypeDef</a>

    /** Creates a `LabelDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, name: Trees.this.Name, params: List[Trees.this.Ident], rhs: Trees.this.Tree)Trees.this.LabelDef" id="405377">LabelDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405442">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="405443">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>, <a title="List[Trees.this.Ident]" id="405444">params</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Ident]">List</a><span class="delimiter">[</span>Ident<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="405445">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56248" title="Trees.this.LabelDef">LabelDef</a>

    /** Creates a `Import` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, expr: Trees.this.Tree, selectors: List[Trees.this.ImportSelector])Trees.this.Import" id="405378">Import</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405446">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405447">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.ImportSelector]" id="405448">selectors</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.ImportSelector]">List</a><span class="delimiter">[</span>ImportSelector<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56258" title="Trees.this.Import">Import</a>

    /** Creates a `Template` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, parents: List[Trees.this.Tree], self: Trees.this.ValDef, body: List[Trees.this.Tree])Trees.this.Template" id="405379">Template</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405449">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="405450">parents</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="Trees.this.ValDef" id="405451">self</a>: <a href="#56233" title="Trees.this.ValDef">ValDef</a>, <a title="List[Trees.this.Tree]" id="405452">body</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56263" title="Trees.this.Template">Template</a>

    /** Creates a `Block` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, stats: List[Trees.this.Tree], expr: Trees.this.Tree)Trees.this.Block" id="405380">Block</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405453">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="405454">stats</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="405455">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56268" title="Trees.this.Block">Block</a>

    /** Creates a `CaseDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, pat: Trees.this.Tree, guard: Trees.this.Tree, body: Trees.this.Tree)Trees.this.CaseDef" id="405381">CaseDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405456">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405457">pat</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405458">guard</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405459">body</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56273" title="Trees.this.CaseDef">CaseDef</a>

    /** Creates a `Alternative` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, trees: List[Trees.this.Tree])Trees.this.Alternative" id="405382">Alternative</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405460">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="405461">trees</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56278" title="Trees.this.Alternative">Alternative</a>

    /** Creates a `Star` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, elem: Trees.this.Tree)Trees.this.Star" id="405383">Star</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405462">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405463">elem</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56283" title="Trees.this.Star">Star</a>

    /** Creates a `Bind` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, name: Trees.this.Name, body: Trees.this.Tree)Trees.this.Bind" id="405384">Bind</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405464">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="405465">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>, <a title="Trees.this.Tree" id="405466">body</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56288" title="Trees.this.Bind">Bind</a>

    /** Creates a `UnApply` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, fun: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.UnApply" id="405385">UnApply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405467">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405468">fun</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="405469">args</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56293" title="Trees.this.UnApply">UnApply</a>

    /** Creates a `Function` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, vparams: List[Trees.this.ValDef], body: Trees.this.Tree)Trees.this.Function" id="405386">Function</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405470">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.ValDef]" id="405471">vparams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.ValDef]">List</a><span class="delimiter">[</span>ValDef<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="405472">body</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56298" title="Trees.this.Function">Function</a>

    /** Creates a `Assign` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, lhs: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.Assign" id="405387">Assign</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405473">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405474">lhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405475">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56303" title="Trees.this.Assign">Assign</a>

    /** Creates a `AssignOrNamedArg` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, lhs: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.AssignOrNamedArg" id="405388">AssignOrNamedArg</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405476">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405477">lhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405478">rhs</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56308" title="Trees.this.AssignOrNamedArg">AssignOrNamedArg</a>

    /** Creates a `If` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, cond: Trees.this.Tree, thenp: Trees.this.Tree, elsep: Trees.this.Tree)Trees.this.If" id="405389">If</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405479">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405480">cond</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405481">thenp</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405482">elsep</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56313" title="Trees.this.If">If</a>

    /** Creates a `Match` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, selector: Trees.this.Tree, cases: List[Trees.this.CaseDef])Trees.this.Match" id="405390">Match</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405483">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405484">selector</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.CaseDef]" id="405485">cases</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56318" title="Trees.this.Match">Match</a>

    /** Creates a `Return` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, expr: Trees.this.Tree)Trees.this.Return" id="405391">Return</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405486">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405487">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56323" title="Trees.this.Return">Return</a>

    /** Creates a `Try` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, block: Trees.this.Tree, catches: List[Trees.this.CaseDef], finalizer: Trees.this.Tree)Trees.this.Try" id="405392">Try</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405488">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405489">block</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.CaseDef]" id="405490">catches</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="405491">finalizer</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56328" title="Trees.this.Try">Try</a>

    /** Creates a `Throw` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, expr: Trees.this.Tree)Trees.this.Throw" id="405393">Throw</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405492">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405493">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56333" title="Trees.this.Throw">Throw</a>

    /** Creates a `New` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, tpt: Trees.this.Tree)Trees.this.New" id="405394">New</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405494">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405495">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56338" title="Trees.this.New">New</a>

    /** Creates a `Typed` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, expr: Trees.this.Tree, tpt: Trees.this.Tree)Trees.this.Typed" id="405395">Typed</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405496">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405497">expr</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405498">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56343" title="Trees.this.Typed">Typed</a>

    /** Creates a `TypeApply` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, fun: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.TypeApply" id="405396">TypeApply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405499">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405500">fun</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="405501">args</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56351" title="Trees.this.TypeApply">TypeApply</a>

    /** Creates a `Apply` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, fun: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.Apply" id="405397">Apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405502">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405503">fun</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="405504">args</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56356" title="Trees.this.Apply">Apply</a>

    /** Creates a `Super` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, qual: Trees.this.Tree, mix: Trees.this.TypeName)Trees.this.Super" id="405398">Super</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405505">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405506">qual</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.TypeName" id="405507">mix</a>: <a href="Names.scala.html#56177" title="Trees.this.TypeName">TypeName</a><span class="delimiter">)</span>: <a href="#56361" title="Trees.this.Super">Super</a>

    /** Creates a `This` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, qual: Trees.this.Name)Trees.this.This" id="405399">This</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405508">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="405509">qual</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#56366" title="Trees.this.This">This</a>

    /** Creates a `Select` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, qualifier: Trees.this.Tree, selector: Trees.this.Name)Trees.this.Select" id="405400">Select</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405510">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405511">qualifier</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="405512">selector</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#56371" title="Trees.this.Select">Select</a>

    /** Creates a `Ident` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, name: Trees.this.Name)Trees.this.Ident" id="405401">Ident</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405513">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="405514">name</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#56376" title="Trees.this.Ident">Ident</a>

    /** Creates a `ReferenceToBoxed` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, idt: Trees.this.Ident)Trees.this.ReferenceToBoxed" id="405402">ReferenceToBoxed</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405515">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Ident" id="405516">idt</a>: <a href="#56376" title="Trees.this.Ident">Ident</a><span class="delimiter">)</span>: <a href="#56381" title="Trees.this.ReferenceToBoxed">ReferenceToBoxed</a>

    /** Creates a `Literal` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, value: Trees.this.Constant)Trees.this.Literal" id="405403">Literal</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405517">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Constant" id="405518">value</a>: <a href="Constants.scala.html#56484" title="Trees.this.Constant">Constant</a><span class="delimiter">)</span>: <a href="#56386" title="Trees.this.Literal">Literal</a>

    /** Creates a `TypeTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree)Trees.this.TypeTree" id="405404">TypeTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405520">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56426" title="Trees.this.TypeTree">TypeTree</a>

    /** Creates a `Annotated` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, annot: Trees.this.Tree, arg: Trees.this.Tree)Trees.this.Annotated" id="405405">Annotated</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405521">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405522">annot</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405523">arg</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56391" title="Trees.this.Annotated">Annotated</a>

    /** Creates a `SingletonTypeTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, ref: Trees.this.Tree)Trees.this.SingletonTypeTree" id="405406">SingletonTypeTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405524">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405525">ref</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56396" title="Trees.this.SingletonTypeTree">SingletonTypeTree</a>

    /** Creates a `SelectFromTypeTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, qualifier: Trees.this.Tree, selector: Trees.this.Name)Trees.this.SelectFromTypeTree" id="405407">SelectFromTypeTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405526">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405527">qualifier</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="405528">selector</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#56401" title="Trees.this.SelectFromTypeTree">SelectFromTypeTree</a>

    /** Creates a `CompoundTypeTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, templ: Trees.this.Template)Trees.this.CompoundTypeTree" id="405408">CompoundTypeTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405529">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Template" id="405530">templ</a>: <a href="#56263" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#56406" title="Trees.this.CompoundTypeTree">CompoundTypeTree</a>

    /** Creates a `AppliedTypeTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, tpt: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.AppliedTypeTree" id="405409">AppliedTypeTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405531">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405532">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="405533">args</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56411" title="Trees.this.AppliedTypeTree">AppliedTypeTree</a>

    /** Creates a `TypeBoundsTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, lo: Trees.this.Tree, hi: Trees.this.Tree)Trees.this.TypeBoundsTree" id="405410">TypeBoundsTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405534">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405535">lo</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405536">hi</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56416" title="Trees.this.TypeBoundsTree">TypeBoundsTree</a>

    /** Creates a `ExistentialTypeTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree, tpt: Trees.this.Tree, whereClauses: List[Trees.this.Tree])Trees.this.ExistentialTypeTree" id="405411">ExistentialTypeTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405537">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="405538">tpt</a>: <a href="#56186" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="405539">whereClauses</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56421" title="Trees.this.ExistentialTypeTree">ExistentialTypeTree</a>
  <span class="delimiter">}</span>

// ---------------------- traversing and transforming ------------------------------

  /** A class that implement a default tree traversal strategy: breadth-first component-wise.
   *  @group Traversal
   */
  <span class="keyword">class</span> <a title="class Traverser extends Object" id="56467">Traverser</a> <a href="#56467" title="Trees.this.Traverser" class="delimiter">{</a>
    <span class="keyword">protected</span><span class="delimiter">[</span>scala<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Trees.this.Symbol" id="405542">currentOwner</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a> = <a href="Mirrors.scala.html#56588" title="=&gt; Trees.this.Mirror">rootMirror</a>.<a href="Mirror.scala.html#402739" title="=&gt; Trees.this.ClassSymbol">RootClass</a>

    /** Traverses a single tree. */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree)Unit" id="405544">traverse</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405560">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#1515" title="Unit">Unit</a> = <a href="#56468" title="(traverser: Trees.this.Traverser, tree: Trees.this.Tree)Unit">itraverse</a><span class="delimiter">(</span><a href="#56467" title="Trees.this.Traverser" class="keyword">this</a>, <a href="#405560" title="Trees.this.Tree">tree</a><span class="delimiter">)</span>

    /** Traverses a list of trees. */
    <span class="keyword">def</span> <a title="(trees: List[Trees.this.Tree])Unit" id="405545">traverseTrees</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="405563">trees</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#405563" title="List[Trees.this.Tree]">trees</a> <a href="../../collection/immutable/List.scala.html#62719" title="(f: Trees.this.Tree =&gt; Unit)Unit">foreach</a> <a href="#405544" title="(tree: Trees.this.Tree)Unit">traverse</a>
    <span class="delimiter">}</span>

    /** Traverses a list of lists of trees. */
    <span class="keyword">def</span> <a title="(treess: List[List[Trees.this.Tree]])Unit" id="405546">traverseTreess</a><span class="delimiter">(</span><a title="List[List[Trees.this.Tree]]" id="405586">treess</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[List[Trees.this.Tree]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#405586" title="List[List[Trees.this.Tree]]">treess</a> <a href="../../collection/immutable/List.scala.html#62719" title="(f: List[Trees.this.Tree] =&gt; Unit)Unit">foreach</a> <a href="#405545" title="(trees: List[Trees.this.Tree])Unit">traverseTrees</a>
    <span class="delimiter">}</span>

    /** Traverses a list of trees with a given owner symbol. */
    <span class="keyword">def</span> <a title="(stats: List[Trees.this.Tree], exprOwner: Trees.this.Symbol)Unit" id="405547">traverseStats</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="405609">stats</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="Trees.this.Symbol" id="405610">exprOwner</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#405609" title="List[Trees.this.Tree]">stats</a> <a href="../../collection/immutable/List.scala.html#62719" title="(f: Trees.this.Tree =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a title="Trees.this.Tree" id="405631">stat</a> =&gt;
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#405610" title="Trees.this.Symbol">exprOwner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#405542" title="=&gt; Trees.this.Symbol">currentOwner</a><span class="delimiter">)</span> <a href="#405548" title="(owner: Trees.this.Symbol)(traverse: =&gt; Unit)Unit">atOwner</a><span class="delimiter">(</span><a href="#405610" title="Trees.this.Symbol">exprOwner</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#405544" title="(tree: Trees.this.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#405631" title="Trees.this.Tree">stat</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#405544" title="(tree: Trees.this.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#405631" title="Trees.this.Tree">stat</a><span class="delimiter">)</span>
      <span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Performs a traversal with a given owner symbol. */
    <span class="keyword">def</span> <a title="(owner: Trees.this.Symbol)(traverse: =&gt; Unit)Unit" id="405548">atOwner</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405636">owner</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; Unit" id="405637">traverse</a>: =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Trees.this.Symbol" id="405639">prevOwner</a> = <a href="#405542" title="=&gt; Trees.this.Symbol">currentOwner</a>
      <a href="#405542" title="(x$1: Trees.this.Symbol)Unit">currentOwner</a> = <a href="#405636" title="Trees.this.Symbol">owner</a>
      <a href="#405637" title="=&gt; Unit">traverse</a>
      <a href="#405542" title="(x$1: Trees.this.Symbol)Unit">currentOwner</a> = <a href="#405639" title="Trees.this.Symbol">prevOwner</a>
    <span class="delimiter">}</span>

    /** Leave apply available in the generic traverser to do something else.
     */
    <span class="keyword">def</span> <a title="[T &lt;: Trees.this.Tree](tree: T)T" id="405549">apply</a><span class="delimiter">[</span><a title=" &lt;: Trees.this.Tree" id="405551">T</a> &lt;: Tree<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="405640">tree</a>: <a href="#405551" title="T">T</a><span class="delimiter">)</span>: <a href="#405551" title="T">T</a> = <span class="delimiter">{</span> <a href="#405544" title="(tree: Trees.this.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#405640" title="T">tree</a><span class="delimiter">)</span>; <a href="#405640" title="T">tree</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Delegates the traversal strategy to `scala.reflect.internal.Trees`,
   *  because pattern matching on abstract types we have here degrades performance.
   *  @group Traversal
   */
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(traverser: Trees.this.Traverser, tree: Trees.this.Tree)Unit" id="56468">itraverse</a><span class="delimiter">(</span><a title="Trees.this.Traverser" id="405561">traverser</a>: <a href="#56467" title="Trees.this.Traverser">Traverser</a>, <a title="Trees.this.Tree" id="405562">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#1515" title="Unit">Unit</a> = <span title="Nothing" class="keyword">throw</span> <span title="MatchError" class="keyword">new</span> <a href="../../MatchError.scala.html#441" title="MatchError">MatchError</a><span class="delimiter">(</span><a href="#405562" title="Trees.this.Tree">tree</a><span class="delimiter">)</span>

  /** Provides an extension hook for the traversal strategy.
   *  Future-proofs against new node types.
   *  @group Traversal
   */
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(traverser: Trees.this.Traverser, tree: Trees.this.Tree)Unit" id="56469">xtraverse</a><span class="delimiter">(</span><a title="Trees.this.Traverser" id="405642">traverser</a>: <a href="#56467" title="Trees.this.Traverser">Traverser</a>, <a title="Trees.this.Tree" id="405643">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#1515" title="Unit">Unit</a> = <span title="Nothing" class="keyword">throw</span> <span title="MatchError" class="keyword">new</span> <a href="../../MatchError.scala.html#441" title="MatchError">MatchError</a><span class="delimiter">(</span><a href="#405643" title="Trees.this.Tree">tree</a><span class="delimiter">)</span>

  /** A class that implement a default tree transformation strategy: breadth-first component-wise cloning.
   *  @group Traversal
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Transformer extends Object" id="56470">Transformer</a> <a href="#56470" title="Trees.this.Transformer" class="delimiter">{</a>
    /** The underlying tree copier. */
    <span class="keyword">val</span> <a title="Trees.this.TreeCopier" id="405645">treeCopy</a>: <a href="#56461" title="Trees.this.TreeCopier">TreeCopier</a> = <a href="#56465" title="=&gt; Trees.this.TreeCopier">newLazyTreeCopier</a>

    /** The current owner symbol. */
    <span class="keyword">protected</span><span class="delimiter">[</span>scala<span class="delimiter">]</span> <span class="keyword">var</span> <a title="Trees.this.Symbol" id="405648">currentOwner</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a> = <a href="Mirrors.scala.html#56588" title="=&gt; Trees.this.Mirror">rootMirror</a>.<a href="Mirror.scala.html#402739" title="=&gt; Trees.this.ClassSymbol">RootClass</a>

    /** The enclosing method of the currently transformed tree. */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Trees.this.Symbol" id="405650">currentMethod</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol)Trees.this.Symbol" id="405672">enclosingMethod</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405673">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a> =
        <span title="Trees.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#405673" title="Trees.this.Symbol">sym</a>.<a href="Symbols.scala.html#402398" title="=&gt; Boolean">isMethod</a> <a href="../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="#405673" title="Trees.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#56048" title="=&gt; Trees.this.Symbol">NoSymbol</a><span class="delimiter">)</span> <a href="#405673" title="Trees.this.Symbol">sym</a> <span class="keyword">else</span> <a href="#405672" title="(sym: Trees.this.Symbol)Trees.this.Symbol">enclosingMethod</a><span class="delimiter">(</span><a href="#405673" title="Trees.this.Symbol">sym</a>.<a href="Symbols.scala.html#402390" title="=&gt; Trees.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#405672" title="(sym: Trees.this.Symbol)Trees.this.Symbol">enclosingMethod</a><span class="delimiter">(</span><a href="#405648" title="=&gt; Trees.this.Symbol">currentOwner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** The enclosing class of the currently transformed tree. */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Trees.this.Symbol" id="405651">currentClass</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(sym: Trees.this.Symbol)Trees.this.Symbol" id="405678">enclosingClass</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405679">sym</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a> =
        <span title="Trees.this.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#405679" title="Trees.this.Symbol">sym</a>.<a href="Symbols.scala.html#402403" title="=&gt; Boolean">isClass</a> <a href="../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="#405679" title="Trees.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Symbols.scala.html#56048" title="=&gt; Trees.this.Symbol">NoSymbol</a><span class="delimiter">)</span> <a href="#405679" title="Trees.this.Symbol">sym</a> <span class="keyword">else</span> <a href="#405678" title="(sym: Trees.this.Symbol)Trees.this.Symbol">enclosingClass</a><span class="delimiter">(</span><a href="#405679" title="Trees.this.Symbol">sym</a>.<a href="Symbols.scala.html#402390" title="=&gt; Trees.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#405678" title="(sym: Trees.this.Symbol)Trees.this.Symbol">enclosingClass</a><span class="delimiter">(</span><a href="#405648" title="=&gt; Trees.this.Symbol">currentOwner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

//    protected def currentPackage = currentOwner.enclosingTopLevelClass.owner

    /** Transforms a single tree. */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Tree)Trees.this.Tree" id="405652">transform</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="405684">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56186" title="Trees.this.Tree">Tree</a> = <a href="#56471" title="(transformer: Trees.this.Transformer, tree: Trees.this.Tree)Trees.this.Tree">itransform</a><span class="delimiter">(</span><a href="#56470" title="Trees.this.Transformer" class="keyword">this</a>, <a href="#405684" title="Trees.this.Tree">tree</a><span class="delimiter">)</span>

    /** Transforms a list of trees. */
    <span class="keyword">def</span> <a title="(trees: List[Trees.this.Tree])List[Trees.this.Tree]" id="405653">transformTrees</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="405687">trees</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> = <a href="#405687" title="List[Trees.this.Tree]">trees</a> <a href="../../collection/immutable/List.scala.html#62694" title="(f: Trees.this.Tree =&gt; Trees.this.Tree)List[Trees.this.Tree]">mapConserve</a> <span class="delimiter">(</span><a href="#405652" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#405694" title="Trees.this.Tree">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

    /** Transforms a `Template`. */
    <span class="keyword">def</span> <a title="(tree: Trees.this.Template)Trees.this.Template" id="405654">transformTemplate</a><span class="delimiter">(</span><a title="Trees.this.Template" id="405696">tree</a>: <a href="#56263" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#56263" title="Trees.this.Template">Template</a> =
      <a href="#405652" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#405696" title="Trees.this.Template">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Trees.this.Template" class="delimiter">[</span><a href="#56263" title="Trees.this.Template">Template</a><span class="delimiter">]</span>
    /** Transforms a list of `TypeDef` trees. */
    <span class="keyword">def</span> <a title="(trees: List[Trees.this.TypeDef])List[Trees.this.TypeDef]" id="405655">transformTypeDefs</a><span class="delimiter">(</span><a title="List[Trees.this.TypeDef]" id="405697">trees</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span> =
      <a href="#405697" title="List[Trees.this.TypeDef]">trees</a> <a href="../../collection/immutable/List.scala.html#62694" title="(f: Trees.this.TypeDef =&gt; Trees.this.TypeDef)List[Trees.this.TypeDef]">mapConserve</a> <span class="delimiter">(</span><a title="Trees.this.TypeDef" id="405704">tree</a> =&gt; <a href="#405652" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#405704" title="Trees.this.TypeDef">tree</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Trees.this.TypeDef" class="delimiter">[</span><a href="#56243" title="Trees.this.TypeDef">TypeDef</a><span class="delimiter">]</span><span class="delimiter">)</span>
    /** Transforms a `ValDef`. */
    <span class="keyword">def</span> <a title="(tree: Trees.this.ValDef)Trees.this.ValDef" id="405656">transformValDef</a><span class="delimiter">(</span><a title="Trees.this.ValDef" id="405706">tree</a>: <a href="#56233" title="Trees.this.ValDef">ValDef</a><span class="delimiter">)</span>: <a href="#56233" title="Trees.this.ValDef">ValDef</a> =
      <span title="Trees.this.ValDef" class="keyword">if</span> <span class="delimiter">(</span><a href="#405706" title="Trees.this.ValDef">tree</a>.<a href="#402617" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#405706" title="Trees.this.ValDef">tree</a> <span class="keyword">else</span> <a href="#405652" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#405706" title="Trees.this.ValDef">tree</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Trees.this.ValDef" class="delimiter">[</span><a href="#56233" title="Trees.this.ValDef">ValDef</a><span class="delimiter">]</span>
    /** Transforms a list of `ValDef` nodes. */
    <span class="keyword">def</span> <a title="(trees: List[Trees.this.ValDef])List[Trees.this.ValDef]" id="405657">transformValDefs</a><span class="delimiter">(</span><a title="List[Trees.this.ValDef]" id="405707">trees</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.ValDef]">List</a><span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.ValDef]">List</a><span class="delimiter">[</span>ValDef<span class="delimiter">]</span> =
      <a href="#405707" title="List[Trees.this.ValDef]">trees</a> <a href="../../collection/immutable/List.scala.html#62694" title="(f: Trees.this.ValDef =&gt; Trees.this.ValDef)List[Trees.this.ValDef]">mapConserve</a> <span class="delimiter">(</span><a href="#405656" title="(tree: Trees.this.ValDef)Trees.this.ValDef">transformValDef</a><span class="delimiter">(</span><a href="#405714" title="Trees.this.ValDef">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    /** Transforms a list of lists of `ValDef` nodes. */
    <span class="keyword">def</span> <a title="(treess: List[List[Trees.this.ValDef]])List[List[Trees.this.ValDef]]" id="405658">transformValDefss</a><span class="delimiter">(</span><a title="List[List[Trees.this.ValDef]]" id="405716">treess</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[List[Trees.this.ValDef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#11952" title="List[List[Trees.this.ValDef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#405716" title="List[List[Trees.this.ValDef]]">treess</a> <a href="../../collection/immutable/List.scala.html#62694" title="(f: List[Trees.this.ValDef] =&gt; List[Trees.this.ValDef])List[List[Trees.this.ValDef]]">mapConserve</a> <span class="delimiter">(</span><a href="#405657" title="(trees: List[Trees.this.ValDef])List[Trees.this.ValDef]">transformValDefs</a><span class="delimiter">(</span><a href="#405723" title="List[Trees.this.ValDef]">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    /** Transforms a list of `CaseDef` nodes. */
    <span class="keyword">def</span> <a title="(trees: List[Trees.this.CaseDef])List[Trees.this.CaseDef]" id="405659">transformCaseDefs</a><span class="delimiter">(</span><a title="List[Trees.this.CaseDef]" id="405725">trees</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span> =
      <a href="#405725" title="List[Trees.this.CaseDef]">trees</a> <a href="../../collection/immutable/List.scala.html#62694" title="(f: Trees.this.CaseDef =&gt; Trees.this.CaseDef)List[Trees.this.CaseDef]">mapConserve</a> <span class="delimiter">(</span><a title="Trees.this.CaseDef" id="405732">tree</a> =&gt; <a href="#405652" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#405732" title="Trees.this.CaseDef">tree</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Trees.this.CaseDef" class="delimiter">[</span><a href="#56273" title="Trees.this.CaseDef">CaseDef</a><span class="delimiter">]</span><span class="delimiter">)</span>
    /** Transforms a list of `Ident` nodes. */
    <span class="keyword">def</span> <a title="(trees: List[Trees.this.Ident])List[Trees.this.Ident]" id="405660">transformIdents</a><span class="delimiter">(</span><a title="List[Trees.this.Ident]" id="405734">trees</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Ident]">List</a><span class="delimiter">[</span>Ident<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Ident]">List</a><span class="delimiter">[</span>Ident<span class="delimiter">]</span> =
      <a href="#405734" title="List[Trees.this.Ident]">trees</a> <a href="../../collection/immutable/List.scala.html#62694" title="(f: Trees.this.Ident =&gt; Trees.this.Ident)List[Trees.this.Ident]">mapConserve</a> <span class="delimiter">(</span><a title="Trees.this.Ident" id="405741">tree</a> =&gt; <a href="#405652" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#405741" title="Trees.this.Ident">tree</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Trees.this.Ident" class="delimiter">[</span><a href="#56376" title="Trees.this.Ident">Ident</a><span class="delimiter">]</span><span class="delimiter">)</span>
    /** Traverses a list of trees with a given owner symbol. */
    <span class="keyword">def</span> <a title="(stats: List[Trees.this.Tree], exprOwner: Trees.this.Symbol)List[Trees.this.Tree]" id="405661">transformStats</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="405743">stats</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="Trees.this.Symbol" id="405744">exprOwner</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> =
      <a href="#405743" title="List[Trees.this.Tree]">stats</a> <a href="../../collection/immutable/List.scala.html#62694" title="(f: Trees.this.Tree =&gt; Trees.this.Tree)List[Trees.this.Tree]">mapConserve</a> <span class="delimiter">(</span><a title="Trees.this.Tree" id="405751">stat</a> =&gt;
        <span title="Trees.this.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#405744" title="Trees.this.Symbol">exprOwner</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#405648" title="=&gt; Trees.this.Symbol">currentOwner</a> <a href="../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#405751" title="Trees.this.Tree">stat</a>.<a href="#402618" title="=&gt; Boolean">isTerm</a><span class="delimiter">)</span> <a href="#405663" title="(owner: Trees.this.Symbol)(trans: =&gt; Trees.this.Tree)Trees.this.Tree">atOwner</a><span class="delimiter">(</span><a href="#405744" title="Trees.this.Symbol">exprOwner</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#405652" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#405751" title="Trees.this.Tree">stat</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#405652" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#405751" title="Trees.this.Tree">stat</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../collection/TraversableLike.scala.html#58073" title="(p: Trees.this.Tree =&gt; Boolean)List[Trees.this.Tree]">filter</a> <span class="delimiter">(</span><a href="#56190" title="=&gt; Trees.this.Tree">EmptyTree</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#405775" title="Trees.this.Tree">_</a><span class="delimiter">)</span>
    /** Transforms `Modifiers`. */
    <span class="keyword">def</span> <a title="(mods: Trees.this.Modifiers)Trees.this.Modifiers" id="405662">transformModifiers</a><span class="delimiter">(</span><a title="Trees.this.Modifiers" id="405780">mods</a>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a><span class="delimiter">)</span>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a> =
      <a href="#405780" title="Trees.this.Modifiers">mods</a>.<a href="#404630" title="(f: List[Trees.this.Tree] =&gt; List[Trees.this.Tree])Trees.this.Modifiers">mapAnnotations</a><span class="delimiter">(</span><a href="#405653" title="(trees: List[Trees.this.Tree])List[Trees.this.Tree]">transformTrees</a><span class="delimiter">)</span>

    /** Transforms a tree with a given owner symbol. */
    <span class="keyword">def</span> <a title="[A](owner: Trees.this.Symbol)(trans: =&gt; A)A" id="405663">atOwner</a><span class="delimiter">[</span><a title="" id="405665">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Trees.this.Symbol" id="405756">owner</a>: <a href="Symbols.scala.html#56032" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; A" id="405757">trans</a>: =&gt; A<span class="delimiter">)</span>: <a href="#405665" title="A">A</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Trees.this.Symbol" id="405784">prevOwner</a> = <a href="#405648" title="=&gt; Trees.this.Symbol">currentOwner</a>
      <a href="#405648" title="(x$1: Trees.this.Symbol)Unit">currentOwner</a> = <a href="#405756" title="Trees.this.Symbol">owner</a>
      <span class="keyword">val</span> <a title="A" id="405785">result</a> = <a href="#405757" title="=&gt; A">trans</a>
      <a href="#405648" title="(x$1: Trees.this.Symbol)Unit">currentOwner</a> = <a href="#405784" title="Trees.this.Symbol">prevOwner</a>
      <a href="#405785" title="A">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Delegates the transformation strategy to `scala.reflect.internal.Trees`,
   *  because pattern matching on abstract types we have here degrades performance.
   *  @group Traversal
   */
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(transformer: Trees.this.Transformer, tree: Trees.this.Tree)Trees.this.Tree" id="56471">itransform</a><span class="delimiter">(</span><a title="Trees.this.Transformer" id="405685">transformer</a>: <a href="#56470" title="Trees.this.Transformer">Transformer</a>, <a title="Trees.this.Tree" id="405686">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56186" title="Trees.this.Tree">Tree</a> = <span title="Nothing" class="keyword">throw</span> <span title="MatchError" class="keyword">new</span> <a href="../../MatchError.scala.html#441" title="MatchError">MatchError</a><span class="delimiter">(</span><a href="#405686" title="Trees.this.Tree">tree</a><span class="delimiter">)</span>

  /** Provides an extension hook for the transformation strategy.
   *  Future-proofs against new node types.
   *  @group Traversal
   */
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(transformer: Trees.this.Transformer, tree: Trees.this.Tree)Trees.this.Tree" id="56472">xtransform</a><span class="delimiter">(</span><a title="Trees.this.Transformer" id="405786">transformer</a>: <a href="#56470" title="Trees.this.Transformer">Transformer</a>, <a title="Trees.this.Tree" id="405787">tree</a>: <a href="#56186" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#56186" title="Trees.this.Tree">Tree</a> = <span title="Nothing" class="keyword">throw</span> <span title="MatchError" class="keyword">new</span> <a href="../../MatchError.scala.html#441" title="MatchError">MatchError</a><span class="delimiter">(</span><a href="#405787" title="Trees.this.Tree">tree</a><span class="delimiter">)</span>

  /** The type of tree modifiers.
   *  @group Traversal
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Trees.this.ModifiersApi" id="56473">Modifiers</a> &gt;: Null &lt;: AnyRef <span class="keyword">with</span> ModifiersApi

  /** A tag that preserves the identity of the `Modifiers` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Traversal
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Trees.this.Modifiers]" id="56474">ModifiersTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Trees.this.Modifiers]">ClassTag</a><span class="delimiter">[</span>Modifiers<span class="delimiter">]</span>

  /** The API that all Modifiers support
   *  @group API
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ModifiersApi extends Object" id="56475">ModifiersApi</a> <a href="#56475" title="Trees.this.ModifiersApi" class="delimiter">{</a>
    /** The underlying flags of the enclosing definition.
     *  Is equal to `NoFlags` if none are specified explicitly.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.FlagSet" id="404626">flags</a>: <a href="FlagSets.scala.html#56156" title="Trees.this.FlagSet">FlagSet</a>

    <span class="keyword">def</span> <a title="(flag: Trees.this.FlagSet)Boolean" id="404627">hasFlag</a><span class="delimiter">(</span><a title="Trees.this.FlagSet" id="405789">flag</a>: <a href="FlagSets.scala.html#56156" title="Trees.this.FlagSet">FlagSet</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** The visibility scope of the enclosing definition.
     *  Is equal to `tpnme.EMPTY` if none is specified explicitly.
     */
    <span class="keyword">def</span> <a title="=&gt; Trees.this.Name" id="404628">privateWithin</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>

    /** The annotations of the enclosing definition.
     *  Empty list if none are specified explicitly.
     */
    <span class="keyword">def</span> <a title="=&gt; List[Trees.this.Tree]" id="404629">annotations</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

    /** Creates a new instance of `Modifiers` with
     *  the annotations transformed according to the given function.
     */
    <span class="keyword">def</span> <a title="(f: List[Trees.this.Tree] =&gt; List[Trees.this.Tree])Trees.this.Modifiers" id="404630">mapAnnotations</a><span class="delimiter">(</span><a title="List[Trees.this.Tree] =&gt; List[Trees.this.Tree]" id="405781">f</a>: List<span class="delimiter">[</span>Tree<span class="delimiter">]</span> =&gt; List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a> =
      <a href="#405805" title="(flags: Trees.this.FlagSet, privateWithin: Trees.this.Name, annotations: List[Trees.this.Tree])Trees.this.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#404626" title="=&gt; Trees.this.FlagSet">flags</a>, <a href="#404628" title="=&gt; Trees.this.Name">privateWithin</a>, <a href="../../Function1.scala.html#58642" title="(v1: List[Trees.this.Tree])List[Trees.this.Tree]">f</a><span class="delimiter">(</span><a href="#404629" title="=&gt; List[Trees.this.Tree]">annotations</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** The constructor/extractor for `Modifiers` instances.
   *  @group Traversal
   */
  <span class="keyword">val</span> <a title="=&gt; Trees.this.ModifiersCreator" id="56476">Modifiers</a>: <a href="#56477" title="Trees.this.ModifiersCreator">ModifiersCreator</a>

  /** An extractor class to create and pattern match with syntax `Modifiers(flags, privateWithin, annotations)`.
   *  Modifiers encapsulate flags, visibility annotations and Scala annotations for member definitions.
   *  @group Traversal
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ModifiersCreator extends Object" id="56477">ModifiersCreator</a> <a href="#56477" title="Trees.this.ModifiersCreator" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="()Trees.this.Modifiers" id="405804">apply</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a> = <a href="#405805" title="(flags: Trees.this.FlagSet, privateWithin: Trees.this.Name, annotations: List[Trees.this.Tree])Trees.this.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="FlagSets.scala.html#56162" title="=&gt; Trees.this.FlagSet">NoFlags</a>, <a href="StandardNames.scala.html#56577" title="=&gt; Trees.this.TypeNamesApi">tpnme</a>.<a href="StandardNames.scala.html#404231" title="=&gt; Trees.this.tpnme.NameType">EMPTY</a>, List<a href="../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(flags: Trees.this.FlagSet, privateWithin: Trees.this.Name, annotations: List[Trees.this.Tree])Trees.this.Modifiers" id="405805">apply</a><span class="delimiter">(</span><a title="Trees.this.FlagSet" id="405808">flags</a>: <a href="FlagSets.scala.html#56156" title="Trees.this.FlagSet">FlagSet</a>, <a title="Trees.this.Name" id="405809">privateWithin</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a>, <a title="List[Trees.this.Tree]" id="405810">annotations</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a>
  <span class="delimiter">}</span>

  /** The factory for `Modifiers` instances.
   *  @group Traversal
   */
  <span class="keyword">def</span> <a title="(flags: Trees.this.FlagSet, privateWithin: Trees.this.Name)Trees.this.Modifiers" id="56478">Modifiers</a><span class="delimiter">(</span><a title="Trees.this.FlagSet" id="405801">flags</a>: <a href="FlagSets.scala.html#56156" title="Trees.this.FlagSet">FlagSet</a>, <a title="Trees.this.Name" id="405802">privateWithin</a>: <a href="Names.scala.html#56175" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a> = <a href="#405805" title="(flags: Trees.this.FlagSet, privateWithin: Trees.this.Name, annotations: List[Trees.this.Tree])Trees.this.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#405801" title="Trees.this.FlagSet">flags</a>, <a href="#405802" title="Trees.this.Name">privateWithin</a>, List<a href="../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span>

  /** The factory for `Modifiers` instances.
   *  @group Traversal
   */
  <span class="keyword">def</span> <a title="(flags: Trees.this.FlagSet)Trees.this.Modifiers" id="56479">Modifiers</a><span class="delimiter">(</span><a title="Trees.this.FlagSet" id="405794">flags</a>: <a href="FlagSets.scala.html#56156" title="Trees.this.FlagSet">FlagSet</a><span class="delimiter">)</span>: <a href="#56473" title="Trees.this.Modifiers">Modifiers</a> = <a href="#56478" title="(flags: Trees.this.FlagSet, privateWithin: Trees.this.Name)Trees.this.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#405794" title="Trees.this.FlagSet">flags</a>, <a href="StandardNames.scala.html#56577" title="=&gt; Trees.this.TypeNamesApi">tpnme</a>.<a href="StandardNames.scala.html#404231" title="=&gt; Trees.this.tpnme.NameType">EMPTY</a><span class="delimiter">)</span>

  /** An empty `Modifiers` object: no flags, empty visibility annotation and no Scala annotations.
   *  @group Traversal
   */
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Trees.this.Modifiers" id="56481">NoMods</a> = <a href="#405804" title="()Trees.this.Modifiers">Modifiers</a><span class="delimiter">(</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>