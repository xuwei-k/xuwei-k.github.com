<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/reflect/api/Symbols.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scala.reflect
<span class="keyword">package</span> api

/**
 * &lt;span class=&quot;badge badge-red&quot; style=&quot;float: right;&quot;&gt;EXPERIMENTAL&lt;/span&gt;
 *
 *  This trait defines symbols and operations on them.
 *
 *  Symbols are used to establish bindings between a name and the entity it refers to, such as a class or a method.
 *  Anything you define and can give a name to in Scala has an associated symbol.
 *
 *  Symbols contain all available information about the declaration of an entity (class/object/trait etc.) or a
 *  member (vals/vars/defs etc.), and as such are an integral abstraction central to both runtime
 *  reflection and macros.
 *
 *  A symbol can provide a wealth of information ranging from the basic `name` method available on all symbols to
 *  other, more involved, concepts such as getting the `baseClasses` from `ClassSymbol`. Other common use cases of
 *  symbols include inspecting members' signatures, getting type parameters of a class, getting the parameter type
 *  of a method or finding out the type of a field.
 *
 *  Example usage of runtime reflection; getting a method's type signature:
 *  {{{
 *    scala&gt; import scala.reflect.runtime.universe._
 *    import scala.reflect.runtime.universe._
 *
 *    scala&gt; class C[T] { def test[U](x: T)(y: U): Int = ??? }
 *    defined class C
 *
 *    scala&gt; val test = typeOf[C[Int]].member(newTermName(&quot;test&quot;)).asMethod
 *    test: reflect.runtime.universe.MethodSymbol = method test
 *
 *    scala&gt; test.typeSignature
 *    res0: reflect.runtime.universe.Type = [U](x: T)(y: U)scala.Int
 *  }}}
 *
 *  Symbols are organized in a hierarchy. For example, a symbol that represents a parameter of a method is owned by
 *  the corresponding method symbol, a method symbol is owned by its enclosing class, a class is owned by a
 *  containing package and so on.
 *
 *  Certain types of tree nodes, such as [[Trees#Ident Ident]] (references to identifiers) and
 *  [[Trees#Select Select]] (references to members) expose method [[Trees.SymTreeApi.symbol `symbol`]]
 *  to obtain the symbol that represents their declaration. During the typechecking phase, the compiler looks up the
 *  symbol based on the name and scope and sets the [[Trees.SymTreeApi.symbol `symbol` field]] of tree nodes.
 *
 *  For more information about `Symbol` usage and attached intricacies, see the [[http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html Reflection Guide: Symbols]]
 *
 *  @group ReflectionAPI
 *
 *  @contentDiagram hideNodes &quot;*Api&quot;
 *
 *  @define SYMACCESSORS Class [[Symbol]] defines `isXXX` test methods such as `isPublic` or `isFinal`, `params` and
 *  `returnType` methods for method symbols, `baseClasses` for class symbols and so on. Some of these methods don't
 *  make sense for certain subclasses of `Symbol` and return `NoSymbol`, `Nil` or other empty values.
 *
 */
<span class="keyword">trait</span> <a title="trait Symbols extends Object" id="18171">Symbols</a> <a href="../../Unit.scala.html#1515" title="Unit" class="delimiter">{</a> self: Universe =&gt;

  /** The type of symbols representing declarations.
   *  @group Symbols
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Symbols.this.SymbolApi" id="56032">Symbol</a> &gt;: Null &lt;: SymbolApi

  /** A tag that preserves the identity of the `Symbol` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Symbols.this.Symbol]" id="56033">SymbolTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Symbols.this.Symbol]">ClassTag</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

  /** The type of type symbols representing type, class, and trait declarations,
   *  as well as type parameters.
   *  @group Symbols
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Symbols.this.Symbol with Symbols.this.TypeSymbolApi" id="56034">TypeSymbol</a> &gt;: Null &lt;: Symbol <span class="keyword">with</span> TypeSymbolApi

  /** A tag that preserves the identity of the `TypeSymbol` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Symbols.this.TypeSymbol]" id="56035">TypeSymbolTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Symbols.this.TypeSymbol]">ClassTag</a><span class="delimiter">[</span>TypeSymbol<span class="delimiter">]</span>

  /** The type of term symbols representing val, var, def, and object declarations as
   *  well as packages and value parameters.
   *  @group Symbols
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Symbols.this.Symbol with Symbols.this.TermSymbolApi" id="56036">TermSymbol</a> &gt;: Null &lt;: Symbol <span class="keyword">with</span> TermSymbolApi

  /** A tag that preserves the identity of the `TermSymbol` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Symbols.this.TermSymbol]" id="56037">TermSymbolTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Symbols.this.TermSymbol]">ClassTag</a><span class="delimiter">[</span>TermSymbol<span class="delimiter">]</span>

  /** The type of method symbols representing def declarations.
   *  @group Symbols
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Symbols.this.TermSymbol with Symbols.this.MethodSymbolApi" id="56038">MethodSymbol</a> &gt;: Null &lt;: TermSymbol <span class="keyword">with</span> MethodSymbolApi

  /** A tag that preserves the identity of the `MethodSymbol` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Symbols.this.MethodSymbol]" id="56039">MethodSymbolTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Symbols.this.MethodSymbol]">ClassTag</a><span class="delimiter">[</span>MethodSymbol<span class="delimiter">]</span>

  /** The type of module symbols representing object declarations.
   *  @group Symbols
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Symbols.this.TermSymbol with Symbols.this.ModuleSymbolApi" id="56040">ModuleSymbol</a> &gt;: Null &lt;: TermSymbol <span class="keyword">with</span> ModuleSymbolApi

  /** A tag that preserves the identity of the `ModuleSymbol` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Symbols.this.ModuleSymbol]" id="56041">ModuleSymbolTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Symbols.this.ModuleSymbol]">ClassTag</a><span class="delimiter">[</span>ModuleSymbol<span class="delimiter">]</span>

  /** The type of class symbols representing class and trait definitions.
   *  @group Symbols
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Symbols.this.TypeSymbol with Symbols.this.ClassSymbolApi" id="56042">ClassSymbol</a> &gt;: Null &lt;: TypeSymbol <span class="keyword">with</span> ClassSymbolApi

  /** A tag that preserves the identity of the `ClassSymbol` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Symbols.this.ClassSymbol]" id="56043">ClassSymbolTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Symbols.this.ClassSymbol]">ClassTag</a><span class="delimiter">[</span>ClassSymbol<span class="delimiter">]</span>

  /** The type of free terms introduced by reification.
   *  @group Symbols
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Symbols.this.TermSymbol with Symbols.this.FreeTermSymbolApi" id="56044">FreeTermSymbol</a> &gt;: Null &lt;: TermSymbol <span class="keyword">with</span> FreeTermSymbolApi

  /** A tag that preserves the identity of the `FreeTermSymbol` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Symbols.this.FreeTermSymbol]" id="56045">FreeTermSymbolTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Symbols.this.FreeTermSymbol]">ClassTag</a><span class="delimiter">[</span>FreeTermSymbol<span class="delimiter">]</span>

  /** The type of free types introduced by reification.
   *  @group Symbols
   *  @template
   */
  <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Symbols.this.TypeSymbol with Symbols.this.FreeTypeSymbolApi" id="56046">FreeTypeSymbol</a> &gt;: Null &lt;: TypeSymbol <span class="keyword">with</span> FreeTypeSymbolApi

  /** A tag that preserves the identity of the `FreeTypeSymbol` abstract type from erasure.
   *  Can be used for pattern matching, instance tests, serialization and likes.
   *  @group Tags
   */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="=&gt; scala.reflect.ClassTag[Symbols.this.FreeTypeSymbol]" id="56047">FreeTypeSymbolTag</a>: <a href="../ClassTag.scala.html#2383" title="scala.reflect.ClassTag[Symbols.this.FreeTypeSymbol]">ClassTag</a><span class="delimiter">[</span>FreeTypeSymbol<span class="delimiter">]</span>

  /** A special &quot;missing&quot; symbol. Commonly used in the API to denote a default or empty value.
   *  @group Symbols
   *  @template
   */
  <span class="keyword">val</span> <a title="=&gt; Symbols.this.Symbol" id="56048">NoSymbol</a>: <a href="#56032" title="Symbols.this.Symbol">Symbol</a>

  /** The API of symbols.
   *  The main source of information about symbols is the [[Symbols]] page.
   *
   *  $SYMACCESSORS
   *  @group API
   *  @groupname Basics        Symbol Basic Information
   *  @groupprio Basics        0
   *  @groupname Tests         Symbol Type Tests
   *  @groupprio Tests         1
   *  @groupname Conversions   Symbol Conversions
   *  @groupprio Conversions   2
   *  @groupname Constructors  New Symbol Constructors
   *  @groupprio Constructors  3
   *  @groupdesc Constructors  These methods construct new symbols owned by the current symbol.
   *  @groupname Helpers       Iteration Helpers
   *  @groupprio Helpers       4
   *  @groupdesc Helpers       These methods enable collections-like operations on symbols.
   *  @groupname Type          TypeSymbol Members
   *  @groupprio Type          -1
   *  @groupname FreeType      FreeType Symbol Members
   *  @groupprio FreeType      -2
   *  @groupname Term          TermSymbol Members
   *  @groupprio Term          -1
   *  @groupname FreeTerm      FreeTerm Symbol Members
   *  @groupprio FreeTerm      -2
   *  @groupname Class         Class Symbol Members
   *  @groupprio Class         -2
   *  @groupname Method        Method Symbol Members
   *  @groupprio Method        -2
   *  @groupname Module        Module Symbol Members
   *  @groupprio Module        -2
   */
  <span class="keyword">trait</span> <a title="trait SymbolApi extends Object" id="56049">SymbolApi</a> <a href="../../Unit.scala.html#1515" title="Unit" class="delimiter">{</a> <span class="keyword">this</span>: Symbol =&gt;

    /** The owner of this symbol. This is the symbol
     *  that directly contains the current symbol's definition.
     *  The `NoSymbol` symbol does not have an owner, and calling this method
     *  on one causes an internal error.
     *  The owner of the Scala root class [[scala.reflect.api.Mirror.RootClass]]
     *  and the Scala root object [[scala.reflect.api.Mirror.RootPackage]] is `NoSymbol`.
     *  Every other symbol has a chain of owners that ends in
     *  [[scala.reflect.api.Mirror.RootClass]].
     *
     *  @group Basics
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Symbol" id="402390">owner</a>: <a href="#56032" title="Symbols.this.Symbol">Symbol</a>

    /** The type of the symbol name.
     *  Can be either `TermName` or `TypeName` depending on whether this is a `TermSymbol` or a `TypeSymbol`.
     *
     *  Type name namespaces do not intersect with term name namespaces.
     *  This fact is reflected in different types for names of `TermSymbol` and `TypeSymbol`.
     *  @group Basics
     */
    <span class="keyword">type</span> <a title=" &gt;: Null &lt;: Symbols.this.Name" id="402391">NameType</a> &gt;: Null &lt;: Name

    /** The name of the symbol as a member of the `Name` type.
     *  @group Basics
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Name" id="402392">name</a>: <a href="Names.scala.html#56175" title="Symbols.this.Name">Name</a>

    /** The encoded full path name of this symbol, where outer names and inner names
     *  are separated by periods.
     *  @group Basics
     */
    <span class="keyword">def</span> <a title="=&gt; String" id="402393">fullName</a>: <span title="String">String</span>

    /** Does this symbol represent the definition of a type?
     *  Note that every symbol is either a term or a type.
     *  So for every symbol `sym` (except for `NoSymbol`),
     *  either `sym.isTerm` is true or `sym.isType` is true.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402394">isType</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** This symbol cast to a TypeSymbol.
     *  @throws ScalaReflectionException if `isType` is false.
     *
     *  @group Conversions
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.TypeSymbol" id="402395">asType</a>: <a href="#56034" title="Symbols.this.TypeSymbol">TypeSymbol</a> = <span title="Nothing" class="keyword">throw</span> <span title="ScalaReflectionException" class="keyword">new</span> <a href="../package.scala.html#615" title="ScalaReflectionException">ScalaReflectionException</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#56629" title="(args: Any*)String">s</a>&quot;$<span class="keyword">this</span><a href="#56049" title="Symbols.this.Symbol" class="string"> is not a type&quot;</a><span class="delimiter">)</span>

    /** Does this symbol represent the definition of a term?
     *  Note that every symbol is either a term or a type.
     *  So for every symbol `sym` (except for `NoSymbol`),
     *  either `sym.isTerm` is true or `sym.isTerm` is true.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402396">isTerm</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** This symbol cast to a TermSymbol.
     *  @throws ScalaReflectionException if `isTerm` is false.
     *
     *  @group Conversions
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.TermSymbol" id="402397">asTerm</a>: <a href="#56036" title="Symbols.this.TermSymbol">TermSymbol</a> = <span title="Nothing" class="keyword">throw</span> <span title="ScalaReflectionException" class="keyword">new</span> <a href="../package.scala.html#615" title="ScalaReflectionException">ScalaReflectionException</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#56629" title="(args: Any*)String">s</a>&quot;$<span class="keyword">this</span><a href="#56049" title="Symbols.this.Symbol" class="string"> is not a term&quot;</a><span class="delimiter">)</span>

    /** Does this symbol represent the definition of a method?
     *  If yes, `isTerm` is also guaranteed to be true.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402398">isMethod</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** This symbol cast to a MethodSymbol.
     *  @throws ScalaReflectionException if `isMethod` is false.
     *
     *  @group Conversions
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.MethodSymbol" id="402399">asMethod</a>: <a href="#56038" title="Symbols.this.MethodSymbol">MethodSymbol</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; String" id="404254">overloadedMsg</a> =
        <span class="string">&quot;encapsulates multiple overloaded alternatives and cannot be treated as a method. &quot;</span><span title="String(&quot;encapsulates multiple overloaded alternatives and cannot be treated as a method. Consider invoking `&lt;offending symbol&gt;.asTerm.alternatives` and manually picking the required method&quot;)">+</span>
        <span class="string">&quot;Consider invoking `&lt;offending symbol&gt;.asTerm.alternatives` and manually picking the required method&quot;</span>
      <span class="keyword">def</span> <a title="=&gt; String" id="404255">vanillaMsg</a> = <span title="String(&quot;is not a method&quot;)" class="string">&quot;is not a method&quot;</span>
      <span class="keyword">val</span> <a title="String" id="404256">msg</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#402400" title="=&gt; Boolean">isOverloadedMethod</a><span class="delimiter">)</span> <a href="#404254" title="=&gt; String">overloadedMsg</a> <span class="keyword">else</span> <a href="#404255" title="=&gt; String">vanillaMsg</a>
      <span title="Nothing" class="keyword">throw</span> <span title="ScalaReflectionException" class="keyword">new</span> <a href="../package.scala.html#615" title="ScalaReflectionException">ScalaReflectionException</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#56629" title="(args: Any*)String">s</a>&quot;$<span class="keyword">this</span><a href="#56049" title="Symbols.this.Symbol"> $</a><a href="#404256" title="String">msg</a><span class="string">&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Used to provide a better error message for `asMethod`
     *
     *  @group Tests
     */
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="402400">isOverloadedMethod</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Does this symbol represent the definition of a module (i.e. it
     *  results from an object definition?).
     *  If yes, `isTerm` is also guaranteed to be true.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402401">isModule</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** This symbol cast to a ModuleSymbol defined by an object definition.
     *  @throws ScalaReflectionException if `isModule` is false.
     *
     *  @group Conversions
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.ModuleSymbol" id="402402">asModule</a>: <a href="#56040" title="Symbols.this.ModuleSymbol">ModuleSymbol</a> = <span title="Nothing" class="keyword">throw</span> <span title="ScalaReflectionException" class="keyword">new</span> <a href="../package.scala.html#615" title="ScalaReflectionException">ScalaReflectionException</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#56629" title="(args: Any*)String">s</a>&quot;$<span class="keyword">this</span><a href="#56049" title="Symbols.this.Symbol" class="string"> is not a module&quot;</a><span class="delimiter">)</span>

    /** Does this symbol represent the definition of a class or trait?
     *  If yes, `isType` is also guaranteed to be true.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402403">isClass</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** Does this symbol represent the definition of a class implicitly associated
     *  with an object definition (module class in scala compiler parlance).
     *  If yes, `isType` is also guaranteed to be true.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402404">isModuleClass</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** This symbol cast to a ClassSymbol representing a class or trait.
     *  @throws ScalaReflectionException if `isClass` is false.
     *
     *  @group Conversions
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.ClassSymbol" id="402405">asClass</a>: <a href="#56042" title="Symbols.this.ClassSymbol">ClassSymbol</a> = <span title="Nothing" class="keyword">throw</span> <span title="ScalaReflectionException" class="keyword">new</span> <a href="../package.scala.html#615" title="ScalaReflectionException">ScalaReflectionException</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#56629" title="(args: Any*)String">s</a>&quot;$<span class="keyword">this</span><a href="#56049" title="Symbols.this.Symbol" class="string"> is not a class&quot;</a><span class="delimiter">)</span>

    /** Does this symbol represent a free term captured by reification?
     *  If yes, `isTerm` is also guaranteed to be true.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402406">isFreeTerm</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** This symbol cast to a free term symbol.
     *  @throws ScalaReflectionException if `isFreeTerm` is false.
     *
     *  @group Conversions
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.FreeTermSymbol" id="402407">asFreeTerm</a>: <a href="#56044" title="Symbols.this.FreeTermSymbol">FreeTermSymbol</a> = <span title="Nothing" class="keyword">throw</span> <span title="ScalaReflectionException" class="keyword">new</span> <a href="../package.scala.html#615" title="ScalaReflectionException">ScalaReflectionException</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#56629" title="(args: Any*)String">s</a>&quot;$<span class="keyword">this</span><a href="#56049" title="Symbols.this.Symbol" class="string"> is not a free term&quot;</a><span class="delimiter">)</span>

    /** Does this symbol represent a free type captured by reification?
     *  If yes, `isType` is also guaranteed to be true.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402408">isFreeType</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span>

    /** This symbol cast to a free type symbol.
     *  @throws ScalaReflectionException if `isFreeType` is false.
     *
     *  @group Conversions
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.FreeTypeSymbol" id="402409">asFreeType</a>: <a href="#56046" title="Symbols.this.FreeTypeSymbol">FreeTypeSymbol</a> = <span title="Nothing" class="keyword">throw</span> <span title="ScalaReflectionException" class="keyword">new</span> <a href="../package.scala.html#615" title="ScalaReflectionException">ScalaReflectionException</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#56629" title="(args: Any*)String">s</a>&quot;$<span class="keyword">this</span><a href="#56049" title="Symbols.this.Symbol" class="string"> is not a free type&quot;</a><span class="delimiter">)</span>

    /** @group Constructors */
    <span class="keyword">def</span> <a title="(name: Symbols.this.TermName, pos: Symbols.this.Position, flags: Symbols.this.FlagSet)Symbols.this.TermSymbol" id="402410">newTermSymbol</a><span class="delimiter">(</span><a title="Symbols.this.TermName" id="404257">name</a>: <a href="Names.scala.html#56179" title="Symbols.this.TermName">TermName</a>, <a title="Symbols.this.Position" id="404260">pos</a>: <a href="Positions.scala.html#56514" title="Symbols.this.Position">Position</a> = <a href="Positions.scala.html#56516" title="=&gt; Symbols.this.Position">NoPosition</a>, <a title="Symbols.this.FlagSet" id="404261">flags</a>: <a href="FlagSets.scala.html#56156" title="Symbols.this.FlagSet">FlagSet</a> = <a href="FlagSets.scala.html#56162" title="=&gt; Symbols.this.FlagSet">NoFlags</a><span class="delimiter">)</span>: <a href="#56036" title="Symbols.this.TermSymbol">TermSymbol</a>
    /** @group Constructors */
    <span class="keyword">def</span> <a title="(name: Symbols.this.Name, pos: Symbols.this.Position, flags: Symbols.this.FlagSet)(Symbols.this.ModuleSymbol, Symbols.this.ClassSymbol)" id="402411">newModuleAndClassSymbol</a><span class="delimiter">(</span><a title="Symbols.this.Name" id="404268">name</a>: <a href="Names.scala.html#56175" title="Symbols.this.Name">Name</a>, <a title="Symbols.this.Position" id="404271">pos</a>: <a href="Positions.scala.html#56514" title="Symbols.this.Position">Position</a> = <a href="Positions.scala.html#56516" title="=&gt; Symbols.this.Position">NoPosition</a>, <a title="Symbols.this.FlagSet" id="404272">flags</a>: <a href="FlagSets.scala.html#56156" title="Symbols.this.FlagSet">FlagSet</a> = <a href="FlagSets.scala.html#56162" title="=&gt; Symbols.this.FlagSet">NoFlags</a><span class="delimiter">)</span>: <a href="../../Tuple2.scala.html#783" title="(Symbols.this.ModuleSymbol, Symbols.this.ClassSymbol)" class="delimiter">(</a>ModuleSymbol, ClassSymbol<span class="delimiter">)</span>
    /** @group Constructors */
    <span class="keyword">def</span> <a title="(name: Symbols.this.TermName, pos: Symbols.this.Position, flags: Symbols.this.FlagSet)Symbols.this.MethodSymbol" id="402412">newMethodSymbol</a><span class="delimiter">(</span><a title="Symbols.this.TermName" id="404276">name</a>: <a href="Names.scala.html#56179" title="Symbols.this.TermName">TermName</a>, <a title="Symbols.this.Position" id="404279">pos</a>: <a href="Positions.scala.html#56514" title="Symbols.this.Position">Position</a> = <a href="Positions.scala.html#56516" title="=&gt; Symbols.this.Position">NoPosition</a>, <a title="Symbols.this.FlagSet" id="404280">flags</a>: <a href="FlagSets.scala.html#56156" title="Symbols.this.FlagSet">FlagSet</a> = <a href="FlagSets.scala.html#56162" title="=&gt; Symbols.this.FlagSet">NoFlags</a><span class="delimiter">)</span>: <a href="#56038" title="Symbols.this.MethodSymbol">MethodSymbol</a>
    /** @group Constructors */
    <span class="keyword">def</span> <a title="(name: Symbols.this.TypeName, pos: Symbols.this.Position, flags: Symbols.this.FlagSet)Symbols.this.TypeSymbol" id="402413">newTypeSymbol</a><span class="delimiter">(</span><a title="Symbols.this.TypeName" id="404284">name</a>: <a href="Names.scala.html#56177" title="Symbols.this.TypeName">TypeName</a>, <a title="Symbols.this.Position" id="404287">pos</a>: <a href="Positions.scala.html#56514" title="Symbols.this.Position">Position</a> = <a href="Positions.scala.html#56516" title="=&gt; Symbols.this.Position">NoPosition</a>, <a title="Symbols.this.FlagSet" id="404288">flags</a>: <a href="FlagSets.scala.html#56156" title="Symbols.this.FlagSet">FlagSet</a> = <a href="FlagSets.scala.html#56162" title="=&gt; Symbols.this.FlagSet">NoFlags</a><span class="delimiter">)</span>: <a href="#56034" title="Symbols.this.TypeSymbol">TypeSymbol</a>
    /** @group Constructors */
    <span class="keyword">def</span> <a title="(name: Symbols.this.TypeName, pos: Symbols.this.Position, flags: Symbols.this.FlagSet)Symbols.this.ClassSymbol" id="402414">newClassSymbol</a><span class="delimiter">(</span><a title="Symbols.this.TypeName" id="404292">name</a>: <a href="Names.scala.html#56177" title="Symbols.this.TypeName">TypeName</a>, <a title="Symbols.this.Position" id="404295">pos</a>: <a href="Positions.scala.html#56514" title="Symbols.this.Position">Position</a> = <a href="Positions.scala.html#56516" title="=&gt; Symbols.this.Position">NoPosition</a>, <a title="Symbols.this.FlagSet" id="404296">flags</a>: <a href="FlagSets.scala.html#56156" title="Symbols.this.FlagSet">FlagSet</a> = <a href="FlagSets.scala.html#56162" title="=&gt; Symbols.this.FlagSet">NoFlags</a><span class="delimiter">)</span>: <a href="#56042" title="Symbols.this.ClassSymbol">ClassSymbol</a>

    /** Source file if this symbol is created during this compilation run,
     *  or a class file if this symbol is loaded from a *.class or *.jar.
     *
     *  The return type is `scala.reflect.io.AbstractFile`, which belongs to an experimental part of Scala reflection.
     *  It should not be used unless you know what you are doing. In subsequent releases, this API will be refined
     *  and exposed as a part of scala.reflect.api.
     *
     *  @group Basics
     */
    <span class="keyword">def</span> <a title="=&gt; scala.reflect.io.AbstractFile" id="402415">associatedFile</a>: scala.reflect.io.<a href="../io/AbstractFile.scala.html#23215" title="scala.reflect.io.AbstractFile">AbstractFile</a>

    /** A list of annotations attached to this Symbol.
     *
     *  @group Basics
     */
    <span class="keyword">def</span> <a title="=&gt; List[Symbols.this.Annotation]" id="402416">annotations</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Symbols.this.Annotation]">List</a><span class="delimiter">[</span>Annotation<span class="delimiter">]</span>

    /** For a class: the module or case class factory with the same name in the same package.
     *  For a module: the class with the same name in the same package.
     *  For all others: NoSymbol
     *
     *  @group Basics
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Symbol" id="402417">companionSymbol</a>: <a href="#56032" title="Symbols.this.Symbol">Symbol</a>

    /** The type signature of this symbol seen as a member of given type `site`.
     *
     *  @group Basics
     */
    <span class="keyword">def</span> <a title="(site: Symbols.this.Type)Symbols.this.Type" id="402418">typeSignatureIn</a><span class="delimiter">(</span><a title="Symbols.this.Type" id="404336">site</a>: <a href="Types.scala.html#56063" title="Symbols.this.Type">Type</a><span class="delimiter">)</span>: <a href="Types.scala.html#56063" title="Symbols.this.Type">Type</a>

    /** The type signature of this symbol.
     *
     *  This method always returns signatures in the most generic way possible, even if the underlying symbol is obtained from an
     *  instantiation of a generic type. For example, signature
     *  of the method `def map[B](f: (A) ⇒ B): List[B]`, which refers to the type parameter `A` of the declaring class `List[A]`,
     *  will always feature `A`, regardless of whether `map` is loaded from the `List[_]` or from `List[Int]`. To get a signature
     *  with type parameters appropriately instantiated, one should use `typeSignatureIn`.
     *
     *  @group Basics
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Type" id="402419">typeSignature</a>: <a href="Types.scala.html#56063" title="Symbols.this.Type">Type</a>

    /** Returns all symbols overriden by this symbol.
     *
     *  @group Basics
     */
    <span class="keyword">def</span> <a title="=&gt; List[Symbols.this.Symbol]" id="402420">allOverriddenSymbols</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Symbols.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    /******************* tests *******************/

    /** Does this symbol represent a synthetic (i.e. a compiler-generated) entity?
     *  Examples of synthetic entities are accessors for vals and vars
     *  or mixin constructors in trait implementation classes.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402421">isSynthetic</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent an implementation artifact that isn't meant for public use?
     *  Examples of such artifacts are erasure bridges and outer fields.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402422">isImplementationArtifact</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a local declaration or definition?
     *
     *  If yes, either `isPrivate` or `isProtected` are guaranteed to be true.
     *  Local symbols can only be accessed from the same object instance.
     *
     *  If yes, `privateWithin` might tell more about this symbol's visibility scope.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402423">isLocal</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a private declaration or definition?
     *  If yes, `privateWithin` might tell more about this symbol's visibility scope.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402424">isPrivate</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a protected declaration or definition?
     *  If yes, `privateWithin` might tell more about this symbol's visibility scope.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402425">isProtected</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a public declaration or definition?
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402426">isPublic</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /**
     * Set when symbol has a modifier of the form private[X], NoSymbol otherwise.
     *
     *  Access level encoding: there are three scala flags (PRIVATE, PROTECTED,
     *  and LOCAL) which combine with value privateWithin (the &quot;foo&quot; in private[foo])
     *  to define from where an entity can be accessed.  The meanings are as follows:
     *
     *  PRIVATE     access restricted to class only.
     *  PROTECTED   access restricted to class and subclasses only.
     *  LOCAL       can only be set in conjunction with PRIVATE or PROTECTED.
     *              Further restricts access to the same object instance.
     *
     *  In addition, privateWithin can be used to set a visibility barrier.
     *  When set, everything contained in the named enclosing package or class
     *  has access.  It is incompatible with PRIVATE or LOCAL, but is additive
     *  with PROTECTED (i.e. if either the flags or privateWithin allow access,
     *  then it is allowed.)
     *
     *  The java access levels translate as follows:
     *
     *  java private:     isPrivate                  &amp;&amp; (privateWithin == NoSymbol)
     *  java package:     !isPrivate &amp;&amp; !isProtected &amp;&amp; (privateWithin == enclosingPackage)
     *  java protected:   isProtected                &amp;&amp; (privateWithin == enclosingPackage)
     *  java public:      !isPrivate &amp;&amp; !isProtected &amp;&amp; (privateWithin == NoSymbol)
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Symbol" id="402427">privateWithin</a>: <a href="#56032" title="Symbols.this.Symbol">Symbol</a>

    /** Does this symbol represent the definition of a package?
     *  If yes, `isTerm` is also guaranteed to be true.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402428">isPackage</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a package class?
     *  If yes, `isClass` is also guaranteed to be true.
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402429">isPackageClass</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol or its underlying type represent a typechecking error?
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402430">isErroneous</a> : <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Is this symbol static (i.e. with no outer instance)?
     *  Q: When exactly is a sym marked as STATIC?
     *  A: If it's a member of a toplevel object, or of an object contained in a toplevel object, or any number of levels deep.
     *  http://groups.google.com/group/scala-internals/browse_thread/thread/d385bcd60b08faf6
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402431">isStatic</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Is this symbol final?
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402432">isFinal</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Is this symbol overriding something?
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402433">isOverride</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Is this symbol labelled as &quot;abstract override&quot;?
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402434">isAbstractOverride</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Is this symbol a macro?
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402435">isMacro</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Is this symbol a parameter (either a method parameter or a type parameter)?
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402436">isParameter</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Is this symbol a specialized type parameter or a generated specialized member?
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402437">isSpecialized</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Is this symbol defined by Java?
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402438">isJava</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent an implicit value, definition, class or parameter?
     *
     *  @group Tests
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402439">isImplicit</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /******************* helpers *******************/

    /** Provides an alternate if symbol is a NoSymbol.
     *
     *  @group Helpers
     */
    <span class="keyword">def</span> <a title="(alt: =&gt; Symbols.this.Symbol)Symbols.this.Symbol" id="402440">orElse</a><span class="delimiter">(</span><a title="=&gt; Symbols.this.Symbol" id="404337">alt</a>: =&gt; Symbol<span class="delimiter">)</span>: <a href="#56032" title="Symbols.this.Symbol">Symbol</a>

    /** Filters the underlying alternatives (or a single-element list
     *  composed of the symbol itself if the symbol is not overloaded).
     *  Returns an overloaded symbol is there are multiple matches.
     *  Returns a NoSymbol if there are no matches.
     *
     *  @group Helpers
     */
    <span class="keyword">def</span> <a title="(cond: Symbols.this.Symbol =&gt; Boolean)Symbols.this.Symbol" id="402441">filter</a><span class="delimiter">(</span><a title="Symbols.this.Symbol =&gt; Boolean" id="404338">cond</a>: Symbol =&gt; Boolean<span class="delimiter">)</span>: <a href="#56032" title="Symbols.this.Symbol">Symbol</a>

    /** If this is a NoSymbol, returns NoSymbol, otherwise
     *  returns the result of applying `f` to this symbol.
     *
     *  @group Helpers
     */
    <span class="keyword">def</span> <a title="(f: Symbols.this.Symbol =&gt; Symbols.this.Symbol)Symbols.this.Symbol" id="402442">map</a><span class="delimiter">(</span><a title="Symbols.this.Symbol =&gt; Symbols.this.Symbol" id="404339">f</a>: Symbol =&gt; Symbol<span class="delimiter">)</span>: <a href="#56032" title="Symbols.this.Symbol">Symbol</a>

    /** Does the same as `filter`, but crashes if there are multiple matches.
     *
     *  @group Helpers
     */
    <span class="keyword">def</span> <a title="(cond: Symbols.this.Symbol =&gt; Boolean)Symbols.this.Symbol" id="402443">suchThat</a><span class="delimiter">(</span><a title="Symbols.this.Symbol =&gt; Boolean" id="404340">cond</a>: Symbol =&gt; Boolean<span class="delimiter">)</span>: <a href="#56032" title="Symbols.this.Symbol">Symbol</a>
  <span class="delimiter">}</span>

  /** The API of term symbols.
   *  The main source of information about symbols is the [[Symbols]] page.
   *
   *  $SYMACCESSORS
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait TermSymbolApi extends Object with Symbols.this.SymbolApi" id="56050">TermSymbolApi</a> <a href="../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#56049" title="Symbols.this.SymbolApi">SymbolApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: TermSymbol =&gt;
    /** Term symbols have their names of type `TermName`.
     */
    <span class="keyword">final</span> <span class="keyword">type</span> <a title="Symbols.this.TermName" id="402466">NameType</a> = <a href="Names.scala.html#56179" title="Symbols.this.TermName">TermName</a>

    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="402467">isTerm</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Symbols.this.TermSymbol" id="402468">asTerm</a> = <a href="#56050" title="Symbols.this.TermSymbol" class="keyword">this</a>

    /** Is this symbol introduced as `val`?
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402469">isVal</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol denote a stable value?
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402470">isStable</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Is this symbol introduced as `var`?
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402471">isVar</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a getter or a setter?
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402472">isAccessor</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a getter of a field?
     *  If yes, `isMethod` is also guaranteed to be true.
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402473">isGetter</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a setter of a field?
     *  If yes, `isMethod` is also guaranteed to be true.
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402474">isSetter</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent an overloaded method?
     *  If yes, `isMethod` is false, and the list of the enclosed alternatives can be found out via `alternatives`.
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402475">isOverloaded</a>   : <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a lazy value?
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402476">isLazy</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** The overloaded alternatives of this symbol
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; List[Symbols.this.Symbol]" id="402477">alternatives</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Symbols.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    /** Used to provide a better error message for `asMethod` */
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="402478">isOverloadedMethod</a> = <a href="#402477" title="=&gt; List[Symbols.this.Symbol]">alternatives</a> <a href="../../collection/LinearSeqOptimized.scala.html#86379" title="(p: Symbols.this.Symbol =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#404397" title="Symbols.this.Symbol">_</a>.<a href="#402398" title="=&gt; Boolean">isMethod</a><span class="delimiter">)</span>

    /** Backing field for an accessor method, NoSymbol for all other term symbols.
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Symbol" id="402479">accessed</a>: <a href="#56032" title="Symbols.this.Symbol">Symbol</a>

    /** Getter method for a backing field of a val or a val, NoSymbol for all other term symbols.
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Symbol" id="402480">getter</a>: <a href="#56032" title="Symbols.this.Symbol">Symbol</a>

    /** Setter method for a backing field of a val or a val, NoSymbol for all other term symbols.
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Symbol" id="402481">setter</a>: <a href="#56032" title="Symbols.this.Symbol">Symbol</a>

    /** Does this symbol represent a field of a class
     *  that was generated from a parameter of that class?
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402482">isParamAccessor</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a field of a case class
     *  that corresponds to a parameter in the first parameter list of the
     *  primary constructor of that class?
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402483">isCaseAccessor</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a parameter with a default value?
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402484">isParamWithDefault</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a by-name parameter?
     *
     *  @group Term
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402485">isByNameParam</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>
  <span class="delimiter">}</span>

  /** The API of type symbols.
   *  The main source of information about symbols is the [[Symbols]] page.
   *
   *  $SYMACCESSORS
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait TypeSymbolApi extends Object with Symbols.this.SymbolApi" id="56051">TypeSymbolApi</a> <a href="../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#56049" title="Symbols.this.SymbolApi">SymbolApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: TypeSymbol =&gt;
    /** Type symbols have their names of type `TypeName`.
     */
    <span class="keyword">final</span> <span class="keyword">type</span> <a title="Symbols.this.TypeName" id="402447">NameType</a> = <a href="Names.scala.html#56177" title="Symbols.this.TypeName">TypeName</a>

    /** The type constructor corresponding to this type symbol.
     *  This is different from `toType` in that type parameters
     *  are part of results of `toType`, but not of `toTypeConstructor`.
     *
     *  Example: Given a class declaration `class C[T] { ... } `, that generates a symbol
     *  `C`. Then `C.toType` is the type `C[T]`, but `C.toTypeConstructor` is `C`.
     *
     *  @group Type
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Type" id="402448">toTypeConstructor</a>: <a href="Types.scala.html#56063" title="Symbols.this.Type">Type</a>

    /** A type reference that refers to this type symbol seen
     *  as a member of given type `site`.
     *
     *  @group Type
     */
    <span class="keyword">def</span> <a title="(site: Symbols.this.Type)Symbols.this.Type" id="402449">toTypeIn</a><span class="delimiter">(</span><a title="Symbols.this.Type" id="404414">site</a>: <a href="Types.scala.html#56063" title="Symbols.this.Type">Type</a><span class="delimiter">)</span>: <a href="Types.scala.html#56063" title="Symbols.this.Type">Type</a>

    /**  A type reference that refers to this type symbol
      *  Note if symbol is a member of a class, one almost always is interested
      *  in `asTypeIn` with a site type instead.
      *
      *  Example: Given a class declaration `class C[T] { ... } `, that generates a symbol
      *  `C`. Then `C.toType` is the type `C[T]`.
      *
      *  By contrast, `C.typeSignature` would be a type signature of form
      *  `PolyType(ClassInfoType(...))` that describes type parameters, value
      *  parameters, parent types, and members of `C`.
     *
     *  @group Type
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Type" id="402450">toType</a>: <a href="Types.scala.html#56063" title="Symbols.this.Type">Type</a>

    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="402451">isType</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Symbols.this.TypeSymbol" id="402452">asType</a> = <a href="#56051" title="Symbols.this.TypeSymbol" class="keyword">this</a>

    /** Is the type parameter represented by this symbol contravariant?
     *
     *  @group Type
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402453">isContravariant</a> : <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Is the type parameter represented by this symbol contravariant?
     *
     *  @group Type
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402454">isCovariant</a>     : <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent the definition of a skolem?
     *  Skolems are used during typechecking to represent type parameters viewed from inside their scopes.
     *
     *  @group Type
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402455">isSkolem</a>       : <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent the definition of a type alias?
     *
     *  @group Type
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402456">isAliasType</a>    : <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent the definition of an abstract type?
     *
     *  @group Type
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402457">isAbstractType</a> : <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent an existentially bound type?
     *
     *  @group Type
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402458">isExistential</a>  : <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** For a polymorphic type, its type parameters, the empty list for all other types
     *
     *  @group Type
     */
    <span class="keyword">def</span> <a title="=&gt; List[Symbols.this.Symbol]" id="402459">typeParams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Symbols.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API of method symbols.
   *  The main source of information about symbols is the [[Symbols]] page.
   *
   *  $SYMACCESSORS
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait MethodSymbolApi extends Object with Symbols.this.TermSymbolApi" id="56052">MethodSymbolApi</a> <a href="../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#56050" title="Symbols.this.TermSymbolApi">TermSymbolApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: MethodSymbol =&gt;
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="402493">isMethod</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Symbols.this.MethodSymbol" id="402494">asMethod</a> = <a href="#56052" title="Symbols.this.MethodSymbol" class="keyword">this</a>

    /** Does this method represent a constructor?
     *
     *  If `owner` is a class, then this is a vanilla JVM constructor.
     *  If `owner` is a trait, then this is a mixin constructor.
     *
     *  @group Method
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402495">isConstructor</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol denote the primary constructor of its enclosing class?
     *
     *  @group Method
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402496">isPrimaryConstructor</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** For a polymorphic method, its type parameters, the empty list for all other methods
     *
     *  @group Method
     */
    <span class="keyword">def</span> <a title="=&gt; List[Symbols.this.Symbol]" id="402497">typeParams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Symbols.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    /** All parameter lists of the method.
     *  The name ending with &quot;ss&quot; indicates that the result type is a list of lists.
     *
     *  Can be used to distinguish nullary methods and methods with empty parameter lists.
     *  For a nullary method, returns the empty list (i.e. `List()`).
     *  For a method with an empty parameter list, returns a list that contains the empty list (i.e. `List(List())`).
     *
     *  @group Method
     */
    <span class="keyword">def</span> <a title="=&gt; List[List[Symbols.this.Symbol]]" id="402498">paramss</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[List[Symbols.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span>

    /** Does this method support variable length argument lists?
     *
     *  @group Method
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="402499">isVarargs</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** The return type of the method
     *
     *  @group Method
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Type" id="402500">returnType</a>: <a href="Types.scala.html#56063" title="Symbols.this.Type">Type</a>
  <span class="delimiter">}</span>

  /** The API of module symbols.
   *  The main source of information about symbols is the [[Symbols]] page.
   *
   *  $SYMACCESSORS
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ModuleSymbolApi extends Object with Symbols.this.TermSymbolApi" id="56053">ModuleSymbolApi</a> <a href="../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#56050" title="Symbols.this.TermSymbolApi">TermSymbolApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: ModuleSymbol =&gt;
    /** The class implicitly associated with the object definition.
     *  One can go back from a module class to the associated module symbol
     *  by inspecting its `selfType.termSymbol`.
     *
     *  @group Module
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Symbol" id="403642">moduleClass</a>: <a href="#56032" title="Symbols.this.Symbol">Symbol</a> // needed for tree traversals
    // when this becomes `moduleClass: ClassSymbol`, it will be the happiest day in my life

    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="403643">isModule</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Symbols.this.ModuleSymbol" id="403644">asModule</a> = <a href="#56053" title="Symbols.this.ModuleSymbol" class="keyword">this</a>
  <span class="delimiter">}</span>

  /** The API of class symbols.
   *  The main source of information about symbols is the [[Symbols]] page.
   *
   *  $SYMACCESSORS
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait ClassSymbolApi extends Object with Symbols.this.TypeSymbolApi" id="56054">ClassSymbolApi</a> <a href="../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#56051" title="Symbols.this.TypeSymbolApi">TypeSymbolApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: ClassSymbol =&gt;
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="403218">isClass</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Symbols.this.ClassSymbol" id="403219">asClass</a> = <a href="#56054" title="Symbols.this.ClassSymbol" class="keyword">this</a>

    /** Does this symbol represent the definition of a primitive class?
     *  Namely, is it one of [[scala.Double]], [[scala.Float]], [[scala.Long]], [[scala.Int]], [[scala.Char]],
     *  [[scala.Short]], [[scala.Byte]], [[scala.Unit]] or [[scala.Boolean]]?
     *
     *  @group Class
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="403220">isPrimitive</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent the definition of a numeric value class?
     *  Namely, is it one of [[scala.Double]], [[scala.Float]], [[scala.Long]], [[scala.Int]], [[scala.Char]],
     *  [[scala.Short]], [[scala.Byte]], [[scala.Unit]] or [[scala.Boolean]]?
     *
     *  @group Class
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="403221">isNumeric</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent the definition of a custom value class?
     *  Namely, is AnyVal among its parent classes?
     *
     *  @group Class
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="403222">isDerivedValueClass</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a trait?
     *
     *  @group Class
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="403223">isTrait</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent an abstract class?
     *
     *  @group Class
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="403224">isAbstractClass</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a case class?
     *
     *  @group Class
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="403225">isCaseClass</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** Does this symbol represent a sealed class?
     *
     *  @group Class
     */
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="403226">isSealed</a>: <a href="../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

    /** If this is a sealed class, its known direct subclasses.
     *  Otherwise, the empty set.
     *
     *  @group Class
     */
    <span class="keyword">def</span> <a title="=&gt; Set[Symbols.this.Symbol]" id="403227">knownDirectSubclasses</a>: <a href="../../collection/immutable/Set.scala.html#11919" title="Set[Symbols.this.Symbol]">Set</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    /** The list of all base classes of this type (including its own typeSymbol)
     *  in reverse linearization order, starting with the class itself and ending
     *  in class Any.
     *
     *  @group Class
     */
    <span class="keyword">def</span> <a title="=&gt; List[Symbols.this.Symbol]" id="403228">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Symbols.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    /** The module corresponding to this module class,
     *  or NoSymbol if this symbol is not a module class.
     *
     *  @group Class
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Symbol" id="403229">module</a>: <a href="#56032" title="Symbols.this.Symbol">Symbol</a>

    /** If this symbol is a class or trait, its self type, otherwise the type
     *  of the symbol itself.
     *
     *  @group Class
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Type" id="403230">selfType</a>: <a href="Types.scala.html#56063" title="Symbols.this.Type">Type</a>

    /** The type `C.this`, where `C` is the current class
     *
     *  @group Class
     */
    <span class="keyword">def</span> <a title="=&gt; Symbols.this.Type" id="403231">thisPrefix</a>: <a href="Types.scala.html#56063" title="Symbols.this.Type">Type</a>

    /** For a polymorphic class/trait, its type parameters, the empty list for all other classes/trait
     *
     *  @group Class
     */
    <span class="keyword">def</span> <a title="=&gt; List[Symbols.this.Symbol]" id="403232">typeParams</a>: <a href="../../collection/immutable/List.scala.html#11952" title="List[Symbols.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  /** The API of free term symbols.
   *  The main source of information about symbols is the [[Symbols]] page.
   *
   *  $SYMACCESSORS
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait FreeTermSymbolApi extends Object with Symbols.this.TermSymbolApi" id="56055">FreeTermSymbolApi</a> <a href="../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#56050" title="Symbols.this.TermSymbolApi">TermSymbolApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: FreeTermSymbol =&gt;
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="402581">isFreeTerm</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Symbols.this.FreeTermSymbol" id="402582">asFreeTerm</a> = <a href="#56055" title="Symbols.this.FreeTermSymbol" class="keyword">this</a>

    /** The place where this symbol has been spawned
     *
     *  @group FreeTerm
     */
    <span class="keyword">def</span> <a title="=&gt; String" id="402583">origin</a>: <span title="String">String</span>

    /** The valus this symbol refers to
     *
     *  @group FreeTerm
     */
    <span class="keyword">def</span> <a title="=&gt; Any" id="402584">value</a>: <span title="Any">Any</span>
  <span class="delimiter">}</span>

  /** The API of free type symbols.
   *  The main source of information about symbols is the [[Symbols]] page.
   *
   *  $SYMACCESSORS
   *  @group API
   */
  <span class="keyword">trait</span> <a title="trait FreeTypeSymbolApi extends Object with Symbols.this.TypeSymbolApi" id="56056">FreeTypeSymbolApi</a> <a href="../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#56051" title="Symbols.this.TypeSymbolApi">TypeSymbolApi</a> <span class="delimiter">{</span> <span class="keyword">this</span>: FreeTypeSymbol =&gt;
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="402595">isFreeType</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Symbols.this.FreeTypeSymbol" id="402596">asFreeType</a> = <a href="#56056" title="Symbols.this.FreeTypeSymbol" class="keyword">this</a>

    /** The place where this symbol has been spawned
     *
     *  @group FreeType
     */
    <span class="keyword">def</span> <a title="=&gt; String" id="402597">origin</a>: <span title="String">String</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>