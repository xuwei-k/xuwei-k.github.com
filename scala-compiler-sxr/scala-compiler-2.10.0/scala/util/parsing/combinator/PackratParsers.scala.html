<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/util/parsing/combinator/PackratParsers.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2006-2013, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */

<span class="keyword">package</span> scala.util.parsing.combinator

<span class="keyword">import</span> scala.util.parsing.combinator._
<span class="keyword">import</span> scala.util.parsing.input.<span class="delimiter">{</span> Reader, Position <span class="delimiter">}</span>
<span class="keyword">import</span> scala.collection.mutable
<span class="keyword">import</span> scala.<a href="../../../language.scala.html#1423" title="language.type">language</a>.implicitConversions

/**
 *  `PackratParsers` is a component that extends the parser combinators
 *  provided by [[scala.util.parsing.combinator.Parsers]] with a memoization
 *  facility (''Packrat Parsing'').
 *
 *  Packrat Parsing is a technique for implementing backtracking,
 *  recursive-descent parsers, with the advantage that it guarantees
 *  unlimited lookahead and a linear parse time. Using this technique,
 *  left recursive grammars can also be accepted.
 *
 *  Using `PackratParsers` is very similar to using `Parsers`:
 *   - any class/trait that extends `Parsers` (directly or through a subclass)
 *     can mix in `PackratParsers`.
 *     Example: `'''object''' MyGrammar '''extends''' StandardTokenParsers '''with''' PackratParsers`
 *   - each grammar production previously declared as a `def` without formal
 *     parameters becomes a `lazy val`, and its type is changed from
 *     `Parser[Elem]` to `PackratParser[Elem]`.
 *     So, for example, `'''def''' production: Parser[Int] = {...}`
 *     becomes `'''lazy val''' production: PackratParser[Int] = {...}`
 *   - Important: using `PackratParser`s is not an ''all or nothing'' decision.
 *     They can be free mixed with regular `Parser`s in a single grammar.
 *
 *  Cached parse results are attached to the ''input'', not the grammar.
 *  Therefore, `PackratsParser`s require a `PackratReader` as input, which
 *  adds memoization to an underlying `Reader`. Programmers can create
 *  `PackratReader` objects either manually, as in
 *  `production('''new''' PackratReader('''new''' lexical.Scanner(&quot;input&quot;)))`,
 *  but the common way should be to rely on the combinator `phrase` to wrap
 *  a given input with a `PackratReader` if the input is not one itself.
 *
 * @see Bryan Ford: &quot;Packrat Parsing: Simple, Powerful, Lazy, Linear Time.&quot; ICFP'02
 * @see Alessandro Warth, James R. Douglass, Todd Millstein: &quot;Packrat Parsers Can Support Left Recursion.&quot; PEPM'08
 *
 * @since 2.8
 * @author Manohar Jonnalagedda
 * @author Tiark Rompf
 */

<span class="keyword">trait</span> <a title="trait PackratParsers extends Object with scala.util.parsing.combinator.Parsers" id="52906">PackratParsers</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="Parsers.scala.html#52870" title="scala.util.parsing.combinator.Parsers">Parsers</a> <span class="delimiter">{</span>

  //type Input = PackratReader[Elem]

  /**
   * A specialized `Reader` class that wraps an underlying `Reader`
   * and provides memoization of parse results.
   */
  <span class="keyword">class</span> <a title="class PackratReader[+T] extends scala.util.parsing.input.Reader[T]" id="1236753">PackratReader</a><span class="delimiter">[</span>+<a title="" id="1236754">T</a><span class="delimiter">]</span><a href="#1236753" title="PackratParsers.this.PackratReader[T]" class="delimiter">(</a><a title="scala.util.parsing.input.Reader[T]" id="1236828">underlying</a>: <a href="../input/Reader.scala.html#53418" title="scala.util.parsing.input.Reader[T]">Reader</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="../input/Reader.scala.html#53418" title="scala.util.parsing.input.Reader[T]">Reader</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> outer =&gt;

    /*
     * caching of intermediate parse results and information about recursion
     */
    <span class="keyword">private</span><span class="delimiter">[</span>PackratParsers<span class="delimiter">]</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(PackratParsers.this.Parser[_], scala.util.parsing.input.Position),PackratParsers.this.MemoEntry[_]]" id="1236791">cache</a> = mutable.<a href="../../../collection/mutable/HashMap.scala.html#12448" title="scala.collection.mutable.HashMap.type">HashMap</a>.<a href="../../../collection/mutable/HashMap.scala.html#153384" title="[A, B]=&gt; scala.collection.mutable.HashMap[A,B]">empty</a><span title="scala.collection.mutable.HashMap[(PackratParsers.this.Parser[_], scala.util.parsing.input.Position),PackratParsers.this.MemoEntry[_]]" class="delimiter">[</span><a href="../../../Tuple2.scala.html#783" title="(PackratParsers.this.Parser[_], scala.util.parsing.input.Position)" class="delimiter">(</a>Parser<span class="delimiter">[</span>_<span class="delimiter">]</span>, Position<span class="delimiter">)</span>, <a href="#1237931" title="PackratParsers.this.MemoEntry[_]">MemoEntry</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>

    <span class="keyword">private</span><span class="delimiter">[</span>PackratParsers<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](p: PackratParsers.this.Parser[T])Option[PackratParsers.this.MemoEntry[T]]" id="1236793">getFromCache</a><span class="delimiter">[</span><a title="" id="1236795">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PackratParsers.this.Parser[T]" id="1236829">p</a>: <a href="Parsers.scala.html#600862" title="PackratParsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[PackratParsers.this.MemoEntry[T]]">Option</a><span class="delimiter">[</span>MemoEntry<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#1236791" title="=&gt; scala.collection.mutable.HashMap[(PackratParsers.this.Parser[_], scala.util.parsing.input.Position),PackratParsers.this.MemoEntry[_]]">cache</a>.<a href="../../../collection/mutable/HashMap.scala.html#88246" title="(key: (PackratParsers.this.Parser[_], scala.util.parsing.input.Position))Option[PackratParsers.this.MemoEntry[_]]">get</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#62849" title="(_1: PackratParsers.this.Parser[T], _2: scala.util.parsing.input.Position)(PackratParsers.this.Parser[T], scala.util.parsing.input.Position)" class="delimiter">(</a><a href="#1236829" title="PackratParsers.this.Parser[T]">p</a>, <a href="#1236808" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Option[PackratParsers.this.MemoEntry[T]]" class="delimiter">[</span><a href="../../../Option.scala.html#978" title="Option[PackratParsers.this.MemoEntry[T]]">Option</a><span class="delimiter">[</span>MemoEntry<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span><span class="delimiter">[</span>PackratParsers<span class="delimiter">]</span> <span class="keyword">def</span> <a title="[T](p: PackratParsers.this.Parser[T], w: PackratParsers.this.MemoEntry[T])PackratParsers.this.MemoEntry[T]" id="1236796">updateCacheAndGet</a><span class="delimiter">[</span><a title="" id="1236798">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PackratParsers.this.Parser[T]" id="1236843">p</a>: <a href="Parsers.scala.html#600862" title="PackratParsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="PackratParsers.this.MemoEntry[T]" id="1236844">w</a>: <a href="#1237931" title="PackratParsers.this.MemoEntry[T]">MemoEntry</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#1237931" title="PackratParsers.this.MemoEntry[T]">MemoEntry</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#1236791" title="=&gt; scala.collection.mutable.HashMap[(PackratParsers.this.Parser[_], scala.util.parsing.input.Position),PackratParsers.this.MemoEntry[_]]">cache</a>.<a href="../../../collection/mutable/HashMap.scala.html#88247" title="(key: (PackratParsers.this.Parser[_], scala.util.parsing.input.Position), value: PackratParsers.this.MemoEntry[_])Option[PackratParsers.this.MemoEntry[_]]">put</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#62849" title="(_1: PackratParsers.this.Parser[T], _2: scala.util.parsing.input.Position)(PackratParsers.this.Parser[T], scala.util.parsing.input.Position)" class="delimiter">(</a><a href="#1236843" title="PackratParsers.this.Parser[T]">p</a>, <a href="#1236808" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span>,<a href="#1236844" title="PackratParsers.this.MemoEntry[T]">w</a><span class="delimiter">)</span>
      <a href="#1236844" title="PackratParsers.this.MemoEntry[T]">w</a>
    <span class="delimiter">}</span>

    /* a cache for storing parser heads: allows to know which parser is involved
       in a recursion*/
    <span class="keyword">private</span><span class="delimiter">[</span>PackratParsers<span class="delimiter">]</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]" id="1236799">recursionHeads</a>: mutable.<a href="../../../collection/mutable/HashMap.scala.html#12447" title="scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]">HashMap</a><span class="delimiter">[</span>Position, Head<span class="delimiter">]</span> = mutable.<a href="../../../collection/mutable/HashMap.scala.html#12448" title="scala.collection.mutable.HashMap.type">HashMap</a>.<a href="../../../collection/mutable/HashMap.scala.html#153384" title="scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]">empty</a>

    //a stack that keeps a list of all involved rules
    <span class="keyword">private</span><span class="delimiter">[</span>PackratParsers<span class="delimiter">]</span> <span class="keyword">var</span> <a title="List[PackratParsers.this.LR]" id="1236802">lrStack</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PackratParsers.this.LR]">List</a><span class="delimiter">[</span>LR<span class="delimiter">]</span> = <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; CharSequence" id="1236804">source</a>: java.lang.<span title="CharSequence">CharSequence</span> = <a href="#1236828" title="scala.util.parsing.input.Reader[T]">underlying</a>.<a href="../input/Reader.scala.html#611234" title="=&gt; CharSequence">source</a>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Int" id="1236805">offset</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a> = <a href="#1236828" title="scala.util.parsing.input.Reader[T]">underlying</a>.<a href="../input/Reader.scala.html#611235" title="=&gt; Int">offset</a>

    <span class="keyword">def</span> <a title="=&gt; T" id="1236806">first</a>: <a href="#1236754" title="T">T</a> = <a href="#1236828" title="scala.util.parsing.input.Reader[T]">underlying</a>.<a href="../input/Reader.scala.html#611236" title="=&gt; T">first</a>
    <span class="keyword">def</span> <a title="=&gt; scala.util.parsing.input.Reader[T]" id="1236807">rest</a>: <a href="../input/Reader.scala.html#53418" title="scala.util.parsing.input.Reader[T]">Reader</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#1236899" title="PackratParsers.this.PackratReader[T]{}" class="keyword">new</a> <a title="anonymous class $anon extends PackratParsers.this.PackratReader[T]" id="1236899">PackratReader</a><span class="delimiter">(</span><a href="#1236828" title="scala.util.parsing.input.Reader[T]">underlying</a>.<a href="../input/Reader.scala.html#611237" title="=&gt; scala.util.parsing.input.Reader[T]">rest</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">private</span><span class="delimiter">[</span>PackratParsers<span class="delimiter">]</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(PackratParsers.this.Parser[_], scala.util.parsing.input.Position),PackratParsers.this.MemoEntry[_]]" id="1236904">cache</a> = <a href="#1236753" title="PackratReader.this.type">outer</a>.<a href="#1236791" title="=&gt; scala.collection.mutable.HashMap[(PackratParsers.this.Parser[_], scala.util.parsing.input.Position),PackratParsers.this.MemoEntry[_]]">cache</a>
      <span class="keyword">override</span> <span class="keyword">private</span><span class="delimiter">[</span>PackratParsers<span class="delimiter">]</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]" id="1236906">recursionHeads</a> = <a href="#1236753" title="PackratReader.this.type">outer</a>.<a href="#1236799" title="=&gt; scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]">recursionHeads</a>
      <a href="#1236802" title="(x$1: List[PackratParsers.this.LR])Unit">lrStack</a> = <a href="#1236753" title="PackratReader.this.type">outer</a>.<a href="#1236802" title="=&gt; List[PackratParsers.this.LR]">lrStack</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="=&gt; scala.util.parsing.input.Position" id="1236808">pos</a>: <a href="../input/Position.scala.html#53442" title="scala.util.parsing.input.Position">Position</a> = <a href="#1236828" title="scala.util.parsing.input.Reader[T]">underlying</a>.<a href="../input/Reader.scala.html#611239" title="=&gt; scala.util.parsing.input.Position">pos</a>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="1236809">atEnd</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <a href="#1236828" title="scala.util.parsing.input.Reader[T]">underlying</a>.<a href="../input/Reader.scala.html#611240" title="=&gt; Boolean">atEnd</a>
  <span class="delimiter">}</span>

  /**
   *  A parser generator delimiting whole phrases (i.e. programs).
   *
   *  Overridden to make sure any input passed to the argument parser
   *  is wrapped in a `PackratReader`.
   */
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="[T](p: PackratParsers.this.Parser[T])PackratParsers.this.PackratParser[T]" id="1236755">phrase</a><span class="delimiter">[</span><a title="" id="1236757">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PackratParsers.this.Parser[T]" id="1236913">p</a>: <a href="Parsers.scala.html#600862" title="PackratParsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="PackratParsers.this.Parser[T]" id="1236922">q</a> = <a href="#52906" title="scala.util.parsing.combinator.PackratParsers" class="keyword">super</a>.<a href="Parsers.scala.html#600934" title="(p: PackratParsers.this.Parser[T])PackratParsers.this.Parser[T]">phrase</a><span class="delimiter">(</span><a href="#1236913" title="PackratParsers.this.Parser[T]">p</a><span class="delimiter">)</span>
    <a href="#1236928" title="PackratParsers.this.PackratParser[T]" class="keyword">new</a> <a title="anonymous class $anon extends PackratParsers.this.PackratParser[T]" id="1236928">PackratParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[T]" id="1236932">apply</a><span class="delimiter">(</span><a title="PackratParsers.this.Input" id="1236938">in</a>: <a href="../input/Reader.scala.html#53418" title="PackratParsers.this.Input">Input</a><span class="delimiter">)</span> = <a href="#1236938" title="PackratParsers.this.Input">in</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="../../../Boolean.scala.html#57826" title="PackratParsers.this.ParseResult[T]" id="3383684">in</a>: PackratReader<span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="Parsers.scala.html#611247" title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[T]">q</a><a href="#3383686" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="delimiter">(</a>in<span class="delimiter">)</span>
        <span class="keyword">case</span> in =&gt; <a href="Parsers.scala.html#611247" title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[T]">q</a><a href="#3383686" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="delimiter">(</a><span title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]" class="keyword">new</span> <a href="#1236753" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">PackratReader</a><span class="delimiter">(</span>in<span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(r: PackratParsers.this.ParseResult[_])scala.util.parsing.input.Position" id="1236758">getPosFromResult</a><span class="delimiter">(</span><a title="PackratParsers.this.ParseResult[_]" id="1236997">r</a>: <a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[_]">ParseResult</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../input/Position.scala.html#53442" title="scala.util.parsing.input.Position">Position</a> = <a href="#1236997" title="PackratParsers.this.ParseResult[_]">r</a>.<a href="Parsers.scala.html#611597" title="=&gt; PackratParsers.this.Input">next</a>.<a href="../input/Reader.scala.html#611239" title="=&gt; scala.util.parsing.input.Position">pos</a>

  // auxiliary data structures

  <span class="keyword">private</span> case <span class="keyword">class</span> <a href="#1237097" title="class MemoEntry[+T] extends AnyRef with Product with Serializable" id="1237931">MemoEntry</a><span class="delimiter">[</span>+<a title="" id="1237449">T</a><span class="delimiter">]</span><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><span class="keyword">var</span> <a title="Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]]" id="1237450">r</a>: <a href="../../Either.scala.html#7222" title="Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]]">Either</a><span class="delimiter">[</span>LR,ParseResult<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; PackratParsers.this.ParseResult[T]" id="1236821">getResult</a>: <a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#1237450" title="=&gt; Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]]">r</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Left<a href="#3383691" title="PackratParsers.this.ParseResult[T]" id="3383693" class="delimiter">(</a>LR<a href="../../Either.scala.html#97650" title="PackratParsers.this.LR" id="3383692" class="delimiter">(</a><a href="#1237707" title="PackratParsers.this.ParseResult[_]" id="1237069">res</a>,<a href="#1237708" title="PackratParsers.this.Parser[_]" id="3383694">_</a>,<a href="#1237709" title="Option[PackratParsers.this.Head]" id="3383695">_</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#1237069" title="PackratParsers.this.ParseResult[_]">res</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><a href="#3383698" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="delimiter">[</a><a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="keyword">case</span> Right<a href="#3383691" title="PackratParsers.this.ParseResult[T]" id="3383696" class="delimiter">(</a><a href="../../Either.scala.html#97679" title="PackratParsers.this.ParseResult[_]" id="1237079">res</a><span class="delimiter">)</span> =&gt; <a href="#1237079" title="PackratParsers.this.ParseResult[_]">res</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><a href="#3383698" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="delimiter">[</a><a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> case <span class="keyword">class</span> <a title="class LR extends AnyRef with Product with Serializable" id="1237947">LR</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><span class="keyword">var</span> <a title="PackratParsers.this.ParseResult[_]" id="1237707">seed</a>: <a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[_]">ParseResult</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <span class="keyword">var</span> <a title="PackratParsers.this.Parser[_]" id="1237708">rule</a>: <a href="Parsers.scala.html#600862" title="PackratParsers.this.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <span class="keyword">var</span> <a title="Option[PackratParsers.this.Head]" id="1237709">head</a>: <a href="../../../Option.scala.html#978" title="Option[PackratParsers.this.Head]">Option</a><span class="delimiter">[</span>Head<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; scala.util.parsing.input.Position" id="1236897">getPos</a>: <a href="../input/Position.scala.html#53442" title="scala.util.parsing.input.Position">Position</a> = <a href="#1236758" title="(r: PackratParsers.this.ParseResult[_])scala.util.parsing.input.Position">getPosFromResult</a><span class="delimiter">(</span><a href="#1237707" title="=&gt; PackratParsers.this.ParseResult[_]">seed</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> case <span class="keyword">class</span> <a title="class Head extends AnyRef with Product with Serializable" id="1237969">Head</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><span class="keyword">var</span> <a title="PackratParsers.this.Parser[_]" id="1237533">headParser</a>: <a href="Parsers.scala.html#600862" title="PackratParsers.this.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <span class="keyword">var</span> <a title="List[PackratParsers.this.Parser[_]]" id="1237534">involvedSet</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PackratParsers.this.Parser[_]]">List</a><span class="delimiter">[</span>Parser<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>, <span class="keyword">var</span> <a title="List[PackratParsers.this.Parser[_]]" id="1237535">evalSet</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PackratParsers.this.Parser[_]]">List</a><span class="delimiter">[</span>Parser<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; PackratParsers.this.Parser[Any]" id="1236882">getHead</a> = <a href="#1237533" title="=&gt; PackratParsers.this.Parser[_]">headParser</a>
  <span class="delimiter">}</span>

  /**
   * The root class of packrat parsers.
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class PackratParser[+T] extends PackratParsers.this.Parser[T]" id="1236769">PackratParser</a><span class="delimiter">[</span>+<a title="" id="1236770">T</a><span class="delimiter">]</span> <a href="#1236769" title="PackratParsers.this.PackratParser[T]" class="keyword">extends</a> <span class="keyword">super</span>.<a href="Parsers.scala.html#600862" title="PackratParsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  /**
   * Implicitly convert a parser to a packrat parser.
   * The conversion is triggered by giving the appropriate target type:
   * {{{
   *   val myParser: PackratParser[MyResult] = aParser
   * }}} */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](p: =&gt; PackratParsers.this.Parser[T])PackratParsers.this.PackratParser[T]" id="1236771">parser2packrat</a><span class="delimiter">[</span><a title="" id="1236773">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; PackratParsers.this.Parser[T]" id="1237316">p</a>: =&gt; <span class="keyword">super</span>.Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#1236769" title="PackratParsers.this.PackratParser[T]">PackratParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="PackratParsers.this.Parser[T]" id="1237321">q</a> = <a href="#1237316" title="=&gt; PackratParsers.this.Parser[T]">p</a>
    <a href="#1236779" title="(p: PackratParsers.this.Parser[T])PackratParsers.this.PackratParser[T]">memo</a><span class="delimiter">(</span><a href="#52906" title="scala.util.parsing.combinator.PackratParsers" class="keyword">super</a>.<a href="Parsers.scala.html#600856" title="(f: PackratParsers.this.Input =&gt; PackratParsers.this.ParseResult[T])PackratParsers.this.Parser[T]">Parser</a> <span class="delimiter">{</span><a title="PackratParsers.this.Input" id="1237333">in</a> =&gt; <a href="Parsers.scala.html#611247" title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[T]">q</a><span class="delimiter">(</span><a href="#1237333" title="PackratParsers.this.Input">in</a><span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /*
   * An unspecified function that is called when a packrat reader is applied.
   * It verifies whether we are in the process of growing a parse or not.
   * In the former case, it makes sure that rules involved in the recursion are evaluated.
   * It also prevents non-involved rules from getting evaluated further
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(p: PackratParsers.this.Parser[_], in: PackratParsers.this.PackratReader[PackratParsers.this.Elem])Option[PackratParsers.this.MemoEntry[_]]" id="1236774">recall</a><span class="delimiter">(</span><a title="PackratParsers.this.Parser[_]" id="1237347">p</a>: <span class="keyword">super</span>.<a href="Parsers.scala.html#600862" title="PackratParsers.this.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]" id="1237348">in</a>: <a href="#1236753" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">PackratReader</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[PackratParsers.this.MemoEntry[_]]">Option</a><span class="delimiter">[</span>MemoEntry<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Option[PackratParsers.this.MemoEntry[Any]]" id="1237358">cached</a> = <a href="#1237348" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">in</a>.<a href="#1236793" title="(p: PackratParsers.this.Parser[_$10])Option[PackratParsers.this.MemoEntry[_$10]]">getFromCache</a><span class="delimiter">(</span><a href="#1237347" title="PackratParsers.this.Parser[_]">p</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Option[PackratParsers.this.Head]" id="1237359">head</a> = <a href="#1237348" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">in</a>.<a href="#1236799" title="=&gt; scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]">recursionHeads</a>.<a href="../../../collection/mutable/HashMap.scala.html#88246" title="(key: scala.util.parsing.input.Position)Option[PackratParsers.this.Head]">get</a><span class="delimiter">(</span><a href="#1237348" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">in</a>.<a href="#1236808" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span>

    <a href="#1237359" title="Option[PackratParsers.this.Head]">head</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="../../../Option.scala.html#1585" title="Option[PackratParsers.this.MemoEntry[_]]" id="3383795">None</a> =&gt; /*no heads*/ <a href="#3383797" title="(x: Option[PackratParsers.this.MemoEntry[_]])Option[PackratParsers.this.MemoEntry[_]]">cached</a>
      <span class="keyword">case</span> Some<a href="#3383792" title="Option[PackratParsers.this.MemoEntry[_]]" id="3383794" class="delimiter">(</a><a href="../../../Option.scala.html#63132" title="PackratParsers.this.Head" id="1237370">h</a>@Head<span class="delimiter">(</span><a href="#1237533" title="PackratParsers.this.Parser[_]" id="1237415">hp</a>, <a href="#1237534" title="List[PackratParsers.this.Parser[_]]" id="1237421">involved</a>, <a href="#1237535" title="List[PackratParsers.this.Parser[_]]" id="1237422">evalSet</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#3383797" title="(x: Option[PackratParsers.this.MemoEntry[_]])Option[PackratParsers.this.MemoEntry[_]]" class="delimiter">{</a>
        //heads found
        <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#1237358" title="Option[PackratParsers.this.MemoEntry[Any]]">cached</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../Option.scala.html#1585" title="None.type">None</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#1237415" title="PackratParsers.this.Parser[_]">hp</a><a href="../../../collection/immutable/List.scala.html#62685" title="(x: PackratParsers.this.Parser[_])List[PackratParsers.this.Parser[_]]">::</a><a href="#1237421" title="List[PackratParsers.this.Parser[_]]">involved</a> <a href="../../../collection/LinearSeqOptimized.scala.html#86380" title="(elem: Any)Boolean">contains</a> <a href="#1237347" title="PackratParsers.this.Parser[_]">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          //Nothing in the cache, and p is not involved
          <span title="Nothing" class="keyword">return</span> <a href="../../../Option.scala.html#63128" title="(x: PackratParsers.this.MemoEntry[Nothing])Some[PackratParsers.this.MemoEntry[Nothing]]">Some</a><span class="delimiter">(</span><a href="#1237931" title="(r: Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]])PackratParsers.this.MemoEntry[Nothing]">MemoEntry</a><span class="delimiter">(</span><a href="../../Either.scala.html#97673" title="(b: PackratParsers.this.Failure)scala.util.Right[Nothing,PackratParsers.this.Failure]">Right</a><span class="delimiter">(</span><a href="Parsers.scala.html#611577" title="(msg: String, next: PackratParsers.this.Input)PackratParsers.this.Failure">Failure</a><span class="delimiter">(</span><span title="String(&quot;dummy &quot;)" class="string">&quot;dummy &quot;</span>,<a href="#1237348" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">in</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#1237422" title="List[PackratParsers.this.Parser[_]]">evalSet</a> <a href="../../../collection/LinearSeqOptimized.scala.html#86380" title="(elem: Any)Boolean">contains</a> <a href="#1237347" title="PackratParsers.this.Parser[_]">p</a><span class="delimiter">)</span><span class="delimiter">{</span>
          //something in cache, and p is in the evalSet
          //remove the rule from the evalSet of the Head
          <a href="#1237370" title="PackratParsers.this.Head">h</a>.<a href="#1237535" title="(x$1: List[PackratParsers.this.Parser[_]])Unit">evalSet</a> = <a href="#1237370" title="PackratParsers.this.Head">h</a>.<a href="#1237535" title="=&gt; List[PackratParsers.this.Parser[_]]">evalSet</a>.<a href="../../../collection/TraversableLike.scala.html#58074" title="(p: PackratParsers.this.Parser[_] =&gt; Boolean)List[PackratParsers.this.Parser[_]]">filterNot</a><span class="delimiter">(</span><a href="#1237481" title="PackratParsers.this.Parser[_]">_</a><span title="(x$1: AnyRef)Boolean">==</span><a href="#1237347" title="PackratParsers.this.Parser[_]">p</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="PackratParsers.this.ParseResult[Any]" id="1237474">tempRes</a> = <a href="Parsers.scala.html#611247" title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[_$10]">p</a><span class="delimiter">(</span><a href="#1237348" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">in</a><span class="delimiter">)</span>
          //we know that cached has an entry here
          <span class="keyword">val</span> <a title="PackratParsers.this.MemoEntry[_]" id="1237475">tempEntry</a>: <a href="#1237931" title="PackratParsers.this.MemoEntry[_]">MemoEntry</a><span class="delimiter">[</span>_<span class="delimiter">]</span> = <a href="#1237358" title="Option[PackratParsers.this.MemoEntry[Any]]">cached</a>.<a href="../../../Option.scala.html#62858" title="=&gt; PackratParsers.this.MemoEntry[Any]">get</a> // match {case Some(x: MemoEntry[_]) =&gt; x}
          //cache is modified
          <a href="#1237475" title="PackratParsers.this.MemoEntry[_]">tempEntry</a>.<a href="#1237450" title="(x$1: Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]])Unit">r</a> = <a href="../../Either.scala.html#97673" title="(b: PackratParsers.this.ParseResult[Any])scala.util.Right[Nothing,PackratParsers.this.ParseResult[Any]]">Right</a><span class="delimiter">(</span><a href="#1237474" title="PackratParsers.this.ParseResult[Any]">tempRes</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#1237358" title="Option[PackratParsers.this.MemoEntry[Any]]">cached</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /*
   * setting up the left-recursion. We have the LR for the rule head
   * we modify the involvedSets of all LRs in the stack, till we see
   * the current parser again
   */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(p: PackratParsers.this.Parser[_], in: PackratParsers.this.PackratReader[_], recDetect: PackratParsers.this.LR)Unit" id="1236775">setupLR</a><span class="delimiter">(</span><a title="PackratParsers.this.Parser[_]" id="1237516">p</a>: <a href="Parsers.scala.html#600862" title="PackratParsers.this.Parser[_]">Parser</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="PackratParsers.this.PackratReader[_]" id="1237517">in</a>: <a href="#1236753" title="PackratParsers.this.PackratReader[_]">PackratReader</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="PackratParsers.this.LR" id="1237518">recDetect</a>: <a href="#1237947" title="PackratParsers.this.LR">LR</a><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#1515" title="Unit">Unit</a> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#1237518" title="PackratParsers.this.LR">recDetect</a>.<a href="#1237709" title="=&gt; Option[PackratParsers.this.Head]">head</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../Option.scala.html#1585" title="None.type">None</a><span class="delimiter">)</span> <a href="#1237518" title="PackratParsers.this.LR">recDetect</a>.<a href="#1237709" title="(x$1: Option[PackratParsers.this.Head])Unit">head</a> = <a href="../../../Option.scala.html#63128" title="(x: PackratParsers.this.Head)Some[PackratParsers.this.Head]">Some</a><span class="delimiter">(</span><a href="#1237969" title="(headParser: PackratParsers.this.Parser[_], involvedSet: List[PackratParsers.this.Parser[_]], evalSet: List[PackratParsers.this.Parser[_]])PackratParsers.this.Head">Head</a><span class="delimiter">(</span><a href="#1237516" title="PackratParsers.this.Parser[_]">p</a>, <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <a href="#1237517" title="PackratParsers.this.PackratReader[_]">in</a>.<a href="#1236802" title="=&gt; List[PackratParsers.this.LR]">lrStack</a>.<a href="../../../collection/immutable/List.scala.html#62713" title="(p: PackratParsers.this.LR =&gt; Boolean)List[PackratParsers.this.LR]">takeWhile</a><span class="delimiter">(</span><a href="#1237561" title="PackratParsers.this.LR">_</a>.<a href="#1237708" title="=&gt; PackratParsers.this.Parser[_]">rule</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#1237516" title="PackratParsers.this.Parser[_]">p</a><span class="delimiter">)</span>.<a href="../../../collection/immutable/List.scala.html#62719" title="(f: PackratParsers.this.LR =&gt; Option[Unit])Unit">foreach</a> <span class="delimiter">{</span><a title="PackratParsers.this.LR" id="1237591">x</a> =&gt;
      <a href="#1237591" title="PackratParsers.this.LR">x</a>.<a href="#1237709" title="(x$1: Option[PackratParsers.this.Head])Unit">head</a> = <a href="#1237518" title="PackratParsers.this.LR">recDetect</a>.<a href="#1237709" title="=&gt; Option[PackratParsers.this.Head]">head</a>
      <a href="#1237518" title="PackratParsers.this.LR">recDetect</a>.<a href="#1237709" title="=&gt; Option[PackratParsers.this.Head]">head</a>.<a href="../../../Option.scala.html#62865" title="(f: PackratParsers.this.Head =&gt; Unit)Option[Unit]">map</a><span class="delimiter">(</span><a title="PackratParsers.this.Head" id="1237596">h</a> =&gt; <a href="#1237596" title="PackratParsers.this.Head">h</a>.<a href="#1237534" title="(x$1: List[PackratParsers.this.Parser[_]])Unit">involvedSet</a> = <a href="#1237591" title="PackratParsers.this.LR">x</a>.<a href="#1237708" title="=&gt; PackratParsers.this.Parser[_]">rule</a><a href="../../../collection/immutable/List.scala.html#62685" title="(x: PackratParsers.this.Parser[_])List[PackratParsers.this.Parser[_]]">::</a><a href="#1237596" title="PackratParsers.this.Head">h</a>.<a href="#1237534" title="=&gt; List[PackratParsers.this.Parser[_]]">involvedSet</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /*
   * growing, if needed the recursion
   * check whether the parser we are growing is the head of the rule.
   * Not =&gt; no grow
   */

  /*
   * Once the result of the recall function is known, if it is nil, then we need to store a dummy
failure into the cache (much like in the previous listings) and compute the future parse. If it
is not, however, this means we have detected a recursion, and we use the setupLR function
to update each parser involved in the recursion.
   */

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T](p: PackratParsers.this.Parser[T], in: PackratParsers.this.PackratReader[PackratParsers.this.Elem], growable: PackratParsers.this.LR)PackratParsers.this.ParseResult[T]" id="1236776">lrAnswer</a><span class="delimiter">[</span><a title="" id="1236778">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PackratParsers.this.Parser[T]" id="1237618">p</a>: <a href="Parsers.scala.html#600862" title="PackratParsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]" id="1237619">in</a>: <a href="#1236753" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">PackratReader</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span>, <a title="PackratParsers.this.LR" id="1237620">growable</a>: <a href="#1237947" title="PackratParsers.this.LR">LR</a><span class="delimiter">)</span>: <a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#1237620" title="PackratParsers.this.LR">growable</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    //growable will always be having a head, we can't enter lrAnswer otherwise
    <span class="keyword">case</span> LR<span class="delimiter">(</span><a href="#1237707" title="PackratParsers.this.ParseResult[_]" id="1237625">seed</a> ,<a href="#1237708" title="PackratParsers.this.Parser[_]" id="1237631">rule</a>, Some<a href="#1237709" title="Option[PackratParsers.this.Head]" id="3383833" class="delimiter">(</a><a href="../../../Option.scala.html#63132" title="PackratParsers.this.Head" id="1237638">head</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
      <a href="#3383835" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="keyword">if</a><span class="delimiter">(</span><a href="#1237638" title="PackratParsers.this.Head">head</a>.<a href="#1236882" title="=&gt; PackratParsers.this.Parser[Any]">getHead</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#1237618" title="PackratParsers.this.Parser[T]">p</a><span class="delimiter">)</span> /*not head rule, so not growing*/ <a href="#1237625" title="PackratParsers.this.ParseResult[_]">seed</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PackratParsers.this.ParseResult[T]" class="delimiter">[</span><a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <a href="#1237619" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">in</a>.<a href="#1236796" title="(p: PackratParsers.this.Parser[T], w: PackratParsers.this.MemoEntry[T])PackratParsers.this.MemoEntry[T]">updateCacheAndGet</a><span class="delimiter">(</span><a href="#1237618" title="PackratParsers.this.Parser[T]">p</a>, <a href="#1237931" title="(r: Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]])PackratParsers.this.MemoEntry[Nothing]">MemoEntry</a><span class="delimiter">(</span><a href="../../Either.scala.html#97673" title="[A, B](b: B)scala.util.Right[A,B]">Right</a><span title="(b: PackratParsers.this.ParseResult[T])scala.util.Right[PackratParsers.this.LR,PackratParsers.this.ParseResult[T]]" class="delimiter">[</span><a href="#1237947" title="PackratParsers.this.LR">LR</a>, <a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#1237625" title="PackratParsers.this.ParseResult[_]">seed</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PackratParsers.this.ParseResult[T]" class="delimiter">[</span><a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#1237625" title="PackratParsers.this.ParseResult[_]">seed</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> f@Failure<a href="#3383811" title="PackratParsers.this.ParseResult[T]" id="3383815" class="delimiter">(</a><a href="Parsers.scala.html#611621" title="String" id="3383812">_</a>,<a href="Parsers.scala.html#611623" title="PackratParsers.this.Input" id="3383813">_</a><span class="delimiter">)</span> =&gt; <a href="#3383825" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]">f</a>
          <span class="keyword">case</span> e@Error<a href="#3383811" title="PackratParsers.this.ParseResult[T]" id="3383819" class="delimiter">(</a><a href="Parsers.scala.html#611943" title="String" id="3383816">_</a>,<a href="Parsers.scala.html#611945" title="PackratParsers.this.Input" id="3383817">_</a><span class="delimiter">)</span> =&gt; <a href="#3383825" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]">e</a>
          <span class="keyword">case</span> s@Success<a href="#3383811" title="PackratParsers.this.ParseResult[T]" id="3383823" class="delimiter">(</a><a href="Parsers.scala.html#611700" title="Any" id="3383820">_</a>,<a href="Parsers.scala.html#611702" title="PackratParsers.this.Input" id="3383821">_</a><span class="delimiter">)</span> =&gt; /*growing*/ <a href="#1236782" title="(p: PackratParsers.this.Parser[T], rest: PackratParsers.this.PackratReader[PackratParsers.this.Elem], head: PackratParsers.this.Head)PackratParsers.this.ParseResult[T]">grow</a><a href="#3383825" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="delimiter">(</a><a href="#1237618" title="PackratParsers.this.Parser[T]">p</a>, <a href="#1237619" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">in</a>, <a href="#1237638" title="PackratParsers.this.Head">head</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> _=&gt; <a href="#3383835" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="keyword">throw</a> <span title="(x$1: String)Exception" class="keyword">new</span> <a href="../../../package.scala.html#55500" title="Exception">Exception</a><span class="delimiter">(</span><span title="String(&quot;lrAnswer with no head !!&quot;)" class="string">&quot;lrAnswer with no head !!&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  //p here should be strict (cannot be non-strict) !!
  //failing left-recursive grammars: This is done by simply storing a failure if nothing is found

  /**
   * Explicitly convert a given parser to a memoizing packrat parser.
   * In most cases, client code should avoid calling `memo` directly
   * and rely on implicit conversion instead.
   */
  <span class="keyword">def</span> <a title="[T](p: PackratParsers.this.Parser[T])PackratParsers.this.PackratParser[T]" id="1236779">memo</a><span class="delimiter">[</span><a title="" id="1236781">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PackratParsers.this.Parser[T]" id="1237322">p</a>: <span class="keyword">super</span>.<a href="Parsers.scala.html#600862" title="PackratParsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#1236769" title="PackratParsers.this.PackratParser[T]">PackratParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#1237686" title="PackratParsers.this.PackratParser[T]" class="keyword">new</a> <a title="anonymous class $anon extends PackratParsers.this.PackratParser[T]" id="1237686">PackratParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[T]" id="1237688">apply</a><span class="delimiter">(</span><a title="PackratParsers.this.Input" id="1237692">in</a>: <a href="../input/Reader.scala.html#53418" title="PackratParsers.this.Input">Input</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        /*
         * transformed reader
         */
        <span class="keyword">val</span> <a title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]" id="1237701">inMem</a> = <a href="#1237692" title="PackratParsers.this.Input">in</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]" class="delimiter">[</span><a href="#1236753" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">PackratReader</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span><span class="delimiter">]</span>

        //look in the global cache if in a recursion
        <span class="keyword">val</span> <a title="Option[PackratParsers.this.MemoEntry[_]]" id="1237702">m</a> = <a href="#1236774" title="(p: PackratParsers.this.Parser[_], in: PackratParsers.this.PackratReader[PackratParsers.this.Elem])Option[PackratParsers.this.MemoEntry[_]]">recall</a><span class="delimiter">(</span><a href="#1237322" title="PackratParsers.this.Parser[T]">p</a>, <a href="#1237701" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a><span class="delimiter">)</span>
        <a href="#1237702" title="Option[PackratParsers.this.MemoEntry[_]]">m</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          //nothing has been done due to recall
          <span class="keyword">case</span> <a href="../../../Option.scala.html#1585" title="PackratParsers.this.ParseResult[T]" id="3383905">None</a> =&gt;
            <span class="keyword">val</span> <a title="PackratParsers.this.LR" id="1237705">base</a> = <a href="#1237947" title="(seed: PackratParsers.this.ParseResult[_], rule: PackratParsers.this.Parser[_], head: Option[PackratParsers.this.Head])PackratParsers.this.LR">LR</a><span class="delimiter">(</span><a href="Parsers.scala.html#611577" title="(msg: String, next: PackratParsers.this.Input)PackratParsers.this.Failure">Failure</a><span class="delimiter">(</span><span title="String(&quot;Base Failure&quot;)" class="string">&quot;Base Failure&quot;</span>,<a href="#1237692" title="PackratParsers.this.Input">in</a><span class="delimiter">)</span>, <a href="#1237322" title="PackratParsers.this.Parser[T]">p</a>, <a href="../../../Option.scala.html#1585" title="None.type">None</a><span class="delimiter">)</span>
            <a href="#1237701" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>.<a href="#1236802" title="(x$1: List[PackratParsers.this.LR])Unit">lrStack</a> = <a href="#1237705" title="PackratParsers.this.LR">base</a><a href="../../../collection/immutable/List.scala.html#62685" title="(x: PackratParsers.this.LR)List[PackratParsers.this.LR]">::</a><a href="#1237701" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>.<a href="#1236802" title="=&gt; List[PackratParsers.this.LR]">lrStack</a>
            //cache base result
            <a href="#1237701" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>.<a href="#1236796" title="(p: PackratParsers.this.Parser[T], w: PackratParsers.this.MemoEntry[T])PackratParsers.this.MemoEntry[T]">updateCacheAndGet</a><span class="delimiter">(</span><a href="#1237322" title="PackratParsers.this.Parser[T]">p</a>,<a href="#1237931" title="(r: Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]])PackratParsers.this.MemoEntry[Nothing]">MemoEntry</a><span class="delimiter">(</span><a href="../../Either.scala.html#97621" title="(a: PackratParsers.this.LR)scala.util.Left[PackratParsers.this.LR,Nothing]">Left</a><span class="delimiter">(</span><a href="#1237705" title="PackratParsers.this.LR">base</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            //parse the input
            <span class="keyword">val</span> <a title="PackratParsers.this.ParseResult[T]" id="1237706">tempRes</a> = <a href="Parsers.scala.html#611247" title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#1237692" title="PackratParsers.this.Input">in</a><span class="delimiter">)</span>
            //the base variable has passed equality tests with the cache
            <a href="#1237701" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>.<a href="#1236802" title="(x$1: List[PackratParsers.this.LR])Unit">lrStack</a> = <a href="#1237701" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>.<a href="#1236802" title="=&gt; List[PackratParsers.this.LR]">lrStack</a>.<a href="../../../collection/TraversableLike.scala.html#58104" title="=&gt; List[PackratParsers.this.LR]">tail</a>
            //check whether base has changed, if yes, we will have a head
            <a href="#1237705" title="PackratParsers.this.LR">base</a>.<a href="#1237709" title="=&gt; Option[PackratParsers.this.Head]">head</a> <span class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <a href="../../../Option.scala.html#1585" title="PackratParsers.this.ParseResult[T]" id="3383848">None</a> =&gt;
                /*simple result*/
                <a href="#1237701" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>.<a href="#1236796" title="(p: PackratParsers.this.Parser[T], w: PackratParsers.this.MemoEntry[T])PackratParsers.this.MemoEntry[T]">updateCacheAndGet</a><span class="delimiter">(</span><a href="#1237322" title="PackratParsers.this.Parser[T]">p</a>,<a href="#1237931" title="(r: Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]])PackratParsers.this.MemoEntry[Nothing]">MemoEntry</a><span class="delimiter">(</span><a href="../../Either.scala.html#97673" title="(b: PackratParsers.this.ParseResult[T])scala.util.Right[Nothing,PackratParsers.this.ParseResult[T]]">Right</a><span class="delimiter">(</span><a href="#1237706" title="PackratParsers.this.ParseResult[T]">tempRes</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <a href="#1237706" title="PackratParsers.this.ParseResult[T]">tempRes</a>
              <span class="keyword">case</span> s@Some<a href="#3383844" title="PackratParsers.this.ParseResult[T]" id="3383847" class="delimiter">(</a><a href="../../../Option.scala.html#63132" title="PackratParsers.this.Head" id="3383846">_</a><span class="delimiter">)</span> =&gt;
                /*non simple result*/
                <a href="#1237705" title="PackratParsers.this.LR">base</a>.<a href="#1237707" title="(x$1: PackratParsers.this.ParseResult[_])Unit">seed</a> = <a href="#1237706" title="PackratParsers.this.ParseResult[T]">tempRes</a>
                //the base variable has passed equality tests with the cache
                <span class="keyword">val</span> <a title="PackratParsers.this.ParseResult[T]" id="1237771">res</a> = <a href="#1236776" title="(p: PackratParsers.this.Parser[T], in: PackratParsers.this.PackratReader[PackratParsers.this.Elem], growable: PackratParsers.this.LR)PackratParsers.this.ParseResult[T]">lrAnswer</a><span class="delimiter">(</span><a href="#1237322" title="PackratParsers.this.Parser[T]">p</a>, <a href="#1237701" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>, <a href="#1237705" title="PackratParsers.this.LR">base</a><span class="delimiter">)</span>
                <a href="#1237771" title="PackratParsers.this.ParseResult[T]">res</a>
            <span class="delimiter">}</span>

          <span class="keyword">case</span> Some<a href="#3383902" title="PackratParsers.this.ParseResult[T]" id="3383904" class="delimiter">(</a><a href="../../../Option.scala.html#63132" title="PackratParsers.this.MemoEntry[_]" id="1237781">mEntry</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
            //entry found in cache
            <a href="#3383910" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]">mEntry</a> <span class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> MemoEntry<span class="delimiter">(</span>Left<a href="#1237450" title="Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]]" id="3383872" class="delimiter">(</a><a href="../../Either.scala.html#97650" title="PackratParsers.this.LR" id="1237804">recDetect</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#3383891" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="delimiter">{</a>
                <a href="#1236775" title="(p: PackratParsers.this.Parser[_], in: PackratParsers.this.PackratReader[_], recDetect: PackratParsers.this.LR)Unit">setupLR</a><span class="delimiter">(</span><a href="#1237322" title="PackratParsers.this.Parser[T]">p</a>, <a href="#1237701" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">inMem</a>, <a href="#1237804" title="PackratParsers.this.LR">recDetect</a><span class="delimiter">)</span>
                //all setupLR does is change the heads of the recursions, so the seed will stay the same
                <a href="#1237804" title="PackratParsers.this.LR">recDetect</a> <span class="keyword">match</span> <span class="delimiter">{</span><span class="keyword">case</span> LR<span class="delimiter">(</span><a href="#1237707" title="PackratParsers.this.ParseResult[_]" id="1237807">seed</a>, <a href="#1237708" title="PackratParsers.this.Parser[_]" id="3383859">_</a>, <a href="#1237709" title="Option[PackratParsers.this.Head]" id="3383860">_</a><span class="delimiter">)</span> =&gt; <a href="#1237807" title="PackratParsers.this.ParseResult[_]">seed</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><a href="#3383862" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="delimiter">[</a><a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span>
              <span class="delimiter">}</span>
              <span class="keyword">case</span> MemoEntry<span class="delimiter">(</span>Right<a href="#1237450" title="Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]]" id="3383874" class="delimiter">(</a><a href="../../Either.scala.html#97679" title="PackratParsers.this.ParseResult[_]" id="1237817">res</a>: ParseResult<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; res.<span title="[T0]=&gt; T0">asInstanceOf</span><a href="#3383891" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="delimiter">[</a><a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T](p: PackratParsers.this.Parser[T], rest: PackratParsers.this.PackratReader[PackratParsers.this.Elem], head: PackratParsers.this.Head)PackratParsers.this.ParseResult[T]" id="1236782">grow</a><span class="delimiter">[</span><a title="" id="1236784">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PackratParsers.this.Parser[T]" id="1237666">p</a>: <span class="keyword">super</span>.<a href="Parsers.scala.html#600862" title="PackratParsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]" id="1237667">rest</a>: <a href="#1236753" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">PackratReader</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span>, <a title="PackratParsers.this.Head" id="1237668">head</a>: <a href="#1237969" title="PackratParsers.this.Head">Head</a><span class="delimiter">)</span>: <a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    //store the head into the recursionHeads
    <a href="#1237667" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#1236799" title="=&gt; scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]">recursionHeads</a>.<a href="../../../collection/mutable/HashMap.scala.html#88247" title="(key: scala.util.parsing.input.Position, value: PackratParsers.this.Head)Option[PackratParsers.this.Head]">put</a><span class="delimiter">(</span><a href="#1237667" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#1236808" title="=&gt; scala.util.parsing.input.Position">pos</a>, <a href="#1237668" title="PackratParsers.this.Head">head</a> /*match {case Head(hp,involved,_) =&gt; Head(hp,involved,involved)}*/<span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="PackratParsers.this.ParseResult[T]" id="1237829">oldRes</a>: <a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#1237667" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#1236793" title="(p: PackratParsers.this.Parser[T])Option[PackratParsers.this.MemoEntry[T]]">getFromCache</a><span class="delimiter">(</span><a href="#1237666" title="PackratParsers.this.Parser[T]">p</a><span class="delimiter">)</span>.<a href="../../../Option.scala.html#62858" title="=&gt; PackratParsers.this.MemoEntry[T]">get</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> MemoEntry<span class="delimiter">(</span>Right<a href="#1237450" title="Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]]" id="3383922" class="delimiter">(</a><a href="../../Either.scala.html#97679" title="PackratParsers.this.ParseResult[_]" id="1237840">x</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#1237840" title="PackratParsers.this.ParseResult[_]">x</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><a href="#3383924" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="delimiter">[</a><a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="keyword">case</span> _ =&gt; <a href="#3383924" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="keyword">throw</a> <span title="(x$1: String)Exception" class="keyword">new</span> <a href="../../../package.scala.html#55500" title="Exception">Exception</a><span class="delimiter">(</span><span title="String(&quot;impossible match&quot;)" class="string">&quot;impossible match&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    //resetting the evalSet of the head of the recursion at each beginning of growth
    <a href="#1237668" title="PackratParsers.this.Head">head</a>.<a href="#1237535" title="(x$1: List[PackratParsers.this.Parser[_]])Unit">evalSet</a> = <a href="#1237668" title="PackratParsers.this.Head">head</a>.<a href="#1237534" title="=&gt; List[PackratParsers.this.Parser[_]]">involvedSet</a>
    <span class="keyword">val</span> <a title="PackratParsers.this.ParseResult[T]" id="1237830">tempRes</a> = <a href="Parsers.scala.html#611247" title="(in: PackratParsers.this.Input)PackratParsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#1237667" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a><span class="delimiter">)</span>; <a href="#1237830" title="PackratParsers.this.ParseResult[T]">tempRes</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> s@Success<a href="#3383961" title="PackratParsers.this.ParseResult[T]" id="3383965" class="delimiter">(</a><a href="Parsers.scala.html#611700" title="T" id="3383962">_</a>,<a href="Parsers.scala.html#611702" title="PackratParsers.this.Input" id="3383963">_</a><span class="delimiter">)</span> =&gt;
        <a href="#3383967" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="keyword">if</a><span class="delimiter">(</span><a href="#1236758" title="(r: PackratParsers.this.ParseResult[_])scala.util.parsing.input.Position">getPosFromResult</a><span class="delimiter">(</span><a href="#1237829" title="PackratParsers.this.ParseResult[T]">oldRes</a><span class="delimiter">)</span> <a href="../input/Position.scala.html#611765" title="(that: scala.util.parsing.input.Position)Boolean">&lt;</a> <a href="#1236758" title="(r: PackratParsers.this.ParseResult[_])scala.util.parsing.input.Position">getPosFromResult</a><span class="delimiter">(</span><a href="#1237830" title="PackratParsers.this.ParseResult[T]">tempRes</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#1237667" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#1236796" title="(p: PackratParsers.this.Parser[T], w: PackratParsers.this.MemoEntry[T])PackratParsers.this.MemoEntry[T]">updateCacheAndGet</a><span class="delimiter">(</span><a href="#1237666" title="PackratParsers.this.Parser[T]">p</a>, <a href="#1237931" title="(r: Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]])PackratParsers.this.MemoEntry[Nothing]">MemoEntry</a><span class="delimiter">(</span><a href="../../Either.scala.html#97673" title="(b: PackratParsers.this.Success[T])scala.util.Right[Nothing,PackratParsers.this.Success[T]]">Right</a><span class="delimiter">(</span>s<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#1236782" title="(p: PackratParsers.this.Parser[T], rest: PackratParsers.this.PackratReader[PackratParsers.this.Elem], head: PackratParsers.this.Head)PackratParsers.this.ParseResult[T]">grow</a><span class="delimiter">(</span><a href="#1237666" title="PackratParsers.this.Parser[T]">p</a>, <a href="#1237667" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>, <a href="#1237668" title="PackratParsers.this.Head">head</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          //we're done with growing, we can remove data from recursion head
          <a href="#1237667" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#1236799" title="=&gt; scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]">recursionHeads</a> <a href="../../../collection/mutable/HashMap.scala.html#88251" title="(key: scala.util.parsing.input.Position)rest.recursionHeads.type">-=</a> <a href="#1237667" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#1236808" title="=&gt; scala.util.parsing.input.Position">pos</a>
          <a href="#1237667" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#1236793" title="(p: PackratParsers.this.Parser[T])Option[PackratParsers.this.MemoEntry[T]]">getFromCache</a><span class="delimiter">(</span><a href="#1237666" title="PackratParsers.this.Parser[T]">p</a><span class="delimiter">)</span>.<a href="../../../Option.scala.html#62858" title="=&gt; PackratParsers.this.MemoEntry[T]">get</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> MemoEntry<span class="delimiter">(</span>Right<a href="#1237450" title="Either[PackratParsers.this.LR,PackratParsers.this.ParseResult[_]]" id="3383935" class="delimiter">(</a><a href="../../Either.scala.html#97679" title="PackratParsers.this.ParseResult[_]" id="1237907">x</a>: ParseResult<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; x.<span title="[T0]=&gt; T0">asInstanceOf</span><a href="#3383952" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="delimiter">[</a><a href="Parsers.scala.html#600837" title="PackratParsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
            <span class="keyword">case</span> _ =&gt; <a href="#3383952" title="(x: PackratParsers.this.ParseResult[T])PackratParsers.this.ParseResult[T]" class="keyword">throw</a> <span title="(x$1: String)Exception" class="keyword">new</span> <a href="../../../package.scala.html#55500" title="Exception">Exception</a><span class="delimiter">(</span><span title="String(&quot;impossible match&quot;)" class="string">&quot;impossible match&quot;</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> f =&gt;
        <a href="#1237667" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#1236799" title="=&gt; scala.collection.mutable.HashMap[scala.util.parsing.input.Position,PackratParsers.this.Head]">recursionHeads</a> <a href="../../../collection/mutable/HashMap.scala.html#88251" title="(key: scala.util.parsing.input.Position)rest.recursionHeads.type">-=</a> <a href="#1237667" title="PackratParsers.this.PackratReader[PackratParsers.this.Elem]">rest</a>.<a href="#1236808" title="=&gt; scala.util.parsing.input.Position">pos</a>
        /*rest.updateCacheAndGet(p, MemoEntry(Right(f)));*/<a href="#1237829" title="PackratParsers.this.ParseResult[T]">oldRes</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>