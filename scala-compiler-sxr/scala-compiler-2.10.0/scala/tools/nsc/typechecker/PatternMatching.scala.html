<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/tools/nsc/typechecker/PatternMatching.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
/* NSC -- new Scala compiler
 *
 * Copyright 2011-2013 LAMP/EPFL
 * @author Adriaan Moors
 */

<span class="keyword">package</span> scala.tools.nsc
<span class="keyword">package</span> typechecker

<span class="keyword">import</span> symtab._
<span class="keyword">import</span> <a href="../symtab/package.scala.html#55820" title="=&gt; reflect.internal.Flags.type">Flags</a>.<span class="delimiter">{</span>MUTABLE, METHOD, LABEL, SYNTHETIC, ARTIFACT<span class="delimiter">}</span>
<span class="keyword">import</span> scala.<a href="../../../language.scala.html#1423" title="language.type">language</a>.postfixOps
<span class="keyword">import</span> scala.tools.nsc.transform.TypingTransformers
<span class="keyword">import</span> scala.tools.nsc.transform.Transform
<span class="keyword">import</span> scala.collection.mutable.HashSet
<span class="keyword">import</span> scala.collection.mutable.HashMap
<span class="keyword">import</span> scala.reflect.internal.util.Statistics
<span class="keyword">import</span> scala.reflect.internal.Types

/** Translate pattern matching.
  *
  * Either into optimized if/then/else's,
  * or virtualized as method calls (these methods form a zero-plus monad), similar in spirit to how for-comprehensions are compiled.
  *
  * For each case, express all patterns as extractor calls, guards as 0-ary extractors, and sequence them using `flatMap`
  * (lifting the body of the case into the monad using `one`).
  *
  * Cases are combined into a pattern match using the `orElse` combinator (the implicit failure case is expressed using the monad's `zero`).
  *
  * TODO:
  *  - DCE (on irrefutable patterns)
  *  - update spec and double check it's implemented correctly (see TODO's)
  *
  * (longer-term) TODO:
  *  - user-defined unapplyProd
  *  - recover GADT typing by locally inserting implicit witnesses to type equalities derived from the current case, and considering these witnesses during subtyping (?)
  *  - recover exhaustivity/unreachability of user-defined extractors by partitioning the types they match on using an HList or similar type-level structure
  */
<span class="keyword">trait</span> <a title="trait PatternMatching extends scala.tools.nsc.SubComponent with scala.tools.nsc.transform.Transform with scala.tools.nsc.transform.TypingTransformers with scala.tools.nsc.ast.TreeDSL" id="45044">PatternMatching</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="../transform/Transform.scala.html#43152" title="scala.tools.nsc.transform.Transform">Transform</a> <span class="keyword">with</span> <a href="../transform/TypingTransformers.scala.html#43407" title="scala.tools.nsc.transform.TypingTransformers">TypingTransformers</a> <span class="keyword">with</span> ast.<a href="../ast/TreeDSL.scala.html#28843" title="scala.tools.nsc.ast.TreeDSL">TreeDSL</a> <span class="delimiter">{</span>   // self: Analyzer =&gt;
  <span class="keyword">import</span> <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>._
  <span class="keyword">import</span> <a href="#45753" title="scala.tools.nsc.typechecker.PatternMatchingStats.type">PatternMatchingStats</a>._

  <span class="keyword">val</span> <a title="=&gt; scala.tools.nsc.Global" id="621351">global</a>: <a href="../Global.scala.html#27346" title="scala.tools.nsc.Global">Global</a>               // need to repeat here because otherwise last mixin defines global as
                                   // SymbolTable. If we had DOT this would not be an issue
  <span class="keyword">import</span> <a href="#621351" title="=&gt; scala.tools.nsc.Global">global</a>._                  // the global environment
  <span class="keyword">import</span> <a href="../../../reflect/internal/Definitions.scala.html#407777" title="PatternMatching.this.global.definitions.type">definitions</a>._             // standard classes and methods

  <span class="keyword">val</span> <a title="String" id="621354">phaseName</a>: <span title="String">String</span> = <span title="String(&quot;patmat&quot;)" class="string">&quot;patmat&quot;</span>

  // TODO: the inliner fails to inline the closures to patmatDebug
  <span class="keyword">object</span> <a title="PatternMatching.this.debugging.type" id="621356">debugging</a> <a href="#621357" title="PatternMatching.this.debugging.type" class="delimiter">{</a>
    <span class="keyword">val</span> <a title="Boolean" id="1068818">printPatmat</a> = <a href="../Global.scala.html#537448" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#540160" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">Ypatmatdebug</a>.<a href="../settings/MutableSettings.scala.html#541066" title="=&gt; Boolean">value</a>
    @inline <span class="keyword">final</span> <span class="keyword">def</span> <a title="(s: =&gt; String)Unit" id="1068820">patmatDebug</a><span class="delimiter">(</span><a title="=&gt; String" id="1068825">s</a>: =&gt; String<span class="delimiter">)</span> = <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1068818" title="=&gt; Boolean">printPatmat</a><span class="delimiter">)</span> <a href="../../../Predef.scala.html#7514" title="(x: Any)Unit">println</a><span class="delimiter">(</span><a href="#1068825" title="=&gt; String">s</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">import</span> <a href="#621356" title="PatternMatching.this.debugging.type">debugging</a>.patmatDebug

  // to govern how much time we spend analyzing matches for unreachability/exhaustivity
  <span class="keyword">object</span> <a title="PatternMatching.this.AnalysisBudget.type" id="621359">AnalysisBudget</a> <a href="#621360" title="PatternMatching.this.AnalysisBudget.type" class="delimiter">{</a>
    <span class="keyword">import</span> scala.tools.cmd.<a href="../../cmd/FromString.scala.html#26868" title="scala.tools.cmd.FromString.type">FromString</a>.IntFromString
    <span class="keyword">val</span> <a title="Int" id="1068830">max</a> = sys.<a href="../../../sys/package.scala.html#55662" title="=&gt; scala.sys.SystemProperties">props</a>.<a href="../../../sys/SystemProperties.scala.html#87501" title="(key: String)Option[String]">get</a><span class="delimiter">(</span><span title="String(&quot;scalac.patmat.analysisBudget&quot;)" class="string">&quot;scalac.patmat.analysisBudget&quot;</span><span class="delimiter">)</span>.<a href="../../../Option.scala.html#62887" title="(pf: PartialFunction[String,Int])Option[Int]">collect</a><span class="delimiter">(</span><a href="../../cmd/FromString.scala.html#609343" title="=&gt; scala.tools.cmd.FromString[Int]">IntFromString</a>.<a href="../../../PartialFunction.scala.html#58654" title="(that: PartialFunction[String,Int])PartialFunction[String,Int]">orElse</a><a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[String,Int] with Serializable" id="1068855" class="delimiter">{</a><span class="keyword">case</span> <a href="#3367893" title="B1" id="3367909" class="string">&quot;off&quot;</a> =&gt; Integer.<a href="#3367898" title="(x: B1)B1">MAX_VALUE</a><span class="delimiter">}</span><span class="delimiter">)</span>.<a href="../../../Option.scala.html#62859" title="(default: =&gt; Int)Int">getOrElse</a><span class="delimiter">(</span><span title="Int(256)" class="int">256</span><span class="delimiter">)</span>

    <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Exception extends RuntimeException" id="1068832">Exception</a> <a href="#1068832" title="scala.tools.nsc.typechecker.PatternMatching.AnalysisBudget.Exception" class="keyword">extends</a> <a href="../../../package.scala.html#55502" title="RuntimeException">RuntimeException</a><span class="delimiter">(</span><span title="String(&quot;CNF budget exceeded&quot;)" class="string">&quot;CNF budget exceeded&quot;</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="=&gt; String" id="1068888">advice</a>: <span title="String">String</span>
      <span class="keyword">def</span> <a title="(pos: PatternMatching.this.global.Position, kind: String)Any" id="1068889">warn</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Position" id="1068896">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#22953" title="PatternMatching.this.global.Position">Position</a>, <a title="String" id="1068897">kind</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="../Global.scala.html#537673" title="=&gt; PatternMatching.this.global.CompilationUnit">currentUnit</a>.<a href="../CompilationUnits.scala.html#539301" title="(pos: PatternMatching.this.global.Position, msg: String)Any">uncheckedWarning</a><span class="delimiter">(</span><a href="#1068896" title="PatternMatching.this.global.Position">pos</a>, <a href="../../../StringContext.scala.html#56629" title="(args: Any*)String">s</a>&quot;Cannot check match for $<a href="#1068897" title="String">kind</a>.\n$<a href="#1068888" title="=&gt; String">advice</a><span class="string">&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">object</span> <a title="scala.tools.nsc.typechecker.PatternMatching.AnalysisBudget.exceeded.type" id="1068908">exceeded</a> <a href="#1068834" title="scala.tools.nsc.typechecker.PatternMatching.AnalysisBudget.exceeded.type" class="keyword">extends</a> <a href="#1068832" title="scala.tools.nsc.typechecker.PatternMatching.AnalysisBudget.Exception">Exception</a> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="1068901">advice</a> = <a href="../../../StringContext.scala.html#56629" title="(args: Any*)String">s</a>&quot;(The analysis required more space than allowed. Please try with scalac -Dscalac.patmat.analysisBudget=$<span class="delimiter">{</span><a href="#621359" title="PatternMatching.this.AnalysisBudget.type">AnalysisBudget</a>.<a href="#1068830" title="=&gt; Int">max</a><a href="../../../Int.scala.html#57168" title="(x: Int)Int">*</a><span title="Int(2)" class="int">2</span><span class="delimiter">}</span><span class="string"> or -Dscalac.patmat.analysisBudget=off.)&quot;</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(unit: PatternMatching.this.global.CompilationUnit)PatternMatching.this.global.Transformer" id="621361">newTransformer</a><span class="delimiter">(</span><a title="PatternMatching.this.global.CompilationUnit" id="1068909">unit</a>: <a href="../CompilationUnits.scala.html#537766" title="PatternMatching.this.global.CompilationUnit">CompilationUnit</a><span class="delimiter">)</span>: <a href="../ast/Trees.scala.html#537817" title="PatternMatching.this.global.Transformer">Transformer</a> =
    <span title="PatternMatching.this.global.Transformer" class="keyword">if</span> <span class="delimiter">(</span><a href="../Global.scala.html#537522" title="PatternMatching.this.global.opt.type">opt</a>.<a href="../settings/AestheticSettings.scala.html#545420" title="=&gt; Boolean">virtPatmat</a><span class="delimiter">)</span> <span title="PatternMatching.this.MatchTransformer" class="keyword">new</span> <a href="#621375" title="PatternMatching.this.MatchTransformer">MatchTransformer</a><span class="delimiter">(</span><a href="#1068909" title="PatternMatching.this.global.CompilationUnit">unit</a><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="../ast/Trees.scala.html#537818" title="PatternMatching.this.global.noopTransformer.type">noopTransformer</a>

  // duplicated from CPSUtils (avoid dependency from compiler -&gt; cps plugin...)
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="621363">MarkerCPSAdaptPlus</a>  = <a href="../Global.scala.html#537442" title="=&gt; PatternMatching.this.global.Mirror">rootMirror</a>.<a href="../../../reflect/internal/Mirrors.scala.html#412980" title="(fullname: String)PatternMatching.this.global.Symbol">getClassIfDefined</a><span class="delimiter">(</span><span title="String(&quot;scala.util.continuations.cpsPlus&quot;)" class="string">&quot;scala.util.continuations.cpsPlus&quot;</span><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="621365">MarkerCPSAdaptMinus</a> = <a href="../Global.scala.html#537442" title="=&gt; PatternMatching.this.global.Mirror">rootMirror</a>.<a href="../../../reflect/internal/Mirrors.scala.html#412980" title="(fullname: String)PatternMatching.this.global.Symbol">getClassIfDefined</a><span class="delimiter">(</span><span title="String(&quot;scala.util.continuations.cpsMinus&quot;)" class="string">&quot;scala.util.continuations.cpsMinus&quot;</span><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="621367">MarkerCPSSynth</a>      = <a href="../Global.scala.html#537442" title="=&gt; PatternMatching.this.global.Mirror">rootMirror</a>.<a href="../../../reflect/internal/Mirrors.scala.html#412980" title="(fullname: String)PatternMatching.this.global.Symbol">getClassIfDefined</a><span class="delimiter">(</span><span title="String(&quot;scala.util.continuations.cpsSynth&quot;)" class="string">&quot;scala.util.continuations.cpsSynth&quot;</span><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="621369">stripTriggerCPSAnns</a> = <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Symbol*)List[PatternMatching.this.global.Symbol]">List</a><span class="delimiter">(</span><a href="#621366" title="=&gt; PatternMatching.this.global.Symbol">MarkerCPSSynth</a>, <a href="#621364" title="=&gt; PatternMatching.this.global.Symbol">MarkerCPSAdaptMinus</a>, <a href="#621362" title="=&gt; PatternMatching.this.global.Symbol">MarkerCPSAdaptPlus</a><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="621371">MarkerCPSTypes</a>      = <a href="../Global.scala.html#537442" title="=&gt; PatternMatching.this.global.Mirror">rootMirror</a>.<a href="../../../reflect/internal/Mirrors.scala.html#412980" title="(fullname: String)PatternMatching.this.global.Symbol">getClassIfDefined</a><span class="delimiter">(</span><span title="String(&quot;scala.util.continuations.cpsParam&quot;)" class="string">&quot;scala.util.continuations.cpsParam&quot;</span><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="621373">strippedCPSAnns</a>     = <a href="#621370" title="=&gt; PatternMatching.this.global.Symbol">MarkerCPSTypes</a> <a href="../../../collection/immutable/List.scala.html#62685" title="(x: PatternMatching.this.global.Symbol)List[PatternMatching.this.global.Symbol]">::</a> <a href="#621368" title="=&gt; List[PatternMatching.this.global.Symbol]">stripTriggerCPSAnns</a>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type" id="621374">removeCPSAdaptAnnotations</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1068948">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> = <a href="#1068948" title="PatternMatching.this.global.Type">tp</a> <a href="../../../reflect/internal/Types.scala.html#408511" title="(p: PatternMatching.this.global.AnnotationInfo =&gt; Boolean)PatternMatching.this.global.Type">filterAnnotations</a> <span class="delimiter">(</span><a title="PatternMatching.this.global.AnnotationInfo" id="1068954">ann</a> =&gt; <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#621372" title="=&gt; List[PatternMatching.this.global.Symbol]">strippedCPSAnns</a> <a href="../../../collection/LinearSeqOptimized.scala.html#86379" title="(p: PatternMatching.this.global.Symbol =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#1068954" title="PatternMatching.this.global.AnnotationInfo">ann</a> <a href="../../../reflect/internal/AnnotationInfos.scala.html#409745" title="(clazz: PatternMatching.this.global.Symbol)Boolean">matches</a> <a href="#1068961" title="PatternMatching.this.global.Symbol">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">class</span> <a title="class MatchTransformer extends PatternMatching.this.TypingTransformer" id="621375">MatchTransformer</a><a href="#621375" title="PatternMatching.this.MatchTransformer" class="delimiter">(</a><a title="PatternMatching.this.global.CompilationUnit" id="1068917">unit</a>: <a href="../CompilationUnits.scala.html#537766" title="PatternMatching.this.global.CompilationUnit">CompilationUnit</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="../transform/TypingTransformers.scala.html#621441" title="PatternMatching.this.TypingTransformer">TypingTransformer</a><span class="delimiter">(</span><a href="#1068917" title="PatternMatching.this.global.CompilationUnit">unit</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1068915">transform</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1068966">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="#1068966" title="PatternMatching.this.global.Tree">tree</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Match<a href="#3367918" title="PatternMatching.this.global.Tree" id="3367920" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410097" title="PatternMatching.this.global.Tree" id="1068973">sel</a>, <a href="../../../reflect/internal/Trees.scala.html#410099" title="List[PatternMatching.this.global.CaseDef]" id="1068974">cases</a><span class="delimiter">)</span> =&gt;
        <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1068975">origTp</a> = <a href="#1068966" title="PatternMatching.this.global.Tree">tree</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>
        // setType origTp intended for CPS -- TODO: is it necessary?
        <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1068976">translated</a> = <a href="#1068916" title="=&gt; PatternMatching.this.MatchTranslation with PatternMatching.this.CodegenCore">translator</a>.<a href="#1068993" title="(match_: PatternMatching.this.global.Match)PatternMatching.this.global.Tree">translateMatch</a><span class="delimiter">(</span><a href="../../../reflect/api/Trees.scala.html#405645" title="=&gt; PatternMatching.this.global.TreeCopier">treeCopy</a>.<a href="../../../reflect/api/Trees.scala.html#405390" title="(tree: PatternMatching.this.global.Tree, selector: PatternMatching.this.global.Tree, cases: List[PatternMatching.this.global.CaseDef])PatternMatching.this.global.Match">Match</a><span class="delimiter">(</span><a href="#1068966" title="PatternMatching.this.global.Tree">tree</a>, <a href="#1068915" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">transform</a><span class="delimiter">(</span><a href="#1068973" title="PatternMatching.this.global.Tree">sel</a><span class="delimiter">)</span>, <a href="../../../reflect/api/Trees.scala.html#405653" title="(trees: List[PatternMatching.this.global.Tree])List[PatternMatching.this.global.Tree]">transformTrees</a><span class="delimiter">(</span><a href="#1068974" title="List[PatternMatching.this.global.CaseDef]">cases</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="List[PatternMatching.this.global.CaseDef]" class="delimiter">[</span><a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <a href="../transform/TypingTransformers.scala.html#984456" title="=&gt; PatternMatching.this.global.analyzer.Typer">localTyper</a>.<a href="Typers.scala.html#538701" title="(tree: PatternMatching.this.global.analyzer.global.Tree)PatternMatching.this.global.analyzer.global.Tree">typed</a><span class="delimiter">(</span><a href="#1068976" title="PatternMatching.this.global.Tree">translated</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Trees.scala.html#408575" title="(tp: PatternMatching.this.global.analyzer.global.Type)PatternMatching.this.global.analyzer.global.Tree">setType</a> <a href="#1068975" title="PatternMatching.this.global.Type">origTp</a>
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a title="PatternMatching.this.global.Tree" id="1069099">x</a>: <span class="delimiter">(</span>Types#<a href="../../../reflect/internal/Types.scala.html#407625" title="scala.reflect.internal.Types#TypeError">TypeError</a><span class="delimiter">)</span> =&gt;
            // TODO: this should never happen; error should've been reported during type checking
            <a href="#1068917" title="PatternMatching.this.global.CompilationUnit">unit</a>.<a href="../CompilationUnits.scala.html#539298" title="(pos: PatternMatching.this.global.Position, msg: String)Unit">error</a><span class="delimiter">(</span><a href="#1068966" title="PatternMatching.this.global.Tree">tree</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a>, <span title="String(&quot;error during expansion of this match (this is a scalac bug).\nThe underlying error was: &quot;)" class="string">&quot;error during expansion of this match (this is a scalac bug).\nThe underlying error was: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1069099" title="scala.reflect.internal.Types#TypeError">x</a>.<a href="../../../reflect/internal/Types.scala.html#416073" title="=&gt; String">msg</a><span class="delimiter">)</span>
            <a href="#1068976" title="PatternMatching.this.global.Tree">translated</a>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> Try<a href="#3367918" title="PatternMatching.this.global.Tree" id="3367922" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410079" title="PatternMatching.this.global.Tree" id="1069113">block</a>, <a href="../../../reflect/internal/Trees.scala.html#410081" title="List[PatternMatching.this.global.CaseDef]" id="1069114">catches</a>, <a href="../../../reflect/internal/Trees.scala.html#410083" title="PatternMatching.this.global.Tree" id="1069115">finalizer</a><span class="delimiter">)</span> =&gt;
        <a href="../../../reflect/api/Trees.scala.html#405645" title="=&gt; PatternMatching.this.global.TreeCopier">treeCopy</a>.<a href="../../../reflect/api/Trees.scala.html#405392" title="(tree: PatternMatching.this.global.Tree, block: PatternMatching.this.global.Tree, catches: List[PatternMatching.this.global.CaseDef], finalizer: PatternMatching.this.global.Tree)PatternMatching.this.global.Try">Try</a><a href="#3367924" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="#1068966" title="PatternMatching.this.global.Tree">tree</a>, <a href="#1068915" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">transform</a><span class="delimiter">(</span><a href="#1069113" title="PatternMatching.this.global.Tree">block</a><span class="delimiter">)</span>, <a href="#1068916" title="=&gt; PatternMatching.this.MatchTranslation with PatternMatching.this.CodegenCore">translator</a>.<a href="#1068994" title="(caseDefs: List[PatternMatching.this.global.CaseDef], pt: PatternMatching.this.global.Type, pos: PatternMatching.this.global.Position)List[PatternMatching.this.global.CaseDef]">translateTry</a><span class="delimiter">(</span><a href="../../../reflect/api/Trees.scala.html#405653" title="(trees: List[PatternMatching.this.global.Tree])List[PatternMatching.this.global.Tree]">transformTrees</a><span class="delimiter">(</span><a href="#1069114" title="List[PatternMatching.this.global.CaseDef]">catches</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="List[PatternMatching.this.global.CaseDef]" class="delimiter">[</span><a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">]</span>, <a href="#1068966" title="PatternMatching.this.global.Tree">tree</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>, <a href="#1068966" title="PatternMatching.this.global.Tree">tree</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span>, <a href="#1068915" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">transform</a><span class="delimiter">(</span><a href="#1069115" title="PatternMatching.this.global.Tree">finalizer</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt; <a href="#621375" title="PatternMatching.this.MatchTransformer" class="keyword">super</a>.<a href="../transform/TypingTransformers.scala.html#984469" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">transform</a><a href="#3367924" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="#1068966" title="PatternMatching.this.global.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.MatchTranslation with PatternMatching.this.CodegenCore" id="1068916">translator</a>: <a href="#1068977" title="MatchTransformer extends PatternMatching.this.MatchTranslation with PatternMatching.this.CodegenCore">MatchTranslation</a> <span class="keyword">with</span> CodegenCore = <span class="delimiter">{</span>
      <span title="PatternMatching.this.OptimizingMatchTranslator" class="keyword">new</span> <a href="#621384" title="PatternMatching.this.OptimizingMatchTranslator">OptimizingMatchTranslator</a><span class="delimiter">(</span><a href="../transform/TypingTransformers.scala.html#984456" title="=&gt; PatternMatching.this.global.analyzer.Typer">localTyper</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">import</span> <a href="../../../reflect/internal/Definitions.scala.html#407777" title="PatternMatching.this.global.definitions.type">definitions</a>._
  <span class="keyword">import</span> <a href="../Global.scala.html#537550" title="=&gt; scala.tools.nsc.typechecker.Analyzer{val global: PatternMatching.this.global.type}">analyzer</a>._ //Typer


  case <span class="keyword">class</span> <a title="class DefaultOverrideMatchAttachment extends AnyRef with Product with Serializable" id="1094202">DefaultOverrideMatchAttachment</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1094199">default</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>

  <span class="keyword">object</span> <a title="PatternMatching.this.vpmName.type" id="621381">vpmName</a> <a href="#621382" title="PatternMatching.this.vpmName.type" class="delimiter">{</a>
    <span class="keyword">val</span> <a title="PatternMatching.this.global.TermName" id="1069363">one</a>       = <a href="../../../reflect/internal/Names.scala.html#406859" title="(s: String)PatternMatching.this.global.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;one&quot;)" class="string">&quot;one&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="PatternMatching.this.global.TermName" id="1069365">drop</a>      = <a href="../../../reflect/internal/Names.scala.html#406859" title="(s: String)PatternMatching.this.global.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;drop&quot;)" class="string">&quot;drop&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="PatternMatching.this.global.TermName" id="1069367">flatMap</a>   = <a href="../../../reflect/internal/Names.scala.html#406859" title="(s: String)PatternMatching.this.global.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;flatMap&quot;)" class="string">&quot;flatMap&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="PatternMatching.this.global.TermName" id="1069369">get</a>       = <a href="../../../reflect/internal/Names.scala.html#406859" title="(s: String)PatternMatching.this.global.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;get&quot;)" class="string">&quot;get&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="PatternMatching.this.global.TermName" id="1069371">guard</a>     = <a href="../../../reflect/internal/Names.scala.html#406859" title="(s: String)PatternMatching.this.global.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;guard&quot;)" class="string">&quot;guard&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="PatternMatching.this.global.TermName" id="1069373">isEmpty</a>   = <a href="../../../reflect/internal/Names.scala.html#406859" title="(s: String)PatternMatching.this.global.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;isEmpty&quot;)" class="string">&quot;isEmpty&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="PatternMatching.this.global.TermName" id="1069375">orElse</a>    = <a href="../../../reflect/internal/Names.scala.html#406859" title="(s: String)PatternMatching.this.global.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;orElse&quot;)" class="string">&quot;orElse&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="PatternMatching.this.global.TermName" id="1069377">outer</a>     = <a href="../../../reflect/internal/Names.scala.html#406859" title="(s: String)PatternMatching.this.global.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;&lt;outer&gt;&quot;)" class="string">&quot;&lt;outer&gt;&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="PatternMatching.this.global.TermName" id="1069379">runOrElse</a> = <a href="../../../reflect/internal/Names.scala.html#406859" title="(s: String)PatternMatching.this.global.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;runOrElse&quot;)" class="string">&quot;runOrElse&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="PatternMatching.this.global.TermName" id="1069381">zero</a>      = <a href="../../../reflect/internal/Names.scala.html#406859" title="(s: String)PatternMatching.this.global.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;zero&quot;)" class="string">&quot;zero&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="PatternMatching.this.global.TermName" id="1069383">_match</a>    = <a href="../../../reflect/internal/Names.scala.html#406859" title="(s: String)PatternMatching.this.global.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;__match&quot;)" class="string">&quot;__match&quot;</span><span class="delimiter">)</span> // don't call the val __match, since that will trigger virtual pattern matching...

    <span class="keyword">def</span> <a title="(str: String, i: Int)PatternMatching.this.global.TermName" id="1069385">counted</a><span class="delimiter">(</span><a title="String" id="1069431">str</a>: <span title="String">String</span>, <a title="Int" id="1069432">i</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a><span class="delimiter">)</span> = <a href="../../../reflect/internal/Names.scala.html#406859" title="(s: String)PatternMatching.this.global.TermName">newTermName</a><span class="delimiter">(</span><a href="#1069431" title="String">str</a><span title="(x$1: Any)String">+</span><a href="#1069432" title="Int">i</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class PureMatchTranslator extends Object with PatternMatching.this.MatchTranslation with PatternMatching.this.TreeMakers with PatternMatching.this.PureCodegen" id="621383">PureMatchTranslator</a><a href="#621383" title="PatternMatching.this.PureMatchTranslator" class="delimiter">(</a><span class="keyword">val</span> <a title="PatternMatching.this.global.analyzer.Typer" id="1069461">typer</a>: <a href="Typers.scala.html#538117" title="PatternMatching.this.global.analyzer.Typer">Typer</a>, <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1069462">matchStrategy</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#621386" title="PatternMatching.this.MatchTranslation">MatchTranslation</a> <span class="keyword">with</span> <a href="#621388" title="PatternMatching.this.TreeMakers">TreeMakers</a> <span class="keyword">with</span> <a href="#621391" title="PatternMatching.this.PureCodegen">PureCodegen</a>
  <span class="keyword">class</span> <a title="class OptimizingMatchTranslator extends Object with PatternMatching.this.MatchTranslation with PatternMatching.this.TreeMakers with PatternMatching.this.MatchOptimizations" id="621384">OptimizingMatchTranslator</a><a href="#621384" title="PatternMatching.this.OptimizingMatchTranslator" class="delimiter">(</a><span class="keyword">val</span> <a title="PatternMatching.this.global.analyzer.Typer" id="1069326">typer</a>: <a href="Typers.scala.html#538117" title="PatternMatching.this.global.analyzer.Typer">Typer</a><span class="delimiter">)</span>                    <span class="keyword">extends</span> <a href="#621386" title="PatternMatching.this.MatchTranslation">MatchTranslation</a> <span class="keyword">with</span> <a href="#621388" title="PatternMatching.this.TreeMakers">TreeMakers</a> <span class="keyword">with</span> <a href="#621403" title="PatternMatching.this.MatchOptimizations">MatchOptimizations</a>

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// talking to userland
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  /** Interface with user-defined match monad?
   * if there's a `__match` in scope, we use this as the match strategy, assuming it conforms to MatchStrategy as defined below:

       type Matcher[P[_], M[+_], A] = {
         def flatMap[B](f: P[A] =&gt; M[B]): M[B]
         def orElse[B &gt;: A](alternative: =&gt; M[B]): M[B]
       }

       abstract class MatchStrategy[P[_], M[+_]] {
         // runs the matcher on the given input
         def runOrElse[T, U](in: P[T])(matcher: P[T] =&gt; M[U]): P[U]

         def zero: M[Nothing]
         def one[T](x: P[T]): M[T]
         def guard[T](cond: P[Boolean], then: =&gt; P[T]): M[T]
       }

   * P and M are derived from one's signature (`def one[T](x: P[T]): M[T]`)


   * if no `__match` is found, we assume the following implementation (and generate optimized code accordingly)

       object __match extends MatchStrategy[({type Id[x] = x})#Id, Option] {
         def zero = None
         def one[T](x: T) = Some(x)
         // NOTE: guard's return type must be of the shape M[T], where M is the monad in which the pattern match should be interpreted
         def guard[T](cond: Boolean, then: =&gt; T): Option[T] = if(cond) Some(then) else None
         def runOrElse[T, U](x: T)(f: T =&gt; Option[U]): U = f(x) getOrElse (throw new MatchError(x))
       }

   */
  <span class="keyword">trait</span> <a title="trait MatchMonadInterface extends Object" id="621385">MatchMonadInterface</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="delimiter">{</a>
    <span class="keyword">val</span> <a title="=&gt; PatternMatching.this.global.analyzer.Typer" id="1068979">typer</a>: <a href="Typers.scala.html#538117" title="PatternMatching.this.global.analyzer.Typer">Typer</a>
    <span class="keyword">val</span> <a title="PatternMatching.this.global.analyzer.global.Symbol" id="1068980">matchOwner</a> = <a href="#1068979" title="=&gt; PatternMatching.this.global.analyzer.Typer">typer</a>.<a href="Typers.scala.html#538560" title="=&gt; PatternMatching.this.global.analyzer.Context">context</a>.<a href="Contexts.scala.html#538749" title="=&gt; PatternMatching.this.global.analyzer.global.Symbol">owner</a>

    <span class="keyword">def</span> <a title="(pos: PatternMatching.this.global.Position)Unit" id="1068982">reportUnreachable</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Position" id="1069467">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#22953" title="PatternMatching.this.global.Position">Position</a><span class="delimiter">)</span> = <a href="#1068979" title="=&gt; PatternMatching.this.global.analyzer.Typer">typer</a>.<a href="Typers.scala.html#538560" title="=&gt; PatternMatching.this.global.analyzer.Context">context</a>.<a href="Contexts.scala.html#538743" title="=&gt; PatternMatching.this.global.analyzer.global.CompilationUnit">unit</a>.<a href="../CompilationUnits.scala.html#539299" title="(pos: PatternMatching.this.global.analyzer.global.Position, msg: String)Unit">warning</a><span class="delimiter">(</span><a href="#1069467" title="PatternMatching.this.global.Position">pos</a>, <span title="String(&quot;unreachable code&quot;)" class="string">&quot;unreachable code&quot;</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(pos: PatternMatching.this.global.Position, counterExamples: List[String])Unit" id="1068983">reportMissingCases</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Position" id="1069470">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#22953" title="PatternMatching.this.global.Position">Position</a>, <a title="List[String]" id="1069471">counterExamples</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[String]">List</a><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="1069472">ceString</a> =
        <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#1069471" title="List[String]">counterExamples</a>.<a href="../../../collection/TraversableLike.scala.html#58104" title="=&gt; List[String]">tail</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span title="String(&quot;input: &quot;)" class="string">&quot;input: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#1069471" title="List[String]">counterExamples</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; String">head</a>
        <span class="keyword">else</span> <span title="String(&quot;inputs: &quot;)" class="string">&quot;inputs: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#1069471" title="List[String]">counterExamples</a>.<a href="../../../collection/TraversableOnce.scala.html#58283" title="(sep: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span>

      <a href="#1068979" title="=&gt; PatternMatching.this.global.analyzer.Typer">typer</a>.<a href="Typers.scala.html#538560" title="=&gt; PatternMatching.this.global.analyzer.Context">context</a>.<a href="Contexts.scala.html#538743" title="=&gt; PatternMatching.this.global.analyzer.global.CompilationUnit">unit</a>.<a href="../CompilationUnits.scala.html#539299" title="(pos: PatternMatching.this.global.analyzer.global.Position, msg: String)Unit">warning</a><span class="delimiter">(</span><a href="#1069470" title="PatternMatching.this.global.Position">pos</a>, <span title="String(&quot;match may not be exhaustive.\nIt would fail on the following &quot;)" class="string">&quot;match may not be exhaustive.\nIt would fail on the following &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1069472" title="String">ceString</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type" id="1068984">inMatchMonad</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1069476">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>
    <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type" id="1068985">pureType</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1069477">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>
    <span class="keyword">final</span> <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type" id="1068986">matchMonadResult</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1069478">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a> =
      <a href="#1069478" title="PatternMatching.this.global.Type">tp</a>.<a href="../../../reflect/internal/Types.scala.html#408459" title="(clazz: PatternMatching.this.global.Symbol)PatternMatching.this.global.Type">baseType</a><span class="delimiter">(</span><a href="#1068987" title="=&gt; PatternMatching.this.global.Symbol">matchMonadSym</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/Types.scala.html#408421" title="=&gt; List[PatternMatching.this.global.Type]">typeArgs</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="../../../collection/immutable/List.scala.html#206583" title="PatternMatching.this.global.Type" id="1069483">arg</a> <a href="#3367935" title="PatternMatching.this.global.Type" id="3367937">::</a> <a href="../../../collection/immutable/List.scala.html#206584" title="List[PatternMatching.this.global.Type]" id="3367939">Nil</a> =&gt; <a href="#3367941" title="(x: PatternMatching.this.global.Type)PatternMatching.this.global.Type">arg</a>
        <span class="keyword">case</span> _ =&gt; <a href="#3367941" title="(x: PatternMatching.this.global.Type)PatternMatching.this.global.Type">ErrorType</a>
      <span class="delimiter">}</span>

    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Symbol" id="1068987">matchMonadSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait MatchTranslation extends Object with PatternMatching.this.MatchMonadInterface" id="621386">MatchTranslation</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621385" title="PatternMatching.this.MatchMonadInterface">MatchMonadInterface</a> <span class="delimiter">{</span> self: TreeMakers <span class="keyword">with</span> CodegenCore =&gt;
    <span class="keyword">import</span> <a href="#1068979" title="=&gt; PatternMatching.this.global.analyzer.Typer">typer</a>.<span class="delimiter">{</span>typed, context, silent, reallyExists<span class="delimiter">}</span>
    // import typer.infer.containsUnchecked

    // Why is it so difficult to say &quot;here's a name and a context, give me any
    // matching symbol in scope&quot; ? I am sure this code is wrong, but attempts to
    // use the scopes of the contexts in the enclosing context chain discover
    // nothing. How to associate a name with a symbol would would be a wonderful
    // linkage for which to establish a canonical acquisition mechanism.
    <span class="keyword">def</span> <a title="(pat: PatternMatching.this.global.Tree)PatternMatching.this.global.Symbol" id="1068991">matchingSymbolInScope</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1069488">pat</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(tpe: PatternMatching.this.global.Type, name: PatternMatching.this.global.Name)PatternMatching.this.global.Symbol" id="1069490">declarationOfName</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1069491">tpe</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <a title="PatternMatching.this.global.Name" id="1069492">name</a>: <a href="../../../reflect/internal/Names.scala.html#406868" title="PatternMatching.this.global.Name">Name</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a> = <a href="#1069491" title="PatternMatching.this.global.Type">tpe</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> PolyType<a href="#3367949" title="PatternMatching.this.global.Symbol" id="3367951" class="delimiter">(</a><a href="../../../reflect/internal/Types.scala.html#410715" title="List[PatternMatching.this.global.Symbol]" id="1069495">tparams</a>, <a href="../../../reflect/internal/Types.scala.html#410717" title="PatternMatching.this.global.Type" id="1069496">restpe</a><span class="delimiter">)</span>  =&gt; <a href="#1069495" title="List[PatternMatching.this.global.Symbol]">tparams</a> <a href="../../../collection/LinearSeqOptimized.scala.html#86381" title="(p: PatternMatching.this.global.Symbol =&gt; Boolean)Option[PatternMatching.this.global.Symbol]">find</a> <span class="delimiter">(</span><a href="#1069503" title="PatternMatching.this.global.Symbol">_</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; x$3.NameType">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1069492" title="PatternMatching.this.global.Name">name</a><span class="delimiter">)</span> <a href="#3367959" title="(x: PatternMatching.this.global.Symbol)PatternMatching.this.global.Symbol">getOrElse</a> <a href="#1069490" title="(tpe: PatternMatching.this.global.Type, name: PatternMatching.this.global.Name)PatternMatching.this.global.Symbol">declarationOfName</a><span class="delimiter">(</span><a href="#1069496" title="PatternMatching.this.global.Type">restpe</a>, <a href="#1069492" title="PatternMatching.this.global.Name">name</a><span class="delimiter">)</span>
        <span class="keyword">case</span> MethodType<a href="#3367949" title="PatternMatching.this.global.Symbol" id="3367953" class="delimiter">(</a><a href="../../../reflect/internal/Types.scala.html#410769" title="List[PatternMatching.this.global.Symbol]" id="1069516">params</a>, <a href="../../../reflect/internal/Types.scala.html#410771" title="PatternMatching.this.global.Type" id="1069517">restpe</a><span class="delimiter">)</span> =&gt; <a href="#1069516" title="List[PatternMatching.this.global.Symbol]">params</a> <a href="../../../collection/LinearSeqOptimized.scala.html#86381" title="(p: PatternMatching.this.global.Symbol =&gt; Boolean)Option[PatternMatching.this.global.Symbol]">find</a> <span class="delimiter">(</span><a href="#1069524" title="PatternMatching.this.global.Symbol">_</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; x$4.NameType">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1069492" title="PatternMatching.this.global.Name">name</a><span class="delimiter">)</span> <a href="#3367959" title="(x: PatternMatching.this.global.Symbol)PatternMatching.this.global.Symbol">getOrElse</a> <a href="#1069490" title="(tpe: PatternMatching.this.global.Type, name: PatternMatching.this.global.Name)PatternMatching.this.global.Symbol">declarationOfName</a><span class="delimiter">(</span><a href="#1069517" title="PatternMatching.this.global.Type">restpe</a>, <a href="#1069492" title="PatternMatching.this.global.Name">name</a><span class="delimiter">)</span>
        <span class="keyword">case</span> ClassInfoType<a href="#3367949" title="PatternMatching.this.global.Symbol" id="3367957" class="delimiter">(</a><a href="../../../reflect/internal/Types.scala.html#410826" title="List[PatternMatching.this.global.Type]" id="3367954">_</a>, <a href="../../../reflect/internal/Types.scala.html#410828" title="PatternMatching.this.global.Scope" id="3367955">_</a>, <a href="../../../reflect/internal/Types.scala.html#410830" title="PatternMatching.this.global.Symbol" id="1069536">clazz</a><span class="delimiter">)</span> =&gt; <a href="#1069536" title="PatternMatching.this.global.Symbol">clazz</a>.<a href="../../../reflect/internal/Symbols.scala.html#411377" title="=&gt; PatternMatching.this.global.Type">rawInfo</a> <a href="#3367959" title="(x: PatternMatching.this.global.Symbol)PatternMatching.this.global.Symbol">member</a> <a href="#1069492" title="PatternMatching.this.global.Name">name</a>
        <span class="keyword">case</span> _                          =&gt; <a href="#3367959" title="(x: PatternMatching.this.global.Symbol)PatternMatching.this.global.Symbol">NoSymbol</a>
      <span class="delimiter">}</span>
      <a href="#1069488" title="PatternMatching.this.global.Tree">pat</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Bind<a href="#3367966" title="PatternMatching.this.global.Symbol" id="3367969" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410157" title="PatternMatching.this.global.Name" id="1069549">name</a>, <a href="../../../reflect/internal/Trees.scala.html#410159" title="PatternMatching.this.global.Tree" id="3367967">_</a><span class="delimiter">)</span> =&gt;
          <a href="Typers.scala.html#538560" title="=&gt; PatternMatching.this.global.analyzer.Context">context</a>.<a href="Contexts.scala.html#538889" title="=&gt; List[PatternMatching.this.global.analyzer.Context]">enclosingContextChain</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86382" title="(z: PatternMatching.this.global.Symbol)(f: (PatternMatching.this.global.Symbol, PatternMatching.this.global.analyzer.Context) =&gt; PatternMatching.this.global.Symbol)PatternMatching.this.global.Symbol">foldLeft</a><span class="delimiter">(</span><a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span><a href="#3367971" title="(x: PatternMatching.this.global.Symbol)PatternMatching.this.global.Symbol" class="delimiter">(</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1069567">res</a>, <a title="PatternMatching.this.global.analyzer.Context" id="1069568">ctx</a><span class="delimiter">)</span> =&gt;
            <a href="#1069567" title="PatternMatching.this.global.Symbol">res</a> <a href="../../../reflect/internal/Symbols.scala.html#411489" title="(alt: =&gt; PatternMatching.this.global.Symbol)PatternMatching.this.global.Symbol">orElse</a> <a href="#1069490" title="(tpe: PatternMatching.this.global.Type, name: PatternMatching.this.global.Name)PatternMatching.this.global.Symbol">declarationOfName</a><span class="delimiter">(</span><a href="#1069568" title="PatternMatching.this.global.analyzer.Context">ctx</a>.<a href="Contexts.scala.html#538749" title="=&gt; PatternMatching.this.global.analyzer.global.Symbol">owner</a>.<a href="../../../reflect/internal/Symbols.scala.html#411377" title="=&gt; PatternMatching.this.global.analyzer.global.Type">rawInfo</a>, <a href="#1069549" title="PatternMatching.this.global.Name">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt; <a href="#3367971" title="(x: PatternMatching.this.global.Symbol)PatternMatching.this.global.Symbol">NoSymbol</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    // Issue better warnings than &quot;unreachable code&quot; when people mis-use
    // variable patterns thinking they bind to existing identifiers.
    //
    // Possible TODO: more deeply nested variable patterns, like
    //   case (a, b) =&gt; 1 ; case (c, d) =&gt; 2
    // However this is a pain (at least the way I'm going about it)
    // and I have to think these detailed errors are primarily useful
    // for beginners, not people writing nested pattern matches.
    <span class="keyword">def</span> <a title="(m: PatternMatching.this.global.Match)Unit" id="1068992">checkMatchVariablePatterns</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Match" id="1069571">m</a>: <a href="../../../reflect/internal/Trees.scala.html#408014" title="PatternMatching.this.global.Match">Match</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      // A string describing the first variable pattern
      <span class="keyword">var</span> <a title="String" id="1069573">vpat</a>: <span title="String">String</span> = <span title="Null(null)" class="keyword">null</span>
      // Using an iterator so we can recognize the last case
      <span class="keyword">val</span> <a title="Iterator[PatternMatching.this.global.CaseDef]" id="1069574">it</a> = <a href="#1069571" title="PatternMatching.this.global.Match">m</a>.<a href="../../../reflect/internal/Trees.scala.html#410099" title="=&gt; List[PatternMatching.this.global.CaseDef]">cases</a>.<a href="../../../collection/LinearSeqLike.scala.html#86318" title="=&gt; Iterator[PatternMatching.this.global.CaseDef]">iterator</a>

      <span class="keyword">def</span> <a title="(pat: PatternMatching.this.global.Tree)String" id="1069575">addendum</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1069576">pat</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <a href="#1068991" title="(pat: PatternMatching.this.global.Tree)PatternMatching.this.global.Symbol">matchingSymbolInScope</a><a href="#3367976" title="PatternMatching.this.global.Symbol" class="delimiter">(</a><a href="#1069576" title="PatternMatching.this.global.Tree">pat</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="String" id="3367979">NoSymbol</a>   =&gt; <a href="#3367982" title="(x: String)String" class="string">&quot;&quot;</a>
          <span class="keyword">case</span> sym        =&gt;
            <span class="keyword">val</span> <a title="String" id="1069578">desc</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span>sym.<a href="../../../reflect/internal/HasFlags.scala.html#409879" title="=&gt; Boolean">isParameter</a><span class="delimiter">)</span> <a href="../../../StringContext.scala.html#56629" title="(args: Any*)String">s</a>&quot;parameter $<span class="delimiter">{</span>sym.<a href="../../../reflect/internal/Symbols.scala.html#411504" title="=&gt; String">nameString</a><span class="delimiter">}</span><span class="string"> of&quot;</span> <span class="keyword">else</span> <a href="../../../Predef.scala.html#7605" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">sym</a> <a href="../../../runtime/StringAdd.scala.html#60046" title="(other: String)String">+</a> <span title="String(&quot; in&quot;)" class="string">&quot; in&quot;</span>
            <a href="../../../StringContext.scala.html#56629" title="(args: Any*)String">s</a>&quot;\nIf you intended to match against $<a href="#1069578" title="String">desc</a> $<span class="delimiter">{</span>sym.<a href="../../../reflect/internal/Symbols.scala.html#411315" title="=&gt; PatternMatching.this.global.Symbol">owner</a><span class="delimiter">}</span>, you must use backticks, like: case `$<span class="delimiter">{</span>sym.<a href="../../../reflect/internal/Symbols.scala.html#411504" title="=&gt; String">nameString</a><span class="delimiter">}</span><span class="string">` =&gt;&quot;</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#1069574" title="Iterator[PatternMatching.this.global.CaseDef]">it</a>.<a href="../../../collection/Iterator.scala.html#66747" title="=&gt; Boolean">hasNext</a><span class="delimiter">)</span> <a href="#1069590" title="()Unit" class="delimiter">{</a>
        <span class="keyword">val</span> <a title="PatternMatching.this.global.CaseDef" id="1069591">cdef</a> = <a href="#1069574" title="Iterator[PatternMatching.this.global.CaseDef]">it</a>.<a href="../../../collection/Iterator.scala.html#66748" title="()PatternMatching.this.global.CaseDef">next</a>
        // If a default case has been seen, then every succeeding case is unreachable.
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1069573" title="String">vpat</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>
          <a href="Typers.scala.html#538560" title="=&gt; PatternMatching.this.global.analyzer.Context">context</a>.<a href="Contexts.scala.html#538743" title="=&gt; PatternMatching.this.global.analyzer.global.CompilationUnit">unit</a>./*error*/<a href="../CompilationUnits.scala.html#539299" title="(pos: PatternMatching.this.global.analyzer.global.Position, msg: String)Unit">warning</a><span class="delimiter">(</span><a href="#1069591" title="PatternMatching.this.global.CaseDef">cdef</a>.<a href="../../../reflect/internal/Trees.scala.html#410184" title="=&gt; PatternMatching.this.global.Tree">body</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a>, <span title="String(&quot;unreachable code due to &quot;)" class="string">&quot;unreachable code due to &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#1069573" title="String">vpat</a> <span title="(x$1: Any)String">+</span> <a href="#1069575" title="(pat: PatternMatching.this.global.Tree)String">addendum</a><span class="delimiter">(</span><a href="#1069591" title="PatternMatching.this.global.CaseDef">cdef</a>.<a href="../../../reflect/internal/Trees.scala.html#410180" title="=&gt; PatternMatching.this.global.Tree">pat</a><span class="delimiter">)</span><span class="delimiter">)</span>
        // If this is a default case and more cases follow, warn about this one so
        // we have a reason to mention its pattern variable name and any corresponding
        // symbol in scope.  Errors will follow from the remaining cases, at least
        // once we make the above warning an error.
        <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1069574" title="Iterator[PatternMatching.this.global.CaseDef]">it</a>.<a href="../../../collection/Iterator.scala.html#66747" title="=&gt; Boolean">hasNext</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="../ast/Trees.scala.html#537807" title="PatternMatching.this.global.treeInfo.type">treeInfo</a> <a href="../../../reflect/internal/TreeInfo.scala.html#479234" title="(cdef: PatternMatching.this.global.treeInfo.global.CaseDef)Boolean">isDefaultCase</a> <a href="#1069591" title="PatternMatching.this.global.CaseDef">cdef</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="String" id="1069598">vpatName</a> = <a href="#1069591" title="PatternMatching.this.global.CaseDef">cdef</a>.<a href="../../../reflect/internal/Trees.scala.html#410180" title="=&gt; PatternMatching.this.global.Tree">pat</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> Bind<a href="#3367990" title="String" id="3367993" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410157" title="PatternMatching.this.global.Name" id="1069603">name</a>, <a href="../../../reflect/internal/Trees.scala.html#410159" title="PatternMatching.this.global.Tree" id="3367991">_</a><span class="delimiter">)</span>   =&gt; <a href="#3367995" title="(x: String)String">s</a>&quot; '$<a href="#1069603" title="PatternMatching.this.global.Name">name</a><span class="string">'&quot;</span>
            <span class="keyword">case</span> _               =&gt; <a href="#3367995" title="(x: String)String" class="string">&quot;&quot;</a>
          <span class="delimiter">}</span>
          <a href="#1069573" title="String">vpat</a> = <a href="../../../StringContext.scala.html#56629" title="(args: Any*)String">s</a>&quot;variable pattern$<a href="#1069598" title="String">vpatName</a> on line $<span class="delimiter">{</span><a href="#1069591" title="PatternMatching.this.global.CaseDef">cdef</a>.<a href="../../../reflect/internal/Trees.scala.html#410180" title="=&gt; PatternMatching.this.global.Tree">pat</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a>.<a href="../../../reflect/internal/util/Position.scala.html#409692" title="=&gt; Int">line</a><span class="delimiter">}</span><span class="string">&quot;</span>
          <a href="Typers.scala.html#538560" title="=&gt; PatternMatching.this.global.analyzer.Context">context</a>.<a href="Contexts.scala.html#538743" title="=&gt; PatternMatching.this.global.analyzer.global.CompilationUnit">unit</a>.<a href="../CompilationUnits.scala.html#539299" title="(pos: PatternMatching.this.global.analyzer.global.Position, msg: String)Unit">warning</a><span class="delimiter">(</span><a href="#1069591" title="PatternMatching.this.global.CaseDef">cdef</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a>, <a href="../../../StringContext.scala.html#56629" title="(args: Any*)String">s</a><span class="string">&quot;patterns after a variable pattern cannot match (SLS 8.1.1)&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#1069575" title="(pat: PatternMatching.this.global.Tree)String">addendum</a><span class="delimiter">(</span><a href="#1069591" title="PatternMatching.this.global.CaseDef">cdef</a>.<a href="../../../reflect/internal/Trees.scala.html#410180" title="=&gt; PatternMatching.this.global.Tree">pat</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** Implement a pattern match by turning its cases (including the implicit failure case)
      * into the corresponding (monadic) extractors, and combining them with the `orElse` combinator.
      *
      * For `scrutinee match { case1 ... caseN }`, the resulting tree has the shape
      * `runOrElse(scrutinee)(x =&gt; translateCase1(x).orElse(translateCase2(x)).....orElse(zero))`
      *
      * NOTE: the resulting tree is not type checked, nor are nested pattern matches transformed
      *   thus, you must typecheck the result (and that will in turn translate nested matches)
      *   this could probably optimized... (but note that the matchStrategy must be solved for each nested patternmatch)
      */
    <span class="keyword">def</span> <a title="(match_: PatternMatching.this.global.Match)PatternMatching.this.global.Tree" id="1068993">translateMatch</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Match" id="1069021">match_</a> : <a href="../../../reflect/internal/Trees.scala.html#408014" title="PatternMatching.this.global.Match">Match</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> Match<a href="#3368002" title="(x: (PatternMatching.this.global.Tree, List[PatternMatching.this.global.CaseDef]))(PatternMatching.this.global.Tree, List[PatternMatching.this.global.CaseDef])" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410097" title="PatternMatching.this.global.Tree" id="1069606">selector</a>, <a href="../../../reflect/internal/Trees.scala.html#410099" title="List[PatternMatching.this.global.CaseDef]" id="1069607">cases</a><span class="delimiter">)</span> = <a href="#1069021" title="PatternMatching.this.global.Match">match_</a>
      <a href="#1068992" title="(m: PatternMatching.this.global.Match)Unit">checkMatchVariablePatterns</a><span class="delimiter">(</span><a href="#1069021" title="PatternMatching.this.global.Match">match_</a><span class="delimiter">)</span>

      // we don't transform after uncurry
      // (that would require more sophistication when generating trees,
      //  and the only place that emits Matches after typers is for exception handling anyway)
      <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="../../../reflect/internal/SymbolTable.scala.html#406659" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="../../../reflect/internal/Phase.scala.html#419695" title="=&gt; Int">id</a> <a href="../../../Int.scala.html#57132" title="(x: Int)Boolean">&gt;=</a> <a href="../Global.scala.html#537672" title="=&gt; PatternMatching.this.global.Run">currentRun</a>.<a href="../Global.scala.html#539386" title="=&gt; scala.tools.nsc.Phase">uncurryPhase</a>.<a href="../../../reflect/internal/Phase.scala.html#419695" title="=&gt; Int">id</a><span class="delimiter">)</span> <a href="../Global.scala.html#537503" title="(msg: =&gt; String)Unit">debugwarn</a><span class="delimiter">(</span><span title="String(&quot;running translateMatch at &quot;)" class="string">&quot;running translateMatch at &quot;</span><span title="(x$1: Any)String">+</span> <a href="../../../reflect/internal/SymbolTable.scala.html#406659" title="=&gt; scala.reflect.internal.Phase">phase</a> <span title="(x$1: Any)String">+</span><span title="String(&quot; on &quot;)" class="string">&quot; on &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1069606" title="PatternMatching.this.global.Tree">selector</a> <span title="(x$1: Any)String">+</span><span title="String(&quot; match &quot;)" class="string">&quot; match &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1069607" title="List[PatternMatching.this.global.CaseDef]">cases</a><span class="delimiter">)</span>
      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;translating &quot;)" class="string">&quot;translating &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1069607" title="List[PatternMatching.this.global.CaseDef]">cases</a>.<a href="../../../collection/TraversableOnce.scala.html#58282" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;{&quot;)" class="string">&quot;{&quot;</span>, <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span>, <span title="String(&quot;}&quot;)" class="string">&quot;}&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="(Long, Long)" id="1069608">start</a> = <span title="(Long, Long)" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415273" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415233" title="(tm: scala.reflect.internal.util.Statistics.Timer)(Long, Long)">startTimer</a><span class="delimiter">(</span><a href="#624634" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatNanos</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

      <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1069609">selectorTp</a> = <a href="../../../reflect/internal/Definitions.scala.html#408824" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">repeatedToSeq</a><span class="delimiter">(</span><a href="../../../reflect/internal/Types.scala.html#407591" title="(t: PatternMatching.this.global.Type)PatternMatching.this.global.Type">elimAnonymousClass</a><span class="delimiter">(</span><a href="#1069606" title="PatternMatching.this.global.Tree">selector</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#408411" title="=&gt; PatternMatching.this.global.Type">widen</a>.<a href="../../../reflect/internal/Types.scala.html#408510" title="=&gt; PatternMatching.this.global.Type">withoutAnnotations</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1069610">origPt</a>  = <a href="#1069021" title="PatternMatching.this.global.Match">match_</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>
      // when one of the internal cps-type-state annotations is present, strip all CPS annotations
      // a cps-type-state-annotated type makes no sense as an expected type (matchX.tpe is used as pt in translateMatch)
      // (only test availability of MarkerCPSAdaptPlus assuming they are either all available or none of them are)
      <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1069611">ptUnCPS</a> =
        <span title="PatternMatching.this.global.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#621362" title="=&gt; PatternMatching.this.global.Symbol">MarkerCPSAdaptPlus</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#621368" title="=&gt; List[PatternMatching.this.global.Symbol]">stripTriggerCPSAnns</a> <a href="../../../collection/LinearSeqOptimized.scala.html#86379" title="(p: PatternMatching.this.global.Symbol =&gt; Boolean)Boolean">exists</a> <a href="#1069610" title="PatternMatching.this.global.Type">origPt</a>.<a href="../../../reflect/internal/AnnotationInfos.scala.html#408615" title="(cls: PatternMatching.this.global.Symbol)Boolean">hasAnnotation</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#621374" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">removeCPSAdaptAnnotations</a><span class="delimiter">(</span><a href="#1069610" title="PatternMatching.this.global.Type">origPt</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#1069610" title="PatternMatching.this.global.Type">origPt</a>

      // relevant test cases: pos/existentials-harmful.scala, pos/gadt-gilles.scala, pos/t2683.scala, pos/virtpatmat_exist4.scala
      // pt is the skolemized version
      <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1069612">pt</a> = <a href="../../../reflect/internal/Definitions.scala.html#408824" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">repeatedToSeq</a><span class="delimiter">(</span><a href="#1069611" title="PatternMatching.this.global.Type">ptUnCPS</a><span class="delimiter">)</span>

      // val packedPt = repeatedToSeq(typer.packedType(match_, context.owner))

      // the alternative to attaching the default case override would be to simply
      // append the default to the list of cases and suppress the unreachable case error that may arise (once we detect that...)
      <span class="keyword">val</span> <a title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]" id="1069613">matchFailGenOverride</a> = <a href="#1069021" title="PatternMatching.this.global.Match">match_</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#409595" title="=&gt; scala.reflect.macros.Attachments{type Pos = PatternMatching.this.global.Position}">attachments</a>.<a href="../../../reflect/macros/Attachments.scala.html#402528" title="[T](implicit evidence$2: scala.reflect.ClassTag[T])Option[T]">get</a><a href="../../../reflect/ClassTag.scala.html#81051" title="(implicit evidence$2: scala.reflect.ClassTag[PatternMatching.this.DefaultOverrideMatchAttachment])Option[PatternMatching.this.DefaultOverrideMatchAttachment]" class="delimiter">[</a><a href="#1094202" title="PatternMatching.this.DefaultOverrideMatchAttachment">DefaultOverrideMatchAttachment</a><span class="delimiter">]</span>.<a href="../../../Option.scala.html#62865" title="(f: PatternMatching.this.DefaultOverrideMatchAttachment =&gt; (PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree))Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">map</a><a href="#1069669" title="PatternMatching.this.DefaultOverrideMatchAttachment" class="delimiter">{</a><span class="keyword">case</span> DefaultOverrideMatchAttachment<span class="delimiter">(</span><a href="#1094199" title="PatternMatching.this.global.Tree" id="1069688">default</a><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span><span class="delimiter">(</span>scrut: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span> =&gt; <a href="#1069688" title="PatternMatching.this.global.Tree">default</a><span class="delimiter">)</span><span class="delimiter">}</span>

      <span class="keyword">val</span> <a title="PatternMatching.this.global.TermSymbol" id="1069614">selectorSym</a> = <a href="#1069013" title="(pos: PatternMatching.this.global.Position, tp: PatternMatching.this.global.Type, prefix: String)PatternMatching.this.global.TermSymbol">freshSym</a><span class="delimiter">(</span><a href="#1069606" title="PatternMatching.this.global.Tree">selector</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a>, <a href="#1068985" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">pureType</a><span class="delimiter">(</span><a href="#1069609" title="PatternMatching.this.global.Type">selectorTp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../reflect/internal/Symbols.scala.html#411236" title="(mask: Long)PatternMatching.this.global.TermSymbol">setFlag</a> treeInfo.<span title="Long(2099200L)">SYNTH_CASE_FLAGS</span>

      // pt = Any* occurs when compiling test/files/pos/annotDepMethType.scala  with -Xexperimental
      <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1069615">combined</a> = <a href="#1069072" title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, casesRaw: List[List[MatchTranslation.this.TreeMaker]], pt: PatternMatching.this.global.Type, owner: PatternMatching.this.global.Symbol, matchFailGenOverride: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree])PatternMatching.this.global.Tree">combineCases</a><span class="delimiter">(</span><a href="#1069606" title="PatternMatching.this.global.Tree">selector</a>, <a href="#1069614" title="PatternMatching.this.global.TermSymbol">selectorSym</a>, <a href="#1069607" title="List[PatternMatching.this.global.CaseDef]">cases</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.CaseDef =&gt; List[MatchTranslation.this.TreeMaker])(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.CaseDef],List[MatchTranslation.this.TreeMaker],List[List[MatchTranslation.this.TreeMaker]]])List[List[MatchTranslation.this.TreeMaker]]">map</a> <a href="#1068995" title="(scrutSym: PatternMatching.this.global.Symbol, pt: PatternMatching.this.global.Type)(caseDef: PatternMatching.this.global.CaseDef)List[MatchTranslation.this.TreeMaker]">translateCase</a><a href="#1069898" title="PatternMatching.this.global.CaseDef" class="delimiter">(</a><a href="#1069614" title="PatternMatching.this.global.TermSymbol">selectorSym</a>, <a href="#1069612" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span>, <a href="#1069612" title="PatternMatching.this.global.Type">pt</a>, <a href="#1068980" title="=&gt; PatternMatching.this.global.analyzer.global.Symbol">matchOwner</a>, <a href="#1069613" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">matchFailGenOverride</a><span class="delimiter">)</span>

      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415273" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415234" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: (Long, Long))Unit">stopTimer</a><span class="delimiter">(</span><a href="#624634" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatNanos</a>, <a href="#1069608" title="(Long, Long)">start</a><span class="delimiter">)</span>
      <a href="#1069615" title="PatternMatching.this.global.Tree">combined</a>
    <span class="delimiter">}</span>

    // return list of typed CaseDefs that are supported by the backend (typed/bind/wildcard)
    // we don't have a global scrutinee -- the caught exception must be bound in each of the casedefs
    // there's no need to check the scrutinee for null -- &quot;throw null&quot; becomes &quot;throw new NullPointerException&quot;
    // try to simplify to a type-based switch, or fall back to a catch-all case that runs a normal pattern match
    // unlike translateMatch, we type our result before returning it
    <span class="keyword">def</span> <a title="(caseDefs: List[PatternMatching.this.global.CaseDef], pt: PatternMatching.this.global.Type, pos: PatternMatching.this.global.Position)List[PatternMatching.this.global.CaseDef]" id="1068994">translateTry</a><span class="delimiter">(</span><a title="List[PatternMatching.this.global.CaseDef]" id="1069120">caseDefs</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span>, <a title="PatternMatching.this.global.Type" id="1069121">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <a title="PatternMatching.this.global.Position" id="1069122">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#22953" title="PatternMatching.this.global.Position">Position</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span> =
      // if they're already simple enough to be handled by the back-end, we're done
      <span title="List[PatternMatching.this.global.CaseDef]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1069120" title="List[PatternMatching.this.global.CaseDef]">caseDefs</a> <a href="../../../collection/LinearSeqOptimized.scala.html#86378" title="(p: PatternMatching.this.global.CaseDef =&gt; Boolean)Boolean">forall</a> <a href="../ast/Trees.scala.html#537807" title="PatternMatching.this.global.treeInfo.type">treeInfo</a>.<a href="../../../reflect/internal/TreeInfo.scala.html#479237" title="(cdef: PatternMatching.this.global.treeInfo.global.CaseDef)Boolean">isCatchCase</a><span class="delimiter">)</span> <a href="#1069120" title="List[PatternMatching.this.global.CaseDef]">caseDefs</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="List[PatternMatching.this.global.CaseDef]" id="1069940">swatches</a> = <span class="delimiter">{</span> // switch-catches
          <span class="keyword">val</span> <a title="List[(PatternMatching.this.global.TermSymbol, List[MatchTranslation.this.TreeMaker])]" id="1069942">bindersAndCases</a> = <a href="#1069120" title="List[PatternMatching.this.global.CaseDef]">caseDefs</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.CaseDef =&gt; (PatternMatching.this.global.TermSymbol, List[MatchTranslation.this.TreeMaker]))(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.CaseDef],(PatternMatching.this.global.TermSymbol, List[MatchTranslation.this.TreeMaker]),List[(PatternMatching.this.global.TermSymbol, List[MatchTranslation.this.TreeMaker])]])List[(PatternMatching.this.global.TermSymbol, List[MatchTranslation.this.TreeMaker])]">map</a> <span class="delimiter">{</span> <a title="PatternMatching.this.global.CaseDef" id="1069959">caseDef</a> =&gt;
            // generate a fresh symbol for each case, hoping we'll end up emitting a type-switch (we don't have a global scrut there)
            // if we fail to emit a fine-grained switch, have to do translateCase again with a single scrutSym (TODO: uniformize substitution on treemakers so we can avoid this)
            <span class="keyword">val</span> <a title="PatternMatching.this.global.TermSymbol" id="1069960">caseScrutSym</a> = <a href="#1069013" title="(pos: PatternMatching.this.global.Position, tp: PatternMatching.this.global.Type, prefix: String)PatternMatching.this.global.TermSymbol">freshSym</a><span class="delimiter">(</span><a href="#1069122" title="PatternMatching.this.global.Position">pos</a>, <a href="#1068985" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">pureType</a><span class="delimiter">(</span><a href="../../../reflect/internal/Definitions.scala.html#408712" title="=&gt; PatternMatching.this.global.ClassSymbol">ThrowableClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.TermSymbol, _2: List[MatchTranslation.this.TreeMaker])(PatternMatching.this.global.TermSymbol, List[MatchTranslation.this.TreeMaker])" class="delimiter">(</a><a href="#1069960" title="PatternMatching.this.global.TermSymbol">caseScrutSym</a>, <a href="#1069071" title="(treeMakers: List[MatchTranslation.this.TreeMaker], initial: MatchTranslation.this.Substitution)List[MatchTranslation.this.TreeMaker]">propagateSubstitution</a><span class="delimiter">(</span><a href="#1068995" title="(scrutSym: PatternMatching.this.global.Symbol, pt: PatternMatching.this.global.Type)(caseDef: PatternMatching.this.global.CaseDef)List[MatchTranslation.this.TreeMaker]">translateCase</a><span class="delimiter">(</span><a href="#1069960" title="PatternMatching.this.global.TermSymbol">caseScrutSym</a>, <a href="#1069121" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1069959" title="PatternMatching.this.global.CaseDef">caseDef</a><span class="delimiter">)</span>, <a href="#1069027" title="MatchTranslation.this.EmptySubstitution.type">EmptySubstitution</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>

          <span class="keyword">for</span><span class="delimiter">(</span><a title="List[PatternMatching.this.global.CaseDef]" id="1070040">cases</a> &lt;- <a href="#1069033" title="(bindersAndCases: List[(PatternMatching.this.global.Symbol, List[MatchTranslation.this.TreeMaker])], pt: PatternMatching.this.global.Type)Option[List[PatternMatching.this.global.CaseDef]]">emitTypeSwitch</a><span class="delimiter">(</span><a href="#1069942" title="List[(PatternMatching.this.global.TermSymbol, List[MatchTranslation.this.TreeMaker])]">bindersAndCases</a>, <a href="#1069121" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span>.<a href="../../../collection/generic/FilterMonadic.scala.html#58166" title="(f: List[PatternMatching.this.global.CaseDef] =&gt; scala.collection.GenTraversableOnce[PatternMatching.this.global.CaseDef])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[PatternMatching.this.global.CaseDef]],PatternMatching.this.global.CaseDef,List[PatternMatching.this.global.CaseDef]])List[PatternMatching.this.global.CaseDef]">toList</a>;
              <span class="keyword">if</span> <a href="#1070040" title="List[PatternMatching.this.global.CaseDef]">cases</a> <a href="../../../collection/LinearSeqOptimized.scala.html#86378" title="(p: PatternMatching.this.global.CaseDef =&gt; Boolean)Boolean">forall</a> <a href="../ast/Trees.scala.html#537807" title="PatternMatching.this.global.treeInfo.type">treeInfo</a>.<a href="../../../reflect/internal/TreeInfo.scala.html#479237" title="(cdef: PatternMatching.this.global.treeInfo.global.CaseDef)Boolean">isCatchCase</a>; // must check again, since it's not guaranteed -- TODO: can we eliminate this? e.g., a type test could test for a trait or a non-trivial prefix, which are not handled by the back-end
              <a title="PatternMatching.this.global.CaseDef" id="1070057">cse</a> &lt;- <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.CaseDef =&gt; PatternMatching.this.global.CaseDef)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.CaseDef],PatternMatching.this.global.CaseDef,List[PatternMatching.this.global.CaseDef]])List[PatternMatching.this.global.CaseDef]">cases</a><span class="delimiter">)</span> <span class="keyword">yield</span> <a href="#1069074" title="(origOwner: PatternMatching.this.global.Symbol, pos: PatternMatching.this.global.Position)PatternMatching.this.global.Traverser">fixerUpper</a><a href="../../../reflect/api/Trees.scala.html#405549" title="(tree: PatternMatching.this.global.CaseDef)PatternMatching.this.global.CaseDef" class="delimiter">(</a><a href="#1068980" title="=&gt; PatternMatching.this.global.analyzer.global.Symbol">matchOwner</a>, <a href="#1069122" title="PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1070057" title="PatternMatching.this.global.CaseDef">cse</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PatternMatching.this.global.CaseDef" class="delimiter">[</span><a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">]</span>
        <span class="delimiter">}</span>

        <span class="keyword">val</span> <a title="List[PatternMatching.this.global.CaseDef]" id="1069941">catches</a> = <span title="List[PatternMatching.this.global.CaseDef]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1069940" title="List[PatternMatching.this.global.CaseDef]">swatches</a>.<a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <a href="#1069940" title="List[PatternMatching.this.global.CaseDef]">swatches</a> <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="PatternMatching.this.global.TermSymbol" id="1070273">scrutSym</a> = <a href="#1069013" title="(pos: PatternMatching.this.global.Position, tp: PatternMatching.this.global.Type, prefix: String)PatternMatching.this.global.TermSymbol">freshSym</a><span class="delimiter">(</span><a href="#1069122" title="PatternMatching.this.global.Position">pos</a>, <a href="#1068985" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">pureType</a><span class="delimiter">(</span><a href="../../../reflect/internal/Definitions.scala.html#408712" title="=&gt; PatternMatching.this.global.ClassSymbol">ThrowableClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[List[MatchTranslation.this.TreeMaker]]" id="1070274">casesNoSubstOnly</a> = <a href="#1069120" title="List[PatternMatching.this.global.CaseDef]">caseDefs</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.CaseDef =&gt; List[MatchTranslation.this.TreeMaker])(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.CaseDef],List[MatchTranslation.this.TreeMaker],List[List[MatchTranslation.this.TreeMaker]]])List[List[MatchTranslation.this.TreeMaker]]">map</a> <span class="delimiter">{</span> <a title="PatternMatching.this.global.CaseDef" id="1070292">caseDef</a> =&gt; <span class="delimiter">(</span><a href="#1069071" title="(treeMakers: List[MatchTranslation.this.TreeMaker], initial: MatchTranslation.this.Substitution)List[MatchTranslation.this.TreeMaker]">propagateSubstitution</a><span class="delimiter">(</span><a href="#1068995" title="(scrutSym: PatternMatching.this.global.Symbol, pt: PatternMatching.this.global.Type)(caseDef: PatternMatching.this.global.CaseDef)List[MatchTranslation.this.TreeMaker]">translateCase</a><span class="delimiter">(</span><a href="#1070273" title="PatternMatching.this.global.TermSymbol">scrutSym</a>, <a href="#1069121" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1070292" title="PatternMatching.this.global.CaseDef">caseDef</a><span class="delimiter">)</span>, <a href="#1069027" title="MatchTranslation.this.EmptySubstitution.type">EmptySubstitution</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">}</span>

          <span class="keyword">val</span> <a title="PatternMatching.this.global.TermSymbol" id="1070275">exSym</a> = <a href="#1069013" title="(pos: PatternMatching.this.global.Position, tp: PatternMatching.this.global.Type, prefix: String)PatternMatching.this.global.TermSymbol">freshSym</a><span class="delimiter">(</span><a href="#1069122" title="PatternMatching.this.global.Position">pos</a>, <a href="#1068985" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">pureType</a><span class="delimiter">(</span><a href="../../../reflect/internal/Definitions.scala.html#408712" title="=&gt; PatternMatching.this.global.ClassSymbol">ThrowableClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span>, <span title="String(&quot;ex&quot;)" class="string">&quot;ex&quot;</span><span class="delimiter">)</span>

          <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.CaseDef*)List[PatternMatching.this.global.CaseDef]">List</a><span class="delimiter">(</span>
              <a href="../../../reflect/internal/Positions.scala.html#408315" title="(pos: PatternMatching.this.global.Position)(tree: PatternMatching.this.global.CaseDef)PatternMatching.this.global.CaseDef">atPos</a><span class="delimiter">(</span><a href="#1069122" title="PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="../../../reflect/internal/Trees.scala.html#453147" title="(pat: PatternMatching.this.global.Tree, guard: PatternMatching.this.global.Tree, body: PatternMatching.this.global.Tree)PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">(</span>
                  <a href="../../../reflect/internal/Trees.scala.html#408115" title="(sym: PatternMatching.this.global.Symbol, body: PatternMatching.this.global.Tree)PatternMatching.this.global.Bind">Bind</a><span class="delimiter">(</span><a href="#1070275" title="PatternMatching.this.global.TermSymbol">exSym</a>, <a href="../../../reflect/internal/Trees.scala.html#418125" title="(name: PatternMatching.this.global.Name)PatternMatching.this.global.Ident">Ident</a><span class="delimiter">(</span><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/StdNames.scala.html#413714" title="=&gt; PatternMatching.this.global.nme.NameType">WILDCARD</a><span class="delimiter">)</span><span class="delimiter">)</span>, // TODO: does this need fixing upping?
                  <a href="../../../reflect/internal/Trees.scala.html#407946" title="PatternMatching.this.global.EmptyTree.type">EmptyTree</a>,
                  <a href="#1069073" title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, casesNoSubstOnly: List[List[MatchTranslation.this.TreeMaker]], pt: PatternMatching.this.global.Type, owner: PatternMatching.this.global.Symbol, matchFailGenOverride: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree])PatternMatching.this.global.Tree">combineCasesNoSubstOnly</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1070275" title="PatternMatching.this.global.TermSymbol">exSym</a><span class="delimiter">)</span>, <a href="#1070273" title="PatternMatching.this.global.TermSymbol">scrutSym</a>, <a href="#1070274" title="List[List[MatchTranslation.this.TreeMaker]]">casesNoSubstOnly</a>, <a href="#1069121" title="PatternMatching.this.global.Type">pt</a>, <a href="#1068980" title="=&gt; PatternMatching.this.global.analyzer.global.Symbol">matchOwner</a>, <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Throw)Some[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Throw]">Some</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1070406">scrut</a> =&gt; <a href="../../../reflect/internal/Trees.scala.html#453782" title="(expr: PatternMatching.this.global.Tree)PatternMatching.this.global.Throw">Throw</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1070275" title="PatternMatching.this.global.TermSymbol">exSym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="delimiter">)</span>
              <span class="delimiter">}</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        <a href="#1068979" title="=&gt; PatternMatching.this.global.analyzer.Typer">typer</a>.<a href="Typers.scala.html#538654" title="(cases: List[PatternMatching.this.global.analyzer.global.CaseDef], pattp: PatternMatching.this.global.analyzer.global.Type, pt: PatternMatching.this.global.analyzer.global.Type)List[PatternMatching.this.global.analyzer.global.CaseDef]">typedCases</a><span class="delimiter">(</span><a href="#1069941" title="List[PatternMatching.this.global.CaseDef]">catches</a>, <a href="../../../reflect/internal/Definitions.scala.html#408712" title="=&gt; PatternMatching.this.global.ClassSymbol">ThrowableClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a>, <a href="../../../reflect/internal/Types.scala.html#407279" title="PatternMatching.this.global.WildcardType.type">WildcardType</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>



    /**  The translation of `pat if guard =&gt; body` has two aspects:
      *     1) the substitution due to the variables bound by patterns
      *     2) the combination of the extractor calls using `flatMap`.
      *
      * 2) is easy -- it looks like: `translatePattern_1.flatMap(translatePattern_2....flatMap(translatePattern_N.flatMap(translateGuard.flatMap((x_i) =&gt; success(Xbody(x_i)))))...)`
      *     this must be right-leaning tree, as can be seen intuitively by considering the scope of bound variables:
      *     variables bound by pat_1 must be visible from the function inside the left-most flatMap right up to Xbody all the way on the right
      * 1) is tricky because translatePattern_i determines the shape of translatePattern_i+1:
      *    zoom in on `translatePattern_1.flatMap(translatePattern_2)` for example -- it actually looks more like:
      *      `translatePattern_1(x_scrut).flatMap((x_1) =&gt; {y_i -&gt; x_1._i}translatePattern_2)`
      *
      *    `x_1` references the result (inside the monad) of the extractor corresponding to `pat_1`,
      *    this result holds the values for the constructor arguments, which translatePattern_1 has extracted
      *    from the object pointed to by `x_scrut`. The `y_i` are the symbols bound by `pat_1` (in order)
      *    in the scope of the remainder of the pattern, and they must thus be replaced by:
      *      - (for 1-ary unapply) x_1
      *      - (for n-ary unapply, n &gt; 1) selection of the i'th tuple component of `x_1`
      *      - (for unapplySeq) x_1.apply(i)
      *
      *    in the treemakers,
      *
      *    Thus, the result type of `translatePattern_i`'s extractor must conform to `M[(T_1,..., T_n)]`.
      *
      *    Operationally, phase 1) is a foldLeft, since we must consider the depth-first-flattening of
      *    the transformed patterns from left to right. For every pattern ast node, it produces a transformed ast and
      *    a function that will take care of binding and substitution of the next ast (to the right).
      *
      */
    <span class="keyword">def</span> <a title="(scrutSym: PatternMatching.this.global.Symbol, pt: PatternMatching.this.global.Type)(caseDef: PatternMatching.this.global.CaseDef)List[MatchTranslation.this.TreeMaker]" id="1068995">translateCase</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1069750">scrutSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1069751">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="PatternMatching.this.global.CaseDef" id="1069752">caseDef</a>: <a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">)</span> = <a href="#1069752" title="PatternMatching.this.global.CaseDef">caseDef</a> <span class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> CaseDef<span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#410180" title="PatternMatching.this.global.Tree" id="1069764">pattern</a>, <a href="../../../reflect/internal/Trees.scala.html#410182" title="PatternMatching.this.global.Tree" id="1069765">guard</a>, <a href="../../../reflect/internal/Trees.scala.html#410184" title="PatternMatching.this.global.Tree" id="1069766">body</a><span class="delimiter">)</span> =&gt;
      <a href="#1068996" title="(patBinder: PatternMatching.this.global.Symbol, patTree: PatternMatching.this.global.Tree)List[MatchTranslation.this.TreeMaker]">translatePattern</a><span class="delimiter">(</span><a href="#1069750" title="PatternMatching.this.global.Symbol">scrutSym</a>, <a href="#1069764" title="PatternMatching.this.global.Tree">pattern</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#62697" title="(that: scala.collection.GenTraversableOnce[MatchTranslation.this.TreeMaker])(implicit bf: scala.collection.generic.CanBuildFrom[List[MatchTranslation.this.TreeMaker],MatchTranslation.this.TreeMaker,List[MatchTranslation.this.TreeMaker]])List[MatchTranslation.this.TreeMaker]">++</a> <a href="#1068997" title="(guard: PatternMatching.this.global.Tree)List[MatchTranslation.this.TreeMaker]">translateGuard</a><span class="delimiter">(</span><a href="#1069765" title="PatternMatching.this.global.Tree">guard</a><span class="delimiter">)</span> <a href="#3368014" title="(x: List[MatchTranslation.this.TreeMaker])List[MatchTranslation.this.TreeMaker]">:+</a> <a href="#1068998" title="(body: PatternMatching.this.global.Tree, matchPt: PatternMatching.this.global.Type)MatchTranslation.this.TreeMaker">translateBody</a><span class="delimiter">(</span><a href="#1069766" title="PatternMatching.this.global.Tree">body</a>, <a href="#1069751" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(patBinder: PatternMatching.this.global.Symbol, patTree: PatternMatching.this.global.Tree)List[MatchTranslation.this.TreeMaker]" id="1068996">translatePattern</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1069767">patBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Tree" id="1069768">patTree</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[MatchTranslation.this.TreeMaker]">List</a><span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span> = <span class="delimiter">{</span>
      // a list of TreeMakers that encode `patTree`, and a list of arguments for recursive invocations of `translatePattern` to encode its subpatterns
      <span class="keyword">type</span> <a title="(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" id="1070432">TranslationStep</a> = <a href="../../../Tuple2.scala.html#783" title="(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" class="delimiter">(</a>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span>, List<span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Tree<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(treeMakers: List[MatchTranslation.this.TreeMaker], subpats: (PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)*)(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" id="1070433">withSubPats</a><span class="delimiter">(</span><a title="List[MatchTranslation.this.TreeMaker]" id="1070442">treeMakers</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[MatchTranslation.this.TreeMaker]">List</a><span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span>, <a title="(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)*" id="1070443">subpats</a>: <span title="(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)*" class="delimiter">(</span>Symbol, Tree<span class="delimiter">)</span>*<span class="delimiter">)</span>: <a href="../../../Tuple2.scala.html#783" title="(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">TranslationStep</a> = <a href="../../../Tuple2.scala.html#62849" title="(_1: List[MatchTranslation.this.TreeMaker], _2: List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" class="delimiter">(</a><a href="#1070442" title="List[MatchTranslation.this.TreeMaker]">treeMakers</a>, <a href="#1070443" title="(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)*">subpats</a>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">toList</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(treeMakers: MatchTranslation.this.TreeMaker*)(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" id="1070434">noFurtherSubPats</a><span class="delimiter">(</span><a title="MatchTranslation.this.TreeMaker*" id="1070454">treeMakers</a>: <span title="MatchTranslation.this.TreeMaker*">TreeMaker</span>*<span class="delimiter">)</span>: <a href="../../../Tuple2.scala.html#783" title="(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">TranslationStep</a> = <a href="../../../Tuple2.scala.html#62849" title="(_1: List[MatchTranslation.this.TreeMaker], _2: scala.collection.immutable.Nil.type)(List[MatchTranslation.this.TreeMaker], scala.collection.immutable.Nil.type)" class="delimiter">(</a><a href="#1070454" title="MatchTranslation.this.TreeMaker*">treeMakers</a>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[MatchTranslation.this.TreeMaker]">toList</a>, <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="PatternMatching.this.global.Position" id="1070435">pos</a> = <a href="#1069768" title="PatternMatching.this.global.Tree">patTree</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a>

      <span class="keyword">def</span> <a title="(extractor: MatchTranslation.this.ExtractorCall)(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" id="1070436">translateExtractorPattern</a><span class="delimiter">(</span><a title="MatchTranslation.this.ExtractorCall" id="1070461">extractor</a>: <a href="#1069001" title="MatchTranslation.this.ExtractorCall">ExtractorCall</a><span class="delimiter">)</span>: <a href="../../../Tuple2.scala.html#783" title="(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">TranslationStep</a> = <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1070461" title="MatchTranslation.this.ExtractorCall">extractor</a>.<a href="#1070468" title="=&gt; Boolean">isTyped</a><span class="delimiter">)</span> <a href="ContextErrors.scala.html#538496" title="PatternMatching.this.global.analyzer.ErrorUtils.type">ErrorUtils</a>.<a href="ContextErrors.scala.html#1024813" title="(tree: PatternMatching.this.global.analyzer.global.Tree, msg: String)(implicit context: PatternMatching.this.global.analyzer.Context)Unit">issueNormalTypeError</a><span class="delimiter">(</span><a href="#1069768" title="PatternMatching.this.global.Tree">patTree</a>, <span title="String(&quot;Could not typecheck extractor call: &quot;)" class="string">&quot;Could not typecheck extractor call: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1070461" title="MatchTranslation.this.ExtractorCall">extractor</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Typers.scala.html#538560" title="=&gt; PatternMatching.this.global.analyzer.Context">context</a><span class="delimiter">)</span>
        // if (extractor.resultInMonad == ErrorType) throw new TypeError(pos, &quot;Unsupported extractor type: &quot;+ extractor.tpe)

        <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;translateExtractorPattern checking parameter type: &quot;)" class="string">&quot;translateExtractorPattern checking parameter type: &quot;</span><a href="../../../Tuple4.scala.html#83441" title="(x$1: Any)String">+</a> <span class="delimiter">(</span><a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a>, <a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411367" title="=&gt; PatternMatching.this.global.Type">info</a>.<a href="../../../reflect/internal/Types.scala.html#408411" title="=&gt; PatternMatching.this.global.Type">widen</a>, <a href="#1070461" title="MatchTranslation.this.ExtractorCall">extractor</a>.<a href="#1070472" title="=&gt; PatternMatching.this.global.Type">paramType</a>, <a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411367" title="=&gt; PatternMatching.this.global.Type">info</a>.<a href="../../../reflect/internal/Types.scala.html#408411" title="=&gt; PatternMatching.this.global.Type">widen</a> <a href="../../../reflect/internal/Types.scala.html#408481" title="(that: PatternMatching.this.global.Type)Boolean">&lt;:&lt;</a> <a href="#1070461" title="MatchTranslation.this.ExtractorCall">extractor</a>.<a href="#1070472" title="=&gt; PatternMatching.this.global.Type">paramType</a><span class="delimiter">)</span><span class="delimiter">)</span>

        // must use type `tp`, which is provided by extractor's result, not the type expected by binder,
        // as b.info may be based on a Typed type ascription, which has not been taken into account yet by the translation
        // (it will later result in a type test when `tp` is not a subtype of `b.info`)
        // TODO: can we simplify this, together with the Bound case?
        <a href="../../../Predef.scala.html#7531" title="(x: (List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.Type]))runtime.Tuple2Zipped.Ops[List[PatternMatching.this.global.Symbol],List[PatternMatching.this.global.Type]]" class="delimiter">(</a><a href="#1070461" title="MatchTranslation.this.ExtractorCall">extractor</a>.<a href="#1070474" title="=&gt; List[PatternMatching.this.global.Symbol]">subPatBinders</a>, <a href="#1070461" title="MatchTranslation.this.ExtractorCall">extractor</a>.<a href="#1070478" title="=&gt; List[PatternMatching.this.global.Type]">subPatTypes</a><span class="delimiter">)</span>.<a href="../../../runtime/Tuple2Zipped.scala.html#60613" title="(implicit w1: List[PatternMatching.this.global.Symbol] =&gt; scala.collection.TraversableLike[PatternMatching.this.global.Symbol,List[PatternMatching.this.global.Symbol]], implicit w2: List[PatternMatching.this.global.Type] =&gt; scala.collection.IterableLike[PatternMatching.this.global.Type,List[PatternMatching.this.global.Type]])scala.runtime.Tuple2Zipped[PatternMatching.this.global.Symbol,List[PatternMatching.this.global.Symbol],PatternMatching.this.global.Type,List[PatternMatching.this.global.Type]]">zipped</a> <a href="../../../runtime/Tuple2Zipped.scala.html#486057" title="(f: (PatternMatching.this.global.Symbol, PatternMatching.this.global.Type) =&gt; PatternMatching.this.global.Symbol)Unit">foreach</a> <a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Symbol, _2: PatternMatching.this.global.Type)(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Symbol" id="1070645">b</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Type" id="1070646">tp</a><span class="delimiter">)</span> =&gt;
          <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;changing &quot;)" class="string">&quot;changing &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1070645" title="PatternMatching.this.global.Symbol">b</a> <span title="(x$1: Any)String">+</span><span title="String(&quot; : &quot;)" class="string">&quot; : &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1070645" title="PatternMatching.this.global.Symbol">b</a>.<a href="../../../reflect/internal/Symbols.scala.html#411367" title="=&gt; PatternMatching.this.global.Type">info</a> <span title="(x$1: Any)String">+</span><span title="String(&quot; -&gt; &quot;)" class="string">&quot; -&gt; &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1070646" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>
          <a href="#1070645" title="PatternMatching.this.global.Symbol">b</a> <a href="../../../reflect/internal/Symbols.scala.html#411369" title="(info: PatternMatching.this.global.Type)b.type">setInfo</a> <a href="#1070646" title="PatternMatching.this.global.Type">tp</a>
        <span class="delimiter">}</span>

        // example check: List[Int] &lt;:&lt; ::[Int]
        // TODO: extractor.paramType may contain unbound type params (run/t2800, run/t3530)
        <span class="keyword">val</span> <a href="#3368026" title="(x: (List[MatchTranslation.this.TypeTestTreeMaker], PatternMatching.this.global.Symbol))(List[MatchTranslation.this.TypeTestTreeMaker], PatternMatching.this.global.Symbol)" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="List[MatchTranslation.this.TypeTestTreeMaker]" id="1070497">typeTestTreeMaker</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Symbol" id="1070498">patBinderOrCasted</a><span class="delimiter">)</span> =
          <a href="#3368024" title="(List[MatchTranslation.this.TypeTestTreeMaker], PatternMatching.this.global.Symbol)" class="keyword">if</a> <span class="delimiter">(</span><a href="#1069056" title="(tp: PatternMatching.this.global.Type, pt: PatternMatching.this.global.Type)Boolean">needsTypeTest</a><span class="delimiter">(</span><a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411367" title="=&gt; PatternMatching.this.global.Type">info</a>.<a href="../../../reflect/internal/Types.scala.html#408411" title="=&gt; PatternMatching.this.global.Type">widen</a>, <a href="#1070461" title="MatchTranslation.this.ExtractorCall">extractor</a>.<a href="#1070472" title="=&gt; PatternMatching.this.global.Type">paramType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            // chain a type-testing extractor before the actual extractor call
            // it tests the type, checks the outer pointer and casts to the expected type
            // TODO: the outer check is mandated by the spec for case classes, but we do it for user-defined unapplies as well [SPEC]
            // (the prefix of the argument passed to the unapply must equal the prefix of the type of the binder)
            <span class="keyword">val</span> <a title="MatchTranslation.this.TypeTestTreeMaker" id="1070657">treeMaker</a> = <a href="#1074623" title="(prevBinder: PatternMatching.this.global.Symbol, testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type, nextBinderTp: PatternMatching.this.global.Type)(pos: PatternMatching.this.global.Position, extractorArgTypeTest: Boolean)MatchTranslation.this.TypeTestTreeMaker">TypeTestTreeMaker</a><span class="delimiter">(</span><a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a>, <a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a>, <a href="#1070461" title="MatchTranslation.this.ExtractorCall">extractor</a>.<a href="#1070472" title="=&gt; PatternMatching.this.global.Type">paramType</a>, <a href="#1070461" title="MatchTranslation.this.ExtractorCall">extractor</a>.<a href="#1070472" title="=&gt; PatternMatching.this.global.Type">paramType</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1070435" title="PatternMatching.this.global.Position">pos</a>, extractorArgTypeTest = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
            <a href="../../../Tuple2.scala.html#62849" title="(_1: List[MatchTranslation.this.TypeTestTreeMaker], _2: PatternMatching.this.global.TermSymbol)(List[MatchTranslation.this.TypeTestTreeMaker], PatternMatching.this.global.TermSymbol)" class="delimiter">(</a><a href="../../../collection/immutable/List.scala.html#62451" title="(xs: MatchTranslation.this.TypeTestTreeMaker*)List[MatchTranslation.this.TypeTestTreeMaker]">List</a><span class="delimiter">(</span><a href="#1070657" title="MatchTranslation.this.TypeTestTreeMaker">treeMaker</a><span class="delimiter">)</span>, <a href="#1070657" title="MatchTranslation.this.TypeTestTreeMaker">treeMaker</a>.<a href="#1070673" title="=&gt; PatternMatching.this.global.TermSymbol">nextBinder</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            // no type test needed, but the tree maker relies on `patBinderOrCasted` having type `extractor.paramType` (and not just some type compatible with it)
            // SI-6624 shows this is necessary because apparently patBinder may have an unfortunate type (.decls don't have the case field accessors)
            // TODO: get to the bottom of this -- I assume it happens when type checking infers a weird type for an unapply call
            // by going back to the parameterType for the extractor call we get a saner type, so let's just do that for now
            /* TODO: uncomment when `settings.developer` and `devWarning` become available
              if (settings.developer.value &amp;&amp; !(patBinder.info =:= extractor.paramType))
                devWarning(s&quot;resetting info of $patBinder: ${patBinder.info} to ${extractor.paramType}&quot;)
            */
            <a href="../../../Tuple2.scala.html#62849" title="(_1: scala.collection.immutable.Nil.type, _2: PatternMatching.this.global.Symbol)(scala.collection.immutable.Nil.type, PatternMatching.this.global.Symbol)" class="delimiter">(</a><a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a> <a href="../../../reflect/internal/Symbols.scala.html#411369" title="(info: PatternMatching.this.global.Type)patBinder.type">setInfo</a> <a href="#1070461" title="MatchTranslation.this.ExtractorCall">extractor</a>.<a href="#1070472" title="=&gt; PatternMatching.this.global.Type">paramType</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>

        <a href="#1070433" title="(treeMakers: List[MatchTranslation.this.TreeMaker], subpats: (PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)*)(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">withSubPats</a><span class="delimiter">(</span><a href="#1070497" title="List[MatchTranslation.this.TypeTestTreeMaker]">typeTestTreeMaker</a> <a href="../../../collection/SeqLike.scala.html#58855" title="(elem: MatchTranslation.this.TreeMaker)(implicit bf: scala.collection.generic.CanBuildFrom[List[MatchTranslation.this.TypeTestTreeMaker],MatchTranslation.this.TreeMaker,List[MatchTranslation.this.TreeMaker]])List[MatchTranslation.this.TreeMaker]">:+</a> <a href="#1070461" title="MatchTranslation.this.ExtractorCall">extractor</a>.<a href="#1070473" title="(binder: PatternMatching.this.global.Symbol, pos: PatternMatching.this.global.Position)MatchTranslation.this.TreeMaker">treeMaker</a><span class="delimiter">(</span><a href="#1070498" title="PatternMatching.this.global.Symbol">patBinderOrCasted</a>, <a href="#1070435" title="PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span>, <a href="#1070461" title="MatchTranslation.this.ExtractorCall">extractor</a>.<a href="#1070476" title="=&gt; List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">subBindersAndPatterns</a>: _*<span class="delimiter">)</span>
      <span class="delimiter">}</span>


      <span class="keyword">object</span> <a title="MaybeBoundTyped.type" id="1070437">MaybeBoundTyped</a> <a href="#1070438" title="MaybeBoundTyped.type" class="delimiter">{</a>
        /** Decompose the pattern in `tree`, of shape C(p_1, ..., p_N), into a list of N symbols, and a list of its N sub-trees
          * The list of N symbols contains symbols for every bound name as well as the un-named sub-patterns (fresh symbols are generated here for these).
          * The returned type is the one inferred by inferTypedPattern (`owntype`)
          *
          * @arg patBinder  symbol used to refer to the result of the previous pattern's extractor (will later be replaced by the outer tree with the correct tree to refer to that patterns result)
        */
        <span class="keyword">def</span> <a title="(tree: PatternMatching.this.global.Tree)Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)]" id="1070807">unapply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1070809">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Type<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#1070809" title="PatternMatching.this.global.Tree">tree</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          // the Ident subpattern can be ignored, subpatBinder or patBinder tell us all we need to know about it
          <span class="keyword">case</span> <a href="#1070542" title="Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]" id="3368058">Bound</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Symbol" id="1070811">subpatBinder</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="1070812">typed</a>@Typed<a href="#1070812" title="Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)]" id="3368034" class="delimiter">(</a>Ident<a href="../../../reflect/internal/Trees.scala.html#410055" title="PatternMatching.this.global.Tree" id="3368037" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3368035">_</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#410057" title="PatternMatching.this.global.Tree" id="1070818">tpt</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> typed.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span> =&gt; <a href="../../../Option.scala.html#63128" title="(x: (PatternMatching.this.global.Symbol, PatternMatching.this.global.Type))Some[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)]">Some</a><a href="#3368054" title="(x: Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)])Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)]" class="delimiter">(</a><a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Symbol, _2: PatternMatching.this.global.Type)(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)" class="delimiter">(</a><a href="#1070811" title="PatternMatching.this.global.Symbol">subpatBinder</a>, typed.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> Bind<a href="#3368030" title="Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)]" id="3368040" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410157" title="PatternMatching.this.global.Name" id="3368038">_</a>, <a href="../../../reflect/internal/Trees.scala.html#410159" title="PatternMatching.this.global.Tree" id="1070832">typed</a>@Typed<a href="#1070832" title="Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)]" id="3368043" class="delimiter">(</a>Ident<a href="../../../reflect/internal/Trees.scala.html#410055" title="PatternMatching.this.global.Tree" id="3368046" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3368044">_</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#410057" title="PatternMatching.this.global.Tree" id="1070838">tpt</a><span class="delimiter">)</span><span class="delimiter">)</span>             <span class="keyword">if</span> typed.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span> =&gt; <a href="../../../Option.scala.html#63128" title="(x: (PatternMatching.this.global.Symbol, PatternMatching.this.global.Type))Some[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)]">Some</a><a href="#3368054" title="(x: Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)])Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)]" class="delimiter">(</a><a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Symbol, _2: PatternMatching.this.global.Type)(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)" class="delimiter">(</a><a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a>, typed.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> Typed<a href="#3368030" title="Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)]" id="3368049" class="delimiter">(</a>Ident<a href="../../../reflect/internal/Trees.scala.html#410055" title="PatternMatching.this.global.Tree" id="3368052" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3368050">_</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#410057" title="PatternMatching.this.global.Tree" id="1070853">tpt</a><span class="delimiter">)</span>                            <span class="keyword">if</span> <a href="#1070809" title="PatternMatching.this.global.Tree">tree</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span>  =&gt; <a href="../../../Option.scala.html#63128" title="(x: (PatternMatching.this.global.Symbol, PatternMatching.this.global.Type))Some[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)]">Some</a><a href="#3368054" title="(x: Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)])Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)]" class="delimiter">(</a><a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Symbol, _2: PatternMatching.this.global.Type)(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)" class="delimiter">(</a><a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a>, <a href="#1070809" title="PatternMatching.this.global.Tree">tree</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> _  =&gt; <a href="#3368054" title="(x: Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)])Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)]">None</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span class="keyword">val</span> <a href="#3368118" title="(x: (List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]))(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="List[MatchTranslation.this.TreeMaker]" id="1070440">treeMakers</a>, <a href="../../../Tuple2.scala.html#60637" title="List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]" id="1070441">subpats</a><span class="delimiter">)</span> = <a href="#1069768" title="PatternMatching.this.global.Tree">patTree</a> <a href="../../../Tuple2.scala.html#783" title="(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]) @unchecked" class="keyword">match</a> <span class="delimiter">{</span>
        // skip wildcard trees -- no point in checking them
        <span class="keyword">case</span> <a href="#1070864" title="(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">WildcardPattern</a><a title="Unit" id="3368065" class="delimiter">(</a><span class="delimiter">)</span> =&gt; <a href="#1070434" title="(treeMakers: MatchTranslation.this.TreeMaker*)(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">noFurtherSubPats</a><a href="#3368091" title="(x: (List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]))(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" class="delimiter">(</a><span class="delimiter">)</span>
        <span class="keyword">case</span> UnApply<a href="#3368064" title="(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" id="3368067" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410145" title="PatternMatching.this.global.Tree" id="1070869">unfun</a>, <a href="../../../reflect/internal/Trees.scala.html#410147" title="List[PatternMatching.this.global.Tree]" id="1070870">args</a><span class="delimiter">)</span> =&gt;
          // TODO: check unargs == args
          // patmatDebug(&quot;unfun: &quot;+ (unfun.tpe, unfun.symbol.ownerChain, unfun.symbol.info, patBinder.info))
          <a href="#1070436" title="(extractor: MatchTranslation.this.ExtractorCall)(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">translateExtractorPattern</a><a href="#3368091" title="(x: (List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]))(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" class="delimiter">(</a><a href="#1070872" title="(unfun: PatternMatching.this.global.Tree, args: List[PatternMatching.this.global.Tree])MatchTranslation.this.ExtractorCall">ExtractorCall</a><span class="delimiter">(</span><a href="#1070869" title="PatternMatching.this.global.Tree">unfun</a>, <a href="#1070870" title="List[PatternMatching.this.global.Tree]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>

        /** A constructor pattern is of the form c(p1, ..., pn) where n  0.
          It consists of a stable identifier c, followed by element patterns p1, ..., pn.
          The constructor c is a simple or qualified name which denotes a case class (5.3.2).

          If the case class is monomorphic, then it must conform to the expected type of the pattern,
          and the formal parameter types of xs primary constructor (5.3) are taken as the expected types of the element patterns p1, ..., pn.

          If the case class is polymorphic, then its type parameters are instantiated so that the instantiation of c conforms to the expected type of the pattern.
          The instantiated formal parameter types of cs primary constructor are then taken as the expected types of the component patterns p1, ..., pn.

          The pattern matches all objects created from constructor invocations c(v1, ..., vn) where each element pattern pi matches the corresponding value vi .
          A special case arises when cs formal parameter types end in a repeated parameter. This is further discussed in (8.1.9).
        **/
        <span class="keyword">case</span> Apply<a href="#3368064" title="(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" id="3368069" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410031" title="PatternMatching.this.global.Tree" id="1070885">fun</a>, <a href="../../../reflect/internal/Trees.scala.html#410033" title="List[PatternMatching.this.global.Tree]" id="1070886">args</a><span class="delimiter">)</span>     =&gt;
          <a href="#1068999" title="MatchTranslation.this.ExtractorCall.type">ExtractorCall</a>.<a href="#1070873" title="(fun: PatternMatching.this.global.Tree, args: List[PatternMatching.this.global.Tree])Option[MatchTranslation.this.ExtractorCall]">fromCaseClass</a><span class="delimiter">(</span><a href="#1070885" title="PatternMatching.this.global.Tree">fun</a>, <a href="#1070886" title="List[PatternMatching.this.global.Tree]">args</a><span class="delimiter">)</span> <a href="../../../Option.scala.html#62865" title="(f: MatchTranslation.this.ExtractorCall =&gt; (List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]))Option[(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])]">map</a> <a href="#1070436" title="(extractor: MatchTranslation.this.ExtractorCall)(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">translateExtractorPattern</a> <a href="#3368091" title="(x: (List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]))(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">getOrElse</a> <span class="delimiter">{</span>
            <a href="ContextErrors.scala.html#538496" title="PatternMatching.this.global.analyzer.ErrorUtils.type">ErrorUtils</a>.<a href="ContextErrors.scala.html#1024813" title="(tree: PatternMatching.this.global.analyzer.global.Tree, msg: String)(implicit context: PatternMatching.this.global.analyzer.Context)Unit">issueNormalTypeError</a><span class="delimiter">(</span><a href="#1069768" title="PatternMatching.this.global.Tree">patTree</a>, <span title="String(&quot;Could not find unapply member for &quot;)" class="string">&quot;Could not find unapply member for &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1070885" title="PatternMatching.this.global.Tree">fun</a> <span title="(x$1: Any)String">+</span><span title="String(&quot; with args &quot;)" class="string">&quot; with args &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1070886" title="List[PatternMatching.this.global.Tree]">args</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Typers.scala.html#538560" title="=&gt; PatternMatching.this.global.analyzer.Context">context</a><span class="delimiter">)</span>
            <a href="#1070434" title="(treeMakers: MatchTranslation.this.TreeMaker*)(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">noFurtherSubPats</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>

        /** A typed pattern x : T consists of a pattern variable x and a type pattern T.
            The type of x is the type pattern T, where each type variable and wildcard is replaced by a fresh, unknown type.
            This pattern matches any value matched by the type pattern T (8.2); it binds the variable name to that value.
        **/
        // must treat Typed and Bind together -- we need to know the patBinder of the Bind pattern to get at the actual type
        <span class="keyword">case</span> <a href="#1070807" title="Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Type)]" id="3368098">MaybeBoundTyped</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Symbol" id="1070901">subPatBinder</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Type" id="1070902">pt</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1070903">next</a> = <a href="../../../reflect/internal/Types.scala.html#407614" title="(ts: List[PatternMatching.this.global.Type])PatternMatching.this.global.Type">glb</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Type*)List[PatternMatching.this.global.Type]">List</a><span class="delimiter">(</span><a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411367" title="=&gt; PatternMatching.this.global.Type">info</a>.<a href="../../../reflect/internal/Types.scala.html#408411" title="=&gt; PatternMatching.this.global.Type">widen</a>, <a href="#1070902" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../reflect/internal/Types.scala.html#408438" title="=&gt; PatternMatching.this.global.Type">normalize</a>
          // a typed pattern never has any subtrees
          <a href="#1070434" title="(treeMakers: MatchTranslation.this.TreeMaker*)(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">noFurtherSubPats</a><span class="delimiter">(</span><a href="#1074488" title="MatchTranslation.this.TypeTestTreeMaker.type">TypeTestTreeMaker</a><a href="#1074594" title="Boolean" id="1070927" class="delimiter">(</a><a href="#1070901" title="PatternMatching.this.global.Symbol" id="1070918">subPatBinder</a>, <a href="#1069767" title="PatternMatching.this.global.Symbol" id="1070919">patBinder</a>, <a href="#1070902" title="PatternMatching.this.global.Type" id="1070920">pt</a>, <a href="#1070903" title="PatternMatching.this.global.Type" id="1070921">next</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1070435" title="PatternMatching.this.global.Position" id="1070926">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>

        /** A pattern binder x@p consists of a pattern variable x and a pattern p.
            The type of the variable x is the static type T of the pattern p.
            This pattern matches any value v matched by the pattern p,
            provided the run-time type of v is also an instance of T,  &lt;-- TODO! https://issues.scala-lang.org/browse/SI-1503
            and it binds the variable name to that value.
        **/
        <span class="keyword">case</span> <a href="#1070542" title="Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]" id="3368100">Bound</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Symbol" id="1070929">subpatBinder</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="1070930">p</a><span class="delimiter">)</span>          =&gt;
          // replace subpatBinder by patBinder (as if the Bind was not there)
          <a href="#1070433" title="(treeMakers: List[MatchTranslation.this.TreeMaker], subpats: (PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)*)(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">withSubPats</a><a href="#3368091" title="(x: (List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]))(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" class="delimiter">(</a><a href="../../../collection/immutable/List.scala.html#62451" title="(xs: MatchTranslation.this.SubstOnlyTreeMaker*)List[MatchTranslation.this.SubstOnlyTreeMaker]">List</a><span class="delimiter">(</span><a href="#1075358" title="(prevBinder: PatternMatching.this.global.Symbol, nextBinder: PatternMatching.this.global.Symbol)MatchTranslation.this.SubstOnlyTreeMaker">SubstOnlyTreeMaker</a><span class="delimiter">(</span><a href="#1070929" title="PatternMatching.this.global.Symbol">subpatBinder</a>, <a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a><span class="delimiter">)</span><span class="delimiter">)</span>,
            // must be patBinder, as subpatBinder has the wrong info: even if the bind assumes a better type, this is not guaranteed until we cast
            <a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Symbol, _2: PatternMatching.this.global.Tree)(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)" class="delimiter">(</a><a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a>, <a href="#1070930" title="PatternMatching.this.global.Tree">p</a><span class="delimiter">)</span>
          <span class="delimiter">)</span>

        /** 8.1.4 Literal Patterns
              A literal pattern L matches any value that is equal (in terms of ==) to the literal L.
              The type of L must conform to the expected type of the pattern.

            8.1.5 Stable Identifier Patterns  (a stable identifier r (see 3.1))
              The pattern matches any value v such that r == v (12.1).
              The type of r must conform to the expected type of the pattern.
        **/
        <span class="keyword">case</span> Literal<a href="#3368064" title="(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" id="3368074" class="delimiter">(</a>Constant<a href="../../../reflect/internal/Trees.scala.html#409973" title="PatternMatching.this.global.Constant" id="3368072" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#409760" title="Any" id="3368075">_</a><span class="delimiter">)</span><span class="delimiter">)</span> | Ident<a href="#3368064" title="Boolean" id="3368078" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3368076">_</a><span class="delimiter">)</span> | Select<a href="#3368064" title="Boolean" id="3368082" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#409999" title="PatternMatching.this.global.Tree" id="3368079">_</a>, <a href="../../../reflect/internal/Trees.scala.html#410001" title="PatternMatching.this.global.Name" id="3368080">_</a><span class="delimiter">)</span> | This<a href="#3368064" title="Boolean" id="3368085" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410008" title="PatternMatching.this.global.TypeName" id="3368083">_</a><span class="delimiter">)</span> =&gt;
          <a href="#1070434" title="(treeMakers: MatchTranslation.this.TreeMaker*)(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">noFurtherSubPats</a><a href="#3368091" title="(x: (List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]))(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" class="delimiter">(</a><a href="#1075442" title="(prevBinder: PatternMatching.this.global.Symbol, patTree: PatternMatching.this.global.Tree, pos: PatternMatching.this.global.Position)MatchTranslation.this.EqualityTestTreeMaker">EqualityTestTreeMaker</a><span class="delimiter">(</span><a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a>, <a href="#1069768" title="PatternMatching.this.global.Tree">patTree</a>, <a href="#1070435" title="PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>

        <span class="keyword">case</span> Alternative<a href="#3368064" title="(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" id="3368087" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410172" title="List[PatternMatching.this.global.Tree]" id="1071021">alts</a><span class="delimiter">)</span>    =&gt;
          <a href="#1070434" title="(treeMakers: MatchTranslation.this.TreeMaker*)(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">noFurtherSubPats</a><a href="#3368091" title="(x: (List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]))(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" class="delimiter">(</a><a href="#1075471" title="(prevBinder: PatternMatching.this.global.Symbol, altss: List[List[MatchTranslation.this.TreeMaker]], pos: PatternMatching.this.global.Position)MatchTranslation.this.AlternativesTreeMaker">AlternativesTreeMaker</a><span class="delimiter">(</span><a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a>, <a href="#1071021" title="List[PatternMatching.this.global.Tree]">alts</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.Tree =&gt; List[MatchTranslation.this.TreeMaker])(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Tree],List[MatchTranslation.this.TreeMaker],List[List[MatchTranslation.this.TreeMaker]]])List[List[MatchTranslation.this.TreeMaker]]">map</a> <span class="delimiter">(</span><a href="#1068996" title="(patBinder: PatternMatching.this.global.Symbol, patTree: PatternMatching.this.global.Tree)List[MatchTranslation.this.TreeMaker]">translatePattern</a><span class="delimiter">(</span><a href="#1069767" title="PatternMatching.this.global.Symbol">patBinder</a>, <a href="#1071071" title="PatternMatching.this.global.Tree">_</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#1071021" title="List[PatternMatching.this.global.Tree]">alts</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; PatternMatching.this.global.Tree">head</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>

      /* TODO: Paul says about future version: I think this should work, and always intended to implement if I can get away with it.
          case class Foo(x: Int, y: String)
          case class Bar(z: Int)

          def f(x: Any) = x match { case Foo(x, _) | Bar(x) =&gt; x } // x is lub of course.
      */

        <span class="keyword">case</span> Bind<a href="#3368064" title="(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" id="3368089" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410157" title="PatternMatching.this.global.Name" id="1071105">n</a>, <a href="../../../reflect/internal/Trees.scala.html#410159" title="PatternMatching.this.global.Tree" id="1071106">p</a><span class="delimiter">)</span> =&gt; // this happens in certain ill-formed programs, there'll be an error later
          <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;WARNING: Bind tree with unbound symbol &quot;)" class="string">&quot;WARNING: Bind tree with unbound symbol &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1069768" title="PatternMatching.this.global.Tree">patTree</a><span class="delimiter">)</span>
          <a href="#1070434" title="(treeMakers: MatchTranslation.this.TreeMaker*)(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">noFurtherSubPats</a><span class="delimiter">(</span><span class="delimiter">)</span> // there's no symbol -- something's wrong... don't fail here though (or should we?)

        // case Star(_) | ArrayValue  =&gt; error(&quot;stone age pattern relics encountered!&quot;)

        <span class="keyword">case</span> _                       =&gt;
          <a href="#1068979" title="=&gt; PatternMatching.this.global.analyzer.Typer">typer</a>.<a href="Typers.scala.html#538560" title="=&gt; PatternMatching.this.global.analyzer.Context">context</a>.<a href="Contexts.scala.html#538743" title="=&gt; PatternMatching.this.global.analyzer.global.CompilationUnit">unit</a>.<a href="../CompilationUnits.scala.html#539298" title="(pos: PatternMatching.this.global.analyzer.global.Position, msg: String)Unit">error</a><span class="delimiter">(</span><a href="#1069768" title="PatternMatching.this.global.Tree">patTree</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a>, <a href="../../../StringContext.scala.html#56629" title="(args: Any*)String">s</a>&quot;unsupported pattern: $<a href="#1069768" title="PatternMatching.this.global.Tree">patTree</a> (a $<span class="delimiter">{</span><a href="#1069768" title="PatternMatching.this.global.Tree">patTree</a>.<span title="()Class[_]">getClass</span><span class="delimiter">}</span>).\n This is a scalac bug. Tree diagnostics: $<span class="delimiter">{</span><a href="../ast/Printers.scala.html#537839" title="(t: PatternMatching.this.global.Tree)String">asCompactDebugString</a><span class="delimiter">(</span><a href="#1069768" title="PatternMatching.this.global.Tree">patTree</a><span class="delimiter">)</span><span class="delimiter">}</span><span class="string">.&quot;</span><span class="delimiter">)</span>
          <a href="#1070434" title="(treeMakers: MatchTranslation.this.TreeMaker*)(List[MatchTranslation.this.TreeMaker], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">noFurtherSubPats</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <a href="#1070440" title="List[MatchTranslation.this.TreeMaker]">treeMakers</a> <a href="../../../collection/immutable/List.scala.html#62697" title="(that: scala.collection.GenTraversableOnce[MatchTranslation.this.TreeMaker])(implicit bf: scala.collection.generic.CanBuildFrom[List[MatchTranslation.this.TreeMaker],MatchTranslation.this.TreeMaker,List[MatchTranslation.this.TreeMaker]])List[MatchTranslation.this.TreeMaker]">++</a> <a href="#1070441" title="List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">subpats</a>.<a href="../../../collection/TraversableLike.scala.html#58068" title="(f: ((PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)) =&gt; scala.collection.GenTraversableOnce[MatchTranslation.this.TreeMaker])(implicit bf: scala.collection.generic.CanBuildFrom[List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)],MatchTranslation.this.TreeMaker,List[MatchTranslation.this.TreeMaker]])List[MatchTranslation.this.TreeMaker]">flatMap</a> <a href="#1071163" title="(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Symbol" id="1071166">binder</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="1071167">pat</a><span class="delimiter">)</span> =&gt;
        <a href="#1068996" title="(patBinder: PatternMatching.this.global.Symbol, patTree: PatternMatching.this.global.Tree)List[MatchTranslation.this.TreeMaker]">translatePattern</a><a href="#3368124" title="(x: List[MatchTranslation.this.TreeMaker])List[MatchTranslation.this.TreeMaker]" class="delimiter">(</a><a href="#1071166" title="PatternMatching.this.global.Symbol">binder</a>, <a href="#1071167" title="PatternMatching.this.global.Tree">pat</a><span class="delimiter">)</span> // recurse on subpatterns
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(guard: PatternMatching.this.global.Tree)List[MatchTranslation.this.TreeMaker]" id="1068997">translateGuard</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1069800">guard</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[MatchTranslation.this.TreeMaker]">List</a><span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span> =
      <span title="List[MatchTranslation.this.TreeMaker]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1069800" title="PatternMatching.this.global.Tree">guard</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/Trees.scala.html#407946" title="PatternMatching.this.global.EmptyTree.type">EmptyTree</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>
      <span class="keyword">else</span> <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: MatchTranslation.this.GuardTreeMaker*)List[MatchTranslation.this.GuardTreeMaker]">List</a><span class="delimiter">(</span><a href="#1075491" title="(guardTree: PatternMatching.this.global.Tree)MatchTranslation.this.GuardTreeMaker">GuardTreeMaker</a><span class="delimiter">(</span><a href="#1069800" title="PatternMatching.this.global.Tree">guard</a><span class="delimiter">)</span><span class="delimiter">)</span>

    // TODO: 1) if we want to support a generalisation of Kotlin's patmat continue, must not hard-wire lifting into the monad (which is now done by codegen.one),
    // so that user can generate failure when needed -- use implicit conversion to lift into monad on-demand?
    // to enable this, probably need to move away from Option to a monad specific to pattern-match,
    // so that we can return Option's from a match without ambiguity whether this indicates failure in the monad, or just some result in the monad
    // 2) body.tpe is the type of the body after applying the substitution that represents the solution of GADT type inference
    // need the explicit cast in case our substitutions in the body change the type to something that doesn't take GADT typing into account
    <span class="keyword">def</span> <a title="(body: PatternMatching.this.global.Tree, matchPt: PatternMatching.this.global.Type)MatchTranslation.this.TreeMaker" id="1068998">translateBody</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1069866">body</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Type" id="1069867">matchPt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="#1069034" title="MatchTranslation.this.TreeMaker">TreeMaker</a> =
      <a href="#1075332" title="(body: PatternMatching.this.global.Tree, matchPt: PatternMatching.this.global.Type)MatchTranslation.this.BodyTreeMaker">BodyTreeMaker</a><span class="delimiter">(</span><a href="#1069866" title="PatternMatching.this.global.Tree">body</a>, <a href="#1069867" title="PatternMatching.this.global.Type">matchPt</a><span class="delimiter">)</span>


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// helper methods: they analyze types and trees in isolation, but they are not (directly) concerned with the structure of the overall translation
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    <span class="keyword">object</span> <a title="MatchTranslation.this.ExtractorCall.type" id="1068999">ExtractorCall</a> <a href="#1069000" title="MatchTranslation.this.ExtractorCall.type" class="delimiter">{</a>
      <span class="keyword">def</span> <a title="(unfun: PatternMatching.this.global.Tree, args: List[PatternMatching.this.global.Tree])MatchTranslation.this.ExtractorCall" id="1070872">apply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1070875">unfun</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="List[PatternMatching.this.global.Tree]" id="1070876">args</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#1069001" title="MatchTranslation.this.ExtractorCall">ExtractorCall</a> = <span title="MatchTranslation.this.ExtractorCallRegular" class="keyword">new</span> <a href="#1069003" title="MatchTranslation.this.ExtractorCallRegular">ExtractorCallRegular</a><span class="delimiter">(</span><a href="#1070875" title="PatternMatching.this.global.Tree">unfun</a>, <a href="#1070876" title="List[PatternMatching.this.global.Tree]">args</a><span class="delimiter">)</span>

      <span class="keyword">def</span> <a title="(fun: PatternMatching.this.global.Tree, args: List[PatternMatching.this.global.Tree])Option[MatchTranslation.this.ExtractorCall]" id="1070873">fromCaseClass</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1070887">fun</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="List[PatternMatching.this.global.Tree]" id="1070888">args</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[MatchTranslation.this.ExtractorCall]">Option</a><span class="delimiter">[</span>ExtractorCall<span class="delimiter">]</span> =  <a href="../../../Option.scala.html#63128" title="(x: MatchTranslation.this.ExtractorCallProd)Some[MatchTranslation.this.ExtractorCallProd]">Some</a><span class="delimiter">(</span><span title="MatchTranslation.this.ExtractorCallProd" class="keyword">new</span> <a href="#1069002" title="MatchTranslation.this.ExtractorCallProd">ExtractorCallProd</a><span class="delimiter">(</span><a href="#1070887" title="PatternMatching.this.global.Tree">fun</a>, <a href="#1070888" title="List[PatternMatching.this.global.Tree]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>

      // THE PRINCIPLED SLOW PATH -- NOT USED
      // generate a call to the (synthetically generated) extractor of a case class
      // NOTE: it's an apply, not a select, since in general an extractor call may have multiple argument lists (including an implicit one)
      // that we need to preserve, so we supply the scrutinee as Ident(nme.SELECTOR_DUMMY),
      // and replace that dummy by a reference to the actual binder in translateExtractorPattern
      <span class="keyword">def</span> <a title="(fun: PatternMatching.this.global.Tree, args: List[PatternMatching.this.global.Tree])Option[MatchTranslation.this.ExtractorCall]" id="1070874">fromCaseClassUnapply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1071315">fun</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="List[PatternMatching.this.global.Tree]" id="1071316">args</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[MatchTranslation.this.ExtractorCall]">Option</a><span class="delimiter">[</span>ExtractorCall<span class="delimiter">]</span> = <span class="delimiter">{</span>
        // TODO: can we rework the typer so we don't have to do all this twice?
        // undo rewrite performed in (5) of adapt
        <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1071317">orig</a>      = <a href="#1071315" title="PatternMatching.this.global.Tree">fun</a> <span class="keyword">match</span> <span class="delimiter">{</span><span class="keyword">case</span> <a href="#3368128" title="PatternMatching.this.global.Tree" id="3368130">tpt</a>: TypeTree =&gt; tpt.<a href="#3368132" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">original</a> <span class="keyword">case</span> _ =&gt; <a href="#3368132" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">fun</a><span class="delimiter">}</span>
        <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="1071318">origSym</a>   = <a href="#1071317" title="PatternMatching.this.global.Tree">orig</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>
        <span class="keyword">val</span> <a title="PatternMatching.this.global.analyzer.global.Symbol" id="1071319">extractor</a> = <a href="Unapplies.scala.html#538265" title="(tp: PatternMatching.this.global.analyzer.global.Type)PatternMatching.this.global.analyzer.global.Symbol">unapplyMember</a><span class="delimiter">(</span><a href="#1071318" title="PatternMatching.this.global.Symbol">origSym</a>.<a href="../../../reflect/internal/Symbols.scala.html#411414" title="(cond: PatternMatching.this.global.Symbol =&gt; Boolean)PatternMatching.this.global.Symbol">filter</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1071327">sym</a> =&gt; <a href="Typers.scala.html#538600" title="(sym: PatternMatching.this.global.analyzer.global.Symbol)Boolean">reallyExists</a><span class="delimiter">(</span><a href="Unapplies.scala.html#538265" title="(tp: PatternMatching.this.global.analyzer.global.Type)PatternMatching.this.global.analyzer.global.Symbol">unapplyMember</a><span class="delimiter">(</span><a href="#1071327" title="PatternMatching.this.global.Symbol">sym</a>.<a href="../../../reflect/internal/Symbols.scala.html#411365" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../reflect/internal/Symbols.scala.html#411365" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span>

        <span title="Option[MatchTranslation.this.ExtractorCall]" class="keyword">if</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#1071315" title="PatternMatching.this.global.Tree">fun</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="#1071315" title="PatternMatching.this.global.Tree">fun</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#408401" title="=&gt; Boolean">isError</a> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#1071319" title="PatternMatching.this.global.analyzer.global.Symbol">extractor</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="../../../Option.scala.html#1585" title="None.type">None</a>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          // this is a tricky balance: pos/t602.scala, pos/sudoku.scala, run/virtpatmat_alts.scala must all be happy
          // bypass typing at own risk: val extractorCall = Select(orig, extractor) setType caseClassApplyToUnapplyTp(fun.tpe)
          // can't always infer type arguments (pos/t602):
          /*  case class Span[K &lt;: Ordered[K]](low: Option[K]) {
                override def equals(x: Any): Boolean = x match {
                  case Span((low0 @ _)) if low0 equals low =&gt; true
                }
              }*/
          // so... leave undetermined type params floating around if we have to
          // (if we don't infer types, uninstantiated type params show up later: pos/sudoku.scala)
          // (see also run/virtpatmat_alts.scala)
          <span class="keyword">val</span> <a title="List[PatternMatching.this.global.analyzer.global.Symbol]" id="1071340">savedUndets</a> = <a href="Typers.scala.html#538560" title="=&gt; PatternMatching.this.global.analyzer.Context">context</a>.<a href="Contexts.scala.html#538827" title="=&gt; List[PatternMatching.this.global.analyzer.global.Symbol]">undetparams</a>
          <span class="keyword">val</span> <a title="PatternMatching.this.global.analyzer.global.Tree" id="1071341">extractorCall</a> = <span class="keyword">try</span> <span class="delimiter">{</span>
            <a href="Typers.scala.html#538560" title="=&gt; PatternMatching.this.global.analyzer.Context">context</a>.<a href="Contexts.scala.html#538828" title="(ps: List[PatternMatching.this.global.analyzer.global.Symbol])Unit">undetparams</a> = <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>
            <a href="Typers.scala.html#538609" title="(op: PatternMatching.this.global.analyzer.Typer =&gt; PatternMatching.this.global.analyzer.global.Tree, reportAmbiguousErrors: Boolean, newtree: PatternMatching.this.global.analyzer.global.Tree)PatternMatching.this.global.analyzer.SilentResult[PatternMatching.this.global.analyzer.global.Tree]">silent</a><span title="PatternMatching.this.global.analyzer.global.Tree" class="delimiter">(</span><a href="#1071351" title="PatternMatching.this.global.analyzer.Typer">_</a>.<a href="Typers.scala.html#538698" title="(tree: PatternMatching.this.global.analyzer.global.Tree, mode: Int, pt: PatternMatching.this.global.analyzer.global.Type)PatternMatching.this.global.analyzer.global.Tree">typed</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#413581" title="(fun: PatternMatching.this.global.Tree, args: List[PatternMatching.this.global.Tree])PatternMatching.this.global.Apply">Apply</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#408125" title="(qualifier: PatternMatching.this.global.Tree, sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.Select">Select</a><span class="delimiter">(</span><a href="#1071317" title="PatternMatching.this.global.Tree">orig</a>, <a href="#1071319" title="PatternMatching.this.global.analyzer.global.Symbol">extractor</a><span class="delimiter">)</span>, <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Ident*)List[PatternMatching.this.global.Ident]">List</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#418125" title="(name: PatternMatching.this.global.Name)PatternMatching.this.global.Ident">Ident</a><span class="delimiter">(</span><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/StdNames.scala.html#414030" title="=&gt; PatternMatching.this.global.nme.NameType">SELECTOR_DUMMY</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Trees.scala.html#408575" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Ident">setType</a> <a href="#1071315" title="PatternMatching.this.global.Tree">fun</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#408427" title="=&gt; PatternMatching.this.global.Type">finalResultType</a><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="Int(1)">EXPRmode</span>, <a href="../../../reflect/internal/Types.scala.html#407279" title="PatternMatching.this.global.WildcardType.type">WildcardType</a><span class="delimiter">)</span>, reportAmbiguousErrors = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> SilentResultValue<a href="#3368137" title="PatternMatching.this.global.analyzer.global.Tree" id="3368139" class="delimiter">(</a><a href="Typers.scala.html#541584" title="PatternMatching.this.global.analyzer.global.Tree" id="1071426">extractorCall</a><span class="delimiter">)</span> =&gt; <a href="#3368141" title="(x: PatternMatching.this.global.analyzer.global.Tree)PatternMatching.this.global.analyzer.global.Tree">extractorCall</a> // if !extractorCall.containsError()
              <span class="keyword">case</span> _ =&gt;
                // this fails to resolve overloading properly...
                // Apply(typedOperator(Select(orig, extractor)), List(Ident(nme.SELECTOR_DUMMY))) // no need to set the type of the dummy arg, it will be replaced anyway

                // patmatDebug(&quot;funtpe after = &quot;+ fun.tpe.finalResultType)
                // patmatDebug(&quot;orig: &quot;+(orig, orig.tpe))
                <span class="keyword">val</span> <a title="PatternMatching.this.global.analyzer.global.Tree" id="1071427">tgt</a> = <a href="Typers.scala.html#538698" title="(tree: PatternMatching.this.global.analyzer.global.Tree, mode: Int, pt: PatternMatching.this.global.analyzer.global.Type)PatternMatching.this.global.analyzer.global.Tree">typed</a><span class="delimiter">(</span><a href="#1071317" title="PatternMatching.this.global.Tree">orig</a>, EXPRmode | QUALmode <span title="Int(97)">|</span> POLYmode, <a href="Implicits.scala.html#1039271" title="(name: PatternMatching.this.global.analyzer.global.Name)PatternMatching.this.global.analyzer.global.Type">HasMember</a><span class="delimiter">(</span><a href="#1071319" title="PatternMatching.this.global.analyzer.global.Symbol">extractor</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; extractor.NameType">name</a><span class="delimiter">)</span><span class="delimiter">)</span> // can't specify fun.tpe.finalResultType as the type for the extractor's arg,
                // as it may have been inferred incorrectly (see t602, where it's  com.mosol.sl.Span[Any], instead of  com.mosol.sl.Span[?K])
                // patmatDebug(&quot;tgt = &quot;+ (tgt, tgt.tpe))
                <span class="keyword">val</span> <a title="PatternMatching.this.global.analyzer.global.Tree" id="1071428">oper</a> = <a href="Typers.scala.html#538698" title="(tree: PatternMatching.this.global.analyzer.global.Tree, mode: Int, pt: PatternMatching.this.global.analyzer.global.Type)PatternMatching.this.global.analyzer.global.Tree">typed</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#418089" title="(qualifier: PatternMatching.this.global.Tree, name: PatternMatching.this.global.Name)PatternMatching.this.global.Select">Select</a><span class="delimiter">(</span><a href="#1071427" title="PatternMatching.this.global.analyzer.global.Tree">tgt</a>, <a href="#1071319" title="PatternMatching.this.global.analyzer.global.Symbol">extractor</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; extractor.NameType">name</a><span class="delimiter">)</span>, EXPRmode | FUNmode | POLYmode <span title="Int(177)">|</span> TAPPmode, <a href="../../../reflect/internal/Types.scala.html#407279" title="PatternMatching.this.global.WildcardType.type">WildcardType</a><span class="delimiter">)</span>
                // patmatDebug(&quot;oper: &quot;+ (oper, oper.tpe))
                <a href="../../../reflect/internal/Trees.scala.html#413581" title="(fun: PatternMatching.this.global.Tree, args: List[PatternMatching.this.global.Tree])PatternMatching.this.global.Apply">Apply</a><span class="delimiter">(</span><a href="#1071428" title="PatternMatching.this.global.analyzer.global.Tree">oper</a>, <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Ident*)List[PatternMatching.this.global.Ident]">List</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#418125" title="(name: PatternMatching.this.global.Name)PatternMatching.this.global.Ident">Ident</a><span class="delimiter">(</span><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/StdNames.scala.html#414030" title="=&gt; PatternMatching.this.global.nme.NameType">SELECTOR_DUMMY</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> // no need to set the type of the dummy arg, it will be replaced anyway
            <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span class="keyword">finally</span> <a href="Typers.scala.html#538560" title="=&gt; PatternMatching.this.global.analyzer.Context">context</a>.<a href="Contexts.scala.html#538828" title="(ps: List[PatternMatching.this.global.analyzer.global.Symbol])Unit">undetparams</a> = <a href="#1071340" title="List[PatternMatching.this.global.analyzer.global.Symbol]">savedUndets</a>

          <a href="../../../Option.scala.html#63128" title="(x: MatchTranslation.this.ExtractorCall)Some[MatchTranslation.this.ExtractorCall]">Some</a><span class="delimiter">(</span><a href="#1070872" title="(unfun: PatternMatching.this.global.Tree, args: List[PatternMatching.this.global.Tree])MatchTranslation.this.ExtractorCall" class="keyword">this</a><span class="delimiter">(</span><a href="#1071341" title="PatternMatching.this.global.analyzer.global.Tree">extractorCall</a>, <a href="#1071316" title="List[PatternMatching.this.global.Tree]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> // TODO: simplify spliceApply?
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ExtractorCall extends Object" id="1069001">ExtractorCall</a><a href="#1069001" title="MatchTranslation.this.ExtractorCall" class="delimiter">(</a><span class="keyword">val</span> <a title="List[PatternMatching.this.global.Tree]" id="1071272">args</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="1070466">nbSubPats</a> = <a href="#1071272" title="=&gt; List[PatternMatching.this.global.Tree]">args</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86373" title="=&gt; Int">length</a>

      // everything okay, captain?
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1070468">isTyped</a>    : <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1070469">isSeq</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a>
      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="1070471">lastIsStar</a> = <span class="delimiter">(</span><a href="#1070466" title="=&gt; Int">nbSubPats</a> <a href="../../../Int.scala.html#57125" title="(x: Int)Boolean">&gt;</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../ast/Trees.scala.html#537807" title="PatternMatching.this.global.treeInfo.type">treeInfo</a>.<a href="../../../reflect/internal/TreeInfo.scala.html#479242" title="(x: PatternMatching.this.global.treeInfo.global.Tree)Boolean">isStar</a><span class="delimiter">(</span><a href="#1071272" title="=&gt; List[PatternMatching.this.global.Tree]">args</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86394" title="=&gt; PatternMatching.this.global.Tree">last</a><span class="delimiter">)</span>

      // to which type should the previous binder be casted?
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Type" id="1070472">paramType</a>  : <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>

      // binder has been casted to paramType if necessary
      <span class="keyword">def</span> <a title="(binder: PatternMatching.this.global.Symbol, pos: PatternMatching.this.global.Position)MatchTranslation.this.TreeMaker" id="1070473">treeMaker</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1070776">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Position" id="1070777">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#22953" title="PatternMatching.this.global.Position">Position</a><span class="delimiter">)</span>: <a href="#1069034" title="MatchTranslation.this.TreeMaker">TreeMaker</a>

      // `subPatBinders` are the variables bound by this pattern in the following patterns
      // subPatBinders are replaced by references to the relevant part of the extractor's result (tuple component, seq element, the result as-is)
      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1070475">subPatBinders</a> = <a href="#1071272" title="=&gt; List[PatternMatching.this.global.Tree]">args</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Tree],PatternMatching.this.global.Symbol,List[PatternMatching.this.global.Symbol]])List[PatternMatching.this.global.Symbol]">map</a> <a href="#1070540" title="PatternMatching.this.global.Tree" class="delimiter">{</a>
        <span class="keyword">case</span> <a href="#1070542" title="Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]" id="3368153">Bound</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Symbol" id="1070545">b</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="1070546">p</a><span class="delimiter">)</span> =&gt; <a href="#3368149" title="(x: PatternMatching.this.global.Symbol)PatternMatching.this.global.Symbol">b</a>
        <span class="keyword">case</span> p =&gt; <a href="#1069697" title="PatternMatching.this.global.Type" id="1070552">freshSym</a><a href="#3368149" title="(x: PatternMatching.this.global.Symbol)PatternMatching.this.global.Symbol" class="delimiter">(</a>p.<a href="../../../reflect/internal/Trees.scala.html#408571" title="PatternMatching.this.global.Position" id="1070550">pos</a>, prefix = <a title="String" id="1070551" class="string">&quot;p&quot;</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]" id="1070477">subBindersAndPatterns</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">List</a><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Tree<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#1070474" title="=&gt; List[PatternMatching.this.global.Symbol]">subPatBinders</a> <a href="../../../collection/IterableLike.scala.html#58590" title="(that: scala.collection.GenIterable[PatternMatching.this.global.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Symbol],(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree),List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]])List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">zip</a> <a href="#1071272" title="=&gt; List[PatternMatching.this.global.Tree]">args</a><span class="delimiter">)</span> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: ((PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)) =&gt; (PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree))(implicit bf: scala.collection.generic.CanBuildFrom[List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)],(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree),List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]])List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">map</a> <a href="#1071592" title="(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)" class="delimiter">{</a>
        <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Symbol" id="1071595">b</a>, <a href="#1070542" title="Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]" id="3368166">Bound</a><a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="3368158" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Symbol" id="3368159">_</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="1071597">p</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#3368162" title="(x: (PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree))(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)" class="delimiter">(</a><a href="#1071595" title="PatternMatching.this.global.Symbol">b</a>, <a href="#1071597" title="PatternMatching.this.global.Tree">p</a><span class="delimiter">)</span>
        <span class="keyword">case</span> bp =&gt; <a href="#3368162" title="(x: (PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree))(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)">bp</a>
      <span class="delimiter">}</span>

      <span class="keyword">def</span> <a title="=&gt; List[PatternMatching.this.global.Type]" id="1070478">subPatTypes</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> =
        <span title="List[PatternMatching.this.global.Type]" class="keyword">if</span><span class="delimiter">(</span><a href="#1070469" title="=&gt; Boolean">isSeq</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> TypeRef<a href="#3368170" title="(PatternMatching.this.global.Type, List[PatternMatching.this.global.Type])" id="3368173" class="delimiter">(</a><a href="../../../reflect/internal/Types.scala.html#410887" title="PatternMatching.this.global.Type" id="1071634">pre</a>, <a href="../../../reflect/internal/Types.scala.html#410889" title="PatternMatching.this.global.Symbol" id="3368176">SeqClass</a>, <a href="../../../reflect/internal/Types.scala.html#410891" title="List[PatternMatching.this.global.Type]" id="1071635">args</a><span class="delimiter">)</span> = <a href="#1070480" title="=&gt; PatternMatching.this.global.Type">seqTp</a>
          // do repeated-parameter expansion to match up with the expected number of arguments (in casu, subpatterns)
          <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Type]" id="1071636">formalsWithRepeated</a> = <a href="#1070479" title="=&gt; List[PatternMatching.this.global.Type]">rawSubPatTypes</a>.<a href="../../../collection/TraversableLike.scala.html#58107" title="=&gt; List[PatternMatching.this.global.Type]">init</a> <a href="../../../collection/SeqLike.scala.html#58855" title="(elem: PatternMatching.this.global.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Type],PatternMatching.this.global.Type,List[PatternMatching.this.global.Type]])List[PatternMatching.this.global.Type]">:+</a> <a href="../../../reflect/internal/Types.scala.html#407402" title="(pre: PatternMatching.this.global.Type, sym: PatternMatching.this.global.Symbol, args: List[PatternMatching.this.global.Type])PatternMatching.this.global.Type">typeRef</a><span class="delimiter">(</span><a href="#1071634" title="PatternMatching.this.global.Type">pre</a>, <a href="../../../reflect/internal/Definitions.scala.html#408810" title="=&gt; PatternMatching.this.global.ClassSymbol">RepeatedParamClass</a>, <a href="#1071635" title="List[PatternMatching.this.global.Type]">args</a><span class="delimiter">)</span>

          <span title="List[PatternMatching.this.global.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1070470" title="=&gt; Boolean">lastIsStar</a><span class="delimiter">)</span> <a href="Infer.scala.html#538149" title="(formals: List[PatternMatching.this.global.analyzer.global.Type], nargs: Int, removeByName: Boolean, removeRepeated: Boolean)List[PatternMatching.this.global.analyzer.global.Type]">formalTypes</a><span class="delimiter">(</span><a href="#1071636" title="List[PatternMatching.this.global.Type]">formalsWithRepeated</a>, <a href="#1070466" title="=&gt; Int">nbSubPats</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="../../../collection/SeqLike.scala.html#58855" title="(elem: PatternMatching.this.global.analyzer.global.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.analyzer.global.Type],PatternMatching.this.global.analyzer.global.Type,List[PatternMatching.this.global.Type]])List[PatternMatching.this.global.Type]">:+</a> <a href="#1070480" title="=&gt; PatternMatching.this.global.Type">seqTp</a>
          <span class="keyword">else</span> <a href="Infer.scala.html#538149" title="(formals: List[PatternMatching.this.global.analyzer.global.Type], nargs: Int, removeByName: Boolean, removeRepeated: Boolean)List[PatternMatching.this.global.analyzer.global.Type]">formalTypes</a><span class="delimiter">(</span><a href="#1071636" title="List[PatternMatching.this.global.Type]">formalsWithRepeated</a>, <a href="#1070466" title="=&gt; Int">nbSubPats</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#1070479" title="=&gt; List[PatternMatching.this.global.Type]">rawSubPatTypes</a>

      <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; List[PatternMatching.this.global.Type]" id="1070479">rawSubPatTypes</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>

      <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Type" id="1070480">seqTp</a> = <a href="#1070479" title="=&gt; List[PatternMatching.this.global.Type]">rawSubPatTypes</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86394" title="=&gt; PatternMatching.this.global.Type">last</a> <a href="../../../reflect/internal/Types.scala.html#408459" title="(clazz: PatternMatching.this.global.Symbol)PatternMatching.this.global.Type">baseType</a> <a href="../../../reflect/internal/Definitions.scala.html#408839" title="=&gt; PatternMatching.this.global.ClassSymbol">SeqClass</a>
      <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Symbol" id="1070481">seqLenCmp</a>                = <a href="#1070479" title="=&gt; List[PatternMatching.this.global.Type]">rawSubPatTypes</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86394" title="=&gt; PatternMatching.this.global.Type">last</a> <a href="../../../reflect/internal/Types.scala.html#408451" title="(name: PatternMatching.this.global.Name)PatternMatching.this.global.Symbol">member</a> <a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/StdNames.scala.html#414421" title="=&gt; PatternMatching.this.global.nme.NameType">lengthCompare</a>
      <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Int" id="1070483">firstIndexingBinder</a> = <a href="#1070479" title="=&gt; List[PatternMatching.this.global.Type]">rawSubPatTypes</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86373" title="=&gt; Int">length</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span> // rawSubPatTypes.last is the Seq, thus there are `rawSubPatTypes.length - 1` non-seq elements in the tuple
      <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Int" id="1070485">lastIndexingBinder</a>  = <span title="Int" class="keyword">if</span><span class="delimiter">(</span><a href="#1070470" title="=&gt; Boolean">lastIsStar</a><span class="delimiter">)</span> <a href="#1070466" title="=&gt; Int">nbSubPats</a><a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a><span title="Int(2)" class="int">2</span> <span class="keyword">else</span> <a href="#1070466" title="=&gt; Int">nbSubPats</a><a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a><span title="Int(1)" class="int">1</span>
      <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Int" id="1070487">expectedLength</a>      = <a href="#1070484" title="=&gt; Int">lastIndexingBinder</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <a href="#1070482" title="=&gt; Int">firstIndexingBinder</a> <a href="../../../Int.scala.html#57154" title="(x: Int)Int">+</a> <span title="Int(1)" class="int">1</span>
      <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Int" id="1070489">minLenToCheck</a>       = <span title="Int" class="keyword">if</span><span class="delimiter">(</span><a href="#1070470" title="=&gt; Boolean">lastIsStar</a><span class="delimiter">)</span> <span title="Int(1)" class="int">1</span> <span class="keyword">else</span> <span title="Int(0)" class="int">0</span>
      <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(binder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree" id="1070490">seqTree</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1071797">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>  = <a href="#1070491" title="(binder: PatternMatching.this.global.Symbol)(i: Int)PatternMatching.this.global.Tree">tupleSel</a><span class="delimiter">(</span><a href="#1071797" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1070482" title="=&gt; Int">firstIndexingBinder</a><a href="../../../Int.scala.html#57154" title="(x: Int)Int">+</a><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(binder: PatternMatching.this.global.Symbol)(i: Int)PatternMatching.this.global.Tree" id="1070491">tupleSel</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1071798">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Int" id="1071799">i</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="#1069017" title="=&gt; MatchTranslation.this.AbsCodegen">codegen</a>.<a href="#1071815" title="(binder: PatternMatching.this.global.Symbol)(i: Int)PatternMatching.this.global.Tree">tupleSel</a><span class="delimiter">(</span><a href="#1071798" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1071799" title="Int">i</a><span class="delimiter">)</span>

      // the trees that select the subpatterns on the extractor's result, referenced by `binder`
      // require isSeq
      <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(binder: PatternMatching.this.global.Symbol)List[PatternMatching.this.global.Tree]" id="1070492">subPatRefsSeq</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1071818">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="scala.collection.immutable.Range.Inclusive" id="1071819">indexingIndices</a>   = <span class="delimiter">(</span><a href="../../../LowPriorityImplicits.scala.html#7395" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">0</a> <a href="../../../runtime/RichInt.scala.html#57062" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <span class="delimiter">(</span><a href="#1070484" title="=&gt; Int">lastIndexingBinder</a><a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a><a href="#1070482" title="=&gt; Int">firstIndexingBinder</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Int" id="1071820">nbIndexingIndices</a> = <a href="#1071819" title="scala.collection.immutable.Range.Inclusive">indexingIndices</a>.<a href="../../../collection/immutable/Range.scala.html#81291" title="=&gt; Int">length</a>

        // this error-condition has already been checked by checkStarPatOK:
        //   if(isSeq) assert(firstIndexingBinder + nbIndexingIndices + (if(lastIsStar) 1 else 0) == nbSubPats, &quot;(resultInMonad, ts, subPatTypes, subPats)= &quot;+(resultInMonad, ts, subPatTypes, subPats))
        // there are `firstIndexingBinder` non-seq tuple elements preceding the Seq
        <span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="../../../LowPriorityImplicits.scala.html#7395" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">1</a> <a href="../../../runtime/RichInt.scala.html#57062" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#1070482" title="=&gt; Int">firstIndexingBinder</a><span class="delimiter">)</span> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: Int =&gt; PatternMatching.this.global.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],PatternMatching.this.global.Tree,scala.collection.immutable.IndexedSeq[PatternMatching.this.global.Tree]])scala.collection.immutable.IndexedSeq[PatternMatching.this.global.Tree]">map</a> <a href="#1070491" title="(binder: PatternMatching.this.global.Symbol)(i: Int)PatternMatching.this.global.Tree">tupleSel</a><a href="#1072037" title="Int" class="delimiter">(</a><a href="#1071818" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../collection/TraversableLike.scala.html#58048" title="(that: scala.collection.GenTraversableOnce[PatternMatching.this.global.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[PatternMatching.this.global.Tree],PatternMatching.this.global.Tree,scala.collection.immutable.IndexedSeq[PatternMatching.this.global.Tree]])scala.collection.immutable.IndexedSeq[PatternMatching.this.global.Tree]">++</a>
        // then we have to index the binder that represents the sequence for the remaining subpatterns, except for...
        <span class="delimiter">(</span><a href="#1071819" title="scala.collection.immutable.Range.Inclusive">indexingIndices</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: Int =&gt; PatternMatching.this.global.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],PatternMatching.this.global.Tree,scala.collection.immutable.IndexedSeq[PatternMatching.this.global.Tree]])scala.collection.immutable.IndexedSeq[PatternMatching.this.global.Tree]">map</a> <a href="#1069017" title="=&gt; MatchTranslation.this.AbsCodegen">codegen</a>.<a href="#1071813" title="(tgt: PatternMatching.this.global.Tree)(i: Int)PatternMatching.this.global.Tree">index</a><a href="#1072118" title="Int" class="delimiter">(</a><a href="#1070490" title="(binder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">seqTree</a><a href="#1072115" title="PatternMatching.this.global.Tree" class="delimiter">(</a><a href="#1071818" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../collection/TraversableLike.scala.html#58048" title="(that: scala.collection.GenTraversableOnce[PatternMatching.this.global.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[PatternMatching.this.global.Tree],PatternMatching.this.global.Tree,scala.collection.immutable.IndexedSeq[PatternMatching.this.global.Tree]])scala.collection.immutable.IndexedSeq[PatternMatching.this.global.Tree]">++</a>
        // the last one -- if the last subpattern is a sequence wildcard: drop the prefix (indexed by the refs on the line above), return the remainder
        <span class="delimiter">(</span><span title="List[PatternMatching.this.global.Tree]" class="keyword">if</span><span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1070470" title="=&gt; Boolean">lastIsStar</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a> <span class="keyword">else</span> <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Tree*)List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">(</span>
          <span title="PatternMatching.this.global.Tree" class="keyword">if</span><span class="delimiter">(</span><a href="#1071820" title="Int">nbIndexingIndices</a> <a href="../../../Int.scala.html#57097" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#1070490" title="(binder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">seqTree</a><span class="delimiter">(</span><a href="#1071818" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#1069017" title="=&gt; MatchTranslation.this.AbsCodegen">codegen</a>.<a href="#1071812" title="(tgt: PatternMatching.this.global.Tree)(n: Int)PatternMatching.this.global.Tree">drop</a><span class="delimiter">(</span><a href="#1070490" title="(binder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">seqTree</a><span class="delimiter">(</span><a href="#1071818" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1071820" title="Int">nbIndexingIndices</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[PatternMatching.this.global.Tree]">toList</a>
      <span class="delimiter">}</span>

      // the trees that select the subpatterns on the extractor's result, referenced by `binder`
      // require (nbSubPats &gt; 0 &amp;&amp; (!lastIsStar || isSeq))
      <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(binder: PatternMatching.this.global.Symbol)List[PatternMatching.this.global.Tree]" id="1070493">subPatRefs</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1072249">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> =
        <span title="List[PatternMatching.this.global.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1070466" title="=&gt; Int">nbSubPats</a> <a href="../../../Int.scala.html#57097" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>
        <span class="keyword">else</span> <span title="List[PatternMatching.this.global.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1070469" title="=&gt; Boolean">isSeq</a><span class="delimiter">)</span> <a href="#1070492" title="(binder: PatternMatching.this.global.Symbol)List[PatternMatching.this.global.Tree]">subPatRefsSeq</a><span class="delimiter">(</span><a href="#1072249" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="../../../LowPriorityImplicits.scala.html#7395" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">1</a> <a href="../../../runtime/RichInt.scala.html#57062" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#1070466" title="=&gt; Int">nbSubPats</a><span class="delimiter">)</span> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: Int =&gt; PatternMatching.this.global.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],PatternMatching.this.global.Tree,scala.collection.immutable.IndexedSeq[PatternMatching.this.global.Tree]])scala.collection.immutable.IndexedSeq[PatternMatching.this.global.Tree]">map</a> <a href="#1070491" title="(binder: PatternMatching.this.global.Symbol)(i: Int)PatternMatching.this.global.Tree">tupleSel</a><a href="#1072353" title="Int" class="delimiter">(</a><a href="#1072249" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[PatternMatching.this.global.Tree]">toList</a>

      <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(binder: PatternMatching.this.global.Symbol)Option[PatternMatching.this.global.Tree]" id="1070494">lengthGuard</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1072386">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> =
        // no need to check unless it's an unapplySeq and the minimal length is non-trivially satisfied
        <a href="#1070495" title="=&gt; Option[Int]">checkedLength</a> <a href="../../../Option.scala.html#62865" title="(f: Int =&gt; PatternMatching.this.global.Tree)Option[PatternMatching.this.global.Tree]">map</a> <span class="delimiter">{</span> <a title="Int" id="1072391">expectedLength</a> =&gt; <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._
          // `binder.lengthCompare(expectedLength)`
          <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Apply" id="1072393">checkExpectedLength</a> = <span class="delimiter">(</span><a href="#1070490" title="(binder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">seqTree</a><a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods" class="delimiter">(</a><a href="#1072386" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#662306" title="(args: PatternMatching.this.global.Tree*)PatternMatching.this.global.Apply">DOT</a> <a href="#1070481" title="=&gt; PatternMatching.this.global.Symbol">seqLenCmp</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#662273" title="(x: Any)PatternMatching.this.global.Literal">LIT</a><span class="delimiter">(</span><a href="#1072391" title="Int">expectedLength</a><span class="delimiter">)</span><span class="delimiter">)</span>

          // the comparison to perform
          // when the last subpattern is a wildcard-star the expectedLength is but a lower bound
          // (otherwise equality is required)
          <span class="keyword">def</span> <a title="=&gt; (PatternMatching.this.global.Tree, PatternMatching.this.global.Tree) =&gt; PatternMatching.this.global.Tree" id="1072394">compareOp</a>: <span class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span> =&gt; Tree =
            <span title="(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree) =&gt; PatternMatching.this.global.Apply" class="keyword">if</span> <span class="delimiter">(</span><a href="#1070470" title="=&gt; Boolean">lastIsStar</a><span class="delimiter">)</span>  <a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods">_</a> <a href="../ast/TreeDSL.scala.html#662327" title="(other: PatternMatching.this.global.Tree)PatternMatching.this.global.Apply">INT_&gt;=</a> <a href="#1072417" title="PatternMatching.this.global.Tree">_</a>
            <span class="keyword">else</span>             <a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods">_</a> <a href="../ast/TreeDSL.scala.html#662328" title="(other: PatternMatching.this.global.Tree)PatternMatching.this.global.Apply">INT_==</a> <a href="#1072425" title="PatternMatching.this.global.Tree">_</a>

          // `if (binder != null &amp;&amp; $checkExpectedLength [== | &gt;=] 0) then else zero`
          <span class="delimiter">(</span><a href="#1070490" title="(binder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">seqTree</a><a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods" class="delimiter">(</a><a href="#1072386" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods">ANY_!=</a> <a href="../ast/TreeDSL.scala.html#624560" title="=&gt; PatternMatching.this.global.Literal">NULL</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#662316" title="(other: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">AND</a> <a href="../../../Function2.scala.html#65848" title="(v1: PatternMatching.this.global.Tree, v2: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">compareOp</a><span class="delimiter">(</span><a href="#1072393" title="=&gt; PatternMatching.this.global.Apply">checkExpectedLength</a>, <a href="../ast/TreeDSL.scala.html#624558" title="=&gt; PatternMatching.this.global.Literal">ZERO</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

      <span class="keyword">def</span> <a title="=&gt; Option[Int]" id="1070495">checkedLength</a>: <a href="../../../Option.scala.html#978" title="Option[Int]">Option</a><span class="delimiter">[</span>Int<span class="delimiter">]</span> =
        // no need to check unless it's an unapplySeq and the minimal length is non-trivially satisfied
        <span title="Option[Int]" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1070469" title="=&gt; Boolean">isSeq</a> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#1070486" title="=&gt; Int">expectedLength</a> <a href="../../../Int.scala.html#57111" title="(x: Int)Boolean">&lt;</a> <a href="#1070488" title="=&gt; Int">minLenToCheck</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../Option.scala.html#1585" title="None.type">None</a>
        <span class="keyword">else</span> <a href="../../../Option.scala.html#63128" title="(x: Int)Some[Int]">Some</a><span class="delimiter">(</span><a href="#1070486" title="=&gt; Int">expectedLength</a><span class="delimiter">)</span>

    <span class="delimiter">}</span>

    // TODO: to be called when there's a def unapplyProd(x: T): U
    // U must have N members _1,..., _N -- the _i are type checked, call their type Ti,
    //
    // for now only used for case classes -- pretending there's an unapplyProd that's the identity (and don't call it)
    <span class="keyword">class</span> <a title="class ExtractorCallProd extends MatchTranslation.this.ExtractorCall" id="1069002">ExtractorCallProd</a><a href="#1069002" title="MatchTranslation.this.ExtractorCallProd" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1071312">fun</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="List[PatternMatching.this.global.Tree]" id="1071313">args</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069001" title="MatchTranslation.this.ExtractorCall">ExtractorCall</a><span class="delimiter">(</span><a href="#1071313" title="List[PatternMatching.this.global.Tree]">args</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      // TODO: fix the illegal type bound in pos/t602 -- type inference messes up before we get here:
      /*override def equals(x$1: Any): Boolean = ...
             val o5: Option[com.mosol.sl.Span[Any]] =  // Span[Any] --&gt; Any is not a legal type argument for Span!
      */
      // private val orig            = fun match {case tpt: TypeTree =&gt; tpt.original case _ =&gt; fun}
      // private val origExtractorTp = unapplyMember(orig.symbol.filter(sym =&gt; reallyExists(unapplyMember(sym.tpe))).tpe).tpe
      // private val extractorTp     = if (wellKinded(fun.tpe)) fun.tpe else existentialAbstraction(origExtractorTp.typeParams, origExtractorTp.resultType)
      // patmatDebug(&quot;ExtractorCallProd: &quot;+ (fun.tpe, existentialAbstraction(origExtractorTp.typeParams, origExtractorTp.resultType)))
      // patmatDebug(&quot;ExtractorCallProd: &quot;+ (fun.tpe, args map (_.tpe)))
      <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Type" id="1071304">constructorTp</a> = <a href="#1071312" title="PatternMatching.this.global.Tree">fun</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>

      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1071305">isTyped</a>    = <a href="#1071312" title="PatternMatching.this.global.Tree">fun</a>.<a href="../../../reflect/internal/Trees.scala.html#408560" title="=&gt; Boolean">isTyped</a>

      // to which type should the previous binder be casted?
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Type" id="1071306">paramType</a>  = <a href="#1071304" title="=&gt; PatternMatching.this.global.Type">constructorTp</a>.<a href="../../../reflect/internal/Types.scala.html#408427" title="=&gt; PatternMatching.this.global.Type">finalResultType</a>

      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1071307">isSeq</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <a href="#1071308" title="=&gt; List[PatternMatching.this.global.Type]">rawSubPatTypes</a>.<a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../reflect/internal/Definitions.scala.html#408815" title="(tp: PatternMatching.this.global.Type)Boolean">isRepeatedParamType</a><span class="delimiter">(</span><a href="#1071308" title="=&gt; List[PatternMatching.this.global.Type]">rawSubPatTypes</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86394" title="=&gt; PatternMatching.this.global.Type">last</a><span class="delimiter">)</span>
      <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; List[PatternMatching.this.global.Type]" id="1071308">rawSubPatTypes</a> = <a href="#1071304" title="=&gt; PatternMatching.this.global.Type">constructorTp</a>.<a href="../../../reflect/internal/Types.scala.html#408431" title="=&gt; List[PatternMatching.this.global.Type]">paramTypes</a>

      // binder has type paramType
      <span class="keyword">def</span> <a title="(binder: PatternMatching.this.global.Symbol, pos: PatternMatching.this.global.Position)MatchTranslation.this.TreeMaker" id="1071309">treeMaker</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1072459">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Position" id="1072460">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#22953" title="PatternMatching.this.global.Position">Position</a><span class="delimiter">)</span>: <a href="#1069034" title="MatchTranslation.this.TreeMaker">TreeMaker</a> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1072461">paramAccessors</a> = <a href="#1072459" title="PatternMatching.this.global.Symbol">binder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411429" title="=&gt; List[PatternMatching.this.global.Symbol]">constrParamAccessors</a>
        // binders corresponding to mutable fields should be stored (SI-5158, SI-6070)
        <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1072462">mutableBinders</a> =
          <span title="List[PatternMatching.this.global.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1072461" title="List[PatternMatching.this.global.Symbol]">paramAccessors</a> <a href="../../../collection/LinearSeqOptimized.scala.html#86379" title="(p: PatternMatching.this.global.Symbol =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#1072469" title="PatternMatching.this.global.Symbol">_</a>.<a href="../../../reflect/internal/HasFlags.scala.html#409860" title="=&gt; Boolean">isMutable</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#1070474" title="=&gt; List[PatternMatching.this.global.Symbol]">subPatBinders</a>.<a href="../../../collection/IterableLike.scala.html#58604" title="(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Symbol],(PatternMatching.this.global.Symbol, Int),List[(PatternMatching.this.global.Symbol, Int)]])List[(PatternMatching.this.global.Symbol, Int)]">zipWithIndex</a>.<a href="../../../collection/TraversableLike.scala.html#58075" title="(pf: PartialFunction[(PatternMatching.this.global.Symbol, Int),PatternMatching.this.global.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[(PatternMatching.this.global.Symbol, Int)],PatternMatching.this.global.Symbol,List[PatternMatching.this.global.Symbol]])List[PatternMatching.this.global.Symbol]">collect</a><a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[(PatternMatching.this.global.Symbol, Int),PatternMatching.this.global.Symbol] with Serializable" id="1072540" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Symbol" id="1072545">binder</a>, <a href="../../../Tuple2.scala.html#60637" title="Int" id="1072546">idx</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="../../../collection/LinearSeqOptimized.scala.html#86374" title="(n: Int)PatternMatching.this.global.Symbol">paramAccessors</a><span class="delimiter">(</span><a href="#1072546" title="Int">idx</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/HasFlags.scala.html#409860" title="=&gt; Boolean">isMutable</a> =&gt; <a href="#3368187" title="(x: B1)B1">binder</a> <span class="delimiter">}</span>
          <span class="keyword">else</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>

        // checks binder ne null before chaining to the next extractor
        <a href="#1075413" title="(prevBinder: PatternMatching.this.global.Symbol, extraCond: Option[PatternMatching.this.global.Tree])(subPatBinders: List[PatternMatching.this.global.Symbol], subPatRefs: List[PatternMatching.this.global.Tree], mutableBinders: List[PatternMatching.this.global.Symbol])MatchTranslation.this.ProductExtractorTreeMaker">ProductExtractorTreeMaker</a><span class="delimiter">(</span><a href="#1072459" title="PatternMatching.this.global.Symbol">binder</a>, <a href="#1070494" title="(binder: PatternMatching.this.global.Symbol)Option[PatternMatching.this.global.Tree]">lengthGuard</a><span class="delimiter">(</span><a href="#1072459" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1070474" title="=&gt; List[PatternMatching.this.global.Symbol]">subPatBinders</a>, <a href="#1070493" title="(binder: PatternMatching.this.global.Symbol)List[PatternMatching.this.global.Tree]">subPatRefs</a><span class="delimiter">(</span><a href="#1072459" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span>, <a href="#1072462" title="List[PatternMatching.this.global.Symbol]">mutableBinders</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      // reference the (i-1)th case accessor if it exists, otherwise the (i-1)th tuple component
      <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(binder: PatternMatching.this.global.Symbol)(i: Int)PatternMatching.this.global.Tree" id="1071310">tupleSel</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1072652">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Int" id="1072653">i</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">{</span> <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._
        // caseFieldAccessors is messed up after typers (reversed, names mangled for non-public fields)
        // TODO: figure out why...
        <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1072655">accessors</a> = <a href="#1072652" title="PatternMatching.this.global.Symbol">binder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411428" title="=&gt; List[PatternMatching.this.global.Symbol]">caseFieldAccessors</a>
        // luckily, the constrParamAccessors are still sorted properly, so sort the field-accessors using them
        // (need to undo name-mangling, including the sneaky trailing whitespace)
        <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1072656">constrParamAccessors</a> = <a href="#1072652" title="PatternMatching.this.global.Symbol">binder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411429" title="=&gt; List[PatternMatching.this.global.Symbol]">constrParamAccessors</a>

        <span class="keyword">def</span> <a title="(acc: PatternMatching.this.global.Symbol)Int" id="1072657">indexInCPA</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1072659">acc</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span> =
          <a href="#1072656" title="List[PatternMatching.this.global.Symbol]">constrParamAccessors</a> <a href="../../../collection/GenSeqLike.scala.html#58688" title="(p: PatternMatching.this.global.Symbol =&gt; Boolean)Int">indexWhere</a> <span class="delimiter">{</span> <a title="PatternMatching.this.global.Symbol" id="1072670">orig</a> =&gt;
            // patmatDebug(&quot;compare: &quot;+ (orig, acc, orig.name, acc.name, (acc.name == orig.name), (acc.name startsWith (orig.name append &quot;$&quot;))))
            <span class="keyword">val</span> <a title="String" id="1072671">origName</a>  = <a href="#1072670" title="PatternMatching.this.global.Symbol">orig</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; orig.NameType">name</a>.<span title="()String">toString</span>.<span title="()String">trim</span>
            <span class="keyword">val</span> <a title="String" id="1072672">accName</a> = <a href="#1072659" title="PatternMatching.this.global.Symbol">acc</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; acc.NameType">name</a>.<span title="()String">toString</span>.<span title="()String">trim</span>
            <span class="delimiter">(</span><a href="#1072672" title="String">accName</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1072671" title="String">origName</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#1072672" title="String">accName</a> <span title="(x$1: String)Boolean">startsWith</span> <span class="delimiter">(</span><a href="#1072671" title="String">origName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;$&quot;)" class="string">&quot;$&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>

        // patmatDebug(&quot;caseFieldAccessors: &quot;+ (accessors, binder.caseFieldAccessors map indexInCPA))
        // patmatDebug(&quot;constrParamAccessors: &quot;+ constrParamAccessors)

        <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1072658">accessorsSorted</a> = <a href="#1072655" title="List[PatternMatching.this.global.Symbol]">accessors</a> <a href="../../../collection/SeqLike.scala.html#58869" title="(f: PatternMatching.this.global.Symbol =&gt; Int)(implicit ord: scala.math.Ordering[Int])List[PatternMatching.this.global.Symbol]">sortBy</a> <a href="#1072657" title="(acc: PatternMatching.this.global.Symbol)Int">indexInCPA</a>
        <span title="PatternMatching.this.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#1072658" title="List[PatternMatching.this.global.Symbol]">accessorsSorted</a> <a href="../../../collection/LinearSeqOptimized.scala.html#86405" title="(x: Int)Boolean">isDefinedAt</a> <span class="delimiter">(</span><a href="#1072653" title="Int">i</a><a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods" class="delimiter">(</a><a href="#1072652" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#624619" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeFromSelectStart : (ss: PatternMatching.this.CODE.SelectStart)PatternMatching.this.global.Select">DOT</a> <a href="../../../collection/LinearSeqOptimized.scala.html#86374" title="(n: Int)PatternMatching.this.global.Symbol">accessorsSorted</a><span class="delimiter">(</span><a href="#1072653" title="Int">i</a><a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#1069017" title="=&gt; MatchTranslation.this.AbsCodegen">codegen</a>.<a href="#1071815" title="(binder: PatternMatching.this.global.Symbol)(i: Int)PatternMatching.this.global.Tree">tupleSel</a><span class="delimiter">(</span><a href="#1072652" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1072653" title="Int">i</a><span class="delimiter">)</span> // this won't type check for case classes, as they do not inherit ProductN
      <span class="delimiter">}</span>

      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1071311">toString</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="String">String</span> = <span title="String(&quot;case class &quot;)" class="string">&quot;case class &quot;</span><span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#1071304" title="=&gt; PatternMatching.this.global.Type">constructorTp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#1071312" title="PatternMatching.this.global.Tree">fun</a> <span class="keyword">else</span> <a href="#1071306" title="=&gt; PatternMatching.this.global.Type">paramType</a>.<a href="../../../reflect/internal/Types.scala.html#408407" title="=&gt; PatternMatching.this.global.Symbol">typeSymbol</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span><span title="String(&quot; with arguments &quot;)" class="string">&quot; with arguments &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1071313" title="List[PatternMatching.this.global.Tree]">args</a>
    <span class="delimiter">}</span>

    <span class="keyword">class</span> <a title="class ExtractorCallRegular extends MatchTranslation.this.ExtractorCall" id="1069003">ExtractorCallRegular</a><a href="#1069003" title="MatchTranslation.this.ExtractorCallRegular" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1071295">extractorCallIncludingDummy</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="List[PatternMatching.this.global.Tree]" id="1071296">args</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069001" title="MatchTranslation.this.ExtractorCall">ExtractorCall</a><span class="delimiter">(</span><a href="#1071296" title="List[PatternMatching.this.global.Tree]">args</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> Some<a href="#3368235" title="PatternMatching.this.global.Tree" id="3368237" class="delimiter">(</a>Apply<a href="../../../Option.scala.html#63132" title="PatternMatching.this.global.Tree" id="3368240" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410031" title="PatternMatching.this.global.Tree" id="1072803">extractorCall</a>, <a href="../../../reflect/internal/Trees.scala.html#410033" title="List[PatternMatching.this.global.Tree]" id="3368238">_</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="#1071295" title="PatternMatching.this.global.Tree">extractorCallIncludingDummy</a>.<a href="../../../reflect/internal/Trees.scala.html#408544" title="(p: PatternMatching.this.global.Tree =&gt; Boolean)Option[PatternMatching.this.global.Tree]">find</a><a href="#1072781" title="PatternMatching.this.global.Tree" class="delimiter">{</a> <span class="keyword">case</span> Apply<a href="#3368198" title="Boolean" id="3368202" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410031" title="PatternMatching.this.global.Tree" id="3368199">_</a>, <a href="../../../collection/generic/SeqFactory.scala.html#59986" title="Option[List[PatternMatching.this.global.Tree]]" id="3368219">List</a><a href="../../../reflect/internal/Trees.scala.html#410033" title="List[PatternMatching.this.global.Tree]" id="3368200" class="delimiter">(</a>Ident<a title="PatternMatching.this.global.Tree" id="3368209" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3368212">SELECTOR_DUMMY</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#3368215" title="(x: Boolean)Boolean" class="keyword">true</a> <span class="keyword">case</span> _ =&gt; <a href="#3368215" title="(x: Boolean)Boolean" class="keyword">false</a> <span class="delimiter">}</span>

      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Type" id="1071281">tpe</a>        = <a href="#1071279" title="=&gt; PatternMatching.this.global.Tree">extractorCall</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1071282">isTyped</a>    = <span class="delimiter">(</span><a href="#1071281" title="=&gt; PatternMatching.this.global.Type">tpe</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../../../reflect/internal/Types.scala.html#407284" title="PatternMatching.this.global.NoType.type">NoType</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1071279" title="=&gt; PatternMatching.this.global.Tree">extractorCall</a>.<a href="../../../reflect/internal/Trees.scala.html#408560" title="=&gt; Boolean">isTyped</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#1071290" title="=&gt; PatternMatching.this.global.Type">resultInMonad</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../../../reflect/internal/Types.scala.html#407277" title="PatternMatching.this.global.ErrorType.type">ErrorType</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Type" id="1071283">paramType</a>  = <a href="#1071281" title="=&gt; PatternMatching.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#408431" title="=&gt; List[PatternMatching.this.global.Type]">paramTypes</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; PatternMatching.this.global.Type">head</a>
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Type" id="1071284">resultType</a> = <a href="#1071281" title="=&gt; PatternMatching.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#408427" title="=&gt; PatternMatching.this.global.Type">finalResultType</a>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1071285">isSeq</a>      = <a href="#1071279" title="=&gt; PatternMatching.this.global.Tree">extractorCall</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; PatternMatching.this.global.Symbol#NameType">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/StdNames.scala.html#414577" title="=&gt; PatternMatching.this.global.nme.NameType">unapplySeq</a>

      <span class="keyword">def</span> <a title="(patBinderOrCasted: PatternMatching.this.global.Symbol, pos: PatternMatching.this.global.Position)MatchTranslation.this.TreeMaker" id="1071286">treeMaker</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1072813">patBinderOrCasted</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Position" id="1072814">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#22953" title="PatternMatching.this.global.Position">Position</a><span class="delimiter">)</span>: <a href="#1069034" title="MatchTranslation.this.TreeMaker">TreeMaker</a> = <span class="delimiter">{</span>
        // the extractor call (applied to the binder bound by the flatMap corresponding to the previous (i.e., enclosing/outer) pattern)
        <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1072815">extractorApply</a> = <a href="../../../reflect/internal/Positions.scala.html#408315" title="(pos: PatternMatching.this.global.Position)(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">atPos</a><span class="delimiter">(</span><a href="#1072814" title="PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1071289" title="(binder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">spliceApply</a><span class="delimiter">(</span><a href="#1072813" title="PatternMatching.this.global.Symbol">patBinderOrCasted</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="PatternMatching.this.global.TermSymbol" id="1072816">binder</a>         = <a href="#1069013" title="(pos: PatternMatching.this.global.Position, tp: PatternMatching.this.global.Type, prefix: String)PatternMatching.this.global.TermSymbol">freshSym</a><span class="delimiter">(</span><a href="#1072814" title="PatternMatching.this.global.Position">pos</a>, <a href="#1068985" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">pureType</a><span class="delimiter">(</span><a href="#1071290" title="=&gt; PatternMatching.this.global.Type">resultInMonad</a><span class="delimiter">)</span><span class="delimiter">)</span> // can't simplify this when subPatBinders.isEmpty, since UnitClass.tpe is definitely wrong when isSeq, and resultInMonad should always be correct since it comes directly from the extractor's result type
        <a href="#1075387" title="(extractor: PatternMatching.this.global.Tree, extraCond: Option[PatternMatching.this.global.Tree], nextBinder: PatternMatching.this.global.Symbol)(subPatBinders: List[PatternMatching.this.global.Symbol], subPatRefs: List[PatternMatching.this.global.Tree], extractorReturnsBoolean: Boolean, checkedLength: Option[Int], prevBinder: PatternMatching.this.global.Symbol)MatchTranslation.this.ExtractorTreeMaker">ExtractorTreeMaker</a><span class="delimiter">(</span><a href="#1072815" title="PatternMatching.this.global.Tree">extractorApply</a>, <a href="#1070494" title="(binder: PatternMatching.this.global.Symbol)Option[PatternMatching.this.global.Tree]">lengthGuard</a><span class="delimiter">(</span><a href="#1072816" title="PatternMatching.this.global.TermSymbol">binder</a><span class="delimiter">)</span>, <a href="#1072816" title="PatternMatching.this.global.TermSymbol">binder</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1070474" title="=&gt; List[PatternMatching.this.global.Symbol]">subPatBinders</a>, <a href="#1071288" title="(binder: PatternMatching.this.global.Symbol)List[PatternMatching.this.global.Tree]">subPatRefs</a><span class="delimiter">(</span><a href="#1072816" title="PatternMatching.this.global.TermSymbol">binder</a><span class="delimiter">)</span>, <a href="#1071284" title="=&gt; PatternMatching.this.global.Type">resultType</a>.<a href="../../../reflect/internal/Types.scala.html#408407" title="=&gt; PatternMatching.this.global.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/Definitions.scala.html#409369" title="=&gt; PatternMatching.this.global.ClassSymbol">BooleanClass</a>, <a href="#1070495" title="=&gt; Option[Int]">checkedLength</a>, <a href="#1072813" title="PatternMatching.this.global.Symbol">patBinderOrCasted</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(binder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree" id="1071287">seqTree</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1072871">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> =
        <span title="PatternMatching.this.global.gen.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#1070482" title="=&gt; Int">firstIndexingBinder</a> <a href="../../../Int.scala.html#57097" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1072871" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#1069003" title="MatchTranslation.this.ExtractorCallRegular" class="keyword">super</a>.<a href="#1070490" title="(binder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">seqTree</a><span class="delimiter">(</span><a href="#1072871" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span>

      // the trees that select the subpatterns on the extractor's result, referenced by `binder`
      // require (nbSubPats &gt; 0 &amp;&amp; (!lastIsStar || isSeq))
      <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(binder: PatternMatching.this.global.Symbol)List[PatternMatching.this.global.Tree]" id="1071288">subPatRefs</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1072864">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> =
        <span title="List[PatternMatching.this.global.gen.global.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1071285" title="=&gt; Boolean">isSeq</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1070466" title="=&gt; Int">nbSubPats</a> <a href="../../../Int.scala.html#57097" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.gen.global.Tree*)List[PatternMatching.this.global.gen.global.Tree]">List</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1072864" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span><span class="delimiter">)</span> // special case for extractors
        <span class="keyword">else</span> <a href="#1069003" title="MatchTranslation.this.ExtractorCallRegular" class="keyword">super</a>.<a href="#1070493" title="(binder: PatternMatching.this.global.Symbol)List[PatternMatching.this.global.Tree]">subPatRefs</a><span class="delimiter">(</span><a href="#1072864" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span>

      <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(binder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree" id="1071289">spliceApply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1072822">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
        <span class="keyword">object</span> <a title="splice.type" id="1072891">splice</a> <a href="#1072892" title="splice.type" class="keyword">extends</a> <a href="../ast/Trees.scala.html#537817" title="PatternMatching.this.global.Transformer">Transformer</a> <span class="delimiter">{</span>
          <span class="keyword">override</span> <span class="keyword">def</span> <a title="(t: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1072894">transform</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1072896">t</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span> = <a href="#1072896" title="PatternMatching.this.global.Tree">t</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> Apply<a href="#3368246" title="PatternMatching.this.global.Tree" id="3368249" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410031" title="PatternMatching.this.global.Tree" id="1072902">x</a>, <a href="../../../collection/generic/SeqFactory.scala.html#59986" title="Option[List[PatternMatching.this.global.Tree]]" id="3368266">List</a><a href="../../../reflect/internal/Trees.scala.html#410033" title="List[PatternMatching.this.global.Tree]" id="3368247" class="delimiter">(</a>Ident<a title="PatternMatching.this.global.Tree" id="3368256" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3368259">SELECTOR_DUMMY</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
              <a href="../../../reflect/api/Trees.scala.html#405645" title="=&gt; PatternMatching.this.global.TreeCopier">treeCopy</a>.<a href="../../../reflect/api/Trees.scala.html#405397" title="(tree: PatternMatching.this.global.Tree, fun: PatternMatching.this.global.Tree, args: List[PatternMatching.this.global.Tree])PatternMatching.this.global.Apply">Apply</a><a href="#3368262" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="#1072896" title="PatternMatching.this.global.Tree">t</a>, <a href="#1072902" title="PatternMatching.this.global.Tree">x</a>, <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.gen.global.Tree*)List[PatternMatching.this.global.gen.global.Tree]">List</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1072822" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">case</span> _ =&gt; <span class="keyword">super</span>.<a href="../../../reflect/api/Trees.scala.html#405652" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">transform</a><a href="#3368262" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="#1072896" title="PatternMatching.this.global.Tree">t</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#1072891" title="splice.type">splice</a>.<a href="#1072894" title="(t: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">transform</a><span class="delimiter">(</span><a href="#1071295" title="PatternMatching.this.global.Tree">extractorCallIncludingDummy</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      // what's the extractor's result type in the monad?
      // turn an extractor's result type into something `monadTypeToSubPatTypesAndRefs` understands
      <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1071291">resultInMonad</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a> = <span title="PatternMatching.this.global.Type" class="keyword">if</span><span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="../../../reflect/internal/Types.scala.html#407539" title="(xs: List[_], len: Int)Boolean">hasLength</a><span class="delimiter">(</span><a href="#1071281" title="=&gt; PatternMatching.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#408431" title="=&gt; List[PatternMatching.this.global.Type]">paramTypes</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../reflect/internal/Types.scala.html#407277" title="PatternMatching.this.global.ErrorType.type">ErrorType</a> <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="PatternMatching.this.global.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#1071284" title="=&gt; PatternMatching.this.global.Type">resultType</a>.<a href="../../../reflect/internal/Types.scala.html#408407" title="=&gt; PatternMatching.this.global.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/Definitions.scala.html#409369" title="=&gt; PatternMatching.this.global.ClassSymbol">BooleanClass</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Definitions.scala.html#409353" title="=&gt; PatternMatching.this.global.ClassSymbol">UnitClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a>
        <span class="keyword">else</span> <a href="#1068986" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">matchMonadResult</a><span class="delimiter">(</span><a href="#1071284" title="=&gt; PatternMatching.this.global.Type">resultType</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Type]" id="1071293">rawSubPatTypes</a> =
        <span title="List[PatternMatching.this.global.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1071290" title="=&gt; PatternMatching.this.global.Type">resultInMonad</a>.<a href="../../../reflect/internal/Types.scala.html#408407" title="=&gt; PatternMatching.this.global.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="../../../reflect/internal/Definitions.scala.html#409353" title="=&gt; PatternMatching.this.global.ClassSymbol">UnitClass</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>
        <span class="keyword">else</span> <span title="List[PatternMatching.this.global.Type]" class="keyword">if</span><span class="delimiter">(</span><a href="#1070466" title="=&gt; Int">nbSubPats</a> <a href="../../../Int.scala.html#57097" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>                    <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Type*)List[PatternMatching.this.global.Type]">List</a><span class="delimiter">(</span><a href="#1071290" title="=&gt; PatternMatching.this.global.Type">resultInMonad</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="../../../reflect/internal/Definitions.scala.html#409017" title="(tpe: PatternMatching.this.global.Type)List[PatternMatching.this.global.Type]">getProductArgs</a><span title="List[PatternMatching.this.global.Type]" class="delimiter">(</span><a href="#1071290" title="=&gt; PatternMatching.this.global.Type">resultInMonad</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="../../../collection/immutable/List.scala.html#11188" title="List[PatternMatching.this.global.Type]" id="3368284">Nil</a> =&gt; <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Type*)List[PatternMatching.this.global.Type]">List</a><a href="#3368286" title="(x: List[PatternMatching.this.global.Type])List[PatternMatching.this.global.Type]" class="delimiter">(</a><a href="#1071290" title="=&gt; PatternMatching.this.global.Type">resultInMonad</a><span class="delimiter">)</span>
          <span class="keyword">case</span> x   =&gt; <a href="#3368286" title="(x: List[PatternMatching.this.global.Type])List[PatternMatching.this.global.Type]">x</a>
        <span class="delimiter">}</span>

      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1071294">toString</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="../../../Predef.scala.html#7605" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">extractorCall</a> <a href="../../../runtime/StringAdd.scala.html#60046" title="(other: String)String">+</a><span title="String(&quot;: &quot;)" class="string">&quot;: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1071279" title="=&gt; PatternMatching.this.global.Tree">extractorCall</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a> <span title="(x$1: Any)String">+</span><span title="String(&quot; (symbol= &quot;)" class="string">&quot; (symbol= &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1071279" title="=&gt; PatternMatching.this.global.Tree">extractorCall</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;).&quot;)" class="string">&quot;).&quot;</span>
    <span class="delimiter">}</span>

    /** A conservative approximation of which patterns do not discern anything.
     * They are discarded during the translation.
     */
    <span class="keyword">object</span> <a title="MatchTranslation.this.WildcardPattern.type" id="1069004">WildcardPattern</a> <a href="#1069005" title="MatchTranslation.this.WildcardPattern.type" class="delimiter">{</a>
      <span class="keyword">def</span> <a title="(pat: PatternMatching.this.global.Tree)Boolean" id="1070864">unapply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1070865">pat</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <a href="#1070865" title="PatternMatching.this.global.Tree">pat</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Bind<a href="#3368294" title="Boolean" id="3368298" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#410157" title="PatternMatching.this.global.Name" id="3368315">WILDCARD</a>, <a href="#1070864" title="Boolean">WildcardPattern</a><a href="../../../reflect/internal/Trees.scala.html#410159" title="PatternMatching.this.global.Tree" id="3368301" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#3368322" title="(x: Boolean)Boolean" class="keyword">true</a> // don't skip when binding an interesting symbol!
        <span class="keyword">case</span> Ident<a href="#3368294" title="Boolean" id="3368304" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3368316">WILDCARD</a><span class="delimiter">)</span>                   =&gt; <a href="#3368322" title="(x: Boolean)Boolean" class="keyword">true</a>
        <span class="keyword">case</span> Star<a href="#3368294" title="Boolean" id="3368309" class="delimiter">(</a><a href="#1070864" title="Boolean">WildcardPattern</a><a href="../../../reflect/internal/Trees.scala.html#410166" title="PatternMatching.this.global.Tree" id="3368310" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span>               =&gt; <a href="#3368322" title="(x: Boolean)Boolean" class="keyword">true</a>
        <span class="keyword">case</span> x: Ident                              =&gt; <a href="../ast/Trees.scala.html#537807" title="PatternMatching.this.global.treeInfo.type">treeInfo</a>.<a href="../../../reflect/internal/TreeInfo.scala.html#479213" title="(pat: PatternMatching.this.global.treeInfo.global.Tree)Boolean">isVarPattern</a><a href="#3368322" title="(x: Boolean)Boolean" class="delimiter">(</a>x<span class="delimiter">)</span>
        <span class="keyword">case</span> Alternative<a href="#3368294" title="Boolean" id="3368313" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410172" title="List[PatternMatching.this.global.Tree]" id="1072973">ps</a><span class="delimiter">)</span>                       =&gt; <a href="#1072973" title="List[PatternMatching.this.global.Tree]">ps</a> <a href="#3368322" title="(x: Boolean)Boolean">forall</a> <span class="delimiter">(</span><a href="#1069004" title="MatchTranslation.this.WildcardPattern.type">WildcardPattern</a>.<a href="#1070864" title="(pat: PatternMatching.this.global.Tree)Boolean">unapply</a><span class="delimiter">(</span><a href="#1072980" title="PatternMatching.this.global.Tree">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <a href="../../../reflect/internal/Trees.scala.html#407946" title="Boolean" id="3368318">EmptyTree</a>                             =&gt; <a href="#3368322" title="(x: Boolean)Boolean" class="keyword">true</a>
        <span class="keyword">case</span> _                                     =&gt; <a href="#3368322" title="(x: Boolean)Boolean" class="keyword">false</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">object</span> <a title="MatchTranslation.this.Bound.type" id="1069006">Bound</a> <a href="#1069007" title="MatchTranslation.this.Bound.type" class="delimiter">{</a>
      <span class="keyword">def</span> <a title="(t: PatternMatching.this.global.Tree)Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]" id="1070542">unapply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1070543">t</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Tree<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#1070543" title="PatternMatching.this.global.Tree">t</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> t@Bind<a href="#3368341" title="Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]" id="3368343" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410157" title="PatternMatching.this.global.Name" id="1072987">n</a>, <a href="../../../reflect/internal/Trees.scala.html#410159" title="PatternMatching.this.global.Tree" id="1072988">p</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span>t.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span>t.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span> =&gt; // pos/t2429 does not satisfy these conditions
          <a href="../../../Option.scala.html#63128" title="(x: (PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree))Some[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">Some</a><a href="#3368345" title="(x: Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]" class="delimiter">(</a><a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Symbol, _2: PatternMatching.this.global.Tree)(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)" class="delimiter">(</a>t.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>, <a href="#1072988" title="PatternMatching.this.global.Tree">p</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt; <a href="#3368345" title="(x: Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])Option[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">None</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span title="Object" class="delimiter">}</span>

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// substitution
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  <span class="keyword">trait</span> <a title="trait TypedSubstitution extends Object with PatternMatching.this.MatchMonadInterface" id="621387">TypedSubstitution</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621385" title="PatternMatching.this.MatchMonadInterface">MatchMonadInterface</a> <span class="delimiter">{</span>
    <span class="keyword">object</span> <a title="TypedSubstitution.this.Substitution.type" id="1069024">Substitution</a> <a href="#1069025" title="TypedSubstitution.this.Substitution.type" class="delimiter">{</a>
      <span class="keyword">def</span> <a title="(from: PatternMatching.this.global.Symbol, to: PatternMatching.this.global.Tree)TypedSubstitution.this.Substitution" id="1073001">apply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1073006">from</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Tree" id="1073007">to</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span> = <span title="TypedSubstitution.this.Substitution" class="keyword">new</span> <a href="#1069026" title="TypedSubstitution.this.Substitution">Substitution</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Symbol*)List[PatternMatching.this.global.Symbol]">List</a><span class="delimiter">(</span><a href="#1073006" title="PatternMatching.this.global.Symbol">from</a><span class="delimiter">)</span>, <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Tree*)List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">(</span><a href="#1073007" title="PatternMatching.this.global.Tree">to</a><span class="delimiter">)</span><span class="delimiter">)</span>
      // requires sameLength(from, to)
      <span class="keyword">def</span> <a title="(from: List[PatternMatching.this.global.Symbol], to: List[PatternMatching.this.global.Tree])TypedSubstitution.this.Substitution" id="1073002">apply</a><span class="delimiter">(</span><a title="List[PatternMatching.this.global.Symbol]" id="1073022">from</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[PatternMatching.this.global.Tree]" id="1073023">to</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span> =
        <span title="TypedSubstitution.this.Substitution" class="keyword">if</span> <span class="delimiter">(</span><a href="#1073022" title="List[PatternMatching.this.global.Symbol]">from</a> <a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <span title="TypedSubstitution.this.Substitution" class="keyword">new</span> <a href="#1069026" title="TypedSubstitution.this.Substitution">Substitution</a><span class="delimiter">(</span><a href="#1073022" title="List[PatternMatching.this.global.Symbol]">from</a>, <a href="#1073023" title="List[PatternMatching.this.global.Tree]">to</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#1069027" title="TypedSubstitution.this.EmptySubstitution.type">EmptySubstitution</a>
    <span class="delimiter">}</span>

    <span class="keyword">class</span> <a title="class Substitution extends Object" id="1069026">Substitution</a><a href="#1069026" title="TypedSubstitution.this.Substitution" class="delimiter">(</a><span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1073003">from</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Tree]" id="1073004">to</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      // We must explicitly type the trees that we replace inside some other tree, since the latter may already have been typed,
      // and will thus not be retyped. This means we might end up with untyped subtrees inside bigger, typed trees.
      <span class="keyword">def</span> <a title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1069977">apply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1073027">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
        // according to -Ystatistics 10% of translateMatch's time is spent in this method...
        // since about half of the typedSubst's end up being no-ops, the check below shaves off 5% of the time spent in typedSubst
        <span title="PatternMatching.this.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1073027" title="PatternMatching.this.global.Tree">tree</a>.<a href="../../../reflect/internal/Trees.scala.html#408545" title="(p: PatternMatching.this.global.Tree =&gt; Boolean)Boolean">exists</a> <a href="#1073031" title="PatternMatching.this.global.Tree" class="delimiter">{</a> <span class="keyword">case</span> i@Ident<a href="#3368350" title="Boolean" id="3368353" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3368351">_</a><span class="delimiter">)</span> =&gt; <a href="#1073003" title="=&gt; List[PatternMatching.this.global.Symbol]">from</a> <a href="#3368355" title="(x: Boolean)Boolean">contains</a> i.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a> <span class="keyword">case</span> _ =&gt; <a href="#3368355" title="(x: Boolean)Boolean" class="keyword">false</a><span class="delimiter">}</span><span class="delimiter">)</span> <a href="#1073027" title="PatternMatching.this.global.Tree">tree</a>
        <span class="keyword">else</span> <span class="delimiter">(</span><a href="#1073036" title="PatternMatching.this.global.Transformer{}" class="keyword">new</a> <a href="../ast/Trees.scala.html#537817" title="anonymous class $anon extends PatternMatching.this.global.Transformer" id="1073036">Transformer</a> <span class="delimiter">{</span>
          <span class="keyword">private</span> <span class="keyword">def</span> <a title="(to: PatternMatching.this.global.Tree, origTp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree" id="1073038">typedIfOrigTyped</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1073043">to</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Type" id="1073044">origTp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> =
            <span title="PatternMatching.this.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#1073044" title="PatternMatching.this.global.Type">origTp</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="#1073044" title="PatternMatching.this.global.Type">origTp</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/Types.scala.html#407284" title="PatternMatching.this.global.NoType.type">NoType</a><span class="delimiter">)</span> <a href="#1073043" title="PatternMatching.this.global.Tree">to</a>
            // important: only type when actually substing and when original tree was typed
            // (don't need to use origTp as the expected type, though, and can't always do this anyway due to unknown type params stemming from polymorphic extractors)
            <span class="keyword">else</span> <a href="#1068979" title="=&gt; PatternMatching.this.global.analyzer.Typer">typer</a>.<a href="Typers.scala.html#538698" title="(tree: PatternMatching.this.global.analyzer.global.Tree, mode: Int, pt: PatternMatching.this.global.analyzer.global.Type)PatternMatching.this.global.analyzer.global.Tree">typed</a><span class="delimiter">(</span><a href="#1073043" title="PatternMatching.this.global.Tree">to</a>, <span title="Int(1)">EXPRmode</span>, <a href="../../../reflect/internal/Types.scala.html#407279" title="PatternMatching.this.global.WildcardType.type">WildcardType</a><span class="delimiter">)</span>

          <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1073039">transform</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1073040">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
            <span class="keyword">def</span> <a title="(from: List[PatternMatching.this.global.Symbol], to: List[PatternMatching.this.global.Tree])PatternMatching.this.global.Tree" id="1073061">subst</a><span class="delimiter">(</span><a title="List[PatternMatching.this.global.Symbol]" id="1073062">from</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[PatternMatching.this.global.Tree]" id="1073063">to</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> =
              <span title="PatternMatching.this.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#1073062" title="List[PatternMatching.this.global.Symbol]">from</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#1073040" title="PatternMatching.this.global.Tree">tree</a>
              <span class="keyword">else</span> <span title="PatternMatching.this.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#1073040" title="PatternMatching.this.global.Tree">tree</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1073062" title="List[PatternMatching.this.global.Symbol]">from</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; PatternMatching.this.global.Symbol">head</a><span class="delimiter">)</span> <a href="#1073038" title="(to: PatternMatching.this.global.Tree, origTp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree">typedIfOrigTyped</a><span class="delimiter">(</span><a href="#1073063" title="List[PatternMatching.this.global.Tree]">to</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; PatternMatching.this.global.Tree">head</a>.<a href="../../../reflect/internal/Trees.scala.html#408564" title="=&gt; PatternMatching.this.global.Tree">shallowDuplicate</a>, <a href="#1073040" title="PatternMatching.this.global.Tree">tree</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span>
              <span class="keyword">else</span> <a href="#1073061" title="(from: List[PatternMatching.this.global.Symbol], to: List[PatternMatching.this.global.Tree])PatternMatching.this.global.Tree">subst</a><span class="delimiter">(</span><a href="#1073062" title="List[PatternMatching.this.global.Symbol]">from</a>.<a href="../../../collection/TraversableLike.scala.html#58104" title="=&gt; List[PatternMatching.this.global.Symbol]">tail</a>, <a href="#1073063" title="List[PatternMatching.this.global.Tree]">to</a>.<a href="../../../collection/TraversableLike.scala.html#58104" title="=&gt; List[PatternMatching.this.global.Tree]">tail</a><span class="delimiter">)</span>

            <a href="#1073040" title="PatternMatching.this.global.Tree">tree</a> <span class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> Ident<a href="#3368360" title="PatternMatching.this.global.Tree" id="3368363" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3368361">_</a><span class="delimiter">)</span> =&gt; <a href="#1073061" title="(from: List[PatternMatching.this.global.Symbol], to: List[PatternMatching.this.global.Tree])PatternMatching.this.global.Tree">subst</a><a href="#3368365" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="#1073003" title="=&gt; List[PatternMatching.this.global.Symbol]">from</a>, <a href="#1073004" title="=&gt; List[PatternMatching.this.global.Tree]">to</a><span class="delimiter">)</span>
              <span class="keyword">case</span> _        =&gt; <a href="#1073036" title="PatternMatching.this.global.Transformer{}" class="keyword">super</a>.<a href="../../../reflect/api/Trees.scala.html#405652" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">transform</a><a href="#3368365" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="#1073040" title="PatternMatching.this.global.Tree">tree</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>.<a href="#1073039" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">transform</a><span class="delimiter">(</span><a href="#1073027" title="PatternMatching.this.global.Tree">tree</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>


      // the substitution that chains `other` before `this` substitution
      // forall t: Tree. this(other(t)) == (this &gt;&gt; other)(t)
      <span class="keyword">def</span> <a title="(other: TypedSubstitution.this.Substitution)TypedSubstitution.this.Substitution" id="1069978">&gt;&gt;</a><span class="delimiter">(</span><a title="TypedSubstitution.this.Substitution" id="1073076">other</a>: <a href="#1069026" title="TypedSubstitution.this.Substitution">Substitution</a><span class="delimiter">)</span>: <a href="#1069026" title="TypedSubstitution.this.Substitution">Substitution</a> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a href="#3368372" title="(x: (List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.Tree]))(List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.Tree])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="List[PatternMatching.this.global.Symbol]" id="1073078">fromFiltered</a>, <a href="../../../Tuple2.scala.html#60637" title="List[PatternMatching.this.global.Tree]" id="1073079">toFiltered</a><span class="delimiter">)</span> = <a href="../../../Predef.scala.html#7531" title="(x: (List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.Tree]))runtime.Tuple2Zipped.Ops[List[PatternMatching.this.global.Symbol],List[PatternMatching.this.global.Tree]]" class="delimiter">(</a><a href="#1073003" title="=&gt; List[PatternMatching.this.global.Symbol]">from</a>, <a href="#1073004" title="=&gt; List[PatternMatching.this.global.Tree]">to</a><span class="delimiter">)</span>.<a href="../../../runtime/Tuple2Zipped.scala.html#60613" title="(implicit w1: List[PatternMatching.this.global.Symbol] =&gt; scala.collection.TraversableLike[PatternMatching.this.global.Symbol,List[PatternMatching.this.global.Symbol]], implicit w2: List[PatternMatching.this.global.Tree] =&gt; scala.collection.IterableLike[PatternMatching.this.global.Tree,List[PatternMatching.this.global.Tree]])scala.runtime.Tuple2Zipped[PatternMatching.this.global.Symbol,List[PatternMatching.this.global.Symbol],PatternMatching.this.global.Tree,List[PatternMatching.this.global.Tree]]">zipped</a> <a href="../../../runtime/Tuple2Zipped.scala.html#486050" title="(f: (PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree) =&gt; Boolean)(implicit cbf1: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Symbol],PatternMatching.this.global.Symbol,List[PatternMatching.this.global.Symbol]], implicit cbf2: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Tree],PatternMatching.this.global.Tree,List[PatternMatching.this.global.Tree]])(List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.Tree])">filter</a> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1073136">f</a>, <a title="PatternMatching.this.global.Tree" id="1073137">t</a><span class="delimiter">)</span> =&gt;  <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1073076" title="TypedSubstitution.this.Substitution">other</a>.<a href="#1073003" title="=&gt; List[PatternMatching.this.global.Symbol]">from</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86380" title="(elem: Any)Boolean">contains</a><span class="delimiter">(</span><a href="#1073136" title="PatternMatching.this.global.Symbol">f</a><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span title="TypedSubstitution.this.Substitution" class="keyword">new</span> <a href="#1069026" title="TypedSubstitution.this.Substitution">Substitution</a><span class="delimiter">(</span><a href="#1073076" title="TypedSubstitution.this.Substitution">other</a>.<a href="#1073003" title="=&gt; List[PatternMatching.this.global.Symbol]">from</a> <a href="../../../collection/immutable/List.scala.html#62697" title="(that: scala.collection.GenTraversableOnce[PatternMatching.this.global.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Symbol],PatternMatching.this.global.Symbol,List[PatternMatching.this.global.Symbol]])List[PatternMatching.this.global.Symbol]">++</a> <a href="#1073078" title="List[PatternMatching.this.global.Symbol]">fromFiltered</a>, <a href="#1073076" title="TypedSubstitution.this.Substitution">other</a>.<a href="#1073004" title="=&gt; List[PatternMatching.this.global.Tree]">to</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Tree],PatternMatching.this.global.Tree,List[PatternMatching.this.global.Tree]])List[PatternMatching.this.global.Tree]">map</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,PatternMatching.this.global.Tree,List[PatternMatching.this.global.Tree]]" class="delimiter">(</a><a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">apply</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#62697" title="(that: scala.collection.GenTraversableOnce[PatternMatching.this.global.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Tree],PatternMatching.this.global.Tree,List[PatternMatching.this.global.Tree]])List[PatternMatching.this.global.Tree]">++</a> <a href="#1073079" title="List[PatternMatching.this.global.Tree]">toFiltered</a><span class="delimiter">)</span> // a quick benchmarking run indicates the `.map(apply)` is not too costly
      <span class="delimiter">}</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1069979">toString</a> = <span class="delimiter">(</span><a href="#1073003" title="=&gt; List[PatternMatching.this.global.Symbol]">from</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.Symbol =&gt; PatternMatching.this.global.Symbol#NameType)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Symbol],PatternMatching.this.global.Symbol#NameType,List[PatternMatching.this.global.Symbol#NameType]])List[PatternMatching.this.global.Symbol#NameType]">map</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,PatternMatching.this.global.Symbol#NameType,List[PatternMatching.this.global.Symbol#NameType]]" class="delimiter">(</a><a href="#1073379" title="PatternMatching.this.global.Symbol">_</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; x$18.NameType">name</a><span class="delimiter">)</span> <a href="../../../collection/IterableLike.scala.html#58590" title="(that: scala.collection.GenIterable[PatternMatching.this.global.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Symbol#NameType],(PatternMatching.this.global.Symbol#NameType, PatternMatching.this.global.Tree),List[(PatternMatching.this.global.Symbol#NameType, PatternMatching.this.global.Tree)]])List[(PatternMatching.this.global.Symbol#NameType, PatternMatching.this.global.Tree)]">zip</a> <a href="#1073004" title="=&gt; List[PatternMatching.this.global.Tree]">to</a><span class="delimiter">)</span> <a href="../../../collection/TraversableOnce.scala.html#58282" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;Substitution(&quot;)" class="string">&quot;Substitution(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">object</span> <a title="TypedSubstitution.this.EmptySubstitution.type" id="1069027">EmptySubstitution</a> <a href="#1069028" title="TypedSubstitution.this.EmptySubstitution.type" class="keyword">extends</a> <a href="#1069026" title="TypedSubstitution.this.Substitution">Substitution</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1069981">apply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1073471">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="#1073471" title="PatternMatching.this.global.Tree">tree</a>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="(other: TypedSubstitution.this.Substitution)TypedSubstitution.this.Substitution" id="1069982">&gt;&gt;</a><span class="delimiter">(</span><a title="TypedSubstitution.this.Substitution" id="1073472">other</a>: <a href="#1069026" title="TypedSubstitution.this.Substitution">Substitution</a><span class="delimiter">)</span>: <a href="#1069026" title="TypedSubstitution.this.Substitution">Substitution</a> = <a href="#1073472" title="TypedSubstitution.this.Substitution">other</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// the making of the trees
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  <span class="keyword">trait</span> <a title="trait TreeMakers extends Object with PatternMatching.this.TypedSubstitution" id="621388">TreeMakers</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621387" title="PatternMatching.this.TypedSubstitution">TypedSubstitution</a> <span class="delimiter">{</span> self: CodegenCore =&gt;
    <span class="keyword">def</span> <a title="(prevBinder: PatternMatching.this.global.Symbol, cases: List[List[TreeMakers.this.TreeMaker]], pt: PatternMatching.this.global.Type, unchecked: Boolean)(List[List[TreeMakers.this.TreeMaker]], List[PatternMatching.this.global.Tree])" id="1069031">optimizeCases</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1073489">prevBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="List[List[TreeMakers.this.TreeMaker]]" id="1073490">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[TreeMakers.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="PatternMatching.this.global.Type" id="1073491">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <a title="Boolean" id="1073492">unchecked</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="../../../Tuple2.scala.html#783" title="(List[List[TreeMakers.this.TreeMaker]], List[PatternMatching.this.global.Tree])" class="delimiter">(</a>List<span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span>, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="../../../Tuple2.scala.html#62849" title="(_1: List[List[TreeMakers.this.TreeMaker]], _2: scala.collection.immutable.Nil.type)(List[List[TreeMakers.this.TreeMaker]], scala.collection.immutable.Nil.type)" class="delimiter">(</a><a href="#1073490" title="List[List[TreeMakers.this.TreeMaker]]">cases</a>, <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, cases: List[List[TreeMakers.this.TreeMaker]], pt: PatternMatching.this.global.Type, matchFailGenOverride: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree], unchecked: Boolean)Option[PatternMatching.this.global.Tree]" id="1069032">emitSwitch</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1073504">scrut</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1073505">scrutSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="List[List[TreeMakers.this.TreeMaker]]" id="1073506">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[TreeMakers.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="PatternMatching.this.global.Type" id="1073507">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <a title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]" id="1073508">matchFailGenOverride</a>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree =&gt; Tree<span class="delimiter">]</span>, <a title="Boolean" id="1073509">unchecked</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> =
      <a href="../../../Option.scala.html#1585" title="None.type">None</a>

    // for catch (no need to customize match failure)
    <span class="keyword">def</span> <a title="(bindersAndCases: List[(PatternMatching.this.global.Symbol, List[TreeMakers.this.TreeMaker])], pt: PatternMatching.this.global.Type)Option[List[PatternMatching.this.global.CaseDef]]" id="1069033">emitTypeSwitch</a><span class="delimiter">(</span><a title="List[(PatternMatching.this.global.Symbol, List[TreeMakers.this.TreeMaker])]" id="1070014">bindersAndCases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[(PatternMatching.this.global.Symbol, List[TreeMakers.this.TreeMaker])]">List</a><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>, <a title="PatternMatching.this.global.Type" id="1070015">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[List[PatternMatching.this.global.CaseDef]]">Option</a><span class="delimiter">[</span>List<span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="../../../Option.scala.html#1585" title="None.type">None</a>

    <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TreeMaker extends Object" id="1069034">TreeMaker</a> <a href="#1069034" title="TreeMakers.this.TreeMaker" class="delimiter">{</a>
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Position" id="1069808">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#22953" title="PatternMatching.this.global.Position">Position</a>

      /** captures the scope and the value of the bindings in patterns
       * important *when* the substitution happens (can't accumulate and do at once after the full matcher has been constructed)
       */
      <span class="keyword">def</span> <a title="=&gt; TreeMakers.this.Substitution" id="1069809">substitution</a>: <a href="#1069026" title="TreeMakers.this.Substitution">Substitution</a> =
        <span title="TreeMakers.this.Substitution" class="keyword">if</span> <span class="delimiter">(</span><a href="#1069812" title="TreeMakers.this.Substitution">currSub</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#1069810" title="=&gt; TreeMakers.this.Substitution">localSubstitution</a>
        <span class="keyword">else</span> <a href="#1069812" title="TreeMakers.this.Substitution">currSub</a>

      <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; TreeMakers.this.Substitution" id="1069810">localSubstitution</a>: <a href="#1069026" title="TreeMakers.this.Substitution">Substitution</a>

      <span class="keyword">private</span><span class="delimiter">[</span>TreeMakers<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(outerSubst: TreeMakers.this.Substitution)Unit" id="1069811">incorporateOuterSubstitution</a><span class="delimiter">(</span><a title="TreeMakers.this.Substitution" id="1073512">outerSubst</a>: <a href="#1069026" title="TreeMakers.this.Substitution">Substitution</a><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#1515" title="Unit">Unit</a> = <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1069812" title="TreeMakers.this.Substitution">currSub</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;BUG: incorporateOuterSubstitution called more than once for &quot;)" class="string">&quot;BUG: incorporateOuterSubstitution called more than once for &quot;</span><a href="../../../Tuple3.scala.html#63169" title="(x$1: Any)String">+</a> <span class="delimiter">(</span><a href="#1069034" title="TreeMakers.this.TreeMaker" class="keyword">this</a>, <a href="#1069812" title="TreeMakers.this.Substitution">currSub</a>, <a href="#1073512" title="TreeMakers.this.Substitution">outerSubst</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="Thread.type">Thread</span>.<span title="()Unit">dumpStack</span><span class="delimiter">(</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">else</span> <a href="#1069812" title="TreeMakers.this.Substitution">currSub</a> = <a href="#1073512" title="TreeMakers.this.Substitution">outerSubst</a> <a href="#1069978" title="(other: TreeMakers.this.Substitution)TreeMakers.this.Substitution">&gt;&gt;</a> <a href="#1069809" title="=&gt; TreeMakers.this.Substitution">substitution</a>
      <span class="delimiter">}</span>
      <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">var</span> <a title="TreeMakers.this.Substitution" id="1069812">currSub</a>: <a href="#1069026" title="TreeMakers.this.Substitution">Substitution</a> = <span title="Null(null)" class="keyword">null</span>

      /** The substitution that specifies the trees that compute the values of the subpattern binders.
       *
       * Should not be used to perform actual substitution!
       * Only used to reason symbolically about the values the subpattern binders are bound to.
       * See TreeMakerToCond#updateSubstitution.
       *
       * Overridden in PreserveSubPatBinders to pretend it replaces the subpattern binders by subpattern refs
       * (Even though we don't do so anymore -- see SI-5158, SI-5739 and SI-6070.)
       *
       * TODO: clean this up, would be nicer to have some higher-level way to compute
       * the binders bound by this tree maker and the symbolic values that correspond to them
       */
      <span class="keyword">def</span> <a title="=&gt; TreeMakers.this.Substitution" id="1069813">subPatternsAsSubstitution</a>: <a href="#1069026" title="TreeMakers.this.Substitution">Substitution</a> = <a href="#1069809" title="=&gt; TreeMakers.this.Substitution">substitution</a>

      // build Tree that chains `next` after the current extractor
      <span class="keyword">def</span> <a title="(next: PatternMatching.this.global.Tree)(casegen: TreeMakers.this.Casegen)PatternMatching.this.global.Tree" id="1069814">chainBefore</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1073523">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="TreeMakers.this.Casegen" id="1073524">casegen</a>: <a href="#1069016" title="TreeMakers.this.Casegen">Casegen</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
    <span class="delimiter">}</span>

    <span class="keyword">trait</span> <a title="trait NoNewBinders extends TreeMakers.this.TreeMaker" id="1069035">NoNewBinders</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#1069034" title="TreeMakers.this.TreeMaker">TreeMaker</a> <span class="delimiter">{</span>
      <span class="keyword">protected</span> <span class="keyword">val</span> <a title="TreeMakers.this.Substitution" id="1071039">localSubstitution</a>: <a href="#1069026" title="TreeMakers.this.Substitution">Substitution</a> = <a href="#1069027" title="TreeMakers.this.EmptySubstitution.type">EmptySubstitution</a>
    <span class="delimiter">}</span>

    case <span class="keyword">class</span> <a title="class TrivialTreeMaker extends TreeMakers.this.TreeMaker with TreeMakers.this.NoNewBinders with Product with Serializable" id="1075306">TrivialTreeMaker</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1074828">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069034" title="TreeMakers.this.TreeMaker">TreeMaker</a> <span class="keyword">with</span> <a href="#1069035" title="TreeMakers.this.NoNewBinders">NoNewBinders</a> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Position" id="1073538">pos</a> = <a href="#1074828" title="=&gt; PatternMatching.this.global.Tree">tree</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a>

      <span class="keyword">def</span> <a title="(next: PatternMatching.this.global.Tree)(casegen: TreeMakers.this.Casegen)PatternMatching.this.global.Tree" id="1073539">chainBefore</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1073547">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="TreeMakers.this.Casegen" id="1073548">casegen</a>: <a href="#1069016" title="TreeMakers.this.Casegen">Casegen</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="#1074828" title="=&gt; PatternMatching.this.global.Tree">tree</a>
    <span class="delimiter">}</span>

    case <span class="keyword">class</span> <a title="class BodyTreeMaker extends TreeMakers.this.TreeMaker with TreeMakers.this.NoNewBinders with Product with Serializable" id="1075332">BodyTreeMaker</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1071266">body</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Type" id="1071267">matchPt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069034" title="TreeMakers.this.TreeMaker">TreeMaker</a> <span class="keyword">with</span> <a href="#1069035" title="TreeMakers.this.NoNewBinders">NoNewBinders</a> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Position" id="1071261">pos</a> = <a href="#1071266" title="=&gt; PatternMatching.this.global.Tree">body</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a>

      <span class="keyword">def</span> <a title="(next: PatternMatching.this.global.Tree)(casegen: TreeMakers.this.Casegen)PatternMatching.this.global.Tree" id="1071262">chainBefore</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1073585">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="TreeMakers.this.Casegen" id="1073586">casegen</a>: <a href="#1069016" title="TreeMakers.this.Casegen">Casegen</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = // assert(next eq EmptyTree)
        <a href="../../../reflect/internal/Positions.scala.html#408315" title="(pos: PatternMatching.this.global.Position)(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">atPos</a><span class="delimiter">(</span><a href="#1071266" title="=&gt; PatternMatching.this.global.Tree">body</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1073586" title="TreeMakers.this.Casegen">casegen</a>.<a href="#1073527" title="(res: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">one</a><span class="delimiter">(</span><a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">substitution</a><span class="delimiter">(</span><a href="#1071266" title="=&gt; PatternMatching.this.global.Tree">body</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> // since SubstOnly treemakers are dropped, need to do it here
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1071263">toString</a> = <span title="String(&quot;B&quot;)" class="string">&quot;B&quot;</span><a href="../../../Tuple2.scala.html#62849" title="(x$1: Any)String">+</a><span class="delimiter">(</span><a href="#1071266" title="=&gt; PatternMatching.this.global.Tree">body</a>, <a href="#1071267" title="=&gt; PatternMatching.this.global.Type">matchPt</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    case <span class="keyword">class</span> <a title="class SubstOnlyTreeMaker extends TreeMakers.this.TreeMaker with Product with Serializable" id="1075358">SubstOnlyTreeMaker</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="PatternMatching.this.global.Symbol" id="1070955">prevBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Symbol" id="1070956">nextBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069034" title="TreeMakers.this.TreeMaker">TreeMaker</a> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="reflect.internal.util.NoPosition.type" id="1070947">pos</a> = <a href="../../../reflect/internal/Positions.scala.html#408302" title="=&gt; reflect.internal.util.NoPosition.type">NoPosition</a>

      <span class="keyword">val</span> <a title="TreeMakers.this.Substitution" id="1070949">localSubstitution</a> = <a href="#1073001" title="(from: PatternMatching.this.global.Symbol, to: PatternMatching.this.global.Tree)TreeMakers.this.Substitution">Substitution</a><span class="delimiter">(</span><a href="#1070955" title="=&gt; PatternMatching.this.global.Symbol">prevBinder</a>, <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1070956" title="=&gt; PatternMatching.this.global.Symbol">nextBinder</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(next: PatternMatching.this.global.Tree)(casegen: TreeMakers.this.Casegen)PatternMatching.this.global.Tree" id="1070951">chainBefore</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1073657">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="TreeMakers.this.Casegen" id="1073658">casegen</a>: <a href="#1069016" title="TreeMakers.this.Casegen">Casegen</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">substitution</a><span class="delimiter">(</span><a href="#1073657" title="PatternMatching.this.global.Tree">next</a><span class="delimiter">)</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1070952">toString</a> = <span title="String(&quot;S&quot;)" class="string">&quot;S&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1070949" title="=&gt; TreeMakers.this.Substitution">localSubstitution</a>
    <span class="delimiter">}</span>

    <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class FunTreeMaker extends TreeMakers.this.TreeMaker" id="1069045">FunTreeMaker</a> <a href="#1069045" title="TreeMakers.this.FunTreeMaker" class="keyword">extends</a> <a href="#1069034" title="TreeMakers.this.TreeMaker">TreeMaker</a> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="=&gt; PatternMatching.this.global.Symbol" id="1070666">nextBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Position" id="1070667">pos</a> = <a href="#1070666" title="=&gt; PatternMatching.this.global.Symbol">nextBinder</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#409602" title="=&gt; PatternMatching.this.global.Position">pos</a>
    <span class="delimiter">}</span>

    <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class CondTreeMaker extends TreeMakers.this.FunTreeMaker" id="1069046">CondTreeMaker</a> <a href="#1069046" title="TreeMakers.this.CondTreeMaker" class="keyword">extends</a> <a href="#1069045" title="TreeMakers.this.FunTreeMaker">FunTreeMaker</a> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="=&gt; PatternMatching.this.global.Symbol" id="1070669">prevBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>
      <span class="keyword">val</span> <a title="=&gt; PatternMatching.this.global.Type" id="1070670">nextBinderTp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>
      <span class="keyword">val</span> <a title="=&gt; PatternMatching.this.global.Tree" id="1070671">cond</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
      <span class="keyword">val</span> <a title="=&gt; PatternMatching.this.global.Tree" id="1070672">res</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>

      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.TermSymbol" id="1070674">nextBinder</a> = <a href="#1069013" title="(pos: PatternMatching.this.global.Position, tp: PatternMatching.this.global.Type, prefix: String)PatternMatching.this.global.TermSymbol">freshSym</a><span class="delimiter">(</span><a href="#1070667" title="=&gt; PatternMatching.this.global.Position">pos</a>, <a href="#1070670" title="=&gt; PatternMatching.this.global.Type">nextBinderTp</a><span class="delimiter">)</span>
      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="TreeMakers.this.Substitution" id="1070676">localSubstitution</a> = <a href="#1073002" title="(from: List[PatternMatching.this.global.Symbol], to: List[PatternMatching.this.global.Tree])TreeMakers.this.Substitution">Substitution</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Symbol*)List[PatternMatching.this.global.Symbol]">List</a><span class="delimiter">(</span><a href="#1070669" title="=&gt; PatternMatching.this.global.Symbol">prevBinder</a><span class="delimiter">)</span>, <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.gen.global.Tree*)List[PatternMatching.this.global.gen.global.Tree]">List</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1070673" title="=&gt; PatternMatching.this.global.TermSymbol">nextBinder</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="keyword">def</span> <a title="(next: PatternMatching.this.global.Tree)(casegen: TreeMakers.this.Casegen)PatternMatching.this.global.Tree" id="1070677">chainBefore</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1073725">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="TreeMakers.this.Casegen" id="1073726">casegen</a>: <a href="#1069016" title="TreeMakers.this.Casegen">Casegen</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> =
        <a href="../../../reflect/internal/Positions.scala.html#408315" title="(pos: PatternMatching.this.global.Position)(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">atPos</a><span class="delimiter">(</span><a href="#1070667" title="=&gt; PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1073726" title="TreeMakers.this.Casegen">casegen</a>.<a href="#1073529" title="(cond: PatternMatching.this.global.Tree, res: PatternMatching.this.global.Tree, nextBinder: PatternMatching.this.global.Symbol, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">flatMapCond</a><span class="delimiter">(</span><a href="#1070671" title="=&gt; PatternMatching.this.global.Tree">cond</a>, <a href="#1070672" title="=&gt; PatternMatching.this.global.Tree">res</a>, <a href="#1070673" title="=&gt; PatternMatching.this.global.TermSymbol">nextBinder</a>, <a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">substitution</a><span class="delimiter">(</span><a href="#1073725" title="PatternMatching.this.global.Tree">next</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // unless we're optimizing, emit local variable bindings for all subpatterns of extractor/case class patterns
    <span class="keyword">protected</span> <span class="keyword">val</span> <a title="Boolean" id="1069047">debugInfoEmitVars</a> = <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="../Global.scala.html#537448" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#540164" title="(=&gt; _792.s.type forSome { val _792: _3058.EnableSettings[_3058.BooleanSetting] }) forSome { val _3058: scala.tools.nsc.Settings }">optimise</a>.<a href="../settings/MutableSettings.scala.html#541066" title="=&gt; Boolean">value</a>

    <span class="keyword">trait</span> <a title="trait PreserveSubPatBinders extends TreeMakers.this.TreeMaker" id="1069049">PreserveSubPatBinders</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#1069034" title="TreeMakers.this.TreeMaker">TreeMaker</a> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="=&gt; List[PatternMatching.this.global.Symbol]" id="1072630">subPatBinders</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
      <span class="keyword">val</span> <a title="=&gt; List[PatternMatching.this.global.Tree]" id="1072631">subPatRefs</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

      // unless `debugInfoEmitVars`, this set should contain the bare minimum for correctness
      // mutable case class fields need to be stored regardless (SI-5158, SI-6070) -- see override in ProductExtractorTreeMaker
      <span class="keyword">def</span> <a title="=&gt; Set[PatternMatching.this.global.Symbol]" id="1072632">storedBinders</a>: <a href="../../../collection/immutable/Set.scala.html#11919" title="Set[PatternMatching.this.global.Symbol]">Set</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span title="scala.collection.immutable.Set[PatternMatching.this.global.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1069047" title="=&gt; Boolean">debugInfoEmitVars</a><span class="delimiter">)</span> <a href="#1072630" title="=&gt; List[PatternMatching.this.global.Symbol]">subPatBinders</a>.<a href="../../../collection/TraversableOnce.scala.html#58270" title="scala.collection.immutable.Set[PatternMatching.this.global.Symbol]">toSet</a> <span class="keyword">else</span> <a href="../../../Predef.scala.html#7446" title="=&gt; scala.collection.immutable.Set.type">Set</a>.<a href="../../../collection/immutable/Set.scala.html#60808" title="scala.collection.immutable.Set[PatternMatching.this.global.Symbol]">empty</a>

      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1072633">emitVars</a> = <a href="#1072632" title="=&gt; Set[PatternMatching.this.global.Symbol]">storedBinders</a>.<a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a>

      <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a href="#3368417" title="(Traversable[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)], Traversable[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" id="1072635" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="Traversable[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]" id="1072637">stored</a>, <a href="../../../Tuple2.scala.html#60637" title="Traversable[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]" id="1072639">substed</a><span class="delimiter">)</span> = <a href="../../../Predef.scala.html#7531" title="(x: (List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.Tree]))runtime.Tuple2Zipped.Ops[List[PatternMatching.this.global.Symbol],List[PatternMatching.this.global.Tree]]" class="delimiter">(</a><a href="#1072630" title="=&gt; List[PatternMatching.this.global.Symbol]">subPatBinders</a>, <a href="#1072631" title="=&gt; List[PatternMatching.this.global.Tree]">subPatRefs</a><span class="delimiter">)</span>.<a href="../../../runtime/Tuple2Zipped.scala.html#582927" title="(zz: scala.runtime.ZippedTraversable2[PatternMatching.this.global.Symbol,PatternMatching.this.global.Tree])Traversable[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">zipped</a>.<a href="../../../collection/TraversableLike.scala.html#58080" title="(p: ((PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)) =&gt; Boolean)(Traversable[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)], Traversable[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">partition</a><a href="#1073859" title="(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Symbol" id="1073862">sym</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="3368409">_</a><span class="delimiter">)</span> =&gt; <a href="../../../collection/GenSetLike.scala.html#66403" title="(elem: PatternMatching.this.global.Symbol)Boolean">storedBinders</a><a href="#3368411" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#1073862" title="PatternMatching.this.global.Symbol">sym</a><span class="delimiter">)</span> <span class="delimiter">}</span>

      <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="TreeMakers.this.Substitution" id="1072641">localSubstitution</a>: <a href="#1069026" title="TreeMakers.this.Substitution">Substitution</a> = <span title="TreeMakers.this.Substitution" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1072633" title="=&gt; Boolean">emitVars</a><span class="delimiter">)</span> <a href="#1073002" title="(from: List[PatternMatching.this.global.Symbol], to: List[PatternMatching.this.global.Tree])TreeMakers.this.Substitution">Substitution</a><span class="delimiter">(</span><a href="#1072630" title="=&gt; List[PatternMatching.this.global.Symbol]">subPatBinders</a>, <a href="#1072631" title="=&gt; List[PatternMatching.this.global.Tree]">subPatRefs</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a href="#3368423" title="(x: (Traversable[PatternMatching.this.global.Symbol], Traversable[PatternMatching.this.global.Tree]))(Traversable[PatternMatching.this.global.Symbol], Traversable[PatternMatching.this.global.Tree])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="Traversable[PatternMatching.this.global.Symbol]" id="1073900">subPatBindersSubstituted</a>, <a href="../../../Tuple2.scala.html#60637" title="Traversable[PatternMatching.this.global.Tree]" id="1073901">subPatRefsSubstituted</a><span class="delimiter">)</span> = <a href="#1072638" title="=&gt; Traversable[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">substed</a>.<a href="../../../collection/generic/GenericTraversableTemplate.scala.html#58476" title="(implicit asPair: ((PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)) =&gt; (PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree))(Traversable[PatternMatching.this.global.Symbol], Traversable[PatternMatching.this.global.Tree])">unzip</a>
          <a href="#1073002" title="(from: List[PatternMatching.this.global.Symbol], to: List[PatternMatching.this.global.Tree])TreeMakers.this.Substitution">Substitution</a><span class="delimiter">(</span><a href="#1073900" title="Traversable[PatternMatching.this.global.Symbol]">subPatBindersSubstituted</a>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[PatternMatching.this.global.Symbol]">toList</a>, <a href="#1073901" title="Traversable[PatternMatching.this.global.Tree]">subPatRefsSubstituted</a>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[PatternMatching.this.global.Tree]">toList</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

      /** The substitution that specifies the trees that compute the values of the subpattern binders.
       *
       * We pretend to replace the subpattern binders by subpattern refs
       * (Even though we don't do so anymore -- see SI-5158, SI-5739 and SI-6070.)
       */
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; TreeMakers.this.Substitution" id="1072642">subPatternsAsSubstitution</a> =
        <a href="#1073002" title="(from: List[PatternMatching.this.global.Symbol], to: List[PatternMatching.this.global.Tree])TreeMakers.this.Substitution">Substitution</a><span class="delimiter">(</span><a href="#1072630" title="=&gt; List[PatternMatching.this.global.Symbol]">subPatBinders</a>, <a href="#1072631" title="=&gt; List[PatternMatching.this.global.Tree]">subPatRefs</a><span class="delimiter">)</span> <a href="#1069978" title="(other: TreeMakers.this.Substitution)TreeMakers.this.Substitution">&gt;&gt;</a> <a href="#1069049" title="TreeMakers.this.PreserveSubPatBinders" class="keyword">super</a>.<a href="#1069813" title="=&gt; TreeMakers.this.Substitution">subPatternsAsSubstitution</a>

      <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._
      <span class="keyword">def</span> <a title="(in: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1072644">bindSubPats</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1073939">in</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span title="PatternMatching.this.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1072633" title="=&gt; Boolean">emitVars</a><span class="delimiter">)</span> <a href="#1073939" title="PatternMatching.this.global.Tree">in</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a href="#3368429" title="(x: (Traversable[PatternMatching.this.global.Symbol], Traversable[PatternMatching.this.global.Tree]))(Traversable[PatternMatching.this.global.Symbol], Traversable[PatternMatching.this.global.Tree])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="Traversable[PatternMatching.this.global.Symbol]" id="1073941">subPatBindersStored</a>, <a href="../../../Tuple2.scala.html#60637" title="Traversable[PatternMatching.this.global.Tree]" id="1073942">subPatRefsStored</a><span class="delimiter">)</span> = <a href="#1072636" title="=&gt; Traversable[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">stored</a>.<a href="../../../collection/generic/GenericTraversableTemplate.scala.html#58476" title="(implicit asPair: ((PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)) =&gt; (PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree))(Traversable[PatternMatching.this.global.Symbol], Traversable[PatternMatching.this.global.Tree])">unzip</a>
          <a href="../../../reflect/internal/Trees.scala.html#453067" title="(stats: List[PatternMatching.this.global.Tree], expr: PatternMatching.this.global.Tree)PatternMatching.this.global.Block">Block</a><span class="delimiter">(</span><a href="../../../reflect/internal/util/Collections.scala.html#406731" title="(xs1: List[PatternMatching.this.global.Symbol], xs2: List[PatternMatching.this.global.Tree])(f: (PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree) =&gt; PatternMatching.this.global.ValDef)List[PatternMatching.this.global.ValDef]">map2</a><span class="delimiter">(</span><a href="#1073941" title="Traversable[PatternMatching.this.global.Symbol]">subPatBindersStored</a>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[PatternMatching.this.global.Symbol]">toList</a>, <a href="#1073942" title="Traversable[PatternMatching.this.global.Tree]">subPatRefsStored</a>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[PatternMatching.this.global.Tree]">toList</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624596" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.CODE.ValSymStart">VAL</a><span class="delimiter">(</span><a href="#1073995" title="PatternMatching.this.global.Symbol">_</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#663071" title="(rhs: PatternMatching.this.global.Tree)PatternMatching.this.global.ValDef">===</a> <a href="#1073996" title="PatternMatching.this.global.Tree">_</a><span class="delimiter">)</span>, <a href="#1073939" title="PatternMatching.this.global.Tree">in</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /**
     * Make a TreeMaker that will result in an extractor call specified by `extractor`
     * the next TreeMaker (here, we don't know which it'll be) is chained after this one by flatMap'ing
     * a function with binder `nextBinder` over our extractor's result
     * the function's body is determined by the next TreeMaker
     * (furthermore, the interpretation of `flatMap` depends on the codegen instance we're using).
     *
     * The values for the subpatterns, as computed by the extractor call in `extractor`,
     * are stored in local variables that re-use the symbols in `subPatBinders`.
     * This makes extractor patterns more debuggable (SI-5739).
     */
    case <span class="keyword">class</span> <a title="class ExtractorTreeMaker extends TreeMakers.this.FunTreeMaker with TreeMakers.this.PreserveSubPatBinders with Product with Serializable" id="1075387">ExtractorTreeMaker</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1072856">extractor</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="Option[PatternMatching.this.global.Tree]" id="1072857">extraCond</a>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="PatternMatching.this.global.Symbol" id="1072858">nextBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span>
          <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1072859">subPatBinders</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
          <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Tree]" id="1072860">subPatRefs</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>,
          <a title="Boolean" id="1072861">extractorReturnsBoolean</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a>,
          <span class="keyword">val</span> <a title="Option[Int]" id="1072862">checkedLength</a>: <a href="../../../Option.scala.html#978" title="Option[Int]">Option</a><span class="delimiter">[</span>Int<span class="delimiter">]</span>,
          <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="1072863">prevBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069045" title="TreeMakers.this.FunTreeMaker">FunTreeMaker</a> <span class="keyword">with</span> <a href="#1069049" title="TreeMakers.this.PreserveSubPatBinders">PreserveSubPatBinders</a> <span class="delimiter">{</span>

      <span class="keyword">def</span> <a title="(next: PatternMatching.this.global.Tree)(casegen: TreeMakers.this.Casegen)PatternMatching.this.global.Tree" id="1072852">chainBefore</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074038">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="TreeMakers.this.Casegen" id="1074039">casegen</a>: <a href="#1069016" title="TreeMakers.this.Casegen">Casegen</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1074041">condAndNext</a> = <a href="#1072857" title="=&gt; Option[PatternMatching.this.global.Tree]">extraCond</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Some<a href="#3368433" title="PatternMatching.this.global.Tree" id="3368434" class="delimiter">(</a><a href="../../../Option.scala.html#63132" title="PatternMatching.this.global.Tree" id="1074043">cond</a><span class="delimiter">)</span> =&gt;
            <a href="#1074039" title="TreeMakers.this.Casegen">casegen</a>.<a href="#1073531" title="(c: PatternMatching.this.global.Tree, then: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">ifThenElseZero</a><a href="#3368436" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">substitution</a><span class="delimiter">(</span><a href="#1074043" title="PatternMatching.this.global.Tree">cond</a><span class="delimiter">)</span>, <a href="#1072644" title="(in: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">bindSubPats</a><span class="delimiter">(</span><a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">substitution</a><span class="delimiter">(</span><a href="#1074038" title="PatternMatching.this.global.Tree">next</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
            <a href="#1072644" title="(in: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">bindSubPats</a><a href="#3368436" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">substitution</a><span class="delimiter">(</span><a href="#1074038" title="PatternMatching.this.global.Tree">next</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="../../../reflect/internal/Positions.scala.html#408315" title="(pos: PatternMatching.this.global.Position)(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">atPos</a><span class="delimiter">(</span><a href="#1072856" title="=&gt; PatternMatching.this.global.Tree">extractor</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">(</span>
          <span title="PatternMatching.this.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#1072861" title="Boolean">extractorReturnsBoolean</a><span class="delimiter">)</span> <a href="#1074039" title="TreeMakers.this.Casegen">casegen</a>.<a href="#1073529" title="(cond: PatternMatching.this.global.Tree, res: PatternMatching.this.global.Tree, nextBinder: PatternMatching.this.global.Symbol, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">flatMapCond</a><span class="delimiter">(</span><a href="#1072856" title="=&gt; PatternMatching.this.global.Tree">extractor</a>, <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624561" title="=&gt; PatternMatching.this.global.Literal">UNIT</a>, <a href="#1072858" title="=&gt; PatternMatching.this.global.Symbol">nextBinder</a>, <a href="#1074041" title="PatternMatching.this.global.Tree">condAndNext</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#1074039" title="TreeMakers.this.Casegen">casegen</a>.<a href="#1073528" title="(prev: PatternMatching.this.global.Tree, b: PatternMatching.this.global.Symbol, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">flatMap</a><span class="delimiter">(</span><a href="#1072856" title="=&gt; PatternMatching.this.global.Tree">extractor</a>, <a href="#1072858" title="=&gt; PatternMatching.this.global.Symbol">nextBinder</a>, <a href="#1074041" title="PatternMatching.this.global.Tree">condAndNext</a><span class="delimiter">)</span>
        <span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1072853">toString</a> = <span title="String(&quot;X&quot;)" class="string">&quot;X&quot;</span><a href="../../../Tuple2.scala.html#62849" title="(x$1: Any)String">+</a><span class="delimiter">(</span><a href="#1072856" title="=&gt; PatternMatching.this.global.Tree">extractor</a>, <a href="#1072858" title="=&gt; PatternMatching.this.global.Symbol">nextBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; ExtractorTreeMaker.this.nextBinder.NameType">name</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /**
     * An optimized version of ExtractorTreeMaker for Products.
     * For now, this is hard-coded to case classes, and we simply extract the case class fields.
     *
     * The values for the subpatterns, as specified by the case class fields at the time of extraction,
     * are stored in local variables that re-use the symbols in `subPatBinders`.
     * This makes extractor patterns more debuggable (SI-5739) as well as
     * avoiding mutation after the pattern has been matched (SI-5158, SI-6070)
     *
     * TODO: make this user-definable as follows
     *   When a companion object defines a method `def unapply_1(x: T): U_1`, but no `def unapply` or `def unapplySeq`,
     *   the extractor is considered to match any non-null value of type T
     *   the pattern is expected to have as many sub-patterns as there are `def unapply_I(x: T): U_I` methods,
     *   and the type of the I'th sub-pattern is `U_I`.
     *   The same exception for Seq patterns applies: if the last extractor is of type `Seq[U_N]`,
     *   the pattern must have at least N arguments (exactly N if the last argument is annotated with `: _*`).
     *   The arguments starting at N (and beyond) are taken from the sequence returned by apply_N,
     *   and it is checked that that sequence has enough elements to provide values for all expected sub-patterns.
     *
     *   For a case class C, the implementation is assumed to be `def unapply_I(x: C) = x._I`,
     *   and the extractor call is inlined under that assumption.
     */
    case <span class="keyword">class</span> <a title="class ProductExtractorTreeMaker extends TreeMakers.this.FunTreeMaker with TreeMakers.this.PreserveSubPatBinders with Product with Serializable" id="1075413">ProductExtractorTreeMaker</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="PatternMatching.this.global.Symbol" id="1072647">prevBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="Option[PatternMatching.this.global.Tree]" id="1072648">extraCond</a>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>
          <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1072649">subPatBinders</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
          <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Tree]" id="1072650">subPatRefs</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>,
          <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1072651">mutableBinders</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069045" title="TreeMakers.this.FunTreeMaker">FunTreeMaker</a> <span class="keyword">with</span> <a href="#1069049" title="TreeMakers.this.PreserveSubPatBinders">PreserveSubPatBinders</a> <span class="delimiter">{</span>

      <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._
      <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="1072624">nextBinder</a> = <a href="#1072647" title="=&gt; PatternMatching.this.global.Symbol">prevBinder</a> // just passing through

      // mutable binders must be stored to avoid unsoundness or seeing mutation of fields after matching (SI-5158, SI-6070)
      // (the implementation could be optimized by duplicating code from `super.storedBinders`, but this seems more elegant)
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Set[PatternMatching.this.global.Symbol]" id="1072626">storedBinders</a>: <a href="../../../collection/immutable/Set.scala.html#11919" title="Set[PatternMatching.this.global.Symbol]">Set</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#1075413" title="TreeMakers.this.ProductExtractorTreeMaker" class="keyword">super</a>.<a href="#1072632" title="=&gt; Set[PatternMatching.this.global.Symbol]">storedBinders</a> <a href="../../../collection/SetLike.scala.html#66445" title="(elems: scala.collection.GenTraversableOnce[PatternMatching.this.global.Symbol])scala.collection.immutable.Set[PatternMatching.this.global.Symbol]">++</a> <a href="#1072651" title="=&gt; List[PatternMatching.this.global.Symbol]">mutableBinders</a>.<a href="../../../collection/TraversableOnce.scala.html#58270" title="scala.collection.immutable.Set[PatternMatching.this.global.Symbol]">toSet</a>

      <span class="keyword">def</span> <a title="(next: PatternMatching.this.global.Tree)(casegen: TreeMakers.this.Casegen)PatternMatching.this.global.Tree" id="1072627">chainBefore</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074189">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="TreeMakers.this.Casegen" id="1074190">casegen</a>: <a href="#1069016" title="TreeMakers.this.Casegen">Casegen</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="PatternMatching.this.global.Apply" id="1074192">nullCheck</a> = <a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods" class="delimiter">(</a><a href="#1072647" title="=&gt; PatternMatching.this.global.Symbol">prevBinder</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#662324" title="(other: PatternMatching.this.global.Tree)PatternMatching.this.global.Apply">OBJ_NE</a> <a href="../ast/TreeDSL.scala.html#624560" title="=&gt; PatternMatching.this.global.Literal">NULL</a>
        <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1074193">cond</a> = <a href="#1072648" title="=&gt; Option[PatternMatching.this.global.Tree]">extraCond</a> <a href="../../../Option.scala.html#62865" title="(f: PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree)Option[PatternMatching.this.global.Tree]">map</a> <span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods">nullCheck</a> <a href="../ast/TreeDSL.scala.html#662316" title="(other: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">AND</a> <a href="#1074205" title="PatternMatching.this.global.Tree">_</a><span class="delimiter">)</span> <a href="../../../Option.scala.html#62859" title="(default: =&gt; PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">getOrElse</a> <a href="#1074192" title="PatternMatching.this.global.Apply">nullCheck</a>
        <a href="#1074190" title="TreeMakers.this.Casegen">casegen</a>.<a href="#1073531" title="(c: PatternMatching.this.global.Tree, then: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">ifThenElseZero</a><span class="delimiter">(</span><a href="#1074193" title="PatternMatching.this.global.Tree">cond</a>, <a href="#1072644" title="(in: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">bindSubPats</a><span class="delimiter">(</span><a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">substitution</a><span class="delimiter">(</span><a href="#1074189" title="PatternMatching.this.global.Tree">next</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1072628">toString</a> = <span title="String(&quot;P&quot;)" class="string">&quot;P&quot;</span><a href="../../../Tuple3.scala.html#63169" title="(x$1: Any)String">+</a><span class="delimiter">(</span><a href="#1072647" title="=&gt; PatternMatching.this.global.Symbol">prevBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; ProductExtractorTreeMaker.this.prevBinder.NameType">name</a>,  <a href="#1072648" title="=&gt; Option[PatternMatching.this.global.Tree]">extraCond</a> <a href="../../../Option.scala.html#62859" title="(default: =&gt; Object)Object">getOrElse</a> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <a href="#1072640" title="=&gt; TreeMakers.this.Substitution">localSubstitution</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // typetag-based tests are inserted by the type checker
    <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type, pt: PatternMatching.this.global.Type)Boolean" id="1069056">needsTypeTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1070653">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <a title="PatternMatching.this.global.Type" id="1070654">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#1070653" title="PatternMatching.this.global.Type">tp</a> <a href="../../../reflect/internal/Types.scala.html#408481" title="(that: PatternMatching.this.global.Type)Boolean">&lt;:&lt;</a> <a href="#1070654" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span>

    <span class="keyword">object</span> <a title="TreeMakers.this.TypeTestTreeMaker.type" id="1074488">TypeTestTreeMaker</a> <a href="#1069058" title="TreeMakers.this.TypeTestTreeMaker.type" class="delimiter">{</a>
      // factored out so that we can consistently generate other representations of the tree that implements the test
      // (e.g. propositions for exhaustivity and friends, boolean for isPureTypeTest)
      <span class="keyword">trait</span> <a title="trait TypeTestCondStrategy extends Object" id="1070659">TypeTestCondStrategy</a> <span class="delimiter">{</span>
        <span class="keyword">type</span> <a title="" id="1074293">Result</a>

        <span class="keyword">def</span> <a title="(testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type)TypeTestCondStrategy.this.Result" id="1074294">outerTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1074301">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1074302">expectedTp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="#1074293" title="TypeTestCondStrategy.this.Result">Result</a>
        // TODO: can probably always widen
        <span class="keyword">def</span> <a title="(testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type)TypeTestCondStrategy.this.Result" id="1074295">typeTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1074303">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1074304">expectedTp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="#1074293" title="TypeTestCondStrategy.this.Result">Result</a>
        <span class="keyword">def</span> <a title="(testedBinder: PatternMatching.this.global.Symbol)TypeTestCondStrategy.this.Result" id="1074296">nonNullTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1074305">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#1074293" title="TypeTestCondStrategy.this.Result">Result</a>
        <span class="keyword">def</span> <a title="(pat: PatternMatching.this.global.Tree, testedBinder: PatternMatching.this.global.Symbol)TypeTestCondStrategy.this.Result" id="1074297">equalsTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074306">pat</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1074307">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#1074293" title="TypeTestCondStrategy.this.Result">Result</a>
        <span class="keyword">def</span> <a title="(pat: PatternMatching.this.global.Tree, testedBinder: PatternMatching.this.global.Symbol)TypeTestCondStrategy.this.Result" id="1074298">eqTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074308">pat</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1074309">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#1074293" title="TypeTestCondStrategy.this.Result">Result</a>
        <span class="keyword">def</span> <a title="(a: TypeTestCondStrategy.this.Result, b: TypeTestCondStrategy.this.Result)TypeTestCondStrategy.this.Result" id="1074299">and</a><span class="delimiter">(</span><a title="TypeTestCondStrategy.this.Result" id="1074310">a</a>: <a href="#1074293" title="TypeTestCondStrategy.this.Result">Result</a>, <a title="TypeTestCondStrategy.this.Result" id="1074311">b</a>: <a href="#1074293" title="TypeTestCondStrategy.this.Result">Result</a><span class="delimiter">)</span>: <a href="#1074293" title="TypeTestCondStrategy.this.Result">Result</a>
      <span class="delimiter">}</span>

      <span class="keyword">object</span> <a title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.treeCondStrategy.type" id="1070660">treeCondStrategy</a> <a href="#1070661" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.treeCondStrategy.type" class="keyword">extends</a> <a href="#1070659" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.TypeTestCondStrategy">TypeTestCondStrategy</a> <span class="delimiter">{</span> <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._
        <span class="keyword">type</span> <a title="PatternMatching.this.global.Tree" id="1074314">Result</a> = <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>

        <span class="keyword">def</span> <a title="(a: scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.treeCondStrategy.Result, b: scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.treeCondStrategy.Result)scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.treeCondStrategy.Result" id="1074315">and</a><span class="delimiter">(</span><a title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.treeCondStrategy.Result" id="1074322">a</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.treeCondStrategy.Result">Result</a>, <a title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.treeCondStrategy.Result" id="1074323">b</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.treeCondStrategy.Result">Result</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.treeCondStrategy.Result">Result</a>                = <a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods">a</a> <a href="../ast/TreeDSL.scala.html#662316" title="(other: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">AND</a> <a href="#1074323" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.treeCondStrategy.Result">b</a>
        <span class="keyword">def</span> <a title="(testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree" id="1074316">typeTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1074331">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1074332">expectedTp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> = <a href="#1069017" title="=&gt; TreeMakers.this.AbsCodegen">codegen</a>.<a href="#1071810" title="(b: PatternMatching.this.global.Symbol, tp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree">_isInstanceOf</a><span class="delimiter">(</span><a href="#1074331" title="PatternMatching.this.global.Symbol">testedBinder</a>, <a href="#1074332" title="PatternMatching.this.global.Type">expectedTp</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="(testedBinder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Apply" id="1074317">nonNullTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1074337">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>                = <a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods" class="delimiter">(</a><a href="#1074337" title="PatternMatching.this.global.Symbol">testedBinder</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#662324" title="(other: PatternMatching.this.global.Tree)PatternMatching.this.global.Apply">OBJ_NE</a> <a href="../ast/TreeDSL.scala.html#624560" title="=&gt; PatternMatching.this.global.Literal">NULL</a>
        <span class="keyword">def</span> <a title="(pat: PatternMatching.this.global.Tree, testedBinder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree" id="1074318">equalsTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074346">pat</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1074347">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>      = <a href="#1069017" title="=&gt; TreeMakers.this.AbsCodegen">codegen</a>.<a href="#1071809" title="(checker: PatternMatching.this.global.Tree, binder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">_equals</a><span class="delimiter">(</span><a href="#1074346" title="PatternMatching.this.global.Tree">pat</a>, <a href="#1074347" title="PatternMatching.this.global.Symbol">testedBinder</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="(pat: PatternMatching.this.global.Tree, testedBinder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Apply" id="1074319">eqTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074352">pat</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1074353">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>          = <a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods" class="delimiter">(</a><a href="#1074353" title="PatternMatching.this.global.Symbol">testedBinder</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#662323" title="(other: PatternMatching.this.global.Tree)PatternMatching.this.global.Apply">OBJ_EQ</a> <a href="#1074352" title="PatternMatching.this.global.Tree">pat</a>

        <span class="keyword">def</span> <a title="(testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree" id="1074320">outerTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1074363">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1074364">expectedTp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="PatternMatching.this.global.gen.global.Tree" id="1074366">expectedOuter</a> = <a href="#1074364" title="PatternMatching.this.global.Type">expectedTp</a>.<a href="../../../reflect/internal/Types.scala.html#408418" title="=&gt; PatternMatching.this.global.Type">prefix</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> ThisType<a href="#3368483" title="PatternMatching.this.global.gen.global.Tree" id="3368485" class="delimiter">(</a><a href="../../../reflect/internal/Types.scala.html#411018" title="PatternMatching.this.global.Symbol" id="1074369">clazz</a><span class="delimiter">)</span>      =&gt; <a href="../ast/TreeDSL.scala.html#624610" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">THIS</a><a href="#3368487" title="(x: PatternMatching.this.global.gen.global.Tree)PatternMatching.this.global.gen.global.Tree" class="delimiter">(</a><a href="#1074369" title="PatternMatching.this.global.Symbol">clazz</a><span class="delimiter">)</span>
            <span class="keyword">case</span> pre <span class="keyword">if</span> pre <span title="(x$1: AnyRef)Boolean">!=</span> <a href="../../../reflect/internal/Types.scala.html#407284" title="PatternMatching.this.global.NoType.type">NoType</a> =&gt; <a href="../ast/TreeDSL.scala.html#624613" title="(pre: PatternMatching.this.global.Type, sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><a href="#3368487" title="(x: PatternMatching.this.global.gen.global.Tree)PatternMatching.this.global.gen.global.Tree" class="delimiter">(</a>pre.<a href="../../../reflect/internal/Types.scala.html#408418" title="=&gt; PatternMatching.this.global.Type">prefix</a>, pre.<a href="../../../reflect/internal/Types.scala.html#408406" title="=&gt; PatternMatching.this.global.Symbol">termSymbol</a><span class="delimiter">)</span>
            <span class="keyword">case</span> _ =&gt; <a href="#3368487" title="(x: PatternMatching.this.global.gen.global.Tree)PatternMatching.this.global.gen.global.Tree">TRUE_typed</a> // fallback for SI-6183
          <span class="delimiter">}</span>

          // ExplicitOuter replaces `Select(q, outerSym) OBJ_EQ expectedPrefix` by `Select(q, outerAccessor(outerSym.owner)) OBJ_EQ expectedPrefix`
          // if there's an outer accessor, otherwise the condition becomes `true` -- TODO: can we improve needsOuterTest so there's always an outerAccessor?
          <span class="keyword">val</span> <a title="PatternMatching.this.global.MethodSymbol" id="1074367">outer</a> = <a href="#1074364" title="PatternMatching.this.global.Type">expectedTp</a>.<a href="../../../reflect/internal/Types.scala.html#408407" title="PatternMatching.this.global.Symbol" id="1074385">typeSymbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#420460" title="PatternMatching.this.global.Position" id="1074391">newMethod</a><span class="delimiter">(</span><a href="#621381" title="PatternMatching.this.vpmName.type">vpmName</a>.<a href="#1069377" title="PatternMatching.this.global.TermName" id="1074389">outer</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Symbols.scala.html#411369" title="(info: PatternMatching.this.global.Type)PatternMatching.this.global.MethodSymbol">setInfo</a> <a href="#1074364" title="PatternMatching.this.global.Type">expectedTp</a>.<a href="../../../reflect/internal/Types.scala.html#408418" title="=&gt; PatternMatching.this.global.Type">prefix</a> <a href="../../../reflect/internal/Symbols.scala.html#411236" title="(mask: Long)PatternMatching.this.global.MethodSymbol">setFlag</a> SYNTHETIC <span title="Long(70368746274816L)">|</span> ARTIFACT

          <span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#408125" title="(qualifier: PatternMatching.this.global.Tree, sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.Select">Select</a><a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods" class="delimiter">(</a><a href="#1069017" title="=&gt; TreeMakers.this.AbsCodegen">codegen</a>.<a href="#1071807" title="(b: PatternMatching.this.global.Symbol, tp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree">_asInstanceOf</a><span class="delimiter">(</span><a href="#1074363" title="PatternMatching.this.global.Symbol">testedBinder</a>, <a href="#1074364" title="PatternMatching.this.global.Type">expectedTp</a><span class="delimiter">)</span>, <a href="#1074367" title="PatternMatching.this.global.MethodSymbol">outer</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#662323" title="(other: PatternMatching.this.global.Tree)PatternMatching.this.global.Apply">OBJ_EQ</a> <a href="#1074366" title="PatternMatching.this.global.gen.global.Tree">expectedOuter</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span class="keyword">object</span> <a title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.type" id="1070662">pureTypeTestChecker</a> <a href="#1070663" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.type" class="keyword">extends</a> <a href="#1070659" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.TypeTestCondStrategy">TypeTestCondStrategy</a> <span class="delimiter">{</span>
        <span class="keyword">type</span> <a title="Boolean" id="1074428">Result</a> = <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

        <span class="keyword">def</span> <a title="(testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type)scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result" id="1074429">typeTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1074436">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1074437">expectedTp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result">Result</a>  = <span title="Boolean(true)" class="keyword">true</span>

        <span class="keyword">def</span> <a title="(testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type)scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result" id="1074430">outerTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1074439">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1074440">expectedTp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result">Result</a> = <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">def</span> <a title="(testedBinder: PatternMatching.this.global.Symbol)scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result" id="1074431">nonNullTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1074442">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result">Result</a>                 = <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">def</span> <a title="(pat: PatternMatching.this.global.Tree, testedBinder: PatternMatching.this.global.Symbol)scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result" id="1074432">equalsTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074444">pat</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1074445">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result">Result</a>       = <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">def</span> <a title="(pat: PatternMatching.this.global.Tree, testedBinder: PatternMatching.this.global.Symbol)scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result" id="1074433">eqTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074447">pat</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1074448">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result">Result</a>           = <span title="Boolean(false)" class="keyword">false</span>
        <span class="keyword">def</span> <a title="(a: scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result, b: scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result)scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result" id="1074434">and</a><span class="delimiter">(</span><a title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result" id="1074450">a</a>: <a href="../../../Boolean.scala.html#1425" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result">Result</a>, <a title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result" id="1074451">b</a>: <a href="../../../Boolean.scala.html#1425" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result">Result</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakers.TypeTestTreeMaker.pureTypeTestChecker.Result">Result</a>                         = <span title="Boolean(false)" class="keyword">false</span> // we don't and type tests, so the conjunction must include at least one false
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    /** implements the run-time aspects of (8.2) (typedPattern has already done the necessary type transformations)
     *
     * Type patterns consist of types, type variables, and wildcards. A type pattern T is of one of the following forms:
        - A reference to a class C, p.C, or T#C.
          This type pattern matches any non-null instance of the given class.
          Note that the prefix of the class, if it is given, is relevant for determining class instances.
          For instance, the pattern p.C matches only instances of classes C which were created with the path p as prefix.
          The bottom types scala.Nothing and scala.Null cannot be used as type patterns, because they would match nothing in any case.

        - A singleton type p.type.
          This type pattern matches only the value denoted by the path p
          (that is, a pattern match involved a comparison of the matched value with p using method eq in class AnyRef). // TODO: the actual pattern matcher uses ==, so that's what I'm using for now
          // https://issues.scala-lang.org/browse/SI-4577 &quot;pattern matcher, still disappointing us at equality time&quot;

        - A compound type pattern T1 with ... with Tn where each Ti is a type pat- tern.
          This type pattern matches all values that are matched by each of the type patterns Ti.

        - A parameterized type pattern T[a1,...,an], where the ai are type variable patterns or wildcards _.
          This type pattern matches all values which match T for some arbitrary instantiation of the type variables and wildcards.
          The bounds or alias type of these type variable are determined as described in (8.3).

        - A parameterized type pattern scala.Array[T1], where T1 is a type pattern. // TODO
          This type pattern matches any non-null instance of type scala.Array[U1], where U1 is a type matched by T1.
    **/
    case <span class="keyword">class</span> <a title="(prevBinder: PatternMatching.this.global.Symbol, testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type, nextBinderTp: PatternMatching.this.global.Type)(pos: PatternMatching.this.global.Position, extractorArgTypeTest: Boolean)TreeMakers.this.TypeTestTreeMaker" id="1074623">TypeTestTreeMaker</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="PatternMatching.this.global.Symbol" id="1074597">prevBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Symbol" id="1074598">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1074599">expectedTp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <a title="PatternMatching.this.global.Type" id="1074600">nextBinderTp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">override</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.Position" id="1074593">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#22953" title="PatternMatching.this.global.Position">Position</a>, <a title="Boolean" id="1074594">extractorArgTypeTest</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069046" title="TreeMakers.this.CondTreeMaker">CondTreeMaker</a> <span class="delimiter">{</span>
      <span class="keyword">import</span> <a href="#1074488" title="TreeMakers.this.TypeTestTreeMaker.type">TypeTestTreeMaker</a>._
      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;TTTM&quot;)" class="string">&quot;TTTM&quot;</span><a href="../../../Tuple5.scala.html#62980" title="(x$1: Any)String">+</a><span class="delimiter">(</span><a href="#1074597" title="=&gt; PatternMatching.this.global.Symbol">prevBinder</a>, <a href="#1074594" title="Boolean">extractorArgTypeTest</a>, <a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a>, <a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a>, <a href="#1074600" title="=&gt; PatternMatching.this.global.Type">nextBinderTp</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="1070698">outerTestNeeded</a> = <span class="delimiter">(</span>
          <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a>.<a href="../../../reflect/internal/Types.scala.html#408418" title="=&gt; PatternMatching.this.global.Type">prefix</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="../../../reflect/internal/Types.scala.html#407286" title="PatternMatching.this.global.NoPrefix.type">NoPrefix</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a>.<a href="../../../reflect/internal/Types.scala.html#408418" title="=&gt; PatternMatching.this.global.Type">prefix</a>.<a href="../../../reflect/internal/Types.scala.html#408407" title="=&gt; PatternMatching.this.global.Symbol">typeSymbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411219" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span>
        <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../reflect/internal/Types.scala.html#407522" title="(patType: PatternMatching.this.global.Type, selType: PatternMatching.this.global.Type, currentOwner: PatternMatching.this.global.Symbol)Boolean">needsOuterTest</a><span class="delimiter">(</span><a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a>, <a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411367" title="=&gt; PatternMatching.this.global.Type">info</a>, <a href="#1068980" title="=&gt; PatternMatching.this.global.analyzer.global.Symbol">matchOwner</a><span class="delimiter">)</span><span class="delimiter">)</span>

      // the logic to generate the run-time test that follows from the fact that
      // a `prevBinder` is expected to have type `expectedTp`
      // the actual tree-generation logic is factored out, since the analyses generate Cond(ition)s rather than Trees
      // TODO: `null match { x : T }` will yield a check that (indirectly) tests whether `null ne null`
      // don't bother (so that we don't end up with the warning &quot;comparing values of types Null and Null using `ne' will always yield false&quot;)
      <span class="keyword">def</span> <a title="(cs: TreeMakers.this.TypeTestTreeMaker.TypeTestCondStrategy)cs.Result" id="1070699">renderCondition</a><span class="delimiter">(</span><a title="TreeMakers.this.TypeTestTreeMaker.TypeTestCondStrategy" id="1074496">cs</a>: <a href="#1070659" title="TreeMakers.this.TypeTestTreeMaker.TypeTestCondStrategy">TypeTestCondStrategy</a><span class="delimiter">)</span>: cs.<a href="#1074293" title="cs.Result">Result</a> = <span class="delimiter">{</span>
        <span class="keyword">import</span> <a href="#1074496" title="TreeMakers.this.TypeTestTreeMaker.TypeTestCondStrategy">cs</a>._

        <span class="keyword">def</span> <a title="=&gt; cs.Result" id="1074523">default</a> =
          // do type test first to ensure we won't select outer on null
          <span title="cs.Result" class="keyword">if</span> <span class="delimiter">(</span><a href="#1070697" title="=&gt; Boolean">outerTestNeeded</a><span class="delimiter">)</span> <a href="#1074299" title="(a: cs.Result, b: cs.Result)cs.Result">and</a><span class="delimiter">(</span><a href="#1074295" title="(testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type)cs.Result">typeTest</a><span class="delimiter">(</span><a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a>, <a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a><span class="delimiter">)</span>, <a href="#1074294" title="(testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type)cs.Result">outerTest</a><span class="delimiter">(</span><a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a>, <a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#1074295" title="(testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type)cs.Result">typeTest</a><span class="delimiter">(</span><a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a>, <a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a><span class="delimiter">)</span>

        // propagate expected type
        <span class="keyword">def</span> <a title="(t: PatternMatching.this.global.Tree)t.type" id="1074524">expTp</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074527">t</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: t.<span class="keyword">type</span> = <a href="#1074527" title="PatternMatching.this.global.Tree">t</a> <a href="../../../reflect/internal/Trees.scala.html#408575" title="(tp: PatternMatching.this.global.Type)t.type">setType</a> <a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a>

        // true when called to type-test the argument to an extractor
        // don't do any fancy equality checking, just test the type
        <span title="cs.Result" class="keyword">if</span> <span class="delimiter">(</span><a href="#1074594" title="Boolean">extractorArgTypeTest</a><span class="delimiter">)</span> <a href="#1074523" title="=&gt; cs.Result">default</a>
        <span class="keyword">else</span> <a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          // TODO: [SPEC] the spec requires `eq` instead of `==` for singleton types
          // this implies sym.isStable
          <span class="keyword">case</span> SingleType<a href="#3368493" title="cs.Result" id="3368496" class="delimiter">(</a><a href="../../../reflect/internal/Types.scala.html#410991" title="PatternMatching.this.global.Type" id="3368494">_</a>, <a href="../../../reflect/internal/Types.scala.html#410993" title="PatternMatching.this.global.Symbol" id="1074532">sym</a><span class="delimiter">)</span>                       =&gt; <a href="#1074299" title="(a: cs.Result, b: cs.Result)cs.Result">and</a><a href="#3368513" title="(x: cs.Result)cs.Result" class="delimiter">(</a><a href="#1074297" title="(pat: PatternMatching.this.global.Tree, testedBinder: PatternMatching.this.global.Symbol)cs.Result">equalsTest</a><span class="delimiter">(</span><a href="../Global.scala.html#537460" title="PatternMatching.this.global.gen.type">gen</a>.<a href="../../../reflect/internal/TreeGen.scala.html#470985" title="(tpe: PatternMatching.this.global.gen.global.Type)PatternMatching.this.global.gen.global.Tree">mkAttributedQualifier</a><span class="delimiter">(</span><a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a><span class="delimiter">)</span>, <a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a><span class="delimiter">)</span>, <a href="#1074295" title="(testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type)cs.Result">typeTest</a><span class="delimiter">(</span><a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a>, <a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a>.<a href="../../../reflect/internal/Types.scala.html#408411" title="=&gt; PatternMatching.this.global.Type">widen</a><span class="delimiter">)</span><span class="delimiter">)</span>
          // must use == to support e.g. List() == Nil
          <span class="keyword">case</span> ThisType<a href="#3368493" title="Boolean" id="3368498" class="delimiter">(</a><a href="../../../reflect/internal/Types.scala.html#411018" title="PatternMatching.this.global.Symbol" id="1074545">sym</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#1074545" title="PatternMatching.this.global.Symbol">sym</a>.<a href="../../../reflect/api/Symbols.scala.html#402401" title="=&gt; Boolean">isModule</a>            =&gt; <a href="#1074299" title="(a: cs.Result, b: cs.Result)cs.Result">and</a><a href="#3368513" title="(x: cs.Result)cs.Result" class="delimiter">(</a><a href="#1074297" title="(pat: PatternMatching.this.global.Tree, testedBinder: PatternMatching.this.global.Symbol)cs.Result">equalsTest</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1074545" title="PatternMatching.this.global.Symbol">sym</a><span class="delimiter">)</span>, <a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a><span class="delimiter">)</span>, <a href="#1074295" title="(testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type)cs.Result">typeTest</a><span class="delimiter">(</span><a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a>, <a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a>.<a href="../../../reflect/internal/Types.scala.html#408411" title="=&gt; PatternMatching.this.global.Type">widen</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> ConstantType<a href="#3368493" title="Boolean" id="3368501" class="delimiter">(</a>Constant<a href="../../../reflect/internal/Types.scala.html#410960" title="PatternMatching.this.global.Constant" id="3368499" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#409760" title="Any" id="3368509" class="keyword">null</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411367" title="=&gt; PatternMatching.this.global.Type">info</a>.<a href="../../../reflect/internal/Types.scala.html#408411" title="=&gt; PatternMatching.this.global.Type">widen</a> <a href="../../../reflect/internal/Types.scala.html#408481" title="(that: PatternMatching.this.global.Type)Boolean">&lt;:&lt;</a> <a href="../../../reflect/internal/Definitions.scala.html#408669" title="=&gt; PatternMatching.this.global.AliasTypeSymbol">AnyRefClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a>
                                                        =&gt; <a href="#1074298" title="(pat: PatternMatching.this.global.Tree, testedBinder: PatternMatching.this.global.Symbol)cs.Result">eqTest</a><a href="#3368513" title="(x: cs.Result)cs.Result" class="delimiter">(</a><a href="#1074524" title="(t: PatternMatching.this.global.Tree)t.type">expTp</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624560" title="=&gt; PatternMatching.this.global.Literal">NULL</a><span class="delimiter">)</span>, <a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a><span class="delimiter">)</span>
          <span class="keyword">case</span> ConstantType<span class="delimiter">(</span><a href="../../../reflect/internal/Types.scala.html#410960" title="PatternMatching.this.global.Constant" id="1074555">const</a><span class="delimiter">)</span>                      =&gt; <a href="#1074297" title="(pat: PatternMatching.this.global.Tree, testedBinder: PatternMatching.this.global.Symbol)cs.Result">equalsTest</a><a href="#3368513" title="(x: cs.Result)cs.Result" class="delimiter">(</a><a href="#1074524" title="(t: PatternMatching.this.global.Tree)t.type">expTp</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#413609" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.Literal">Literal</a><span class="delimiter">(</span><a href="#1074555" title="PatternMatching.this.global.Constant">const</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a><span class="delimiter">)</span>
          <span class="keyword">case</span> ThisType<span class="delimiter">(</span><a href="../../../reflect/internal/Types.scala.html#411018" title="PatternMatching.this.global.Symbol" id="1074559">sym</a><span class="delimiter">)</span>                            =&gt; <a href="#1074298" title="(pat: PatternMatching.this.global.Tree, testedBinder: PatternMatching.this.global.Symbol)cs.Result">eqTest</a><a href="#3368513" title="(x: cs.Result)cs.Result" class="delimiter">(</a><a href="#1074524" title="(t: PatternMatching.this.global.Tree)t.type">expTp</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#408123" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">This</a><span class="delimiter">(</span><a href="#1074559" title="PatternMatching.this.global.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a><span class="delimiter">)</span>

          // TODO: verify that we don't need to special-case Array
          // I think it's okay:
          //  - the isInstanceOf test includes a test for the element type
          //  - Scala's arrays are invariant (so we don't drop type tests unsoundly)
          <span class="keyword">case</span> _ <span class="keyword">if</span> <span class="delimiter">(</span><a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a> <a href="../../../reflect/internal/Types.scala.html#408481" title="(that: PatternMatching.this.global.Type)Boolean">&lt;:&lt;</a> <a href="../../../reflect/internal/Definitions.scala.html#408669" title="=&gt; PatternMatching.this.global.AliasTypeSymbol">AnyRefClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1069056" title="(tp: PatternMatching.this.global.Type, pt: PatternMatching.this.global.Type)Boolean">needsTypeTest</a><span class="delimiter">(</span><a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411367" title="=&gt; PatternMatching.this.global.Type">info</a>.<a href="../../../reflect/internal/Types.scala.html#408411" title="=&gt; PatternMatching.this.global.Type">widen</a>, <a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a><span class="delimiter">)</span> =&gt;
            // do non-null check first to ensure we won't select outer on null
            <a href="#3368513" title="(x: cs.Result)cs.Result" class="keyword">if</a> <span class="delimiter">(</span><a href="#1070697" title="=&gt; Boolean">outerTestNeeded</a><span class="delimiter">)</span> <a href="#1074299" title="(a: cs.Result, b: cs.Result)cs.Result">and</a><span class="delimiter">(</span><a href="#1074296" title="(testedBinder: PatternMatching.this.global.Symbol)cs.Result">nonNullTest</a><span class="delimiter">(</span><a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a><span class="delimiter">)</span>, <a href="#1074294" title="(testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type)cs.Result">outerTest</a><span class="delimiter">(</span><a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a>, <a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#1074296" title="(testedBinder: PatternMatching.this.global.Symbol)cs.Result">nonNullTest</a><span class="delimiter">(</span><a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a><span class="delimiter">)</span>

          <span class="keyword">case</span> _ =&gt; <a href="#3368513" title="(x: cs.Result)cs.Result">default</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span class="keyword">val</span> <a title="TreeMakers.this.TypeTestTreeMaker.treeCondStrategy.Result" id="1070700">cond</a> = <a href="#1070699" title="(cs: TreeMakers.this.TypeTestTreeMaker.TypeTestCondStrategy)cs.Result">renderCondition</a><span class="delimiter">(</span><a href="#1070660" title="TreeMakers.this.TypeTestTreeMaker.treeCondStrategy.type">treeCondStrategy</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1070702">res</a>  = <a href="#1069017" title="=&gt; TreeMakers.this.AbsCodegen">codegen</a>.<a href="#1071807" title="(b: PatternMatching.this.global.Symbol, tp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree">_asInstanceOf</a><span class="delimiter">(</span><a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a>, <a href="#1074600" title="=&gt; PatternMatching.this.global.Type">nextBinderTp</a><span class="delimiter">)</span>

      // is this purely a type test, e.g. no outer check, no equality tests (used in switch emission)
      <span class="keyword">def</span> <a title="=&gt; TreeMakers.this.TypeTestTreeMaker.pureTypeTestChecker.Result" id="1070704">isPureTypeTest</a> = <a href="#1070699" title="(cs: TreeMakers.this.TypeTestTreeMaker.TypeTestCondStrategy)cs.Result">renderCondition</a><span class="delimiter">(</span><a href="#1070662" title="TreeMakers.this.TypeTestTreeMaker.pureTypeTestChecker.type">pureTypeTestChecker</a><span class="delimiter">)</span>

      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1070705">toString</a> = <span title="String(&quot;TT&quot;)" class="string">&quot;TT&quot;</span><a href="../../../Tuple3.scala.html#63169" title="(x$1: Any)String">+</a><span class="delimiter">(</span><a href="#1074599" title="=&gt; PatternMatching.this.global.Type">expectedTp</a>, <a href="#1074598" title="=&gt; PatternMatching.this.global.Symbol">testedBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; TypeTestTreeMaker.this.testedBinder.NameType">name</a>, <a href="#1074600" title="=&gt; PatternMatching.this.global.Type">nextBinderTp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // need to substitute to deal with existential types -- TODO: deal with existentials better, don't substitute (see RichClass during quick.comp)
    case <span class="keyword">class</span> <a title="class EqualityTestTreeMaker extends TreeMakers.this.CondTreeMaker with Product with Serializable" id="1075442">EqualityTestTreeMaker</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="PatternMatching.this.global.Symbol" id="1071011">prevBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Tree" id="1071012">patTree</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.Position" id="1071013">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#22953" title="PatternMatching.this.global.Position">Position</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069046" title="TreeMakers.this.CondTreeMaker">CondTreeMaker</a> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1071002">nextBinderTp</a> = <a href="#1071011" title="=&gt; PatternMatching.this.global.Symbol">prevBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411367" title="=&gt; PatternMatching.this.global.Type">info</a>.<a href="../../../reflect/internal/Types.scala.html#408411" title="=&gt; PatternMatching.this.global.Type">widen</a>

      // NOTE: generate `patTree == patBinder`, since the extractor must be in control of the equals method (also, patBinder may be null)
      // equals need not be well-behaved, so don't intersect with pattern's (stabilized) type (unlike MaybeBoundTyped's accumType, where it's required)
      <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1071004">cond</a> = <a href="#1069017" title="=&gt; TreeMakers.this.AbsCodegen">codegen</a>.<a href="#1071809" title="(checker: PatternMatching.this.global.Tree, binder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">_equals</a><span class="delimiter">(</span><a href="#1071012" title="=&gt; PatternMatching.this.global.Tree">patTree</a>, <a href="#1071011" title="=&gt; PatternMatching.this.global.Symbol">prevBinder</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="PatternMatching.this.global.gen.global.Tree" id="1071006">res</a>  = <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1071011" title="=&gt; PatternMatching.this.global.Symbol">prevBinder</a><span class="delimiter">)</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1071008">toString</a> = <span title="String(&quot;ET&quot;)" class="string">&quot;ET&quot;</span><a href="../../../Tuple2.scala.html#62849" title="(x$1: Any)String">+</a><span class="delimiter">(</span><a href="#1071011" title="=&gt; PatternMatching.this.global.Symbol">prevBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; EqualityTestTreeMaker.this.prevBinder.NameType">name</a>, <a href="#1071012" title="=&gt; PatternMatching.this.global.Tree">patTree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    case <span class="keyword">class</span> <a title="class AlternativesTreeMaker extends TreeMakers.this.TreeMaker with TreeMakers.this.NoNewBinders with Product with Serializable" id="1075471">AlternativesTreeMaker</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="PatternMatching.this.global.Symbol" id="1071043">prevBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <span class="keyword">var</span> <a title="List[List[TreeMakers.this.TreeMaker]]" id="1071044">altss</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[TreeMakers.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="PatternMatching.this.global.Position" id="1071045">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#22953" title="PatternMatching.this.global.Position">Position</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069034" title="TreeMakers.this.TreeMaker">TreeMaker</a> <span class="keyword">with</span> <a href="#1069035" title="TreeMakers.this.NoNewBinders">NoNewBinders</a> <span class="delimiter">{</span>
      // don't substitute prevBinder to nextBinder, a set of alternatives does not need to introduce a new binder, simply reuse the previous one

      <span class="keyword">override</span> <span class="keyword">private</span><span class="delimiter">[</span>TreeMakers<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(outerSubst: TreeMakers.this.Substitution)Unit" id="1071036">incorporateOuterSubstitution</a><span class="delimiter">(</span><a title="TreeMakers.this.Substitution" id="1074720">outerSubst</a>: <a href="#1069026" title="TreeMakers.this.Substitution">Substitution</a><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#1515" title="Unit">Unit</a> = <span class="delimiter">{</span>
        <a href="#1075471" title="TreeMakers.this.AlternativesTreeMaker" class="keyword">super</a>.<a href="#1069811" title="(outerSubst: TreeMakers.this.Substitution)Unit">incorporateOuterSubstitution</a><span class="delimiter">(</span><a href="#1074720" title="TreeMakers.this.Substitution">outerSubst</a><span class="delimiter">)</span>
        <a href="#1071044" title="(x$1: List[List[TreeMakers.this.TreeMaker]])Unit">altss</a> = <a href="#1071044" title="=&gt; List[List[TreeMakers.this.TreeMaker]]">altss</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[TreeMakers.this.TreeMaker] =&gt; List[TreeMakers.this.TreeMaker])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[TreeMakers.this.TreeMaker]],List[TreeMakers.this.TreeMaker],List[List[TreeMakers.this.TreeMaker]]])List[List[TreeMakers.this.TreeMaker]]">map</a> <span class="delimiter">(</span><a title="List[TreeMakers.this.TreeMaker]" id="1074742">alts</a> =&gt; <a href="#1069071" title="(treeMakers: List[TreeMakers.this.TreeMaker], initial: TreeMakers.this.Substitution)List[TreeMakers.this.TreeMaker]">propagateSubstitution</a><span class="delimiter">(</span><a href="#1074742" title="List[TreeMakers.this.TreeMaker]">alts</a>, <a href="#1069809" title="=&gt; TreeMakers.this.Substitution">substitution</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="keyword">def</span> <a title="(next: PatternMatching.this.global.Tree)(codegenAlt: TreeMakers.this.Casegen)PatternMatching.this.global.Tree" id="1071037">chainBefore</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074771">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="TreeMakers.this.Casegen" id="1074772">codegenAlt</a>: <a href="#1069016" title="TreeMakers.this.Casegen">Casegen</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">{</span> <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._
        <a href="../../../reflect/internal/Positions.scala.html#408315" title="(pos: PatternMatching.this.global.Position)(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">atPos</a><span class="delimiter">(</span><a href="#1071045" title="=&gt; PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">{</span>
          // one alternative may still generate multiple trees (e.g., an extractor call + equality test)
          // (for now,) alternatives may not bind variables (except wildcards), so we don't care about the final substitution built internally by makeTreeMakers
          <span class="keyword">val</span> <a title="List[TreeMakers.this.Casegen =&gt; PatternMatching.this.global.Tree]" id="1074780">combinedAlts</a> = <a href="#1071044" title="=&gt; List[List[TreeMakers.this.TreeMaker]]">altss</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[TreeMakers.this.TreeMaker] =&gt; (TreeMakers.this.Casegen =&gt; PatternMatching.this.global.Tree))(implicit bf: scala.collection.generic.CanBuildFrom[List[List[TreeMakers.this.TreeMaker]],TreeMakers.this.Casegen =&gt; PatternMatching.this.global.Tree,List[TreeMakers.this.Casegen =&gt; PatternMatching.this.global.Tree]])List[TreeMakers.this.Casegen =&gt; PatternMatching.this.global.Tree]">map</a> <span class="delimiter">(</span><a title="List[TreeMakers.this.TreeMaker]" id="1074801">altTreeMakers</a> =&gt;
            <span class="delimiter">(</span><span class="delimiter">(</span>casegen: <a href="#1069016" title="TreeMakers.this.Casegen">Casegen</a><span class="delimiter">)</span> =&gt; <a href="#1069069" title="(treeMakers: List[TreeMakers.this.TreeMaker])(casegen: TreeMakers.this.Casegen)PatternMatching.this.global.Tree">combineExtractors</a><span class="delimiter">(</span><a href="#1074801" title="List[TreeMakers.this.TreeMaker]">altTreeMakers</a> <a href="../../../collection/SeqLike.scala.html#58855" title="(elem: TreeMakers.this.TreeMaker)(implicit bf: scala.collection.generic.CanBuildFrom[List[TreeMakers.this.TreeMaker],TreeMakers.this.TreeMaker,List[TreeMakers.this.TreeMaker]])List[TreeMakers.this.TreeMaker]">:+</a> <a href="#1075306" title="(tree: PatternMatching.this.global.Tree)TreeMakers.this.TrivialTreeMaker">TrivialTreeMaker</a><span class="delimiter">(</span><a href="#1074803" title="TreeMakers.this.Casegen">casegen</a>.<a href="#1073527" title="(res: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">one</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624562" title="=&gt; PatternMatching.this.global.Literal">TRUE_typed</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1074803" title="TreeMakers.this.Casegen">casegen</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">)</span>

          <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1074781">findAltMatcher</a> = <a href="#1074772" title="TreeMakers.this.Casegen">codegenAlt</a>.<a href="#1071806" title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, restpe: PatternMatching.this.global.Type)(cases: List[TreeMakers.this.Casegen =&gt; PatternMatching.this.global.Tree], matchFailGen: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree])PatternMatching.this.global.Tree">matcher</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#407946" title="PatternMatching.this.global.EmptyTree.type">EmptyTree</a>, <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a>, <a href="../../../reflect/internal/Definitions.scala.html#409369" title="=&gt; PatternMatching.this.global.ClassSymbol">BooleanClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1074780" title="List[TreeMakers.this.Casegen =&gt; PatternMatching.this.global.Tree]">combinedAlts</a>, <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Literal)Some[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Literal]">Some</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074901">x</a> =&gt; <a href="../ast/TreeDSL.scala.html#624563" title="=&gt; PatternMatching.this.global.Literal">FALSE_typed</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#1074772" title="TreeMakers.this.Casegen">codegenAlt</a>.<a href="#1073531" title="(c: PatternMatching.this.global.Tree, then: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">ifThenElseZero</a><span class="delimiter">(</span><a href="#1074781" title="PatternMatching.this.global.Tree">findAltMatcher</a>, <a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">substitution</a><span class="delimiter">(</span><a href="#1074771" title="PatternMatching.this.global.Tree">next</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    case <span class="keyword">class</span> <a title="class GuardTreeMaker extends TreeMakers.this.TreeMaker with TreeMakers.this.NoNewBinders with Product with Serializable" id="1075491">GuardTreeMaker</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1071247">guardTree</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069034" title="TreeMakers.this.TreeMaker">TreeMaker</a> <span class="keyword">with</span> <a href="#1069035" title="TreeMakers.this.NoNewBinders">NoNewBinders</a> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="PatternMatching.this.global.Position" id="1071241">pos</a> = <a href="#1071247" title="=&gt; PatternMatching.this.global.Tree">guardTree</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a>

      <span class="keyword">def</span> <a title="(next: PatternMatching.this.global.Tree)(casegen: TreeMakers.this.Casegen)PatternMatching.this.global.Tree" id="1071243">chainBefore</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074955">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="TreeMakers.this.Casegen" id="1074956">casegen</a>: <a href="#1069016" title="TreeMakers.this.Casegen">Casegen</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="#1074956" title="TreeMakers.this.Casegen">casegen</a>.<a href="#1073530" title="(cond: PatternMatching.this.global.Tree, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">flatMapGuard</a><span class="delimiter">(</span><a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">substitution</a><span class="delimiter">(</span><a href="#1071247" title="=&gt; PatternMatching.this.global.Tree">guardTree</a><span class="delimiter">)</span>, <a href="#1074955" title="PatternMatching.this.global.Tree">next</a><span class="delimiter">)</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1071244">toString</a> = <span title="String(&quot;G(&quot;)" class="string">&quot;G(&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1071247" title="=&gt; PatternMatching.this.global.Tree">guardTree</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
    <span class="delimiter">}</span>

    // combineExtractors changes the current substitution's of the tree makers in `treeMakers`
    // requires propagateSubstitution(treeMakers) has been called
    <span class="keyword">def</span> <a title="(treeMakers: List[TreeMakers.this.TreeMaker])(casegen: TreeMakers.this.Casegen)PatternMatching.this.global.Tree" id="1069069">combineExtractors</a><span class="delimiter">(</span><a title="List[TreeMakers.this.TreeMaker]" id="1074804">treeMakers</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[TreeMakers.this.TreeMaker]">List</a><span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="TreeMakers.this.Casegen" id="1074805">casegen</a>: <a href="#1069016" title="TreeMakers.this.Casegen">Casegen</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> =
      <a href="#1074804" title="List[TreeMakers.this.TreeMaker]">treeMakers</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86385" title="(z: PatternMatching.this.global.Tree)(f: (TreeMakers.this.TreeMaker, PatternMatching.this.global.Tree) =&gt; PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">foldRight</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#407946" title="PatternMatching.this.global.EmptyTree.type">EmptyTree</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="TreeMakers.this.TreeMaker" id="1075008">a</a>, <a title="PatternMatching.this.global.Tree" id="1075009">b</a><span class="delimiter">)</span> =&gt; <a href="#1075008" title="TreeMakers.this.TreeMaker">a</a>.<a href="#1069814" title="(next: PatternMatching.this.global.Tree)(casegen: TreeMakers.this.Casegen)PatternMatching.this.global.Tree">chainBefore</a><span class="delimiter">(</span><a href="#1075009" title="PatternMatching.this.global.Tree">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1074805" title="TreeMakers.this.Casegen">casegen</a><span class="delimiter">)</span><span class="delimiter">)</span>


    <span class="keyword">def</span> <a title="(makers: List[TreeMakers.this.TreeMaker])List[TreeMakers.this.TreeMaker]" id="1069070">removeSubstOnly</a><span class="delimiter">(</span><a title="List[TreeMakers.this.TreeMaker]" id="1075010">makers</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[TreeMakers.this.TreeMaker]">List</a><span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#1075010" title="List[TreeMakers.this.TreeMaker]">makers</a> <a href="../../../collection/TraversableLike.scala.html#58074" title="(p: TreeMakers.this.TreeMaker =&gt; Boolean)List[TreeMakers.this.TreeMaker]">filterNot</a> <span class="delimiter">(</span><a href="#1075016" title="TreeMakers.this.TreeMaker">_</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#1075358" title="TreeMakers.this.SubstOnlyTreeMaker">SubstOnlyTreeMaker</a><span class="delimiter">]</span><span class="delimiter">)</span>

    // a foldLeft to accumulate the localSubstitution left-to-right
    // it drops SubstOnly tree makers, since their only goal in life is to propagate substitutions to the next tree maker, which is fullfilled by propagateSubstitution
    <span class="keyword">def</span> <a title="(treeMakers: List[TreeMakers.this.TreeMaker], initial: TreeMakers.this.Substitution)List[TreeMakers.this.TreeMaker]" id="1069071">propagateSubstitution</a><span class="delimiter">(</span><a title="List[TreeMakers.this.TreeMaker]" id="1069965">treeMakers</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[TreeMakers.this.TreeMaker]">List</a><span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span>, <a title="TreeMakers.this.Substitution" id="1069966">initial</a>: <a href="#1069026" title="TreeMakers.this.Substitution">Substitution</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[TreeMakers.this.TreeMaker]">List</a><span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">var</span> <a title="TreeMakers.this.Substitution" id="1075017">accumSubst</a>: <a href="#1069026" title="TreeMakers.this.Substitution">Substitution</a> = <a href="#1069966" title="TreeMakers.this.Substitution">initial</a>
      <a href="#1069965" title="List[TreeMakers.this.TreeMaker]">treeMakers</a> <a href="../../../collection/immutable/List.scala.html#62719" title="(f: TreeMakers.this.TreeMaker =&gt; Unit)Unit">foreach</a> <span class="delimiter">{</span> <a title="TreeMakers.this.TreeMaker" id="1075038">maker</a> =&gt;
        <a href="#1075038" title="TreeMakers.this.TreeMaker">maker</a> <a href="#1069811" title="(outerSubst: TreeMakers.this.Substitution)Unit">incorporateOuterSubstitution</a> <a href="#1075017" title="TreeMakers.this.Substitution">accumSubst</a>
        <a href="#1075017" title="TreeMakers.this.Substitution">accumSubst</a> = <a href="#1075038" title="TreeMakers.this.TreeMaker">maker</a>.<a href="#1069809" title="=&gt; TreeMakers.this.Substitution">substitution</a>
      <span class="delimiter">}</span>
      <a href="#1069070" title="(makers: List[TreeMakers.this.TreeMaker])List[TreeMakers.this.TreeMaker]">removeSubstOnly</a><span class="delimiter">(</span><a href="#1069965" title="List[TreeMakers.this.TreeMaker]">treeMakers</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // calls propagateSubstitution on the treemakers
    <span class="keyword">def</span> <a title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, casesRaw: List[List[TreeMakers.this.TreeMaker]], pt: PatternMatching.this.global.Type, owner: PatternMatching.this.global.Symbol, matchFailGenOverride: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree])PatternMatching.this.global.Tree" id="1069072">combineCases</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1069722">scrut</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1069723">scrutSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="List[List[TreeMakers.this.TreeMaker]]" id="1069724">casesRaw</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[TreeMakers.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="PatternMatching.this.global.Type" id="1069725">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <a title="PatternMatching.this.global.Symbol" id="1069726">owner</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]" id="1069727">matchFailGenOverride</a>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree =&gt; Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
      // drops SubstOnlyTreeMakers, since their effect is now contained in the TreeMakers that follow them
      <span class="keyword">val</span> <a title="List[List[TreeMakers.this.TreeMaker]]" id="1075040">casesNoSubstOnly</a> = <a href="#1069724" title="List[List[TreeMakers.this.TreeMaker]]">casesRaw</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[TreeMakers.this.TreeMaker] =&gt; List[TreeMakers.this.TreeMaker])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[TreeMakers.this.TreeMaker]],List[TreeMakers.this.TreeMaker],List[List[TreeMakers.this.TreeMaker]]])List[List[TreeMakers.this.TreeMaker]]">map</a> <span class="delimiter">(</span><a href="#1069071" title="(treeMakers: List[TreeMakers.this.TreeMaker], initial: TreeMakers.this.Substitution)List[TreeMakers.this.TreeMaker]">propagateSubstitution</a><span class="delimiter">(</span><a href="#1075057" title="List[TreeMakers.this.TreeMaker]">_</a>, <a href="#1069027" title="TreeMakers.this.EmptySubstitution.type">EmptySubstitution</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#1069073" title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, casesNoSubstOnly: List[List[TreeMakers.this.TreeMaker]], pt: PatternMatching.this.global.Type, owner: PatternMatching.this.global.Symbol, matchFailGenOverride: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree])PatternMatching.this.global.Tree">combineCasesNoSubstOnly</a><span class="delimiter">(</span><a href="#1069722" title="PatternMatching.this.global.Tree">scrut</a>, <a href="#1069723" title="PatternMatching.this.global.Symbol">scrutSym</a>, <a href="#1075040" title="List[List[TreeMakers.this.TreeMaker]]">casesNoSubstOnly</a>, <a href="#1069725" title="PatternMatching.this.global.Type">pt</a>, <a href="#1069726" title="PatternMatching.this.global.Symbol">owner</a>, <a href="#1069727" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">matchFailGenOverride</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // pt is the fully defined type of the cases (either pt or the lub of the types of the cases)
    <span class="keyword">def</span> <a title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, casesNoSubstOnly: List[List[TreeMakers.this.TreeMaker]], pt: PatternMatching.this.global.Type, owner: PatternMatching.this.global.Symbol, matchFailGenOverride: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree])PatternMatching.this.global.Tree" id="1069073">combineCasesNoSubstOnly</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1070385">scrut</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1070386">scrutSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="List[List[TreeMakers.this.TreeMaker]]" id="1070387">casesNoSubstOnly</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[TreeMakers.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="PatternMatching.this.global.Type" id="1070388">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <a title="PatternMatching.this.global.Symbol" id="1070389">owner</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]" id="1070390">matchFailGenOverride</a>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree =&gt; Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> =
      <a href="#1069074" title="(origOwner: PatternMatching.this.global.Symbol, pos: PatternMatching.this.global.Position)PatternMatching.this.global.Traverser">fixerUpper</a><a href="../../../reflect/api/Trees.scala.html#405549" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="#1070389" title="PatternMatching.this.global.Symbol">owner</a>, <a href="#1070385" title="PatternMatching.this.global.Tree">scrut</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="=&gt; Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]" id="1075088">matchFailGen</a> = <span class="delimiter">(</span><a href="#1070390" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">matchFailGenOverride</a> <a href="../../../Option.scala.html#62890" title="(alternative: =&gt; Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree])Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">orElse</a> <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Throw)Some[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Throw]">Some</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624587" title="(arg: PatternMatching.this.global.Tree)PatternMatching.this.global.Throw">MATCHERROR</a><span class="delimiter">(</span><a href="#1075099" title="PatternMatching.this.global.Tree">_</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;combining cases: &quot;)" class="string">&quot;combining cases: &quot;</span><span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="#1070387" title="List[List[TreeMakers.this.TreeMaker]]">casesNoSubstOnly</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[TreeMakers.this.TreeMaker] =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[TreeMakers.this.TreeMaker]],String,List[String]])List[String]">map</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</a><a href="#1075119" title="List[TreeMakers.this.TreeMaker]">_</a>.<a href="../../../collection/TraversableOnce.scala.html#58283" title="(sep: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot; &gt;&gt; &quot;)" class="string">&quot; &gt;&gt; &quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../collection/TraversableOnce.scala.html#58282" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;{&quot;)" class="string">&quot;{&quot;</span>, <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span>, <span title="String(&quot;}&quot;)" class="string">&quot;}&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

        <span class="keyword">val</span> <a href="#3368827" title="(x: (Boolean, Boolean))(Boolean, Boolean)" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="Boolean" id="1075090">unchecked</a>, <a href="../../../Tuple2.scala.html#60637" title="Boolean" id="1075091">requireSwitch</a><span class="delimiter">)</span> =
          <a href="#3368825" title="(Boolean, Boolean)" class="keyword">if</a> <span class="delimiter">(</span><a href="../Global.scala.html#537448" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#540027" title="=&gt; scala.tools.nsc.Settings#BooleanSetting">XnoPatmatAnalysis</a>.<a href="../settings/MutableSettings.scala.html#541066" title="=&gt; Boolean">value</a><span class="delimiter">)</span> <a href="../../../Tuple2.scala.html#62849" title="(_1: Boolean, _2: Boolean)(Boolean, Boolean)" class="delimiter">(</a><span title="Boolean(true)" class="keyword">true</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#1070385" title="PatternMatching.this.global.Tree">scrut</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> Typed<a href="#3368815" title="(Boolean, Boolean)" id="3368818" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410055" title="PatternMatching.this.global.Tree" id="3368816">_</a>, <a href="../../../reflect/internal/Trees.scala.html#410057" title="PatternMatching.this.global.Tree" id="1075165">tpt</a><span class="delimiter">)</span> =&gt;
              <a href="#3368820" title="(x: (Boolean, Boolean))(Boolean, Boolean)" class="delimiter">(</a><a href="#1075165" title="PatternMatching.this.global.Tree">tpt</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a> <a href="../../../reflect/internal/AnnotationInfos.scala.html#408615" title="(cls: PatternMatching.this.global.Symbol)Boolean">hasAnnotation</a> <a href="../../../reflect/internal/Definitions.scala.html#409205" title="=&gt; PatternMatching.this.global.ClassSymbol">UncheckedClass</a>,
               // matches with two or fewer cases need not apply for switchiness (if-then-else will do)
               <a href="../ast/Trees.scala.html#537807" title="PatternMatching.this.global.treeInfo.type">treeInfo</a>.<a href="../../../reflect/internal/TreeInfo.scala.html#479226" title="(tpe: PatternMatching.this.global.treeInfo.global.Type)Boolean">isSwitchAnnotation</a><span class="delimiter">(</span><a href="#1075165" title="PatternMatching.this.global.Tree">tpt</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1070387" title="List[List[TreeMakers.this.TreeMaker]]">casesNoSubstOnly</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86404" title="(len: Int)Int">lengthCompare</a><span class="delimiter">(</span><span title="Int(2)" class="int">2</span><span class="delimiter">)</span> <a href="../../../Int.scala.html#57125" title="(x: Int)Boolean">&gt;</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
            <span class="keyword">case</span> _ =&gt;
              <a href="#3368820" title="(x: (Boolean, Boolean))(Boolean, Boolean)" class="delimiter">(</a><span title="Boolean(false)" class="keyword">false</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>

        <a href="#1069032" title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, cases: List[List[TreeMakers.this.TreeMaker]], pt: PatternMatching.this.global.Type, matchFailGenOverride: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree], unchecked: Boolean)Option[PatternMatching.this.global.Tree]">emitSwitch</a><span class="delimiter">(</span><a href="#1070385" title="PatternMatching.this.global.Tree">scrut</a>, <a href="#1070386" title="PatternMatching.this.global.Symbol">scrutSym</a>, <a href="#1070387" title="List[List[TreeMakers.this.TreeMaker]]">casesNoSubstOnly</a>, <a href="#1070388" title="PatternMatching.this.global.Type">pt</a>, <a href="#1070390" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">matchFailGenOverride</a>, <a href="#1075090" title="Boolean">unchecked</a><span class="delimiter">)</span>.<a href="../../../Option.scala.html#62859" title="(default: =&gt; PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">getOrElse</a><span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1075091" title="Boolean">requireSwitch</a><span class="delimiter">)</span> <a href="#1068979" title="=&gt; PatternMatching.this.global.analyzer.Typer">typer</a>.<a href="Typers.scala.html#538560" title="=&gt; PatternMatching.this.global.analyzer.Context">context</a>.<a href="Contexts.scala.html#538743" title="=&gt; PatternMatching.this.global.analyzer.global.CompilationUnit">unit</a>.<a href="../CompilationUnits.scala.html#539299" title="(pos: PatternMatching.this.global.analyzer.global.Position, msg: String)Unit">warning</a><span class="delimiter">(</span><a href="#1070385" title="PatternMatching.this.global.Tree">scrut</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a>, <span title="String(&quot;could not emit switch for @switch annotated match&quot;)" class="string">&quot;could not emit switch for @switch annotated match&quot;</span><span class="delimiter">)</span>

          <span title="PatternMatching.this.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#1070387" title="List[List[TreeMakers.this.TreeMaker]]">casesNoSubstOnly</a> <a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            // before optimizing, check casesNoSubstOnly for presence of a default case,
            // since DCE will eliminate trivial cases like `case _ =&gt;`, even if they're the last one
            // exhaustivity and reachability must be checked before optimization as well
            // TODO: improve notion of trivial/irrefutable -- a trivial type test before the body still makes for a default case
            //   (&quot;trivial&quot; depends on whether we're emitting a straight match or an exception, or more generally, any supertype of scrutSym.tpe is a no-op)
            //   irrefutability checking should use the approximation framework also used for CSE, unreachability and exhaustivity checking
            <span class="keyword">val</span> <a title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]" id="1075199">synthCatchAll</a> =
              <span title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1070387" title="List[List[TreeMakers.this.TreeMaker]]">casesNoSubstOnly</a>.<a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
                    <span class="keyword">val</span> <a title="List[TreeMakers.this.TreeMaker]" id="1075204">nonTrivLast</a> = <a href="#1070387" title="List[List[TreeMakers.this.TreeMaker]]">casesNoSubstOnly</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86394" title="=&gt; List[TreeMakers.this.TreeMaker]">last</a>
                    <a href="#1075204" title="List[TreeMakers.this.TreeMaker]">nonTrivLast</a>.<a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1075204" title="List[TreeMakers.this.TreeMaker]">nonTrivLast</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; TreeMakers.this.TreeMaker">head</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#1075332" title="TreeMakers.this.BodyTreeMaker">BodyTreeMaker</a><span class="delimiter">]</span>
                  <span class="delimiter">}</span><span class="delimiter">)</span> <a href="../../../Option.scala.html#1585" title="None.type">None</a>
              <span class="keyword">else</span> <a href="#1075088" title="=&gt; Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">matchFailGen</a>

            <span class="keyword">val</span> <a href="#3368833" title="(x: (List[List[TreeMakers.this.TreeMaker]], List[PatternMatching.this.global.Tree]))(List[List[TreeMakers.this.TreeMaker]], List[PatternMatching.this.global.Tree])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="List[List[TreeMakers.this.TreeMaker]]" id="1075201">cases</a>, <a href="../../../Tuple2.scala.html#60637" title="List[PatternMatching.this.global.Tree]" id="1075202">toHoist</a><span class="delimiter">)</span> = <a href="#1069031" title="(prevBinder: PatternMatching.this.global.Symbol, cases: List[List[TreeMakers.this.TreeMaker]], pt: PatternMatching.this.global.Type, unchecked: Boolean)(List[List[TreeMakers.this.TreeMaker]], List[PatternMatching.this.global.Tree])">optimizeCases</a><a href="../../../Tuple2.scala.html#783" title="(List[List[TreeMakers.this.TreeMaker]], List[PatternMatching.this.global.Tree]) @unchecked" class="delimiter">(</a><a href="#1070386" title="PatternMatching.this.global.Symbol">scrutSym</a>, <a href="#1070387" title="List[List[TreeMakers.this.TreeMaker]]">casesNoSubstOnly</a>, <a href="#1070388" title="PatternMatching.this.global.Type">pt</a>, <a href="#1075090" title="Boolean">unchecked</a><span class="delimiter">)</span>

            <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1075203">matchRes</a> = <a href="#1069017" title="=&gt; TreeMakers.this.AbsCodegen">codegen</a>.<a href="#1071806" title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, restpe: PatternMatching.this.global.Type)(cases: List[TreeMakers.this.Casegen =&gt; PatternMatching.this.global.Tree], matchFailGen: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree])PatternMatching.this.global.Tree">matcher</a><span class="delimiter">(</span><a href="#1070385" title="PatternMatching.this.global.Tree">scrut</a>, <a href="#1070386" title="PatternMatching.this.global.Symbol">scrutSym</a>, <a href="#1070388" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1075201" title="List[List[TreeMakers.this.TreeMaker]]">cases</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[TreeMakers.this.TreeMaker] =&gt; (TreeMakers.this.Casegen =&gt; PatternMatching.this.global.Tree))(implicit bf: scala.collection.generic.CanBuildFrom[List[List[TreeMakers.this.TreeMaker]],TreeMakers.this.Casegen =&gt; PatternMatching.this.global.Tree,List[TreeMakers.this.Casegen =&gt; PatternMatching.this.global.Tree]])List[TreeMakers.this.Casegen =&gt; PatternMatching.this.global.Tree]">map</a> <a href="#1069069" title="(treeMakers: List[TreeMakers.this.TreeMaker])(casegen: TreeMakers.this.Casegen)PatternMatching.this.global.Tree">combineExtractors</a>, <a href="#1075199" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">synthCatchAll</a><span class="delimiter">)</span>

            <span title="PatternMatching.this.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#1075202" title="List[PatternMatching.this.global.Tree]">toHoist</a> <a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#1075203" title="PatternMatching.this.global.Tree">matchRes</a> <span class="keyword">else</span> <a href="../../../reflect/internal/Trees.scala.html#453067" title="(stats: List[PatternMatching.this.global.Tree], expr: PatternMatching.this.global.Tree)PatternMatching.this.global.Block">Block</a><span class="delimiter">(</span><a href="#1075202" title="List[PatternMatching.this.global.Tree]">toHoist</a>, <a href="#1075203" title="PatternMatching.this.global.Tree">matchRes</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="#1069017" title="=&gt; TreeMakers.this.AbsCodegen">codegen</a>.<a href="#1071806" title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, restpe: PatternMatching.this.global.Type)(cases: List[TreeMakers.this.Casegen =&gt; PatternMatching.this.global.Tree], matchFailGen: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree])PatternMatching.this.global.Tree">matcher</a><span class="delimiter">(</span><a href="#1070385" title="PatternMatching.this.global.Tree">scrut</a>, <a href="#1070386" title="PatternMatching.this.global.Symbol">scrutSym</a>, <a href="#1070388" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#1075088" title="=&gt; Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">matchFailGen</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

    // TODO: do this during tree construction, but that will require tracking the current owner in treemakers
    // TODO: assign more fine-grained positions
    // fixes symbol nesting, assigns positions
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(origOwner: PatternMatching.this.global.Symbol, pos: PatternMatching.this.global.Position)PatternMatching.this.global.Traverser" id="1069074">fixerUpper</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1070058">origOwner</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Position" id="1070059">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#22953" title="PatternMatching.this.global.Position">Position</a><span class="delimiter">)</span> = <a href="#1070062" title="PatternMatching.this.global.Traverser" class="keyword">new</a> <a href="../../../reflect/api/Trees.scala.html#56467" title="anonymous class $anon extends PatternMatching.this.global.Traverser" id="1070062">Traverser</a> <span class="delimiter">{</span>
      <a href="../../../reflect/api/Trees.scala.html#405542" title="(x$1: PatternMatching.this.global.Symbol)Unit">currentOwner</a> = <a href="#1070058" title="PatternMatching.this.global.Symbol">origOwner</a>

      <span class="keyword">override</span> <span class="keyword">def</span> <a title="(t: PatternMatching.this.global.Tree)Unit" id="1070064">traverse</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1070065">t</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#1070065" title="PatternMatching.this.global.Tree">t</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="../../../reflect/internal/Trees.scala.html#407946" title="PatternMatching.this.global.EmptyTree.type">EmptyTree</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1070065" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/Positions.scala.html#408302" title="=&gt; reflect.internal.util.NoPosition.type">NoPosition</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#1070065" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#409604" title="(newpos: PatternMatching.this.global.Position)t.type">setPos</a><span class="delimiter">(</span><a href="#1070059" title="PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#1070065" title="PatternMatching.this.global.Tree">t</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Function<a href="#3368837" title="Boolean" id="3368841" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410136" title="List[PatternMatching.this.global.ValDef]" id="3368838">_</a>, <a href="../../../reflect/internal/Trees.scala.html#410138" title="PatternMatching.this.global.Tree" id="3368839">_</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#1070065" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a> =&gt;
            <a href="#1070065" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408578" title="(sym: PatternMatching.this.global.Symbol)Unit">symbol</a> = <a href="../../../reflect/api/Trees.scala.html#405541" title="PatternMatching.this.global.Symbol" id="1070096">currentOwner</a>.<a href="../../../reflect/internal/Symbols.scala.html#473029" title="Long" id="1070100">newAnonymousFunctionValue</a><span class="delimiter">(</span><a href="#1070065" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="PatternMatching.this.global.Position" id="1070099">pos</a><span class="delimiter">)</span>
            <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;new symbol for &quot;)" class="string">&quot;new symbol for &quot;</span><a href="../../../Tuple2.scala.html#62849" title="(x$1: Any)String">+</a> <span class="delimiter">(</span><a href="#1070065" title="PatternMatching.this.global.Tree">t</a>, <a href="#1070065" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411317" title="=&gt; List[PatternMatching.this.global.Symbol]">ownerChain</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> Function<span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#410136" title="List[PatternMatching.this.global.ValDef]" id="3368842">_</a>, <a href="../../../reflect/internal/Trees.scala.html#410138" title="PatternMatching.this.global.Tree" id="3368843">_</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#1070065" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411315" title="=&gt; PatternMatching.this.global.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#1070065" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411315" title="=&gt; PatternMatching.this.global.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1070058" title="PatternMatching.this.global.Symbol">origOwner</a><span class="delimiter">)</span> =&gt;
            <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;fundef: &quot;)" class="string">&quot;fundef: &quot;</span><a href="../../../Tuple3.scala.html#63169" title="(x$1: Any)String">+</a> <span class="delimiter">(</span><a href="#1070065" title="PatternMatching.this.global.Tree">t</a>, <a href="#1070065" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411317" title="=&gt; List[PatternMatching.this.global.Symbol]">ownerChain</a>, <a href="../../../reflect/api/Trees.scala.html#405541" title="=&gt; PatternMatching.this.global.Symbol">currentOwner</a>.<a href="../../../reflect/internal/Symbols.scala.html#411317" title="=&gt; List[PatternMatching.this.global.Symbol]">ownerChain</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#1070065" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411316" title="(owner: PatternMatching.this.global.Symbol)Unit">owner</a> = <a href="../../../reflect/api/Trees.scala.html#405541" title="=&gt; PatternMatching.this.global.Symbol">currentOwner</a>
          <span class="keyword">case</span> <a href="#3368837" title="Unit" id="3368847">d</a> : DefTree <span class="keyword">if</span> <span class="delimiter">(</span>d.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><span class="delimiter">(</span>d.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411315" title="=&gt; PatternMatching.this.global.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span>d.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411315" title="=&gt; PatternMatching.this.global.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1070058" title="PatternMatching.this.global.Symbol">origOwner</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; // don't indiscriminately change existing owners! (see e.g., pos/t3440, pos/t3534, pos/unapplyContexts2)
            <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;def: &quot;)" class="string">&quot;def: &quot;</span><a href="../../../Tuple3.scala.html#63169" title="(x$1: Any)String">+</a> <span class="delimiter">(</span>d, d.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411317" title="=&gt; List[PatternMatching.this.global.Symbol]">ownerChain</a>, <a href="../../../reflect/api/Trees.scala.html#405541" title="=&gt; PatternMatching.this.global.Symbol">currentOwner</a>.<a href="../../../reflect/internal/Symbols.scala.html#411317" title="=&gt; List[PatternMatching.this.global.Symbol]">ownerChain</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span title="Unit" class="keyword">if</span><span class="delimiter">(</span>d.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/HasFlags.scala.html#409857" title="=&gt; Boolean">isLazy</a><span class="delimiter">)</span> <span class="delimiter">{</span> // for lazy val's accessor -- is there no tree??
              <a href="../Global.scala.html#537497" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span>d.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411436" title="=&gt; PatternMatching.this.global.Symbol">lazyAccessor</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> d.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411436" title="=&gt; PatternMatching.this.global.Symbol">lazyAccessor</a>.<a href="../../../reflect/internal/Symbols.scala.html#411315" title="=&gt; PatternMatching.this.global.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> d.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411315" title="=&gt; PatternMatching.this.global.Symbol">owner</a>, d.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411436" title="=&gt; PatternMatching.this.global.Symbol">lazyAccessor</a><span class="delimiter">)</span>
              d.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411436" title="=&gt; PatternMatching.this.global.Symbol">lazyAccessor</a>.<a href="../../../reflect/internal/Symbols.scala.html#411316" title="(owner: PatternMatching.this.global.Symbol)Unit">owner</a> = <a href="../../../reflect/api/Trees.scala.html#405541" title="=&gt; PatternMatching.this.global.Symbol">currentOwner</a>
            <span class="delimiter">}</span>
            <span title="Unit" class="keyword">if</span><span class="delimiter">(</span>d.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411459" title="=&gt; PatternMatching.this.global.Symbol">moduleClass</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
              d.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411459" title="=&gt; PatternMatching.this.global.Symbol">moduleClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411316" title="(owner: PatternMatching.this.global.Symbol)Unit">owner</a> = <a href="../../../reflect/api/Trees.scala.html#405541" title="=&gt; PatternMatching.this.global.Symbol">currentOwner</a>

            d.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411316" title="(owner: PatternMatching.this.global.Symbol)Unit">owner</a> = <a href="../../../reflect/api/Trees.scala.html#405541" title="=&gt; PatternMatching.this.global.Symbol">currentOwner</a>
          // case _ if (t.symbol != NoSymbol) &amp;&amp; (t.symbol ne null) =&gt;
          <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;untouched &quot;)" class="string">&quot;untouched &quot;</span><a href="../../../Tuple4.scala.html#83441" title="(x$1: Any)String">+</a> <span class="delimiter">(</span><a href="#1070065" title="PatternMatching.this.global.Tree">t</a>, <a href="#1070065" title="PatternMatching.this.global.Tree">t</a>.<span title="()Class[_]">getClass</span>, <a href="#1070065" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411317" title="=&gt; List[PatternMatching.this.global.Symbol]">ownerChain</a>, <a href="../../../reflect/api/Trees.scala.html#405541" title="=&gt; PatternMatching.this.global.Symbol">currentOwner</a>.<a href="../../../reflect/internal/Symbols.scala.html#411317" title="=&gt; List[PatternMatching.this.global.Symbol]">ownerChain</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
        <span class="delimiter">}</span>
        <a href="#1070062" title="PatternMatching.this.global.Traverser" class="keyword">super</a>.<a href="../../../reflect/api/Trees.scala.html#405544" title="(tree: PatternMatching.this.global.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#1070065" title="PatternMatching.this.global.Tree">t</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      // override def apply
      // patmatDebug(&quot;before fixerupper: &quot;+ xTree)
      // currentRun.trackerFactory.snapshot()
      // patmatDebug(&quot;after fixerupper&quot;)
      // currentRun.trackerFactory.snapshot()
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// generate actual trees
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  <span class="keyword">trait</span> <a title="trait CodegenCore extends Object with PatternMatching.this.MatchMonadInterface" id="621389">CodegenCore</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621385" title="PatternMatching.this.MatchMonadInterface">MatchMonadInterface</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="1069010">ctr</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">def</span> <a title="(prefix: String)PatternMatching.this.global.TermName" id="1069012">freshName</a><span class="delimiter">(</span><a title="String" id="1069705">prefix</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">{</span><a href="#1069010" title="(x$1: Int)Unit">ctr</a> <a href="../../../Int.scala.html#57154" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>; <a href="#621381" title="PatternMatching.this.vpmName.type">vpmName</a>.<a href="#1069385" title="(str: String, i: Int)PatternMatching.this.global.TermName">counted</a><span class="delimiter">(</span><a href="#1069705" title="String">prefix</a>, <a href="#1069010" title="=&gt; Int">ctr</a><span class="delimiter">)</span><span class="delimiter">}</span>

    // assert(owner ne null); assert(owner ne NoSymbol)
    <span class="keyword">def</span> <a title="(pos: PatternMatching.this.global.Position, tp: PatternMatching.this.global.Type, prefix: String)PatternMatching.this.global.TermSymbol" id="1069013">freshSym</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Position" id="1069692">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#22953" title="PatternMatching.this.global.Position">Position</a>, <a title="PatternMatching.this.global.Type" id="1069697">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a> = <a href="../../../reflect/internal/Types.scala.html#407284" title="PatternMatching.this.global.NoType.type">NoType</a>, <a title="String" id="1069698">prefix</a>: <span title="String">String</span> = <span title="String(&quot;x&quot;)" class="string">&quot;x&quot;</span><span class="delimiter">)</span> =
      <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411350" title="(name: PatternMatching.this.global.TermName, pos: PatternMatching.this.global.Position, newFlags: Long)PatternMatching.this.global.TermSymbol">newTermSymbol</a><span class="delimiter">(</span><a href="#1069012" title="(prefix: String)PatternMatching.this.global.TermName">freshName</a><span class="delimiter">(</span><a href="#1069698" title="String">prefix</a><span class="delimiter">)</span>, <a href="#1069692" title="PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Symbols.scala.html#411369" title="(info: PatternMatching.this.global.Type)PatternMatching.this.global.TermSymbol">setInfo</a> <a href="#1069697" title="PatternMatching.this.global.Type">tp</a>

    <span class="keyword">def</span> <a title="(name: String)PatternMatching.this.global.MethodSymbol" id="1069014">newSynthCaseLabel</a><span class="delimiter">(</span><a title="String" id="1075494">name</a>: <span title="String">String</span><span class="delimiter">)</span> =
      <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411115" title="(name: PatternMatching.this.global.TermName, pos: PatternMatching.this.global.Position)PatternMatching.this.global.MethodSymbol">newLabel</a><span class="delimiter">(</span><a href="#1069012" title="(prefix: String)PatternMatching.this.global.TermName">freshName</a><span class="delimiter">(</span><a href="#1075494" title="String">name</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Positions.scala.html#408302" title="=&gt; reflect.internal.util.NoPosition.type">NoPosition</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Symbols.scala.html#411236" title="(mask: Long)PatternMatching.this.global.MethodSymbol">setFlag</a> treeInfo.<span title="Long(2099200L)">SYNTH_CASE_FLAGS</span>

    // codegen relevant to the structure of the translation (how extractors are combined)
    <span class="keyword">trait</span> <a title="trait AbsCodegen extends Object" id="1069015">AbsCodegen</a> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, restpe: PatternMatching.this.global.Type)(cases: List[CodegenCore.this.Casegen =&gt; PatternMatching.this.global.Tree], matchFailGen: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree])PatternMatching.this.global.Tree" id="1071806">matcher</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074891">scrut</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1074892">scrutSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1074893">restpe</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="List[CodegenCore.this.Casegen =&gt; PatternMatching.this.global.Tree]" id="1074894">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[CodegenCore.this.Casegen =&gt; PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Casegen =&gt; Tree<span class="delimiter">]</span>, <a title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]" id="1074895">matchFailGen</a>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree =&gt; Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>

      // local / context-free
      <span class="keyword">def</span> <a title="(b: PatternMatching.this.global.Symbol, tp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree" id="1071807">_asInstanceOf</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1074413">b</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1074414">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
      <span class="keyword">def</span> <a title="(t: PatternMatching.this.global.Tree, tp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree" id="1071808">_asInstanceOf</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074411">t</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Type" id="1074412">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
      <span class="keyword">def</span> <a title="(checker: PatternMatching.this.global.Tree, binder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree" id="1071809">_equals</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074350">checker</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1074351">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
      <span class="keyword">def</span> <a title="(b: PatternMatching.this.global.Symbol, tp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree" id="1071810">_isInstanceOf</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1074335">b</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1074336">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
      <span class="keyword">def</span> <a title="(a: PatternMatching.this.global.Tree, b: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1071811">and</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1075506">a</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Tree" id="1075507">b</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
      <span class="keyword">def</span> <a title="(tgt: PatternMatching.this.global.Tree)(n: Int)PatternMatching.this.global.Tree" id="1071812">drop</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1072214">tgt</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Int" id="1072215">n</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
      <span class="keyword">def</span> <a title="(tgt: PatternMatching.this.global.Tree)(i: Int)PatternMatching.this.global.Tree" id="1071813">index</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1072113">tgt</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Int" id="1072114">i</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
      <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree" id="1071814">mkZero</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1075508">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
      <span class="keyword">def</span> <a title="(binder: PatternMatching.this.global.Symbol)(i: Int)PatternMatching.this.global.Tree" id="1071815">tupleSel</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1071816">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Int" id="1071817">i</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
    <span class="delimiter">}</span>

    // structure
    <span class="keyword">trait</span> <a title="trait Casegen extends Object with CodegenCore.this.AbsCodegen" id="1069016">Casegen</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#1069015" title="CodegenCore.this.AbsCodegen">AbsCodegen</a> <span class="delimiter">{</span> <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._
      <span class="keyword">def</span> <a title="(res: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1073527">one</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1073593">res</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>

      <span class="keyword">def</span> <a title="(prev: PatternMatching.this.global.Tree, b: PatternMatching.this.global.Symbol, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1073528">flatMap</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074052">prev</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1074053">b</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Tree" id="1074054">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
      <span class="keyword">def</span> <a title="(cond: PatternMatching.this.global.Tree, res: PatternMatching.this.global.Tree, nextBinder: PatternMatching.this.global.Symbol, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1073529">flatMapCond</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1073732">cond</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Tree" id="1073733">res</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1073734">nextBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Tree" id="1073735">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
      <span class="keyword">def</span> <a title="(cond: PatternMatching.this.global.Tree, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1073530">flatMapGuard</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074958">cond</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Tree" id="1074959">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
      <span class="keyword">def</span> <a title="(c: PatternMatching.this.global.Tree, then: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1073531">ifThenElseZero</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1074044">c</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Tree" id="1074045">then</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="../ast/TreeDSL.scala.html#624605" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.CODE.IfStart">IF</a> <span class="delimiter">(</span><a href="#1074044" title="PatternMatching.this.global.Tree">c</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#662292" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.CODE.IfStart">THEN</a> <a href="#1074045" title="PatternMatching.this.global.Tree">then</a> <a href="../ast/TreeDSL.scala.html#662293" title="(elsep: PatternMatching.this.global.Tree)PatternMatching.this.global.If">ELSE</a> <a href="#1073532" title="=&gt; PatternMatching.this.global.Tree">zero</a>
      <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Tree" id="1073532">zero</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="=&gt; CodegenCore.this.AbsCodegen" id="1069017">codegen</a>: <a href="#1069015" title="CodegenCore.this.AbsCodegen">AbsCodegen</a>

    <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type, pt: PatternMatching.this.global.Type)Boolean" id="1069018">typesConform</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1075516">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <a title="PatternMatching.this.global.Type" id="1075517">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span><span class="delimiter">(</span><a href="#1075516" title="PatternMatching.this.global.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#1075517" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#1075516" title="PatternMatching.this.global.Type">tp</a> <a href="../../../reflect/internal/Types.scala.html#408481" title="(that: PatternMatching.this.global.Type)Boolean">&lt;:&lt;</a> <a href="#1075517" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span><span class="delimiter">)</span>

    // we use subtyping as a model for implication between instanceof tests
    // i.e., when S &lt;:&lt; T we assume x.isInstanceOf[S] implies x.isInstanceOf[T]
    // unfortunately this is not true in general:
    // SI-6022 expects instanceOfTpImplies(ProductClass.tpe, AnyRefClass.tpe)
    <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type, tpImplied: PatternMatching.this.global.Type)Boolean" id="1069019">instanceOfTpImplies</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1075522">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <a title="PatternMatching.this.global.Type" id="1075523">tpImplied</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Boolean" id="1075526">tpValue</a>    = <a href="#1075522" title="PatternMatching.this.global.Type">tp</a>.<a href="../../../reflect/internal/Types.scala.html#408407" title="=&gt; PatternMatching.this.global.Symbol">typeSymbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411183" title="=&gt; Boolean">isPrimitiveValueClass</a>

      // pretend we're comparing to Any when we're actually comparing to AnyVal or AnyRef
      // (and the subtype is respectively a value type or not a value type)
      // this allows us to reuse subtyping as a model for implication between instanceOf tests
      // the latter don't see a difference between AnyRef, Object or Any when comparing non-value types -- SI-6022
      <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1075527">tpImpliedNormalizedToAny</a> =
        <span title="PatternMatching.this.global.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#1075523" title="PatternMatching.this.global.Type">tpImplied</a> <a href="../../../reflect/internal/Types.scala.html#408485" title="(that: PatternMatching.this.global.Type)Boolean">=:=</a> <span class="delimiter">(</span><span title="PatternMatching.this.global.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#1075526" title="Boolean">tpValue</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Definitions.scala.html#408682" title="=&gt; PatternMatching.this.global.ClassSymbol">AnyValClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a> <span class="keyword">else</span> <a href="../../../reflect/internal/Definitions.scala.html#408669" title="=&gt; PatternMatching.this.global.AliasTypeSymbol">AnyRefClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../reflect/internal/Definitions.scala.html#408667" title="=&gt; PatternMatching.this.global.ClassSymbol">AnyClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a>
        <span class="keyword">else</span> <a href="#1075523" title="PatternMatching.this.global.Type">tpImplied</a>

      <a href="#1075522" title="PatternMatching.this.global.Type">tp</a> <a href="../../../reflect/internal/Types.scala.html#408481" title="(that: PatternMatching.this.global.Type)Boolean">&lt;:&lt;</a> <a href="#1075527" title="PatternMatching.this.global.Type">tpImpliedNormalizedToAny</a>
    <span class="delimiter">}</span>

    <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class CommonCodegen extends Object with CodegenCore.this.AbsCodegen" id="1069020">CommonCodegen</a> <a href="#1069020" title="CodegenCore.this.CommonCodegen" class="keyword">extends</a> <a href="#1069015" title="CodegenCore.this.AbsCodegen">AbsCodegen</a> <span class="delimiter">{</span> <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._
      <span class="keyword">def</span> <a title="(arg: PatternMatching.this.global.Symbol, body: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1075534">fun</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1075547">arg</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Tree" id="1075548">body</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>           = <a href="../../../reflect/internal/Trees.scala.html#453438" title="(vparams: List[PatternMatching.this.global.ValDef], body: PatternMatching.this.global.Tree)PatternMatching.this.global.Function">Function</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.ValDef*)List[PatternMatching.this.global.ValDef]">List</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#408103" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.ValDef">ValDef</a><span class="delimiter">(</span><a href="#1075547" title="PatternMatching.this.global.Symbol">arg</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#1075548" title="PatternMatching.this.global.Tree">body</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(tfun: PatternMatching.this.global.Tree, args: PatternMatching.this.global.Type*)PatternMatching.this.global.Tree" id="1075535">genTypeApply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1075581">tfun</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Type*" id="1075582">args</a>: <span title="PatternMatching.this.global.Type*">Type</span>*<span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>  = <span title="PatternMatching.this.global.Tree" class="keyword">if</span><span class="delimiter">(</span><a href="#1075582" title="PatternMatching.this.global.Type*">args</a> <a href="../../../collection/SeqLike.scala.html#58824" title="(elem: Any)Boolean">contains</a> <a href="../../../reflect/internal/Types.scala.html#407284" title="PatternMatching.this.global.NoType.type">NoType</a><span class="delimiter">)</span> <a href="#1075581" title="PatternMatching.this.global.Tree">tfun</a> <span class="keyword">else</span> <a href="../../../reflect/internal/Trees.scala.html#453869" title="(fun: PatternMatching.this.global.Tree, args: List[PatternMatching.this.global.Tree])PatternMatching.this.global.TypeApply">TypeApply</a><span class="delimiter">(</span><a href="#1075581" title="PatternMatching.this.global.Tree">tfun</a>, <a href="#1075582" title="PatternMatching.this.global.Type*">args</a>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[PatternMatching.this.global.Type]">toList</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.Type =&gt; PatternMatching.this.global.TypeTree)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Type],PatternMatching.this.global.TypeTree,List[PatternMatching.this.global.Tree]])List[PatternMatching.this.global.Tree]">map</a> <a href="../../../reflect/internal/Trees.scala.html#408087" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.TypeTree">TypeTree</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(binder: PatternMatching.this.global.Symbol)(i: Int)PatternMatching.this.global.Tree" id="1075536">tupleSel</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1075643">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Int" id="1075644">i</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>       = <span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods" class="delimiter">(</a><a href="#1075643" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#624619" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeFromSelectStart : (ss: PatternMatching.this.CODE.SelectStart)PatternMatching.this.global.Select">DOT</a> <a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/StdNames.scala.html#414152" title="(j: Int)PatternMatching.this.global.TermName">productAccessorName</a><span class="delimiter">(</span><a href="#1075644" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span> // make tree that accesses the i'th component of the tuple referenced by binder
      <span class="keyword">def</span> <a title="(tgt: PatternMatching.this.global.Tree)(i: Int)PatternMatching.this.global.Tree" id="1075537">index</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1075659">tgt</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Int" id="1075660">i</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>               = <a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods">tgt</a> <a href="../ast/TreeDSL.scala.html#662336" title="(params: PatternMatching.this.global.Tree*)PatternMatching.this.global.Apply">APPLY</a> <span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#662273" title="(x: Any)PatternMatching.this.global.Literal">LIT</a><span class="delimiter">(</span><a href="#1075660" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(tgt: PatternMatching.this.global.Tree)(n: Int)PatternMatching.this.global.Tree" id="1075538">drop</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1075676">tgt</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Int" id="1075677">n</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>                = <span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods">tgt</a> <a href="../ast/TreeDSL.scala.html#662306" title="(args: PatternMatching.this.global.Tree*)PatternMatching.this.global.Apply">DOT</a> <a href="#621381" title="PatternMatching.this.vpmName.type">vpmName</a>.<a href="#1069365" title="=&gt; PatternMatching.this.global.TermName">drop</a><span class="delimiter">)</span> <span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#662273" title="(x: Any)PatternMatching.this.global.Literal">LIT</a><span class="delimiter">(</span><a href="#1075677" title="Int">n</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(checker: PatternMatching.this.global.Tree, binder: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree" id="1075539">_equals</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1075690">checker</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1075691">binder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods">checker</a> <a href="../ast/TreeDSL.scala.html#662317" title="(other: PatternMatching.this.global.Tree)PatternMatching.this.global.Apply">MEMBER_==</a> <a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1075691" title="PatternMatching.this.global.Symbol">binder</a><span class="delimiter">)</span>          // NOTE: checker must be the target of the ==, that's the patmat semantics for ya
      <span class="keyword">def</span> <a title="(a: PatternMatching.this.global.Tree, b: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1075540">and</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1075700">a</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Tree" id="1075701">b</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>                  = <a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods">a</a> <a href="../ast/TreeDSL.scala.html#662316" title="(other: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">AND</a> <a href="#1075701" title="PatternMatching.this.global.Tree">b</a>

      // drop annotations generated by CPS plugin etc, since its annotationchecker rejects T @cps[U] &lt;: Any
      // let's assume for now annotations don't affect casts, drop them there, and bring them back using the outer Typed tree
      <span class="keyword">private</span> <span class="keyword">def</span> <a title="(t: PatternMatching.this.global.Tree, tp: PatternMatching.this.global.Type)PatternMatching.this.global.Typed" id="1075541">mkCast</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1075707">t</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Type" id="1075708">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> =
        <a href="../../../reflect/internal/Trees.scala.html#453846" title="(expr: PatternMatching.this.global.Tree, tpt: PatternMatching.this.global.Tree)PatternMatching.this.global.Typed">Typed</a><span class="delimiter">(</span><a href="../Global.scala.html#537460" title="PatternMatching.this.global.gen.type">gen</a>.<a href="../../../reflect/internal/TreeGen.scala.html#471005" title="(value: PatternMatching.this.global.gen.global.Tree, tpe: PatternMatching.this.global.gen.global.Type, any: Boolean, wrapInApply: Boolean)PatternMatching.this.global.gen.global.Tree">mkAsInstanceOf</a><span class="delimiter">(</span><a href="#1075707" title="PatternMatching.this.global.Tree">t</a>, <a href="#1075708" title="PatternMatching.this.global.Type">tp</a>.<a href="../../../reflect/internal/Types.scala.html#408510" title="=&gt; PatternMatching.this.global.Type">withoutAnnotations</a>, <span title="Boolean(true)" class="keyword">true</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#418149" title="()PatternMatching.this.global.TypeTree">TypeTree</a><span class="delimiter">(</span><span class="delimiter">)</span> <a href="../../../reflect/internal/Trees.scala.html#408575" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.TypeTree">setType</a> <a href="#1075708" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>

      // the force is needed mainly to deal with the GADT typing hack (we can't detect it otherwise as tp nor pt need contain an abstract type, we're just casting wildly)
      <span class="keyword">def</span> <a title="(t: PatternMatching.this.global.Tree, tp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree" id="1075542">_asInstanceOf</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1075727">t</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Type" id="1075728">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span title="PatternMatching.this.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#1075727" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="../../../reflect/internal/Types.scala.html#407284" title="PatternMatching.this.global.NoType.type">NoType</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1075727" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408560" title="=&gt; Boolean">isTyped</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1069018" title="(tp: PatternMatching.this.global.Type, pt: PatternMatching.this.global.Type)Boolean">typesConform</a><span class="delimiter">(</span><a href="#1075727" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>, <a href="#1075728" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#1075727" title="PatternMatching.this.global.Tree">t</a> <span class="keyword">else</span> <a href="#1075541" title="(t: PatternMatching.this.global.Tree, tp: PatternMatching.this.global.Type)PatternMatching.this.global.Typed">mkCast</a><span class="delimiter">(</span><a href="#1075727" title="PatternMatching.this.global.Tree">t</a>, <a href="#1075728" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(b: PatternMatching.this.global.Symbol, tp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree" id="1075543">_asInstanceOf</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1075736">b</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1075737">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span title="PatternMatching.this.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#1069018" title="(tp: PatternMatching.this.global.Type, pt: PatternMatching.this.global.Type)Boolean">typesConform</a><span class="delimiter">(</span><a href="#1075736" title="PatternMatching.this.global.Symbol">b</a>.<a href="../../../reflect/internal/Symbols.scala.html#411367" title="=&gt; PatternMatching.this.global.Type">info</a>, <a href="#1075737" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1075736" title="PatternMatching.this.global.Symbol">b</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#1075541" title="(t: PatternMatching.this.global.Tree, tp: PatternMatching.this.global.Type)PatternMatching.this.global.Typed">mkCast</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1075736" title="PatternMatching.this.global.Symbol">b</a><span class="delimiter">)</span>, <a href="#1075737" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(b: PatternMatching.this.global.Symbol, tp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree" id="1075544">_isInstanceOf</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1075744">b</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1075745">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="../Global.scala.html#537460" title="PatternMatching.this.global.gen.type">gen</a>.<a href="../../../reflect/internal/TreeGen.scala.html#471004" title="(value: PatternMatching.this.global.gen.global.Tree, tpe: PatternMatching.this.global.gen.global.Type, any: Boolean, wrapInApply: Boolean)PatternMatching.this.global.gen.global.Tree">mkIsInstanceOf</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1075744" title="PatternMatching.this.global.Symbol">b</a><span class="delimiter">)</span>, <a href="#1075745" title="PatternMatching.this.global.Type">tp</a>.<a href="../../../reflect/internal/Types.scala.html#408510" title="=&gt; PatternMatching.this.global.Type">withoutAnnotations</a>, <span title="Boolean(true)" class="keyword">true</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      //   if (typesConform(b.info, tpX)) { patmatDebug(&quot;warning: emitted spurious isInstanceOf: &quot;+(b, tp)); TRUE }

      // duplicated out of frustration with cast generation
      <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree" id="1075545">mkZero</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1075753">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
        <a href="#1075753" title="PatternMatching.this.global.Type">tp</a>.<a href="../../../reflect/internal/Types.scala.html#408407" title="=&gt; PatternMatching.this.global.Symbol">typeSymbol</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="../../../reflect/internal/Definitions.scala.html#409353" title="PatternMatching.this.global.Tree" id="3368876">UnitClass</a>    =&gt; <a href="../../../reflect/internal/Trees.scala.html#413609" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.Literal">Literal</a><a href="#3368895" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="../../../reflect/internal/Definitions.scala.html#409369" title="PatternMatching.this.global.Tree" id="3368877">BooleanClass</a> =&gt; <a href="../../../reflect/internal/Trees.scala.html#413609" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.Literal">Literal</a><a href="#3368895" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="../../../reflect/internal/Definitions.scala.html#409365" title="PatternMatching.this.global.Tree" id="3368878">FloatClass</a>   =&gt; <a href="../../../reflect/internal/Trees.scala.html#413609" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.Literal">Literal</a><a href="#3368895" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Float(0.0)" class="float">0.0f</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="../../../reflect/internal/Definitions.scala.html#409367" title="PatternMatching.this.global.Tree" id="3368879">DoubleClass</a>  =&gt; <a href="../../../reflect/internal/Trees.scala.html#413609" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.Literal">Literal</a><a href="#3368895" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Double(0.0)" class="double">0.0d</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="../../../reflect/internal/Definitions.scala.html#409355" title="PatternMatching.this.global.Tree" id="3368880">ByteClass</a>    =&gt; <a href="../../../reflect/internal/Trees.scala.html#413609" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.Literal">Literal</a><a href="#3368895" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>.<a href="../../../Int.scala.html#57077" title="=&gt; Byte">toByte</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="../../../reflect/internal/Definitions.scala.html#409357" title="PatternMatching.this.global.Tree" id="3368881">ShortClass</a>   =&gt; <a href="../../../reflect/internal/Trees.scala.html#413609" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.Literal">Literal</a><a href="#3368895" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>.<a href="../../../Int.scala.html#57078" title="=&gt; Short">toShort</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="../../../reflect/internal/Definitions.scala.html#409361" title="PatternMatching.this.global.Tree" id="3368882">IntClass</a>     =&gt; <a href="../../../reflect/internal/Trees.scala.html#413609" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.Literal">Literal</a><a href="#3368895" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="../../../reflect/internal/Definitions.scala.html#409363" title="PatternMatching.this.global.Tree" id="3368883">LongClass</a>    =&gt; <a href="../../../reflect/internal/Trees.scala.html#413609" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.Literal">Literal</a><a href="#3368895" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Long(0L)" class="long">0L</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="../../../reflect/internal/Definitions.scala.html#409359" title="PatternMatching.this.global.Tree" id="3368884">CharClass</a>    =&gt; <a href="../../../reflect/internal/Trees.scala.html#413609" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.Literal">Literal</a><a href="#3368895" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>.<a href="../../../Int.scala.html#57079" title="=&gt; Char">toChar</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> _            =&gt; <a href="../Global.scala.html#537460" title="PatternMatching.this.global.gen.type">gen</a>.<a href="../../../reflect/internal/TreeGen.scala.html#471005" title="(value: PatternMatching.this.global.gen.global.Tree, tpe: PatternMatching.this.global.gen.global.Type, any: Boolean, wrapInApply: Boolean)PatternMatching.this.global.gen.global.Tree">mkAsInstanceOf</a><a href="#3368895" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#413609" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.Literal">Literal</a><span class="delimiter">(</span><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#1075753" title="PatternMatching.this.global.Type">tp</a>, any = <span title="Boolean(true)" class="keyword">true</span>, wrapInApply = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> // the magic incantation is true/false here
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait PureMatchMonadInterface extends Object with PatternMatching.this.MatchMonadInterface" id="621390">PureMatchMonadInterface</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621385" title="PatternMatching.this.MatchMonadInterface">MatchMonadInterface</a> <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="=&gt; PatternMatching.this.global.Tree" id="1069452">matchStrategy</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>

    <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type" id="1069453">inMatchMonad</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1075757">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a> = <a href="../../../reflect/internal/Types.scala.html#407408" title="(tycon: PatternMatching.this.global.Type, args: List[PatternMatching.this.global.Type])PatternMatching.this.global.Type">appliedType</a><span class="delimiter">(</span><a href="#1069458" title="=&gt; PatternMatching.this.global.Type">oneSig</a>, <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Type*)List[PatternMatching.this.global.Type]">List</a><span class="delimiter">(</span><a href="#1075757" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../reflect/internal/Types.scala.html#408427" title="=&gt; PatternMatching.this.global.Type">finalResultType</a>
    <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type" id="1069454">pureType</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1075776">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>     = <a href="../../../reflect/internal/Types.scala.html#407408" title="(tycon: PatternMatching.this.global.Type, args: List[PatternMatching.this.global.Type])PatternMatching.this.global.Type">appliedType</a><span class="delimiter">(</span><a href="#1069458" title="=&gt; PatternMatching.this.global.Type">oneSig</a>, <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Type*)List[PatternMatching.this.global.Type]">List</a><span class="delimiter">(</span><a href="#1075776" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../reflect/internal/Types.scala.html#408431" title="=&gt; List[PatternMatching.this.global.Type]">paramTypes</a>.<a href="../../../collection/TraversableLike.scala.html#58103" title="=&gt; Option[PatternMatching.this.global.Type]">headOption</a> <a href="../../../Option.scala.html#62859" title="(default: =&gt; PatternMatching.this.global.Type)PatternMatching.this.global.Type">getOrElse</a> <a href="../../../reflect/internal/Types.scala.html#407284" title="PatternMatching.this.global.NoType.type">NoType</a> // fail gracefully (otherwise we get crashes)
    <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Symbol" id="1069455">matchMonadSym</a>      = <a href="#1069458" title="=&gt; PatternMatching.this.global.Type">oneSig</a>.<a href="../../../reflect/internal/Types.scala.html#408427" title="=&gt; PatternMatching.this.global.Type">finalResultType</a>.<a href="../../../reflect/internal/Types.scala.html#408407" title="=&gt; PatternMatching.this.global.Symbol">typeSymbol</a>

    <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._
    <span class="keyword">def</span> <a title="(n: PatternMatching.this.global.Name)PatternMatching.this.CODE.SelectStart" id="1069457">_match</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Name" id="1075799">n</a>: <a href="../../../reflect/internal/Names.scala.html#406868" title="PatternMatching.this.global.Name">Name</a><span class="delimiter">)</span>: <a href="../ast/TreeDSL.scala.html#624569" title="PatternMatching.this.CODE.SelectStart">SelectStart</a> = <a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods">matchStrategy</a> <a href="../ast/TreeDSL.scala.html#662339" title="(member: PatternMatching.this.global.Name)PatternMatching.this.CODE.SelectStart">DOT</a> <a href="#1075799" title="PatternMatching.this.global.Name">n</a>

    <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1069459">oneSig</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a> =
      <a href="#1068979" title="=&gt; PatternMatching.this.global.analyzer.Typer">typer</a>.<a href="Typers.scala.html#538698" title="(tree: PatternMatching.this.global.analyzer.global.Tree, mode: Int, pt: PatternMatching.this.global.analyzer.global.Type)PatternMatching.this.global.analyzer.global.Tree">typed</a><span class="delimiter">(</span><a href="#1069457" title="(n: PatternMatching.this.global.Name)PatternMatching.this.CODE.SelectStart">_match</a><a href="../ast/TreeDSL.scala.html#624619" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeFromSelectStart : (ss: PatternMatching.this.CODE.SelectStart)PatternMatching.this.global.Select" class="delimiter">(</a><a href="#621381" title="PatternMatching.this.vpmName.type">vpmName</a>.<a href="#1069363" title="=&gt; PatternMatching.this.global.TermName">one</a><span class="delimiter">)</span>, EXPRmode | POLYmode | TAPPmode <span title="Int(177)">|</span> FUNmode, <a href="../../../reflect/internal/Types.scala.html#407279" title="PatternMatching.this.global.WildcardType.type">WildcardType</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.analyzer.global.Type">tpe</a>  // TODO: error message
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait PureCodegen extends Object with PatternMatching.this.CodegenCore with PatternMatching.this.PureMatchMonadInterface" id="621391">PureCodegen</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621389" title="PatternMatching.this.CodegenCore">CodegenCore</a> <span class="keyword">with</span> <a href="#621390" title="PatternMatching.this.PureMatchMonadInterface">PureMatchMonadInterface</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; PureCodegen.this.AbsCodegen" id="1069448">codegen</a>: <a href="#1069015" title="PureCodegen.this.AbsCodegen">AbsCodegen</a> = <a href="#1069449" title="PureCodegen.this.pureCodegen.type">pureCodegen</a>

    <span class="keyword">object</span> <a title="PureCodegen.this.pureCodegen.type" id="1069449">pureCodegen</a> <a href="#1069450" title="PureCodegen.this.pureCodegen.type" class="keyword">extends</a> <a href="#1069020" title="PureCodegen.this.CommonCodegen">CommonCodegen</a> <span class="keyword">with</span> <a href="#1069016" title="PureCodegen.this.Casegen">Casegen</a> <span class="delimiter">{</span> <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._
      //// methods in MatchingStrategy (the monad companion) -- used directly in translation
      // __match.runOrElse(`scrut`)(`scrutSym` =&gt; `matcher`)
      // TODO: consider catchAll, or virtualized matching will break in exception handlers
      <span class="keyword">def</span> <a title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, restpe: PatternMatching.this.global.Type)(cases: List[PureCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree], matchFailGen: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree])PatternMatching.this.global.Tree" id="1075839">matcher</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1075848">scrut</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1075849">scrutSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1075850">restpe</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="List[PureCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree]" id="1075851">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PureCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Casegen =&gt; Tree<span class="delimiter">]</span>, <a title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]" id="1075852">matchFailGen</a>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree =&gt; Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> =
        <a href="#1069457" title="(n: PatternMatching.this.global.Name)PatternMatching.this.CODE.SelectStart">_match</a><a href="../ast/TreeDSL.scala.html#624620" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethodsFromSelectStart : (ss: PatternMatching.this.CODE.SelectStart)PatternMatching.this.CODE.TreeMethods" class="delimiter">(</a><a href="#621381" title="PatternMatching.this.vpmName.type">vpmName</a>.<a href="#1069379" title="=&gt; PatternMatching.this.global.TermName">runOrElse</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods">APPLY</a> <span class="delimiter">(</span><a href="#1075848" title="PatternMatching.this.global.Tree">scrut</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#662336" title="(params: PatternMatching.this.global.Tree*)PatternMatching.this.global.Apply">APPLY</a> <span class="delimiter">(</span><a href="#1075534" title="(arg: PatternMatching.this.global.Symbol, body: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">fun</a><span class="delimiter">(</span><a href="#1075849" title="PatternMatching.this.global.Symbol">scrutSym</a>, <a href="#1075851" title="List[PureCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree]">cases</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: (PureCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree) =&gt; PatternMatching.this.global.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[PureCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree],PatternMatching.this.global.Tree,List[PatternMatching.this.global.Tree]])List[PatternMatching.this.global.Tree]">map</a> <span class="delimiter">(</span><a title="PureCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree" id="1075894">f</a> =&gt; <a href="../../../Function1.scala.html#58642" title="(v1: PureCodegen.this.Casegen)PatternMatching.this.global.Tree">f</a><span class="delimiter">(</span><span class="keyword">this</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../collection/LinearSeqOptimized.scala.html#86388" title="(f: (PatternMatching.this.global.Tree, PatternMatching.this.global.Tree) =&gt; PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">reduceLeft</a> <a href="#1075844" title="(thisCase: PatternMatching.this.global.Tree, elseCase: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">typedOrElse</a><span class="delimiter">)</span><span class="delimiter">)</span>

      // __match.one(`res`)
      <span class="keyword">def</span> <a title="(res: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1075840">one</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1075944">res</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">(</span><a href="#1069457" title="(n: PatternMatching.this.global.Name)PatternMatching.this.CODE.SelectStart">_match</a><a href="../ast/TreeDSL.scala.html#662306" title="(args: PatternMatching.this.global.Tree*)PatternMatching.this.global.Apply" class="delimiter">(</a><a href="#621381" title="PatternMatching.this.vpmName.type">vpmName</a>.<a href="#1069363" title="=&gt; PatternMatching.this.global.TermName">one</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">(</span><a href="#1075944" title="PatternMatching.this.global.Tree">res</a><span class="delimiter">)</span>
      // __match.zero
      <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Tree" id="1075841">zero</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="#1069457" title="(n: PatternMatching.this.global.Name)PatternMatching.this.CODE.SelectStart">_match</a><a href="../ast/TreeDSL.scala.html#624619" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeFromSelectStart : (ss: PatternMatching.this.CODE.SelectStart)PatternMatching.this.global.Select" class="delimiter">(</a><a href="#621381" title="PatternMatching.this.vpmName.type">vpmName</a>.<a href="#1069381" title="=&gt; PatternMatching.this.global.TermName">zero</a><span class="delimiter">)</span>
      // __match.guard(`c`, `then`)
      <span class="keyword">def</span> <a title="(c: PatternMatching.this.global.Tree, then: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1075842">guard</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1075948">c</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Tree" id="1075949">then</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="#1069457" title="(n: PatternMatching.this.global.Name)PatternMatching.this.CODE.SelectStart">_match</a><a href="../ast/TreeDSL.scala.html#624620" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethodsFromSelectStart : (ss: PatternMatching.this.CODE.SelectStart)PatternMatching.this.CODE.TreeMethods" class="delimiter">(</a><a href="#621381" title="PatternMatching.this.vpmName.type">vpmName</a>.<a href="#1069371" title="=&gt; PatternMatching.this.global.TermName">guard</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#662336" title="(params: PatternMatching.this.global.Tree*)PatternMatching.this.global.Apply">APPLY</a> <span class="delimiter">(</span><a href="#1075948" title="PatternMatching.this.global.Tree">c</a>, <a href="#1075949" title="PatternMatching.this.global.Tree">then</a><span class="delimiter">)</span>

      //// methods in the monad instance -- used directly in translation
      // `prev`.flatMap(`b` =&gt; `next`)
      <span class="keyword">def</span> <a title="(prev: PatternMatching.this.global.Tree, b: PatternMatching.this.global.Symbol, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1075843">flatMap</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1075960">prev</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1075961">b</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Tree" id="1075962">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods">prev</a> <a href="../ast/TreeDSL.scala.html#662306" title="(args: PatternMatching.this.global.Tree*)PatternMatching.this.global.Apply">DOT</a> <a href="#621381" title="PatternMatching.this.vpmName.type">vpmName</a>.<a href="#1069367" title="=&gt; PatternMatching.this.global.TermName">flatMap</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1075534" title="(arg: PatternMatching.this.global.Symbol, body: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">fun</a><span class="delimiter">(</span><a href="#1075961" title="PatternMatching.this.global.Symbol">b</a>, <a href="#1075962" title="PatternMatching.this.global.Tree">next</a><span class="delimiter">)</span><span class="delimiter">)</span>
      // `thisCase`.orElse(`elseCase`)
      <span class="keyword">def</span> <a title="(thisCase: PatternMatching.this.global.Tree, elseCase: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1075844">typedOrElse</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1075937">thisCase</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Tree" id="1075938">elseCase</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods">thisCase</a> <a href="../ast/TreeDSL.scala.html#624620" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethodsFromSelectStart : (ss: PatternMatching.this.CODE.SelectStart)PatternMatching.this.CODE.TreeMethods">DOT</a> <a href="#621381" title="PatternMatching.this.vpmName.type">vpmName</a>.<a href="#1069375" title="=&gt; PatternMatching.this.global.TermName">orElse</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#662336" title="(params: PatternMatching.this.global.Tree*)PatternMatching.this.global.Apply">APPLY</a> <span class="delimiter">(</span><a href="#1075938" title="PatternMatching.this.global.Tree">elseCase</a><span class="delimiter">)</span>
      //  __match.guard(`cond`, `res`).flatMap(`nextBinder` =&gt; `next`)
      <span class="keyword">def</span> <a title="(cond: PatternMatching.this.global.Tree, res: PatternMatching.this.global.Tree, nextBinder: PatternMatching.this.global.Symbol, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1075845">flatMapCond</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1075997">cond</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Tree" id="1075998">res</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1075999">nextBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Tree" id="1076000">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="#1075843" title="(prev: PatternMatching.this.global.Tree, b: PatternMatching.this.global.Symbol, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">flatMap</a><span class="delimiter">(</span><a href="#1075842" title="(c: PatternMatching.this.global.Tree, then: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">guard</a><span class="delimiter">(</span><a href="#1075997" title="PatternMatching.this.global.Tree">cond</a>, <a href="#1075998" title="PatternMatching.this.global.Tree">res</a><span class="delimiter">)</span>, <a href="#1075999" title="PatternMatching.this.global.Symbol">nextBinder</a>, <a href="#1076000" title="PatternMatching.this.global.Tree">next</a><span class="delimiter">)</span>
      //  __match.guard(`guardTree`, ()).flatMap((_: P[Unit]) =&gt; `next`)
      <span class="keyword">def</span> <a title="(guardTree: PatternMatching.this.global.Tree, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1075846">flatMapGuard</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1076002">guardTree</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Tree" id="1076003">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="#1075845" title="(cond: PatternMatching.this.global.Tree, res: PatternMatching.this.global.Tree, nextBinder: PatternMatching.this.global.Symbol, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">flatMapCond</a><span class="delimiter">(</span><a href="#1076002" title="PatternMatching.this.global.Tree">guardTree</a>, <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624561" title="=&gt; PatternMatching.this.global.Literal">UNIT</a>, <a href="#1069013" title="(pos: PatternMatching.this.global.Position, tp: PatternMatching.this.global.Type, prefix: String)PatternMatching.this.global.TermSymbol">freshSym</a><span class="delimiter">(</span><a href="#1076002" title="PatternMatching.this.global.Tree">guardTree</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a>, <a href="#1069454" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">pureType</a><span class="delimiter">(</span><a href="../../../reflect/internal/Definitions.scala.html#409353" title="=&gt; PatternMatching.this.global.ClassSymbol">UnitClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#1076003" title="PatternMatching.this.global.Tree">next</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// OPTIMIZATIONS
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// decisions, decisions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  <span class="keyword">trait</span> <a title="trait TreeMakerApproximation extends Object with PatternMatching.this.TreeMakers with PatternMatching.this.Prettification" id="621392">TreeMakerApproximation</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621388" title="PatternMatching.this.TreeMakers">TreeMakers</a> <span class="keyword">with</span> <a href="#621393" title="PatternMatching.this.Prettification">Prettification</a><span class="delimiter">{</span> self: CodegenCore =&gt;
    <span class="keyword">object</span> <a title="TreeMakerApproximation.this.Test.type" id="1076061">Test</a> <a href="#1069132" title="TreeMakerApproximation.this.Test.type" class="delimiter">{</a>
      <span class="keyword">var</span> <a title="Int" id="1076010">currId</a> = <span title="Int(0)" class="int">0</span>
    <span class="delimiter">}</span>
    case <span class="keyword">class</span> <a title="(cond: TreeMakerApproximation.this.Cond, treeMaker: TreeMakerApproximation.this.TreeMaker)TreeMakerApproximation.this.Test" id="1076105">Test</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="TreeMakerApproximation.this.Cond" id="1076087">cond</a>: <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a>, <a title="TreeMakerApproximation.this.TreeMaker" id="1076088">treeMaker</a>: <a href="#1069034" title="TreeMakerApproximation.this.TreeMaker">TreeMaker</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      // private val reusedBy = new scala.collection.mutable.HashSet[Test]
      <span class="keyword">var</span> <a title="Option[TreeMakerApproximation.this.Test]" id="1076021">reuses</a>: <a href="../../../Option.scala.html#978" title="Option[TreeMakerApproximation.this.Test]">Option</a><span class="delimiter">[</span>Test<span class="delimiter">]</span> = <a href="../../../Option.scala.html#1585" title="None.type">None</a>
      <span class="keyword">def</span> <a title="(later: TreeMakerApproximation.this.Test)Unit" id="1076023">registerReuseBy</a><span class="delimiter">(</span><a title="TreeMakerApproximation.this.Test" id="1076072">later</a>: <a href="#1076105" title="TreeMakerApproximation.this.Test">Test</a><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#1515" title="Unit">Unit</a> = <span class="delimiter">{</span>
        <a href="../Global.scala.html#537497" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#1076072" title="TreeMakerApproximation.this.Test">later</a>.<a href="#1076021" title="=&gt; Option[TreeMakerApproximation.this.Test]">reuses</a>.<a href="../../../Option.scala.html#62856" title="=&gt; Boolean">isEmpty</a>, <a href="#1076072" title="TreeMakerApproximation.this.Test">later</a>.<a href="#1076021" title="=&gt; Option[TreeMakerApproximation.this.Test]">reuses</a><span class="delimiter">)</span>
        // reusedBy += later
        <a href="#1076072" title="TreeMakerApproximation.this.Test">later</a>.<a href="#1076021" title="(x$1: Option[TreeMakerApproximation.this.Test])Unit">reuses</a> = <a href="../../../Option.scala.html#63128" title="(x: TreeMakerApproximation.this.Test)Some[TreeMakerApproximation.this.Test]">Some</a><span class="delimiter">(</span><a href="#1076105" title="TreeMakerApproximation.this.Test" class="keyword">this</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="keyword">val</span> <a title="Int" id="1076024">id</a> = <span class="delimiter">{</span> <a href="#1076061" title="TreeMakerApproximation.this.Test.type">Test</a>.<a href="#1076010" title="(x$1: Int)Unit">currId</a> <a href="../../../Int.scala.html#57154" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>; <a href="#1076061" title="TreeMakerApproximation.this.Test.type">Test</a>.<a href="#1076010" title="=&gt; Int">currId</a><span class="delimiter">}</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1076026">toString</a> =
        <span title="String(&quot;T&quot;)" class="string">&quot;T&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1076024" title="=&gt; Int">id</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;C(&quot;)" class="string">&quot;C(&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1076087" title="=&gt; TreeMakerApproximation.this.Cond">cond</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>  //+ (reuses map (&quot;== T&quot;+_.id) getOrElse (if(reusedBy.isEmpty) treeMaker else reusedBy mkString (treeMaker+ &quot; --&gt;(&quot;, &quot;, &quot;,&quot;)&quot;)))
    <span class="delimiter">}</span>

    // TODO: remove Cond, replace by Prop from Logic
    <span class="keyword">object</span> <a title="TreeMakerApproximation.this.Cond.type" id="1069134">Cond</a> <a href="#1069135" title="TreeMakerApproximation.this.Cond.type" class="delimiter">{</a>
      <span class="keyword">var</span> <a title="Int" id="1076121">currId</a> = <span title="Int(0)" class="int">0</span>
    <span class="delimiter">}</span>

    <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Cond extends Object" id="1069136">Cond</a> <a href="#1069136" title="TreeMakerApproximation.this.Cond" class="delimiter">{</a>
      <span class="keyword">val</span> <a title="Int" id="1076037">id</a> = <span class="delimiter">{</span> <a href="#1069134" title="TreeMakerApproximation.this.Cond.type">Cond</a>.<a href="#1076121" title="(x$1: Int)Unit">currId</a> <a href="../../../Int.scala.html#57154" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>; <a href="#1069134" title="TreeMakerApproximation.this.Cond.type">Cond</a>.<a href="#1076121" title="=&gt; Int">currId</a><span class="delimiter">}</span>
    <span class="delimiter">}</span>

    case <span class="keyword">object</span> <a href="#1076141" title="TreeMakerApproximation.this.TrueCond.type" id="1076148">TrueCond</a> <a href="../../../Product.scala.html#186" title="Product" class="keyword">extends</a> <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a>  <span class="delimiter">{</span><span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1076133">toString</a> = <span title="String(&quot;T&quot;)" class="string">&quot;T&quot;</span><span class="delimiter">}</span>
    case <span class="keyword">object</span> <a href="#1076158" title="TreeMakerApproximation.this.FalseCond.type" id="1076165">FalseCond</a> <a href="../../../Product.scala.html#186" title="Product" class="keyword">extends</a> <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a> <span class="delimiter">{</span><span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1076150">toString</a> = <span title="String(&quot;F&quot;)" class="string">&quot;F&quot;</span><span class="delimiter">}</span>

    case <span class="keyword">class</span> <a title="class AndCond extends TreeMakerApproximation.this.Cond with Product with Serializable" id="1077436">AndCond</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="TreeMakerApproximation.this.Cond" id="1076546">a</a>: <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a>, <a title="TreeMakerApproximation.this.Cond" id="1076547">b</a>: <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a> <span class="delimiter">{</span><span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1076173">toString</a> = <a href="../../../Predef.scala.html#7605" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">a</a> <a href="../../../runtime/StringAdd.scala.html#60046" title="(other: String)String">+</a><span title="String(&quot;/\\&quot;)" class="string">&quot;/\\&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1076547" title="=&gt; TreeMakerApproximation.this.Cond">b</a><span class="delimiter">}</span>
    case <span class="keyword">class</span> <a title="class OrCond extends TreeMakerApproximation.this.Cond with Product with Serializable" id="1077462">OrCond</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="TreeMakerApproximation.this.Cond" id="1076567">a</a>: <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a>, <a title="TreeMakerApproximation.this.Cond" id="1076568">b</a>: <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a><span class="delimiter">)</span>  <span class="keyword">extends</span> <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a> <span class="delimiter">{</span><span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1076228">toString</a> = <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span><span title="(x$1: Any)String">+</span><a href="#1076567" title="=&gt; TreeMakerApproximation.this.Cond">a</a><span title="(x$1: Any)String">+</span><span title="String(&quot;) \\/ (&quot;)" class="string">&quot;) \\/ (&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1076568" title="=&gt; TreeMakerApproximation.this.Cond">b</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">}</span>

    <span class="keyword">object</span> <a title="TreeMakerApproximation.this.EqualityCond.type" id="1069147">EqualityCond</a> <a href="#1069148" title="TreeMakerApproximation.this.EqualityCond.type" class="delimiter">{</a>
      <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree),TreeMakerApproximation.this.EqualityCond]" id="1076275">uniques</a> = <a href="../../../collection/mutable/HashMap.scala.html#88242" title="()scala.collection.mutable.HashMap[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree),TreeMakerApproximation.this.EqualityCond]" class="keyword">new</a> scala.collection.mutable.<a href="../../../collection/mutable/HashMap.scala.html#12447" title="scala.collection.mutable.HashMap[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree),TreeMakerApproximation.this.EqualityCond]">HashMap</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span>, EqualityCond<span class="delimiter">]</span>
      <span class="keyword">def</span> <a title="(testedPath: PatternMatching.this.global.Tree, rhs: PatternMatching.this.global.Tree)TreeMakerApproximation.this.EqualityCond" id="1076277">apply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1076291">testedPath</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Tree" id="1076292">rhs</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="#1069149" title="TreeMakerApproximation.this.EqualityCond">EqualityCond</a> = <a href="#1076275" title="=&gt; scala.collection.mutable.HashMap[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree),TreeMakerApproximation.this.EqualityCond]">uniques</a> <a href="../../../collection/mutable/MapLike.scala.html#87629" title="(key: (PatternMatching.this.global.Tree, PatternMatching.this.global.Tree), op: =&gt; TreeMakerApproximation.this.EqualityCond)TreeMakerApproximation.this.EqualityCond">getOrElseUpdate</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Tree, _2: PatternMatching.this.global.Tree)(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)" class="delimiter">(</a><a href="#1076291" title="PatternMatching.this.global.Tree">testedPath</a>, <a href="#1076292" title="PatternMatching.this.global.Tree">rhs</a><span class="delimiter">)</span>, <span title="TreeMakerApproximation.this.EqualityCond" class="keyword">new</span> <a href="#1069149" title="TreeMakerApproximation.this.EqualityCond">EqualityCond</a><span class="delimiter">(</span><a href="#1076291" title="PatternMatching.this.global.Tree">testedPath</a>, <a href="#1076292" title="PatternMatching.this.global.Tree">rhs</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(c: TreeMakerApproximation.this.EqualityCond)Some[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]" id="1076278">unapply</a><span class="delimiter">(</span><a title="TreeMakerApproximation.this.EqualityCond" id="1076301">c</a>: <a href="#1069149" title="TreeMakerApproximation.this.EqualityCond">EqualityCond</a><span class="delimiter">)</span> = <a href="../../../Option.scala.html#63128" title="(x: (PatternMatching.this.global.Tree, PatternMatching.this.global.Tree))Some[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]">Some</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Tree, _2: PatternMatching.this.global.Tree)(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)" class="delimiter">(</a><a href="#1076301" title="TreeMakerApproximation.this.EqualityCond">c</a>.<a href="#1076287" title="=&gt; PatternMatching.this.global.Tree">testedPath</a>, <a href="#1076301" title="TreeMakerApproximation.this.EqualityCond">c</a>.<a href="#1076288" title="=&gt; PatternMatching.this.global.Tree">rhs</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">class</span> <a title="class EqualityCond extends TreeMakerApproximation.this.Cond" id="1069149">EqualityCond</a><a href="#1069149" title="TreeMakerApproximation.this.EqualityCond" class="delimiter">(</a><span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1076287">testedPath</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1076288">rhs</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1076286">toString</a> = <a href="../../../Predef.scala.html#7605" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">testedPath</a> <a href="../../../runtime/StringAdd.scala.html#60046" title="(other: String)String">+</a><span title="String(&quot; == &quot;)" class="string">&quot; == &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1076288" title="=&gt; PatternMatching.this.global.Tree">rhs</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1076037" title="=&gt; Int">id</a>
    <span class="delimiter">}</span>

    <span class="keyword">object</span> <a title="TreeMakerApproximation.this.NonNullCond.type" id="1069150">NonNullCond</a> <a href="#1069151" title="TreeMakerApproximation.this.NonNullCond.type" class="delimiter">{</a>
      <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[PatternMatching.this.global.Tree,TreeMakerApproximation.this.NonNullCond]" id="1076320">uniques</a> = <a href="../../../collection/mutable/HashMap.scala.html#88242" title="()scala.collection.mutable.HashMap[PatternMatching.this.global.Tree,TreeMakerApproximation.this.NonNullCond]" class="keyword">new</a> scala.collection.mutable.<a href="../../../collection/mutable/HashMap.scala.html#12447" title="scala.collection.mutable.HashMap[PatternMatching.this.global.Tree,TreeMakerApproximation.this.NonNullCond]">HashMap</a><span class="delimiter">[</span>Tree, NonNullCond<span class="delimiter">]</span>
      <span class="keyword">def</span> <a title="(testedPath: PatternMatching.this.global.Tree)TreeMakerApproximation.this.NonNullCond" id="1076322">apply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1076332">testedPath</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="#1069152" title="TreeMakerApproximation.this.NonNullCond">NonNullCond</a> = <a href="#1076320" title="=&gt; scala.collection.mutable.HashMap[PatternMatching.this.global.Tree,TreeMakerApproximation.this.NonNullCond]">uniques</a> <a href="../../../collection/mutable/MapLike.scala.html#87629" title="(key: PatternMatching.this.global.Tree, op: =&gt; TreeMakerApproximation.this.NonNullCond)TreeMakerApproximation.this.NonNullCond">getOrElseUpdate</a><span class="delimiter">(</span><a href="#1076332" title="PatternMatching.this.global.Tree">testedPath</a>, <span title="TreeMakerApproximation.this.NonNullCond" class="keyword">new</span> <a href="#1069152" title="TreeMakerApproximation.this.NonNullCond">NonNullCond</a><span class="delimiter">(</span><a href="#1076332" title="PatternMatching.this.global.Tree">testedPath</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(c: TreeMakerApproximation.this.NonNullCond)Some[PatternMatching.this.global.Tree]" id="1076323">unapply</a><span class="delimiter">(</span><a title="TreeMakerApproximation.this.NonNullCond" id="1076335">c</a>: <a href="#1069152" title="TreeMakerApproximation.this.NonNullCond">NonNullCond</a><span class="delimiter">)</span> = <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.Tree)Some[PatternMatching.this.global.Tree]">Some</a><span class="delimiter">(</span><a href="#1076335" title="TreeMakerApproximation.this.NonNullCond">c</a>.<a href="#1076329" title="=&gt; PatternMatching.this.global.Tree">testedPath</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">class</span> <a title="class NonNullCond extends TreeMakerApproximation.this.Cond" id="1069152">NonNullCond</a><a href="#1069152" title="TreeMakerApproximation.this.NonNullCond" class="delimiter">(</a><span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1076329">testedPath</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1076328">toString</a> = <a href="../../../Predef.scala.html#7605" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">testedPath</a> <a href="../../../runtime/StringAdd.scala.html#60046" title="(other: String)String">+</a><span title="String(&quot; ne null &quot;)" class="string">&quot; ne null &quot;</span> <span title="(x$1: Any)String">+</span><span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1076037" title="=&gt; Int">id</a>
    <span class="delimiter">}</span>

    <span class="keyword">object</span> <a title="TreeMakerApproximation.this.TypeCond.type" id="1069153">TypeCond</a> <a href="#1069154" title="TreeMakerApproximation.this.TypeCond.type" class="delimiter">{</a>
      <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[(PatternMatching.this.global.Tree, PatternMatching.this.global.Type),TreeMakerApproximation.this.TypeCond]" id="1076347">uniques</a> = <a href="../../../collection/mutable/HashMap.scala.html#88242" title="()scala.collection.mutable.HashMap[(PatternMatching.this.global.Tree, PatternMatching.this.global.Type),TreeMakerApproximation.this.TypeCond]" class="keyword">new</a> scala.collection.mutable.<a href="../../../collection/mutable/HashMap.scala.html#12447" title="scala.collection.mutable.HashMap[(PatternMatching.this.global.Tree, PatternMatching.this.global.Type),TreeMakerApproximation.this.TypeCond]">HashMap</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Type<span class="delimiter">)</span>, TypeCond<span class="delimiter">]</span>
      <span class="keyword">def</span> <a title="(testedPath: PatternMatching.this.global.Tree, pt: PatternMatching.this.global.Type)TreeMakerApproximation.this.TypeCond" id="1076349">apply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1076363">testedPath</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Type" id="1076364">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="#1069155" title="TreeMakerApproximation.this.TypeCond">TypeCond</a> = <a href="#1076347" title="=&gt; scala.collection.mutable.HashMap[(PatternMatching.this.global.Tree, PatternMatching.this.global.Type),TreeMakerApproximation.this.TypeCond]">uniques</a> <a href="../../../collection/mutable/MapLike.scala.html#87629" title="(key: (PatternMatching.this.global.Tree, PatternMatching.this.global.Type), op: =&gt; TreeMakerApproximation.this.TypeCond)TreeMakerApproximation.this.TypeCond">getOrElseUpdate</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Tree, _2: PatternMatching.this.global.Type)(PatternMatching.this.global.Tree, PatternMatching.this.global.Type)" class="delimiter">(</a><a href="#1076363" title="PatternMatching.this.global.Tree">testedPath</a>, <a href="#1076364" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span>, <span title="TreeMakerApproximation.this.TypeCond" class="keyword">new</span> <a href="#1069155" title="TreeMakerApproximation.this.TypeCond">TypeCond</a><span class="delimiter">(</span><a href="#1076363" title="PatternMatching.this.global.Tree">testedPath</a>, <a href="#1076364" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(c: TreeMakerApproximation.this.TypeCond)Some[(PatternMatching.this.global.Tree, PatternMatching.this.global.Type)]" id="1076350">unapply</a><span class="delimiter">(</span><a title="TreeMakerApproximation.this.TypeCond" id="1076373">c</a>: <a href="#1069155" title="TreeMakerApproximation.this.TypeCond">TypeCond</a><span class="delimiter">)</span> = <a href="../../../Option.scala.html#63128" title="(x: (PatternMatching.this.global.Tree, PatternMatching.this.global.Type))Some[(PatternMatching.this.global.Tree, PatternMatching.this.global.Type)]">Some</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Tree, _2: PatternMatching.this.global.Type)(PatternMatching.this.global.Tree, PatternMatching.this.global.Type)" class="delimiter">(</a><a href="#1076373" title="TreeMakerApproximation.this.TypeCond">c</a>.<a href="#1076359" title="=&gt; PatternMatching.this.global.Tree">testedPath</a>, <a href="#1076373" title="TreeMakerApproximation.this.TypeCond">c</a>.<a href="#1076360" title="=&gt; PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">class</span> <a title="class TypeCond extends TreeMakerApproximation.this.Cond" id="1069155">TypeCond</a><a href="#1069155" title="TreeMakerApproximation.this.TypeCond" class="delimiter">(</a><span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1076359">testedPath</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1076360">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1076358">toString</a> = <a href="../../../Predef.scala.html#7605" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">testedPath</a> <a href="../../../runtime/StringAdd.scala.html#60046" title="(other: String)String">+</a><span title="String(&quot; : &quot;)" class="string">&quot; : &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1076360" title="=&gt; PatternMatching.this.global.Type">pt</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1076037" title="=&gt; Int">id</a>
    <span class="delimiter">}</span>

//    class OuterEqCond(val testedPath: Tree, val expectedType: Type) extends Cond {
//      val expectedOuter = expectedTp.prefix match {
//        case ThisType(clazz)  =&gt; THIS(clazz)
//        case pre              =&gt; REF(pre.prefix, pre.termSymbol)
//      }
//
//      // ExplicitOuter replaces `Select(q, outerSym) OBJ_EQ expectedPrefix` by `Select(q, outerAccessor(outerSym.owner)) OBJ_EQ expectedPrefix`
//      // if there's an outer accessor, otherwise the condition becomes `true` -- TODO: can we improve needsOuterTest so there's always an outerAccessor?
//      val outer = expectedTp.typeSymbol.newMethod(vpmName.outer) setInfo expectedTp.prefix setFlag SYNTHETIC
//
//      (Select(codegen._asInstanceOf(testedBinder, expectedTp), outer)) OBJ_EQ expectedOuter
//    }

    // TODO: improve, e.g., for constants
    <span class="keyword">def</span> <a title="(a: PatternMatching.this.global.Tree, b: PatternMatching.this.global.Tree)Boolean" id="1069156">sameValue</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1076391">a</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Tree" id="1076392">b</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span class="delimiter">(</span><a href="#1076391" title="PatternMatching.this.global.Tree">a</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#1076392" title="PatternMatching.this.global.Tree">b</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Tree, _2: PatternMatching.this.global.Tree)(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)" class="delimiter">(</a><a href="#1076391" title="PatternMatching.this.global.Tree">a</a>, <a href="#1076392" title="PatternMatching.this.global.Tree">b</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>_ : Ident, _ : Ident<span class="delimiter">)</span> =&gt; <a href="#1076391" title="PatternMatching.this.global.Tree">a</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a> <a href="#3368990" title="(x: Boolean)Boolean">eq</a> <a href="#1076392" title="PatternMatching.this.global.Tree">b</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>
      <span class="keyword">case</span> _                      =&gt; <a href="#3368990" title="(x: Boolean)Boolean" class="keyword">false</a>
    <span class="delimiter">}</span><span class="delimiter">)</span>

    <span class="keyword">object</span> <a title="TreeMakerApproximation.this.IrrefutableExtractorTreeMaker.type" id="1069157">IrrefutableExtractorTreeMaker</a> <a href="#1069158" title="TreeMakerApproximation.this.IrrefutableExtractorTreeMaker.type" class="delimiter">{</a>
      // will an extractor with unapply method of methodtype `tp` always succeed?
      // note: this assumes the other side-conditions implied by the extractor are met
      // (argument of the right type, length check succeeds for unapplySeq,...)
      <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)Boolean" id="1076403">irrefutableExtractorType</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1076406">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <a href="#1076406" title="PatternMatching.this.global.Type">tp</a>.<a href="../../../reflect/internal/Types.scala.html#408423" title="=&gt; PatternMatching.this.global.Type">resultType</a>.<a href="../../../reflect/internal/Types.scala.html#408439" title="=&gt; PatternMatching.this.global.Type">dealias</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> TypeRef<a href="#3368995" title="Boolean" id="3369000" class="delimiter">(</a><a href="../../../reflect/internal/Types.scala.html#410887" title="PatternMatching.this.global.Type" id="3368996">_</a>, <a href="../../../reflect/internal/Types.scala.html#410889" title="PatternMatching.this.global.Symbol" id="3369009">SomeClass</a>, <a href="../../../reflect/internal/Types.scala.html#410891" title="List[PatternMatching.this.global.Type]" id="3368998">_</a><span class="delimiter">)</span> =&gt; <a href="#3369013" title="(x: Boolean)Boolean" class="keyword">true</a>
        // probably not useful since this type won't be inferred nor can it be written down (yet)
        <span class="keyword">case</span> ConstantType<a href="#3368995" title="Boolean" id="3369005" class="delimiter">(</a>Constant<a href="../../../reflect/internal/Types.scala.html#410960" title="PatternMatching.this.global.Constant" id="3369003" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#409760" title="Any" id="3369010" class="keyword">true</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#3369013" title="(x: Boolean)Boolean" class="keyword">true</a>
        <span class="keyword">case</span> _ =&gt; <a href="#3369013" title="(x: Boolean)Boolean" class="keyword">false</a>
      <span class="delimiter">}</span>

      <span class="keyword">def</span> <a title="(xtm: TreeMakerApproximation.this.ExtractorTreeMaker)Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Symbol)]" id="1076404">unapply</a><span class="delimiter">(</span><a title="TreeMakerApproximation.this.ExtractorTreeMaker" id="1076414">xtm</a>: <a href="#1075387" title="TreeMakerApproximation.this.ExtractorTreeMaker">ExtractorTreeMaker</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Symbol)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Symbol<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#1076414" title="TreeMakerApproximation.this.ExtractorTreeMaker">xtm</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> ExtractorTreeMaker<span class="delimiter">(</span><a href="#1072856" title="PatternMatching.this.global.Tree" id="1076415">extractor</a>, <a href="#1072857" title="Option[PatternMatching.this.global.Tree]" id="3369028">None</a>, <a href="#1072858" title="PatternMatching.this.global.Symbol" id="1076416">nextBinder</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#1076403" title="(tp: PatternMatching.this.global.Type)Boolean">irrefutableExtractorType</a><span class="delimiter">(</span><a href="#1076415" title="PatternMatching.this.global.Tree">extractor</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span> =&gt;
          <a href="../../../Option.scala.html#63128" title="(x: (PatternMatching.this.global.Tree, PatternMatching.this.global.Symbol))Some[(PatternMatching.this.global.Tree, PatternMatching.this.global.Symbol)]">Some</a><a href="#3369030" title="(x: Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Symbol)])Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Symbol)]" class="delimiter">(</a><a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Tree, _2: PatternMatching.this.global.Symbol)(PatternMatching.this.global.Tree, PatternMatching.this.global.Symbol)" class="delimiter">(</a><a href="#1076415" title="PatternMatching.this.global.Tree">extractor</a>, <a href="#1076416" title="PatternMatching.this.global.Symbol">nextBinder</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt;
          <a href="#3369030" title="(x: Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Symbol)])Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Symbol)]">None</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    // returns (tree, tests), where `tree` will be used to refer to `root` in `tests`
    <span class="keyword">class</span> <a title="class TreeMakersToConds extends Object" id="1069159">TreeMakersToConds</a><a href="#1069159" title="TreeMakerApproximation.this.TreeMakersToConds" class="delimiter">(</a><span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="1076476">root</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      // a variable in this set should never be replaced by a tree that &quot;does not consist of a selection on a variable in this set&quot; (intuitively)
      <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[PatternMatching.this.global.Symbol]" id="1076430">pointsToBound</a> = scala.collection.mutable.<a href="../../../collection/generic/GenericCompanion.scala.html#59933" title="(elems: PatternMatching.this.global.Symbol*)scala.collection.mutable.HashSet[PatternMatching.this.global.Symbol]">HashSet</a><span class="delimiter">(</span><a href="#1076476" title="=&gt; PatternMatching.this.global.Symbol">root</a><span class="delimiter">)</span>
      <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[PatternMatching.this.global.Tree]" id="1076432">trees</a>         = scala.collection.mutable.<a href="../../../collection/mutable/HashSet.scala.html#13054" title="scala.collection.mutable.HashSet.type">HashSet</a>.<a href="../../../collection/mutable/HashSet.scala.html#156202" title="[A]=&gt; scala.collection.mutable.HashSet[A]">empty</a><span title="scala.collection.mutable.HashSet[PatternMatching.this.global.Tree]" class="delimiter">[</span><a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">]</span>

      // the substitution that renames variables to variables in pointsToBound
      <span class="keyword">private</span> <span class="keyword">var</span> <a title="TreeMakerApproximation.this.Substitution" id="1076435">normalize</a>: <a href="#1069026" title="TreeMakerApproximation.this.Substitution">Substitution</a>  = <a href="#1069027" title="TreeMakerApproximation.this.EmptySubstitution.type">EmptySubstitution</a>
      <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="1076438">substitutionComputed</a> = <span title="Boolean(false)" class="keyword">false</span>

      // replaces a variable (in pointsToBound) by a selection on another variable in pointsToBound
      // in the end, instead of having x1, x1.hd, x2, x2.hd, ... flying around,
      // we want something like x1, x1.hd, x1.hd.tl, x1.hd.tl.hd, so that we can easily recognize when
      // we're testing the same variable
      // TODO check:
      //   pointsToBound -- accumSubst.from == Set(root) &amp;&amp; (accumSubst.from.toSet -- pointsToBound) isEmpty
      <span class="keyword">private</span> <span class="keyword">var</span> <a title="TreeMakerApproximation.this.Substitution" id="1076441">accumSubst</a>: <a href="#1069026" title="TreeMakerApproximation.this.Substitution">Substitution</a> = <a href="#1069027" title="TreeMakerApproximation.this.EmptySubstitution.type">EmptySubstitution</a>

      // hashconsing trees (modulo value-equality)
      <span class="keyword">def</span> <a title="(t: PatternMatching.this.global.Tree, tpOverride: PatternMatching.this.global.Type)PatternMatching.this.global.Tree" id="1076443">unique</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1076477">t</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Type" id="1076479">tpOverride</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a> = <a href="../../../reflect/internal/Types.scala.html#407284" title="PatternMatching.this.global.NoType.type">NoType</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> =
        <a href="#1076432" title="=&gt; scala.collection.mutable.HashSet[PatternMatching.this.global.Tree]">trees</a> <a href="../../../collection/IterableLike.scala.html#58567" title="(p: PatternMatching.this.global.Tree =&gt; Boolean)Option[PatternMatching.this.global.Tree]">find</a> <span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1076485">a</a> =&gt; <a href="#1076485" title="PatternMatching.this.global.Tree">a</a>.<a href="../../../reflect/internal/Trees.scala.html#408548" title="(that: PatternMatching.this.global.Tree)(f: (PatternMatching.this.global.Tree, PatternMatching.this.global.Tree) =&gt; Boolean)Boolean">correspondsStructure</a><span class="delimiter">(</span><a href="#1076477" title="PatternMatching.this.global.Tree">t</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1069156" title="(a: PatternMatching.this.global.Tree, b: PatternMatching.this.global.Tree)Boolean">sameValue</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Some<a href="#3369038" title="PatternMatching.this.global.Tree" id="3369039" class="delimiter">(</a><a href="../../../Option.scala.html#63132" title="PatternMatching.this.global.Tree" id="1076492">orig</a><span class="delimiter">)</span> =&gt;
            // patmatDebug(&quot;unique: &quot;+ (t eq orig, orig))
            <a href="#3369041" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">orig</a>
          <span class="keyword">case</span> _ =&gt;
            <a href="#1076432" title="=&gt; scala.collection.mutable.HashSet[PatternMatching.this.global.Tree]">trees</a> <a href="../../../collection/mutable/HashSet.scala.html#125963" title="(elem: PatternMatching.this.global.Tree)TreeMakersToConds.this.trees.type">+=</a> <a href="#1076477" title="PatternMatching.this.global.Tree">t</a>
            <span title="PatternMatching.this.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#1076479" title="PatternMatching.this.global.Type">tpOverride</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="../../../reflect/internal/Types.scala.html#407284" title="PatternMatching.this.global.NoType.type">NoType</a><span class="delimiter">)</span> <a href="#1076477" title="PatternMatching.this.global.Tree">t</a> <a href="../../../reflect/internal/Trees.scala.html#408575" title="(tp: PatternMatching.this.global.Type)t.type">setType</a> <a href="#1076479" title="PatternMatching.this.global.Type">tpOverride</a>
            <span class="keyword">else</span> <a href="#1076477" title="PatternMatching.this.global.Tree">t</a>
        <span class="delimiter">}</span>

      <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type" id="1076444">uniqueTp</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1076508">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a> = <a href="#1076508" title="PatternMatching.this.global.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        // typerefs etc are already hashconsed
        <span class="keyword">case</span> _ : UniqueType                      =&gt; <a href="#3369055" title="(x: PatternMatching.this.global.Type)PatternMatching.this.global.Type">tp</a>
        <span class="keyword">case</span> tp@RefinedType<a href="#3369046" title="PatternMatching.this.global.Type" id="3369050" class="delimiter">(</a><a href="../../../reflect/internal/Types.scala.html#410866" title="List[PatternMatching.this.global.Type]" id="1076512">parents</a>, <a href="../../../reflect/internal/Types.scala.html#410868" title="PatternMatching.this.global.Scope" id="3369053">EmptyScope</a><span class="delimiter">)</span> =&gt; tp.<a href="../../../reflect/internal/Types.scala.html#410815" title="(op1: =&gt; PatternMatching.this.global.Type)(op2: PatternMatching.this.global.Type =&gt; PatternMatching.this.global.Type)PatternMatching.this.global.Type">memo</a><span class="delimiter">(</span>tp: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span><a href="#3369055" title="(x: PatternMatching.this.global.Type)PatternMatching.this.global.Type" class="delimiter">(</a><a href="../../../Predef.scala.html#7469" title="(x: PatternMatching.this.global.Type)PatternMatching.this.global.Type">identity</a><span class="delimiter">)</span> // TODO: does this help?
        <span class="keyword">case</span> _                                   =&gt; <a href="#3369055" title="(x: PatternMatching.this.global.Type)PatternMatching.this.global.Type">tp</a>
      <span class="delimiter">}</span>

      // produce the unique tree used to refer to this binder
      // the type of the binder passed to the first invocation
      // determines the type of the tree that'll be returned for that binder as of then
      <span class="keyword">final</span> <span class="keyword">def</span> <a title="(b: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree" id="1076445">binderToUniqueTree</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1076528">b</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span> =
        <a href="#1076443" title="(t: PatternMatching.this.global.Tree, tpOverride: PatternMatching.this.global.Type)PatternMatching.this.global.Tree">unique</a><span class="delimiter">(</span><a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">accumSubst</a><span class="delimiter">(</span><a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">normalize</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1076528" title="PatternMatching.this.global.Symbol">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#1076528" title="PatternMatching.this.global.Symbol">b</a>.<a href="../../../reflect/internal/Symbols.scala.html#411365" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span>

      <span class="keyword">def</span> <a title="(conds: Iterable[TreeMakerApproximation.this.Cond])TreeMakerApproximation.this.Cond" id="1076446">/\</a><span class="delimiter">(</span><a title="Iterable[TreeMakerApproximation.this.Cond]" id="1076531">conds</a>: <a href="../../../collection/Iterable.scala.html#4163" title="Iterable[TreeMakerApproximation.this.Cond]">Iterable</a><span class="delimiter">[</span>Cond<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="TreeMakerApproximation.this.Cond" class="keyword">if</span> <span class="delimiter">(</span><a href="#1076531" title="Iterable[TreeMakerApproximation.this.Cond]">conds</a>.<a href="../../../collection/IterableLike.scala.html#58568" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#1076148" title="TreeMakerApproximation.this.TrueCond.type">TrueCond</a> <span class="keyword">else</span> <a href="#1076531" title="Iterable[TreeMakerApproximation.this.Cond]">conds</a>.<a href="../../../collection/TraversableOnce.scala.html#58208" title="(op: (TreeMakerApproximation.this.Cond, TreeMakerApproximation.this.Cond) =&gt; TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.Cond">reduceLeft</a><span class="delimiter">(</span><a href="#1077436" title="(a: TreeMakerApproximation.this.Cond, b: TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.AndCond">AndCond</a><span class="delimiter">(</span><a href="#1076540" title="TreeMakerApproximation.this.Cond">_</a>, <a href="#1076541" title="TreeMakerApproximation.this.Cond">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(conds: Iterable[TreeMakerApproximation.this.Cond])TreeMakerApproximation.this.Cond" id="1076447">\/</a><span class="delimiter">(</span><a title="Iterable[TreeMakerApproximation.this.Cond]" id="1076552">conds</a>: <a href="../../../collection/Iterable.scala.html#4163" title="Iterable[TreeMakerApproximation.this.Cond]">Iterable</a><span class="delimiter">[</span>Cond<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="TreeMakerApproximation.this.Cond" class="keyword">if</span> <span class="delimiter">(</span><a href="#1076552" title="Iterable[TreeMakerApproximation.this.Cond]">conds</a>.<a href="../../../collection/IterableLike.scala.html#58568" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#1076165" title="TreeMakerApproximation.this.FalseCond.type">FalseCond</a> <span class="keyword">else</span> <a href="#1076552" title="Iterable[TreeMakerApproximation.this.Cond]">conds</a>.<a href="../../../collection/TraversableOnce.scala.html#58208" title="(op: (TreeMakerApproximation.this.Cond, TreeMakerApproximation.this.Cond) =&gt; TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.Cond">reduceLeft</a><span class="delimiter">(</span><a href="#1077462" title="(a: TreeMakerApproximation.this.Cond, b: TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.OrCond">OrCond</a><span class="delimiter">(</span><a href="#1076561" title="TreeMakerApproximation.this.Cond">_</a>, <a href="#1076562" title="TreeMakerApproximation.this.Cond">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

      // note that the sequencing of operations is important: must visit in same order as match execution
      // binderToUniqueTree uses the type of the first symbol that was encountered as the type for all future binders
      <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class TreeMakerToCond extends Object with TreeMakerApproximation.this.TreeMaker =&gt; TreeMakerApproximation.this.Cond" id="1076448">TreeMakerToCond</a> <a href="#1076448" title="TreeMakersToConds.this.TreeMakerToCond" class="keyword">extends</a> <span class="delimiter">(</span>TreeMaker =&gt; Cond<span class="delimiter">)</span> <span class="delimiter">{</span>
        // requires(if (!substitutionComputed))
        <span class="keyword">def</span> <a title="(subst: TreeMakerApproximation.this.Substitution)Unit" id="1076574">updateSubstitution</a><span class="delimiter">(</span><a title="TreeMakerApproximation.this.Substitution" id="1076578">subst</a>: <a href="#1069026" title="TreeMakerApproximation.this.Substitution">Substitution</a><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#1515" title="Unit">Unit</a> = <span class="delimiter">{</span>
          // find part of substitution that replaces bound symbols by new symbols, and reverse that part
          // so that we don't introduce new aliases for existing symbols, thus keeping the set of bound symbols minimal
          <span class="keyword">val</span> <a href="#3369072" title="(x: (List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]))(List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]" id="1076581">boundSubst</a>, <a href="../../../Tuple2.scala.html#60637" title="List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]" id="1076582">unboundSubst</a><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#1076578" title="TreeMakerApproximation.this.Substitution">subst</a>.<a href="#1073003" title="=&gt; List[PatternMatching.this.global.Symbol]">from</a> <a href="../../../collection/IterableLike.scala.html#58590" title="(that: scala.collection.GenIterable[PatternMatching.this.global.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Symbol],(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree),List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]])List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">zip</a> <a href="#1076578" title="TreeMakerApproximation.this.Substitution">subst</a>.<a href="#1073004" title="=&gt; List[PatternMatching.this.global.Tree]">to</a><span class="delimiter">)</span> <a href="../../../collection/TraversableLike.scala.html#58080" title="(p: ((PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)) =&gt; Boolean)(List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)], List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)])">partition</a> <a href="#1076643" title="(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)" class="delimiter">{</a>
            <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Symbol" id="1076646">f</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="1076647">t</a><span class="delimiter">)</span> =&gt;
              <a href="#1076647" title="PatternMatching.this.global.Tree">t</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="../../../reflect/internal/Trees.scala.html#408054" title="PatternMatching.this.global.Ident">Ident</a><span class="delimiter">]</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#1076647" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#3369066" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../collection/GenSetLike.scala.html#66403" title="(elem: PatternMatching.this.global.Symbol)Boolean">pointsToBound</a><span class="delimiter">(</span><a href="#1076646" title="PatternMatching.this.global.Symbol">f</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <span class="keyword">val</span> <a href="#3369078" title="(x: (List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.Tree]))(List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.Tree])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="List[PatternMatching.this.global.Symbol]" id="1076584">boundFrom</a>, <a href="../../../Tuple2.scala.html#60637" title="List[PatternMatching.this.global.Tree]" id="1076585">boundTo</a><span class="delimiter">)</span> = <a href="#1076581" title="List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">boundSubst</a>.<a href="../../../collection/generic/GenericTraversableTemplate.scala.html#58476" title="(implicit asPair: ((PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)) =&gt; (PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree))(List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.Tree])">unzip</a>
          <span class="keyword">val</span> <a href="#3369084" title="(x: (List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.Tree]))(List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.Tree])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="List[PatternMatching.this.global.Symbol]" id="1076587">unboundFrom</a>, <a href="../../../Tuple2.scala.html#60637" title="List[PatternMatching.this.global.Tree]" id="1076588">unboundTo</a><span class="delimiter">)</span> = <a href="#1076582" title="List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)]">unboundSubst</a>.<a href="../../../collection/generic/GenericTraversableTemplate.scala.html#58476" title="(implicit asPair: ((PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree)) =&gt; (PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree))(List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.Tree])">unzip</a>

          // reverse substitution that would otherwise replace a variable we already encountered by a new variable
          // NOTE: this forgets the more precise type we have for these later variables, but that's probably okay
          <a href="#1076435" title="(x$1: TreeMakerApproximation.this.Substitution)Unit">normalize</a> <a href="#1069978" title="(other: TreeMakerApproximation.this.Substitution)TreeMakerApproximation.this.Substitution">&gt;&gt;=</a> <a href="#1073002" title="(from: List[PatternMatching.this.global.Symbol], to: List[PatternMatching.this.global.Tree])TreeMakerApproximation.this.Substitution">Substitution</a><span class="delimiter">(</span><a href="#1076585" title="List[PatternMatching.this.global.Tree]">boundTo</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Tree],PatternMatching.this.global.Symbol,List[PatternMatching.this.global.Symbol]])List[PatternMatching.this.global.Symbol]">map</a> <span class="delimiter">(</span><a href="#1076737" title="PatternMatching.this.global.Tree">_</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a><span class="delimiter">)</span>, <a href="#1076584" title="List[PatternMatching.this.global.Symbol]">boundFrom</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.Symbol =&gt; PatternMatching.this.global.gen.global.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Symbol],PatternMatching.this.global.gen.global.Tree,List[PatternMatching.this.global.gen.global.Tree]])List[PatternMatching.this.global.gen.global.Tree]">map</a> <span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1076782" title="PatternMatching.this.global.Symbol">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          // patmatDebug (&quot;normalize subst: &quot;+ normalize)

          <span class="keyword">val</span> <a title="TreeMakerApproximation.this.Substitution" id="1076589">okSubst</a> = <a href="#1073002" title="(from: List[PatternMatching.this.global.Symbol], to: List[PatternMatching.this.global.Tree])TreeMakerApproximation.this.Substitution">Substitution</a><span class="delimiter">(</span><a href="#1076587" title="List[PatternMatching.this.global.Symbol]">unboundFrom</a>, <a href="#1076588" title="List[PatternMatching.this.global.Tree]">unboundTo</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Tree],PatternMatching.this.global.Tree,List[PatternMatching.this.global.Tree]])List[PatternMatching.this.global.Tree]">map</a> <span class="delimiter">(</span><a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">normalize</a><span class="delimiter">(</span><a href="#1076837" title="PatternMatching.this.global.Tree">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> // it's important substitution does not duplicate trees here -- it helps to keep hash consing simple, anyway
          <a href="#1076430" title="=&gt; scala.collection.mutable.HashSet[PatternMatching.this.global.Symbol]">pointsToBound</a> <a href="../../../collection/generic/Growable.scala.html#60003" title="(xs: scala.collection.TraversableOnce[PatternMatching.this.global.Symbol])TreeMakersToConds.this.pointsToBound.type">++=</a> <span class="delimiter">(</span><a href="../../../Predef.scala.html#7531" title="(x: (List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.Tree]))runtime.Tuple2Zipped.Ops[List[PatternMatching.this.global.Symbol],List[PatternMatching.this.global.Tree]]" class="delimiter">(</a><a href="#1076589" title="TreeMakerApproximation.this.Substitution">okSubst</a>.<a href="#1073003" title="=&gt; List[PatternMatching.this.global.Symbol]">from</a>, <a href="#1076589" title="TreeMakerApproximation.this.Substitution">okSubst</a>.<a href="#1073004" title="=&gt; List[PatternMatching.this.global.Tree]">to</a><span class="delimiter">)</span>.<a href="../../../runtime/Tuple2Zipped.scala.html#60613" title="(implicit w1: List[PatternMatching.this.global.Symbol] =&gt; scala.collection.TraversableLike[PatternMatching.this.global.Symbol,List[PatternMatching.this.global.Symbol]], implicit w2: List[PatternMatching.this.global.Tree] =&gt; scala.collection.IterableLike[PatternMatching.this.global.Tree,List[PatternMatching.this.global.Tree]])scala.runtime.Tuple2Zipped[PatternMatching.this.global.Symbol,List[PatternMatching.this.global.Symbol],PatternMatching.this.global.Tree,List[PatternMatching.this.global.Tree]]">zipped</a> <a href="../../../runtime/Tuple2Zipped.scala.html#486050" title="(f: (PatternMatching.this.global.Symbol, PatternMatching.this.global.Tree) =&gt; Boolean)(implicit cbf1: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Symbol],PatternMatching.this.global.Symbol,List[PatternMatching.this.global.Symbol]], implicit cbf2: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Tree],PatternMatching.this.global.Tree,List[PatternMatching.this.global.Tree]])(List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.Tree])">filter</a> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1076918">f</a>, <a title="PatternMatching.this.global.Tree" id="1076919">t</a><span class="delimiter">)</span> =&gt; <a href="#1076430" title="=&gt; scala.collection.mutable.HashSet[PatternMatching.this.global.Symbol]">pointsToBound</a> <a href="../../../collection/IterableLike.scala.html#58566" title="(p: PatternMatching.this.global.Symbol =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1076925">sym</a> =&gt; <a href="#1076919" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408545" title="(p: PatternMatching.this.global.Tree =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#1076929" title="PatternMatching.this.global.Tree">_</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1076925" title="PatternMatching.this.global.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>.<a href="../../../Tuple2.scala.html#60635" title="=&gt; List[PatternMatching.this.global.Symbol]">_1</a>
          // patmatDebug(&quot;pointsToBound: &quot;+ pointsToBound)

          <a href="#1076441" title="(x$1: TreeMakerApproximation.this.Substitution)Unit">accumSubst</a> <a href="#1069978" title="(other: TreeMakerApproximation.this.Substitution)TreeMakerApproximation.this.Substitution">&gt;&gt;=</a> <a href="#1076589" title="TreeMakerApproximation.this.Substitution">okSubst</a>
          // patmatDebug(&quot;accumSubst: &quot;+ accumSubst)
        <span class="delimiter">}</span>

        <span class="keyword">def</span> <a title="(tm: TreeMakerApproximation.this.TreeMaker)TreeMakerApproximation.this.Cond" id="1076575">handleUnknown</a><span class="delimiter">(</span><a title="TreeMakerApproximation.this.TreeMaker" id="1076994">tm</a>: <a href="#1069034" title="TreeMakerApproximation.this.TreeMaker">TreeMaker</a><span class="delimiter">)</span>: <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a>

        /** apply itself must render a faithful representation of the TreeMaker
         *
         * Concretely, TrueCond must only be used to represent a TreeMaker that is sure to match and that does not do any computation at all
         * e.g., doCSE relies on apply itself being sound in this sense (since it drops TreeMakers that are approximated to TrueCond -- SI-6077)
         *
         * handleUnknown may be customized by the caller to approximate further
         *
         * TODO: don't ignore outer-checks
         */
        <span class="keyword">def</span> <a title="(tm: TreeMakerApproximation.this.TreeMaker)TreeMakerApproximation.this.Cond" id="1076576">apply</a><span class="delimiter">(</span><a title="TreeMakerApproximation.this.TreeMaker" id="1076996">tm</a>: <a href="#1069034" title="TreeMakerApproximation.this.TreeMaker">TreeMaker</a><span class="delimiter">)</span>: <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a> = <span class="delimiter">{</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1076438" title="=&gt; Boolean">substitutionComputed</a><span class="delimiter">)</span> <a href="#1076574" title="(subst: TreeMakerApproximation.this.Substitution)Unit">updateSubstitution</a><span class="delimiter">(</span><a href="#1076996" title="TreeMakerApproximation.this.TreeMaker">tm</a>.<a href="#1069813" title="=&gt; TreeMakerApproximation.this.Substitution">subPatternsAsSubstitution</a><span class="delimiter">)</span>

          <a href="#1076996" title="TreeMakerApproximation.this.TreeMaker">tm</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> ttm@TypeTestTreeMaker<a href="#3369117" title="TreeMakerApproximation.this.Cond" id="3369120" class="delimiter">(</a><a href="#1074597" title="PatternMatching.this.global.Symbol" id="1077000">prevBinder</a>, <a href="#1074598" title="PatternMatching.this.global.Symbol" id="1077001">testedBinder</a>, <a href="#1074599" title="PatternMatching.this.global.Type" id="1077002">pt</a>, <a href="#1074600" title="PatternMatching.this.global.Type" id="3369118">_</a><span class="delimiter">)</span>   =&gt;
              <span class="keyword">object</span> <a title="condStrategy.type" id="1077003">condStrategy</a> <a href="#1077004" title="condStrategy.type" class="keyword">extends</a> TypeTestTreeMaker.<a href="#1070659" title="TreeMakerApproximation.this.TypeTestTreeMaker.TypeTestCondStrategy">TypeTestCondStrategy</a> <span class="delimiter">{</span>
                <span class="keyword">type</span> <a title="TreeMakerApproximation.this.Cond" id="1077006">Result</a>                                           = <a href="#1069136" title="TreeMakerApproximation.this.Cond">Cond</a>
                <span class="keyword">def</span> <a title="(a: scala.tools.nsc.typechecker.PatternMatching.TreeMakerApproximation.TreeMakersToConds.TreeMakerToCond.condStrategy.Result, b: scala.tools.nsc.typechecker.PatternMatching.TreeMakerApproximation.TreeMakersToConds.TreeMakerToCond.condStrategy.Result)TreeMakerApproximation.this.AndCond" id="1077007">and</a><span class="delimiter">(</span><a title="scala.tools.nsc.typechecker.PatternMatching.TreeMakerApproximation.TreeMakersToConds.TreeMakerToCond.condStrategy.Result" id="1077014">a</a>: <a href="#1069136" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakerApproximation.TreeMakersToConds.TreeMakerToCond.condStrategy.Result">Result</a>, <a title="scala.tools.nsc.typechecker.PatternMatching.TreeMakerApproximation.TreeMakersToConds.TreeMakerToCond.condStrategy.Result" id="1077015">b</a>: <a href="#1069136" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakerApproximation.TreeMakersToConds.TreeMakerToCond.condStrategy.Result">Result</a><span class="delimiter">)</span>                         = <a href="#1077436" title="(a: TreeMakerApproximation.this.Cond, b: TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.AndCond">AndCond</a><span class="delimiter">(</span><a href="#1077014" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakerApproximation.TreeMakersToConds.TreeMakerToCond.condStrategy.Result">a</a>, <a href="#1077015" title="scala.tools.nsc.typechecker.PatternMatching.TreeMakerApproximation.TreeMakersToConds.TreeMakerToCond.condStrategy.Result">b</a><span class="delimiter">)</span>
                <span class="keyword">def</span> <a title="(testedBinder: PatternMatching.this.global.Symbol, expectedTp: PatternMatching.this.global.Type)TreeMakerApproximation.this.TrueCond.type" id="1077008">outerTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1077022">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1077023">expectedTp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> = <a href="#1076148" title="TreeMakerApproximation.this.TrueCond.type">TrueCond</a> // TODO OuterEqCond(testedBinder, expectedType)
                <span class="keyword">def</span> <a title="(b: PatternMatching.this.global.Symbol, pt: PatternMatching.this.global.Type)TreeMakerApproximation.this.AndCond" id="1077009">typeTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1077026">b</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1077027">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span> // a type test implies the tested path is non-null (null.isInstanceOf[T] is false for all T)
                  <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1077030">p</a> = <a href="#1076445" title="(b: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">binderToUniqueTree</a><span class="delimiter">(</span><a href="#1077026" title="PatternMatching.this.global.Symbol">b</a><span class="delimiter">)</span>;                        <a href="#1077436" title="(a: TreeMakerApproximation.this.Cond, b: TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.AndCond">AndCond</a><span class="delimiter">(</span><a href="#1076322" title="(testedPath: PatternMatching.this.global.Tree)TreeMakerApproximation.this.NonNullCond">NonNullCond</a><span class="delimiter">(</span><a href="#1077030" title="PatternMatching.this.global.Tree">p</a><span class="delimiter">)</span>, <a href="#1076349" title="(testedPath: PatternMatching.this.global.Tree, pt: PatternMatching.this.global.Type)TreeMakerApproximation.this.TypeCond">TypeCond</a><span class="delimiter">(</span><a href="#1077030" title="PatternMatching.this.global.Tree">p</a>, <a href="#1076444" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">uniqueTp</a><span class="delimiter">(</span><a href="#1077027" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="delimiter">}</span>
                <span class="keyword">def</span> <a title="(testedBinder: PatternMatching.this.global.Symbol)TreeMakerApproximation.this.NonNullCond" id="1077010">nonNullTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1077031">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>                 = <a href="#1076322" title="(testedPath: PatternMatching.this.global.Tree)TreeMakerApproximation.this.NonNullCond">NonNullCond</a><span class="delimiter">(</span><a href="#1076445" title="(b: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">binderToUniqueTree</a><span class="delimiter">(</span><a href="#1077031" title="PatternMatching.this.global.Symbol">testedBinder</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">def</span> <a title="(pat: PatternMatching.this.global.Tree, testedBinder: PatternMatching.this.global.Symbol)TreeMakerApproximation.this.EqualityCond" id="1077011">equalsTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1077034">pat</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1077035">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>       = <a href="#1076277" title="(testedPath: PatternMatching.this.global.Tree, rhs: PatternMatching.this.global.Tree)TreeMakerApproximation.this.EqualityCond">EqualityCond</a><span class="delimiter">(</span><a href="#1076445" title="(b: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">binderToUniqueTree</a><span class="delimiter">(</span><a href="#1077035" title="PatternMatching.this.global.Symbol">testedBinder</a><span class="delimiter">)</span>, <a href="#1076443" title="(t: PatternMatching.this.global.Tree, tpOverride: PatternMatching.this.global.Type)PatternMatching.this.global.Tree">unique</a><span class="delimiter">(</span><a href="#1077034" title="PatternMatching.this.global.Tree">pat</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">def</span> <a title="(pat: PatternMatching.this.global.Tree, testedBinder: PatternMatching.this.global.Symbol)TreeMakerApproximation.this.EqualityCond" id="1077012">eqTest</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1077038">pat</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1077039">testedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span>           = <a href="#1076277" title="(testedPath: PatternMatching.this.global.Tree, rhs: PatternMatching.this.global.Tree)TreeMakerApproximation.this.EqualityCond">EqualityCond</a><span class="delimiter">(</span><a href="#1076445" title="(b: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">binderToUniqueTree</a><span class="delimiter">(</span><a href="#1077039" title="PatternMatching.this.global.Symbol">testedBinder</a><span class="delimiter">)</span>, <a href="#1076443" title="(t: PatternMatching.this.global.Tree, tpOverride: PatternMatching.this.global.Type)PatternMatching.this.global.Tree">unique</a><span class="delimiter">(</span><a href="#1077038" title="PatternMatching.this.global.Tree">pat</a><span class="delimiter">)</span><span class="delimiter">)</span> // TODO: eq, not ==
              <span class="delimiter">}</span>
              ttm.<a href="#1070699" title="(cs: TreeMakerApproximation.this.TypeTestTreeMaker.TypeTestCondStrategy)cs.Result">renderCondition</a><span class="delimiter">(</span><a href="#1077003" title="condStrategy.type">condStrategy</a><span class="delimiter">)</span>
            <span class="keyword">case</span> EqualityTestTreeMaker<a href="#3369117" title="TreeMakerApproximation.this.Cond" id="3369123" class="delimiter">(</a><a href="#1071011" title="PatternMatching.this.global.Symbol" id="1077043">prevBinder</a>, <a href="#1071012" title="PatternMatching.this.global.Tree" id="1077044">patTree</a>, <a href="#1071013" title="PatternMatching.this.global.Position" id="3369121">_</a><span class="delimiter">)</span>        =&gt; <a href="#1076277" title="(testedPath: PatternMatching.this.global.Tree, rhs: PatternMatching.this.global.Tree)TreeMakerApproximation.this.EqualityCond">EqualityCond</a><a href="#3369153" title="(x: TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.Cond" class="delimiter">(</a><a href="#1076445" title="(b: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">binderToUniqueTree</a><span class="delimiter">(</span><a href="#1077043" title="PatternMatching.this.global.Symbol">prevBinder</a><span class="delimiter">)</span>, <a href="#1076443" title="(t: PatternMatching.this.global.Tree, tpOverride: PatternMatching.this.global.Type)PatternMatching.this.global.Tree">unique</a><span class="delimiter">(</span><a href="#1077044" title="PatternMatching.this.global.Tree">patTree</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">case</span> AlternativesTreeMaker<a href="#3369117" title="TreeMakerApproximation.this.Cond" id="3369127" class="delimiter">(</a><a href="#1071043" title="PatternMatching.this.global.Symbol" id="3369124">_</a>, <a href="#1071044" title="List[List[TreeMakerApproximation.this.TreeMaker]]" id="1077048">altss</a>, <a href="#1071045" title="PatternMatching.this.global.Position" id="3369125">_</a><span class="delimiter">)</span>                   =&gt; <a href="#1076447" title="(conds: Iterable[TreeMakerApproximation.this.Cond])TreeMakerApproximation.this.Cond">\/</a><a href="#3369153" title="(x: TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.Cond" class="delimiter">(</a><a href="#1077048" title="List[List[TreeMakerApproximation.this.TreeMaker]]">altss</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[TreeMakerApproximation.this.TreeMaker] =&gt; TreeMakerApproximation.this.Cond)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[TreeMakerApproximation.this.TreeMaker]],TreeMakerApproximation.this.Cond,Iterable[TreeMakerApproximation.this.Cond]])Iterable[TreeMakerApproximation.this.Cond]">map</a> <span class="delimiter">(</span><a title="List[TreeMakerApproximation.this.TreeMaker]" id="1077065">alts</a> =&gt; <a href="#1076446" title="(conds: Iterable[TreeMakerApproximation.this.Cond])TreeMakerApproximation.this.Cond">/\</a><span class="delimiter">(</span><a href="#1077065" title="List[TreeMakerApproximation.this.TreeMaker]">alts</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: TreeMakerApproximation.this.TreeMaker =&gt; TreeMakerApproximation.this.Cond)(implicit bf: scala.collection.generic.CanBuildFrom[List[TreeMakerApproximation.this.TreeMaker],TreeMakerApproximation.this.Cond,Iterable[TreeMakerApproximation.this.Cond]])Iterable[TreeMakerApproximation.this.Cond]">map</a> <a href="#1076448" title="TreeMakersToConds.this.TreeMakerToCond" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">case</span> ProductExtractorTreeMaker<a href="#3369117" title="TreeMakerApproximation.this.Cond" id="3369130" class="delimiter">(</a><a href="#1072647" title="PatternMatching.this.global.Symbol" id="1077144">testedBinder</a>, <a href="#1072648" title="Option[PatternMatching.this.global.Tree]" id="3369151">None</a><span class="delimiter">)</span>        =&gt; <a href="#1076322" title="(testedPath: PatternMatching.this.global.Tree)TreeMakerApproximation.this.NonNullCond">NonNullCond</a><a href="#3369153" title="(x: TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.Cond" class="delimiter">(</a><a href="#1076445" title="(b: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">binderToUniqueTree</a><span class="delimiter">(</span><a href="#1077144" title="PatternMatching.this.global.Symbol">testedBinder</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">case</span> SubstOnlyTreeMaker<a href="#3369117" title="TreeMakerApproximation.this.Cond" id="3369135" class="delimiter">(</a><a href="#1070955" title="PatternMatching.this.global.Symbol" id="3369132">_</a>, <a href="#1070956" title="PatternMatching.this.global.Symbol" id="3369133">_</a><span class="delimiter">)</span>                             =&gt; <a href="#3369153" title="(x: TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.Cond">TrueCond</a>
            <span class="keyword">case</span> GuardTreeMaker<a href="#3369117" title="TreeMakerApproximation.this.Cond" id="3369137" class="delimiter">(</a><a href="#1071247" title="PatternMatching.this.global.Tree" id="1077145">guard</a><span class="delimiter">)</span> =&gt;
              <a href="#1077145" title="PatternMatching.this.global.Tree">guard</a>.<a href="#3369153" title="(x: TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.Cond">tpe</a> <span class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> ConstantType<a href="#3369088" title="Boolean" id="3369091" class="delimiter">(</a>Constant<a href="../../../reflect/internal/Types.scala.html#410960" title="PatternMatching.this.global.Constant" id="3369089" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#409760" title="Any" id="3369101" class="keyword">true</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#3369105" title="(x: TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.Cond">TrueCond</a>
                <span class="keyword">case</span> ConstantType<span class="delimiter">(</span>Constant<a href="../../../reflect/internal/Types.scala.html#410960" title="PatternMatching.this.global.Constant" id="3369095" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#409760" title="Any" id="3369102" class="keyword">false</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#3369105" title="(x: TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.Cond">FalseCond</a>
                <span class="keyword">case</span> _                             =&gt; <a href="#1076575" title="(tm: TreeMakerApproximation.this.TreeMaker)TreeMakerApproximation.this.Cond">handleUnknown</a><a href="#3369105" title="(x: TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.Cond" class="delimiter">(</a><a href="#1076996" title="TreeMakerApproximation.this.TreeMaker">tm</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="keyword">case</span> ExtractorTreeMaker<a href="#3369117" title="TreeMakerApproximation.this.Cond" id="3369142" class="delimiter">(</a><a href="#1072856" title="PatternMatching.this.global.Tree" id="3369138">_</a>, <a href="#1072857" title="Option[PatternMatching.this.global.Tree]" id="3369139">_</a>, <a href="#1072858" title="PatternMatching.this.global.Symbol" id="3369140">_</a><span class="delimiter">)</span> |
                 ProductExtractorTreeMaker<a href="#3369117" title="Boolean" id="3369146" class="delimiter">(</a><a href="#1072647" title="PatternMatching.this.global.Symbol" id="3369143">_</a>, <a href="#1072648" title="Option[PatternMatching.this.global.Tree]" id="3369144">_</a><span class="delimiter">)</span> |
                 BodyTreeMaker<a href="#3369117" title="Boolean" id="3369150" class="delimiter">(</a><a href="#1071266" title="PatternMatching.this.global.Tree" id="3369147">_</a>, <a href="#1071267" title="PatternMatching.this.global.Type" id="3369148">_</a><span class="delimiter">)</span>               =&gt; <a href="#1076575" title="(tm: TreeMakerApproximation.this.TreeMaker)TreeMakerApproximation.this.Cond">handleUnknown</a><a href="#3369153" title="(x: TreeMakerApproximation.this.Cond)TreeMakerApproximation.this.Cond" class="delimiter">(</a><a href="#1076996" title="TreeMakerApproximation.this.TreeMaker">tm</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>


      <span class="keyword">private</span> <span class="keyword">val</span> <a title="PartialFunction[TreeMakerApproximation.this.TreeMaker,TreeMakerApproximation.this.Cond]" id="1076449">irrefutableExtractor</a>: <a href="../../../PartialFunction.scala.html#129" title="PartialFunction[TreeMakerApproximation.this.TreeMaker,TreeMakerApproximation.this.Cond]">PartialFunction</a><span class="delimiter">[</span>TreeMaker, Cond<span class="delimiter">]</span> = <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[TreeMakerApproximation.this.TreeMaker,TreeMakerApproximation.this.Cond] with Serializable" id="1077158" class="delimiter">{</a>
        // the extra condition is None, the extractor's result indicates it always succeeds,
        // (the potential type-test for the argument is represented by a separate TypeTestTreeMaker)
        <span class="keyword">case</span> <a href="#1076404" title="Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Symbol)]" id="3369198">IrrefutableExtractorTreeMaker</a><a href="#3369172" title="B1" id="3369191" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="3369188">_</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Symbol" id="3369189">_</a><span class="delimiter">)</span> =&gt; <a href="#3369179" title="(x: B1)B1">TrueCond</a>
      <span class="delimiter">}</span>

      // special-case: interpret pattern `List()` as `Nil`
      // TODO: make it more general List(1, 2) =&gt; 1 :: 2 :: Nil  -- not sure this is a good idea...
      <span class="keyword">private</span> <span class="keyword">val</span> <a title="PartialFunction[TreeMakerApproximation.this.TreeMaker,TreeMakerApproximation.this.Cond]" id="1076451">rewriteListPattern</a>: <a href="../../../PartialFunction.scala.html#129" title="PartialFunction[TreeMakerApproximation.this.TreeMaker,TreeMakerApproximation.this.Cond]">PartialFunction</a><span class="delimiter">[</span>TreeMaker, Cond<span class="delimiter">]</span> = <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[TreeMakerApproximation.this.TreeMaker,TreeMakerApproximation.this.Cond] with Serializable" id="1077222" class="delimiter">{</a>
        <span class="keyword">case</span> p @ ExtractorTreeMaker<a href="#3369201" title="B1" id="3369216" class="delimiter">(</a><a href="#1072856" title="PatternMatching.this.global.Tree" id="3369213">_</a>, <a href="#1072857" title="Option[PatternMatching.this.global.Tree]" id="3369214">_</a>, <a href="#1072858" title="PatternMatching.this.global.Symbol" id="1077226">testedBinder</a><span class="delimiter">)</span>
          <span class="keyword">if</span> <a href="#1077226" title="PatternMatching.this.global.Symbol">testedBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411365" title="=&gt; PatternMatching.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#408407" title="=&gt; PatternMatching.this.global.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/Definitions.scala.html#408837" title="=&gt; PatternMatching.this.global.ClassSymbol">ListClass</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> p.<a href="#1072862" title="=&gt; Option[Int]">checkedLength</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../Option.scala.html#63128" title="(x: Int)Some[Int]">Some</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> =&gt;
            <a href="#1076277" title="(testedPath: PatternMatching.this.global.Tree, rhs: PatternMatching.this.global.Tree)TreeMakerApproximation.this.EqualityCond">EqualityCond</a><a href="#3369207" title="(x: B1)B1" class="delimiter">(</a><a href="#1076445" title="(b: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">binderToUniqueTree</a><span class="delimiter">(</span>p.<a href="#1072863" title="=&gt; PatternMatching.this.global.Symbol">prevBinder</a><span class="delimiter">)</span>, <a href="#1076443" title="(t: PatternMatching.this.global.Tree, tpOverride: PatternMatching.this.global.Type)PatternMatching.this.global.Tree">unique</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#408127" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.Ident">Ident</a><span class="delimiter">(</span><a href="../../../reflect/internal/Definitions.scala.html#408849" title="=&gt; PatternMatching.this.global.ModuleSymbol">NilModule</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Trees.scala.html#408575" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Ident">setType</a> <a href="../../../reflect/internal/Definitions.scala.html#408849" title="=&gt; PatternMatching.this.global.ModuleSymbol">NilModule</a>.<a href="../../../reflect/internal/Symbols.scala.html#411365" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="PartialFunction[TreeMakerApproximation.this.TreeMaker,TreeMakerApproximation.this.Cond]" id="1076453">fullRewrite</a>      = <span class="delimiter">(</span><a href="#1076449" title="=&gt; PartialFunction[TreeMakerApproximation.this.TreeMaker,TreeMakerApproximation.this.Cond]">irrefutableExtractor</a> <a href="../../../PartialFunction.scala.html#58654" title="(that: PartialFunction[TreeMakerApproximation.this.TreeMaker,TreeMakerApproximation.this.Cond])PartialFunction[TreeMakerApproximation.this.TreeMaker,TreeMakerApproximation.this.Cond]">orElse</a> <a href="#1076451" title="=&gt; PartialFunction[TreeMakerApproximation.this.TreeMaker,TreeMakerApproximation.this.Cond]">rewriteListPattern</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="PartialFunction[TreeMakerApproximation.this.TreeMaker,TreeMakerApproximation.this.Cond]" id="1076455">refutableRewrite</a> = <a href="#1076449" title="=&gt; PartialFunction[TreeMakerApproximation.this.TreeMaker,TreeMakerApproximation.this.Cond]">irrefutableExtractor</a>

      @inline <span class="keyword">def</span> <a title="(handler: TreeMakerApproximation.this.TreeMaker =&gt; TreeMakerApproximation.this.Cond)TreeMakersToConds.this.TreeMakerToCond" id="1076457">onUnknown</a><span class="delimiter">(</span><a title="TreeMakerApproximation.this.TreeMaker =&gt; TreeMakerApproximation.this.Cond" id="1077262">handler</a>: TreeMaker =&gt; Cond<span class="delimiter">)</span> = <a href="#1077263" title="TreeMakersToConds.this.TreeMakerToCond" class="keyword">new</a> <a href="#1076448" title="anonymous class $anon extends TreeMakersToConds.this.TreeMakerToCond" id="1077263">TreeMakerToCond</a> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(tm: TreeMakerApproximation.this.TreeMaker)TreeMakerApproximation.this.Cond" id="1077265">handleUnknown</a><span class="delimiter">(</span><a title="TreeMakerApproximation.this.TreeMaker" id="1077266">tm</a>: <a href="#1069034" title="TreeMakerApproximation.this.TreeMaker">TreeMaker</a><span class="delimiter">)</span> = <a href="../../../Function1.scala.html#58642" title="(v1: TreeMakerApproximation.this.TreeMaker)TreeMakerApproximation.this.Cond">handler</a><span class="delimiter">(</span><a href="#1077266" title="TreeMakerApproximation.this.TreeMaker">tm</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      // used for CSE -- rewrite all unknowns to False (the most conserative option)
      <span class="keyword">object</span> <a title="TreeMakersToConds.this.conservative.type" id="1076458">conservative</a> <a href="#1076459" title="TreeMakersToConds.this.conservative.type" class="keyword">extends</a> <a href="#1076448" title="TreeMakersToConds.this.TreeMakerToCond">TreeMakerToCond</a> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(tm: TreeMakerApproximation.this.TreeMaker)TreeMakerApproximation.this.FalseCond.type" id="1077280">handleUnknown</a><span class="delimiter">(</span><a title="TreeMakerApproximation.this.TreeMaker" id="1077282">tm</a>: <a href="#1069034" title="TreeMakerApproximation.this.TreeMaker">TreeMaker</a><span class="delimiter">)</span> = <a href="#1076165" title="TreeMakerApproximation.this.FalseCond.type">FalseCond</a>
      <span class="delimiter">}</span>

      <span class="keyword">final</span> <span class="keyword">def</span> <a title="(cases: List[List[TreeMakerApproximation.this.TreeMaker]], treeMakerToCond: TreeMakersToConds.this.TreeMakerToCond)List[List[TreeMakerApproximation.this.Test]]" id="1076460">approximateMatch</a><span class="delimiter">(</span><a title="List[List[TreeMakerApproximation.this.TreeMaker]]" id="1077283">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[TreeMakerApproximation.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="TreeMakersToConds.this.TreeMakerToCond" id="1077285">treeMakerToCond</a>: <a href="#1076448" title="TreeMakersToConds.this.TreeMakerToCond">TreeMakerToCond</a> = <a href="#1076458" title="TreeMakersToConds.this.conservative.type">conservative</a><span class="delimiter">)</span> =<span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="List[List[TreeMakerApproximation.this.Test]]" id="1077286">testss</a> = <a href="#1077283" title="List[List[TreeMakerApproximation.this.TreeMaker]]">cases</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[TreeMakerApproximation.this.TreeMaker] =&gt; List[TreeMakerApproximation.this.Test])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[TreeMakerApproximation.this.TreeMaker]],List[TreeMakerApproximation.this.Test],List[List[TreeMakerApproximation.this.Test]]])List[List[TreeMakerApproximation.this.Test]]">map</a> <a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,List[TreeMakerApproximation.this.Test],List[List[TreeMakerApproximation.this.Test]]]" class="delimiter">{</a> <a href="#1077303" title="List[TreeMakerApproximation.this.TreeMaker]">_</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: TreeMakerApproximation.this.TreeMaker =&gt; TreeMakerApproximation.this.Test)(implicit bf: scala.collection.generic.CanBuildFrom[List[TreeMakerApproximation.this.TreeMaker],TreeMakerApproximation.this.Test,List[TreeMakerApproximation.this.Test]])List[TreeMakerApproximation.this.Test]">map</a> <span class="delimiter">(</span><a title="TreeMakerApproximation.this.TreeMaker" id="1077320">tm</a> =&gt; <a href="#1076105" title="(cond: TreeMakerApproximation.this.Cond, treeMaker: TreeMakerApproximation.this.TreeMaker)TreeMakerApproximation.this.Test">Test</a><span class="delimiter">(</span><a href="#1076576" title="(tm: TreeMakerApproximation.this.TreeMaker)TreeMakerApproximation.this.Cond">treeMakerToCond</a><span class="delimiter">(</span><a href="#1077320" title="TreeMakerApproximation.this.TreeMaker">tm</a><span class="delimiter">)</span>, <a href="#1077320" title="TreeMakerApproximation.this.TreeMaker">tm</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
        <a href="#1076438" title="(x$1: Boolean)Unit">substitutionComputed</a> = <span title="Boolean(true)" class="keyword">true</span> // a second call to approximateMatch should not re-compute the substitution (would be wrong)
        <a href="#1077286" title="List[List[TreeMakerApproximation.this.Test]]">testss</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(root: PatternMatching.this.global.Symbol, cases: List[List[TreeMakerApproximation.this.TreeMaker]])List[List[TreeMakerApproximation.this.Test]]" id="1069160">approximateMatchConservative</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1077384">root</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="List[List[TreeMakerApproximation.this.TreeMaker]]" id="1077385">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[TreeMakerApproximation.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[TreeMakerApproximation.this.Test]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Test<span class="delimiter">]</span><span class="delimiter">]</span> =
      <span class="delimiter">(</span><a title="TreeMakerApproximation.this.TreeMakersToConds" id="1077396" class="keyword">new</a> <a href="#1069159" title="TreeMakerApproximation.this.TreeMakersToConds">TreeMakersToConds</a><span class="delimiter">(</span><a href="#1077384" title="PatternMatching.this.global.Symbol">root</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#1077285" title="qual$3.TreeMakerToCond" id="1077400">approximateMatch</a><span class="delimiter">(</span><a href="#1077385" title="List[List[TreeMakerApproximation.this.TreeMaker]]" id="1077399">cases</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(cases: List[List[TreeMakerApproximation.this.TreeMaker]])Unit" id="1069161">showTreeMakers</a><span class="delimiter">(</span><a title="List[List[TreeMakerApproximation.this.TreeMaker]]" id="1077401">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[TreeMakerApproximation.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;treeMakers:&quot;)" class="string">&quot;treeMakers:&quot;</span><span class="delimiter">)</span>
      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><a href="#1069178" title="(xss: List[List[AnyRef]], sep: String, lineSep: String)String">alignAcrossRows</a><span class="delimiter">(</span><a href="#1077401" title="List[List[TreeMakerApproximation.this.TreeMaker]]">cases</a>, <span title="String(&quot;&gt;&gt;&quot;)" class="string">&quot;&gt;&gt;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(testss: List[List[TreeMakerApproximation.this.Test]])Unit" id="1069162">showTests</a><span class="delimiter">(</span><a title="List[List[TreeMakerApproximation.this.Test]]" id="1077408">testss</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[TreeMakerApproximation.this.Test]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Test<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;tests: &quot;)" class="string">&quot;tests: &quot;</span><span class="delimiter">)</span>
      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><a href="#1069178" title="(xss: List[List[AnyRef]], sep: String, lineSep: String)String">alignAcrossRows</a><span class="delimiter">(</span><a href="#1077408" title="List[List[TreeMakerApproximation.this.Test]]">testss</a>, <span title="String(&quot;&amp;&quot;)" class="string">&quot;&amp;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait Prettification extends Object" id="621393">Prettification</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="delimiter">{</a>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(xs: Seq[Int])Int" id="1069176">max</a><span class="delimiter">(</span><a title="Seq[Int]" id="1077464">xs</a>: <a href="../../../collection/Seq.scala.html#4340" title="Seq[Int]">Seq</a><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#1077464" title="Seq[Int]">xs</a> <a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> <a href="#1077464" title="Seq[Int]">xs</a> <a href="../../../collection/TraversableOnce.scala.html#58241" title="(implicit cmp: Ordering[Int])Int">max</a>

    <span class="keyword">def</span> <a title="(cols: Seq[AnyRef])Seq[String]" id="1069177">alignedColumns</a><span class="delimiter">(</span><a title="Seq[AnyRef]" id="1077527">cols</a>: <a href="../../../collection/Seq.scala.html#4340" title="Seq[AnyRef]">Seq</a><span class="delimiter">[</span>AnyRef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../collection/Seq.scala.html#4340" title="Seq[String]">Seq</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(x: AnyRef)String" id="1077528">toString</a><span class="delimiter">(</span><a title="AnyRef" id="1077529">x</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#1077529" title="AnyRef">x</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#1077529" title="AnyRef">x</a>.<span title="()String">toString</span>
      <span title="Seq[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1077527" title="Seq[AnyRef]">cols</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="#1077527" title="Seq[AnyRef]">cols</a>.<a href="../../../collection/TraversableLike.scala.html#58118" title="=&gt; Iterator[Seq[AnyRef]]">tails</a>.<a href="../../../collection/Iterator.scala.html#66749" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#1077527" title="Seq[AnyRef]">cols</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: AnyRef =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[AnyRef],String,Seq[String]])Seq[String]">map</a> <a href="#1077528" title="(x: AnyRef)String">toString</a>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a href="#3369224" title="(x: (Seq[String], Seq[Int]))(Seq[String], Seq[Int])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="Seq[String]" id="1077569">colStrs</a>, <a href="../../../Tuple2.scala.html#60637" title="Seq[Int]" id="1077570">colLens</a><span class="delimiter">)</span> = <a href="#1077527" title="Seq[AnyRef]">cols</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: AnyRef =&gt; (String, Int))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[AnyRef],(String, Int),Seq[(String, Int)]])Seq[(String, Int)]">map</a> <span class="delimiter">{</span><a title="AnyRef" id="1077585">c</a> =&gt; <span class="keyword">val</span> <a title="String" id="1077586">s</a> = <a href="#1077528" title="(x: AnyRef)String">toString</a><span class="delimiter">(</span><a href="#1077585" title="AnyRef">c</a><span class="delimiter">)</span>; <a href="../../../Tuple2.scala.html#62849" title="(_1: String, _2: Int)(String, Int)" class="delimiter">(</a><a href="#1077586" title="String">s</a>, <a href="#1077586" title="String">s</a>.<span title="()Int">length</span><span class="delimiter">)</span><span class="delimiter">}</span> <a href="../../../collection/generic/GenericTraversableTemplate.scala.html#58476" title="(implicit asPair: ((String, Int)) =&gt; (String, Int))(Seq[String], Seq[Int])">unzip</a>
        <span class="keyword">val</span> <a title="Int" id="1077571">maxLen</a> = <a href="#1069176" title="(xs: Seq[Int])Int">max</a><span class="delimiter">(</span><a href="#1077570" title="Seq[Int]">colLens</a><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Int" id="1077572">avgLen</a> = <a href="#1077570" title="Seq[Int]">colLens</a>.<a href="../../../collection/TraversableOnce.scala.html#58232" title="(implicit num: Numeric[Int])Int">sum</a><a href="../../../Int.scala.html#57175" title="(x: Int)Int">/</a><a href="#1077570" title="Seq[Int]">colLens</a>.<a href="../../../collection/SeqLike.scala.html#58783" title="=&gt; Int">length</a>
        <span class="keyword">val</span> <a title="Int" id="1077573">goalLen</a> = <a href="../../../LowPriorityImplicits.scala.html#7395" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">maxLen</a> <a href="../../../runtime/RichInt.scala.html#57064" title="(that: Int)Int">min</a> <a href="#1077572" title="Int">avgLen</a><a href="../../../Int.scala.html#57168" title="(x: Int)Int">*</a><span title="Int(2)" class="int">2</span>
        <span class="keyword">def</span> <a title="(s: String)String" id="1077574">pad</a><span class="delimiter">(</span><a title="String" id="1077658">s</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="Int" id="1077659">toAdd</a> = <span class="delimiter">(</span><span class="delimiter">(</span><a href="#1077573" title="Int">goalLen</a> <a href="../../../LowPriorityImplicits.scala.html#7395" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">-</a> <a href="#1077658" title="String">s</a>.<span title="()Int">length</span><span class="delimiter">)</span> <a href="../../../runtime/RichInt.scala.html#57065" title="(that: Int)Int">max</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="../../../Int.scala.html#57154" title="(x: Int)Int">+</a> <span title="Int(2)" class="int">2</span>
          <span class="delimiter">(</span><a href="../../../Predef.scala.html#7604" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot; &quot;</a> <a href="../../../collection/immutable/StringLike.scala.html#59852" title="(n: Int)String">*</a> <span class="delimiter">(</span><a href="#1077659" title="Int">toAdd</a><a href="../../../Int.scala.html#57175" title="(x: Int)Int">/</a><span title="Int(2)" class="int">2</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#1077658" title="String">s</a> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="../../../Predef.scala.html#7604" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot; &quot;</a> <a href="../../../collection/immutable/StringLike.scala.html#59852" title="(n: Int)String">*</a> <span class="delimiter">(</span><a href="#1077659" title="Int">toAdd</a><a href="../../../Int.scala.html#57175" title="(x: Int)Int">/</a><span title="Int(2)" class="int">2</span> <a href="../../../Int.scala.html#57154" title="(x: Int)Int">+</a> <span class="delimiter">(</span><a href="#1077659" title="Int">toAdd</a><a href="../../../Int.scala.html#57182" title="(x: Int)Int">%</a><span title="Int(2)" class="int">2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#1077527" title="Seq[AnyRef]">cols</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: AnyRef =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[AnyRef],String,Seq[String]])Seq[String]">map</a> <span class="delimiter">(</span><a title="AnyRef" id="1077716">x</a> =&gt; <a href="#1077574" title="(s: String)String">pad</a><span class="delimiter">(</span><a href="#1077528" title="(x: AnyRef)String">toString</a><span class="delimiter">(</span><a href="#1077716" title="AnyRef">x</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(xss: List[List[AnyRef]], sep: String, lineSep: String)String" id="1069178">alignAcrossRows</a><span class="delimiter">(</span><a title="List[List[AnyRef]]" id="1077404">xss</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[AnyRef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>AnyRef<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="String" id="1077405">sep</a>: <span title="String">String</span>, <a title="String" id="1077407">lineSep</a>: <span title="String">String</span> = <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Int" id="1077737">maxLen</a> = <a href="#1069176" title="(xs: Seq[Int])Int">max</a><span class="delimiter">(</span><a href="#1077404" title="List[List[AnyRef]]">xss</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[AnyRef] =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[AnyRef]],Int,Seq[Int]])Seq[Int]">map</a> <span class="delimiter">(</span><a href="#1077755" title="List[AnyRef]">_</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86373" title="=&gt; Int">length</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[List[AnyRef]]" id="1077738">padded</a> = <a href="#1077404" title="List[List[AnyRef]]">xss</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[AnyRef] =&gt; List[AnyRef])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[AnyRef]],List[AnyRef],List[List[AnyRef]]])List[List[AnyRef]]">map</a> <span class="delimiter">(</span><a title="List[AnyRef]" id="1077804">xs</a> =&gt; <a href="#1077804" title="List[AnyRef]">xs</a> <a href="../../../collection/immutable/List.scala.html#62697" title="(that: scala.collection.GenTraversableOnce[AnyRef])(implicit bf: scala.collection.generic.CanBuildFrom[List[AnyRef],AnyRef,List[AnyRef]])List[AnyRef]">++</a> <a href="../../../collection/immutable/List.scala.html#11953" title="scala.collection.immutable.List.type">List</a>.<a href="../../../collection/generic/GenTraversableFactory.scala.html#59945" title="(n: Int)(elem: =&gt; Null)List[Null]">fill</a><span class="delimiter">(</span><a href="#1077737" title="Int">maxLen</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <a href="#1077804" title="List[AnyRef]">xs</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86373" title="=&gt; Int">length</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#1077738" title="List[List[AnyRef]]">padded</a>.<a href="../../../collection/generic/GenericTraversableTemplate.scala.html#58491" title="(implicit asTraversable: List[AnyRef] =&gt; scala.collection.GenTraversableOnce[AnyRef])List[List[AnyRef]]">transpose</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[AnyRef] =&gt; Seq[String])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[AnyRef]],Seq[String],List[Seq[String]]])List[Seq[String]]">map</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Seq[String],List[Seq[String]]]" class="delimiter">(</a><a href="#1069177" title="(cols: Seq[AnyRef])Seq[String]">alignedColumns</a><span class="delimiter">)</span>.<a href="../../../collection/generic/GenericTraversableTemplate.scala.html#58491" title="(implicit asTraversable: Seq[String] =&gt; scala.collection.GenTraversableOnce[String])List[List[String]]">transpose</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[String] =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[String]],String,List[String]])List[String]">map</a> <span class="delimiter">(</span><a href="#1077988" title="List[String]">_</a>.<a href="../../../collection/TraversableOnce.scala.html#58283" title="(sep: String)String">mkString</a><span class="delimiter">(</span><a href="#1077405" title="String">sep</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../collection/TraversableOnce.scala.html#58283" title="(sep: String)String">mkString</a><span class="delimiter">(</span><a href="#1077407" title="String">lineSep</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  // http://www.cis.upenn.edu/~cis510/tcl/chap3.pdf
  // http://users.encs.concordia.ca/~ta_ahmed/ms_thesis.pdf
  <span class="keyword">trait</span> <a title="trait Logic extends Object with PatternMatching.this.Prettification" id="621394">Logic</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621393" title="PatternMatching.this.Prettification">Prettification</a> <span class="delimiter">{</span>
    <span class="keyword">class</span> <a title="class Prop extends Object" id="1069255">Prop</a>
    case <span class="keyword">class</span> <a title="class Eq extends Logic.this.Prop with Product with Serializable" id="1078847">Eq</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="Logic.this.Var" id="1078842">p</a>: <a href="#1069264" title="Logic.this.Var">Var</a>, <a title="Logic.this.Const" id="1078843">q</a>: <a href="#1069259" title="Logic.this.Const">Const</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069255" title="Logic.this.Prop">Prop</a>

    <span class="keyword">type</span> <a title="" id="1069259">Const</a>

    <span class="keyword">type</span> <a title=" &lt;: Logic.this.Const" id="1069260">TypeConst</a> &lt;: Const
    <span class="keyword">def</span> <a title="=&gt; Logic.this.TypeConstExtractor" id="1069261">TypeConst</a>: <a href="#1069262" title="Logic.this.TypeConstExtractor">TypeConstExtractor</a>
    <span class="keyword">trait</span> <a title="trait TypeConstExtractor extends Object" id="1069262">TypeConstExtractor</a> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)Logic.this.Const" id="1078081">apply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1078083">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="#1069259" title="Logic.this.Const">Const</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="=&gt; Logic.this.Const" id="1069263">NullConst</a>: <a href="#1069259" title="Logic.this.Const">Const</a>

    <span class="keyword">type</span> <a title=" &lt;: Logic.this.AbsVar" id="1069264">Var</a> &lt;: AbsVar

    <span class="keyword">trait</span> <a title="trait AbsVar extends Object" id="1069265">AbsVar</a> <span class="delimiter">{</span>
      // indicate we may later require a prop for V = C
      <span class="keyword">def</span> <a title="(c: Logic.this.Const)Unit" id="1078038">registerEquality</a><span class="delimiter">(</span><a title="Logic.this.Const" id="1078087">c</a>: <a href="#1069259" title="Logic.this.Const">Const</a><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#1515" title="Unit">Unit</a>

      // call this to indicate null is part of the domain
      <span class="keyword">def</span> <a title="()Unit" id="1078039">registerNull</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#1515" title="Unit">Unit</a>

      // can this variable be null?
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1078040">mayBeNull</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

      // compute the domain and return it (call registerNull first!)
      <span class="keyword">def</span> <a title="=&gt; Option[Set[Logic.this.Sym]]" id="1078041">domainSyms</a>: <a href="../../../Option.scala.html#978" title="Option[Set[Logic.this.Sym]]">Option</a><span class="delimiter">[</span>Set<span class="delimiter">[</span>Sym<span class="delimiter">]</span><span class="delimiter">]</span>

      // the symbol for this variable being equal to its statically known type
      // (only available if registerEquality has been called for that type before)
      <span class="keyword">def</span> <a title="=&gt; Option[Logic.this.Sym]" id="1078042">symForStaticTp</a>: <a href="../../../Option.scala.html#978" title="Option[Logic.this.Sym]">Option</a><span class="delimiter">[</span>Sym<span class="delimiter">]</span>

      // for this var, call it V, turn V = C into the equivalent proposition in boolean logic
      // registerEquality(c) must have been called prior to this call
      // in fact, all equalities relevant to this variable must have been registered
      <span class="keyword">def</span> <a title="(c: Logic.this.Const)Logic.this.Prop" id="1078043">propForEqualsTo</a><span class="delimiter">(</span><a title="Logic.this.Const" id="1078088">c</a>: <a href="#1069259" title="Logic.this.Const">Const</a><span class="delimiter">)</span>: <a href="#1069255" title="Logic.this.Prop">Prop</a>

      // populated by registerEquality
      // once implications has been called, must not call registerEquality anymore
      <span class="keyword">def</span> <a title="=&gt; List[(Logic.this.Sym, List[Logic.this.Sym], List[Logic.this.Sym])]" id="1078044">implications</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[(Logic.this.Sym, List[Logic.this.Sym], List[Logic.this.Sym])]">List</a><span class="delimiter">[</span><span class="delimiter">(</span>Sym, List<span class="delimiter">[</span>Sym<span class="delimiter">]</span>, List<span class="delimiter">[</span>Sym<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
    <span class="delimiter">}</span>

    // would be nice to statically check whether a prop is equational or pure,
    // but that requires typing relations like And(x: Tx, y: Ty) : (if(Tx == PureProp &amp;&amp; Ty == PureProp) PureProp else Prop)
    case <span class="keyword">class</span> <a title="class And extends Logic.this.Prop with Product with Serializable" id="1078851">And</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="Logic.this.Prop" id="1078343">a</a>: <a href="#1069255" title="Logic.this.Prop">Prop</a>, <a title="Logic.this.Prop" id="1078344">b</a>: <a href="#1069255" title="Logic.this.Prop">Prop</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069255" title="Logic.this.Prop">Prop</a>
    case <span class="keyword">class</span> <a title="class Or extends Logic.this.Prop with Product with Serializable" id="1078855">Or</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="Logic.this.Prop" id="1078366">a</a>: <a href="#1069255" title="Logic.this.Prop">Prop</a>, <a title="Logic.this.Prop" id="1078367">b</a>: <a href="#1069255" title="Logic.this.Prop">Prop</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069255" title="Logic.this.Prop">Prop</a>
    case <span class="keyword">class</span> <a title="class Not extends Logic.this.Prop with Product with Serializable" id="1078859">Not</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="Logic.this.Prop" id="1078512">a</a>: <a href="#1069255" title="Logic.this.Prop">Prop</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069255" title="Logic.this.Prop">Prop</a>

    case <span class="keyword">object</span> <a href="#1078229" title="Logic.this.True.type" id="1078237">True</a> <a href="../../../Product.scala.html#186" title="Product" class="keyword">extends</a> <a href="#1069255" title="Logic.this.Prop">Prop</a>
    case <span class="keyword">object</span> <a href="#1078243" title="Logic.this.False.type" id="1078251">False</a> <a href="../../../Product.scala.html#186" title="Product" class="keyword">extends</a> <a href="#1069255" title="Logic.this.Prop">Prop</a>

    // symbols are propositions
    case <span class="keyword">class</span> <a title="class Sym extends Logic.this.Prop with Product with Serializable" id="1078894">Sym</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><span class="keyword">val</span> <a title="Logic.this.Var" id="1078867">variable</a>: <a href="#1069264" title="Logic.this.Var">Var</a>, <span class="keyword">val</span> <a title="Logic.this.Const" id="1078868">const</a>: <a href="#1069259" title="Logic.this.Const">Const</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069255" title="Logic.this.Prop">Prop</a> <span class="delimiter">{</span>
      <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="Int" id="1078259">id</a> = <a href="#1069282" title="=&gt; Int">nextSymId</a>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1078260">toString</a> = <a href="../../../Predef.scala.html#7605" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">variable</a> <a href="../../../runtime/StringAdd.scala.html#60046" title="(other: String)String">+</a><span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1078868" title="=&gt; Logic.this.Const">const</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1078259" title="Int">id</a>
    <span class="delimiter">}</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="=&gt; Int" id="1069282">nextSymId</a> = <span class="delimiter">{</span><a href="#1069284" title="(x$1: Int)Unit">_symId</a> <a href="../../../Int.scala.html#57154" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>; <a href="#1069284" title="=&gt; Int">_symId</a><span class="delimiter">}</span>; <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="1069284">_symId</a> = <span title="Int(0)" class="int">0</span>


    <span class="keyword">def</span> <a title="(props: Iterable[Logic.this.Prop])Logic.this.Prop" id="1069286">/\</a><span class="delimiter">(</span><a title="Iterable[Logic.this.Prop]" id="1078326">props</a>: <a href="../../../collection/Iterable.scala.html#4163" title="Iterable[Logic.this.Prop]">Iterable</a><span class="delimiter">[</span>Prop<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="Logic.this.Prop" class="keyword">if</span> <span class="delimiter">(</span><a href="#1078326" title="Iterable[Logic.this.Prop]">props</a>.<a href="../../../collection/IterableLike.scala.html#58568" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#1078237" title="Logic.this.True.type">True</a> <span class="keyword">else</span> <a href="#1078326" title="Iterable[Logic.this.Prop]">props</a>.<a href="../../../collection/TraversableOnce.scala.html#58208" title="(op: (Logic.this.Prop, Logic.this.Prop) =&gt; Logic.this.Prop)Logic.this.Prop">reduceLeft</a><span class="delimiter">(</span><a href="#1078851" title="(a: Logic.this.Prop, b: Logic.this.Prop)Logic.this.And">And</a><span class="delimiter">(</span><a href="#1078337" title="Logic.this.Prop">_</a>, <a href="#1078338" title="Logic.this.Prop">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(props: Iterable[Logic.this.Prop])Logic.this.Prop" id="1069287">\/</a><span class="delimiter">(</span><a title="Iterable[Logic.this.Prop]" id="1078349">props</a>: <a href="../../../collection/Iterable.scala.html#4163" title="Iterable[Logic.this.Prop]">Iterable</a><span class="delimiter">[</span>Prop<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="Logic.this.Prop" class="keyword">if</span> <span class="delimiter">(</span><a href="#1078349" title="Iterable[Logic.this.Prop]">props</a>.<a href="../../../collection/IterableLike.scala.html#58568" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#1078251" title="Logic.this.False.type">False</a> <span class="keyword">else</span> <a href="#1078349" title="Iterable[Logic.this.Prop]">props</a>.<a href="../../../collection/TraversableOnce.scala.html#58208" title="(op: (Logic.this.Prop, Logic.this.Prop) =&gt; Logic.this.Prop)Logic.this.Prop">reduceLeft</a><span class="delimiter">(</span><a href="#1078855" title="(a: Logic.this.Prop, b: Logic.this.Prop)Logic.this.Or">Or</a><span class="delimiter">(</span><a href="#1078360" title="Logic.this.Prop">_</a>, <a href="#1078361" title="Logic.this.Prop">_</a><span class="delimiter">)</span><span class="delimiter">)</span>


    <span class="keyword">trait</span> <a title="trait PropTraverser extends Object" id="1069288">PropTraverser</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="delimiter">{</a>
      <span class="keyword">def</span> <a title="(x: Logic.this.Prop)Unit" id="1078373">apply</a><span class="delimiter">(</span><a title="Logic.this.Prop" id="1078377">x</a>: <a href="#1069255" title="Logic.this.Prop">Prop</a><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#1515" title="Unit">Unit</a> = <a href="#1078377" title="Logic.this.Prop">x</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> And<a href="#3369287" title="Unit" id="3369289" class="delimiter">(</a><a href="#1078343" title="Logic.this.Prop" id="1078398">a</a>, <a href="#1078344" title="Logic.this.Prop" id="1078399">b</a><span class="delimiter">)</span> =&gt; <a href="#1078373" title="(x: Logic.this.Prop)Unit">apply</a><span class="delimiter">(</span><a href="#1078398" title="Logic.this.Prop">a</a><span class="delimiter">)</span>; <a href="#1078373" title="(x: Logic.this.Prop)Unit">apply</a><span class="delimiter">(</span><a href="#1078399" title="Logic.this.Prop">b</a><span class="delimiter">)</span>
        <span class="keyword">case</span> Or<a href="#3369287" title="Unit" id="3369291" class="delimiter">(</a><a href="#1078366" title="Logic.this.Prop" id="1078420">a</a>, <a href="#1078367" title="Logic.this.Prop" id="1078421">b</a><span class="delimiter">)</span> =&gt; <a href="#1078373" title="(x: Logic.this.Prop)Unit">apply</a><span class="delimiter">(</span><a href="#1078420" title="Logic.this.Prop">a</a><span class="delimiter">)</span>; <a href="#1078373" title="(x: Logic.this.Prop)Unit">apply</a><span class="delimiter">(</span><a href="#1078421" title="Logic.this.Prop">b</a><span class="delimiter">)</span>
        <span class="keyword">case</span> Not<a href="#3369287" title="Unit" id="3369293" class="delimiter">(</a><a href="#1078512" title="Logic.this.Prop" id="1078440">a</a><span class="delimiter">)</span> =&gt; <a href="#1078373" title="(x: Logic.this.Prop)Unit">apply</a><a href="#3369297" title="(x: Unit)Unit" class="delimiter">(</a><a href="#1078440" title="Logic.this.Prop">a</a><span class="delimiter">)</span>
        <span class="keyword">case</span> Eq<a href="#3369287" title="Unit" id="3369295" class="delimiter">(</a><a href="#1078842" title="Logic.this.Var" id="1078465">a</a>, <a href="#1078843" title="Logic.this.Const" id="1078466">b</a><span class="delimiter">)</span> =&gt; <a href="#1078374" title="(x: Logic.this.Var)Unit">applyVar</a><span class="delimiter">(</span><a href="#1078465" title="Logic.this.Var">a</a><span class="delimiter">)</span>; <a href="#1078375" title="(x: Logic.this.Const)Unit">applyConst</a><span class="delimiter">(</span><a href="#1078466" title="Logic.this.Const">b</a><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt;
      <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="(x: Logic.this.Var)Unit" id="1078374">applyVar</a><span class="delimiter">(</span><a title="Logic.this.Var" id="1078467">x</a>: <a href="#1069264" title="Logic.this.Var">Var</a><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#1515" title="Unit">Unit</a> = <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="(x: Logic.this.Const)Unit" id="1078375">applyConst</a><span class="delimiter">(</span><a title="Logic.this.Const" id="1078468">x</a>: <a href="#1069259" title="Logic.this.Const">Const</a><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#1515" title="Unit">Unit</a> = <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(p: Logic.this.Prop)Set[Logic.this.Var]" id="1069289">gatherVariables</a><span class="delimiter">(</span><a title="Logic.this.Prop" id="1078469">p</a>: <a href="#1069255" title="Logic.this.Prop">Prop</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/Set.scala.html#11919" title="Set[Logic.this.Var]">Set</a><span class="delimiter">[</span>Var<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Logic.this.Var]" id="1078471">vars</a> = <a href="../../../collection/mutable/HashSet.scala.html#125959" title="()scala.collection.mutable.HashSet[Logic.this.Var]" class="keyword">new</a> <a href="../../../collection/mutable/HashSet.scala.html#13053" title="scala.collection.mutable.HashSet[Logic.this.Var]">HashSet</a><span class="delimiter">[</span>Var<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">(</span><a href="#1078373" title="(x: Logic.this.Prop)Unit" class="keyword">new</a> <a title="anonymous class $anon extends Object with Logic.this.PropTraverser" id="1078473">PropTraverser</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(v: Logic.this.Var)Unit" id="1078475">applyVar</a><span class="delimiter">(</span><a title="Logic.this.Var" id="1078478">v</a>: <a href="#1069264" title="Logic.this.Var">Var</a><span class="delimiter">)</span> = <a href="#1078471" title="scala.collection.mutable.HashSet[Logic.this.Var]">vars</a> <a href="../../../collection/mutable/HashSet.scala.html#125963" title="(elem: Logic.this.Var)vars.type">+=</a> <a href="#1078478" title="Logic.this.Var">v</a>
      <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1078469" title="Logic.this.Prop">p</a><span class="delimiter">)</span>
      <a href="#1078471" title="scala.collection.mutable.HashSet[Logic.this.Var]">vars</a>.<a href="../../../collection/TraversableOnce.scala.html#58270" title="scala.collection.immutable.Set[Logic.this.Var]">toSet</a>
    <span class="delimiter">}</span>

    <span class="keyword">trait</span> <a title="trait PropMap extends Object" id="1069290">PropMap</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="delimiter">{</a>
      <span class="keyword">def</span> <a title="(x: Logic.this.Prop)Logic.this.Prop" id="1078500">apply</a><span class="delimiter">(</span><a title="Logic.this.Prop" id="1078502">x</a>: <a href="#1069255" title="Logic.this.Prop">Prop</a><span class="delimiter">)</span>: <a href="#1069255" title="Logic.this.Prop">Prop</a> = <a href="#1078502" title="Logic.this.Prop">x</a> <span class="keyword">match</span> <span class="delimiter">{</span> // TODO: mapConserve
        <span class="keyword">case</span> And<a href="#3369305" title="Logic.this.Prop" id="3369307" class="delimiter">(</a><a href="#1078343" title="Logic.this.Prop" id="1078503">a</a>, <a href="#1078344" title="Logic.this.Prop" id="1078504">b</a><span class="delimiter">)</span> =&gt; <a href="#1078851" title="(a: Logic.this.Prop, b: Logic.this.Prop)Logic.this.And">And</a><a href="#3369313" title="(x: Logic.this.Prop)Logic.this.Prop" class="delimiter">(</a><a href="#1078500" title="(x: Logic.this.Prop)Logic.this.Prop">apply</a><span class="delimiter">(</span><a href="#1078503" title="Logic.this.Prop">a</a><span class="delimiter">)</span>, <a href="#1078500" title="(x: Logic.this.Prop)Logic.this.Prop">apply</a><span class="delimiter">(</span><a href="#1078504" title="Logic.this.Prop">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> Or<a href="#3369305" title="Logic.this.Prop" id="3369309" class="delimiter">(</a><a href="#1078366" title="Logic.this.Prop" id="1078507">a</a>, <a href="#1078367" title="Logic.this.Prop" id="1078508">b</a><span class="delimiter">)</span> =&gt; <a href="#1078855" title="(a: Logic.this.Prop, b: Logic.this.Prop)Logic.this.Or">Or</a><a href="#3369313" title="(x: Logic.this.Prop)Logic.this.Prop" class="delimiter">(</a><a href="#1078500" title="(x: Logic.this.Prop)Logic.this.Prop">apply</a><span class="delimiter">(</span><a href="#1078507" title="Logic.this.Prop">a</a><span class="delimiter">)</span>, <a href="#1078500" title="(x: Logic.this.Prop)Logic.this.Prop">apply</a><span class="delimiter">(</span><a href="#1078508" title="Logic.this.Prop">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> Not<a href="#3369305" title="Logic.this.Prop" id="3369311" class="delimiter">(</a><a href="#1078512" title="Logic.this.Prop" id="1078511">a</a><span class="delimiter">)</span> =&gt; <a href="#1078859" title="(a: Logic.this.Prop)Logic.this.Not">Not</a><a href="#3369313" title="(x: Logic.this.Prop)Logic.this.Prop" class="delimiter">(</a><a href="#1078500" title="(x: Logic.this.Prop)Logic.this.Prop">apply</a><span class="delimiter">(</span><a href="#1078511" title="Logic.this.Prop">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> p =&gt; <a href="#3369313" title="(x: Logic.this.Prop)Logic.this.Prop">p</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    // convert finite domain propositional logic with subtyping to pure boolean propositional logic
    // a type test or a value equality test are modelled as a variable being equal to some constant
    // a variable V may be assigned multiple constants, as long as they do not contradict each other
    // according to subtyping, e.g., V = ConstantType(1) and V = Int are valid assignments
    // we rewrite V = C to a fresh boolean symbol, and model what we know about the variable's domain
    // in a prelude (the equality axioms)
    //   1. a variable with a closed domain (of a sealed type) must be assigned one of the instantiatable types in its domain
    //   2. for each variable V in props, and each constant C it is compared to,
    //      compute which assignments imply each other (as in the example above: V = 1 implies V = Int)
    //      and which assignments are mutually exclusive (V = String implies -(V = Int))
    //
    // note that this is a conservative approximation: V = Constant(A) and V = Constant(B)
    // are considered mutually exclusive (and thus both cases are considered reachable in {case A =&gt; case B =&gt;}),
    // even though A may be equal to B   (and thus the second case is not &quot;dynamically reachable&quot;)
    //
    // TODO: for V1 representing x1 and V2 standing for x1.head, encode that
    //       V1 = Nil implies -(V2 = Ci) for all Ci in V2's domain (i.e., it is unassignable)
    <span class="keyword">def</span> <a title="(props: List[Logic.this.Prop], modelNull: Boolean)(Logic.this.Prop, List[Logic.this.Prop])" id="1069291">removeVarEq</a><span class="delimiter">(</span><a title="List[Logic.this.Prop]" id="1078516">props</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[Logic.this.Prop]">List</a><span class="delimiter">[</span>Prop<span class="delimiter">]</span>, <a title="Boolean" id="1078519">modelNull</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="../../../Tuple2.scala.html#783" title="(Logic.this.Prop, List[Logic.this.Prop])" class="delimiter">(</a>Prop, List<span class="delimiter">[</span>Prop<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="(Long, Long)" id="1078520">start</a> = <span title="(Long, Long)" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415273" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415233" title="(tm: scala.reflect.internal.util.Statistics.Timer)(Long, Long)">startTimer</a><span class="delimiter">(</span><a href="#624642" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatAnaVarEq</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

      <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[Logic.this.Var]" id="1078521">vars</a> = <a href="../../../collection/mutable/HashSet.scala.html#125959" title="()scala.collection.mutable.HashSet[Logic.this.Var]" class="keyword">new</a> scala.collection.mutable.<a href="../../../collection/mutable/HashSet.scala.html#13053" title="scala.collection.mutable.HashSet[Logic.this.Var]">HashSet</a><span class="delimiter">[</span>Var<span class="delimiter">]</span>

      <span class="keyword">object</span> <a title="gatherEqualities.type" id="1078522">gatherEqualities</a> <a href="#1078523" title="gatherEqualities.type" class="keyword">extends</a> <a href="#1069288" title="Logic.this.PropTraverser">PropTraverser</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(p: Logic.this.Prop)Unit" id="1078531">apply</a><span class="delimiter">(</span><a title="Logic.this.Prop" id="1078533">p</a>: <a href="#1069255" title="Logic.this.Prop">Prop</a><span class="delimiter">)</span> = <a href="#1078533" title="Logic.this.Prop">p</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Eq<a href="#3369320" title="Unit" id="3369322" class="delimiter">(</a><a href="#1078842" title="Logic.this.Var" id="1078536">v</a>, <a href="#1078843" title="Logic.this.Const" id="1078537">c</a><span class="delimiter">)</span> =&gt;
            <a href="#1078521" title="scala.collection.mutable.HashSet[Logic.this.Var]">vars</a> <a href="../../../collection/mutable/HashSet.scala.html#125963" title="(elem: Logic.this.Var)vars.type">+=</a> <a href="#1078536" title="Logic.this.Var">v</a>
            <a href="#1078536" title="Logic.this.Var">v</a>.<a href="#1078038" title="(c: Logic.this.Const)Unit">registerEquality</a><span class="delimiter">(</span><a href="#1078537" title="Logic.this.Const">c</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt; <span class="keyword">super</span>.<a href="#1078373" title="(x: Logic.this.Prop)Unit">apply</a><a href="#3369324" title="(x: Unit)Unit" class="delimiter">(</a><a href="#1078533" title="Logic.this.Prop">p</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span class="keyword">object</span> <a title="rewriteEqualsToProp.type" id="1078524">rewriteEqualsToProp</a> <a href="#1078525" title="rewriteEqualsToProp.type" class="keyword">extends</a> <a href="#1069290" title="Logic.this.PropMap">PropMap</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(p: Logic.this.Prop)Logic.this.Prop" id="1078549">apply</a><span class="delimiter">(</span><a title="Logic.this.Prop" id="1078551">p</a>: <a href="#1069255" title="Logic.this.Prop">Prop</a><span class="delimiter">)</span> = <a href="#1078551" title="Logic.this.Prop">p</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Eq<a href="#3369329" title="Logic.this.Prop" id="3369331" class="delimiter">(</a><a href="#1078842" title="Logic.this.Var" id="1078554">v</a>, <a href="#1078843" title="Logic.this.Const" id="1078555">c</a><span class="delimiter">)</span> =&gt; <a href="#1078554" title="Logic.this.Var">v</a>.<a href="#1078043" title="(c: Logic.this.Const)Logic.this.Prop">propForEqualsTo</a><a href="#3369333" title="(x: Logic.this.Prop)Logic.this.Prop" class="delimiter">(</a><a href="#1078555" title="Logic.this.Const">c</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt; <span class="keyword">super</span>.<a href="#1078500" title="(x: Logic.this.Prop)Logic.this.Prop">apply</a><a href="#3369333" title="(x: Logic.this.Prop)Logic.this.Prop" class="delimiter">(</a><a href="#1078551" title="Logic.this.Prop">p</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#1078516" title="List[Logic.this.Prop]">props</a> <a href="../../../collection/immutable/List.scala.html#62719" title="(f: Logic.this.Prop =&gt; Unit)Unit">foreach</a> <a href="#1078522" title="gatherEqualities.type">gatherEqualities</a>.<a href="#1078531" title="(p: Logic.this.Prop)Unit">apply</a>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1078519" title="Boolean">modelNull</a><span class="delimiter">)</span> <a href="#1078521" title="scala.collection.mutable.HashSet[Logic.this.Var]">vars</a> <a href="../../../collection/mutable/HashSet.scala.html#125970" title="(f: Logic.this.Var =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a href="#1078597" title="Logic.this.Var">_</a>.<a href="#1078039" title="()Unit">registerNull</a><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="List[Logic.this.Prop]" id="1078526">pure</a> = <a href="#1078516" title="List[Logic.this.Prop]">props</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: Logic.this.Prop =&gt; Logic.this.Prop)(implicit bf: scala.collection.generic.CanBuildFrom[List[Logic.this.Prop],Logic.this.Prop,List[Logic.this.Prop]])List[Logic.this.Prop]">map</a> <a href="#1078524" title="rewriteEqualsToProp.type">rewriteEqualsToProp</a>.<a href="#1078549" title="(p: Logic.this.Prop)Logic.this.Prop">apply</a>

      <span class="keyword">var</span> <a title="Logic.this.Prop" id="1078527">eqAxioms</a>: <a href="#1069255" title="Logic.this.Prop">Prop</a> = <a href="#1078237" title="Logic.this.True.type">True</a>
      <span class="keyword">def</span> <a title="(p: Logic.this.Prop)Unit" id="1078528">addAxiom</a><span class="delimiter">(</span><a title="Logic.this.Prop" id="1078644">p</a>: <a href="#1069255" title="Logic.this.Prop">Prop</a><span class="delimiter">)</span> = <a href="#1078527" title="Logic.this.Prop">eqAxioms</a> = <a href="#1078851" title="(a: Logic.this.Prop, b: Logic.this.Prop)Logic.this.And">And</a><span class="delimiter">(</span><a href="#1078527" title="Logic.this.Prop">eqAxioms</a>, <a href="#1078644" title="Logic.this.Prop">p</a><span class="delimiter">)</span>

      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;removeVarEq vars: &quot;)" class="string">&quot;removeVarEq vars: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1078521" title="scala.collection.mutable.HashSet[Logic.this.Var]">vars</a><span class="delimiter">)</span>
      <a href="#1078521" title="scala.collection.mutable.HashSet[Logic.this.Var]">vars</a>.<a href="../../../collection/mutable/HashSet.scala.html#125970" title="(f: Logic.this.Var =&gt; Unit)Unit">foreach</a> <span class="delimiter">{</span> <a title="Logic.this.Var" id="1078657">v</a> =&gt;
        // if v.domainSyms.isEmpty, we must consider the domain to be infinite
        // otherwise, since the domain fully partitions the type of the value,
        // exactly one of the types (and whatever it implies, imposed separately) must be chosen
        // consider X ::= A | B | C, and A =&gt; B
        // coverage is formulated as: A \/ B \/ C and the implications are
        <a href="#1078657" title="Logic.this.Var">v</a>.<a href="#1078041" title="=&gt; Option[Set[Logic.this.Sym]]">domainSyms</a> <a href="../../../Option.scala.html#62884" title="(f: Set[Logic.this.Sym] =&gt; Unit)Unit">foreach</a> <span class="delimiter">{</span> <a title="Set[Logic.this.Sym]" id="1078662">dsyms</a> =&gt; <a href="#1078528" title="(p: Logic.this.Prop)Unit">addAxiom</a><span class="delimiter">(</span><a href="#1069287" title="(props: Iterable[Logic.this.Prop])Logic.this.Prop">\/</a><span class="delimiter">(</span><a href="#1078662" title="Set[Logic.this.Sym]">dsyms</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>

        // when this variable cannot be null the equality corresponding to the type test `(x: T)`, where T is x's static type,
        // is always true; when the variable may be null we use the implication `(x != null) =&gt; (x: T)` for the axiom
        <a href="#1078657" title="Logic.this.Var">v</a>.<a href="#1078042" title="=&gt; Option[Logic.this.Sym]">symForStaticTp</a> <a href="../../../Option.scala.html#62884" title="(f: Logic.this.Sym =&gt; Unit)Unit">foreach</a> <span class="delimiter">{</span> <a title="Logic.this.Sym" id="1078668">symForStaticTp</a> =&gt;
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1078657" title="Logic.this.Var">v</a>.<a href="#1078040" title="=&gt; Boolean">mayBeNull</a><span class="delimiter">)</span> <a href="#1078528" title="(p: Logic.this.Prop)Unit">addAxiom</a><span class="delimiter">(</span><a href="#1078855" title="(a: Logic.this.Prop, b: Logic.this.Prop)Logic.this.Or">Or</a><span class="delimiter">(</span><a href="#1078657" title="Logic.this.Var">v</a>.<a href="#1078043" title="(c: Logic.this.Const)Logic.this.Prop">propForEqualsTo</a><span class="delimiter">(</span><a href="#1069263" title="=&gt; Logic.this.Const">NullConst</a><span class="delimiter">)</span>, <a href="#1078668" title="Logic.this.Sym">symForStaticTp</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#1078528" title="(p: Logic.this.Prop)Unit">addAxiom</a><span class="delimiter">(</span><a href="#1078668" title="Logic.this.Sym">symForStaticTp</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        <a href="#1078657" title="Logic.this.Var">v</a>.<a href="#1078044" title="=&gt; List[(Logic.this.Sym, List[Logic.this.Sym], List[Logic.this.Sym])]">implications</a> <a href="../../../collection/immutable/List.scala.html#62719" title="(f: ((Logic.this.Sym, List[Logic.this.Sym], List[Logic.this.Sym])) =&gt; Unit)Unit">foreach</a> <a href="#1078694" title="(Logic.this.Sym, List[Logic.this.Sym], List[Logic.this.Sym])" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple3.scala.html#60576" title="Logic.this.Sym" id="1078698">sym</a>, <a href="../../../Tuple3.scala.html#60578" title="List[Logic.this.Sym]" id="1078699">implied</a>, <a href="../../../Tuple3.scala.html#60580" title="List[Logic.this.Sym]" id="1078700">excluded</a><span class="delimiter">)</span> =&gt;
          // when sym is true, what must hold...
          <a href="#1078699" title="List[Logic.this.Sym]">implied</a>  <a href="../../../collection/immutable/List.scala.html#62719" title="(f: Logic.this.Sym =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a title="Logic.this.Sym" id="1078721">impliedSym</a>  =&gt; <a href="#1078528" title="(p: Logic.this.Prop)Unit">addAxiom</a><span class="delimiter">(</span><a href="#1078855" title="(a: Logic.this.Prop, b: Logic.this.Prop)Logic.this.Or">Or</a><span class="delimiter">(</span><a href="#1078859" title="(a: Logic.this.Prop)Logic.this.Not">Not</a><span class="delimiter">(</span><a href="#1078698" title="Logic.this.Sym">sym</a><span class="delimiter">)</span>, <a href="#1078721" title="Logic.this.Sym">impliedSym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          // ... and what must not?
          <a href="#1078700" title="List[Logic.this.Sym]">excluded</a> <a href="../../../collection/immutable/List.scala.html#62719" title="(f: Logic.this.Sym =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a title="Logic.this.Sym" id="1078743">excludedSym</a> =&gt; <a href="#1078528" title="(p: Logic.this.Prop)Unit">addAxiom</a><span class="delimiter">(</span><a href="#1078855" title="(a: Logic.this.Prop, b: Logic.this.Prop)Logic.this.Or">Or</a><span class="delimiter">(</span><a href="#1078859" title="(a: Logic.this.Prop)Logic.this.Not">Not</a><span class="delimiter">(</span><a href="#1078698" title="Logic.this.Sym">sym</a><span class="delimiter">)</span>, <a href="#1078859" title="(a: Logic.this.Prop)Logic.this.Not">Not</a><span class="delimiter">(</span><a href="#1078743" title="Logic.this.Sym">excludedSym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;eqAxioms:\n&quot;)" class="string">&quot;eqAxioms:\n&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1069296" title="(f: Logic.this.Formula)String">cnfString</a><span class="delimiter">(</span><a href="#1069295" title="(p: Logic.this.Prop)Logic.this.Formula">eqFreePropToSolvable</a><span class="delimiter">(</span><a href="#1078527" title="Logic.this.Prop">eqAxioms</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;pure:&quot;)" class="string">&quot;pure:&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1078526" title="List[Logic.this.Prop]">pure</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: Logic.this.Prop =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Logic.this.Prop],String,List[String]])List[String]">map</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</a><a title="Logic.this.Prop" id="1078767">p</a> =&gt; <a href="#1069296" title="(f: Logic.this.Formula)String">cnfString</a><span class="delimiter">(</span><a href="#1069295" title="(p: Logic.this.Prop)Logic.this.Formula">eqFreePropToSolvable</a><span class="delimiter">(</span><a href="#1078767" title="Logic.this.Prop">p</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../collection/TraversableOnce.scala.html#58283" title="(sep: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415273" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415234" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: (Long, Long))Unit">stopTimer</a><span class="delimiter">(</span><a href="#624642" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatAnaVarEq</a>, <a href="#1078520" title="(Long, Long)">start</a><span class="delimiter">)</span>

      <a href="../../../Tuple2.scala.html#62849" title="(_1: Logic.this.Prop, _2: List[Logic.this.Prop])(Logic.this.Prop, List[Logic.this.Prop])" class="delimiter">(</a><a href="#1078527" title="Logic.this.Prop">eqAxioms</a>, <a href="#1078526" title="List[Logic.this.Prop]">pure</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>


    <span class="keyword">type</span> <a title="" id="1069292">Formula</a>
    <span class="keyword">def</span> <a title="(a: Logic.this.Formula, b: Logic.this.Formula)Logic.this.Formula" id="1069293">andFormula</a><span class="delimiter">(</span><a title="Logic.this.Formula" id="1078805">a</a>: <a href="#1069292" title="Logic.this.Formula">Formula</a>, <a title="Logic.this.Formula" id="1078806">b</a>: <a href="#1069292" title="Logic.this.Formula">Formula</a><span class="delimiter">)</span>: <a href="#1069292" title="Logic.this.Formula">Formula</a>


    // may throw an AnalysisBudget.Exception
    <span class="keyword">def</span> <a title="(p: Logic.this.Prop)Logic.this.Formula" id="1069294">propToSolvable</a><span class="delimiter">(</span><a title="Logic.this.Prop" id="1078808">p</a>: <a href="#1069255" title="Logic.this.Prop">Prop</a><span class="delimiter">)</span>: <a href="#1069292" title="Logic.this.Formula">Formula</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#3369351" title="(x: (Logic.this.Prop, Logic.this.Prop))(Logic.this.Prop, Logic.this.Prop)" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="Logic.this.Prop" id="1078811">eqAxioms</a>, <a href="../../../collection/immutable/List.scala.html#206583" title="Logic.this.Prop" id="1078812">pure</a> <a href="../../../Tuple2.scala.html#60637" title="List[Logic.this.Prop]" id="3369347">::</a> <a href="../../../collection/immutable/List.scala.html#206584" title="List[Logic.this.Prop]" id="3369349">Nil</a><span class="delimiter">)</span> = <a href="#1069291" title="(props: List[Logic.this.Prop], modelNull: Boolean)(Logic.this.Prop, List[Logic.this.Prop])">removeVarEq</a><a href="../../../Tuple2.scala.html#783" title="(Logic.this.Prop, List[Logic.this.Prop]) @unchecked" class="delimiter">(</a><a href="../../../collection/immutable/List.scala.html#62451" title="(xs: Logic.this.Prop*)List[Logic.this.Prop]">List</a><span class="delimiter">(</span><a href="#1078808" title="Logic.this.Prop">p</a><span class="delimiter">)</span>, modelNull = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
      <a href="#1069295" title="(p: Logic.this.Prop)Logic.this.Formula">eqFreePropToSolvable</a><span class="delimiter">(</span><a href="#1078851" title="(a: Logic.this.Prop, b: Logic.this.Prop)Logic.this.And">And</a><span class="delimiter">(</span><a href="#1078811" title="Logic.this.Prop">eqAxioms</a>, <a href="#1078812" title="Logic.this.Prop">pure</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // may throw an AnalysisBudget.Exception
    <span class="keyword">def</span> <a title="(p: Logic.this.Prop)Logic.this.Formula" id="1069295">eqFreePropToSolvable</a><span class="delimiter">(</span><a title="Logic.this.Prop" id="1078749">p</a>: <a href="#1069255" title="Logic.this.Prop">Prop</a><span class="delimiter">)</span>: <a href="#1069292" title="Logic.this.Formula">Formula</a>
    <span class="keyword">def</span> <a title="(f: Logic.this.Formula)String" id="1069296">cnfString</a><span class="delimiter">(</span><a title="Logic.this.Formula" id="1078747">f</a>: <a href="#1069292" title="Logic.this.Formula">Formula</a><span class="delimiter">)</span>: <span title="String">String</span>

    <span class="keyword">type</span> <a title="Map[Logic.this.Sym,Boolean]" id="1069297">Model</a> = <a href="../../../collection/immutable/Map.scala.html#11241" title="Map[Logic.this.Sym,Boolean]">Map</a><span class="delimiter">[</span>Sym, Boolean<span class="delimiter">]</span>
    <span class="keyword">val</span> <a title="=&gt; Logic.this.Model" id="1069298">EmptyModel</a>: <a href="../../../collection/immutable/Map.scala.html#11241" title="Logic.this.Model">Model</a>
    <span class="keyword">val</span> <a title="=&gt; Logic.this.Model" id="1069299">NoModel</a>: <a href="../../../collection/immutable/Map.scala.html#11241" title="Logic.this.Model">Model</a>

    <span class="keyword">def</span> <a title="(f: Logic.this.Formula)Logic.this.Model" id="1069300">findModelFor</a><span class="delimiter">(</span><a title="Logic.this.Formula" id="1078835">f</a>: <a href="#1069292" title="Logic.this.Formula">Formula</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/Map.scala.html#11241" title="Logic.this.Model">Model</a>
    <span class="keyword">def</span> <a title="(f: Logic.this.Formula)List[Logic.this.Model]" id="1069301">findAllModelsFor</a><span class="delimiter">(</span><a title="Logic.this.Formula" id="1078837">f</a>: <a href="#1069292" title="Logic.this.Formula">Formula</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[Logic.this.Model]">List</a><span class="delimiter">[</span>Model<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait CNF extends Object with PatternMatching.this.Logic" id="621395">CNF</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621394" title="PatternMatching.this.Logic">Logic</a> <span class="delimiter">{</span>
    // CNF: a formula is a conjunction of clauses
    <span class="keyword">type</span> <a title="Array[CNF.this.Clause]" id="1069303">Formula</a> = <a href="../../../Array.scala.html#174" title="Array[CNF.this.Clause]">Array</a><span class="delimiter">[</span>Clause<span class="delimiter">]</span>
    /** Override Array creation for efficiency (to not go through reflection). */
    <span class="keyword">private</span> <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scala.reflect.ClassTag[CNF.this.Formula]" id="1069304">formulaTag</a>: scala.reflect.<a href="../../../reflect/ClassTag.scala.html#2383" title="scala.reflect.ClassTag[CNF.this.Formula]">ClassTag</a><span class="delimiter">[</span>Formula<span class="delimiter">]</span> = <a href="#1078899" title="scala.reflect.ClassTag[CNF.this.Formula]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scala.reflect.ClassTag[CNF.this.Formula]" id="1078899">scala</a>.reflect.<a href="../../../reflect/ClassTag.scala.html#2383" title="scala.reflect.ClassTag[CNF.this.Formula]">ClassTag</a><span class="delimiter">[</span>Formula<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; Class[CNF.this.Formula]" id="1078901">runtimeClass</a>: java.lang.<span title="Class[CNF.this.Formula]">Class</span><span class="delimiter">[</span>Formula<span class="delimiter">]</span> = classOf<span title="Class[CNF.this.Formula](classOf[[Lscala.collection.immutable.Set;])" class="delimiter">[</span>Formula<span class="delimiter">]</span>
      <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="(len: Int)Array[CNF.this.Formula]" id="1078902">newArray</a><span class="delimiter">(</span><a title="Int" id="1078906">len</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../../Array.scala.html#174" title="Array[CNF.this.Formula]">Array</a><span class="delimiter">[</span>Formula<span class="delimiter">]</span> = <span title="Array[CNF.this.Formula]" class="keyword">new</span> <a href="../../../Array.scala.html#174" title="Array[CNF.this.Formula]">Array</a><span class="delimiter">[</span>Formula<span class="delimiter">]</span><span class="delimiter">(</span><a href="#1078906" title="Int">len</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(c: CNF.this.Clause*)CNF.this.Formula" id="1069306">formula</a><span class="delimiter">(</span><a title="CNF.this.Clause*" id="1078910">c</a>: <span title="CNF.this.Clause*">Clause</span>*<span class="delimiter">)</span>: <a href="../../../Array.scala.html#174" title="CNF.this.Formula">Formula</a> = <a href="#1078910" title="CNF.this.Clause*">c</a>.<a href="../../../collection/TraversableOnce.scala.html#58259" title="(implicit evidence$1: scala.reflect.ClassTag[CNF.this.Clause])Array[CNF.this.Clause]">toArray</a>
    <span class="keyword">def</span> <a title="(a: CNF.this.Formula, b: CNF.this.Formula)CNF.this.Formula" id="1069307">andFormula</a><span class="delimiter">(</span><a title="CNF.this.Formula" id="1078930">a</a>: <a href="../../../Array.scala.html#174" title="CNF.this.Formula">Formula</a>, <a title="CNF.this.Formula" id="1078931">b</a>: <a href="../../../Array.scala.html#174" title="CNF.this.Formula">Formula</a><span class="delimiter">)</span>: <a href="../../../Array.scala.html#174" title="CNF.this.Formula">Formula</a> = <a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">a</a> <a href="../../../collection/TraversableLike.scala.html#58048" title="(that: scala.collection.GenTraversableOnce[CNF.this.Clause])(implicit bf: scala.collection.generic.CanBuildFrom[Array[CNF.this.Clause],CNF.this.Clause,CNF.this.Formula])CNF.this.Formula">++</a> <a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">b</a>

    // a clause is a disjunction of distinct literals
    <span class="keyword">type</span> <a title="Set[CNF.this.Lit]" id="1069308">Clause</a> = <a href="../../../collection/immutable/Set.scala.html#11919" title="Set[CNF.this.Lit]">Set</a><span class="delimiter">[</span>Lit<span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="(l: CNF.this.Lit*)CNF.this.Clause" id="1069309">clause</a><span class="delimiter">(</span><a title="CNF.this.Lit*" id="1079480">l</a>: <span title="CNF.this.Lit*">Lit</span>*<span class="delimiter">)</span>: <a href="../../../collection/immutable/Set.scala.html#11919" title="CNF.this.Clause">Clause</a> = <a href="#1079480" title="CNF.this.Lit*">l</a>.<a href="../../../collection/TraversableOnce.scala.html#58270" title="scala.collection.immutable.Set[CNF.this.Lit]">toSet</a>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(a: CNF.this.Clause, b: CNF.this.Clause)scala.collection.immutable.Set[CNF.this.Lit]" id="1069310">merge</a><span class="delimiter">(</span><a title="CNF.this.Clause" id="1079487">a</a>: <a href="../../../collection/immutable/Set.scala.html#11919" title="CNF.this.Clause">Clause</a>, <a title="CNF.this.Clause" id="1079488">b</a>: <a href="../../../collection/immutable/Set.scala.html#11919" title="CNF.this.Clause">Clause</a><span class="delimiter">)</span> = <a href="#1079487" title="CNF.this.Clause">a</a> <a href="../../../collection/SetLike.scala.html#66445" title="(elems: scala.collection.GenTraversableOnce[CNF.this.Lit])scala.collection.immutable.Set[CNF.this.Lit]">++</a> <a href="#1079488" title="CNF.this.Clause">b</a>

    <span class="keyword">type</span> <a title="" id="1069311">Lit</a>
    <span class="keyword">def</span> <a title="(sym: CNF.this.Sym, pos: Boolean)CNF.this.Lit" id="1069312">Lit</a><span class="delimiter">(</span><a title="CNF.this.Sym" id="1079536">sym</a>: <a href="#1078894" title="CNF.this.Sym">Sym</a>, <a title="Boolean" id="1079539">pos</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>: <a href="#1069311" title="CNF.this.Lit">Lit</a>

    // throws an AnalysisBudget.Exception when the prop results in a CNF that's too big
    // TODO: be smarter/more efficient about this (http://lara.epfl.ch/w/sav09:tseitin_s_encoding)
    <span class="keyword">def</span> <a title="(p: CNF.this.Prop)CNF.this.Formula" id="1069313">eqFreePropToSolvable</a><span class="delimiter">(</span><a title="CNF.this.Prop" id="1079540">p</a>: <a href="#1069255" title="CNF.this.Prop">Prop</a><span class="delimiter">)</span>: <a href="../../../Array.scala.html#174" title="CNF.this.Formula">Formula</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(p: CNF.this.Prop, budget: Int)CNF.this.Prop" id="1079543">negationNormalFormNot</a><span class="delimiter">(</span><a title="CNF.this.Prop" id="1079552">p</a>: <a href="#1069255" title="CNF.this.Prop">Prop</a>, <a title="Int" id="1079554">budget</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a> = <a href="#621359" title="PatternMatching.this.AnalysisBudget.type">AnalysisBudget</a>.<a href="#1068830" title="=&gt; Int">max</a><span class="delimiter">)</span>: <a href="#1069255" title="CNF.this.Prop">Prop</a> =
        <span title="CNF.this.Prop" class="keyword">if</span> <span class="delimiter">(</span><a href="#1079554" title="Int">budget</a> <a href="../../../Int.scala.html#57118" title="(x: Int)Boolean">&lt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <a href="#621359" title="PatternMatching.this.AnalysisBudget.type">AnalysisBudget</a>.<a href="#1068908" title="PatternMatching.this.AnalysisBudget.exceeded.type">exceeded</a>
        <span class="keyword">else</span> <a href="#1079552" title="CNF.this.Prop">p</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> And<a href="#3369358" title="CNF.this.Prop" id="3369360" class="delimiter">(</a><a href="#1078343" title="CNF.this.Prop" id="1079561">a</a>, <a href="#1078344" title="CNF.this.Prop" id="1079562">b</a><span class="delimiter">)</span> =&gt;  <a href="#1078855" title="(a: CNF.this.Prop, b: CNF.this.Prop)CNF.this.Or">Or</a><a href="#3369372" title="(x: CNF.this.Prop)CNF.this.Prop" class="delimiter">(</a><a href="#1079543" title="(p: CNF.this.Prop, budget: Int)CNF.this.Prop">negationNormalFormNot</a><span class="delimiter">(</span><a href="#1079561" title="CNF.this.Prop">a</a>, <a href="#1079554" title="Int">budget</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>, <a href="#1079543" title="(p: CNF.this.Prop, budget: Int)CNF.this.Prop">negationNormalFormNot</a><span class="delimiter">(</span><a href="#1079562" title="CNF.this.Prop">b</a>, <a href="#1079554" title="Int">budget</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> Or<a href="#3369358" title="CNF.this.Prop" id="3369362" class="delimiter">(</a><a href="#1078366" title="CNF.this.Prop" id="1079577">a</a>, <a href="#1078367" title="CNF.this.Prop" id="1079578">b</a><span class="delimiter">)</span>  =&gt; <a href="#1078851" title="(a: CNF.this.Prop, b: CNF.this.Prop)CNF.this.And">And</a><a href="#3369372" title="(x: CNF.this.Prop)CNF.this.Prop" class="delimiter">(</a><a href="#1079543" title="(p: CNF.this.Prop, budget: Int)CNF.this.Prop">negationNormalFormNot</a><span class="delimiter">(</span><a href="#1079577" title="CNF.this.Prop">a</a>, <a href="#1079554" title="Int">budget</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>, <a href="#1079543" title="(p: CNF.this.Prop, budget: Int)CNF.this.Prop">negationNormalFormNot</a><span class="delimiter">(</span><a href="#1079578" title="CNF.this.Prop">b</a>, <a href="#1079554" title="Int">budget</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> Not<a href="#3369358" title="CNF.this.Prop" id="3369364" class="delimiter">(</a><a href="#1078512" title="CNF.this.Prop" id="1079592">p</a><span class="delimiter">)</span>    =&gt; <a href="#1079544" title="(p: CNF.this.Prop, budget: Int)CNF.this.Prop">negationNormalForm</a><a href="#3369372" title="(x: CNF.this.Prop)CNF.this.Prop" class="delimiter">(</a><a href="#1079592" title="CNF.this.Prop">p</a>, <a href="#1079554" title="Int">budget</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="#1078237" title="CNF.this.Prop" id="3369368">True</a>      =&gt; <a href="#3369372" title="(x: CNF.this.Prop)CNF.this.Prop">False</a>
          <span class="keyword">case</span> <a href="#1078251" title="CNF.this.Prop" id="3369369">False</a>     =&gt; <a href="#3369372" title="(x: CNF.this.Prop)CNF.this.Prop">True</a>
          <span class="keyword">case</span> <a href="#3369358" title="CNF.this.Prop" id="3369370">s</a>: Sym    =&gt; <a href="#1078859" title="(a: CNF.this.Prop)CNF.this.Not">Not</a><a href="#3369372" title="(x: CNF.this.Prop)CNF.this.Prop" class="delimiter">(</a>s<span class="delimiter">)</span>
        <span class="delimiter">}</span>

      <span class="keyword">def</span> <a title="(p: CNF.this.Prop, budget: Int)CNF.this.Prop" id="1079544">negationNormalForm</a><span class="delimiter">(</span><a title="CNF.this.Prop" id="1079593">p</a>: <a href="#1069255" title="CNF.this.Prop">Prop</a>, <a title="Int" id="1079595">budget</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a> = <a href="#621359" title="PatternMatching.this.AnalysisBudget.type">AnalysisBudget</a>.<a href="#1068830" title="=&gt; Int">max</a><span class="delimiter">)</span>: <a href="#1069255" title="CNF.this.Prop">Prop</a> =
        <span title="CNF.this.Prop" class="keyword">if</span> <span class="delimiter">(</span><a href="#1079595" title="Int">budget</a> <a href="../../../Int.scala.html#57118" title="(x: Int)Boolean">&lt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <a href="#621359" title="PatternMatching.this.AnalysisBudget.type">AnalysisBudget</a>.<a href="#1068908" title="PatternMatching.this.AnalysisBudget.exceeded.type">exceeded</a>
        <span class="keyword">else</span> <a href="#1079593" title="CNF.this.Prop">p</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> And<a href="#3369387" title="CNF.this.Prop" id="3369389" class="delimiter">(</a><a href="#1078343" title="CNF.this.Prop" id="1079609">a</a>, <a href="#1078344" title="CNF.this.Prop" id="1079610">b</a><span class="delimiter">)</span>      =&gt; <a href="#1078851" title="(a: CNF.this.Prop, b: CNF.this.Prop)CNF.this.And">And</a><a href="#3369401" title="(x: CNF.this.Prop)CNF.this.Prop" class="delimiter">(</a><a href="#1079544" title="(p: CNF.this.Prop, budget: Int)CNF.this.Prop">negationNormalForm</a><span class="delimiter">(</span><a href="#1079609" title="CNF.this.Prop">a</a>, <a href="#1079595" title="Int">budget</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>, <a href="#1079544" title="(p: CNF.this.Prop, budget: Int)CNF.this.Prop">negationNormalForm</a><span class="delimiter">(</span><a href="#1079610" title="CNF.this.Prop">b</a>, <a href="#1079595" title="Int">budget</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> Or<a href="#3369387" title="CNF.this.Prop" id="3369391" class="delimiter">(</a><a href="#1078366" title="CNF.this.Prop" id="1079621">a</a>, <a href="#1078367" title="CNF.this.Prop" id="1079622">b</a><span class="delimiter">)</span>       =&gt;  <a href="#1078855" title="(a: CNF.this.Prop, b: CNF.this.Prop)CNF.this.Or">Or</a><a href="#3369401" title="(x: CNF.this.Prop)CNF.this.Prop" class="delimiter">(</a><a href="#1079544" title="(p: CNF.this.Prop, budget: Int)CNF.this.Prop">negationNormalForm</a><span class="delimiter">(</span><a href="#1079621" title="CNF.this.Prop">a</a>, <a href="#1079595" title="Int">budget</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>, <a href="#1079544" title="(p: CNF.this.Prop, budget: Int)CNF.this.Prop">negationNormalForm</a><span class="delimiter">(</span><a href="#1079622" title="CNF.this.Prop">b</a>, <a href="#1079595" title="Int">budget</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> Not<a href="#3369387" title="CNF.this.Prop" id="3369393" class="delimiter">(</a><a href="#1078512" title="CNF.this.Prop" id="1079634">negated</a><span class="delimiter">)</span>   =&gt; <a href="#1079543" title="(p: CNF.this.Prop, budget: Int)CNF.this.Prop">negationNormalFormNot</a><a href="#3369401" title="(x: CNF.this.Prop)CNF.this.Prop" class="delimiter">(</a><a href="#1079634" title="CNF.this.Prop">negated</a>, <a href="#1079595" title="Int">budget</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="#1078237" title="CNF.this.Prop" id="3369397">True</a>
             | <a href="#1078251" title="Boolean" id="3369398">False</a>
             | <span class="delimiter">(</span>_ : Sym<span class="delimiter">)</span>      =&gt; <a href="#3369401" title="(x: CNF.this.Prop)CNF.this.Prop">p</a>
        <span class="delimiter">}</span>

      <span class="keyword">val</span> <a title="Array[scala.collection.immutable.Set[CNF.this.Lit]]" id="1079545">TrueF</a>          = <a href="#1069306" title="(c: CNF.this.Clause*)CNF.this.Formula">formula</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="CNF.this.Formula" id="1079546">FalseF</a>         = <a href="#1069306" title="(c: CNF.this.Clause*)CNF.this.Formula">formula</a><span class="delimiter">(</span><a href="#1069309" title="(l: CNF.this.Lit*)CNF.this.Clause">clause</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(s: CNF.this.Sym)CNF.this.Formula" id="1079547">lit</a><span class="delimiter">(</span><a title="CNF.this.Sym" id="1079639">s</a>: <a href="#1078894" title="CNF.this.Sym">Sym</a><span class="delimiter">)</span>    = <a href="#1069306" title="(c: CNF.this.Clause*)CNF.this.Formula">formula</a><span class="delimiter">(</span><a href="#1069309" title="(l: CNF.this.Lit*)CNF.this.Clause">clause</a><span class="delimiter">(</span><a href="#1069312" title="(sym: CNF.this.Sym, pos: Boolean)CNF.this.Lit">Lit</a><span class="delimiter">(</span><a href="#1079639" title="CNF.this.Sym">s</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(s: CNF.this.Sym)CNF.this.Formula" id="1079548">negLit</a><span class="delimiter">(</span><a title="CNF.this.Sym" id="1079642">s</a>: <a href="#1078894" title="CNF.this.Sym">Sym</a><span class="delimiter">)</span> = <a href="#1069306" title="(c: CNF.this.Clause*)CNF.this.Formula">formula</a><span class="delimiter">(</span><a href="#1069309" title="(l: CNF.this.Lit*)CNF.this.Clause">clause</a><span class="delimiter">(</span><a href="#1069312" title="(sym: CNF.this.Sym, pos: Boolean)CNF.this.Lit">Lit</a><span class="delimiter">(</span><a href="#1079642" title="CNF.this.Sym">s</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="keyword">def</span> <a title="(p: CNF.this.Prop, budget: Int)CNF.this.Formula" id="1079549">conjunctiveNormalForm</a><span class="delimiter">(</span><a title="CNF.this.Prop" id="1079643">p</a>: <a href="#1069255" title="CNF.this.Prop">Prop</a>, <a title="Int" id="1079645">budget</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a> = <a href="#621359" title="PatternMatching.this.AnalysisBudget.type">AnalysisBudget</a>.<a href="#1068830" title="=&gt; Int">max</a><span class="delimiter">)</span>: <a href="../../../Array.scala.html#174" title="CNF.this.Formula">Formula</a> = <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(a: CNF.this.Formula, b: CNF.this.Formula, budget: Int)CNF.this.Formula" id="1079646">distribute</a><span class="delimiter">(</span><a title="CNF.this.Formula" id="1079647">a</a>: <a href="../../../Array.scala.html#174" title="CNF.this.Formula">Formula</a>, <a title="CNF.this.Formula" id="1079648">b</a>: <a href="../../../Array.scala.html#174" title="CNF.this.Formula">Formula</a>, <a title="Int" id="1079649">budget</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../../Array.scala.html#174" title="CNF.this.Formula">Formula</a> =
          <span title="CNF.this.Formula" class="keyword">if</span> <span class="delimiter">(</span><a href="#1079649" title="Int">budget</a> <a href="../../../Int.scala.html#57118" title="(x: Int)Boolean">&lt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <a href="#621359" title="PatternMatching.this.AnalysisBudget.type">AnalysisBudget</a>.<a href="#1068908" title="PatternMatching.this.AnalysisBudget.exceeded.type">exceeded</a>
          <span class="keyword">else</span>
            <a href="../../../Tuple2.scala.html#62849" title="(_1: CNF.this.Formula, _2: CNF.this.Formula)(CNF.this.Formula, CNF.this.Formula)" class="delimiter">(</a><a href="#1079647" title="CNF.this.Formula">a</a>, <a href="#1079648" title="CNF.this.Formula">b</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
              // true \/ _ = true
              // _ \/ true = true
              <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="CNF.this.Formula" id="1079662">trueA</a>, <a href="../../../Tuple2.scala.html#60637" title="CNF.this.Formula" id="1079663">trueB</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">trueA</a>.<a href="../../../collection/SeqLike.scala.html#58788" title="=&gt; Int">size</a> <a href="../../../Int.scala.html#57097" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">trueB</a>.<a href="../../../collection/SeqLike.scala.html#58788" title="=&gt; Int">size</a> <a href="../../../Int.scala.html#57097" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span> =&gt; <a href="#3369428" title="(x: CNF.this.Formula)CNF.this.Formula">TrueF</a>
              // lit \/ lit
              <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="CNF.this.Formula" id="1079786">a</a>, <a href="../../../Tuple2.scala.html#60637" title="CNF.this.Formula" id="1079787">b</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">a</a>.<a href="../../../collection/SeqLike.scala.html#58788" title="=&gt; Int">size</a> <a href="../../../Int.scala.html#57097" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">b</a>.<a href="../../../collection/SeqLike.scala.html#58788" title="=&gt; Int">size</a> <a href="../../../Int.scala.html#57097" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span> =&gt; <a href="#1069306" title="(c: CNF.this.Clause*)CNF.this.Formula">formula</a><a href="#3369428" title="(x: CNF.this.Formula)CNF.this.Formula" class="delimiter">(</a><a href="#1069310" title="(a: CNF.this.Clause, b: CNF.this.Clause)scala.collection.immutable.Set[CNF.this.Lit]">merge</a><span class="delimiter">(</span><a href="../../../Array.scala.html#56639" title="(i: Int)CNF.this.Clause">a</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>, <a href="../../../Array.scala.html#56639" title="(i: Int)CNF.this.Clause">b</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              // (c1 /\ ... /\ cn) \/ d = ((c1 \/ d) /\ ... /\ (cn \/ d))
              // d \/ (c1 /\ ... /\ cn) = ((d \/ c1) /\ ... /\ (d \/ cn))
              <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="CNF.this.Formula" id="1079910">cs</a>, <a href="../../../Tuple2.scala.html#60637" title="CNF.this.Formula" id="1079911">ds</a><span class="delimiter">)</span> =&gt;
                <span class="keyword">val</span> <a href="#3369422" title="(x: (CNF.this.Formula, CNF.this.Formula))(CNF.this.Formula, CNF.this.Formula)" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="CNF.this.Formula" id="1079913">big</a>, <a href="../../../Tuple2.scala.html#60637" title="CNF.this.Formula" id="1079914">small</a><span class="delimiter">)</span> = <a href="#3369420" title="(CNF.this.Formula, CNF.this.Formula)" class="keyword">if</a> <span class="delimiter">(</span><a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">cs</a>.<a href="../../../collection/SeqLike.scala.html#58788" title="=&gt; Int">size</a> <a href="../../../Int.scala.html#57125" title="(x: Int)Boolean">&gt;</a> <a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">ds</a>.<a href="../../../collection/SeqLike.scala.html#58788" title="=&gt; Int">size</a><span class="delimiter">)</span> <a href="../../../Tuple2.scala.html#62849" title="(_1: CNF.this.Formula, _2: CNF.this.Formula)(CNF.this.Formula, CNF.this.Formula)" class="delimiter">(</a><a href="#1079910" title="CNF.this.Formula">cs</a>, <a href="#1079911" title="CNF.this.Formula">ds</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../../Tuple2.scala.html#62849" title="(_1: CNF.this.Formula, _2: CNF.this.Formula)(CNF.this.Formula, CNF.this.Formula)" class="delimiter">(</a><a href="#1079911" title="CNF.this.Formula">ds</a>, <a href="#1079910" title="CNF.this.Formula">cs</a><span class="delimiter">)</span>
                <a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">big</a> <a href="../../../collection/TraversableLike.scala.html#58068" title="(f: CNF.this.Clause =&gt; scala.collection.GenTraversableOnce[CNF.this.Clause])(implicit bf: scala.collection.generic.CanBuildFrom[Array[CNF.this.Clause],CNF.this.Clause,CNF.this.Formula])CNF.this.Formula">flatMap</a> <span class="delimiter">(</span><a title="CNF.this.Clause" id="1080457">c</a> =&gt; <a href="#1079646" title="(a: CNF.this.Formula, b: CNF.this.Formula, budget: Int)CNF.this.Formula">distribute</a><a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]" class="delimiter">(</a><a href="#1069306" title="(c: CNF.this.Clause*)CNF.this.Formula">formula</a><span class="delimiter">(</span><a href="#1080457" title="CNF.this.Clause">c</a><span class="delimiter">)</span>, <a href="#1079914" title="CNF.this.Formula">small</a>, <a href="#1079649" title="Int">budget</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span class="delimiter">(</span><a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">big</a>.<a href="../../../collection/SeqLike.scala.html#58788" title="=&gt; Int">size</a><a href="../../../Int.scala.html#57168" title="(x: Int)Int">*</a><a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">small</a>.<a href="../../../collection/SeqLike.scala.html#58788" title="=&gt; Int">size</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>

        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1079645" title="Int">budget</a> <a href="../../../Int.scala.html#57118" title="(x: Int)Boolean">&lt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <a href="#621359" title="PatternMatching.this.AnalysisBudget.type">AnalysisBudget</a>.<a href="#1068908" title="PatternMatching.this.AnalysisBudget.exceeded.type">exceeded</a>

        <a href="#1079643" title="CNF.this.Prop">p</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#1078237" title="CNF.this.Formula" id="3369445">True</a>        =&gt; <a href="#3369450" title="(x: CNF.this.Formula)CNF.this.Formula">TrueF</a>
          <span class="keyword">case</span> <a href="#1078251" title="CNF.this.Formula" id="3369446">False</a>       =&gt; <a href="#3369450" title="(x: CNF.this.Formula)CNF.this.Formula">FalseF</a>
          <span class="keyword">case</span> <a href="#3369434" title="CNF.this.Formula" id="3369447">s</a>: Sym      =&gt; <a href="#1079547" title="(s: CNF.this.Sym)CNF.this.Formula">lit</a><a href="#3369450" title="(x: CNF.this.Formula)CNF.this.Formula" class="delimiter">(</a>s<span class="delimiter">)</span>
          <span class="keyword">case</span> Not<a href="#3369434" title="CNF.this.Formula" id="3369439" class="delimiter">(</a><a href="#1078512" title="CNF.this.Prop" id="1080635">s</a>: Sym<span class="delimiter">)</span> =&gt; <a href="#1079548" title="(s: CNF.this.Sym)CNF.this.Formula">negLit</a><a href="#3369450" title="(x: CNF.this.Formula)CNF.this.Formula" class="delimiter">(</a>s<span class="delimiter">)</span>
          <span class="keyword">case</span> And<a href="#3369434" title="CNF.this.Formula" id="3369442" class="delimiter">(</a><a href="#1078343" title="CNF.this.Prop" id="1080638">a</a>, <a href="#1078344" title="CNF.this.Prop" id="1080639">b</a><span class="delimiter">)</span>   =&gt;
            <span class="keyword">val</span> <a title="CNF.this.Formula" id="1080640">cnfA</a> = <a href="#1079549" title="(p: CNF.this.Prop, budget: Int)CNF.this.Formula">conjunctiveNormalForm</a><span class="delimiter">(</span><a href="#1080638" title="CNF.this.Prop">a</a>, <a href="#1079645" title="Int">budget</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="CNF.this.Formula" id="1080641">cnfB</a> = <a href="#1079549" title="(p: CNF.this.Prop, budget: Int)CNF.this.Formula">conjunctiveNormalForm</a><span class="delimiter">(</span><a href="#1080639" title="CNF.this.Prop">b</a>, <a href="#1079645" title="Int">budget</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">cnfA</a>.<a href="../../../collection/SeqLike.scala.html#58788" title="=&gt; Int">size</a><span class="delimiter">)</span>
            <a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">cnfA</a> <a href="../../../collection/TraversableLike.scala.html#58048" title="(that: scala.collection.GenTraversableOnce[CNF.this.Clause])(implicit bf: scala.collection.generic.CanBuildFrom[Array[CNF.this.Clause],CNF.this.Clause,CNF.this.Formula])CNF.this.Formula">++</a> <a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">cnfB</a>
          <span class="keyword">case</span> Or<a href="#3369434" title="CNF.this.Formula" id="3369444" class="delimiter">(</a><a href="#1078366" title="CNF.this.Prop" id="1081252">a</a>, <a href="#1078367" title="CNF.this.Prop" id="1081253">b</a><span class="delimiter">)</span>    =&gt;
            <span class="keyword">val</span> <a title="CNF.this.Formula" id="1081254">cnfA</a> = <a href="#1079549" title="(p: CNF.this.Prop, budget: Int)CNF.this.Formula">conjunctiveNormalForm</a><span class="delimiter">(</span><a href="#1081252" title="CNF.this.Prop">a</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="CNF.this.Formula" id="1081255">cnfB</a> = <a href="#1079549" title="(p: CNF.this.Prop, budget: Int)CNF.this.Formula">conjunctiveNormalForm</a><span class="delimiter">(</span><a href="#1081253" title="CNF.this.Prop">b</a><span class="delimiter">)</span>
            <a href="#1079646" title="(a: CNF.this.Formula, b: CNF.this.Formula, budget: Int)CNF.this.Formula">distribute</a><span class="delimiter">(</span><a href="#1081254" title="CNF.this.Formula">cnfA</a>, <a href="#1081255" title="CNF.this.Formula">cnfB</a>, <a href="#1079645" title="Int">budget</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span class="delimiter">(</span><a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">cnfA</a>.<a href="../../../collection/SeqLike.scala.html#58788" title="=&gt; Int">size</a> <a href="../../../Int.scala.html#57154" title="(x: Int)Int">+</a> <a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">cnfB</a>.<a href="../../../collection/SeqLike.scala.html#58788" title="=&gt; Int">size</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span class="keyword">val</span> <a title="(Long, Long)" id="1079550">start</a> = <span title="(Long, Long)" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415273" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415233" title="(tm: scala.reflect.internal.util.Statistics.Timer)(Long, Long)">startTimer</a><span class="delimiter">(</span><a href="#624638" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatCNF</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>
      <span class="keyword">val</span> <a title="CNF.this.Formula" id="1079551">res</a>   = <a href="#1079549" title="(p: CNF.this.Prop, budget: Int)CNF.this.Formula">conjunctiveNormalForm</a><span class="delimiter">(</span><a href="#1079544" title="(p: CNF.this.Prop, budget: Int)CNF.this.Prop">negationNormalForm</a><span class="delimiter">(</span><a href="#1079540" title="CNF.this.Prop">p</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415273" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415234" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: (Long, Long))Unit">stopTimer</a><span class="delimiter">(</span><a href="#624638" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatCNF</a>, <a href="#1079550" title="(Long, Long)">start</a><span class="delimiter">)</span>

      //
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415273" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../collection/mutable/SynchronizedMap.scala.html#299904" title="(key: Int)scala.reflect.internal.util.Statistics.Counter">patmatCNFSizes</a><a href="#1081556" title="scala.reflect.internal.util.Statistics.Counter" class="delimiter">(</a><a href="../../../Predef.scala.html#7555" title="(xs: Array[CNF.this.Clause])scala.collection.mutable.ArrayOps[CNF.this.Clause]">res</a>.<a href="../../../collection/SeqLike.scala.html#58788" title="=&gt; Int">size</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/util/Statistics.scala.html#415383" title="(x$1: Int)Unit">value</a> <a href="../../../Int.scala.html#57154" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>

//      patmatDebug(&quot;cnf for\n&quot;+ p +&quot;\nis:\n&quot;+cnfString(res))
      <a href="#1079551" title="CNF.this.Formula">res</a>
    <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait DPLLSolver extends Object with PatternMatching.this.CNF" id="621396">DPLLSolver</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621395" title="PatternMatching.this.CNF">CNF</a> <span class="delimiter">{</span>
    // a literal is a (possibly negated) variable
    <span class="keyword">def</span> <a title="(sym: DPLLSolver.this.Sym, pos: Boolean)DPLLSolver.this.Lit" id="1069315">Lit</a><span class="delimiter">(</span><a title="DPLLSolver.this.Sym" id="1081563">sym</a>: <a href="#1078894" title="DPLLSolver.this.Sym">Sym</a>, <a title="Boolean" id="1081569">pos</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span> = <span title="DPLLSolver.this.Lit" class="keyword">new</span> <a href="#1069316" title="DPLLSolver.this.Lit">Lit</a><span class="delimiter">(</span><a href="#1081563" title="DPLLSolver.this.Sym">sym</a>, <a href="#1081569" title="Boolean">pos</a><span class="delimiter">)</span>
    <span class="keyword">class</span> <a title="class Lit extends Object" id="1069316">Lit</a><a href="#1069316" title="DPLLSolver.this.Lit" class="delimiter">(</a><span class="keyword">val</span> <a title="DPLLSolver.this.Sym" id="1081581">sym</a>: <a href="#1078894" title="DPLLSolver.this.Sym">Sym</a>, <span class="keyword">val</span> <a title="Boolean" id="1081582">pos</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1081577">toString</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1081582" title="=&gt; Boolean">pos</a><span class="delimiter">)</span> <span title="String(&quot;-&quot;)" class="string">&quot;-&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1081581" title="=&gt; DPLLSolver.this.Sym">sym</a>.<a href="#1078260" title="()String">toString</a> <span class="keyword">else</span> <a href="#1081581" title="=&gt; DPLLSolver.this.Sym">sym</a>.<a href="#1078260" title="()String">toString</a>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="(o: Any)Boolean" id="1081578">equals</a><span class="delimiter">(</span><a title="Any" id="1081589">o</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <a href="#1081589" title="Any">o</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="../../../Boolean.scala.html#57826" title="Boolean" id="3369468">o</a>: Lit =&gt; <span class="delimiter">(</span>o.<a href="#1081581" title="=&gt; DPLLSolver.this.Sym">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1081581" title="=&gt; DPLLSolver.this.Sym">sym</a><span class="delimiter">)</span> <a href="#3369470" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span>o.<a href="#1081582" title="=&gt; Boolean">pos</a> <a href="../../../Boolean.scala.html#57823" title="(x: Boolean)Boolean">==</a> <a href="#1081582" title="=&gt; Boolean">pos</a><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt; <a href="#3369470" title="(x: Boolean)Boolean" class="keyword">false</a>
      <span class="delimiter">}</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()Int" id="1081579">hashCode</a> = <a href="#1081581" title="=&gt; DPLLSolver.this.Sym">sym</a>.<a href="#1078894" title="()Int">hashCode</a> <a href="../../../Int.scala.html#57154" title="(x: Int)Int">+</a> <a href="#1081582" title="=&gt; Boolean">pos</a>.<span title="()Int">hashCode</span>

      <span class="keyword">def</span> <a title="=&gt; DPLLSolver.this.Lit" id="1081580">unary_-</a> = <a href="#1069315" title="(sym: DPLLSolver.this.Sym, pos: Boolean)DPLLSolver.this.Lit">Lit</a><span class="delimiter">(</span><a href="#1081581" title="=&gt; DPLLSolver.this.Sym">sym</a>, <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1081582" title="=&gt; Boolean">pos</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(f: DPLLSolver.this.Formula)String" id="1069317">cnfString</a><span class="delimiter">(</span><a title="DPLLSolver.this.Formula" id="1081608">f</a>: <a href="../../../Array.scala.html#174" title="DPLLSolver.this.Formula">Formula</a><span class="delimiter">)</span> = <a href="#1069178" title="(xss: List[List[AnyRef]], sep: String, lineSep: String)String">alignAcrossRows</a><span class="delimiter">(</span><a href="../../../Predef.scala.html#7555" title="(xs: Array[DPLLSolver.this.Clause])scala.collection.mutable.ArrayOps[DPLLSolver.this.Clause]">f</a> <a href="../../../Predef.scala.html#7555" title="(xs: Array[List[DPLLSolver.this.Lit]])scala.collection.mutable.ArrayOps[List[DPLLSolver.this.Lit]]">map</a> <span class="delimiter">(</span><a href="#1082017" title="DPLLSolver.this.Clause">_</a>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[DPLLSolver.this.Lit]">toList</a><span class="delimiter">)</span> <a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[List[DPLLSolver.this.Lit]]">toList</a>, <span title="String(&quot;\\/&quot;)" class="string">&quot;\\/&quot;</span>, <span title="String(&quot; /\\\n&quot;)" class="string">&quot; /\\\n&quot;</span><span class="delimiter">)</span>

    // adapted from http://lara.epfl.ch/w/sav10:simple_sat_solver (original by Hossein Hojjat)
    <span class="keyword">val</span> <a title="scala.collection.immutable.Map[DPLLSolver.this.Sym,Boolean]" id="1069318">EmptyModel</a> = <a href="../../../Predef.scala.html#7444" title="=&gt; scala.collection.immutable.Map.type">Map</a>.<a href="../../../collection/immutable/Map.scala.html#60770" title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</a><span title="scala.collection.immutable.Map[DPLLSolver.this.Sym,Boolean]" class="delimiter">[</span><a href="#1078894" title="DPLLSolver.this.Sym">Sym</a>, <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a><span class="delimiter">]</span>
    <span class="keyword">val</span> <a title="DPLLSolver.this.Model" id="1069320">NoModel</a>: <a href="../../../collection/immutable/Map.scala.html#11241" title="DPLLSolver.this.Model">Model</a> = <span title="Null(null)" class="keyword">null</span>

    // returns all solutions, if any (TODO: better infinite recursion backstop -- detect fixpoint??)
    <span class="keyword">def</span> <a title="(f: DPLLSolver.this.Formula)List[DPLLSolver.this.Model]" id="1069322">findAllModelsFor</a><span class="delimiter">(</span><a title="DPLLSolver.this.Formula" id="1082128">f</a>: <a href="../../../Array.scala.html#174" title="DPLLSolver.this.Formula">Formula</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[DPLLSolver.this.Model]">List</a><span class="delimiter">[</span>Model<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Set[DPLLSolver.this.Sym]" id="1082131">vars</a>: <a href="../../../collection/immutable/Set.scala.html#11919" title="Set[DPLLSolver.this.Sym]">Set</a><span class="delimiter">[</span>Sym<span class="delimiter">]</span> = <a href="../../../Predef.scala.html#7555" title="(xs: Array[DPLLSolver.this.Clause])scala.collection.mutable.ArrayOps[DPLLSolver.this.Clause]">f</a>.<a href="../../../collection/TraversableLike.scala.html#58068" title="(f: DPLLSolver.this.Clause =&gt; scala.collection.GenTraversableOnce[DPLLSolver.this.Sym])(implicit bf: scala.collection.generic.CanBuildFrom[Array[DPLLSolver.this.Clause],DPLLSolver.this.Sym,Array[DPLLSolver.this.Sym]])Array[DPLLSolver.this.Sym]">flatMap</a><a href="../../../Predef.scala.html#7555" title="(xs: Array[DPLLSolver.this.Sym])scala.collection.mutable.ArrayOps[DPLLSolver.this.Sym]" class="delimiter">(</a><a href="#1082539" title="DPLLSolver.this.Clause">_</a> <a href="../../../collection/TraversableLike.scala.html#58075" title="(pf: PartialFunction[DPLLSolver.this.Lit,DPLLSolver.this.Sym])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[DPLLSolver.this.Lit],DPLLSolver.this.Sym,scala.collection.immutable.Set[DPLLSolver.this.Sym]])scala.collection.immutable.Set[DPLLSolver.this.Sym]">collect</a> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[DPLLSolver.this.Lit,DPLLSolver.this.Sym] with Serializable" id="1082559" class="delimiter">{</a><span class="keyword">case</span> <a href="#3369475" title="B1" id="3369486">l</a>: Lit =&gt; l.<a href="#3369479" title="(x: B1)B1">sym</a><span class="delimiter">}</span><span class="delimiter">)</span>.<a href="../../../collection/TraversableOnce.scala.html#58270" title="scala.collection.immutable.Set[DPLLSolver.this.Sym]">toSet</a>
      // patmatDebug(&quot;vars &quot;+ vars)
      // the negation of a model -(S1=True/False /\ ... /\ SN=True/False) = clause(S1=False/True, ...., SN=False/True)
      <span class="keyword">def</span> <a title="(m: DPLLSolver.this.Model)DPLLSolver.this.Clause" id="1082132">negateModel</a><span class="delimiter">(</span><a title="DPLLSolver.this.Model" id="1082791">m</a>: <a href="../../../collection/immutable/Map.scala.html#11241" title="DPLLSolver.this.Model">Model</a><span class="delimiter">)</span> = <a href="#1069309" title="(l: DPLLSolver.this.Lit*)DPLLSolver.this.Clause">clause</a><span class="delimiter">(</span><a href="#1082791" title="DPLLSolver.this.Model">m</a>.<a href="../../../collection/MapLike.scala.html#87563" title="=&gt; Seq[(DPLLSolver.this.Sym, Boolean)]">toSeq</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: ((DPLLSolver.this.Sym, Boolean)) =&gt; DPLLSolver.this.Lit)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(DPLLSolver.this.Sym, Boolean)],DPLLSolver.this.Lit,Seq[DPLLSolver.this.Lit]])Seq[DPLLSolver.this.Lit]">map</a><a href="#1082812" title="(DPLLSolver.this.Sym, Boolean)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="DPLLSolver.this.Sym" id="1082815">sym</a>, <a href="../../../Tuple2.scala.html#60637" title="Boolean" id="1082816">pos</a><span class="delimiter">)</span> =&gt; <a href="#1069315" title="(sym: DPLLSolver.this.Sym, pos: Boolean)DPLLSolver.this.Lit">Lit</a><a href="#3369494" title="(x: DPLLSolver.this.Lit)DPLLSolver.this.Lit" class="delimiter">(</a><a href="#1082815" title="DPLLSolver.this.Sym">sym</a>, <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1082816" title="Boolean">pos</a><span class="delimiter">)</span> <span class="delimiter">}</span> : _*<span class="delimiter">)</span>

      <span class="keyword">def</span> <a title="(f: DPLLSolver.this.Formula, models: List[DPLLSolver.this.Model], recursionDepthAllowed: Int)List[DPLLSolver.this.Model]" id="1082133">findAllModels</a><span class="delimiter">(</span><a title="DPLLSolver.this.Formula" id="1082837">f</a>: <a href="../../../Array.scala.html#174" title="DPLLSolver.this.Formula">Formula</a>, <a title="List[DPLLSolver.this.Model]" id="1082838">models</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[DPLLSolver.this.Model]">List</a><span class="delimiter">[</span>Model<span class="delimiter">]</span>, <a title="Int" id="1082840">recursionDepthAllowed</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a> = <span title="Int(10)" class="int">10</span><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[DPLLSolver.this.Model]">List</a><span class="delimiter">[</span>Model<span class="delimiter">]</span>=
        <span title="List[DPLLSolver.this.Model]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1082840" title="Int">recursionDepthAllowed</a> <a href="../../../Int.scala.html#57097" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#1082838" title="List[DPLLSolver.this.Model]">models</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;find all models for\n&quot;)" class="string">&quot;find all models for\n&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1069317" title="(f: DPLLSolver.this.Formula)String">cnfString</a><span class="delimiter">(</span><a href="#1082837" title="DPLLSolver.this.Formula">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="DPLLSolver.this.Model" id="1082845">model</a> = <a href="#1069325" title="(f: DPLLSolver.this.Formula)DPLLSolver.this.Model">findModelFor</a><span class="delimiter">(</span><a href="#1082837" title="DPLLSolver.this.Formula">f</a><span class="delimiter">)</span>
          // if we found a solution, conjunct the formula with the model's negation and recurse
          <span title="List[DPLLSolver.this.Model]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1082845" title="DPLLSolver.this.Model">model</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#1069320" title="=&gt; DPLLSolver.this.Model">NoModel</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">val</span> <a title="List[DPLLSolver.this.Sym]" id="1082849">unassigned</a> = <span class="delimiter">(</span><a href="#1082131" title="Set[DPLLSolver.this.Sym]">vars</a> <a href="../../../collection/generic/Subtractable.scala.html#66460" title="(xs: scala.collection.GenTraversableOnce[DPLLSolver.this.Sym])scala.collection.immutable.Set[DPLLSolver.this.Sym]">--</a> <a href="#1082845" title="DPLLSolver.this.Model">model</a>.<a href="../../../collection/immutable/MapLike.scala.html#120411" title="=&gt; scala.collection.immutable.Set[DPLLSolver.this.Sym]">keySet</a><span class="delimiter">)</span>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[DPLLSolver.this.Sym]">toList</a>
            <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;unassigned &quot;)" class="string">&quot;unassigned &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1082849" title="List[DPLLSolver.this.Sym]">unassigned</a> <span title="(x$1: Any)String">+</span><span title="String(&quot; in &quot;)" class="string">&quot; in &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1082845" title="DPLLSolver.this.Model">model</a><span class="delimiter">)</span>
            <span class="keyword">def</span> <a title="(lit: DPLLSolver.this.Lit)List[DPLLSolver.this.Model]" id="1082850">force</a><span class="delimiter">(</span><a title="DPLLSolver.this.Lit" id="1082859">lit</a>: <a href="#1069316" title="DPLLSolver.this.Lit">Lit</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="DPLLSolver.this.Model" id="1082860">model</a> = <a href="#1069323" title="(res: DPLLSolver.this.Model, l: DPLLSolver.this.Lit)DPLLSolver.this.Model">withLit</a><span class="delimiter">(</span><a href="#1069325" title="(f: DPLLSolver.this.Formula)DPLLSolver.this.Model">findModelFor</a><span class="delimiter">(</span><a href="#1069324" title="(f: DPLLSolver.this.Formula, unitLit: DPLLSolver.this.Lit)Array[scala.collection.immutable.Set[DPLLSolver.this.Lit]]">dropUnit</a><span class="delimiter">(</span><a href="#1082837" title="DPLLSolver.this.Formula">f</a>, <a href="#1082859" title="DPLLSolver.this.Lit">lit</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#1082859" title="DPLLSolver.this.Lit">lit</a><span class="delimiter">)</span>
              <span title="List[DPLLSolver.this.Model]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1082860" title="DPLLSolver.this.Model">model</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#1069320" title="=&gt; DPLLSolver.this.Model">NoModel</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: DPLLSolver.this.Model*)List[DPLLSolver.this.Model]">List</a><span class="delimiter">(</span><a href="#1082860" title="DPLLSolver.this.Model">model</a><span class="delimiter">)</span>
              <span class="keyword">else</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>
            <span class="delimiter">}</span>
            <span class="keyword">val</span> <a title="List[DPLLSolver.this.Model]" id="1082851">forced</a> = <a href="#1082849" title="List[DPLLSolver.this.Sym]">unassigned</a> <a href="../../../collection/TraversableLike.scala.html#58068" title="(f: DPLLSolver.this.Sym =&gt; scala.collection.GenTraversableOnce[DPLLSolver.this.Model])(implicit bf: scala.collection.generic.CanBuildFrom[List[DPLLSolver.this.Sym],DPLLSolver.this.Model,List[DPLLSolver.this.Model]])List[DPLLSolver.this.Model]">flatMap</a> <span class="delimiter">{</span> <a title="DPLLSolver.this.Sym" id="1083483">s</a> =&gt;
              <a href="#1082850" title="(lit: DPLLSolver.this.Lit)List[DPLLSolver.this.Model]">force</a><span class="delimiter">(</span><a href="#1069315" title="(sym: DPLLSolver.this.Sym, pos: Boolean)DPLLSolver.this.Lit">Lit</a><span class="delimiter">(</span><a href="#1083483" title="DPLLSolver.this.Sym">s</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#62697" title="(that: scala.collection.GenTraversableOnce[DPLLSolver.this.Model])(implicit bf: scala.collection.generic.CanBuildFrom[List[DPLLSolver.this.Model],DPLLSolver.this.Model,List[DPLLSolver.this.Model]])List[DPLLSolver.this.Model]">++</a> <a href="#1082850" title="(lit: DPLLSolver.this.Lit)List[DPLLSolver.this.Model]">force</a><span class="delimiter">(</span><a href="#1069315" title="(sym: DPLLSolver.this.Sym, pos: Boolean)DPLLSolver.this.Lit">Lit</a><span class="delimiter">(</span><a href="#1083483" title="DPLLSolver.this.Sym">s</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;forced &quot;)" class="string">&quot;forced &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1082851" title="List[DPLLSolver.this.Model]">forced</a><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="DPLLSolver.this.Clause" id="1082852">negated</a> = <a href="#1082132" title="(m: DPLLSolver.this.Model)DPLLSolver.this.Clause">negateModel</a><span class="delimiter">(</span><a href="#1082845" title="DPLLSolver.this.Model">model</a><span class="delimiter">)</span>
            <a href="#1082133" title="(f: DPLLSolver.this.Formula, models: List[DPLLSolver.this.Model], recursionDepthAllowed: Int)List[DPLLSolver.this.Model]">findAllModels</a><span class="delimiter">(</span><a href="../../../Predef.scala.html#7555" title="(xs: Array[DPLLSolver.this.Clause])scala.collection.mutable.ArrayOps[DPLLSolver.this.Clause]">f</a> <a href="../../../collection/SeqLike.scala.html#58855" title="(elem: DPLLSolver.this.Clause)(implicit bf: scala.collection.generic.CanBuildFrom[Array[DPLLSolver.this.Clause],DPLLSolver.this.Clause,DPLLSolver.this.Formula])DPLLSolver.this.Formula">:+</a> <a href="#1082852" title="DPLLSolver.this.Clause">negated</a>, <a href="#1082845" title="DPLLSolver.this.Model">model</a> <a href="../../../collection/immutable/List.scala.html#62685" title="(x: DPLLSolver.this.Model)List[DPLLSolver.this.Model]">::</a> <span class="delimiter">(</span><a href="#1082851" title="List[DPLLSolver.this.Model]">forced</a> <a href="../../../collection/immutable/List.scala.html#62697" title="(that: scala.collection.GenTraversableOnce[DPLLSolver.this.Model])(implicit bf: scala.collection.generic.CanBuildFrom[List[DPLLSolver.this.Model],DPLLSolver.this.Model,List[DPLLSolver.this.Model]])List[DPLLSolver.this.Model]">++</a> <a href="#1082838" title="List[DPLLSolver.this.Model]">models</a><span class="delimiter">)</span>, <a href="#1082840" title="Int">recursionDepthAllowed</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <span class="keyword">else</span> <a href="#1082838" title="List[DPLLSolver.this.Model]">models</a>
        <span class="delimiter">}</span>

      <a href="#1082133" title="(f: DPLLSolver.this.Formula, models: List[DPLLSolver.this.Model], recursionDepthAllowed: Int)List[DPLLSolver.this.Model]">findAllModels</a><span class="delimiter">(</span><a href="#1082128" title="DPLLSolver.this.Formula">f</a>, <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(res: DPLLSolver.this.Model, l: DPLLSolver.this.Lit)DPLLSolver.this.Model" id="1069323">withLit</a><span class="delimiter">(</span><a title="DPLLSolver.this.Model" id="1082861">res</a>: <a href="../../../collection/immutable/Map.scala.html#11241" title="DPLLSolver.this.Model">Model</a>, <a title="DPLLSolver.this.Lit" id="1082862">l</a>: <a href="#1069316" title="DPLLSolver.this.Lit">Lit</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/Map.scala.html#11241" title="DPLLSolver.this.Model">Model</a> = <span title="DPLLSolver.this.Model" class="keyword">if</span> <span class="delimiter">(</span><a href="#1082861" title="DPLLSolver.this.Model">res</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#1069320" title="=&gt; DPLLSolver.this.Model">NoModel</a><span class="delimiter">)</span> <a href="#1069320" title="=&gt; DPLLSolver.this.Model">NoModel</a> <span class="keyword">else</span> <a href="#1082861" title="DPLLSolver.this.Model">res</a> <a href="../../../collection/immutable/Map.scala.html#62533" title="(kv: (DPLLSolver.this.Sym, Boolean))scala.collection.immutable.Map[DPLLSolver.this.Sym,Boolean]">+</a> <span class="delimiter">(</span><a href="#1082862" title="DPLLSolver.this.Lit">l</a>.<a href="../../../Predef.scala.html#7509" title="(x: DPLLSolver.this.Sym)ArrowAssoc[DPLLSolver.this.Sym]">sym</a> <a href="../../../Predef.scala.html#62634" title="(y: Boolean)(DPLLSolver.this.Sym, Boolean)">-&gt;</a> <a href="#1082862" title="DPLLSolver.this.Lit">l</a>.<a href="#1081582" title="=&gt; Boolean">pos</a><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(f: DPLLSolver.this.Formula, unitLit: DPLLSolver.this.Lit)Array[scala.collection.immutable.Set[DPLLSolver.this.Lit]]" id="1069324">dropUnit</a><span class="delimiter">(</span><a title="DPLLSolver.this.Formula" id="1082864">f</a>: <a href="../../../Array.scala.html#174" title="DPLLSolver.this.Formula">Formula</a>, <a title="DPLLSolver.this.Lit" id="1082865">unitLit</a>: <a href="#1069316" title="DPLLSolver.this.Lit">Lit</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="DPLLSolver.this.Lit" id="1082868">negated</a> = <a href="#1081580" title="=&gt; DPLLSolver.this.Lit">-</a><a href="#1082865" title="DPLLSolver.this.Lit">unitLit</a>
      // drop entire clauses that are trivially true
      // (i.e., disjunctions that contain the literal we're making true in the returned model),
      // and simplify clauses by dropping the negation of the literal we're making true
      // (since False \/ X == X)
      <a href="../../../Predef.scala.html#7555" title="(xs: Array[DPLLSolver.this.Clause])scala.collection.mutable.ArrayOps[DPLLSolver.this.Clause]">f</a>.<a href="../../../collection/TraversableLike.scala.html#58074" title="(p: DPLLSolver.this.Clause =&gt; Boolean)Array[DPLLSolver.this.Clause]">filterNot</a><a href="../../../Predef.scala.html#7555" title="(xs: Array[DPLLSolver.this.Clause])scala.collection.mutable.ArrayOps[DPLLSolver.this.Clause]" class="delimiter">(</a><a href="#1083005" title="DPLLSolver.this.Clause">_</a>.<a href="../../../collection/SetLike.scala.html#66442" title="(elem: DPLLSolver.this.Lit)Boolean">contains</a><span class="delimiter">(</span><a href="#1082865" title="DPLLSolver.this.Lit">unitLit</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: DPLLSolver.this.Clause =&gt; scala.collection.immutable.Set[DPLLSolver.this.Lit])(implicit bf: scala.collection.generic.CanBuildFrom[Array[DPLLSolver.this.Clause],scala.collection.immutable.Set[DPLLSolver.this.Lit],Array[scala.collection.immutable.Set[DPLLSolver.this.Lit]]])Array[scala.collection.immutable.Set[DPLLSolver.this.Lit]]">map</a><a href="../../../Array.scala.html#72249" title="(implicit t: scala.reflect.ClassTag[scala.collection.immutable.Set[DPLLSolver.this.Lit]])scala.collection.generic.CanBuildFrom[Array[_],scala.collection.immutable.Set[DPLLSolver.this.Lit],Array[scala.collection.immutable.Set[DPLLSolver.this.Lit]]]" class="delimiter">(</a><a href="#1083391" title="DPLLSolver.this.Clause">_</a> <a href="../../../collection/SetLike.scala.html#66446" title="(elem: DPLLSolver.this.Lit)scala.collection.immutable.Set[DPLLSolver.this.Lit]">-</a> <a href="#1082868" title="DPLLSolver.this.Lit">negated</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(f: DPLLSolver.this.Formula)DPLLSolver.this.Model" id="1069325">findModelFor</a><span class="delimiter">(</span><a title="DPLLSolver.this.Formula" id="1082846">f</a>: <a href="../../../Array.scala.html#174" title="DPLLSolver.this.Formula">Formula</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/Map.scala.html#11241" title="DPLLSolver.this.Model">Model</a> = <span class="delimiter">{</span>
      @inline <span class="keyword">def</span> <a title="(a: DPLLSolver.this.Model, b: =&gt; DPLLSolver.this.Model)DPLLSolver.this.Model" id="1084262">orElse</a><span class="delimiter">(</span><a title="DPLLSolver.this.Model" id="1084265">a</a>: <a href="../../../collection/immutable/Map.scala.html#11241" title="DPLLSolver.this.Model">Model</a>, <a title="=&gt; DPLLSolver.this.Model" id="1084266">b</a>: =&gt; Model<span class="delimiter">)</span> = <span title="DPLLSolver.this.Model" class="keyword">if</span> <span class="delimiter">(</span><a href="#1084265" title="DPLLSolver.this.Model">a</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#1069320" title="=&gt; DPLLSolver.this.Model">NoModel</a><span class="delimiter">)</span> <a href="#1084265" title="DPLLSolver.this.Model">a</a> <span class="keyword">else</span> <a href="#1084266" title="=&gt; DPLLSolver.this.Model">b</a>

      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;DPLL\n&quot;)" class="string">&quot;DPLL\n&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1069317" title="(f: DPLLSolver.this.Formula)String">cnfString</a><span class="delimiter">(</span><a href="#1082846" title="DPLLSolver.this.Formula">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="(Long, Long)" id="1084263">start</a> = <span title="(Long, Long)" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415273" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415233" title="(tm: scala.reflect.internal.util.Statistics.Timer)(Long, Long)">startTimer</a><span class="delimiter">(</span><a href="#624636" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatAnaDPLL</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

      <span class="keyword">val</span> <a title="DPLLSolver.this.Model" id="1084264">satisfiableWithModel</a>: <a href="../../../collection/immutable/Map.scala.html#11241" title="DPLLSolver.this.Model">Model</a> =
        <span title="scala.collection.immutable.Map[DPLLSolver.this.Sym,Boolean]" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Predef.scala.html#7555" title="(xs: Array[DPLLSolver.this.Clause])scala.collection.mutable.ArrayOps[DPLLSolver.this.Clause]">f</a> <a href="../../../collection/IndexedSeqOptimized.scala.html#59120" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#1069318" title="=&gt; scala.collection.immutable.Map[DPLLSolver.this.Sym,Boolean]">EmptyModel</a>
        <span class="keyword">else</span> <span title="DPLLSolver.this.Model" class="keyword">if</span><span class="delimiter">(</span><a href="../../../Predef.scala.html#7555" title="(xs: Array[DPLLSolver.this.Clause])scala.collection.mutable.ArrayOps[DPLLSolver.this.Clause]">f</a> <a href="../../../collection/IndexedSeqOptimized.scala.html#59125" title="(p: DPLLSolver.this.Clause =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#1084554" title="DPLLSolver.this.Clause">_</a>.<a href="../../../collection/SetLike.scala.html#66447" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#1069320" title="=&gt; DPLLSolver.this.Model">NoModel</a>
        <span class="keyword">else</span> <a href="../../../Predef.scala.html#7555" title="(xs: Array[DPLLSolver.this.Clause])scala.collection.mutable.ArrayOps[DPLLSolver.this.Clause]">f</a>.<a href="../../../collection/IndexedSeqOptimized.scala.html#59126" title="(p: DPLLSolver.this.Clause =&gt; Boolean)Option[DPLLSolver.this.Clause]">find</a><span title="DPLLSolver.this.Model" class="delimiter">(</span><a href="#1084787" title="DPLLSolver.this.Clause">_</a>.<a href="../../../collection/TraversableOnce.scala.html#58190" title="=&gt; Int">size</a> <a href="../../../Int.scala.html#57097" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Some<a href="#3369498" title="DPLLSolver.this.Model" id="3369499" class="delimiter">(</a><a href="../../../Option.scala.html#63132" title="DPLLSolver.this.Clause" id="1084794">unitClause</a><span class="delimiter">)</span> =&gt;
            <span class="keyword">val</span> <a title="DPLLSolver.this.Lit" id="1084795">unitLit</a> = <a href="#1084794" title="DPLLSolver.this.Clause">unitClause</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; DPLLSolver.this.Lit">head</a>
            // patmatDebug(&quot;unit: &quot;+ unitLit)
            <a href="#1069323" title="(res: DPLLSolver.this.Model, l: DPLLSolver.this.Lit)DPLLSolver.this.Model">withLit</a><span class="delimiter">(</span><a href="#1069325" title="(f: DPLLSolver.this.Formula)DPLLSolver.this.Model">findModelFor</a><span class="delimiter">(</span><a href="#1069324" title="(f: DPLLSolver.this.Formula, unitLit: DPLLSolver.this.Lit)Array[scala.collection.immutable.Set[DPLLSolver.this.Lit]]">dropUnit</a><span class="delimiter">(</span><a href="#1082846" title="DPLLSolver.this.Formula">f</a>, <a href="#1084795" title="DPLLSolver.this.Lit">unitLit</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#1084795" title="DPLLSolver.this.Lit">unitLit</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
            // partition symbols according to whether they appear in positive and/or negative literals
            <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]" id="1084796">pos</a> = <a href="../../../collection/mutable/HashSet.scala.html#125959" title="()scala.collection.mutable.HashSet[DPLLSolver.this.Sym]" class="keyword">new</a> <a href="../../../collection/mutable/HashSet.scala.html#13053" title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]">HashSet</a><span class="delimiter">[</span>Sym<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]" id="1084797">neg</a> = <a href="../../../collection/mutable/HashSet.scala.html#125959" title="()scala.collection.mutable.HashSet[DPLLSolver.this.Sym]" class="keyword">new</a> <a href="../../../collection/mutable/HashSet.scala.html#13053" title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]">HashSet</a><span class="delimiter">[</span>Sym<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
            <a href="../../../Predef.scala.html#7555" title="(xs: Array[DPLLSolver.this.Clause])scala.collection.mutable.ArrayOps[DPLLSolver.this.Clause]">f</a>.<a href="../../../collection/IndexedSeqOptimized.scala.html#59121" title="(f: DPLLSolver.this.Clause =&gt; Unit)Unit">foreach</a><span class="delimiter">{</span><a href="#1085564" title="DPLLSolver.this.Clause">_</a>.<a href="../../../collection/IterableLike.scala.html#58562" title="(f: DPLLSolver.this.Lit =&gt; scala.collection.mutable.HashSet[DPLLSolver.this.Sym])Unit">foreach</a><span class="delimiter">{</span> <a title="DPLLSolver.this.Lit" id="1085581">lit</a> =&gt;
              <span title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1085581" title="DPLLSolver.this.Lit">lit</a>.<a href="#1081582" title="=&gt; Boolean">pos</a><span class="delimiter">)</span> <a href="#1084796" title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]">pos</a> <a href="../../../collection/mutable/HashSet.scala.html#125963" title="(elem: DPLLSolver.this.Sym)pos.type">+=</a> <a href="#1085581" title="DPLLSolver.this.Lit">lit</a>.<a href="#1081581" title="=&gt; DPLLSolver.this.Sym">sym</a> <span class="keyword">else</span> <a href="#1084797" title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]">neg</a> <a href="../../../collection/mutable/HashSet.scala.html#125963" title="(elem: DPLLSolver.this.Sym)neg.type">+=</a> <a href="#1085581" title="DPLLSolver.this.Lit">lit</a>.<a href="#1081581" title="=&gt; DPLLSolver.this.Sym">sym</a>
            <span class="delimiter">}</span><span class="delimiter">}</span>
            // appearing in both positive and negative
            <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]" id="1084798">impures</a> = <a href="#1084796" title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]">pos</a> <a href="../../../collection/GenSetLike.scala.html#66404" title="(that: scala.collection.GenSet[DPLLSolver.this.Sym])scala.collection.mutable.HashSet[DPLLSolver.this.Sym]">intersect</a> <a href="#1084797" title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]">neg</a>
            // appearing only in either positive/negative positions
            <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]" id="1084799">pures</a> = <span class="delimiter">(</span><a href="#1084796" title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]">pos</a> <a href="../../../collection/mutable/SetLike.scala.html#90905" title="(xs: scala.collection.GenTraversableOnce[DPLLSolver.this.Sym])scala.collection.mutable.HashSet[DPLLSolver.this.Sym]">++</a> <a href="#1084797" title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]">neg</a><span class="delimiter">)</span> <a href="../../../collection/mutable/SetLike.scala.html#90908" title="(xs: scala.collection.GenTraversableOnce[DPLLSolver.this.Sym])scala.collection.mutable.HashSet[DPLLSolver.this.Sym]">--</a> <a href="#1084798" title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]">impures</a>

            <span title="DPLLSolver.this.Model" class="keyword">if</span> <span class="delimiter">(</span><a href="#1084799" title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]">pures</a> <a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="DPLLSolver.this.Sym" id="1085662">pureSym</a> = <a href="#1084799" title="scala.collection.mutable.HashSet[DPLLSolver.this.Sym]">pures</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; DPLLSolver.this.Sym">head</a>
              // turn it back into a literal
              // (since equality on literals is in terms of equality
              //  of the underlying symbol and its positivity, simply construct a new Lit)
              <span class="keyword">val</span> <a title="DPLLSolver.this.Lit" id="1085663">pureLit</a> = <a href="#1069315" title="(sym: DPLLSolver.this.Sym, pos: Boolean)DPLLSolver.this.Lit">Lit</a><span class="delimiter">(</span><a href="#1085662" title="DPLLSolver.this.Sym">pureSym</a>, <a href="../../../collection/GenSetLike.scala.html#66403" title="(elem: DPLLSolver.this.Sym)Boolean">pos</a><span class="delimiter">(</span><a href="#1085662" title="DPLLSolver.this.Sym">pureSym</a><span class="delimiter">)</span><span class="delimiter">)</span>
              // patmatDebug(&quot;pure: &quot;+ pureLit +&quot; pures: &quot;+ pures +&quot; impures: &quot;+ impures)
              <span class="keyword">val</span> <a title="Array[DPLLSolver.this.Clause]" id="1085664">simplified</a> = <a href="../../../Predef.scala.html#7555" title="(xs: Array[DPLLSolver.this.Clause])scala.collection.mutable.ArrayOps[DPLLSolver.this.Clause]">f</a>.<a href="../../../collection/TraversableLike.scala.html#58074" title="(p: DPLLSolver.this.Clause =&gt; Boolean)Array[DPLLSolver.this.Clause]">filterNot</a><span class="delimiter">(</span><a href="#1085812" title="DPLLSolver.this.Clause">_</a>.<a href="../../../collection/SetLike.scala.html#66442" title="(elem: DPLLSolver.this.Lit)Boolean">contains</a><span class="delimiter">(</span><a href="#1085663" title="DPLLSolver.this.Lit">pureLit</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#1069323" title="(res: DPLLSolver.this.Model, l: DPLLSolver.this.Lit)DPLLSolver.this.Model">withLit</a><span class="delimiter">(</span><a href="#1069325" title="(f: DPLLSolver.this.Formula)DPLLSolver.this.Model">findModelFor</a><span class="delimiter">(</span><a href="#1085664" title="Array[DPLLSolver.this.Clause]">simplified</a><span class="delimiter">)</span>, <a href="#1085663" title="DPLLSolver.this.Lit">pureLit</a><span class="delimiter">)</span>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">val</span> <a title="DPLLSolver.this.Lit" id="1085815">split</a> = <a href="../../../Predef.scala.html#7555" title="(xs: Array[DPLLSolver.this.Clause])scala.collection.mutable.ArrayOps[DPLLSolver.this.Clause]">f</a>.<a href="../../../collection/IndexedSeqOptimized.scala.html#59158" title="=&gt; DPLLSolver.this.Clause">head</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; DPLLSolver.this.Lit">head</a>
              // patmatDebug(&quot;split: &quot;+ split)
              <a href="#1084262" title="(a: DPLLSolver.this.Model, b: =&gt; DPLLSolver.this.Model)DPLLSolver.this.Model">orElse</a><span class="delimiter">(</span><a href="#1069325" title="(f: DPLLSolver.this.Formula)DPLLSolver.this.Model">findModelFor</a><span class="delimiter">(</span><a href="../../../Predef.scala.html#7555" title="(xs: Array[DPLLSolver.this.Clause])scala.collection.mutable.ArrayOps[DPLLSolver.this.Clause]">f</a> <a href="../../../collection/SeqLike.scala.html#58855" title="(elem: DPLLSolver.this.Clause)(implicit bf: scala.collection.generic.CanBuildFrom[Array[DPLLSolver.this.Clause],DPLLSolver.this.Clause,DPLLSolver.this.Formula])DPLLSolver.this.Formula">:+</a> <a href="#1069309" title="(l: DPLLSolver.this.Lit*)DPLLSolver.this.Clause">clause</a><span class="delimiter">(</span><a href="#1085815" title="DPLLSolver.this.Lit">split</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#1069325" title="(f: DPLLSolver.this.Formula)DPLLSolver.this.Model">findModelFor</a><span class="delimiter">(</span><a href="../../../Predef.scala.html#7555" title="(xs: Array[DPLLSolver.this.Clause])scala.collection.mutable.ArrayOps[DPLLSolver.this.Clause]">f</a> <a href="../../../collection/SeqLike.scala.html#58855" title="(elem: DPLLSolver.this.Clause)(implicit bf: scala.collection.generic.CanBuildFrom[Array[DPLLSolver.this.Clause],DPLLSolver.this.Clause,DPLLSolver.this.Formula])DPLLSolver.this.Formula">:+</a> <a href="#1069309" title="(l: DPLLSolver.this.Lit*)DPLLSolver.this.Clause">clause</a><span class="delimiter">(</span><a href="#1081580" title="=&gt; DPLLSolver.this.Lit">-</a><a href="#1085815" title="DPLLSolver.this.Lit">split</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415273" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415234" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: (Long, Long))Unit">stopTimer</a><span class="delimiter">(</span><a href="#624636" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatAnaDPLL</a>, <a href="#1084263" title="(Long, Long)">start</a><span class="delimiter">)</span>

        <a href="#1084264" title="DPLLSolver.this.Model">satisfiableWithModel</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  /**
   * Represent a match as a formula in propositional logic that encodes whether the match matches (abstractly: we only consider types)
   *
   */
  <span class="keyword">trait</span> <a title="trait SymbolicMatchAnalysis extends Object with PatternMatching.this.TreeMakerApproximation with PatternMatching.this.Logic" id="621397">SymbolicMatchAnalysis</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621392" title="PatternMatching.this.TreeMakerApproximation">TreeMakerApproximation</a> <span class="keyword">with</span> <a href="#621394" title="PatternMatching.this.Logic">Logic</a> <span class="delimiter">{</span> self: CodegenCore =&gt;
    <span class="keyword">def</span> <a title="()Unit" id="1069201">prepareNewAnalysis</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span> <a href="#1069202" title="SymbolicMatchAnalysis.this.Var.type">Var</a>.<a href="#1087198" title="()Unit">resetUniques</a><span class="delimiter">(</span><span class="delimiter">)</span>; <a href="#1069205" title="SymbolicMatchAnalysis.this.Const.type">Const</a>.<a href="#1087205" title="()Unit">resetUniques</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>

    <span class="keyword">object</span> <a title="SymbolicMatchAnalysis.this.Var.type" id="1069202">Var</a> <a href="#1069203" title="SymbolicMatchAnalysis.this.Var.type" class="delimiter">{</a>
      <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="1087195">_nextId</a> = <span title="Int(0)" class="int">0</span>
      <span class="keyword">def</span> <a title="=&gt; Int" id="1087197">nextId</a> = <span class="delimiter">{</span><a href="#1087195" title="(x$1: Int)Unit">_nextId</a> <a href="../../../Int.scala.html#57154" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>; <a href="#1087195" title="=&gt; Int">_nextId</a><span class="delimiter">}</span>

      <span class="keyword">def</span> <a title="()Unit" id="1087198">resetUniques</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span><a href="#1087195" title="(x$1: Int)Unit">_nextId</a> = <span title="Int(0)" class="int">0</span>; <a href="#1087199" title="=&gt; scala.collection.mutable.HashMap[PatternMatching.this.global.Tree,SymbolicMatchAnalysis.this.Var]">uniques</a>.<a href="../../../collection/mutable/HashMap.scala.html#88240" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">}</span>
      <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[PatternMatching.this.global.Tree,SymbolicMatchAnalysis.this.Var]" id="1087199">uniques</a> = <a href="../../../collection/mutable/HashMap.scala.html#88242" title="()scala.collection.mutable.HashMap[PatternMatching.this.global.Tree,SymbolicMatchAnalysis.this.Var]" class="keyword">new</a> scala.collection.mutable.<a href="../../../collection/mutable/HashMap.scala.html#12447" title="scala.collection.mutable.HashMap[PatternMatching.this.global.Tree,SymbolicMatchAnalysis.this.Var]">HashMap</a><span class="delimiter">[</span>Tree, Var<span class="delimiter">]</span>
      <span class="keyword">def</span> <a title="(x: PatternMatching.this.global.Tree)SymbolicMatchAnalysis.this.Var" id="1087201">apply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1087261">x</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="#1069204" title="SymbolicMatchAnalysis.this.Var">Var</a> = <a href="#1087199" title="=&gt; scala.collection.mutable.HashMap[PatternMatching.this.global.Tree,SymbolicMatchAnalysis.this.Var]">uniques</a> <a href="../../../collection/mutable/MapLike.scala.html#87629" title="(key: PatternMatching.this.global.Tree, op: =&gt; SymbolicMatchAnalysis.this.Var)SymbolicMatchAnalysis.this.Var">getOrElseUpdate</a><span class="delimiter">(</span><a href="#1087261" title="PatternMatching.this.global.Tree">x</a>, <span title="SymbolicMatchAnalysis.this.Var" class="keyword">new</span> <a href="#1069204" title="SymbolicMatchAnalysis.this.Var">Var</a><span class="delimiter">(</span><a href="#1087261" title="PatternMatching.this.global.Tree">x</a>, <a href="#1087261" title="PatternMatching.this.global.Tree">x</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">class</span> <a title="class Var extends Object with SymbolicMatchAnalysis.this.AbsVar" id="1069204">Var</a><a href="#1069204" title="SymbolicMatchAnalysis.this.Var" class="delimiter">(</a><span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1087252">path</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Type" id="1087253">staticTp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069265" title="SymbolicMatchAnalysis.this.AbsVar">AbsVar</a> <span class="delimiter">{</span>
      <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="Int" id="1087229">id</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a> = <a href="#1069202" title="SymbolicMatchAnalysis.this.Var.type">Var</a>.<a href="#1087197" title="=&gt; Int">nextId</a>

      // private[this] var canModify: Option[Array[StackTraceElement]] = None
      <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Unit" id="1087230">ensureCanModify</a> = <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span> //if (canModify.nonEmpty) patmatDebug(&quot;BUG!&quot;+ this +&quot; modified after having been observed: &quot;+ canModify.get.mkString(&quot;\n&quot;))

      <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Unit" id="1087231">observed</a> = <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span> //canModify = Some(Thread.currentThread.getStackTrace)

      // don't access until all potential equalities have been registered using registerEquality
      <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[SymbolicMatchAnalysis.this.Const,SymbolicMatchAnalysis.this.Sym]" id="1087232">symForEqualsTo</a> = <a href="../../../collection/mutable/HashMap.scala.html#88242" title="()scala.collection.mutable.HashMap[SymbolicMatchAnalysis.this.Const,SymbolicMatchAnalysis.this.Sym]" class="keyword">new</a> scala.collection.mutable.<a href="../../../collection/mutable/HashMap.scala.html#12447" title="scala.collection.mutable.HashMap[SymbolicMatchAnalysis.this.Const,SymbolicMatchAnalysis.this.Sym]">HashMap</a><span class="delimiter">[</span>Const, Sym<span class="delimiter">]</span>

      // when looking at the domain, we only care about types we can check at run time
      <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1087233">staticTpCheckable</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a> = <a href="#1069222" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">checkableType</a><span class="delimiter">(</span><a href="#1087253" title="PatternMatching.this.global.Type">staticTp</a><span class="delimiter">)</span>

      <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">var</span> <a title="Boolean" id="1087235">_mayBeNull</a> = <span title="Boolean(false)" class="keyword">false</span>
      <span class="keyword">def</span> <a title="()Unit" id="1087236">registerNull</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#1515" title="Unit">Unit</a> = <span class="delimiter">{</span> <a href="#1087230" title="=&gt; Unit">ensureCanModify</a>; <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1069215" title="=&gt; PatternMatching.this.global.UniqueConstantType">NullTp</a> <a href="../../../reflect/internal/Types.scala.html#408481" title="(that: PatternMatching.this.global.Type)Boolean">&lt;:&lt;</a> <a href="#1087233" title="=&gt; PatternMatching.this.global.Type">staticTpCheckable</a><span class="delimiter">)</span> <a href="#1087235" title="Boolean">_mayBeNull</a> = <span title="Boolean(true)" class="keyword">true</span> <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1087237">mayBeNull</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <a href="#1087235" title="Boolean">_mayBeNull</a>

      // case None =&gt; domain is unknown,
      // case Some(List(tps: _*)) =&gt; domain is exactly tps
      // we enumerate the subtypes of the full type, as that allows us to filter out more types statically,
      // once we go to run-time checks (on Const's), convert them to checkable types
      // TODO: there seems to be bug for singleton domains (variable does not show up in model)
      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Option[Set[SymbolicMatchAnalysis.this.Const]]" id="1087239">domain</a>: <a href="../../../Option.scala.html#978" title="Option[Set[SymbolicMatchAnalysis.this.Const]]">Option</a><span class="delimiter">[</span>Set<span class="delimiter">[</span>Const<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Option[scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const]]" id="1087283">subConsts</a> = <a href="#1069221" title="(tp: PatternMatching.this.global.Type)Option[List[PatternMatching.this.global.Type]]">enumerateSubtypes</a><span class="delimiter">(</span><a href="#1087253" title="PatternMatching.this.global.Type">staticTp</a><span class="delimiter">)</span>.<a href="../../../Option.scala.html#62865" title="(f: List[PatternMatching.this.global.Type] =&gt; scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const])Option[scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const]]">map</a><span class="delimiter">{</span> <a title="List[PatternMatching.this.global.Type]" id="1087291">tps</a> =&gt;
          <a href="#1087291" title="List[PatternMatching.this.global.Type]">tps</a>.<a href="../../../collection/TraversableOnce.scala.html#58270" title="[B &gt;: PatternMatching.this.global.Type]=&gt; scala.collection.immutable.Set[B]">toSet</a><span title="scala.collection.immutable.Set[PatternMatching.this.global.Type]" class="delimiter">[</span><a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">]</span>.<a href="../../../collection/SetLike.scala.html#66437" title="(f: PatternMatching.this.global.Type =&gt; SymbolicMatchAnalysis.this.Const)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[PatternMatching.this.global.Type],SymbolicMatchAnalysis.this.Const,scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const]])scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const]">map</a><a href="../../../collection/immutable/Set.scala.html#60805" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,SymbolicMatchAnalysis.this.Const,scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const]]" class="delimiter">{</a> <a title="PatternMatching.this.global.Type" id="1087321">tp</a> =&gt;
            <span class="keyword">val</span> <a title="SymbolicMatchAnalysis.this.Const" id="1087322">domainC</a> = <a href="#1087324" title="(tp: PatternMatching.this.global.Type)SymbolicMatchAnalysis.this.Const">TypeConst</a><span class="delimiter">(</span><a href="#1087321" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>
            <a href="#1087240" title="(c: SymbolicMatchAnalysis.this.Const)Unit">registerEquality</a><span class="delimiter">(</span><a href="#1087322" title="SymbolicMatchAnalysis.this.Const">domainC</a><span class="delimiter">)</span>
            <a href="#1087322" title="SymbolicMatchAnalysis.this.Const">domainC</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        <span class="keyword">val</span> <a title="Option[scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const]]" id="1087284">allConsts</a> =
          <span title="Option[scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1087237" title="=&gt; Boolean">mayBeNull</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="#1087240" title="(c: SymbolicMatchAnalysis.this.Const)Unit">registerEquality</a><span class="delimiter">(</span><a href="#1087986" title="SymbolicMatchAnalysis.this.NullConst.type">NullConst</a><span class="delimiter">)</span>
            <a href="#1087283" title="Option[scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const]]">subConsts</a> <a href="../../../Option.scala.html#62865" title="(f: scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const] =&gt; scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const])Option[scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const]]">map</a> <span class="delimiter">(</span><a href="#1087411" title="scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const]">_</a> <a href="../../../collection/SetLike.scala.html#66443" title="(elem: SymbolicMatchAnalysis.this.Const)scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const]">+</a> <a href="#1087986" title="SymbolicMatchAnalysis.this.NullConst.type">NullConst</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span>
            <a href="#1087283" title="Option[scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const]]">subConsts</a>

        <a href="#1087231" title="=&gt; Unit">observed</a>; <a href="#1087284" title="Option[scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const]]">allConsts</a>
      <span class="delimiter">}</span>

      // populate equalitySyms
      // don't care about the result, but want only one fresh symbol per distinct constant c
      <span class="keyword">def</span> <a title="(c: SymbolicMatchAnalysis.this.Const)Unit" id="1087240">registerEquality</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Const" id="1087378">c</a>: <a href="#1069207" title="SymbolicMatchAnalysis.this.Const">Const</a><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#1515" title="Unit">Unit</a> = <span class="delimiter">{</span><a href="#1087230" title="=&gt; Unit">ensureCanModify</a>; <a href="#1087232" title="scala.collection.mutable.HashMap[SymbolicMatchAnalysis.this.Const,SymbolicMatchAnalysis.this.Sym]">symForEqualsTo</a> <a href="../../../collection/mutable/MapLike.scala.html#87629" title="(key: SymbolicMatchAnalysis.this.Const, op: =&gt; SymbolicMatchAnalysis.this.Sym)SymbolicMatchAnalysis.this.Sym">getOrElseUpdate</a><span class="delimiter">(</span><a href="#1087378" title="SymbolicMatchAnalysis.this.Const">c</a>, <a href="#1078894" title="(variable: SymbolicMatchAnalysis.this.Var, const: SymbolicMatchAnalysis.this.Const)SymbolicMatchAnalysis.this.Sym">Sym</a><span class="delimiter">(</span><a href="#1069204" title="SymbolicMatchAnalysis.this.Var" class="keyword">this</a>, <a href="#1087378" title="SymbolicMatchAnalysis.this.Const">c</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">}</span>

      // return the symbol that represents this variable being equal to the constant `c`, if it exists, otherwise False (for robustness)
      // (registerEquality(c) must have been called prior, either when constructing the domain or from outside)
      <span class="keyword">def</span> <a title="(c: SymbolicMatchAnalysis.this.Const)SymbolicMatchAnalysis.this.Prop" id="1087241">propForEqualsTo</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Const" id="1087426">c</a>: <a href="#1069207" title="SymbolicMatchAnalysis.this.Const">Const</a><span class="delimiter">)</span>: <a href="#1069255" title="SymbolicMatchAnalysis.this.Prop">Prop</a> = <span class="delimiter">{</span><a href="#1087231" title="=&gt; Unit">observed</a>; <a href="#1087232" title="scala.collection.mutable.HashMap[SymbolicMatchAnalysis.this.Const,SymbolicMatchAnalysis.this.Sym]">symForEqualsTo</a>.<a href="../../../collection/MapLike.scala.html#87532" title="(key: SymbolicMatchAnalysis.this.Const, default: =&gt; Product with Serializable with SymbolicMatchAnalysis.this.Prop)Product with Serializable with SymbolicMatchAnalysis.this.Prop">getOrElse</a><span class="delimiter">(</span><a href="#1087426" title="SymbolicMatchAnalysis.this.Const">c</a>, <a href="#1078251" title="SymbolicMatchAnalysis.this.False.type">False</a><span class="delimiter">)</span><span class="delimiter">}</span>

      // [implementation NOTE: don't access until all potential equalities have been registered using registerEquality]p
      /** the information needed to construct the boolean proposition that encods the equality proposition (V = C)
       *
       * that models a type test pattern `_: C` or constant pattern `C`, where the type test gives rise to a TypeConst C,
       * and the constant pattern yields a ValueConst C
       *
       * for exhaustivity, we really only need implication (e.g., V = 1 implies that V = 1 /\ V = Int, if both tests occur in the match,
       * and thus in this variable's equality symbols), but reachability also requires us to model things like V = 1 precluding V = &quot;1&quot;
       */
      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="List[(SymbolicMatchAnalysis.this.Sym, List[SymbolicMatchAnalysis.this.Sym], List[SymbolicMatchAnalysis.this.Sym])]" id="1087243">implications</a> = <span class="delimiter">{</span>
        /** when we know V = C, which other equalities must hold
         *
         * in general, equality to some type implies equality to its supertypes
         * (this multi-valued kind of equality is necessary for unreachability)
         * note that we use subtyping as a model for implication between instanceof tests
         * i.e., when S &lt;:&lt; T we assume x.isInstanceOf[S] implies x.isInstanceOf[T]
         * unfortunately this is not true in general (see e.g. SI-6022)
         */
        <span class="keyword">def</span> <a title="(lower: SymbolicMatchAnalysis.this.Const, upper: SymbolicMatchAnalysis.this.Const)Boolean" id="1087456">implies</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Const" id="1087462">lower</a>: <a href="#1069207" title="SymbolicMatchAnalysis.this.Const">Const</a>, <a title="SymbolicMatchAnalysis.this.Const" id="1087463">upper</a>: <a href="#1069207" title="SymbolicMatchAnalysis.this.Const">Const</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> =
          // values and null
            <a href="#1087462" title="SymbolicMatchAnalysis.this.Const">lower</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1087463" title="SymbolicMatchAnalysis.this.Const">upper</a> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a>
          // type implication
            <span class="delimiter">(</span><a href="#1087462" title="SymbolicMatchAnalysis.this.Const">lower</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#1087986" title="SymbolicMatchAnalysis.this.NullConst.type">NullConst</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1087463" title="SymbolicMatchAnalysis.this.Const">upper</a>.<a href="#1087335" title="=&gt; Boolean">isValue</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a>
             <a href="#1069019" title="(tp: PatternMatching.this.global.Type, tpImplied: PatternMatching.this.global.Type)Boolean">instanceOfTpImplies</a><span class="delimiter">(</span><span title="PatternMatching.this.global.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#1087462" title="SymbolicMatchAnalysis.this.Const">lower</a>.<a href="#1087335" title="=&gt; Boolean">isValue</a><span class="delimiter">)</span> <a href="#1087462" title="SymbolicMatchAnalysis.this.Const">lower</a>.<a href="#1087333" title="=&gt; PatternMatching.this.global.Type">wideTp</a> <span class="keyword">else</span> <a href="#1087462" title="SymbolicMatchAnalysis.this.Const">lower</a>.<a href="#1087332" title="=&gt; PatternMatching.this.global.Type">tp</a>, <a href="#1087463" title="SymbolicMatchAnalysis.this.Const">upper</a>.<a href="#1087332" title="=&gt; PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>

          // if(r) patmatDebug(&quot;implies    : &quot;+(lower, lower.tp, upper, upper.tp))
          // else  patmatDebug(&quot;NOT implies: &quot;+(lower, upper))


        /** does V = C preclude V having value `other`?
         (1) V = null is an exclusive assignment,
         (2) V = A and V = B, for A and B value constants, are mutually exclusive unless A == B
             we err on the safe side, for example:
               - assume `val X = 1; val Y = 1`, then
                 (2: Int) match { case X =&gt; case Y =&gt;  &lt;falsely considered reachable&gt;  }
               - V = 1 does not preclude V = Int, or V = Any, it could be said to preclude V = String, but we don't model that

         (3) for types we could try to do something fancy, but be conservative and just say no
         */
        <span class="keyword">def</span> <a title="(a: SymbolicMatchAnalysis.this.Const, b: SymbolicMatchAnalysis.this.Const)Boolean" id="1087457">excludes</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Const" id="1087472">a</a>: <a href="#1069207" title="SymbolicMatchAnalysis.this.Const">Const</a>, <a title="SymbolicMatchAnalysis.this.Const" id="1087473">b</a>: <a href="#1069207" title="SymbolicMatchAnalysis.this.Const">Const</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> =
          <a href="#1087472" title="SymbolicMatchAnalysis.this.Const">a</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#1087473" title="SymbolicMatchAnalysis.this.Const">b</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#1087472" title="SymbolicMatchAnalysis.this.Const">a</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1087986" title="SymbolicMatchAnalysis.this.NullConst.type">NullConst</a> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="#1087473" title="SymbolicMatchAnalysis.this.Const">b</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1087986" title="SymbolicMatchAnalysis.this.NullConst.type">NullConst</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#1087472" title="SymbolicMatchAnalysis.this.Const">a</a>.<a href="#1087335" title="=&gt; Boolean">isValue</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1087473" title="SymbolicMatchAnalysis.this.Const">b</a>.<a href="#1087335" title="=&gt; Boolean">isValue</a><span class="delimiter">)</span><span class="delimiter">)</span>

          // if(r) patmatDebug(&quot;excludes    : &quot;+(a, a.tp, b, b.tp))
          // else  patmatDebug(&quot;NOT excludes: &quot;+(a, b))

/*
[ HALF BAKED FANCINESS: //!equalitySyms.exists(common =&gt; implies(common.const, a) &amp;&amp; implies(common.const, b)))
 when type tests are involved, we reason (conservatively) under a closed world assumption,
 since we are really only trying to counter the effects of the symbols that we introduce to model type tests
 we don't aim to model the whole subtyping hierarchy, simply to encode enough about subtyping to do unreachability properly

 consider the following hierarchy:

    trait A
    trait B
    trait C
    trait AB extends B with A

  // two types are mutually exclusive if there is no equality symbol whose constant implies both
  object Test extends App {
    def foo(x: Any) = x match {
      case _ : C  =&gt; println(&quot;C&quot;)
      case _ : AB =&gt; println(&quot;AB&quot;)
      case _ : (A with B) =&gt; println(&quot;AB'&quot;)
      case _ : B  =&gt; println(&quot;B&quot;)
      case _ : A  =&gt; println(&quot;A&quot;)
    }

 of course this kind of reasoning is not true in general,
 but we can safely pretend types are mutually exclusive as long as there are no counter-examples in the match we're analyzing}
*/

        <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[ExcludedPair]" id="1087458">excludedPair</a> = <a href="../../../collection/mutable/HashSet.scala.html#125959" title="()scala.collection.mutable.HashSet[ExcludedPair]" class="keyword">new</a> scala.collection.mutable.<a href="../../../collection/mutable/HashSet.scala.html#13053" title="scala.collection.mutable.HashSet[ExcludedPair]">HashSet</a><span class="delimiter">[</span>ExcludedPair<span class="delimiter">]</span>

        case <span class="keyword">class</span> <a title="class ExcludedPair extends AnyRef with Product with Serializable" id="1087584">ExcludedPair</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="SymbolicMatchAnalysis.this.Const" id="1087579">a</a>: <a href="#1069207" title="SymbolicMatchAnalysis.this.Const">Const</a>, <a title="SymbolicMatchAnalysis.this.Const" id="1087580">b</a>: <a href="#1069207" title="SymbolicMatchAnalysis.this.Const">Const</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">override</span> <span class="keyword">def</span> <a title="(o: Any)Boolean" id="1087494">equals</a><span class="delimiter">(</span><a title="Any" id="1087502">o</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <a href="#1087502" title="Any">o</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> ExcludedPair<a href="#3369506" title="Boolean" id="3369507" class="delimiter">(</a><a href="#1087579" title="SymbolicMatchAnalysis.this.Const" id="1087529">aa</a>, <a href="#1087580" title="SymbolicMatchAnalysis.this.Const" id="1087530">bb</a><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span><a href="#1087579" title="=&gt; SymbolicMatchAnalysis.this.Const">a</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1087529" title="SymbolicMatchAnalysis.this.Const">aa</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1087580" title="=&gt; SymbolicMatchAnalysis.this.Const">b</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1087530" title="SymbolicMatchAnalysis.this.Const">bb</a><span class="delimiter">)</span> <a href="#3369509" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#1087579" title="=&gt; SymbolicMatchAnalysis.this.Const">a</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1087530" title="SymbolicMatchAnalysis.this.Const">bb</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1087580" title="=&gt; SymbolicMatchAnalysis.this.Const">b</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1087529" title="SymbolicMatchAnalysis.this.Const">aa</a><span class="delimiter">)</span>
            <span class="keyword">case</span> _ =&gt; <a href="#3369509" title="(x: Boolean)Boolean" class="keyword">false</a>
          <span class="delimiter">}</span>
          // make ExcludedPair(a, b).hashCode == ExcludedPair(b, a).hashCode
          <span class="keyword">override</span> <span class="keyword">def</span> <a title="()Int" id="1087495">hashCode</a> = <a href="#1087579" title="=&gt; SymbolicMatchAnalysis.this.Const">a</a>.<span title="()Int">hashCode</span> <a href="../../../Int.scala.html#57149" title="(x: Int)Int">^</a> <a href="#1087580" title="=&gt; SymbolicMatchAnalysis.this.Const">b</a>.<span title="()Int">hashCode</span>
        <span class="delimiter">}</span>

        <a href="#1087248" title="=&gt; List[SymbolicMatchAnalysis.this.Sym]">equalitySyms</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: SymbolicMatchAnalysis.this.Sym =&gt; (SymbolicMatchAnalysis.this.Sym, List[SymbolicMatchAnalysis.this.Sym], List[SymbolicMatchAnalysis.this.Sym]))(implicit bf: scala.collection.generic.CanBuildFrom[List[SymbolicMatchAnalysis.this.Sym],(SymbolicMatchAnalysis.this.Sym, List[SymbolicMatchAnalysis.this.Sym], List[SymbolicMatchAnalysis.this.Sym]),List[(SymbolicMatchAnalysis.this.Sym, List[SymbolicMatchAnalysis.this.Sym], List[SymbolicMatchAnalysis.this.Sym])]])List[(SymbolicMatchAnalysis.this.Sym, List[SymbolicMatchAnalysis.this.Sym], List[SymbolicMatchAnalysis.this.Sym])]">map</a> <span class="delimiter">{</span> <a title="SymbolicMatchAnalysis.this.Sym" id="1087604">sym</a> =&gt;
          // if we've already excluded the pair at some point (-A \/ -B), then don't exclude the symmetric one (-B \/ -A)
          // (nor the positive implications -B \/ A, or -A \/ B, which would entail the equality axioms falsifying the whole formula)
          <span class="keyword">val</span> <a title="List[SymbolicMatchAnalysis.this.Sym]" id="1087605">todo</a> = <a href="#1087248" title="=&gt; List[SymbolicMatchAnalysis.this.Sym]">equalitySyms</a> <a href="../../../collection/TraversableLike.scala.html#58074" title="(p: SymbolicMatchAnalysis.this.Sym =&gt; Boolean)List[SymbolicMatchAnalysis.this.Sym]">filterNot</a> <span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Sym" id="1087613">b</a> =&gt; <span class="delimiter">(</span><a href="#1087613" title="SymbolicMatchAnalysis.this.Sym">b</a>.<a href="#1078868" title="=&gt; SymbolicMatchAnalysis.this.Const">const</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1087604" title="SymbolicMatchAnalysis.this.Sym">sym</a>.<a href="#1078868" title="=&gt; SymbolicMatchAnalysis.this.Const">const</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="../../../collection/GenSetLike.scala.html#66403" title="(elem: ExcludedPair)Boolean">excludedPair</a><span class="delimiter">(</span><a href="#1087584" title="(a: SymbolicMatchAnalysis.this.Const, b: SymbolicMatchAnalysis.this.Const)ExcludedPair">ExcludedPair</a><span class="delimiter">(</span><a href="#1087613" title="SymbolicMatchAnalysis.this.Sym">b</a>.<a href="#1078868" title="=&gt; SymbolicMatchAnalysis.this.Const">const</a>, <a href="#1087604" title="SymbolicMatchAnalysis.this.Sym">sym</a>.<a href="#1078868" title="=&gt; SymbolicMatchAnalysis.this.Const">const</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a href="#3369524" title="(x: (List[SymbolicMatchAnalysis.this.Sym], List[SymbolicMatchAnalysis.this.Sym]))(List[SymbolicMatchAnalysis.this.Sym], List[SymbolicMatchAnalysis.this.Sym])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="List[SymbolicMatchAnalysis.this.Sym]" id="1087607">excluded</a>, <a href="../../../Tuple2.scala.html#60637" title="List[SymbolicMatchAnalysis.this.Sym]" id="1087608">notExcluded</a><span class="delimiter">)</span> = <a href="#1087605" title="List[SymbolicMatchAnalysis.this.Sym]">todo</a> <a href="../../../collection/TraversableLike.scala.html#58080" title="(p: SymbolicMatchAnalysis.this.Sym =&gt; Boolean)(List[SymbolicMatchAnalysis.this.Sym], List[SymbolicMatchAnalysis.this.Sym])">partition</a> <span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Sym" id="1087638">b</a> =&gt; <a href="#1087457" title="(a: SymbolicMatchAnalysis.this.Const, b: SymbolicMatchAnalysis.this.Const)Boolean">excludes</a><span class="delimiter">(</span><a href="#1087604" title="SymbolicMatchAnalysis.this.Sym">sym</a>.<a href="#1078868" title="=&gt; SymbolicMatchAnalysis.this.Const">const</a>, <a href="#1087638" title="SymbolicMatchAnalysis.this.Sym">b</a>.<a href="#1078868" title="=&gt; SymbolicMatchAnalysis.this.Const">const</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[SymbolicMatchAnalysis.this.Sym]" id="1087609">implied</a> = <a href="#1087608" title="List[SymbolicMatchAnalysis.this.Sym]">notExcluded</a> <a href="../../../collection/TraversableLike.scala.html#58073" title="(p: SymbolicMatchAnalysis.this.Sym =&gt; Boolean)List[SymbolicMatchAnalysis.this.Sym]">filter</a> <span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Sym" id="1087653">b</a> =&gt; <a href="#1087456" title="(lower: SymbolicMatchAnalysis.this.Const, upper: SymbolicMatchAnalysis.this.Const)Boolean">implies</a><span class="delimiter">(</span><a href="#1087604" title="SymbolicMatchAnalysis.this.Sym">sym</a>.<a href="#1078868" title="=&gt; SymbolicMatchAnalysis.this.Const">const</a>, <a href="#1087653" title="SymbolicMatchAnalysis.this.Sym">b</a>.<a href="#1078868" title="=&gt; SymbolicMatchAnalysis.this.Const">const</a><span class="delimiter">)</span><span class="delimiter">)</span>

          <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;eq axioms for: &quot;)" class="string">&quot;eq axioms for: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1087604" title="SymbolicMatchAnalysis.this.Sym">sym</a>.<a href="#1078868" title="=&gt; SymbolicMatchAnalysis.this.Const">const</a><span class="delimiter">)</span>
          <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;excluded: &quot;)" class="string">&quot;excluded: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1087607" title="List[SymbolicMatchAnalysis.this.Sym]">excluded</a><span class="delimiter">)</span>
          <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;implied: &quot;)" class="string">&quot;implied: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1087609" title="List[SymbolicMatchAnalysis.this.Sym]">implied</a><span class="delimiter">)</span>

          <a href="#1087607" title="List[SymbolicMatchAnalysis.this.Sym]">excluded</a> <a href="../../../collection/immutable/List.scala.html#62719" title="(f: SymbolicMatchAnalysis.this.Sym =&gt; scala.collection.mutable.HashSet[ExcludedPair])Unit">foreach</a> <span class="delimiter">{</span> <a title="SymbolicMatchAnalysis.this.Sym" id="1087674">excludedSym</a> =&gt; <a href="#1087458" title="scala.collection.mutable.HashSet[ExcludedPair]">excludedPair</a> <a href="../../../collection/mutable/HashSet.scala.html#125963" title="(elem: ExcludedPair)excludedPair.type">+=</a> <a href="#1087584" title="(a: SymbolicMatchAnalysis.this.Const, b: SymbolicMatchAnalysis.this.Const)ExcludedPair">ExcludedPair</a><span class="delimiter">(</span><a href="#1087604" title="SymbolicMatchAnalysis.this.Sym">sym</a>.<a href="#1078868" title="=&gt; SymbolicMatchAnalysis.this.Const">const</a>, <a href="#1087674" title="SymbolicMatchAnalysis.this.Sym">excludedSym</a>.<a href="#1078868" title="=&gt; SymbolicMatchAnalysis.this.Const">const</a><span class="delimiter">)</span><span class="delimiter">}</span>

          <a href="../../../Tuple3.scala.html#63169" title="(_1: SymbolicMatchAnalysis.this.Sym, _2: List[SymbolicMatchAnalysis.this.Sym], _3: List[SymbolicMatchAnalysis.this.Sym])(SymbolicMatchAnalysis.this.Sym, List[SymbolicMatchAnalysis.this.Sym], List[SymbolicMatchAnalysis.this.Sym])" class="delimiter">(</a><a href="#1087604" title="SymbolicMatchAnalysis.this.Sym">sym</a>, <a href="#1087609" title="List[SymbolicMatchAnalysis.this.Sym]">implied</a>, <a href="#1087607" title="List[SymbolicMatchAnalysis.this.Sym]">excluded</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      // accessing after calling registerNull will result in inconsistencies
      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Option[Set[SymbolicMatchAnalysis.this.Sym]]" id="1087245">domainSyms</a>: <a href="../../../Option.scala.html#978" title="Option[Set[SymbolicMatchAnalysis.this.Sym]]">Option</a><span class="delimiter">[</span>Set<span class="delimiter">[</span>Sym<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#1087238" title="=&gt; Option[Set[SymbolicMatchAnalysis.this.Const]]">domain</a> <a href="../../../Option.scala.html#62865" title="(f: Set[SymbolicMatchAnalysis.this.Const] =&gt; Set[SymbolicMatchAnalysis.this.Sym])Option[Set[SymbolicMatchAnalysis.this.Sym]]">map</a> <span class="delimiter">{</span> <a href="#1087726" title="Set[SymbolicMatchAnalysis.this.Const]">_</a> <a href="../../../collection/SetLike.scala.html#66437" title="(f: SymbolicMatchAnalysis.this.Const =&gt; SymbolicMatchAnalysis.this.Sym)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[SymbolicMatchAnalysis.this.Const],SymbolicMatchAnalysis.this.Sym,Set[SymbolicMatchAnalysis.this.Sym]])Set[SymbolicMatchAnalysis.this.Sym]">map</a> <a href="#1087232" title="scala.collection.mutable.HashMap[SymbolicMatchAnalysis.this.Const,SymbolicMatchAnalysis.this.Sym]">symForEqualsTo</a> <span class="delimiter">}</span>

      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Option[SymbolicMatchAnalysis.this.Sym]" id="1087247">symForStaticTp</a>: <a href="../../../Option.scala.html#978" title="Option[SymbolicMatchAnalysis.this.Sym]">Option</a><span class="delimiter">[</span>Sym<span class="delimiter">]</span>  = <a href="#1087232" title="scala.collection.mutable.HashMap[SymbolicMatchAnalysis.this.Const,SymbolicMatchAnalysis.this.Sym]">symForEqualsTo</a>.<a href="../../../collection/mutable/HashMap.scala.html#88246" title="(key: SymbolicMatchAnalysis.this.Const)Option[SymbolicMatchAnalysis.this.Sym]">get</a><span class="delimiter">(</span><a href="#1087324" title="(tp: PatternMatching.this.global.Type)SymbolicMatchAnalysis.this.Const">TypeConst</a><span class="delimiter">(</span><a href="#1087233" title="=&gt; PatternMatching.this.global.Type">staticTpCheckable</a><span class="delimiter">)</span><span class="delimiter">)</span>

      // don't access until all potential equalities have been registered using registerEquality
      <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="List[SymbolicMatchAnalysis.this.Sym]" id="1087249">equalitySyms</a> = <span class="delimiter">{</span><a href="#1087231" title="=&gt; Unit">observed</a>; <a href="#1087232" title="scala.collection.mutable.HashMap[SymbolicMatchAnalysis.this.Const,SymbolicMatchAnalysis.this.Sym]">symForEqualsTo</a>.<a href="../../../collection/mutable/HashMap.scala.html#88257" title="=&gt; Iterable[SymbolicMatchAnalysis.this.Sym]">values</a>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[SymbolicMatchAnalysis.this.Sym]">toList</a><span class="delimiter">}</span>

      // don't call until all equalities have been registered and registerNull has been called (if needed)
      <span class="keyword">def</span> <a title="=&gt; String" id="1087250">describe</a> = <a href="#1087251" title="()String">toString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;: &quot;)" class="string">&quot;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#1087253" title="PatternMatching.this.global.Type">staticTp</a> <span title="(x$1: Any)String">+</span> <a href="#1087238" title="=&gt; Option[Set[SymbolicMatchAnalysis.this.Const]]">domain</a>.<a href="../../../Option.scala.html#62865" title="(f: Set[SymbolicMatchAnalysis.this.Const] =&gt; String)Option[String]">map</a><span class="delimiter">(</span><a href="#1087791" title="Set[SymbolicMatchAnalysis.this.Const]">_</a>.<a href="../../../collection/TraversableOnce.scala.html#58282" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot; ::= &quot;)" class="string">&quot; ::= &quot;</span>, <span title="String(&quot; | &quot;)" class="string">&quot; | &quot;</span>, <span title="String(&quot;// &quot;)" class="string">&quot;// &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1087232" title="scala.collection.mutable.HashMap[SymbolicMatchAnalysis.this.Const,SymbolicMatchAnalysis.this.Sym]">symForEqualsTo</a>.<a href="../../../collection/MapLike.scala.html#87541" title="=&gt; Iterable[SymbolicMatchAnalysis.this.Const]">keys</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../Option.scala.html#62859" title="(default: =&gt; String)String">getOrElse</a><span class="delimiter">(</span><a href="#1087232" title="scala.collection.mutable.HashMap[SymbolicMatchAnalysis.this.Const,SymbolicMatchAnalysis.this.Sym]">symForEqualsTo</a>.<a href="../../../collection/MapLike.scala.html#87541" title="=&gt; Iterable[SymbolicMatchAnalysis.this.Const]">keys</a>.<a href="../../../collection/TraversableOnce.scala.html#58282" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot; ::= &quot;)" class="string">&quot; ::= &quot;</span>, <span title="String(&quot; | &quot;)" class="string">&quot; | &quot;</span>, <span title="String(&quot; | ...&quot;)" class="string">&quot; | ...&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; // = &quot;)" class="string">&quot; // = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#1087252" title="=&gt; PatternMatching.this.global.Tree">path</a>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1087251">toString</a> = <span title="String(&quot;V&quot;)" class="string">&quot;V&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1087229" title="Int">id</a>
    <span class="delimiter">}</span>


    // all our variables range over types
    // a literal constant becomes ConstantType(Constant(v)) when the type allows it (roughly, anyval + string + null)
    // equality between variables: SingleType(x) (note that pattern variables cannot relate to each other -- it's always patternVar == nonPatternVar)
    <span class="keyword">object</span> <a title="SymbolicMatchAnalysis.this.Const.type" id="1069205">Const</a> <a href="#1069206" title="SymbolicMatchAnalysis.this.Const.type" class="delimiter">{</a>
      <span class="keyword">def</span> <a title="()Unit" id="1087205">resetUniques</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span><a href="#1087207" title="(x$1: Int)Unit">_nextTypeId</a> = <span title="Int(0)" class="int">0</span>; <a href="#1087211" title="(x$1: Int)Unit">_nextValueId</a> = <span title="Int(0)" class="int">0</span>; <a href="#1087214" title="=&gt; scala.collection.mutable.HashMap[PatternMatching.this.global.Type,SymbolicMatchAnalysis.this.Const]">uniques</a>.<a href="../../../collection/mutable/HashMap.scala.html#88240" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span> ; <a href="#1087217" title="=&gt; scala.collection.mutable.HashSet[PatternMatching.this.global.Tree]">trees</a>.<a href="../../../collection/mutable/HashSet.scala.html#125968" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">}</span>

      <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="1087207">_nextTypeId</a> = <span title="Int(0)" class="int">0</span>
      <span class="keyword">def</span> <a title="=&gt; Int" id="1087209">nextTypeId</a> = <span class="delimiter">{</span><a href="#1087207" title="(x$1: Int)Unit">_nextTypeId</a> <a href="../../../Int.scala.html#57154" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>; <a href="#1087207" title="=&gt; Int">_nextTypeId</a><span class="delimiter">}</span>

      <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="1087211">_nextValueId</a> = <span title="Int(0)" class="int">0</span>
      <span class="keyword">def</span> <a title="=&gt; Int" id="1087213">nextValueId</a> = <span class="delimiter">{</span><a href="#1087211" title="(x$1: Int)Unit">_nextValueId</a> <a href="../../../Int.scala.html#57154" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>; <a href="#1087211" title="=&gt; Int">_nextValueId</a><span class="delimiter">}</span>

      <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[PatternMatching.this.global.Type,SymbolicMatchAnalysis.this.Const]" id="1087214">uniques</a> = <a href="../../../collection/mutable/HashMap.scala.html#88242" title="()scala.collection.mutable.HashMap[PatternMatching.this.global.Type,SymbolicMatchAnalysis.this.Const]" class="keyword">new</a> scala.collection.mutable.<a href="../../../collection/mutable/HashMap.scala.html#12447" title="scala.collection.mutable.HashMap[PatternMatching.this.global.Type,SymbolicMatchAnalysis.this.Const]">HashMap</a><span class="delimiter">[</span>Type, Const<span class="delimiter">]</span>
      <span class="keyword">private</span><span class="delimiter">[</span>SymbolicMatchAnalysis<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type, mkFresh: =&gt; SymbolicMatchAnalysis.this.Const)SymbolicMatchAnalysis.this.Const" id="1087216">unique</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1087351">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <a title="=&gt; SymbolicMatchAnalysis.this.Const" id="1087352">mkFresh</a>: =&gt; Const<span class="delimiter">)</span>: <a href="#1069207" title="SymbolicMatchAnalysis.this.Const">Const</a> =
        <a href="#1087214" title="=&gt; scala.collection.mutable.HashMap[PatternMatching.this.global.Type,SymbolicMatchAnalysis.this.Const]">uniques</a>.<a href="../../../collection/mutable/HashMap.scala.html#88246" title="(key: PatternMatching.this.global.Type)Option[SymbolicMatchAnalysis.this.Const]">get</a><span class="delimiter">(</span><a href="#1087351" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>.<a href="../../../Option.scala.html#62859" title="(default: =&gt; SymbolicMatchAnalysis.this.Const)SymbolicMatchAnalysis.this.Const">getOrElse</a><span class="delimiter">(</span>
          <a href="#1087214" title="=&gt; scala.collection.mutable.HashMap[PatternMatching.this.global.Type,SymbolicMatchAnalysis.this.Const]">uniques</a>.<a href="../../../collection/IterableLike.scala.html#58567" title="(p: ((PatternMatching.this.global.Type, SymbolicMatchAnalysis.this.Const)) =&gt; Boolean)Option[(PatternMatching.this.global.Type, SymbolicMatchAnalysis.this.Const)]">find</a> <a href="#1087828" title="(PatternMatching.this.global.Type, SymbolicMatchAnalysis.this.Const)" class="delimiter">{</a><span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Type" id="1087831">oldTp</a>, <a href="../../../Tuple2.scala.html#60637" title="SymbolicMatchAnalysis.this.Const" id="1087832">oldC</a><span class="delimiter">)</span> =&gt; <a href="#1087831" title="PatternMatching.this.global.Type">oldTp</a> <a href="#3369530" title="(x: Boolean)Boolean">=:=</a> <a href="#1087351" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">}</span> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> Some<a href="#3369534" title="SymbolicMatchAnalysis.this.Const" id="3369536" class="delimiter">(</a><a href="../../../Option.scala.html#63132" title="(PatternMatching.this.global.Type, SymbolicMatchAnalysis.this.Const)" id="3369535" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Type" id="3369537">_</a>, <a href="../../../Tuple2.scala.html#60637" title="SymbolicMatchAnalysis.this.Const" id="1087838">c</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
              <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;unique const: &quot;)" class="string">&quot;unique const: &quot;</span><a href="../../../Tuple2.scala.html#62849" title="(x$1: Any)String">+</a> <span class="delimiter">(</span><a href="#1087351" title="PatternMatching.this.global.Type">tp</a>, <a href="#1087838" title="SymbolicMatchAnalysis.this.Const">c</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#1087838" title="SymbolicMatchAnalysis.this.Const">c</a>
            <span class="keyword">case</span> _ =&gt;
              <span class="keyword">val</span> <a title="SymbolicMatchAnalysis.this.Const" id="1087845">fresh</a> = <a href="#1087352" title="=&gt; SymbolicMatchAnalysis.this.Const">mkFresh</a>
              <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;uniqued const: &quot;)" class="string">&quot;uniqued const: &quot;</span><a href="../../../Tuple2.scala.html#62849" title="(x$1: Any)String">+</a> <span class="delimiter">(</span><a href="#1087351" title="PatternMatching.this.global.Type">tp</a>, <a href="#1087845" title="SymbolicMatchAnalysis.this.Const">fresh</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="../../../collection/mutable/HashMap.scala.html#88248" title="(key: PatternMatching.this.global.Type, value: SymbolicMatchAnalysis.this.Const)Unit">uniques</a><span class="delimiter">(</span><a href="#1087351" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span> = <a href="#1087845" title="SymbolicMatchAnalysis.this.Const">fresh</a>
              <a href="#1087845" title="SymbolicMatchAnalysis.this.Const">fresh</a>
          <span class="delimiter">}</span><span class="delimiter">)</span>

      <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[PatternMatching.this.global.Tree]" id="1087217">trees</a> = scala.collection.mutable.<a href="../../../collection/mutable/HashSet.scala.html#13054" title="scala.collection.mutable.HashSet.type">HashSet</a>.<a href="../../../collection/mutable/HashSet.scala.html#156202" title="[A]=&gt; scala.collection.mutable.HashSet[A]">empty</a><span title="scala.collection.mutable.HashSet[PatternMatching.this.global.Tree]" class="delimiter">[</span><a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">]</span>

      // hashconsing trees (modulo value-equality)
      <span class="keyword">private</span><span class="delimiter">[</span>SymbolicMatchAnalysis<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(t: PatternMatching.this.global.Tree)PatternMatching.this.global.Type" id="1087219">uniqueTpForTree</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1087857">t</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a> =
        // a new type for every unstable symbol -- only stable value are uniqued
        // technically, an unreachable value may change between cases
        // thus, the failure of a case that matches on a mutable value does not exclude the next case succeeding
        // (and thuuuuus, the latter case must be considered reachable)
        <span title="PatternMatching.this.global.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1087857" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411286" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#1087857" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#408414" title="=&gt; PatternMatching.this.global.Type">narrow</a>
        <span class="keyword">else</span> <a href="#1087217" title="=&gt; scala.collection.mutable.HashSet[PatternMatching.this.global.Tree]">trees</a> <a href="../../../collection/IterableLike.scala.html#58567" title="(p: PatternMatching.this.global.Tree =&gt; Boolean)Option[PatternMatching.this.global.Tree]">find</a> <span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1087863">a</a> =&gt; <a href="#1087863" title="PatternMatching.this.global.Tree">a</a>.<a href="../../../reflect/internal/Trees.scala.html#408548" title="(that: PatternMatching.this.global.Tree)(f: (PatternMatching.this.global.Tree, PatternMatching.this.global.Tree) =&gt; Boolean)Boolean">correspondsStructure</a><span class="delimiter">(</span><a href="#1087857" title="PatternMatching.this.global.Tree">t</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1069156" title="(a: PatternMatching.this.global.Tree, b: PatternMatching.this.global.Tree)Boolean">sameValue</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Some<a href="#3369544" title="PatternMatching.this.global.Type" id="3369545" class="delimiter">(</a><a href="../../../Option.scala.html#63132" title="PatternMatching.this.global.Tree" id="1087870">orig</a><span class="delimiter">)</span> =&gt;
            <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;unique tp for tree: &quot;)" class="string">&quot;unique tp for tree: &quot;</span><a href="../../../Tuple2.scala.html#62849" title="(x$1: Any)String">+</a> <span class="delimiter">(</span><a href="#1087870" title="PatternMatching.this.global.Tree">orig</a>, <a href="#1087870" title="PatternMatching.this.global.Tree">orig</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#1087870" title="PatternMatching.this.global.Tree">orig</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>
          <span class="keyword">case</span> _ =&gt;
            // duplicate, don't mutate old tree (TODO: use a map tree -&gt; type instead?)
            <span class="keyword">val</span> <a title="t.type" id="1087877">treeWithNarrowedType</a> = <a href="#1087857" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408588" title="=&gt; t.type">duplicate</a> <a href="../../../reflect/internal/Trees.scala.html#408575" title="(tp: PatternMatching.this.global.Type)t.type">setType</a> <a href="#1087857" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#408414" title="=&gt; PatternMatching.this.global.Type">narrow</a>
            <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;uniqued: &quot;)" class="string">&quot;uniqued: &quot;</span><a href="../../../Tuple3.scala.html#63169" title="(x$1: Any)String">+</a> <span class="delimiter">(</span><a href="#1087857" title="PatternMatching.this.global.Tree">t</a>, <a href="#1087857" title="PatternMatching.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>, <a href="#1087877" title="t.type">treeWithNarrowedType</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#1087217" title="=&gt; scala.collection.mutable.HashSet[PatternMatching.this.global.Tree]">trees</a> <a href="../../../collection/mutable/HashSet.scala.html#125963" title="(elem: PatternMatching.this.global.Tree)scala.tools.nsc.typechecker.PatternMatching.SymbolicMatchAnalysis.Const.trees.type">+=</a> <a href="#1087877" title="t.type">treeWithNarrowedType</a>
            <a href="#1087877" title="t.type">treeWithNarrowedType</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Const extends Object" id="1069207">Const</a> <a href="#1069207" title="SymbolicMatchAnalysis.this.Const" class="delimiter">{</a>
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Type" id="1087332">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Type" id="1087333">wideTp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>

      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1087334">isAny</a> = <a href="#1087333" title="=&gt; PatternMatching.this.global.Type">wideTp</a>.<a href="../../../reflect/internal/Types.scala.html#408407" title="=&gt; PatternMatching.this.global.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/Definitions.scala.html#408667" title="=&gt; PatternMatching.this.global.ClassSymbol">AnyClass</a>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1087335">isValue</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> //= tp.isStable

      // note: use reference equality on Const since they're hash-consed (doing type equality all the time is too expensive)
      // the equals inherited from AnyRef does just this
    <span class="delimiter">}</span>

    // find most precise super-type of tp that is a class
    // we skip non-class types (singleton types, abstract types) so that we can
    // correctly compute how types relate in terms of the values they rule out
    // e.g., when we know some value must be of type T, can it still be of type S? (this is the positive formulation of what `excludes` on Const computes)
    // since we're talking values, there must have been a class involved in creating it, so rephrase our types in terms of classes
    // (At least conceptually: `true` is an instance of class `Boolean`)
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type" id="1069208">widenToClass</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1087905">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a> =
      <span title="PatternMatching.this.global.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#1087905" title="PatternMatching.this.global.Type">tp</a>.<a href="../../../reflect/internal/Types.scala.html#408407" title="=&gt; PatternMatching.this.global.Symbol">typeSymbol</a>.<a href="../../../reflect/api/Symbols.scala.html#402403" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> <a href="#1087905" title="PatternMatching.this.global.Type">tp</a>
      <span class="keyword">else</span> <a href="#1087905" title="PatternMatching.this.global.Type">tp</a>.<a href="../../../reflect/internal/Types.scala.html#408459" title="(clazz: PatternMatching.this.global.Symbol)PatternMatching.this.global.Type">baseType</a><span class="delimiter">(</span><a href="#1087905" title="PatternMatching.this.global.Type">tp</a>.<a href="../../../reflect/internal/Types.scala.html#408491" title="=&gt; List[PatternMatching.this.global.Symbol]">baseClasses</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; PatternMatching.this.global.Symbol">head</a><span class="delimiter">)</span>

    <span class="keyword">object</span> <a title="SymbolicMatchAnalysis.this.TypeConst.type" id="1069209">TypeConst</a> <a href="#1069210" title="SymbolicMatchAnalysis.this.TypeConst.type" class="keyword">extends</a> <a href="#1069262" title="SymbolicMatchAnalysis.this.TypeConstExtractor">TypeConstExtractor</a> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)SymbolicMatchAnalysis.this.Const" id="1087324">apply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1087326">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span title="SymbolicMatchAnalysis.this.Const" class="keyword">if</span> <span class="delimiter">(</span><a href="#1087326" title="PatternMatching.this.global.Type">tp</a> <a href="../../../reflect/internal/Types.scala.html#408485" title="(that: PatternMatching.this.global.Type)Boolean">=:=</a> <a href="#1069215" title="=&gt; PatternMatching.this.global.UniqueConstantType">NullTp</a><span class="delimiter">)</span> <a href="#1087986" title="SymbolicMatchAnalysis.this.NullConst.type">NullConst</a>
        <span class="keyword">else</span> <span title="SymbolicMatchAnalysis.this.Const" class="keyword">if</span> <span class="delimiter">(</span><a href="#1087326" title="PatternMatching.this.global.Type">tp</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="../../../reflect/internal/Types.scala.html#407276" title="PatternMatching.this.global.SingletonType">SingletonType</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#1069212" title="SymbolicMatchAnalysis.this.ValueConst.type">ValueConst</a>.<a href="#1087342" title="(tp: PatternMatching.this.global.Type)SymbolicMatchAnalysis.this.Const">fromType</a><span class="delimiter">(</span><a href="#1087326" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#1069205" title="SymbolicMatchAnalysis.this.Const.type">Const</a>.<a href="#1087216" title="(tp: PatternMatching.this.global.Type, mkFresh: =&gt; SymbolicMatchAnalysis.this.Const)SymbolicMatchAnalysis.this.Const">unique</a><span class="delimiter">(</span><a href="#1087326" title="PatternMatching.this.global.Type">tp</a>, <span title="SymbolicMatchAnalysis.this.TypeConst" class="keyword">new</span> <a href="#1069211" title="SymbolicMatchAnalysis.this.TypeConst">TypeConst</a><span class="delimiter">(</span><a href="#1087326" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="(c: SymbolicMatchAnalysis.this.TypeConst)Some[PatternMatching.this.global.Type]" id="1087325">unapply</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.TypeConst" id="1087911">c</a>: <a href="#1069211" title="SymbolicMatchAnalysis.this.TypeConst">TypeConst</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#582" title="Some[PatternMatching.this.global.Type]">Some</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.Type)Some[PatternMatching.this.global.Type]">Some</a><span class="delimiter">(</span><a href="#1087911" title="SymbolicMatchAnalysis.this.TypeConst">c</a>.<a href="#1087377" title="=&gt; PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // corresponds to a type test that does not imply any value-equality (well, except for outer checks, which we don't model yet)
    <span class="keyword">sealed</span> <span class="keyword">class</span> <a title="class TypeConst extends SymbolicMatchAnalysis.this.Const" id="1069211">TypeConst</a><a href="#1069211" title="SymbolicMatchAnalysis.this.TypeConst" class="delimiter">(</a><span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1087377">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069207" title="SymbolicMatchAnalysis.this.Const">Const</a> <span class="delimiter">{</span>
      <a href="../Global.scala.html#537498" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#1087377" title="=&gt; PatternMatching.this.global.Type">tp</a> <a href="../../../reflect/internal/Types.scala.html#408485" title="(that: PatternMatching.this.global.Type)Boolean">=:=</a> <a href="#1069215" title="=&gt; PatternMatching.this.global.UniqueConstantType">NullTp</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="Int" id="1087372">id</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a> = <a href="#1069205" title="SymbolicMatchAnalysis.this.Const.type">Const</a>.<a href="#1087209" title="=&gt; Int">nextTypeId</a>

      <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1087373">wideTp</a> = <a href="#1069208" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">widenToClass</a><span class="delimiter">(</span><a href="#1087377" title="=&gt; PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1087375">isValue</a> = <span title="Boolean(false)" class="keyword">false</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1087376">toString</a> = <a href="#1087377" title="=&gt; PatternMatching.this.global.Type">tp</a>.<a href="../../../reflect/internal/Types.scala.html#408499" title="()String">toString</a> //+&quot;#&quot;+ id
    <span class="delimiter">}</span>

    // p is a unique type or a constant value
    <span class="keyword">object</span> <a title="SymbolicMatchAnalysis.this.ValueConst.type" id="1069212">ValueConst</a> <a href="#1069213" title="SymbolicMatchAnalysis.this.ValueConst.type" class="delimiter">{</a>
      <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)SymbolicMatchAnalysis.this.Const" id="1087342">fromType</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1087344">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <a href="../Global.scala.html#537498" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="#1087344" title="PatternMatching.this.global.Type">tp</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="../../../reflect/internal/Types.scala.html#407276" title="PatternMatching.this.global.SingletonType">SingletonType</a><span class="delimiter">]</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="String" id="1087345">toString</a> = <a href="#1087344" title="PatternMatching.this.global.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> ConstantType<a href="#3369552" title="String" id="3369554" class="delimiter">(</a><a href="../../../reflect/internal/Types.scala.html#410960" title="PatternMatching.this.global.Constant" id="1087350">c</a><span class="delimiter">)</span> =&gt; <a href="#1087350" title="PatternMatching.this.global.Constant">c</a>.<a href="#3369556" title="(x: String)String">escapedStringValue</a>
          <span class="keyword">case</span> _ =&gt; <a href="#1087344" title="PatternMatching.this.global.Type">tp</a>.<a href="#3369556" title="(x: String)String">toString</a>
        <span class="delimiter">}</span>
        <a href="#1069205" title="SymbolicMatchAnalysis.this.Const.type">Const</a>.<a href="#1087216" title="(tp: PatternMatching.this.global.Type, mkFresh: =&gt; SymbolicMatchAnalysis.this.Const)SymbolicMatchAnalysis.this.Const">unique</a><span class="delimiter">(</span><a href="#1087344" title="PatternMatching.this.global.Type">tp</a>, <span title="SymbolicMatchAnalysis.this.ValueConst" class="keyword">new</span> <a href="#1069214" title="SymbolicMatchAnalysis.this.ValueConst">ValueConst</a><span class="delimiter">(</span><a href="#1087344" title="PatternMatching.this.global.Type">tp</a>, <a href="#1087344" title="PatternMatching.this.global.Type">tp</a>.<a href="../../../reflect/internal/Types.scala.html#408411" title="=&gt; PatternMatching.this.global.Type">widen</a>, <a href="#1087345" title="String">toString</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="(p: PatternMatching.this.global.Tree)SymbolicMatchAnalysis.this.Const" id="1087343">apply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1087927">p</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1087928">tp</a> = <a href="#1087927" title="PatternMatching.this.global.Tree">p</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#408438" title="=&gt; PatternMatching.this.global.Type">normalize</a>
        <span title="SymbolicMatchAnalysis.this.Const" class="keyword">if</span> <span class="delimiter">(</span><a href="#1087928" title="PatternMatching.this.global.Type">tp</a> <a href="../../../reflect/internal/Types.scala.html#408485" title="(that: PatternMatching.this.global.Type)Boolean">=:=</a> <a href="#1069215" title="=&gt; PatternMatching.this.global.UniqueConstantType">NullTp</a><span class="delimiter">)</span> <a href="#1087986" title="SymbolicMatchAnalysis.this.NullConst.type">NullConst</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1087932">wideTp</a> = <a href="#1069208" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">widenToClass</a><span class="delimiter">(</span><a href="#1087928" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>

          <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1087933">narrowTp</a> =
            <span title="PatternMatching.this.global.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#1087928" title="PatternMatching.this.global.Type">tp</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="../../../reflect/internal/Types.scala.html#407276" title="PatternMatching.this.global.SingletonType">SingletonType</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#1087928" title="PatternMatching.this.global.Type">tp</a>
            <span class="keyword">else</span> <a href="#1087927" title="PatternMatching.this.global.Tree">p</a> <span class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> Literal<a href="#3369561" title="PatternMatching.this.global.Type" id="3369563" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#409973" title="PatternMatching.this.global.Constant" id="1087936">c</a><span class="delimiter">)</span> =&gt;
                <a href="#3369568" title="(x: PatternMatching.this.global.Type)PatternMatching.this.global.Type" class="keyword">if</a> <span class="delimiter">(</span><a href="#1087936" title="PatternMatching.this.global.Constant">c</a>.<a href="../../../reflect/internal/Constants.scala.html#409776" title="=&gt; PatternMatching.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#408407" title="=&gt; PatternMatching.this.global.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/Definitions.scala.html#409353" title="=&gt; PatternMatching.this.global.ClassSymbol">UnitClass</a><span class="delimiter">)</span> <a href="#1087936" title="PatternMatching.this.global.Constant">c</a>.<a href="../../../reflect/internal/Constants.scala.html#409776" title="=&gt; PatternMatching.this.global.Type">tpe</a>
                <span class="keyword">else</span> <a href="../../../reflect/internal/Types.scala.html#441752" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.UniqueConstantType">ConstantType</a><span class="delimiter">(</span><a href="#1087936" title="PatternMatching.this.global.Constant">c</a><span class="delimiter">)</span>
              <span class="keyword">case</span> Ident<a href="#3369561" title="PatternMatching.this.global.Type" id="3369566" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3369564">_</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#1087927" title="PatternMatching.this.global.Tree">p</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411286" title="=&gt; Boolean">isStable</a> =&gt;
                // for Idents, can encode uniqueness of symbol as uniqueness of the corresponding singleton type
                // for Selects, which are handled by the next case, the prefix of the select varies independently of the symbol (see pos/virtpatmat_unreach_select.scala)
                <a href="../../../reflect/internal/Types.scala.html#407398" title="(pre: PatternMatching.this.global.Type, sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.Type">singleType</a><a href="#3369568" title="(x: PatternMatching.this.global.Type)PatternMatching.this.global.Type" class="delimiter">(</a><a href="#1087928" title="PatternMatching.this.global.Type">tp</a>.<a href="../../../reflect/internal/Types.scala.html#408418" title="=&gt; PatternMatching.this.global.Type">prefix</a>, <a href="#1087927" title="PatternMatching.this.global.Tree">p</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a><span class="delimiter">)</span>
              <span class="keyword">case</span> _ =&gt;
                <a href="#1069205" title="SymbolicMatchAnalysis.this.Const.type">Const</a>.<a href="#1087219" title="(t: PatternMatching.this.global.Tree)PatternMatching.this.global.Type">uniqueTpForTree</a><a href="#3369568" title="(x: PatternMatching.this.global.Type)PatternMatching.this.global.Type" class="delimiter">(</a><a href="#1087927" title="PatternMatching.this.global.Tree">p</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>

          <span class="keyword">val</span> <a title="String" id="1087934">toString</a> =
            <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#1087927" title="PatternMatching.this.global.Tree">p</a>.<a href="../../../reflect/internal/Trees.scala.html#408580" title="=&gt; Boolean">hasSymbol</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1087927" title="PatternMatching.this.global.Tree">p</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411286" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#1087927" title="PatternMatching.this.global.Tree">p</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; PatternMatching.this.global.Symbol#NameType">name</a>.<span title="()String">toString</span> // tp.toString
            <span class="keyword">else</span> <a href="#1087927" title="PatternMatching.this.global.Tree">p</a>.<a href="../../../reflect/api/Trees.scala.html#402641" title="()String">toString</a> //+&quot;#&quot;+ id

          <a href="#1069205" title="SymbolicMatchAnalysis.this.Const.type">Const</a>.<a href="#1087216" title="(tp: PatternMatching.this.global.Type, mkFresh: =&gt; SymbolicMatchAnalysis.this.Const)SymbolicMatchAnalysis.this.Const">unique</a><span class="delimiter">(</span><a href="#1087933" title="PatternMatching.this.global.Type">narrowTp</a>, <span title="SymbolicMatchAnalysis.this.ValueConst" class="keyword">new</span> <a href="#1069214" title="SymbolicMatchAnalysis.this.ValueConst">ValueConst</a><span class="delimiter">(</span><a href="#1087933" title="PatternMatching.this.global.Type">narrowTp</a>, <a href="#1069222" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">checkableType</a><span class="delimiter">(</span><a href="#1087932" title="PatternMatching.this.global.Type">wideTp</a><span class="delimiter">)</span>, <a href="#1087934" title="String">toString</a><span class="delimiter">)</span><span class="delimiter">)</span> // must make wide type checkable so that it is comparable to types from TypeConst
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">sealed</span> <span class="keyword">class</span> <a title="class ValueConst extends SymbolicMatchAnalysis.this.Const" id="1069214">ValueConst</a><a href="#1069214" title="SymbolicMatchAnalysis.this.ValueConst" class="delimiter">(</a><span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1087365">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1087366">wideTp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="String" id="1087367">toString</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069207" title="SymbolicMatchAnalysis.this.Const">Const</a> <span class="delimiter">{</span>
      // patmatDebug(&quot;VC&quot;+(tp, wideTp, toString))
      <a href="../Global.scala.html#537498" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#1087365" title="=&gt; PatternMatching.this.global.Type">tp</a> <a href="../../../reflect/internal/Types.scala.html#408485" title="(that: PatternMatching.this.global.Type)Boolean">=:=</a> <a href="#1069215" title="=&gt; PatternMatching.this.global.UniqueConstantType">NullTp</a><span class="delimiter">)</span><span class="delimiter">)</span> // TODO: assert(!tp.isStable)
      <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">val</span> <a title="Int" id="1087363">id</a>: <a href="../../../Int.scala.html#321" title="Int">Int</a> = <a href="#1069205" title="SymbolicMatchAnalysis.this.Const.type">Const</a>.<a href="#1087213" title="=&gt; Int">nextValueId</a>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1087364">isValue</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="delimiter">}</span>

    <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.UniqueConstantType" id="1069216">NullTp</a> = <a href="../../../reflect/internal/Types.scala.html#441752" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.UniqueConstantType">ConstantType</a><span class="delimiter">(</span><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span>
    case <span class="keyword">object</span> <a href="#1087979" title="SymbolicMatchAnalysis.this.NullConst.type" id="1087986">NullConst</a> <a href="../../../Product.scala.html#186" title="Product" class="keyword">extends</a> <a href="#1069207" title="SymbolicMatchAnalysis.this.Const">Const</a> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.UniqueConstantType" id="1087337">tp</a>     = <a href="#1069215" title="=&gt; PatternMatching.this.global.UniqueConstantType">NullTp</a>
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.UniqueConstantType" id="1087338">wideTp</a> = <a href="#1069215" title="=&gt; PatternMatching.this.global.UniqueConstantType">NullTp</a>

      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1087339">isValue</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1087340">toString</a> = <span title="String(&quot;null&quot;)" class="string">&quot;null&quot;</span>
    <span class="delimiter">}</span>


    // turns a case (represented as a list of abstract tests)
    // into a proposition that is satisfiable if the case may match
    <span class="keyword">def</span> <a title="(tests: List[SymbolicMatchAnalysis.this.Test], modelNull: Boolean)SymbolicMatchAnalysis.this.Prop" id="1069219">symbolicCase</a><span class="delimiter">(</span><a title="List[SymbolicMatchAnalysis.this.Test]" id="1087987">tests</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[SymbolicMatchAnalysis.this.Test]">List</a><span class="delimiter">[</span>Test<span class="delimiter">]</span>, <a title="Boolean" id="1087990">modelNull</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="#1069255" title="SymbolicMatchAnalysis.this.Prop">Prop</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(t: SymbolicMatchAnalysis.this.Cond)SymbolicMatchAnalysis.this.Prop" id="1087991">symbolic</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Cond" id="1087993">t</a>: <a href="#1069136" title="SymbolicMatchAnalysis.this.Cond">Cond</a><span class="delimiter">)</span>: <a href="#1069255" title="SymbolicMatchAnalysis.this.Prop">Prop</a> = <a href="#1087993" title="SymbolicMatchAnalysis.this.Cond">t</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> AndCond<a href="#3369580" title="SymbolicMatchAnalysis.this.Prop" id="3369582" class="delimiter">(</a><a href="#1076546" title="SymbolicMatchAnalysis.this.Cond" id="1087996">a</a>, <a href="#1076547" title="SymbolicMatchAnalysis.this.Cond" id="1087997">b</a><span class="delimiter">)</span> =&gt; <a href="#1078851" title="(a: SymbolicMatchAnalysis.this.Prop, b: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.And">And</a><a href="#3369599" title="(x: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Prop" class="delimiter">(</a><a href="#1087991" title="(t: SymbolicMatchAnalysis.this.Cond)SymbolicMatchAnalysis.this.Prop">symbolic</a><span class="delimiter">(</span><a href="#1087996" title="SymbolicMatchAnalysis.this.Cond">a</a><span class="delimiter">)</span>, <a href="#1087991" title="(t: SymbolicMatchAnalysis.this.Cond)SymbolicMatchAnalysis.this.Prop">symbolic</a><span class="delimiter">(</span><a href="#1087997" title="SymbolicMatchAnalysis.this.Cond">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> OrCond<a href="#3369580" title="SymbolicMatchAnalysis.this.Prop" id="3369584" class="delimiter">(</a><a href="#1076567" title="SymbolicMatchAnalysis.this.Cond" id="1088004">a</a>, <a href="#1076568" title="SymbolicMatchAnalysis.this.Cond" id="1088005">b</a><span class="delimiter">)</span> =&gt; <a href="#1078855" title="(a: SymbolicMatchAnalysis.this.Prop, b: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Or">Or</a><a href="#3369599" title="(x: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Prop" class="delimiter">(</a><a href="#1087991" title="(t: SymbolicMatchAnalysis.this.Cond)SymbolicMatchAnalysis.this.Prop">symbolic</a><span class="delimiter">(</span><a href="#1088004" title="SymbolicMatchAnalysis.this.Cond">a</a><span class="delimiter">)</span>, <a href="#1087991" title="(t: SymbolicMatchAnalysis.this.Cond)SymbolicMatchAnalysis.this.Prop">symbolic</a><span class="delimiter">(</span><a href="#1088005" title="SymbolicMatchAnalysis.this.Cond">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <a href="#1076148" title="SymbolicMatchAnalysis.this.Prop" id="3369596">TrueCond</a> =&gt; <a href="#3369599" title="(x: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Prop">True</a>
        <span class="keyword">case</span> <a href="#1076165" title="SymbolicMatchAnalysis.this.Prop" id="3369597">FalseCond</a> =&gt; <a href="#3369599" title="(x: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Prop">False</a>
        <span class="keyword">case</span> <a href="#1076350" title="Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Type)]" id="3369607">TypeCond</a><a href="#3369580" title="SymbolicMatchAnalysis.this.Prop" id="3369588" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="1088013">p</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Type" id="1088014">pt</a><span class="delimiter">)</span> =&gt; <a href="#1078847" title="(p: SymbolicMatchAnalysis.this.Var, q: SymbolicMatchAnalysis.this.Const)SymbolicMatchAnalysis.this.Eq">Eq</a><a href="#3369599" title="(x: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Prop" class="delimiter">(</a><a href="#1087201" title="(x: PatternMatching.this.global.Tree)SymbolicMatchAnalysis.this.Var">Var</a><span class="delimiter">(</span><a href="#1088013" title="PatternMatching.this.global.Tree">p</a><span class="delimiter">)</span>, <a href="#1087324" title="(tp: PatternMatching.this.global.Type)SymbolicMatchAnalysis.this.Const">TypeConst</a><span class="delimiter">(</span><a href="#1069222" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">checkableType</a><span class="delimiter">(</span><a href="#1088014" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <a href="#1076278" title="Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]" id="3369609">EqualityCond</a><a href="#3369580" title="SymbolicMatchAnalysis.this.Prop" id="3369591" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="1088022">p</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="1088023">q</a><span class="delimiter">)</span> =&gt; <a href="#1078847" title="(p: SymbolicMatchAnalysis.this.Var, q: SymbolicMatchAnalysis.this.Const)SymbolicMatchAnalysis.this.Eq">Eq</a><a href="#3369599" title="(x: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Prop" class="delimiter">(</a><a href="#1087201" title="(x: PatternMatching.this.global.Tree)SymbolicMatchAnalysis.this.Var">Var</a><span class="delimiter">(</span><a href="#1088022" title="PatternMatching.this.global.Tree">p</a><span class="delimiter">)</span>, <a href="#1087343" title="(p: PatternMatching.this.global.Tree)SymbolicMatchAnalysis.this.Const">ValueConst</a><span class="delimiter">(</span><a href="#1088023" title="PatternMatching.this.global.Tree">q</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <a href="#1076323" title="Option[PatternMatching.this.global.Tree]" id="3369611">NonNullCond</a><a href="#3369580" title="SymbolicMatchAnalysis.this.Prop" id="3369594" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1088027">p</a><span class="delimiter">)</span> =&gt; <a href="#3369599" title="(x: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Prop" class="keyword">if</a> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1087990" title="Boolean">modelNull</a><span class="delimiter">)</span> <a href="#1078237" title="SymbolicMatchAnalysis.this.True.type">True</a> <span class="keyword">else</span> <a href="#1078859" title="(a: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Not">Not</a><span class="delimiter">(</span><a href="#1078847" title="(p: SymbolicMatchAnalysis.this.Var, q: SymbolicMatchAnalysis.this.Const)SymbolicMatchAnalysis.this.Eq">Eq</a><span class="delimiter">(</span><a href="#1087201" title="(x: PatternMatching.this.global.Tree)SymbolicMatchAnalysis.this.Var">Var</a><span class="delimiter">(</span><a href="#1088027" title="PatternMatching.this.global.Tree">p</a><span class="delimiter">)</span>, <a href="#1087986" title="SymbolicMatchAnalysis.this.NullConst.type">NullConst</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="keyword">val</span> <a title="List[SymbolicMatchAnalysis.this.Test]" id="1087992">testsBeforeBody</a> = <a href="#1087987" title="List[SymbolicMatchAnalysis.this.Test]">tests</a>.<a href="../../../collection/immutable/List.scala.html#62713" title="(p: SymbolicMatchAnalysis.this.Test =&gt; Boolean)List[SymbolicMatchAnalysis.this.Test]">takeWhile</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Test" id="1088036">t</a> =&gt; <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1088036" title="SymbolicMatchAnalysis.this.Test">t</a>.<a href="#1076088" title="=&gt; SymbolicMatchAnalysis.this.TreeMaker">treeMaker</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#1075332" title="SymbolicMatchAnalysis.this.BodyTreeMaker">BodyTreeMaker</a><span class="delimiter">]</span><span class="delimiter">)</span>
      <a href="#1069286" title="(props: Iterable[SymbolicMatchAnalysis.this.Prop])SymbolicMatchAnalysis.this.Prop">/\</a><span class="delimiter">(</span><a href="#1087992" title="List[SymbolicMatchAnalysis.this.Test]">testsBeforeBody</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: SymbolicMatchAnalysis.this.Test =&gt; SymbolicMatchAnalysis.this.Prop)(implicit bf: scala.collection.generic.CanBuildFrom[List[SymbolicMatchAnalysis.this.Test],SymbolicMatchAnalysis.this.Prop,Iterable[SymbolicMatchAnalysis.this.Prop]])Iterable[SymbolicMatchAnalysis.this.Prop]">map</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,SymbolicMatchAnalysis.this.Prop,List[SymbolicMatchAnalysis.this.Prop]]" class="delimiter">(</a><a title="SymbolicMatchAnalysis.this.Test" id="1088054">t</a> =&gt; <a href="#1087991" title="(t: SymbolicMatchAnalysis.this.Cond)SymbolicMatchAnalysis.this.Prop">symbolic</a><span class="delimiter">(</span><a href="#1088054" title="SymbolicMatchAnalysis.this.Test">t</a>.<a href="#1076087" title="=&gt; SymbolicMatchAnalysis.this.Cond">cond</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    // TODO: model dependencies between variables: if V1 corresponds to (x: List[_]) and V2 is (x.hd), V2 cannot be assigned when V1 = null or V1 = Nil
    // right now hackily implement this by pruning counter-examples
    // unreachability would also benefit from a more faithful representation


    // reachability (dead code)

    // computes the first 0-based case index that is unreachable (if any)
    // a case is unreachable if it implies its preceding cases
    // call C the formula that is satisfiable if the considered case matches
    // call P the formula that is satisfiable if the cases preceding it match
    // the case is reachable if there is a model for -P /\ C,
    // thus, the case is unreachable if there is no model for -(-P /\ C),
    // or, equivalently, P \/ -C, or C =&gt; P
    <span class="keyword">def</span> <a title="(prevBinder: PatternMatching.this.global.Symbol, cases: List[List[SymbolicMatchAnalysis.this.TreeMaker]], pt: PatternMatching.this.global.Type)Option[Int]" id="1069220">unreachableCase</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1088090">prevBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="List[List[SymbolicMatchAnalysis.this.TreeMaker]]" id="1088091">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[SymbolicMatchAnalysis.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="PatternMatching.this.global.Type" id="1088092">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[Int]">Option</a><span class="delimiter">[</span>Int<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="(Long, Long)" id="1088094">start</a> = <span title="(Long, Long)" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415273" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415233" title="(tm: scala.reflect.internal.util.Statistics.Timer)(Long, Long)">startTimer</a><span class="delimiter">(</span><a href="#624646" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatAnaReach</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>

      // use the same approximator so we share variables,
      // but need different conditions depending on whether we're conservatively looking for failure or success
      // don't rewrite List-like patterns, as List() and Nil need to distinguished for unreachability
      <span class="keyword">val</span> <a title="SymbolicMatchAnalysis.this.TreeMakersToConds" id="1088095">approx</a> = <span title="SymbolicMatchAnalysis.this.TreeMakersToConds" class="keyword">new</span> <a href="#1069159" title="SymbolicMatchAnalysis.this.TreeMakersToConds">TreeMakersToConds</a><span class="delimiter">(</span><a href="#1088090" title="PatternMatching.this.global.Symbol">prevBinder</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(default: SymbolicMatchAnalysis.this.Cond)List[List[SymbolicMatchAnalysis.this.Test]]" id="1088096">approximate</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Cond" id="1088107">default</a>: <a href="#1069136" title="SymbolicMatchAnalysis.this.Cond">Cond</a><span class="delimiter">)</span> = <a href="#1088095" title="SymbolicMatchAnalysis.this.TreeMakersToConds">approx</a>.<a href="#1076460" title="(cases: List[List[SymbolicMatchAnalysis.this.TreeMaker]], treeMakerToCond: approx.TreeMakerToCond)List[List[SymbolicMatchAnalysis.this.Test]]">approximateMatch</a><span class="delimiter">(</span><a href="#1088091" title="List[List[SymbolicMatchAnalysis.this.TreeMaker]]">cases</a>, <a href="#1088095" title="SymbolicMatchAnalysis.this.TreeMakersToConds">approx</a>.<a href="#1076457" title="(handler: SymbolicMatchAnalysis.this.TreeMaker =&gt; SymbolicMatchAnalysis.this.Cond)approx.TreeMakerToCond">onUnknown</a> <span class="delimiter">{</span> <a title="SymbolicMatchAnalysis.this.TreeMaker" id="1088112">tm</a> =&gt;
        <a href="#1088095" title="SymbolicMatchAnalysis.this.TreeMakersToConds">approx</a>.<a href="#1076455" title="=&gt; PartialFunction[SymbolicMatchAnalysis.this.TreeMaker,SymbolicMatchAnalysis.this.Cond]">refutableRewrite</a>.<a href="../../../PartialFunction.scala.html#58663" title="(x: SymbolicMatchAnalysis.this.TreeMaker, default: SymbolicMatchAnalysis.this.TreeMaker =&gt; SymbolicMatchAnalysis.this.Cond)SymbolicMatchAnalysis.this.Cond">applyOrElse</a><span class="delimiter">(</span><a href="#1088112" title="SymbolicMatchAnalysis.this.TreeMaker">tm</a>, <span class="delimiter">(</span>_: <a href="#1069034" title="SymbolicMatchAnalysis.this.TreeMaker">TreeMaker</a><span class="delimiter">)</span> =&gt; <a href="#1088107" title="SymbolicMatchAnalysis.this.Cond">default</a> <span class="delimiter">)</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="List[List[SymbolicMatchAnalysis.this.Test]]" id="1088097">testCasesOk</a>   = <a href="#1088096" title="(default: SymbolicMatchAnalysis.this.Cond)List[List[SymbolicMatchAnalysis.this.Test]]">approximate</a><span class="delimiter">(</span><a href="#1076148" title="SymbolicMatchAnalysis.this.TrueCond.type">TrueCond</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[List[SymbolicMatchAnalysis.this.Test]]" id="1088098">testCasesFail</a> = <a href="#1088096" title="(default: SymbolicMatchAnalysis.this.Cond)List[List[SymbolicMatchAnalysis.this.Test]]">approximate</a><span class="delimiter">(</span><a href="#1076165" title="SymbolicMatchAnalysis.this.FalseCond.type">FalseCond</a><span class="delimiter">)</span>

      <a href="#1069201" title="()Unit">prepareNewAnalysis</a><span class="delimiter">(</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="List[SymbolicMatchAnalysis.this.Prop]" id="1088099">propsCasesOk</a>   = <a href="#1088097" title="List[List[SymbolicMatchAnalysis.this.Test]]">testCasesOk</a>   <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[SymbolicMatchAnalysis.this.Test] =&gt; SymbolicMatchAnalysis.this.Prop)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[SymbolicMatchAnalysis.this.Test]],SymbolicMatchAnalysis.this.Prop,List[SymbolicMatchAnalysis.this.Prop]])List[SymbolicMatchAnalysis.this.Prop]">map</a> <span class="delimiter">(</span><a title="List[SymbolicMatchAnalysis.this.Test]" id="1088141">t</a> =&gt; <a href="#1069219" title="(tests: List[SymbolicMatchAnalysis.this.Test], modelNull: Boolean)SymbolicMatchAnalysis.this.Prop">symbolicCase</a><span class="delimiter">(</span><a href="#1088141" title="List[SymbolicMatchAnalysis.this.Test]">t</a>, modelNull = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[SymbolicMatchAnalysis.this.Not]" id="1088100">propsCasesFail</a> = <a href="#1088098" title="List[List[SymbolicMatchAnalysis.this.Test]]">testCasesFail</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[SymbolicMatchAnalysis.this.Test] =&gt; SymbolicMatchAnalysis.this.Not)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[SymbolicMatchAnalysis.this.Test]],SymbolicMatchAnalysis.this.Not,List[SymbolicMatchAnalysis.this.Not]])List[SymbolicMatchAnalysis.this.Not]">map</a> <span class="delimiter">(</span><a title="List[SymbolicMatchAnalysis.this.Test]" id="1088186">t</a> =&gt; <a href="#1078859" title="(a: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Not">Not</a><span class="delimiter">(</span><a href="#1069219" title="(tests: List[SymbolicMatchAnalysis.this.Test], modelNull: Boolean)SymbolicMatchAnalysis.this.Prop">symbolicCase</a><span class="delimiter">(</span><a href="#1088186" title="List[SymbolicMatchAnalysis.this.Test]">t</a>, modelNull = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a href="#3369624" title="(x: (SymbolicMatchAnalysis.this.Prop, List[SymbolicMatchAnalysis.this.Prop]))(SymbolicMatchAnalysis.this.Prop, List[SymbolicMatchAnalysis.this.Prop])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="SymbolicMatchAnalysis.this.Prop" id="1088102">eqAxiomsFail</a>, <a href="../../../Tuple2.scala.html#60637" title="List[SymbolicMatchAnalysis.this.Prop]" id="1088103">symbolicCasesFail</a><span class="delimiter">)</span> = <a href="#1069291" title="(props: List[SymbolicMatchAnalysis.this.Prop], modelNull: Boolean)(SymbolicMatchAnalysis.this.Prop, List[SymbolicMatchAnalysis.this.Prop])">removeVarEq</a><a href="../../../Tuple2.scala.html#783" title="(SymbolicMatchAnalysis.this.Prop, List[SymbolicMatchAnalysis.this.Prop]) @unchecked" class="delimiter">(</a><a href="#1088100" title="List[SymbolicMatchAnalysis.this.Not]">propsCasesFail</a>, modelNull = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a href="#3369630" title="(x: (SymbolicMatchAnalysis.this.Prop, List[SymbolicMatchAnalysis.this.Prop]))(SymbolicMatchAnalysis.this.Prop, List[SymbolicMatchAnalysis.this.Prop])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="SymbolicMatchAnalysis.this.Prop" id="1088105">eqAxiomsOk</a>, <a href="../../../Tuple2.scala.html#60637" title="List[SymbolicMatchAnalysis.this.Prop]" id="1088106">symbolicCasesOk</a><span class="delimiter">)</span>     = <a href="#1069291" title="(props: List[SymbolicMatchAnalysis.this.Prop], modelNull: Boolean)(SymbolicMatchAnalysis.this.Prop, List[SymbolicMatchAnalysis.this.Prop])">removeVarEq</a><a href="../../../Tuple2.scala.html#783" title="(SymbolicMatchAnalysis.this.Prop, List[SymbolicMatchAnalysis.this.Prop]) @unchecked" class="delimiter">(</a><a href="#1088099" title="List[SymbolicMatchAnalysis.this.Prop]">propsCasesOk</a>,   modelNull = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

      <a href="#3369645" title="Option[Int]" id="3369639" class="keyword">try</a> <span class="delimiter">{</span>
        // most of the time eqAxiomsFail == eqAxiomsOk, but the different approximations might cause different variables to disapper in general
        <span class="keyword">val</span> <a title="SymbolicMatchAnalysis.this.Formula" id="1088243">eqAxiomsCNF</a> =
          <span title="SymbolicMatchAnalysis.this.Formula" class="keyword">if</span> <span class="delimiter">(</span><a href="#1088102" title="SymbolicMatchAnalysis.this.Prop">eqAxiomsFail</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1088105" title="SymbolicMatchAnalysis.this.Prop">eqAxiomsOk</a><span class="delimiter">)</span> <a href="#1069295" title="(p: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Formula">eqFreePropToSolvable</a><span class="delimiter">(</span><a href="#1088102" title="SymbolicMatchAnalysis.this.Prop">eqAxiomsFail</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="#1069295" title="(p: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Formula">eqFreePropToSolvable</a><span class="delimiter">(</span><a href="#1078851" title="(a: SymbolicMatchAnalysis.this.Prop, b: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.And">And</a><span class="delimiter">(</span><a href="#1088102" title="SymbolicMatchAnalysis.this.Prop">eqAxiomsFail</a>, <a href="#1088105" title="SymbolicMatchAnalysis.this.Prop">eqAxiomsOk</a><span class="delimiter">)</span><span class="delimiter">)</span>

        <span class="keyword">var</span> <a title="SymbolicMatchAnalysis.this.Formula" id="1088244">prefix</a>     = <a href="#1088243" title="SymbolicMatchAnalysis.this.Formula">eqAxiomsCNF</a>
        <span class="keyword">var</span> <a title="List[SymbolicMatchAnalysis.this.Prop]" id="1088245">prefixRest</a> = <a href="#1088103" title="List[SymbolicMatchAnalysis.this.Prop]">symbolicCasesFail</a>
        <span class="keyword">var</span> <a title="List[SymbolicMatchAnalysis.this.Prop]" id="1088246">current</a>    = <a href="#1088106" title="List[SymbolicMatchAnalysis.this.Prop]">symbolicCasesOk</a>
        <span class="keyword">var</span> <a title="Boolean" id="1088247">reachable</a>  = <span title="Boolean(true)" class="keyword">true</span>
        <span class="keyword">var</span> <a title="Int" id="1088248">caseIndex</a>  = <span title="Int(0)" class="int">0</span>

        <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;reachability, vars:\n&quot;)" class="string">&quot;reachability, vars:\n&quot;</span><span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#1088100" title="List[SymbolicMatchAnalysis.this.Not]">propsCasesFail</a> <a href="../../../collection/TraversableLike.scala.html#58068" title="(f: SymbolicMatchAnalysis.this.Not =&gt; scala.collection.GenTraversableOnce[SymbolicMatchAnalysis.this.Var])(implicit bf: scala.collection.generic.CanBuildFrom[List[SymbolicMatchAnalysis.this.Not],SymbolicMatchAnalysis.this.Var,List[SymbolicMatchAnalysis.this.Var]])List[SymbolicMatchAnalysis.this.Var]">flatMap</a> <a href="#1069289" title="(p: SymbolicMatchAnalysis.this.Prop)Set[SymbolicMatchAnalysis.this.Var]">gatherVariables</a><span class="delimiter">)</span>.<a href="../../../collection/SeqLike.scala.html#58839" title="=&gt; List[SymbolicMatchAnalysis.this.Var]">distinct</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: SymbolicMatchAnalysis.this.Var =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[SymbolicMatchAnalysis.this.Var],String,List[String]])List[String]">map</a> <span class="delimiter">(</span><a href="#1088323" title="SymbolicMatchAnalysis.this.Var">_</a>.<a href="#1087250" title="=&gt; String">describe</a><span class="delimiter">)</span> <a href="../../../collection/TraversableOnce.scala.html#58283" title="(sep: String)String">mkString</a> <span class="delimiter">(</span><span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;equality axioms:\n&quot;)" class="string">&quot;equality axioms:\n&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1069296" title="(f: SymbolicMatchAnalysis.this.Formula)String">cnfString</a><span class="delimiter">(</span><a href="#1088243" title="SymbolicMatchAnalysis.this.Formula">eqAxiomsCNF</a><span class="delimiter">)</span><span class="delimiter">)</span>

        // invariant (prefixRest.length == current.length) &amp;&amp; (prefix.reverse ++ prefixRest == symbolicCasesFail)
        // termination: prefixRest.length decreases by 1
        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#1088245" title="List[SymbolicMatchAnalysis.this.Prop]">prefixRest</a>.<a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1088247" title="Boolean">reachable</a><span class="delimiter">)</span> <a href="#1088249" title="()Unit" class="delimiter">{</a>
          <span class="keyword">val</span> <a title="SymbolicMatchAnalysis.this.Prop" id="1088357">prefHead</a> = <a href="#1088245" title="List[SymbolicMatchAnalysis.this.Prop]">prefixRest</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; SymbolicMatchAnalysis.this.Prop">head</a>
          <a href="#1088248" title="Int">caseIndex</a> <a href="../../../Int.scala.html#57154" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
          <a href="#1088245" title="List[SymbolicMatchAnalysis.this.Prop]">prefixRest</a> = <a href="#1088245" title="List[SymbolicMatchAnalysis.this.Prop]">prefixRest</a>.<a href="../../../collection/TraversableLike.scala.html#58104" title="=&gt; List[SymbolicMatchAnalysis.this.Prop]">tail</a>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1088245" title="List[SymbolicMatchAnalysis.this.Prop]">prefixRest</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#1088247" title="Boolean">reachable</a> = <span title="Boolean(true)" class="keyword">true</span>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="#1088244" title="SymbolicMatchAnalysis.this.Formula">prefix</a> = <a href="#1069293" title="(a: SymbolicMatchAnalysis.this.Formula, b: SymbolicMatchAnalysis.this.Formula)SymbolicMatchAnalysis.this.Formula">andFormula</a><span class="delimiter">(</span><a href="#1069295" title="(p: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Formula">eqFreePropToSolvable</a><span class="delimiter">(</span><a href="#1088357" title="SymbolicMatchAnalysis.this.Prop">prefHead</a><span class="delimiter">)</span>, <a href="#1088244" title="SymbolicMatchAnalysis.this.Formula">prefix</a><span class="delimiter">)</span>
            <a href="#1088246" title="List[SymbolicMatchAnalysis.this.Prop]">current</a> = <a href="#1088246" title="List[SymbolicMatchAnalysis.this.Prop]">current</a>.<a href="../../../collection/TraversableLike.scala.html#58104" title="=&gt; List[SymbolicMatchAnalysis.this.Prop]">tail</a>
            <span class="keyword">val</span> <a title="SymbolicMatchAnalysis.this.Model" id="1088367">model</a> = <a href="#1069300" title="(f: SymbolicMatchAnalysis.this.Formula)SymbolicMatchAnalysis.this.Model">findModelFor</a><span class="delimiter">(</span><a href="#1069293" title="(a: SymbolicMatchAnalysis.this.Formula, b: SymbolicMatchAnalysis.this.Formula)SymbolicMatchAnalysis.this.Formula">andFormula</a><span class="delimiter">(</span><a href="#1069295" title="(p: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Formula">eqFreePropToSolvable</a><span class="delimiter">(</span><a href="#1088246" title="List[SymbolicMatchAnalysis.this.Prop]">current</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; SymbolicMatchAnalysis.this.Prop">head</a><span class="delimiter">)</span>, <a href="#1088244" title="SymbolicMatchAnalysis.this.Formula">prefix</a><span class="delimiter">)</span><span class="delimiter">)</span>

            // patmatDebug(&quot;trying to reach:\n&quot;+ cnfString(eqFreePropToSolvable(current.head)) +&quot;\nunder prefix:\n&quot;+ cnfString(prefix))
            // if (NoModel ne model) patmatDebug(&quot;reached: &quot;+ modelString(model))

            <a href="#1088247" title="Boolean">reachable</a> = <a href="#1069299" title="=&gt; SymbolicMatchAnalysis.this.Model">NoModel</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#1088367" title="SymbolicMatchAnalysis.this.Model">model</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415273" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415234" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: (Long, Long))Unit">stopTimer</a><span class="delimiter">(</span><a href="#624646" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatAnaReach</a>, <a href="#1088094" title="(Long, Long)">start</a><span class="delimiter">)</span>

        <span title="Option[Int]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1088247" title="Boolean">reachable</a><span class="delimiter">)</span> <a href="../../../Option.scala.html#1585" title="None.type">None</a> <span class="keyword">else</span> <a href="../../../Option.scala.html#63128" title="(x: Int)Some[Int]">Some</a><span class="delimiter">(</span><a href="#1088248" title="Int">caseIndex</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="../../../Boolean.scala.html#57826" title="Option[Int]" id="3369642">ex</a>: AnalysisBudget.Exception =&gt;
          ex.<a href="#1068889" title="(pos: PatternMatching.this.global.Position, kind: String)Any">warn</a><span class="delimiter">(</span><a href="#1088090" title="PatternMatching.this.global.Symbol">prevBinder</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#409602" title="=&gt; PatternMatching.this.global.Position">pos</a>, <span title="String(&quot;unreachability&quot;)" class="string">&quot;unreachability&quot;</span><span class="delimiter">)</span>
          <a href="../../../Option.scala.html#1585" title="None.type">None</a> // CNF budget exceeded
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    // exhaustivity

    // TODO: domain of other feasibly enumerable built-in types (char?)
    <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)Option[List[PatternMatching.this.global.Type]]" id="1069221">enumerateSubtypes</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1087285">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[List[PatternMatching.this.global.Type]]">Option</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#1087285" title="PatternMatching.this.global.Type">tp</a>.<a href="../../../reflect/internal/Types.scala.html#408407" title="=&gt; PatternMatching.this.global.Symbol">typeSymbol</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        // TODO case _ if tp.isTupleType =&gt; // recurse into component types?
        <span class="keyword">case</span> <a href="../../../reflect/internal/Definitions.scala.html#409353" title="Option[List[PatternMatching.this.global.Type]]" id="3369655">UnitClass</a> =&gt;
          <a href="../../../Option.scala.html#63128" title="(x: List[PatternMatching.this.global.Type])Some[List[PatternMatching.this.global.Type]]">Some</a><a href="#3369661" title="(x: Option[List[PatternMatching.this.global.Type]])Option[List[PatternMatching.this.global.Type]]" class="delimiter">(</a><a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Type*)List[PatternMatching.this.global.Type]">List</a><span class="delimiter">(</span><a href="../../../reflect/internal/Definitions.scala.html#409353" title="=&gt; PatternMatching.this.global.ClassSymbol">UnitClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <a href="../../../reflect/internal/Definitions.scala.html#409369" title="Option[List[PatternMatching.this.global.Type]]" id="3369656">BooleanClass</a> =&gt;
          <a href="../../../Option.scala.html#63128" title="(x: List[PatternMatching.this.global.UniqueConstantType])Some[List[PatternMatching.this.global.UniqueConstantType]]">Some</a><a href="#3369661" title="(x: Option[List[PatternMatching.this.global.Type]])Option[List[PatternMatching.this.global.Type]]" class="delimiter">(</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.UniqueConstantType*)List[PatternMatching.this.global.UniqueConstantType]">List</a><span class="delimiter">(</span><a href="../../../reflect/internal/Types.scala.html#441752" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.UniqueConstantType">ConstantType</a><span class="delimiter">(</span><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="../../../reflect/internal/Types.scala.html#441752" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.UniqueConstantType">ConstantType</a><span class="delimiter">(</span><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        // TODO case _ if tp.isTupleType =&gt; // recurse into component types
        <span class="keyword">case</span> <a href="#3369649" title="Option[List[PatternMatching.this.global.Type]]" id="3369657">modSym</a>: ModuleClassSymbol =&gt;
          <a href="../../../Option.scala.html#63128" title="(x: List[PatternMatching.this.global.Type])Some[List[PatternMatching.this.global.Type]]">Some</a><a href="#3369661" title="(x: Option[List[PatternMatching.this.global.Type]])Option[List[PatternMatching.this.global.Type]]" class="delimiter">(</a><a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Type*)List[PatternMatching.this.global.Type]">List</a><span class="delimiter">(</span><a href="#1087285" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
        // make sure it's not a primitive, else (5: Byte) match { case 5 =&gt; ... } sees no Byte
        <span class="keyword">case</span> sym <span class="keyword">if</span> <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a>sym.<a href="../../../reflect/internal/HasFlags.scala.html#409869" title="=&gt; Boolean">isSealed</a> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="../../../reflect/internal/Definitions.scala.html#409297" title="(sym: PatternMatching.this.global.Symbol)Boolean">isPrimitiveValueClass</a><span class="delimiter">(</span>sym<span class="delimiter">)</span> =&gt;
          <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;enum unsealed &quot;)" class="string">&quot;enum unsealed &quot;</span><a href="../../../Tuple4.scala.html#83441" title="(x$1: Any)String">+</a> <span class="delimiter">(</span><a href="#1087285" title="PatternMatching.this.global.Type">tp</a>, sym, sym.<a href="../../../reflect/internal/HasFlags.scala.html#409869" title="=&gt; Boolean">isSealed</a>, <a href="../../../reflect/internal/Definitions.scala.html#409297" title="(sym: PatternMatching.this.global.Symbol)Boolean">isPrimitiveValueClass</a><span class="delimiter">(</span>sym<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="../../../Option.scala.html#1585" title="None.type">None</a>
        <span class="keyword">case</span> sym =&gt;
          <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1088423">subclasses</a> = <span class="delimiter">(</span>
            sym.<a href="../../../reflect/internal/Symbols.scala.html#411488" title="=&gt; Set[PatternMatching.this.global.Symbol]">sealedDescendants</a>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[PatternMatching.this.global.Symbol]">toList</a> <a href="../../../collection/SeqLike.scala.html#58869" title="(f: PatternMatching.this.global.Symbol =&gt; String)(implicit ord: scala.math.Ordering[String])List[PatternMatching.this.global.Symbol]">sortBy</a> <span class="delimiter">(</span><a href="#1088434" title="PatternMatching.this.global.Symbol">_</a>.<a href="../../../reflect/internal/Symbols.scala.html#411493" title="=&gt; String">sealedSortName</a><span class="delimiter">)</span>
            // symbols which are both sealed and abstract need not be covered themselves, because
            // all of their children must be and they cannot otherwise be created.
            <a href="../../../collection/TraversableLike.scala.html#58074" title="(p: PatternMatching.this.global.Symbol =&gt; Boolean)List[PatternMatching.this.global.Symbol]">filterNot</a> <span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1088496">x</a> =&gt; <a href="#1088496" title="PatternMatching.this.global.Symbol">x</a>.<a href="../../../reflect/internal/HasFlags.scala.html#409869" title="=&gt; Boolean">isSealed</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1088496" title="PatternMatching.this.global.Symbol">x</a>.<a href="../../../reflect/internal/Symbols.scala.html#411175" title="=&gt; Boolean">isAbstractClass</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="../../../reflect/internal/Definitions.scala.html#409297" title="(sym: PatternMatching.this.global.Symbol)Boolean">isPrimitiveValueClass</a><span class="delimiter">(</span><a href="#1088496" title="PatternMatching.this.global.Symbol">x</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;enum sealed -- subclasses: &quot;)" class="string">&quot;enum sealed -- subclasses: &quot;</span><a href="../../../Tuple2.scala.html#62849" title="(x$1: Any)String">+</a> <span class="delimiter">(</span>sym, <a href="#1088423" title="List[PatternMatching.this.global.Symbol]">subclasses</a><span class="delimiter">)</span><span class="delimiter">)</span>

          <span class="keyword">val</span> <a title="PatternMatching.this.global.analyzer.global.Type" id="1088424">tpApprox</a> = <a href="#1068979" title="=&gt; PatternMatching.this.global.analyzer.Typer">typer</a>.<a href="Typers.scala.html#538550" title="=&gt; PatternMatching.this.global.analyzer.Inferencer">infer</a>.<a href="Infer.scala.html#1049751" title="(tp: PatternMatching.this.global.analyzer.global.Type)PatternMatching.this.global.analyzer.global.Type">approximateAbstracts</a><span class="delimiter">(</span><a href="#1087285" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="PatternMatching.this.global.analyzer.global.Type" id="1088425">pre</a> = <a href="#1088424" title="PatternMatching.this.global.analyzer.global.Type">tpApprox</a>.<a href="../../../reflect/internal/Types.scala.html#408418" title="=&gt; PatternMatching.this.global.analyzer.global.Type">prefix</a>
          // valid subtypes are turned into checkable types, as we are entering the realm of the dynamic
          <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Type]" id="1088426">validSubTypes</a> = <span class="delimiter">(</span><a href="#1088423" title="List[PatternMatching.this.global.Symbol]">subclasses</a> <a href="../../../collection/TraversableLike.scala.html#58068" title="(f: PatternMatching.this.global.Symbol =&gt; scala.collection.GenTraversableOnce[PatternMatching.this.global.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Symbol],PatternMatching.this.global.Type,List[PatternMatching.this.global.Type]])List[PatternMatching.this.global.Type]">flatMap</a> <span class="delimiter">{</span><a title="PatternMatching.this.global.Symbol" id="1088522">sym</a> =&gt;
              // have to filter out children which cannot match: see ticket #3683 for an example
              // compare to the fully known type `tp` (modulo abstract types),
              // so that we can rule out stuff like: sealed trait X[T]; class XInt extends X[Int] --&gt; XInt not valid when enumerating X[String]
              // however, must approximate abstract types in
              <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1088523">subTp</a>       = <a href="../../../reflect/internal/Types.scala.html#407408" title="(tycon: PatternMatching.this.global.Type, args: List[PatternMatching.this.global.Type])PatternMatching.this.global.Type">appliedType</a><span class="delimiter">(</span><a href="#1088425" title="PatternMatching.this.global.analyzer.global.Type">pre</a>.<a href="../../../reflect/internal/Types.scala.html#408462" title="(sym: PatternMatching.this.global.analyzer.global.Symbol)PatternMatching.this.global.analyzer.global.Type">memberType</a><span class="delimiter">(</span><a href="#1088522" title="PatternMatching.this.global.Symbol">sym</a><span class="delimiter">)</span>, <a href="#1088522" title="PatternMatching.this.global.Symbol">sym</a>.<a href="../../../reflect/internal/Symbols.scala.html#411389" title="=&gt; List[PatternMatching.this.global.Symbol]">typeParams</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.Symbol =&gt; PatternMatching.this.global.WildcardType.type)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Symbol],PatternMatching.this.global.WildcardType.type,List[PatternMatching.this.global.WildcardType.type]])List[PatternMatching.this.global.WildcardType.type]">map</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,PatternMatching.this.global.WildcardType.type,List[PatternMatching.this.global.WildcardType.type]]" class="delimiter">(</a><a title="PatternMatching.this.global.Symbol" id="1088549">_</a> =&gt; <a href="../../../reflect/internal/Types.scala.html#407279" title="PatternMatching.this.global.WildcardType.type">WildcardType</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">val</span> <a title="PatternMatching.this.global.analyzer.global.Type" id="1088524">subTpApprox</a> = <a href="#1068979" title="=&gt; PatternMatching.this.global.analyzer.Typer">typer</a>.<a href="Typers.scala.html#538550" title="=&gt; PatternMatching.this.global.analyzer.Inferencer">infer</a>.<a href="Infer.scala.html#1049751" title="(tp: PatternMatching.this.global.analyzer.global.Type)PatternMatching.this.global.analyzer.global.Type">approximateAbstracts</a><span class="delimiter">(</span><a href="#1088523" title="PatternMatching.this.global.Type">subTp</a><span class="delimiter">)</span> // TODO: needed?
              // patmatDebug(&quot;subtp&quot;+(subTpApprox &lt;:&lt; tpApprox, subTpApprox, tpApprox))
              <span title="Iterable[PatternMatching.this.global.Type]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1088524" title="PatternMatching.this.global.analyzer.global.Type">subTpApprox</a> <a href="../../../reflect/internal/Types.scala.html#408481" title="(that: PatternMatching.this.global.analyzer.global.Type)Boolean">&lt;:&lt;</a> <a href="#1088424" title="PatternMatching.this.global.analyzer.global.Type">tpApprox</a><span class="delimiter">)</span> <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.Type)Some[PatternMatching.this.global.Type]">Some</a><a href="../../../Option.scala.html#97396" title="(xo: Option[PatternMatching.this.global.Type])Iterable[PatternMatching.this.global.Type]" class="delimiter">(</a><a href="#1069222" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">checkableType</a><span class="delimiter">(</span><a href="#1088523" title="PatternMatching.this.global.Type">subTp</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <a href="../../../Option.scala.html#97396" title="(xo: Option[Nothing])Iterable[Nothing]">None</a>
            <span class="delimiter">}</span><span class="delimiter">)</span>
          <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;enum sealed &quot;)" class="string">&quot;enum sealed &quot;</span><a href="../../../Tuple2.scala.html#62849" title="(x$1: Any)String">+</a> <span class="delimiter">(</span><a href="#1087285" title="PatternMatching.this.global.Type">tp</a>, <a href="#1088424" title="PatternMatching.this.global.analyzer.global.Type">tpApprox</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; as &quot;)" class="string">&quot; as &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1088426" title="List[PatternMatching.this.global.Type]">validSubTypes</a><span class="delimiter">)</span>
          <a href="../../../Option.scala.html#63128" title="(x: List[PatternMatching.this.global.Type])Some[List[PatternMatching.this.global.Type]]">Some</a><span class="delimiter">(</span><a href="#1088426" title="List[PatternMatching.this.global.Type]">validSubTypes</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    // approximate a type to the static type that is fully checkable at run time,
    // hiding statically known but dynamically uncheckable information using existential quantification
    // TODO: this is subject to the availability of TypeTags (since an abstract type with a type tag is checkable at run time)
    <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type" id="1069222">checkableType</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1087274">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a> = <span class="delimiter">{</span>
      // TODO: this is extremely rough...
      // replace type args by wildcards, since they can't be checked (don't use existentials: overkill)
      // TODO: when type tags are available, we will check -- when this is implemented, can we take that into account here?
      // similar to typer.infer.approximateAbstracts
      <span class="keyword">object</span> <a title="typeArgsToWildcardsExceptArray.type" id="1088637">typeArgsToWildcardsExceptArray</a> <a href="#1088638" title="typeArgsToWildcardsExceptArray.type" class="keyword">extends</a> <a href="../../../reflect/internal/Types.scala.html#407460" title="PatternMatching.this.global.TypeMap">TypeMap</a> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type" id="1088641">apply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1088643">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a> = <a href="#1088643" title="PatternMatching.this.global.Type">tp</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> TypeRef<a href="#3369675" title="PatternMatching.this.global.Type" id="3369677" class="delimiter">(</a><a href="../../../reflect/internal/Types.scala.html#410887" title="PatternMatching.this.global.Type" id="1088651">pre</a>, <a href="../../../reflect/internal/Types.scala.html#410889" title="PatternMatching.this.global.Symbol" id="1088652">sym</a>, <a href="../../../reflect/internal/Types.scala.html#410891" title="List[PatternMatching.this.global.Type]" id="1088653">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#1088653" title="List[PatternMatching.this.global.Type]">args</a>.<a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#1088652" title="PatternMatching.this.global.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../../../reflect/internal/Definitions.scala.html#408861" title="=&gt; PatternMatching.this.global.ClassSymbol">ArrayClass</a><span class="delimiter">)</span> =&gt;
            <a href="../../../reflect/internal/Types.scala.html#415106" title="(pre: PatternMatching.this.global.Type, sym: PatternMatching.this.global.Symbol, args: List[PatternMatching.this.global.Type])PatternMatching.this.global.Type">TypeRef</a><a href="#3369679" title="(x: PatternMatching.this.global.Type)PatternMatching.this.global.Type" class="delimiter">(</a><a href="#1088651" title="PatternMatching.this.global.Type">pre</a>, <a href="#1088652" title="PatternMatching.this.global.Symbol">sym</a>, <a href="#1088653" title="List[PatternMatching.this.global.Type]">args</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.Type =&gt; PatternMatching.this.global.WildcardType.type)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Type],PatternMatching.this.global.WildcardType.type,List[PatternMatching.this.global.Type]])List[PatternMatching.this.global.Type]">map</a> <span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1088676">_</a> =&gt; <a href="../../../reflect/internal/Types.scala.html#407279" title="PatternMatching.this.global.WildcardType.type">WildcardType</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
            <a href="../../../reflect/internal/Types.scala.html#441772" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">mapOver</a><a href="#3369679" title="(x: PatternMatching.this.global.Type)PatternMatching.this.global.Type" class="delimiter">(</a><a href="#1088643" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1088639">res</a> = <a href="#1088641" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">typeArgsToWildcardsExceptArray</a><span class="delimiter">(</span><a href="#1087274" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>
      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;checkable &quot;)" class="string">&quot;checkable &quot;</span><a href="../../../Tuple2.scala.html#62849" title="(x$1: Any)String">+</a><span class="delimiter">(</span><a href="#1087274" title="PatternMatching.this.global.Type">tp</a>, <a href="#1088639" title="PatternMatching.this.global.Type">res</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#1088639" title="PatternMatching.this.global.Type">res</a>
    <span class="delimiter">}</span>

    // a type is &quot;uncheckable&quot; (for exhaustivity) if we don't statically know its subtypes (i.e., it's unsealed)
    // we consider tuple types with at least one component of a checkable type as a checkable type
    <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)Boolean" id="1069223">uncheckableType</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1088749">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)List[PatternMatching.this.global.Type]" id="1088751">tupleComponents</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1088753">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> = <a href="#1088753" title="PatternMatching.this.global.Type">tp</a>.<a href="../../../reflect/internal/Types.scala.html#408438" title="=&gt; PatternMatching.this.global.Type">normalize</a>.<a href="../../../reflect/internal/Types.scala.html#408421" title="=&gt; List[PatternMatching.this.global.Type]">typeArgs</a>
      <span class="keyword">val</span> <a title="Boolean" id="1088752">checkable</a> = <span class="delimiter">(</span>
           <span class="delimiter">(</span><a href="../../../reflect/internal/Definitions.scala.html#409006" title="(tp: PatternMatching.this.global.Type)Boolean">isTupleType</a><span class="delimiter">(</span><a href="#1088749" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1088751" title="(tp: PatternMatching.this.global.Type)List[PatternMatching.this.global.Type]">tupleComponents</a><span class="delimiter">(</span><a href="#1088749" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>.<a href="../../../collection/LinearSeqOptimized.scala.html#86379" title="(p: PatternMatching.this.global.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1088763">tp</a> =&gt; <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1069223" title="(tp: PatternMatching.this.global.Type)Boolean">uncheckableType</a><span class="delimiter">(</span><a href="#1088763" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="#1069221" title="(tp: PatternMatching.this.global.Type)Option[List[PatternMatching.this.global.Type]]">enumerateSubtypes</a><span class="delimiter">(</span><a href="#1088749" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>.<a href="../../../Option.scala.html#62879" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span>
      // if (!checkable) patmatDebug(&quot;deemed uncheckable: &quot;+ tp)
      <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1088752" title="Boolean">checkable</a>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(prevBinder: PatternMatching.this.global.Symbol, cases: List[List[SymbolicMatchAnalysis.this.TreeMaker]], pt: PatternMatching.this.global.Type)List[String]" id="1069224">exhaustive</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1088764">prevBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="List[List[SymbolicMatchAnalysis.this.TreeMaker]]" id="1088765">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[SymbolicMatchAnalysis.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="PatternMatching.this.global.Type" id="1088766">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[String]">List</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span title="List[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1069223" title="(tp: PatternMatching.this.global.Type)Boolean">uncheckableType</a><span class="delimiter">(</span><a href="#1088764" title="PatternMatching.this.global.Symbol">prevBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411367" title="=&gt; PatternMatching.this.global.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a> <span class="keyword">else</span> <span class="delimiter">{</span>
      // customize TreeMakersToConds (which turns a tree of tree makers into a more abstract DAG of tests)
      // - approximate the pattern `List()` (unapplySeq on List with empty length) as `Nil`,
      //   otherwise the common (xs: List[Any]) match { case List() =&gt; case x :: xs =&gt; } is deemed unexhaustive
      // - back off (to avoid crying exhaustive too often) when:
      //    - there are guards --&gt;
      //    - there are extractor calls (that we can't secretly/soundly) rewrite
      <span class="keyword">val</span> <a title="(Long, Long)" id="1088768">start</a> = <span title="(Long, Long)" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415273" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415233" title="(tm: scala.reflect.internal.util.Statistics.Timer)(Long, Long)">startTimer</a><span class="delimiter">(</span><a href="#624644" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatAnaExhaust</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="Null(null)" class="keyword">null</span>
      <span class="keyword">var</span> <a title="Boolean" id="1088769">backoff</a> = <span title="Boolean(false)" class="keyword">false</span>

      <span class="keyword">val</span> <a title="SymbolicMatchAnalysis.this.TreeMakersToConds" id="1088770">approx</a> = <span title="SymbolicMatchAnalysis.this.TreeMakersToConds" class="keyword">new</span> <a href="#1069159" title="SymbolicMatchAnalysis.this.TreeMakersToConds">TreeMakersToConds</a><span class="delimiter">(</span><a href="#1088764" title="PatternMatching.this.global.Symbol">prevBinder</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[List[SymbolicMatchAnalysis.this.Test]]" id="1088771">tests</a> = <a href="#1088770" title="SymbolicMatchAnalysis.this.TreeMakersToConds">approx</a>.<a href="#1076460" title="(cases: List[List[SymbolicMatchAnalysis.this.TreeMaker]], treeMakerToCond: approx.TreeMakerToCond)List[List[SymbolicMatchAnalysis.this.Test]]">approximateMatch</a><span class="delimiter">(</span><a href="#1088765" title="List[List[SymbolicMatchAnalysis.this.TreeMaker]]">cases</a>, <a href="#1088770" title="SymbolicMatchAnalysis.this.TreeMakersToConds">approx</a>.<a href="#1076457" title="(handler: SymbolicMatchAnalysis.this.TreeMaker =&gt; SymbolicMatchAnalysis.this.Cond)approx.TreeMakerToCond">onUnknown</a> <span class="delimiter">{</span> <a title="SymbolicMatchAnalysis.this.TreeMaker" id="1088776">tm</a> =&gt;
        <a href="#1088770" title="SymbolicMatchAnalysis.this.TreeMakersToConds">approx</a>.<a href="#1076453" title="=&gt; PartialFunction[SymbolicMatchAnalysis.this.TreeMaker,SymbolicMatchAnalysis.this.Cond]">fullRewrite</a>.<a href="../../../PartialFunction.scala.html#58663" title="[A1 &lt;: SymbolicMatchAnalysis.this.TreeMaker, B1 &gt;: SymbolicMatchAnalysis.this.Cond](x: A1, default: A1 =&gt; B1)B1">applyOrElse</a><span title="(x: SymbolicMatchAnalysis.this.TreeMaker, default: SymbolicMatchAnalysis.this.TreeMaker =&gt; SymbolicMatchAnalysis.this.Cond)SymbolicMatchAnalysis.this.Cond" class="delimiter">[</span><a href="#1069034" title="SymbolicMatchAnalysis.this.TreeMaker">TreeMaker</a>, <a href="#1069136" title="SymbolicMatchAnalysis.this.Cond">Cond</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#1088776" title="SymbolicMatchAnalysis.this.TreeMaker">tm</a>, <a href="#1088784" title="SymbolicMatchAnalysis.this.TreeMaker" class="delimiter">{</a>
          <span class="keyword">case</span> BodyTreeMaker<a href="#3369684" title="SymbolicMatchAnalysis.this.Cond" id="3369688" class="delimiter">(</a><a href="#1071266" title="PatternMatching.this.global.Tree" id="3369685">_</a>, <a href="#1071267" title="PatternMatching.this.global.Type" id="3369686">_</a><span class="delimiter">)</span> =&gt; <a href="#3369690" title="(x: SymbolicMatchAnalysis.this.Cond)SymbolicMatchAnalysis.this.Cond">TrueCond</a> // irrelevant -- will be discarded by symbolCase later
          <span class="keyword">case</span> _ =&gt; // patmatDebug(&quot;backing off due to &quot;+ tm)
            <a href="#1088769" title="Boolean">backoff</a> = <span title="Boolean(true)" class="keyword">true</span>
            <a href="#1076165" title="SymbolicMatchAnalysis.this.FalseCond.type">FalseCond</a>
        <span class="delimiter">}</span><span class="delimiter">)</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>

      <span title="List[String]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1088769" title="Boolean">backoff</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a> <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1088785">prevBinderTree</a> = <a href="#1088770" title="SymbolicMatchAnalysis.this.TreeMakersToConds">approx</a>.<a href="#1076445" title="(b: PatternMatching.this.global.Symbol)PatternMatching.this.global.Tree">binderToUniqueTree</a><span class="delimiter">(</span><a href="#1088764" title="PatternMatching.this.global.Symbol">prevBinder</a><span class="delimiter">)</span>

        <a href="#1069201" title="()Unit">prepareNewAnalysis</a><span class="delimiter">(</span><span class="delimiter">)</span>

        <span class="keyword">val</span> <a title="List[SymbolicMatchAnalysis.this.Prop]" id="1088786">symbolicCases</a> = <a href="#1088771" title="List[List[SymbolicMatchAnalysis.this.Test]]">tests</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[SymbolicMatchAnalysis.this.Test] =&gt; SymbolicMatchAnalysis.this.Prop)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[SymbolicMatchAnalysis.this.Test]],SymbolicMatchAnalysis.this.Prop,List[SymbolicMatchAnalysis.this.Prop]])List[SymbolicMatchAnalysis.this.Prop]">map</a> <span class="delimiter">(</span><a href="#1069219" title="(tests: List[SymbolicMatchAnalysis.this.Test], modelNull: Boolean)SymbolicMatchAnalysis.this.Prop">symbolicCase</a><span class="delimiter">(</span><a href="#1088805" title="List[SymbolicMatchAnalysis.this.Test]">_</a>, modelNull = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span>


        // TODO: null tests generate too much noise, so disabled them -- is there any way to bring them back?
        // assuming we're matching on a non-null scrutinee (prevBinder), when does the match fail?
        // val nonNullScrutineeCond =
        //   assume non-null for all the components of the tuple we're matching on (if we're matching on a tuple)
        //   if (isTupleType(prevBinder.tpe))
        //     prevBinder.tpe.typeArgs.mapWithIndex{case (_, i) =&gt; NonNullCond(codegen.tupleSel(prevBinderTree)(i))}.reduceLeft(AndCond)
        //   else
        //     NonNullCond(prevBinderTree)
        // val matchFails = And(symbolic(nonNullScrutineeCond), Not(symbolicCases reduceLeft (Or(_, _))))

        // when does the match fail?
        <span class="keyword">val</span> <a title="SymbolicMatchAnalysis.this.Not" id="1088787">matchFails</a> = <a href="#1078859" title="(a: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Not">Not</a><span class="delimiter">(</span><a href="#1069287" title="(props: Iterable[SymbolicMatchAnalysis.this.Prop])SymbolicMatchAnalysis.this.Prop">\/</a><span class="delimiter">(</span><a href="#1088786" title="List[SymbolicMatchAnalysis.this.Prop]">symbolicCases</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Set[SymbolicMatchAnalysis.this.Var]" id="1088788">vars</a> = <a href="#1069289" title="(p: SymbolicMatchAnalysis.this.Prop)Set[SymbolicMatchAnalysis.this.Var]">gatherVariables</a><span class="delimiter">(</span><a href="#1088787" title="SymbolicMatchAnalysis.this.Not">matchFails</a><span class="delimiter">)</span>

  // debug output:
        <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;analysing:&quot;)" class="string">&quot;analysing:&quot;</span><span class="delimiter">)</span>
        <a href="#1069161" title="(cases: List[List[SymbolicMatchAnalysis.this.TreeMaker]])Unit">showTreeMakers</a><span class="delimiter">(</span><a href="#1088765" title="List[List[SymbolicMatchAnalysis.this.TreeMaker]]">cases</a><span class="delimiter">)</span>
        <a href="#1069162" title="(testss: List[List[SymbolicMatchAnalysis.this.Test]])Unit">showTests</a><span class="delimiter">(</span><a href="#1088771" title="List[List[SymbolicMatchAnalysis.this.Test]]">tests</a><span class="delimiter">)</span>

        // patmatDebug(&quot;\nvars:\n&quot;+ (vars map (_.describe) mkString (&quot;\n&quot;)))
        // patmatDebug(&quot;\nmatchFails as CNF:\n&quot;+ cnfString(propToSolvable(matchFails)))

        <a href="#3369706" title="List[String]" id="3369700" class="keyword">try</a> <span class="delimiter">{</span>
          // find the models (under which the match fails)
          <span class="keyword">val</span> <a title="List[SymbolicMatchAnalysis.this.Model]" id="1088838">matchFailModels</a> = <a href="#1069301" title="(f: SymbolicMatchAnalysis.this.Formula)List[SymbolicMatchAnalysis.this.Model]">findAllModelsFor</a><span class="delimiter">(</span><a href="#1069294" title="(p: SymbolicMatchAnalysis.this.Prop)SymbolicMatchAnalysis.this.Formula">propToSolvable</a><span class="delimiter">(</span><a href="#1088787" title="SymbolicMatchAnalysis.this.Not">matchFails</a><span class="delimiter">)</span><span class="delimiter">)</span>

          <span class="keyword">val</span> <a title="SymbolicMatchAnalysis.this.Var" id="1088839">scrutVar</a> = <a href="#1087201" title="(x: PatternMatching.this.global.Tree)SymbolicMatchAnalysis.this.Var">Var</a><span class="delimiter">(</span><a href="#1088785" title="PatternMatching.this.global.Tree">prevBinderTree</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[SymbolicMatchAnalysis.this.CounterExample]" id="1088840">counterExamples</a> = <a href="#1088838" title="List[SymbolicMatchAnalysis.this.Model]">matchFailModels</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: SymbolicMatchAnalysis.this.Model =&gt; SymbolicMatchAnalysis.this.CounterExample)(implicit bf: scala.collection.generic.CanBuildFrom[List[SymbolicMatchAnalysis.this.Model],SymbolicMatchAnalysis.this.CounterExample,List[SymbolicMatchAnalysis.this.CounterExample]])List[SymbolicMatchAnalysis.this.CounterExample]">map</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,SymbolicMatchAnalysis.this.CounterExample,List[SymbolicMatchAnalysis.this.CounterExample]]" class="delimiter">(</a><a href="#1069253" title="(scrutVar: SymbolicMatchAnalysis.this.Var)(model: SymbolicMatchAnalysis.this.Model)SymbolicMatchAnalysis.this.CounterExample">modelToCounterExample</a><a href="#1088863" title="SymbolicMatchAnalysis.this.Model" class="delimiter">(</a><a href="#1088839" title="SymbolicMatchAnalysis.this.Var">scrutVar</a><span class="delimiter">)</span><span class="delimiter">)</span>

          <span class="keyword">val</span> <a title="List[String]" id="1088841">pruned</a> = <a href="#1069225" title="SymbolicMatchAnalysis.this.CounterExample.type">CounterExample</a>.<a href="#1088872" title="(examples: List[SymbolicMatchAnalysis.this.CounterExample])List[SymbolicMatchAnalysis.this.CounterExample]">prune</a><span class="delimiter">(</span><a href="#1088840" title="List[SymbolicMatchAnalysis.this.CounterExample]">counterExamples</a><span class="delimiter">)</span>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: SymbolicMatchAnalysis.this.CounterExample =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[SymbolicMatchAnalysis.this.CounterExample],String,List[String]])List[String]">map</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</a><a href="#1088927" title="SymbolicMatchAnalysis.this.CounterExample">_</a>.<span title="()String">toString</span><span class="delimiter">)</span>.<a href="../../../collection/SeqLike.scala.html#58872" title="(implicit ord: scala.math.Ordering[String])List[String]">sorted</a>

          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415273" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415234" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: (Long, Long))Unit">stopTimer</a><span class="delimiter">(</span><a href="#624644" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatAnaExhaust</a>, <a href="#1088768" title="(Long, Long)">start</a><span class="delimiter">)</span>
          <a href="#1088841" title="List[String]">pruned</a>
        <span class="delimiter">}</span> <span class="keyword">catch</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="../../../Boolean.scala.html#57826" title="List[String]" id="3369703">ex</a> : AnalysisBudget.Exception =&gt;
            ex.<a href="#1068889" title="(pos: PatternMatching.this.global.Position, kind: String)Any">warn</a><span class="delimiter">(</span><a href="#1088764" title="PatternMatching.this.global.Symbol">prevBinder</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#409602" title="=&gt; PatternMatching.this.global.Position">pos</a>, <span title="String(&quot;exhaustivity&quot;)" class="string">&quot;exhaustivity&quot;</span><span class="delimiter">)</span>
            <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a> // CNF budget exceeded
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">object</span> <a title="SymbolicMatchAnalysis.this.CounterExample.type" id="1069225">CounterExample</a> <a href="#1069226" title="SymbolicMatchAnalysis.this.CounterExample.type" class="delimiter">{</a>
      <span class="keyword">def</span> <a title="(examples: List[SymbolicMatchAnalysis.this.CounterExample])List[SymbolicMatchAnalysis.this.CounterExample]" id="1088872">prune</a><span class="delimiter">(</span><a title="List[SymbolicMatchAnalysis.this.CounterExample]" id="1088907">examples</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[SymbolicMatchAnalysis.this.CounterExample]">List</a><span class="delimiter">[</span>CounterExample<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[SymbolicMatchAnalysis.this.CounterExample]">List</a><span class="delimiter">[</span>CounterExample<span class="delimiter">]</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="scala.collection.immutable.Set[SymbolicMatchAnalysis.this.CounterExample]" id="1089017">distinct</a> = <a href="#1088907" title="List[SymbolicMatchAnalysis.this.CounterExample]">examples</a>.<a href="../../../collection/TraversableLike.scala.html#58074" title="(p: SymbolicMatchAnalysis.this.CounterExample =&gt; Boolean)List[SymbolicMatchAnalysis.this.CounterExample]">filterNot</a><span class="delimiter">(</span><a href="#1089021" title="SymbolicMatchAnalysis.this.CounterExample">_</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1089670" title="SymbolicMatchAnalysis.this.NoExample.type">NoExample</a><span class="delimiter">)</span>.<a href="../../../collection/TraversableOnce.scala.html#58270" title="scala.collection.immutable.Set[SymbolicMatchAnalysis.this.CounterExample]">toSet</a>
        <a href="#1089017" title="scala.collection.immutable.Set[SymbolicMatchAnalysis.this.CounterExample]">distinct</a>.<a href="../../../collection/TraversableLike.scala.html#58074" title="(p: SymbolicMatchAnalysis.this.CounterExample =&gt; Boolean)scala.collection.immutable.Set[SymbolicMatchAnalysis.this.CounterExample]">filterNot</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.CounterExample" id="1089038">ce</a> =&gt; <a href="#1089017" title="scala.collection.immutable.Set[SymbolicMatchAnalysis.this.CounterExample]">distinct</a>.<a href="../../../collection/IterableLike.scala.html#58566" title="(p: SymbolicMatchAnalysis.this.CounterExample =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.CounterExample" id="1089044">other</a> =&gt; <span class="delimiter">(</span><a href="#1089038" title="SymbolicMatchAnalysis.this.CounterExample">ce</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#1089044" title="SymbolicMatchAnalysis.this.CounterExample">other</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1089038" title="SymbolicMatchAnalysis.this.CounterExample">ce</a>.<a href="#1088867" title="(other: SymbolicMatchAnalysis.this.CounterExample)Boolean">coveredBy</a><span class="delimiter">(</span><a href="#1089044" title="SymbolicMatchAnalysis.this.CounterExample">other</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]">toList</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    // a way to construct a value that will make the match fail: a constructor invocation, a constant, an object of some type)
    <span class="keyword">class</span> <a title="class CounterExample extends Object" id="1069227">CounterExample</a> <a href="#1069227" title="SymbolicMatchAnalysis.this.CounterExample" class="delimiter">{</a>
      <span class="keyword">protected</span><span class="delimiter">[</span>SymbolicMatchAnalysis<span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]" id="1088866">flattenConsArgs</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[SymbolicMatchAnalysis.this.CounterExample]">List</a><span class="delimiter">[</span>CounterExample<span class="delimiter">]</span> = <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>
      <span class="keyword">def</span> <a title="(other: SymbolicMatchAnalysis.this.CounterExample)Boolean" id="1088867">coveredBy</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.CounterExample" id="1089045">other</a>: <a href="#1069227" title="SymbolicMatchAnalysis.this.CounterExample">CounterExample</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <a href="#1069227" title="CounterExample.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1089045" title="SymbolicMatchAnalysis.this.CounterExample">other</a> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="#1089045" title="SymbolicMatchAnalysis.this.CounterExample">other</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1089655" title="SymbolicMatchAnalysis.this.WildcardExample.type">WildcardExample</a>
    <span class="delimiter">}</span>
    case <span class="keyword">class</span> <a title="class ValueExample extends SymbolicMatchAnalysis.this.CounterExample with Product with Serializable" id="1090692">ValueExample</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="SymbolicMatchAnalysis.this.ValueConst" id="1090310">c</a>: <a href="#1069214" title="SymbolicMatchAnalysis.this.ValueConst">ValueConst</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069227" title="SymbolicMatchAnalysis.this.CounterExample">CounterExample</a> <span class="delimiter">{</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1089066">toString</a> = <a href="#1090310" title="=&gt; SymbolicMatchAnalysis.this.ValueConst">c</a>.<a href="#1087367" title="=&gt; String">toString</a> <span class="delimiter">}</span>
    case <span class="keyword">class</span> <a title="class TypeExample extends SymbolicMatchAnalysis.this.CounterExample with Product with Serializable" id="1090712">TypeExample</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="SymbolicMatchAnalysis.this.Const" id="1090537">c</a>: <a href="#1069207" title="SymbolicMatchAnalysis.this.Const">Const</a><span class="delimiter">)</span>  <span class="keyword">extends</span> <a href="#1069227" title="SymbolicMatchAnalysis.this.CounterExample">CounterExample</a> <span class="delimiter">{</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1089104">toString</a> = <span title="String(&quot;(_ : &quot;)" class="string">&quot;(_ : &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1090537" title="=&gt; SymbolicMatchAnalysis.this.Const">c</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span class="delimiter">}</span>
    case <span class="keyword">class</span> <a title="class NegativeExample extends SymbolicMatchAnalysis.this.CounterExample with Product with Serializable" id="1090738">NegativeExample</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="SymbolicMatchAnalysis.this.Const" id="1090550">eqTo</a>: <a href="#1069207" title="SymbolicMatchAnalysis.this.Const">Const</a>, <a title="List[SymbolicMatchAnalysis.this.Const]" id="1090551">nonTrivialNonEqualTo</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[SymbolicMatchAnalysis.this.Const]">List</a><span class="delimiter">[</span>Const<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069227" title="SymbolicMatchAnalysis.this.CounterExample">CounterExample</a> <span class="delimiter">{</span>
      // require(nonTrivialNonEqualTo.nonEmpty, nonTrivialNonEqualTo)
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1089145">toString</a> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="String" id="1089155">negation</a> =
          <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#1090551" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">nonTrivialNonEqualTo</a>.<a href="../../../collection/TraversableLike.scala.html#58104" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">tail</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#1090551" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">nonTrivialNonEqualTo</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; SymbolicMatchAnalysis.this.Const">head</a>.<span title="()String">toString</span>
          <span class="keyword">else</span> <a href="#1090551" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">nonTrivialNonEqualTo</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: SymbolicMatchAnalysis.this.Const =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[SymbolicMatchAnalysis.this.Const],String,List[String]])List[String]">map</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</a><a href="#1089174" title="SymbolicMatchAnalysis.this.Const">_</a>.<span title="()String">toString</span><span class="delimiter">)</span>.<a href="../../../collection/SeqLike.scala.html#58872" title="(implicit ord: scala.math.Ordering[String])List[String]">sorted</a>.<a href="../../../collection/TraversableOnce.scala.html#58282" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
        <span title="String(&quot;(x: &quot;)" class="string">&quot;(x: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1090550" title="=&gt; SymbolicMatchAnalysis.this.Const">eqTo</a> <span title="(x$1: Any)String">+</span><span title="String(&quot; forSome x not in &quot;)" class="string">&quot; forSome x not in &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1089155" title="String">negation</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    case <span class="keyword">class</span> <a title="class ListExample extends SymbolicMatchAnalysis.this.CounterExample with Product with Serializable" id="1090742">ListExample</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="List[SymbolicMatchAnalysis.this.CounterExample]" id="1090495">ctorArgs</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[SymbolicMatchAnalysis.this.CounterExample]">List</a><span class="delimiter">[</span>CounterExample<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069227" title="SymbolicMatchAnalysis.this.CounterExample">CounterExample</a> <span class="delimiter">{</span>
      <span class="keyword">protected</span><span class="delimiter">[</span>SymbolicMatchAnalysis<span class="delimiter">]</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]" id="1089303">flattenConsArgs</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[SymbolicMatchAnalysis.this.CounterExample]">List</a><span class="delimiter">[</span>CounterExample<span class="delimiter">]</span> = <a href="#1090495" title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]">ctorArgs</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="../../../collection/immutable/List.scala.html#206583" title="SymbolicMatchAnalysis.this.CounterExample" id="1089316">hd</a> <a href="#3369743" title="List[SymbolicMatchAnalysis.this.CounterExample]" id="3369745">::</a> <a href="../../../collection/immutable/List.scala.html#206583" title="SymbolicMatchAnalysis.this.CounterExample" id="1089319">tl</a> <a href="../../../collection/immutable/List.scala.html#206584" title="List[SymbolicMatchAnalysis.this.CounterExample]" id="3369747">::</a> <a href="../../../collection/immutable/List.scala.html#206584" title="List[SymbolicMatchAnalysis.this.CounterExample]" id="3369749">Nil</a> =&gt; <a href="#1089316" title="SymbolicMatchAnalysis.this.CounterExample">hd</a> <a href="#3369751" title="(x: List[SymbolicMatchAnalysis.this.CounterExample])List[SymbolicMatchAnalysis.this.CounterExample]">::</a> <a href="#1089319" title="SymbolicMatchAnalysis.this.CounterExample">tl</a>.<a href="#1088866" title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]">flattenConsArgs</a>
        <span class="keyword">case</span> _ =&gt; <a href="#3369751" title="(x: List[SymbolicMatchAnalysis.this.CounterExample])List[SymbolicMatchAnalysis.this.CounterExample]">Nil</a>
      <span class="delimiter">}</span>
      <span class="keyword">protected</span><span class="delimiter">[</span>SymbolicMatchAnalysis<span class="delimiter">]</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="List[SymbolicMatchAnalysis.this.CounterExample]" id="1089305">elems</a> = <a href="#1089303" title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]">flattenConsArgs</a>

      <span class="keyword">override</span> <span class="keyword">def</span> <a title="(other: SymbolicMatchAnalysis.this.CounterExample)Boolean" id="1089306">coveredBy</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.CounterExample" id="1089326">other</a>: <a href="#1069227" title="SymbolicMatchAnalysis.this.CounterExample">CounterExample</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> =
        <a href="#1089326" title="SymbolicMatchAnalysis.this.CounterExample">other</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> other@ListExample<a href="#3369765" title="Boolean" id="3369768" class="delimiter">(</a><a href="#1090495" title="List[SymbolicMatchAnalysis.this.CounterExample]" id="3369766">_</a><span class="delimiter">)</span> =&gt;
            <a href="#1090742" title="ListExample.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">==</span> other <a href="#3369770" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#1089304" title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]">elems</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86373" title="=&gt; Int">length</a> <a href="../../../Int.scala.html#57097" title="(x: Int)Boolean">==</a> other.<a href="#1089304" title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]">elems</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86373" title="=&gt; Int">length</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#1089304" title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]">elems</a> <a href="../../../collection/IterableLike.scala.html#58590" title="(that: scala.collection.GenIterable[SymbolicMatchAnalysis.this.CounterExample])(implicit bf: scala.collection.generic.CanBuildFrom[List[SymbolicMatchAnalysis.this.CounterExample],(SymbolicMatchAnalysis.this.CounterExample, SymbolicMatchAnalysis.this.CounterExample),List[(SymbolicMatchAnalysis.this.CounterExample, SymbolicMatchAnalysis.this.CounterExample)]])List[(SymbolicMatchAnalysis.this.CounterExample, SymbolicMatchAnalysis.this.CounterExample)]">zip</a> other.<a href="#1089304" title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]">elems</a><span class="delimiter">)</span>.<a href="../../../collection/LinearSeqOptimized.scala.html#86378" title="(p: ((SymbolicMatchAnalysis.this.CounterExample, SymbolicMatchAnalysis.this.CounterExample)) =&gt; Boolean)Boolean">forall</a><a href="#1089416" title="(SymbolicMatchAnalysis.this.CounterExample, SymbolicMatchAnalysis.this.CounterExample)" class="delimiter">{</a><span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="SymbolicMatchAnalysis.this.CounterExample" id="1089419">a</a>, <a href="../../../Tuple2.scala.html#60637" title="SymbolicMatchAnalysis.this.CounterExample" id="1089420">b</a><span class="delimiter">)</span> =&gt; <a href="#1089419" title="SymbolicMatchAnalysis.this.CounterExample">a</a> <a href="#3369761" title="(x: Boolean)Boolean">coveredBy</a> <a href="#1089420" title="SymbolicMatchAnalysis.this.CounterExample">b</a><span class="delimiter">}</span><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt; <a href="#1090742" title="SymbolicMatchAnalysis.this.ListExample" class="keyword">super</a>.<a href="#1088867" title="(other: SymbolicMatchAnalysis.this.CounterExample)Boolean">coveredBy</a><a href="#3369770" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#1089326" title="SymbolicMatchAnalysis.this.CounterExample">other</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1089307">toString</a> = <a href="#1089304" title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]">elems</a>.<a href="../../../collection/TraversableOnce.scala.html#58282" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;List(&quot;)" class="string">&quot;List(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    case <span class="keyword">class</span> <a title="class TupleExample extends SymbolicMatchAnalysis.this.CounterExample with Product with Serializable" id="1090746">TupleExample</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="List[SymbolicMatchAnalysis.this.CounterExample]" id="1090499">ctorArgs</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[SymbolicMatchAnalysis.this.CounterExample]">List</a><span class="delimiter">[</span>CounterExample<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069227" title="SymbolicMatchAnalysis.this.CounterExample">CounterExample</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1089457">toString</a> = <a href="#1090499" title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]">ctorArgs</a>.<a href="../../../collection/TraversableOnce.scala.html#58282" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>

      <span class="keyword">override</span> <span class="keyword">def</span> <a title="(other: SymbolicMatchAnalysis.this.CounterExample)Boolean" id="1089458">coveredBy</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.CounterExample" id="1089468">other</a>: <a href="#1069227" title="SymbolicMatchAnalysis.this.CounterExample">CounterExample</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> =
        <a href="#1089468" title="SymbolicMatchAnalysis.this.CounterExample">other</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> TupleExample<a href="#3369786" title="Boolean" id="3369788" class="delimiter">(</a><a href="#1090499" title="List[SymbolicMatchAnalysis.this.CounterExample]" id="1089488">otherArgs</a><span class="delimiter">)</span> =&gt;
            <a href="#1090746" title="TupleExample.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1089468" title="SymbolicMatchAnalysis.this.CounterExample">other</a> <a href="#3369790" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#1090499" title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]">ctorArgs</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86373" title="=&gt; Int">length</a> <a href="../../../Int.scala.html#57097" title="(x: Int)Boolean">==</a> <a href="#1089488" title="List[SymbolicMatchAnalysis.this.CounterExample]">otherArgs</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86373" title="=&gt; Int">length</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#1090499" title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]">ctorArgs</a> <a href="../../../collection/IterableLike.scala.html#58590" title="(that: scala.collection.GenIterable[SymbolicMatchAnalysis.this.CounterExample])(implicit bf: scala.collection.generic.CanBuildFrom[List[SymbolicMatchAnalysis.this.CounterExample],(SymbolicMatchAnalysis.this.CounterExample, SymbolicMatchAnalysis.this.CounterExample),List[(SymbolicMatchAnalysis.this.CounterExample, SymbolicMatchAnalysis.this.CounterExample)]])List[(SymbolicMatchAnalysis.this.CounterExample, SymbolicMatchAnalysis.this.CounterExample)]">zip</a> <a href="#1089488" title="List[SymbolicMatchAnalysis.this.CounterExample]">otherArgs</a><span class="delimiter">)</span>.<a href="../../../collection/LinearSeqOptimized.scala.html#86378" title="(p: ((SymbolicMatchAnalysis.this.CounterExample, SymbolicMatchAnalysis.this.CounterExample)) =&gt; Boolean)Boolean">forall</a><a href="#1089554" title="(SymbolicMatchAnalysis.this.CounterExample, SymbolicMatchAnalysis.this.CounterExample)" class="delimiter">{</a><span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="SymbolicMatchAnalysis.this.CounterExample" id="1089557">a</a>, <a href="../../../Tuple2.scala.html#60637" title="SymbolicMatchAnalysis.this.CounterExample" id="1089558">b</a><span class="delimiter">)</span> =&gt; <a href="#1089557" title="SymbolicMatchAnalysis.this.CounterExample">a</a> <a href="#3369782" title="(x: Boolean)Boolean">coveredBy</a> <a href="#1089558" title="SymbolicMatchAnalysis.this.CounterExample">b</a><span class="delimiter">}</span><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt; <a href="#1090746" title="SymbolicMatchAnalysis.this.TupleExample" class="keyword">super</a>.<a href="#1088867" title="(other: SymbolicMatchAnalysis.this.CounterExample)Boolean">coveredBy</a><a href="#3369790" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#1089468" title="SymbolicMatchAnalysis.this.CounterExample">other</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    case <span class="keyword">class</span> <a title="class ConstructorExample extends SymbolicMatchAnalysis.this.CounterExample with Product with Serializable" id="1090772">ConstructorExample</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="PatternMatching.this.global.Symbol" id="1090506">cls</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="List[SymbolicMatchAnalysis.this.CounterExample]" id="1090507">ctorArgs</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[SymbolicMatchAnalysis.this.CounterExample]">List</a><span class="delimiter">[</span>CounterExample<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069227" title="SymbolicMatchAnalysis.this.CounterExample">CounterExample</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1089593">toString</a> = <a href="#1090506" title="=&gt; PatternMatching.this.global.Symbol">cls</a>.<a href="../../../reflect/internal/Symbols.scala.html#411324" title="=&gt; String">decodedName</a> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#1090506" title="=&gt; PatternMatching.this.global.Symbol">cls</a>.<a href="../../../reflect/api/Symbols.scala.html#402404" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <a href="#1090507" title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]">ctorArgs</a>.<a href="../../../collection/TraversableOnce.scala.html#58282" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    case <span class="keyword">object</span> <a href="#1089648" title="SymbolicMatchAnalysis.this.WildcardExample.type" id="1089655">WildcardExample</a> <a href="../../../Product.scala.html#186" title="Product" class="keyword">extends</a> <a href="#1069227" title="SymbolicMatchAnalysis.this.CounterExample">CounterExample</a> <span class="delimiter">{</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1089061">toString</a> = <span title="String(&quot;_&quot;)" class="string">&quot;_&quot;</span> <span class="delimiter">}</span>
    case <span class="keyword">object</span> <a href="#1089663" title="SymbolicMatchAnalysis.this.NoExample.type" id="1089670">NoExample</a> <a href="../../../Product.scala.html#186" title="Product" class="keyword">extends</a> <a href="#1069227" title="SymbolicMatchAnalysis.this.CounterExample">CounterExample</a> <span class="delimiter">{</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1089027">toString</a> = <span title="String(&quot;??&quot;)" class="string">&quot;??&quot;</span> <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(model: SymbolicMatchAnalysis.this.Model)Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])]" id="1069250">modelToVarAssignment</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Model" id="1089671">model</a>: <a href="../../../collection/immutable/Map.scala.html#11241" title="SymbolicMatchAnalysis.this.Model">Model</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/Map.scala.html#11241" title="Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])]">Map</a><span class="delimiter">[</span>Var, <span class="delimiter">(</span>Seq<span class="delimiter">[</span>Const<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>Const<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> =
      <a href="#1089671" title="SymbolicMatchAnalysis.this.Model">model</a>.<a href="../../../collection/MapLike.scala.html#87563" title="=&gt; Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)]">toSeq</a>.<a href="../../../collection/TraversableLike.scala.html#58081" title="(f: ((SymbolicMatchAnalysis.this.Sym, Boolean)) =&gt; SymbolicMatchAnalysis.this.Var)scala.collection.immutable.Map[SymbolicMatchAnalysis.this.Var,Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)]]">groupBy</a><span class="delimiter">{</span><a title="(SymbolicMatchAnalysis.this.Sym, Boolean)" id="1089681">f</a> =&gt; <a href="#1089681" title="(SymbolicMatchAnalysis.this.Sym, Boolean)">f</a> <span class="keyword">match</span> <span class="delimiter">{</span><span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="SymbolicMatchAnalysis.this.Sym" id="1089684">sym</a>, <a href="../../../Tuple2.scala.html#60637" title="Boolean" id="1089685">value</a><span class="delimiter">)</span> =&gt; <a href="#1089684" title="SymbolicMatchAnalysis.this.Sym">sym</a>.<a href="#3369837" title="(x: SymbolicMatchAnalysis.this.Var)SymbolicMatchAnalysis.this.Var">variable</a><span class="delimiter">}</span> <span class="delimiter">}</span>.<a href="../../../collection/immutable/MapLike.scala.html#120408" title="(f: Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)] =&gt; (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))scala.collection.immutable.Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])]">mapValues</a><span class="delimiter">{</span> <a title="Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)]" id="1089701">xs</a> =&gt;
        <span class="keyword">val</span> <a href="#3369843" title="(x: (Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)], Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)]))(Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)], Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)]" id="1089703">trues</a>, <a href="../../../Tuple2.scala.html#60637" title="Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)]" id="1089704">falses</a><span class="delimiter">)</span> = <a href="#1089701" title="Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)]">xs</a>.<a href="../../../collection/TraversableLike.scala.html#58080" title="(p: ((SymbolicMatchAnalysis.this.Sym, Boolean)) =&gt; Boolean)(Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)], Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)])">partition</a><a href="../../../Tuple2.scala.html#783" title="(Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)], Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)]) @unchecked" class="delimiter">(</a><a href="#1089708" title="(SymbolicMatchAnalysis.this.Sym, Boolean)">_</a>.<a href="../../../Tuple2.scala.html#60637" title="=&gt; Boolean">_2</a><span class="delimiter">)</span>
        <a href="../../../Tuple2.scala.html#62849" title="(_1: Seq[SymbolicMatchAnalysis.this.Const], _2: Seq[SymbolicMatchAnalysis.this.Const])(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])" class="delimiter">(</a><a href="#1089703" title="Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)]">trues</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: ((SymbolicMatchAnalysis.this.Sym, Boolean)) =&gt; SymbolicMatchAnalysis.this.Const)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)],SymbolicMatchAnalysis.this.Const,Seq[SymbolicMatchAnalysis.this.Const]])Seq[SymbolicMatchAnalysis.this.Const]">map</a> <span class="delimiter">(</span><a href="#1089740" title="(SymbolicMatchAnalysis.this.Sym, Boolean)">_</a>.<a href="../../../Tuple2.scala.html#60635" title="=&gt; SymbolicMatchAnalysis.this.Sym">_1</a>.<a href="#1078868" title="=&gt; SymbolicMatchAnalysis.this.Const">const</a><span class="delimiter">)</span>, <a href="#1089704" title="Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)]">falses</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: ((SymbolicMatchAnalysis.this.Sym, Boolean)) =&gt; SymbolicMatchAnalysis.this.Const)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(SymbolicMatchAnalysis.this.Sym, Boolean)],SymbolicMatchAnalysis.this.Const,Seq[SymbolicMatchAnalysis.this.Const]])Seq[SymbolicMatchAnalysis.this.Const]">map</a> <span class="delimiter">(</span><a href="#1089787" title="(SymbolicMatchAnalysis.this.Sym, Boolean)">_</a>.<a href="../../../Tuple2.scala.html#60635" title="=&gt; SymbolicMatchAnalysis.this.Sym">_1</a>.<a href="#1078868" title="=&gt; SymbolicMatchAnalysis.this.Const">const</a><span class="delimiter">)</span><span class="delimiter">)</span>
        // should never be more than one value in trues...
      <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(varAssignment: Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])])String" id="1069251">varAssignmentString</a><span class="delimiter">(</span><a title="Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])]" id="1089811">varAssignment</a>: <a href="../../../collection/immutable/Map.scala.html#11241" title="Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])]">Map</a><span class="delimiter">[</span>Var, <span class="delimiter">(</span>Seq<span class="delimiter">[</span>Const<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>Const<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#1089811" title="Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])]">varAssignment</a>.<a href="../../../collection/MapLike.scala.html#87563" title="=&gt; Seq[(SymbolicMatchAnalysis.this.Var, (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))]">toSeq</a>.<a href="../../../collection/SeqLike.scala.html#58869" title="(f: ((SymbolicMatchAnalysis.this.Var, (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))) =&gt; String)(implicit ord: scala.math.Ordering[String])Seq[(SymbolicMatchAnalysis.this.Var, (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))]">sortBy</a><a href="../../../math/Ordering.scala.html#82256" title="scala.math.Ordering.String.type" class="delimiter">(</a><a href="#1089820" title="(SymbolicMatchAnalysis.this.Var, (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))">_</a>.<a href="../../../Tuple2.scala.html#60635" title="=&gt; SymbolicMatchAnalysis.this.Var">_1</a>.<a href="#1087251" title="()String">toString</a><span class="delimiter">)</span>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: ((SymbolicMatchAnalysis.this.Var, (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(SymbolicMatchAnalysis.this.Var, (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))],String,Seq[String]])Seq[String]">map</a> <a href="#1089896" title="(SymbolicMatchAnalysis.this.Var, (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="SymbolicMatchAnalysis.this.Var" id="1089899">v</a>, <a href="../../../Tuple2.scala.html#60637" title="(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])" id="3369848" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="Seq[SymbolicMatchAnalysis.this.Const]" id="1089902">trues</a>, <a href="../../../Tuple2.scala.html#60637" title="Seq[SymbolicMatchAnalysis.this.Const]" id="1089903">falses</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
         <span class="keyword">val</span> <a title="String" id="1089904">assignment</a> = <span title="String(&quot;== &quot;)" class="string">&quot;== &quot;</span><span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="#1089902" title="Seq[SymbolicMatchAnalysis.this.Const]">trues</a> <a href="../../../collection/TraversableOnce.scala.html#58282" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span><span title="String(&quot;  != (&quot;)" class="string">&quot;  != (&quot;</span><span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="#1089903" title="Seq[SymbolicMatchAnalysis.this.Const]">falses</a> <a href="../../../collection/TraversableOnce.scala.html#58283" title="(sep: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
         <a href="../../../Predef.scala.html#7605" title="implicit scala.Predef.any2stringadd : (x: Any)scala.runtime.StringAdd">v</a> <a href="../../../runtime/StringAdd.scala.html#60046" title="(other: String)String">+</a><span title="String(&quot;(=&quot;)" class="string">&quot;(=&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1089899" title="SymbolicMatchAnalysis.this.Var">v</a>.<a href="#1087252" title="=&gt; PatternMatching.this.global.Tree">path</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;: &quot;)" class="string">&quot;: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1089899" title="SymbolicMatchAnalysis.this.Var">v</a>.<a href="#1087233" title="=&gt; PatternMatching.this.global.Type">staticTpCheckable</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;) &quot;)" class="string">&quot;) &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1089904" title="String">assignment</a>
       <span class="delimiter">}</span>.<a href="../../../collection/TraversableOnce.scala.html#58283" title="(sep: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(model: SymbolicMatchAnalysis.this.Model)String" id="1069252">modelString</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Model" id="1089934">model</a>: <a href="../../../collection/immutable/Map.scala.html#11241" title="SymbolicMatchAnalysis.this.Model">Model</a><span class="delimiter">)</span> = <a href="#1069251" title="(varAssignment: Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])])String">varAssignmentString</a><span class="delimiter">(</span><a href="#1069250" title="(model: SymbolicMatchAnalysis.this.Model)Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])]">modelToVarAssignment</a><span class="delimiter">(</span><a href="#1089934" title="SymbolicMatchAnalysis.this.Model">model</a><span class="delimiter">)</span><span class="delimiter">)</span>

    // return constructor call when the model is a true counter example
    // (the variables don't take into account type information derived from other variables,
    //  so, naively, you might try to construct a counter example like _ :: Nil(_ :: _, _ :: _),
    //  since we didn't realize the tail of the outer cons was a Nil)
    <span class="keyword">def</span> <a title="(scrutVar: SymbolicMatchAnalysis.this.Var)(model: SymbolicMatchAnalysis.this.Model)SymbolicMatchAnalysis.this.CounterExample" id="1069253">modelToCounterExample</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Var" id="1088859">scrutVar</a>: <a href="#1069204" title="SymbolicMatchAnalysis.this.Var">Var</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Model" id="1088860">model</a>: <a href="../../../collection/immutable/Map.scala.html#11241" title="SymbolicMatchAnalysis.this.Model">Model</a><span class="delimiter">)</span>: <a href="#1069227" title="SymbolicMatchAnalysis.this.CounterExample">CounterExample</a> = <span class="delimiter">{</span>
      // x1 = ...
      // x1.hd = ...
      // x1.tl = ...
      // x1.hd.hd = ...
      // ...
      <span class="keyword">val</span> <a title="Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])]" id="1089937">varAssignment</a> = <a href="#1069250" title="(model: SymbolicMatchAnalysis.this.Model)Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])]">modelToVarAssignment</a><span class="delimiter">(</span><a href="#1088860" title="SymbolicMatchAnalysis.this.Model">model</a><span class="delimiter">)</span>

      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;var assignment for model &quot;)" class="string">&quot;var assignment for model &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1088860" title="SymbolicMatchAnalysis.this.Model">model</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;:\n&quot;)" class="string">&quot;:\n&quot;</span><span title="(x$1: Any)String">+</span> <a href="#1069251" title="(varAssignment: Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])])String">varAssignmentString</a><span class="delimiter">(</span><a href="#1089937" title="Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])]">varAssignment</a><span class="delimiter">)</span><span class="delimiter">)</span>

      // chop a path into a list of symbols
      <span class="keyword">def</span> <a title="(path: PatternMatching.this.global.Tree)List[PatternMatching.this.global.Symbol]" id="1089938">chop</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1089942">path</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#1089942" title="PatternMatching.this.global.Tree">path</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Ident<a href="#3369854" title="List[PatternMatching.this.global.Symbol]" id="3369857" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3369855">_</a><span class="delimiter">)</span> =&gt; <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Symbol*)List[PatternMatching.this.global.Symbol]">List</a><a href="#3369861" title="(x: List[PatternMatching.this.global.Symbol])List[PatternMatching.this.global.Symbol]" class="delimiter">(</a><a href="#1089942" title="PatternMatching.this.global.Tree">path</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a><span class="delimiter">)</span>
        <span class="keyword">case</span> Select<a href="#3369854" title="List[PatternMatching.this.global.Symbol]" id="3369859" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#409999" title="PatternMatching.this.global.Tree" id="1089957">pre</a>, <a href="../../../reflect/internal/Trees.scala.html#410001" title="PatternMatching.this.global.Name" id="1089958">name</a><span class="delimiter">)</span> =&gt; <a href="#1089938" title="(path: PatternMatching.this.global.Tree)List[PatternMatching.this.global.Symbol]">chop</a><span class="delimiter">(</span><a href="#1089957" title="PatternMatching.this.global.Tree">pre</a><span class="delimiter">)</span> <a href="#3369861" title="(x: List[PatternMatching.this.global.Symbol])List[PatternMatching.this.global.Symbol]">:+</a> <a href="#1089942" title="PatternMatching.this.global.Tree">path</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a>
        <span class="keyword">case</span> _ =&gt;
          // patmatDebug(&quot;don't know how to chop &quot;+ path)
          <a href="#3369861" title="(x: List[PatternMatching.this.global.Symbol])List[PatternMatching.this.global.Symbol]">Nil</a>
      <span class="delimiter">}</span>

      // turn the variable assignments into a tree
      // the root is the scrutinee (x1), edges are labelled by the fields that are assigned
      // a node is a variable example (which is later turned into a counter example)
      <span class="keyword">object</span> <a title="VariableAssignment.type" id="1090205">VariableAssignment</a> <a href="#1089940" title="VariableAssignment.type" class="delimiter">{</a>
        <span class="keyword">private</span> <span class="keyword">def</span> <a title="(path: List[PatternMatching.this.global.Symbol])Option[SymbolicMatchAnalysis.this.Var]" id="1090011">findVar</a><span class="delimiter">(</span><a title="List[PatternMatching.this.global.Symbol]" id="1090055">path</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#1090055" title="List[PatternMatching.this.global.Symbol]">path</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="../../../collection/generic/SeqFactory.scala.html#59986" title="Option[List[PatternMatching.this.global.Symbol]]" id="3369882">List</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1090066">root</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#1090066" title="PatternMatching.this.global.Symbol">root</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1088859" title="SymbolicMatchAnalysis.this.Var">scrutVar</a>.<a href="#1087252" title="=&gt; PatternMatching.this.global.Tree">path</a>.<a href="../../../reflect/internal/Trees.scala.html#408577" title="=&gt; PatternMatching.this.global.Symbol">symbol</a> =&gt; <a href="../../../Option.scala.html#63128" title="(x: SymbolicMatchAnalysis.this.Var)Some[SymbolicMatchAnalysis.this.Var]">Some</a><a href="#3369878" title="(x: Option[SymbolicMatchAnalysis.this.Var])Option[SymbolicMatchAnalysis.this.Var]" class="delimiter">(</a><a href="#1088859" title="SymbolicMatchAnalysis.this.Var">scrutVar</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt; <a href="#1089937" title="Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])]">varAssignment</a>.<a href="../../../collection/IterableLike.scala.html#58567" title="(p: ((SymbolicMatchAnalysis.this.Var, (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))) =&gt; Boolean)Option[(SymbolicMatchAnalysis.this.Var, (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))]">find</a><a href="#1090079" title="(SymbolicMatchAnalysis.this.Var, (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))" class="delimiter">{</a><span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="SymbolicMatchAnalysis.this.Var" id="1090082">v</a>, <a href="../../../Tuple2.scala.html#60637" title="(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])" id="1090083">a</a><span class="delimiter">)</span> =&gt; <a href="#1089938" title="(path: PatternMatching.this.global.Tree)List[PatternMatching.this.global.Symbol]">chop</a><span class="delimiter">(</span><a href="#1090082" title="SymbolicMatchAnalysis.this.Var">v</a>.<a href="#1087252" title="=&gt; PatternMatching.this.global.Tree">path</a><span class="delimiter">)</span> <a href="#3369869" title="(x: Boolean)Boolean">==</a> <a href="#1090055" title="List[PatternMatching.this.global.Symbol]">path</a><span class="delimiter">}</span>.<a href="../../../Option.scala.html#62865" title="(f: ((SymbolicMatchAnalysis.this.Var, (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))) =&gt; SymbolicMatchAnalysis.this.Var)Option[SymbolicMatchAnalysis.this.Var]">map</a><a href="#3369878" title="(x: Option[SymbolicMatchAnalysis.this.Var])Option[SymbolicMatchAnalysis.this.Var]" class="delimiter">(</a><a href="#1090093" title="(SymbolicMatchAnalysis.this.Var, (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))">_</a>.<a href="../../../Tuple2.scala.html#60635" title="=&gt; SymbolicMatchAnalysis.this.Var">_1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[SymbolicMatchAnalysis.this.Var,VariableAssignment]" id="1090012">uniques</a> = <a href="../../../collection/mutable/HashMap.scala.html#88242" title="()scala.collection.mutable.HashMap[SymbolicMatchAnalysis.this.Var,VariableAssignment]" class="keyword">new</a> scala.collection.mutable.<a href="../../../collection/mutable/HashMap.scala.html#12447" title="scala.collection.mutable.HashMap[SymbolicMatchAnalysis.this.Var,VariableAssignment]">HashMap</a><span class="delimiter">[</span>Var, VariableAssignment<span class="delimiter">]</span>
        <span class="keyword">private</span> <span class="keyword">def</span> <a title="(variable: SymbolicMatchAnalysis.this.Var)VariableAssignment" id="1090014">unique</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Var" id="1090095">variable</a>: <a href="#1069204" title="SymbolicMatchAnalysis.this.Var">Var</a><span class="delimiter">)</span>: <a href="#1090604" title="VariableAssignment">VariableAssignment</a> =
          <a href="#1090012" title="=&gt; scala.collection.mutable.HashMap[SymbolicMatchAnalysis.this.Var,VariableAssignment]">uniques</a>.<a href="../../../collection/mutable/MapLike.scala.html#87629" title="(key: SymbolicMatchAnalysis.this.Var, op: =&gt; VariableAssignment)VariableAssignment">getOrElseUpdate</a><span class="delimiter">(</span><a href="#1090095" title="SymbolicMatchAnalysis.this.Var">variable</a>, <span class="delimiter">{</span>
            <span class="keyword">val</span> <a href="#3369897" title="(x: (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="Seq[SymbolicMatchAnalysis.this.Const]" id="1090100">eqTo</a>, <a href="../../../Tuple2.scala.html#60637" title="Seq[SymbolicMatchAnalysis.this.Const]" id="1090101">neqTo</a><span class="delimiter">)</span> = <a href="#1089937" title="Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])]">varAssignment</a>.<a href="../../../collection/MapLike.scala.html#87532" title="(key: SymbolicMatchAnalysis.this.Var, default: =&gt; (Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]))(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])">getOrElse</a><a href="../../../Tuple2.scala.html#783" title="(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const]) @unchecked" class="delimiter">(</a><a href="#1090095" title="SymbolicMatchAnalysis.this.Var">variable</a>, <a href="../../../Tuple2.scala.html#62849" title="(_1: scala.collection.immutable.Nil.type, _2: scala.collection.immutable.Nil.type)(scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)" class="delimiter">(</a><a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span><span class="delimiter">)</span> // TODO
            <a href="#1090604" title="(variable: SymbolicMatchAnalysis.this.Var, equalTo: List[SymbolicMatchAnalysis.this.Const], notEqualTo: List[SymbolicMatchAnalysis.this.Const], fields: scala.collection.mutable.Map[PatternMatching.this.global.Symbol,VariableAssignment])VariableAssignment">VariableAssignment</a><span class="delimiter">(</span><a href="#1090095" title="SymbolicMatchAnalysis.this.Var">variable</a>, <a href="#1090100" title="Seq[SymbolicMatchAnalysis.this.Const]">eqTo</a>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">toList</a>, <a href="#1090101" title="Seq[SymbolicMatchAnalysis.this.Const]">neqTo</a>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">toList</a>, <a href="../../../collection/mutable/HashMap.scala.html#12448" title="scala.collection.mutable.HashMap.type">HashMap</a>.<a href="../../../collection/mutable/HashMap.scala.html#153384" title="scala.collection.mutable.HashMap[PatternMatching.this.global.Symbol,VariableAssignment]">empty</a><span class="delimiter">)</span>
          <span class="delimiter">}</span><span class="delimiter">)</span>

        <span class="keyword">def</span> <a title="(variable: SymbolicMatchAnalysis.this.Var)VariableAssignment" id="1090015">apply</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Var" id="1090143">variable</a>: <a href="#1069204" title="SymbolicMatchAnalysis.this.Var">Var</a><span class="delimiter">)</span>: <a href="#1090604" title="VariableAssignment">VariableAssignment</a> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1090154">path</a>  = <a href="#1089938" title="(path: PatternMatching.this.global.Tree)List[PatternMatching.this.global.Symbol]">chop</a><span class="delimiter">(</span><a href="#1090143" title="SymbolicMatchAnalysis.this.Var">variable</a>.<a href="#1087252" title="=&gt; PatternMatching.this.global.Tree">path</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1090155">pre</a>   = <a href="#1090154" title="List[PatternMatching.this.global.Symbol]">path</a>.<a href="../../../collection/TraversableLike.scala.html#58107" title="=&gt; List[PatternMatching.this.global.Symbol]">init</a>
          <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="1090156">field</a> = <a href="#1090154" title="List[PatternMatching.this.global.Symbol]">path</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86394" title="=&gt; PatternMatching.this.global.Symbol">last</a>

          <span class="keyword">val</span> <a title="VariableAssignment" id="1090157">newCtor</a> = <a href="#1090014" title="(variable: SymbolicMatchAnalysis.this.Var)VariableAssignment">unique</a><span class="delimiter">(</span><a href="#1090143" title="SymbolicMatchAnalysis.this.Var">variable</a><span class="delimiter">)</span>

          <span title="VariableAssignment" class="keyword">if</span> <span class="delimiter">(</span><a href="#1090155" title="List[PatternMatching.this.global.Symbol]">pre</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#1090157" title="VariableAssignment">newCtor</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="#1090011" title="(path: List[PatternMatching.this.global.Symbol])Option[SymbolicMatchAnalysis.this.Var]">findVar</a><span class="delimiter">(</span><a href="#1090155" title="List[PatternMatching.this.global.Symbol]">pre</a><span class="delimiter">)</span> <a href="../../../Option.scala.html#62884" title="(f: SymbolicMatchAnalysis.this.Var =&gt; Unit)Unit">foreach</a> <span class="delimiter">{</span> <a title="SymbolicMatchAnalysis.this.Var" id="1090162">preVar</a> =&gt;
              <span class="keyword">val</span> <a title="VariableAssignment" id="1090163">outerCtor</a> = <a href="#1090015" title="(variable: SymbolicMatchAnalysis.this.Var)VariableAssignment" class="keyword">this</a><span class="delimiter">(</span><a href="#1090162" title="SymbolicMatchAnalysis.this.Var">preVar</a><span class="delimiter">)</span>
              <a href="#1090163" title="VariableAssignment">outerCtor</a>.<a href="../../../collection/mutable/MapLike.scala.html#87611" title="(key: PatternMatching.this.global.Symbol, value: VariableAssignment)Unit">fields</a><span class="delimiter">(</span><a href="#1090156" title="PatternMatching.this.global.Symbol">field</a><span class="delimiter">)</span> = <a href="#1090157" title="VariableAssignment">newCtor</a>
            <span class="delimiter">}</span>
            <a href="#1090157" title="VariableAssignment">newCtor</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      // node in the tree that describes how to construct a counter-example
      case <span class="keyword">class</span> <a title="(variable: SymbolicMatchAnalysis.this.Var, equalTo: List[SymbolicMatchAnalysis.this.Const], notEqualTo: List[SymbolicMatchAnalysis.this.Const], fields: scala.collection.mutable.Map[PatternMatching.this.global.Symbol,VariableAssignment])VariableAssignment" id="1090604">VariableAssignment</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="SymbolicMatchAnalysis.this.Var" id="1090578">variable</a>: <a href="#1069204" title="SymbolicMatchAnalysis.this.Var">Var</a>, <a title="List[SymbolicMatchAnalysis.this.Const]" id="1090579">equalTo</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[SymbolicMatchAnalysis.this.Const]">List</a><span class="delimiter">[</span>Const<span class="delimiter">]</span>, <a title="List[SymbolicMatchAnalysis.this.Const]" id="1090580">notEqualTo</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[SymbolicMatchAnalysis.this.Const]">List</a><span class="delimiter">[</span>Const<span class="delimiter">]</span>, <a title="scala.collection.mutable.Map[PatternMatching.this.global.Symbol,VariableAssignment]" id="1090581">fields</a>: scala.collection.mutable.<a href="../../../collection/mutable/Map.scala.html#12498" title="scala.collection.mutable.Map[PatternMatching.this.global.Symbol,VariableAssignment]">Map</a><span class="delimiter">[</span>Symbol, VariableAssignment<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        // need to prune since the model now incorporates all super types of a constant (needed for reachability)
        <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="List[SymbolicMatchAnalysis.this.Const]" id="1090031">uniqueEqualTo</a> = <a href="#1090579" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">equalTo</a> <a href="../../../collection/TraversableLike.scala.html#58074" title="(p: SymbolicMatchAnalysis.this.Const =&gt; Boolean)List[SymbolicMatchAnalysis.this.Const]">filterNot</a> <span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Const" id="1090214">subsumed</a> =&gt; <a href="#1090579" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">equalTo</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86379" title="(p: SymbolicMatchAnalysis.this.Const =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Const" id="1090221">better</a> =&gt; <span class="delimiter">(</span><a href="#1090221" title="SymbolicMatchAnalysis.this.Const">better</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#1090214" title="SymbolicMatchAnalysis.this.Const">subsumed</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1069019" title="(tp: PatternMatching.this.global.Type, tpImplied: PatternMatching.this.global.Type)Boolean">instanceOfTpImplies</a><span class="delimiter">(</span><a href="#1090221" title="SymbolicMatchAnalysis.this.Const">better</a>.<a href="#1087332" title="=&gt; PatternMatching.this.global.Type">tp</a>, <a href="#1090214" title="SymbolicMatchAnalysis.this.Const">subsumed</a>.<a href="#1087332" title="=&gt; PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="List[SymbolicMatchAnalysis.this.Const]" id="1090033">prunedEqualTo</a> = <a href="#1090030" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">uniqueEqualTo</a> <a href="../../../collection/TraversableLike.scala.html#58074" title="(p: SymbolicMatchAnalysis.this.Const =&gt; Boolean)List[SymbolicMatchAnalysis.this.Const]">filterNot</a> <span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Const" id="1090225">subsumed</a> =&gt; <a href="#1090578" title="=&gt; SymbolicMatchAnalysis.this.Var">variable</a>.<a href="#1087233" title="=&gt; PatternMatching.this.global.Type">staticTpCheckable</a> <a href="../../../reflect/internal/Types.scala.html#408481" title="(that: PatternMatching.this.global.Type)Boolean">&lt;:&lt;</a> <a href="#1090225" title="SymbolicMatchAnalysis.this.Const">subsumed</a>.<a href="#1087332" title="=&gt; PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>
        <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="1090035">ctor</a>       = <span class="delimiter">(</span><a href="#1090032" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">prunedEqualTo</a> <span class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> <a href="../../../collection/generic/SeqFactory.scala.html#59986" title="Option[List[SymbolicMatchAnalysis.this.Const]]" id="3369915">List</a><span class="delimiter">(</span><a href="#1087325" title="Option[PatternMatching.this.global.Type]" id="3369914">TypeConst</a><a title="SymbolicMatchAnalysis.this.Const" id="3369907" class="delimiter">(</a><a title="PatternMatching.this.global.Type" id="1090237">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#3369910" title="(x: PatternMatching.this.global.Type)PatternMatching.this.global.Type">tp</a> <span class="keyword">case</span> _ =&gt; <a href="#1090578" title="=&gt; SymbolicMatchAnalysis.this.Var">variable</a>.<a href="#3369910" title="(x: PatternMatching.this.global.Type)PatternMatching.this.global.Type">staticTpCheckable</a> <span class="delimiter">}</span><span class="delimiter">)</span>.<a href="../../../reflect/internal/Types.scala.html#408407" title="=&gt; PatternMatching.this.global.Symbol">typeSymbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411424" title="=&gt; PatternMatching.this.global.Symbol">primaryConstructor</a>
        <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1090037">ctorParams</a> = <span title="List[PatternMatching.this.global.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1090034" title="=&gt; PatternMatching.this.global.Symbol">ctor</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="#1090034" title="=&gt; PatternMatching.this.global.Symbol">ctor</a>.<a href="../../../reflect/internal/Symbols.scala.html#411390" title="=&gt; List[List[PatternMatching.this.global.Symbol]]">paramss</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a> <span class="keyword">else</span> <a href="#1090034" title="=&gt; PatternMatching.this.global.Symbol">ctor</a>.<a href="../../../reflect/internal/Symbols.scala.html#411390" title="=&gt; List[List[PatternMatching.this.global.Symbol]]">paramss</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; List[PatternMatching.this.global.Symbol]">head</a>
        <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="1090039">cls</a>        = <span title="PatternMatching.this.global.Symbol" class="keyword">if</span> <span class="delimiter">(</span><a href="#1090034" title="=&gt; PatternMatching.this.global.Symbol">ctor</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a> <span class="keyword">else</span> <a href="#1090034" title="=&gt; PatternMatching.this.global.Symbol">ctor</a>.<a href="../../../reflect/internal/Symbols.scala.html#411315" title="=&gt; PatternMatching.this.global.Symbol">owner</a>
        <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1090041">caseFieldAccs</a> = <span title="List[PatternMatching.this.global.Symbol]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1090038" title="=&gt; PatternMatching.this.global.Symbol">cls</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a> <span class="keyword">else</span> <a href="#1090038" title="=&gt; PatternMatching.this.global.Symbol">cls</a>.<a href="../../../reflect/internal/Symbols.scala.html#411428" title="=&gt; List[PatternMatching.this.global.Symbol]">caseFieldAccessors</a>


        <span class="keyword">def</span> <a title="=&gt; Boolean" id="1090042">allFieldAssignmentsLegal</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> =
          <span class="delimiter">(</span><a href="#1090581" title="=&gt; scala.collection.mutable.Map[PatternMatching.this.global.Symbol,VariableAssignment]">fields</a>.<a href="../../../collection/MapLike.scala.html#87538" title="=&gt; scala.collection.Set[PatternMatching.this.global.Symbol]">keySet</a> <a href="../../../collection/GenSetLike.scala.html#66410" title="(that: scala.collection.GenSet[PatternMatching.this.global.Symbol])Boolean">subsetOf</a> <a href="#1090040" title="=&gt; List[PatternMatching.this.global.Symbol]">caseFieldAccs</a>.<a href="../../../collection/TraversableOnce.scala.html#58270" title="scala.collection.immutable.Set[PatternMatching.this.global.Symbol]">toSet</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1090581" title="=&gt; scala.collection.mutable.Map[PatternMatching.this.global.Symbol,VariableAssignment]">fields</a>.<a href="../../../collection/MapLike.scala.html#87542" title="=&gt; Iterable[VariableAssignment]">values</a>.<a href="../../../collection/IterableLike.scala.html#58565" title="(p: VariableAssignment =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#1090270" title="VariableAssignment">_</a>.<a href="#1090042" title="=&gt; Boolean">allFieldAssignmentsLegal</a><span class="delimiter">)</span>

        <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="List[SymbolicMatchAnalysis.this.Const]" id="1090044">nonTrivialNonEqualTo</a> = <a href="#1090580" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">notEqualTo</a>.<a href="../../../collection/TraversableLike.scala.html#58074" title="(p: SymbolicMatchAnalysis.this.Const =&gt; Boolean)List[SymbolicMatchAnalysis.this.Const]">filterNot</a><span class="delimiter">{</span><a title="SymbolicMatchAnalysis.this.Const" id="1090274">c</a> =&gt; <a href="#1090274" title="SymbolicMatchAnalysis.this.Const">c</a>.<a href="#1087334" title="=&gt; Boolean">isAny</a> <span class="delimiter">}</span>

        // NoExample if the constructor call is ill-typed
        // (thus statically impossible -- can we incorporate this into the formula?)
        // beBrief is used to suppress negative information nested in tuples -- it tends to get too noisy
        <span class="keyword">def</span> <a title="(beBrief: Boolean)SymbolicMatchAnalysis.this.CounterExample" id="1090045">toCounterExample</a><span class="delimiter">(</span><a title="Boolean" id="1090277">beBrief</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <a href="#1069227" title="SymbolicMatchAnalysis.this.CounterExample">CounterExample</a> =
          <span title="SymbolicMatchAnalysis.this.CounterExample" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1090042" title="=&gt; Boolean">allFieldAssignmentsLegal</a><span class="delimiter">)</span> <a href="#1089670" title="SymbolicMatchAnalysis.this.NoExample.type">NoExample</a>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;describing &quot;)" class="string">&quot;describing &quot;</span><a href="../../../Tuple6.scala.html#91857" title="(x$1: Any)String">+</a> <span class="delimiter">(</span><a href="#1090578" title="=&gt; SymbolicMatchAnalysis.this.Var">variable</a>, <a href="#1090579" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">equalTo</a>, <a href="#1090580" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">notEqualTo</a>, <a href="#1090581" title="=&gt; scala.collection.mutable.Map[PatternMatching.this.global.Symbol,VariableAssignment]">fields</a>, <a href="#1090038" title="=&gt; PatternMatching.this.global.Symbol">cls</a>, <a href="#1090042" title="=&gt; Boolean">allFieldAssignmentsLegal</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">val</span> <a title="SymbolicMatchAnalysis extends Product with Serializable with SymbolicMatchAnalysis.this.CounterExample" id="1090278">res</a> = <a href="#1090032" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">prunedEqualTo</a> <span class="keyword">match</span> <span class="delimiter">{</span>
              // a definite assignment to a value
              <span class="keyword">case</span> <a href="../../../collection/generic/SeqFactory.scala.html#59986" title="Option[List[SymbolicMatchAnalysis.this.Const]]" id="3369959">List</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Const" id="1090305">eq</a>: ValueConst<span class="delimiter">)</span> <span class="keyword">if</span> <a href="#1090581" title="=&gt; scala.collection.mutable.Map[PatternMatching.this.global.Symbol,VariableAssignment]">fields</a>.<a href="../../../collection/MapLike.scala.html#87531" title="=&gt; Boolean">isEmpty</a> =&gt; <a href="#1090692" title="(c: SymbolicMatchAnalysis.this.ValueConst)SymbolicMatchAnalysis.this.ValueExample">ValueExample</a><a href="#3369955" title="(x: Product with Serializable with SymbolicMatchAnalysis.this.CounterExample)Product with Serializable with SymbolicMatchAnalysis.this.CounterExample" class="delimiter">(</a>eq<span class="delimiter">)</span>

              // constructor call
              // or we did not gather any information about equality but we have information about the fields
              //  --&gt; typical example is when the scrutinee is a tuple and all the cases first unwrap that tuple and only then test something interesting
              <span class="keyword">case</span> _ <span class="keyword">if</span> <a href="#1090038" title="=&gt; PatternMatching.this.global.Symbol">cls</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="../../../reflect/internal/Definitions.scala.html#409297" title="(sym: PatternMatching.this.global.Symbol)Boolean">isPrimitiveValueClass</a><span class="delimiter">(</span><a href="#1090038" title="=&gt; PatternMatching.this.global.Symbol">cls</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a>
                        <span class="delimiter">(</span>  <a href="#1090030" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">uniqueEqualTo</a>.<a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a>
                        <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#1090581" title="=&gt; scala.collection.mutable.Map[PatternMatching.this.global.Symbol,VariableAssignment]">fields</a>.<a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1090032" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">prunedEqualTo</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1090580" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">notEqualTo</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;

                <span class="keyword">def</span> <a title="(brevity: Boolean)List[SymbolicMatchAnalysis.this.CounterExample]" id="1090317">args</a><span class="delimiter">(</span><a title="Boolean" id="1090319">brevity</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <a href="#1090277" title="Boolean">beBrief</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
                  // figure out the constructor arguments from the field assignment
                  <span class="keyword">val</span> <a title="Int" id="1090320">argLen</a> = <span class="delimiter">(</span><a href="#1090040" title="=&gt; List[PatternMatching.this.global.Symbol]">caseFieldAccs</a>.<a href="../../../LowPriorityImplicits.scala.html#7395" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">length</a> <a href="../../../runtime/RichInt.scala.html#57064" title="(that: Int)Int">min</a> <a href="#1090036" title="=&gt; List[PatternMatching.this.global.Symbol]">ctorParams</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86373" title="=&gt; Int">length</a><span class="delimiter">)</span>

                  <span class="delimiter">(</span><a href="../../../LowPriorityImplicits.scala.html#7395" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">0</a> <a href="../../../runtime/RichInt.scala.html#57060" title="(end: Int)scala.collection.immutable.Range">until</a> <a href="#1090320" title="Int">argLen</a><span class="delimiter">)</span>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: Int =&gt; SymbolicMatchAnalysis.this.CounterExample)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],SymbolicMatchAnalysis.this.CounterExample,scala.collection.immutable.IndexedSeq[SymbolicMatchAnalysis.this.CounterExample]])scala.collection.immutable.IndexedSeq[SymbolicMatchAnalysis.this.CounterExample]">map</a><a href="../../../collection/immutable/IndexedSeq.scala.html#59992" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq.Coll,SymbolicMatchAnalysis.this.CounterExample,scala.collection.immutable.IndexedSeq[SymbolicMatchAnalysis.this.CounterExample]]" class="delimiter">(</a><a title="Int" id="1090436">i</a> =&gt; <a href="#1090581" title="=&gt; scala.collection.mutable.Map[PatternMatching.this.global.Symbol,VariableAssignment]">fields</a>.<a href="../../../collection/MapLike.scala.html#87525" title="(key: PatternMatching.this.global.Symbol)Option[VariableAssignment]">get</a><span class="delimiter">(</span><a href="../../../collection/LinearSeqOptimized.scala.html#86374" title="(n: Int)PatternMatching.this.global.Symbol">caseFieldAccs</a><span class="delimiter">(</span><a href="#1090436" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../Option.scala.html#62865" title="(f: VariableAssignment =&gt; SymbolicMatchAnalysis.this.CounterExample)Option[SymbolicMatchAnalysis.this.CounterExample]">map</a><span class="delimiter">(</span><a href="#1090450" title="VariableAssignment">_</a>.<a href="#1090045" title="(beBrief: Boolean)SymbolicMatchAnalysis.this.CounterExample">toCounterExample</a><span class="delimiter">(</span><a href="#1090319" title="Boolean">brevity</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../Option.scala.html#62859" title="(default: =&gt; SymbolicMatchAnalysis.this.CounterExample)SymbolicMatchAnalysis.this.CounterExample">getOrElse</a> <a href="#1089655" title="SymbolicMatchAnalysis.this.WildcardExample.type">WildcardExample</a><span class="delimiter">)</span>.<a href="../../../collection/TraversableOnce.scala.html#58263" title="=&gt; List[SymbolicMatchAnalysis.this.CounterExample]">toList</a>
                <span class="delimiter">}</span>

                <a href="#1090038" title="=&gt; PatternMatching.this.global.Symbol">cls</a> <span class="keyword">match</span> <span class="delimiter">{</span>
                  <span class="keyword">case</span> <a href="../../../reflect/internal/Definitions.scala.html#408831" title="SymbolicMatchAnalysis extends Product with Serializable with SymbolicMatchAnalysis.this.CounterExample" id="3369931">ConsClass</a>               =&gt; <a href="#1090742" title="(ctorArgs: List[SymbolicMatchAnalysis.this.CounterExample])SymbolicMatchAnalysis.this.ListExample">ListExample</a><a href="#3369934" title="(x: Product with Serializable with SymbolicMatchAnalysis.this.CounterExample)Product with Serializable with SymbolicMatchAnalysis.this.CounterExample" class="delimiter">(</a><a href="#1090317" title="(brevity: Boolean)List[SymbolicMatchAnalysis.this.CounterExample]">args</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span class="keyword">case</span> _ <span class="keyword">if</span> <a href="../../../reflect/internal/Definitions.scala.html#409001" title="(sym: PatternMatching.this.global.Symbol)Boolean">isTupleSymbol</a><span class="delimiter">(</span><a href="#1090038" title="=&gt; PatternMatching.this.global.Symbol">cls</a><span class="delimiter">)</span> =&gt; <a href="#1090746" title="(ctorArgs: List[SymbolicMatchAnalysis.this.CounterExample])SymbolicMatchAnalysis.this.TupleExample">TupleExample</a><a href="#3369934" title="(x: Product with Serializable with SymbolicMatchAnalysis.this.CounterExample)Product with Serializable with SymbolicMatchAnalysis.this.CounterExample" class="delimiter">(</a><a href="#1090317" title="(brevity: Boolean)List[SymbolicMatchAnalysis.this.CounterExample]">args</a><span class="delimiter">(</span><span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">)</span>
                  <span class="keyword">case</span> _ =&gt; <a href="#1090772" title="(cls: PatternMatching.this.global.Symbol, ctorArgs: List[SymbolicMatchAnalysis.this.CounterExample])SymbolicMatchAnalysis.this.ConstructorExample">ConstructorExample</a><a href="#3369934" title="(x: Product with Serializable with SymbolicMatchAnalysis.this.CounterExample)Product with Serializable with SymbolicMatchAnalysis.this.CounterExample" class="delimiter">(</a><a href="#1090038" title="=&gt; PatternMatching.this.global.Symbol">cls</a>, <a href="#1090317" title="(brevity: Boolean)List[SymbolicMatchAnalysis.this.CounterExample]">args</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="delimiter">}</span>

              // a definite assignment to a type
              <span class="keyword">case</span> <a href="../../../collection/generic/SeqFactory.scala.html#59986" title="Option[List[SymbolicMatchAnalysis.this.Const]]" id="3369962">List</a><span class="delimiter">(</span><a title="SymbolicMatchAnalysis.this.Const" id="1090532">eq</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#1090581" title="=&gt; scala.collection.mutable.Map[PatternMatching.this.global.Symbol,VariableAssignment]">fields</a>.<a href="../../../collection/MapLike.scala.html#87531" title="=&gt; Boolean">isEmpty</a> =&gt; <a href="#1090712" title="(c: SymbolicMatchAnalysis.this.Const)SymbolicMatchAnalysis.this.TypeExample">TypeExample</a><a href="#3369955" title="(x: Product with Serializable with SymbolicMatchAnalysis.this.CounterExample)Product with Serializable with SymbolicMatchAnalysis.this.CounterExample" class="delimiter">(</a><a href="#1090532" title="SymbolicMatchAnalysis.this.Const">eq</a><span class="delimiter">)</span>

              // negative information
              <span class="keyword">case</span> <a href="../../../collection/immutable/List.scala.html#11188" title="SymbolicMatchAnalysis extends Product with Serializable with SymbolicMatchAnalysis.this.CounterExample" id="3369953">Nil</a> <span class="keyword">if</span> <a href="#1090043" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">nonTrivialNonEqualTo</a>.<a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a> =&gt;
                // negation tends to get pretty verbose
                <a href="#3369955" title="(x: Product with Serializable with SymbolicMatchAnalysis.this.CounterExample)Product with Serializable with SymbolicMatchAnalysis.this.CounterExample" class="keyword">if</a> <span class="delimiter">(</span><a href="#1090277" title="Boolean">beBrief</a><span class="delimiter">)</span> <a href="#1089655" title="SymbolicMatchAnalysis.this.WildcardExample.type">WildcardExample</a>
                <span class="keyword">else</span> <span class="delimiter">{</span>
                  <span class="keyword">val</span> <a title="SymbolicMatchAnalysis.this.Const" id="1090540">eqTo</a> = <a href="#1090579" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">equalTo</a>.<a href="../../../collection/TraversableLike.scala.html#58103" title="=&gt; Option[SymbolicMatchAnalysis.this.Const]">headOption</a> <a href="../../../Option.scala.html#62859" title="(default: =&gt; SymbolicMatchAnalysis.this.Const)SymbolicMatchAnalysis.this.Const">getOrElse</a> <a href="#1087324" title="(tp: PatternMatching.this.global.Type)SymbolicMatchAnalysis.this.Const">TypeConst</a><span class="delimiter">(</span><a href="#1090578" title="=&gt; SymbolicMatchAnalysis.this.Var">variable</a>.<a href="#1087233" title="=&gt; PatternMatching.this.global.Type">staticTpCheckable</a><span class="delimiter">)</span>
                  <a href="#1090738" title="(eqTo: SymbolicMatchAnalysis.this.Const, nonTrivialNonEqualTo: List[SymbolicMatchAnalysis.this.Const])SymbolicMatchAnalysis.this.NegativeExample">NegativeExample</a><span class="delimiter">(</span><a href="#1090540" title="SymbolicMatchAnalysis.this.Const">eqTo</a>, <a href="#1090043" title="=&gt; List[SymbolicMatchAnalysis.this.Const]">nonTrivialNonEqualTo</a><span class="delimiter">)</span>
                <span class="delimiter">}</span>

              // not a valid counter-example, possibly since we have a definite type but there was a field mismatch
              // TODO: improve reasoning -- in the mean time, a false negative is better than an annoying false positive
              <span class="keyword">case</span> _ =&gt; <a href="#3369955" title="(x: Product with Serializable with SymbolicMatchAnalysis.this.CounterExample)Product with Serializable with SymbolicMatchAnalysis.this.CounterExample">NoExample</a>
            <span class="delimiter">}</span>
            <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;described as: &quot;)" class="string">&quot;described as: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1090278" title="SymbolicMatchAnalysis extends Product with Serializable with SymbolicMatchAnalysis.this.CounterExample">res</a><span class="delimiter">)</span>
            <a href="#1090278" title="SymbolicMatchAnalysis extends Product with Serializable with SymbolicMatchAnalysis.this.CounterExample">res</a>
          <span class="delimiter">}</span>

        <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1090046">toString</a> = <a href="#1090045" title="(beBrief: Boolean)SymbolicMatchAnalysis.this.CounterExample">toCounterExample</a><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="()String">toString</span>
      <span class="delimiter">}</span>

      // slurp in information from other variables
      <a href="#1089937" title="Map[SymbolicMatchAnalysis.this.Var,(Seq[SymbolicMatchAnalysis.this.Const], Seq[SymbolicMatchAnalysis.this.Const])]">varAssignment</a>.<a href="../../../collection/MapLike.scala.html#87541" title="=&gt; Iterable[SymbolicMatchAnalysis.this.Var]">keys</a>.<a href="../../../collection/IterableLike.scala.html#58562" title="(f: SymbolicMatchAnalysis.this.Var =&gt; Any)Unit">foreach</a><span class="delimiter">{</span> <a title="SymbolicMatchAnalysis.this.Var" id="1090648">v</a> =&gt; <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#1090648" title="SymbolicMatchAnalysis.this.Var">v</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#1088859" title="SymbolicMatchAnalysis.this.Var">scrutVar</a><span class="delimiter">)</span> <a href="#1090015" title="(variable: SymbolicMatchAnalysis.this.Var)VariableAssignment">VariableAssignment</a><span class="delimiter">(</span><a href="#1090648" title="SymbolicMatchAnalysis.this.Var">v</a><span class="delimiter">)</span> <span class="delimiter">}</span>

      // this is the variable we want a counter example for
      <a href="#1090015" title="(variable: SymbolicMatchAnalysis.this.Var)VariableAssignment">VariableAssignment</a><a title="VariableAssignment" id="1090671" class="delimiter">(</a><a href="#1088859" title="SymbolicMatchAnalysis.this.Var">scrutVar</a><span class="delimiter">)</span>.<a href="#1090277" title="Boolean" id="1090672">toCounterExample</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

////
  <span class="keyword">trait</span> <a title="trait CommonSubconditionElimination extends Object with PatternMatching.this.TreeMakerApproximation" id="621398">CommonSubconditionElimination</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621392" title="PatternMatching.this.TreeMakerApproximation">TreeMakerApproximation</a> <span class="delimiter">{</span> self: OptimizedCodegen =&gt;
    /** a flow-sensitive, generalised, common sub-expression elimination
     * reuse knowledge from performed tests
     * the only sub-expressions we consider are the conditions and results of the three tests (type, type&amp;equality, equality)
     * when a sub-expression is shared, it is stored in a mutable variable
     * the variable is floated up so that its scope includes all of the program that shares it
     * we generalize sharing to implication, where b reuses a if a =&gt; b and priors(a) =&gt; priors(b) (the priors of a sub expression form the path through the decision tree)
     */
    <span class="keyword">def</span> <a title="(prevBinder: PatternMatching.this.global.Symbol, cases: List[List[CommonSubconditionElimination.this.TreeMaker]], pt: PatternMatching.this.global.Type)List[List[CommonSubconditionElimination.this.TreeMaker]]" id="1069165">doCSE</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1090778">prevBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="List[List[CommonSubconditionElimination.this.TreeMaker]]" id="1090779">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[CommonSubconditionElimination.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="PatternMatching.this.global.Type" id="1090780">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[CommonSubconditionElimination.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;before CSE:&quot;)" class="string">&quot;before CSE:&quot;</span><span class="delimiter">)</span>
      <a href="#1069161" title="(cases: List[List[CommonSubconditionElimination.this.TreeMaker]])Unit">showTreeMakers</a><span class="delimiter">(</span><a href="#1090779" title="List[List[CommonSubconditionElimination.this.TreeMaker]]">cases</a><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="List[List[CommonSubconditionElimination.this.Test]]" id="1090782">testss</a> = <a href="#1069160" title="(root: PatternMatching.this.global.Symbol, cases: List[List[CommonSubconditionElimination.this.TreeMaker]])List[List[CommonSubconditionElimination.this.Test]]">approximateMatchConservative</a><span class="delimiter">(</span><a href="#1090778" title="PatternMatching.this.global.Symbol">prevBinder</a>, <a href="#1090779" title="List[List[CommonSubconditionElimination.this.TreeMaker]]">cases</a><span class="delimiter">)</span>

      // interpret:
      <span class="keyword">val</span> <a title="scala.collection.mutable.LinkedHashMap[CommonSubconditionElimination.this.Test,Set[CommonSubconditionElimination.this.Cond]]" id="1090783">dependencies</a> = <span title="scala.collection.mutable.LinkedHashMap[CommonSubconditionElimination.this.Test,Set[CommonSubconditionElimination.this.Cond]]" class="keyword">new</span> scala.collection.mutable.<a href="../../../collection/mutable/LinkedHashMap.scala.html#12729" title="scala.collection.mutable.LinkedHashMap[CommonSubconditionElimination.this.Test,Set[CommonSubconditionElimination.this.Cond]]">LinkedHashMap</a><span class="delimiter">[</span>Test, Set<span class="delimiter">[</span>Cond<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="keyword">val</span> <a title="scala.collection.mutable.HashSet[CommonSubconditionElimination.this.Cond]" id="1090784">tested</a> = <a href="../../../collection/mutable/HashSet.scala.html#125959" title="()scala.collection.mutable.HashSet[CommonSubconditionElimination.this.Cond]" class="keyword">new</a> scala.collection.mutable.<a href="../../../collection/mutable/HashSet.scala.html#13053" title="scala.collection.mutable.HashSet[CommonSubconditionElimination.this.Cond]">HashSet</a><span class="delimiter">[</span>Cond<span class="delimiter">]</span>

      <span class="keyword">def</span> <a title="(test: CommonSubconditionElimination.this.Test)Boolean" id="1090785">storeDependencies</a><span class="delimiter">(</span><a title="CommonSubconditionElimination.this.Test" id="1090795">test</a>: <a href="#1076105" title="CommonSubconditionElimination.this.Test">Test</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="CommonSubconditionElimination.this.Cond" id="1090796">cond</a> = <a href="#1090795" title="CommonSubconditionElimination.this.Test">test</a>.<a href="#1076087" title="=&gt; CommonSubconditionElimination.this.Cond">cond</a>

        <span class="keyword">def</span> <a title="(c: CommonSubconditionElimination.this.Cond)Set[CommonSubconditionElimination.this.Cond]" id="1090797">simplify</a><span class="delimiter">(</span><a title="CommonSubconditionElimination.this.Cond" id="1090799">c</a>: <a href="#1069136" title="CommonSubconditionElimination.this.Cond">Cond</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/Set.scala.html#11919" title="Set[CommonSubconditionElimination.this.Cond]">Set</a><span class="delimiter">[</span>Cond<span class="delimiter">]</span> = <a href="#1090799" title="CommonSubconditionElimination.this.Cond">c</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> AndCond<a href="#3370016" title="Set[CommonSubconditionElimination.this.Cond]" id="3370018" class="delimiter">(</a><a href="#1076546" title="CommonSubconditionElimination.this.Cond" id="1090802">a</a>, <a href="#1076547" title="CommonSubconditionElimination.this.Cond" id="1090803">b</a><span class="delimiter">)</span> =&gt; <a href="#1090797" title="(c: CommonSubconditionElimination.this.Cond)Set[CommonSubconditionElimination.this.Cond]">simplify</a><span class="delimiter">(</span><a href="#1090802" title="CommonSubconditionElimination.this.Cond">a</a><span class="delimiter">)</span> <a href="#3370028" title="(x: Set[CommonSubconditionElimination.this.Cond])Set[CommonSubconditionElimination.this.Cond]">++</a> <a href="#1090797" title="(c: CommonSubconditionElimination.this.Cond)Set[CommonSubconditionElimination.this.Cond]">simplify</a><span class="delimiter">(</span><a href="#1090803" title="CommonSubconditionElimination.this.Cond">b</a><span class="delimiter">)</span>
          <span class="keyword">case</span> OrCond<a href="#3370016" title="Set[CommonSubconditionElimination.this.Cond]" id="3370022" class="delimiter">(</a><a href="#1076567" title="CommonSubconditionElimination.this.Cond" id="3370019">_</a>, <a href="#1076568" title="CommonSubconditionElimination.this.Cond" id="3370020">_</a><span class="delimiter">)</span>   =&gt; <a href="../../../collection/generic/GenericCompanion.scala.html#59933" title="(elems: CommonSubconditionElimination.this.Cond*)scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]">Set</a><a href="#3370028" title="(x: Set[CommonSubconditionElimination.this.Cond])Set[CommonSubconditionElimination.this.Cond]" class="delimiter">(</a><a href="#1076165" title="CommonSubconditionElimination.this.FalseCond.type">FalseCond</a><span class="delimiter">)</span> // TODO: make more precise
          <span class="keyword">case</span> <a href="#1076323" title="Option[PatternMatching.this.global.Tree]" id="3370034">NonNullCond</a><a href="#3370016" title="Set[CommonSubconditionElimination.this.Cond]" id="3370025" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="3370023">_</a><span class="delimiter">)</span> =&gt; <a href="../../../collection/generic/GenericCompanion.scala.html#59933" title="(elems: CommonSubconditionElimination.this.Cond*)scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]">Set</a><a href="#3370028" title="(x: Set[CommonSubconditionElimination.this.Cond])Set[CommonSubconditionElimination.this.Cond]" class="delimiter">(</a><a href="#1076148" title="CommonSubconditionElimination.this.TrueCond.type">TrueCond</a><span class="delimiter">)</span>  // not worth remembering
          <span class="keyword">case</span> _ =&gt; <a href="../../../collection/generic/GenericCompanion.scala.html#59933" title="(elems: CommonSubconditionElimination.this.Cond*)scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]">Set</a><a href="#3370028" title="(x: Set[CommonSubconditionElimination.this.Cond])Set[CommonSubconditionElimination.this.Cond]" class="delimiter">(</a><a href="#1090799" title="CommonSubconditionElimination.this.Cond">c</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">val</span> <a title="Set[CommonSubconditionElimination.this.Cond]" id="1090798">conds</a> = <a href="#1090797" title="(c: CommonSubconditionElimination.this.Cond)Set[CommonSubconditionElimination.this.Cond]">simplify</a><span class="delimiter">(</span><a href="#1090796" title="CommonSubconditionElimination.this.Cond">cond</a><span class="delimiter">)</span>

        <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../collection/GenSetLike.scala.html#66403" title="(elem: CommonSubconditionElimination.this.Cond)Boolean">conds</a><span class="delimiter">(</span><a href="#1076165" title="CommonSubconditionElimination.this.FalseCond.type">FalseCond</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Boolean(false)" class="keyword">false</span> // stop when we encounter a definite &quot;no&quot; or a &quot;not sure&quot;
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]" id="1090889">nonTrivial</a> = <a href="#1090798" title="Set[CommonSubconditionElimination.this.Cond]">conds</a> <a href="../../../collection/TraversableLike.scala.html#58074" title="(p: CommonSubconditionElimination.this.Cond =&gt; Boolean)scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]">filterNot</a> <span class="delimiter">(</span><a href="#1090893" title="CommonSubconditionElimination.this.Cond">_</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1076148" title="CommonSubconditionElimination.this.TrueCond.type">TrueCond</a><span class="delimiter">)</span>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1090889" title="scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]">nonTrivial</a> <a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="#1090784" title="scala.collection.mutable.HashSet[CommonSubconditionElimination.this.Cond]">tested</a> <a href="../../../collection/generic/Growable.scala.html#60003" title="(xs: scala.collection.TraversableOnce[CommonSubconditionElimination.this.Cond])tested.type">++=</a> <a href="#1090889" title="scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]">nonTrivial</a>

            // is there an earlier test that checks our condition and whose dependencies are implied by ours?
            <a href="#1090783" title="scala.collection.mutable.LinkedHashMap[CommonSubconditionElimination.this.Test,Set[CommonSubconditionElimination.this.Cond]]">dependencies</a> <a href="../../../collection/IterableLike.scala.html#58567" title="(p: ((CommonSubconditionElimination.this.Test, Set[CommonSubconditionElimination.this.Cond])) =&gt; Boolean)Option[(CommonSubconditionElimination.this.Test, Set[CommonSubconditionElimination.this.Cond])]">find</a> <a href="#1090904" title="(CommonSubconditionElimination.this.Test, Set[CommonSubconditionElimination.this.Cond])" class="delimiter">{</a>
              <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="CommonSubconditionElimination.this.Test" id="1090907">priorTest</a>, <a href="../../../Tuple2.scala.html#60637" title="Set[CommonSubconditionElimination.this.Cond]" id="1090908">deps</a><span class="delimiter">)</span> =&gt;
                <span class="delimiter">(</span><span class="delimiter">(</span><a href="#1090797" title="(c: CommonSubconditionElimination.this.Cond)Set[CommonSubconditionElimination.this.Cond]">simplify</a><span class="delimiter">(</span><a href="#1090907" title="CommonSubconditionElimination.this.Test">priorTest</a>.<a href="#1076087" title="=&gt; CommonSubconditionElimination.this.Cond">cond</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1090889" title="scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]">nonTrivial</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> // our conditions are implied by priorTest if it checks the same thing directly
                 <span class="delimiter">(</span><a href="#1090889" title="scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]">nonTrivial</a> <a href="../../../collection/GenSetLike.scala.html#66410" title="(that: scala.collection.GenSet[CommonSubconditionElimination.this.Cond])Boolean">subsetOf</a> <a href="#1090908" title="Set[CommonSubconditionElimination.this.Cond]">deps</a><span class="delimiter">)</span>                  // or if it depends on a superset of our conditions
                <span class="delimiter">)</span> <a href="#3370038" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#1090908" title="Set[CommonSubconditionElimination.this.Cond]">deps</a> <a href="../../../collection/GenSetLike.scala.html#66410" title="(that: scala.collection.GenSet[CommonSubconditionElimination.this.Cond])Boolean">subsetOf</a> <a href="#1090784" title="scala.collection.mutable.HashSet[CommonSubconditionElimination.this.Cond]">tested</a><span class="delimiter">)</span>                 // the conditions we've tested when we are here in the match satisfy the prior test, and hence what it tested
            <span class="delimiter">}</span> <a href="../../../Option.scala.html#62884" title="(f: ((CommonSubconditionElimination.this.Test, Set[CommonSubconditionElimination.this.Cond])) =&gt; Unit)Unit">foreach</a> <a href="#1090920" title="(CommonSubconditionElimination.this.Test, Set[CommonSubconditionElimination.this.Cond])" class="delimiter">{</a>
              <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="CommonSubconditionElimination.this.Test" id="1090923">priorTest</a>, <a href="../../../Tuple2.scala.html#60637" title="Set[CommonSubconditionElimination.this.Cond]" id="3370043">_</a><span class="delimiter">)</span> =&gt;
                // if so, note the dependency in both tests
                <a href="#1090923" title="CommonSubconditionElimination.this.Test">priorTest</a> <a href="#3370045" title="(x: Unit)Unit">registerReuseBy</a> <a href="#1090795" title="CommonSubconditionElimination.this.Test">test</a>
            <span class="delimiter">}</span>

            <a href="../../../collection/mutable/MapLike.scala.html#87611" title="(key: CommonSubconditionElimination.this.Test, value: Set[CommonSubconditionElimination.this.Cond])Unit">dependencies</a><span class="delimiter">(</span><a href="#1090795" title="CommonSubconditionElimination.this.Test">test</a><span class="delimiter">)</span> = <a href="#1090784" title="scala.collection.mutable.HashSet[CommonSubconditionElimination.this.Cond]">tested</a>.<a href="../../../collection/TraversableOnce.scala.html#58270" title="scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]">toSet</a> // copies
          <span class="delimiter">}</span>
          <span title="Boolean(true)" class="keyword">true</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>


      <a href="#1090782" title="List[List[CommonSubconditionElimination.this.Test]]">testss</a> <a href="../../../collection/immutable/List.scala.html#62719" title="(f: List[CommonSubconditionElimination.this.Test] =&gt; List[CommonSubconditionElimination.this.Test])Unit">foreach</a> <span class="delimiter">{</span> <a title="List[CommonSubconditionElimination.this.Test]" id="1090953">tests</a> =&gt;
        <a href="#1090784" title="scala.collection.mutable.HashSet[CommonSubconditionElimination.this.Cond]">tested</a>.<a href="../../../collection/mutable/HashSet.scala.html#125968" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#1090953" title="List[CommonSubconditionElimination.this.Test]">tests</a> <a href="../../../collection/immutable/List.scala.html#62714" title="(p: CommonSubconditionElimination.this.Test =&gt; Boolean)List[CommonSubconditionElimination.this.Test]">dropWhile</a> <a href="#1090785" title="(test: CommonSubconditionElimination.this.Test)Boolean">storeDependencies</a>
      <span class="delimiter">}</span>
      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;dependencies: &quot;)" class="string">&quot;dependencies: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1090783" title="scala.collection.mutable.LinkedHashMap[CommonSubconditionElimination.this.Test,Set[CommonSubconditionElimination.this.Cond]]">dependencies</a><span class="delimiter">)</span>

      // find longest prefix of tests that reuse a prior test, and whose dependent conditions monotonically increase
      // then, collapse these contiguous sequences of reusing tests
      // store the result of the final test and the intermediate results in hoisted mutable variables (TODO: optimize: don't store intermediate results that aren't used)
      // replace each reference to a variable originally bound by a collapsed test by a reference to the hoisted variable
      <span class="keyword">val</span> <a title="scala.collection.mutable.HashMap[CommonSubconditionElimination.this.TreeMaker,CommonSubconditionElimination.this.ReusedCondTreeMaker]" id="1090786">reused</a> = <a href="../../../collection/mutable/HashMap.scala.html#88242" title="()scala.collection.mutable.HashMap[CommonSubconditionElimination.this.TreeMaker,CommonSubconditionElimination.this.ReusedCondTreeMaker]" class="keyword">new</a> scala.collection.mutable.<a href="../../../collection/mutable/HashMap.scala.html#12447" title="scala.collection.mutable.HashMap[CommonSubconditionElimination.this.TreeMaker,CommonSubconditionElimination.this.ReusedCondTreeMaker]">HashMap</a><span class="delimiter">[</span>TreeMaker, ReusedCondTreeMaker<span class="delimiter">]</span>
      <span class="keyword">var</span> <a title="Boolean" id="1090787">okToCall</a> = <span title="Boolean(false)" class="keyword">false</span>
      <span class="keyword">val</span> <a title="CommonSubconditionElimination.this.TreeMaker =&gt; CommonSubconditionElimination.this.TreeMaker" id="1090788">reusedOrOrig</a> = <span class="delimiter">(</span>tm: <a href="#1069034" title="CommonSubconditionElimination.this.TreeMaker">TreeMaker</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span><a href="../Global.scala.html#537498" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="#1090787" title="Boolean">okToCall</a><span class="delimiter">)</span>; <a href="#1090786" title="scala.collection.mutable.HashMap[CommonSubconditionElimination.this.TreeMaker,CommonSubconditionElimination.this.ReusedCondTreeMaker]">reused</a>.<a href="../../../collection/MapLike.scala.html#87532" title="(key: CommonSubconditionElimination.this.TreeMaker, default: =&gt; CommonSubconditionElimination.this.TreeMaker)CommonSubconditionElimination.this.TreeMaker">getOrElse</a><span class="delimiter">(</span><a href="#1090962" title="CommonSubconditionElimination.this.TreeMaker">tm</a>, <a href="#1090962" title="CommonSubconditionElimination.this.TreeMaker">tm</a><span class="delimiter">)</span><span class="delimiter">}</span>

      // maybe collapse: replace shared prefix of tree makers by a ReusingCondTreeMaker
      // once this has been computed, we'll know which tree makers are reused,
      // and we'll replace those by the ReusedCondTreeMakers we've constructed (and stored in the reused map)
      <span class="keyword">val</span> <a title="List[List[CommonSubconditionElimination.this.TreeMaker]]" id="1090789">collapsed</a> = <a href="#1090782" title="List[List[CommonSubconditionElimination.this.Test]]">testss</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[CommonSubconditionElimination.this.Test] =&gt; List[CommonSubconditionElimination.this.TreeMaker])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[CommonSubconditionElimination.this.Test]],List[CommonSubconditionElimination.this.TreeMaker],List[List[CommonSubconditionElimination.this.TreeMaker]]])List[List[CommonSubconditionElimination.this.TreeMaker]]">map</a> <span class="delimiter">{</span> <a title="List[CommonSubconditionElimination.this.Test]" id="1091021">tests</a> =&gt;
        // map tests to the equivalent list of treemakers, replacing shared prefixes by a reusing treemaker
        // if there's no sharing, simply map to the tree makers corresponding to the tests
        <span class="keyword">var</span> <a title="scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]" id="1091022">currDeps</a> = <a href="../../../collection/generic/GenericCompanion.scala.html#59933" title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</a><span title="(elems: CommonSubconditionElimination.this.Cond*)scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]" class="delimiter">[</span><a href="#1069136" title="CommonSubconditionElimination.this.Cond">Cond</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a href="#3370051" title="(x: (List[CommonSubconditionElimination.this.Test], List[CommonSubconditionElimination.this.Test]))(List[CommonSubconditionElimination.this.Test], List[CommonSubconditionElimination.this.Test])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="List[CommonSubconditionElimination.this.Test]" id="1091024">sharedPrefix</a>, <a href="../../../Tuple2.scala.html#60637" title="List[CommonSubconditionElimination.this.Test]" id="1091025">suffix</a><span class="delimiter">)</span> = <a href="#1091021" title="List[CommonSubconditionElimination.this.Test]">tests</a> <a href="../../../collection/immutable/List.scala.html#62715" title="(p: CommonSubconditionElimination.this.Test =&gt; Boolean)(List[CommonSubconditionElimination.this.Test], List[CommonSubconditionElimination.this.Test])">span</a> <span class="delimiter">{</span> <a title="CommonSubconditionElimination.this.Test" id="1091033">test</a> =&gt;
          <span class="delimiter">(</span><a href="#1091033" title="CommonSubconditionElimination.this.Test">test</a>.<a href="#1076087" title="=&gt; CommonSubconditionElimination.this.Cond">cond</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1076148" title="CommonSubconditionElimination.this.TrueCond.type">TrueCond</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><span class="keyword">for</span><span class="delimiter">(</span>
              <a title="CommonSubconditionElimination.this.Test" id="1091042">reusedTest</a> &lt;- <a href="#1091033" title="CommonSubconditionElimination.this.Test">test</a>.<a href="../../../Option.scala.html#62871" title="(f: CommonSubconditionElimination.this.Test =&gt; Option[CommonSubconditionElimination.this.Cond])Option[CommonSubconditionElimination.this.Cond]">reuses</a>;
              <a title="Set[CommonSubconditionElimination.this.Cond]" id="1091050">nextDeps</a> &lt;- <a href="#1090783" title="scala.collection.mutable.LinkedHashMap[CommonSubconditionElimination.this.Test,Set[CommonSubconditionElimination.this.Cond]]">dependencies</a>.<a href="../../../collection/mutable/LinkedHashMap.scala.html#285234" title="(key: CommonSubconditionElimination.this.Test)Option[Set[CommonSubconditionElimination.this.Cond]]">get</a><a href="../../../Option.scala.html#62871" title="(f: Set[CommonSubconditionElimination.this.Cond] =&gt; Option[CommonSubconditionElimination.this.Cond])Option[CommonSubconditionElimination.this.Cond]" class="delimiter">(</a><a href="#1091042" title="CommonSubconditionElimination.this.Test">reusedTest</a><span class="delimiter">)</span>;
              <a title="CommonSubconditionElimination.this.Cond" id="1091057">diff</a> &lt;- <span class="delimiter">(</span><a href="#1091050" title="Set[CommonSubconditionElimination.this.Cond]">nextDeps</a> <a href="../../../collection/generic/Subtractable.scala.html#66460" title="(xs: scala.collection.GenTraversableOnce[CommonSubconditionElimination.this.Cond])scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]">--</a> <a href="#1091022" title="scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]">currDeps</a><span class="delimiter">)</span>.<a href="../../../Option.scala.html#62871" title="(f: CommonSubconditionElimination.this.Cond =&gt; Option[CommonSubconditionElimination.this.Cond])Option[CommonSubconditionElimination.this.Cond]">headOption</a>;
              <a title="Unit" id="1091065">_</a> &lt;- <a href="../../../Option.scala.html#63128" title="(x: Unit)Some[Unit]">Some</a><a href="../../../Option.scala.html#62865" title="(f: Unit =&gt; CommonSubconditionElimination.this.Cond)Option[CommonSubconditionElimination.this.Cond]" class="delimiter">(</a><a href="#1091022" title="scala.collection.immutable.Set[CommonSubconditionElimination.this.Cond]">currDeps</a> = <a href="#1091050" title="Set[CommonSubconditionElimination.this.Cond]">nextDeps</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">yield</span> <a href="#1091057" title="CommonSubconditionElimination.this.Cond">diff</a><span class="delimiter">)</span>.<a href="../../../Option.scala.html#62879" title="=&gt; Boolean">nonEmpty</a>
        <span class="delimiter">}</span>

        <span class="keyword">val</span> <a title="Option[List[CommonSubconditionElimination.this.TreeMaker]]" id="1091026">collapsedTreeMakers</a> =
          <span title="Option[List[CommonSubconditionElimination.this.TreeMaker]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1091024" title="List[CommonSubconditionElimination.this.Test]">sharedPrefix</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../../../Option.scala.html#1585" title="None.type">None</a>
          <span class="keyword">else</span> <span class="delimiter">{</span> // even sharing prefixes of length 1 brings some benefit (overhead-percentage for compiler: 26-&gt;24%, lib: 19-&gt;16%)
            <span class="keyword">for</span> <span class="delimiter">(</span><a title="CommonSubconditionElimination.this.Test" id="1091101">test</a> &lt;- <a href="../../../collection/immutable/List.scala.html#62719" title="(f: CommonSubconditionElimination.this.Test =&gt; Unit)Unit">sharedPrefix</a>; <a title="CommonSubconditionElimination.this.Test" id="1091106">reusedTest</a> &lt;- <a href="#1091101" title="CommonSubconditionElimination.this.Test">test</a>.<a href="../../../Option.scala.html#62884" title="(f: CommonSubconditionElimination.this.Test =&gt; Unit)Unit">reuses</a><span class="delimiter">)</span> <a href="#1091106" title="CommonSubconditionElimination.this.Test">reusedTest</a>.<a href="#1076088" title="=&gt; CommonSubconditionElimination.this.TreeMaker">treeMaker</a> <span class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <a href="#3370055" title="Unit" id="3370057">reusedCTM</a>: CondTreeMaker =&gt; <a href="../../../collection/mutable/HashMap.scala.html#88248" title="(key: CommonSubconditionElimination.this.TreeMaker, value: CommonSubconditionElimination.this.ReusedCondTreeMaker)Unit">reused</a><span class="delimiter">(</span>reusedCTM<span class="delimiter">)</span> = <a href="#1091113" title="(orig: CommonSubconditionElimination.this.CondTreeMaker)CommonSubconditionElimination.this.ReusedCondTreeMaker">ReusedCondTreeMaker</a><span class="delimiter">(</span>reusedCTM<span class="delimiter">)</span>
              <span class="keyword">case</span> _ =&gt;
            <span class="delimiter">}</span>

            <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;sharedPrefix: &quot;)" class="string">&quot;sharedPrefix: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1091024" title="List[CommonSubconditionElimination.this.Test]">sharedPrefix</a><span class="delimiter">)</span>
            <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;suffix: &quot;)" class="string">&quot;suffix: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#1091024" title="List[CommonSubconditionElimination.this.Test]">sharedPrefix</a><span class="delimiter">)</span>
            // if the shared prefix contains interesting conditions (!= TrueCond)
            // and the last of such interesting shared conditions reuses another treemaker's test
            // replace the whole sharedPrefix by a ReusingCondTreeMaker
            <span class="keyword">for</span> <span class="delimiter">(</span><a title="CommonSubconditionElimination.this.Test" id="1091138">lastShared</a> &lt;- <a href="#1091024" title="List[CommonSubconditionElimination.this.Test]">sharedPrefix</a>.<a href="../../../collection/immutable/List.scala.html#62716" title="=&gt; List[CommonSubconditionElimination.this.Test]">reverse</a>.<a href="../../../collection/immutable/List.scala.html#62714" title="(p: CommonSubconditionElimination.this.Test =&gt; Boolean)List[CommonSubconditionElimination.this.Test]">dropWhile</a><span class="delimiter">(</span><a href="#1091128" title="CommonSubconditionElimination.this.Test">_</a>.<a href="#1076087" title="=&gt; CommonSubconditionElimination.this.Cond">cond</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#1076148" title="CommonSubconditionElimination.this.TrueCond.type">TrueCond</a><span class="delimiter">)</span>.<a href="../../../Option.scala.html#62871" title="(f: CommonSubconditionElimination.this.Test =&gt; Option[List[CommonSubconditionElimination.this.TreeMaker]])Option[List[CommonSubconditionElimination.this.TreeMaker]]">headOption</a>;
                 <a title="CommonSubconditionElimination.this.Test" id="1091143">lastReused</a> &lt;- <a href="#1091138" title="CommonSubconditionElimination.this.Test">lastShared</a>.<a href="../../../Option.scala.html#62865" title="(f: CommonSubconditionElimination.this.Test =&gt; List[CommonSubconditionElimination.this.TreeMaker])Option[List[CommonSubconditionElimination.this.TreeMaker]]">reuses</a><span class="delimiter">)</span>
              <span class="keyword">yield</span> <a href="#1091860" title="(sharedPrefix: List[CommonSubconditionElimination.this.Test], toReused: CommonSubconditionElimination.this.TreeMaker =&gt; CommonSubconditionElimination.this.TreeMaker)CommonSubconditionElimination.this.ReusingCondTreeMaker">ReusingCondTreeMaker</a><span class="delimiter">(</span><a href="#1091024" title="List[CommonSubconditionElimination.this.Test]">sharedPrefix</a>, <a href="#1090788" title="CommonSubconditionElimination.this.TreeMaker =&gt; CommonSubconditionElimination.this.TreeMaker">reusedOrOrig</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#62685" title="(x: CommonSubconditionElimination.this.TreeMaker)List[CommonSubconditionElimination.this.TreeMaker]">::</a> <a href="#1091025" title="List[CommonSubconditionElimination.this.Test]">suffix</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: CommonSubconditionElimination.this.Test =&gt; CommonSubconditionElimination.this.TreeMaker)(implicit bf: scala.collection.generic.CanBuildFrom[List[CommonSubconditionElimination.this.Test],CommonSubconditionElimination.this.TreeMaker,List[CommonSubconditionElimination.this.TreeMaker]])List[CommonSubconditionElimination.this.TreeMaker]">map</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,CommonSubconditionElimination.this.TreeMaker,List[CommonSubconditionElimination.this.TreeMaker]]" class="delimiter">(</a><a href="#1091188" title="CommonSubconditionElimination.this.Test">_</a>.<a href="#1076088" title="=&gt; CommonSubconditionElimination.this.TreeMaker">treeMaker</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>

        <a href="#1091026" title="Option[List[CommonSubconditionElimination.this.TreeMaker]]">collapsedTreeMakers</a> <a href="../../../Option.scala.html#62859" title="(default: =&gt; List[CommonSubconditionElimination.this.TreeMaker])List[CommonSubconditionElimination.this.TreeMaker]">getOrElse</a> <a href="#1091021" title="List[CommonSubconditionElimination.this.Test]">tests</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: CommonSubconditionElimination.this.Test =&gt; CommonSubconditionElimination.this.TreeMaker)(implicit bf: scala.collection.generic.CanBuildFrom[List[CommonSubconditionElimination.this.Test],CommonSubconditionElimination.this.TreeMaker,List[CommonSubconditionElimination.this.TreeMaker]])List[CommonSubconditionElimination.this.TreeMaker]">map</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,CommonSubconditionElimination.this.TreeMaker,List[CommonSubconditionElimination.this.TreeMaker]]" class="delimiter">(</a><a href="#1091244" title="CommonSubconditionElimination.this.Test">_</a>.<a href="#1076088" title="=&gt; CommonSubconditionElimination.this.TreeMaker">treeMaker</a><span class="delimiter">)</span> // sharedPrefix need not be empty (but it only contains TrueCond-tests, which are dropped above)
      <span class="delimiter">}</span>
      <a href="#1090787" title="Boolean">okToCall</a> = <span title="Boolean(true)" class="keyword">true</span> // TODO: remove (debugging)

      // replace original treemakers that are reused (as determined when computing collapsed),
      // by ReusedCondTreeMakers
      <span class="keyword">val</span> <a title="List[List[CommonSubconditionElimination.this.TreeMaker]]" id="1090790">reusedMakers</a> = <a href="#1090789" title="List[List[CommonSubconditionElimination.this.TreeMaker]]">collapsed</a> <a href="../../../collection/immutable/List.scala.html#62694" title="(f: List[CommonSubconditionElimination.this.TreeMaker] =&gt; List[CommonSubconditionElimination.this.TreeMaker])List[List[CommonSubconditionElimination.this.TreeMaker]]">mapConserve</a> <span class="delimiter">(</span><a href="#1091308" title="List[CommonSubconditionElimination.this.TreeMaker]">_</a> <a href="../../../collection/immutable/List.scala.html#62694" title="(f: CommonSubconditionElimination.this.TreeMaker =&gt; CommonSubconditionElimination.this.TreeMaker)List[CommonSubconditionElimination.this.TreeMaker]">mapConserve</a> <a href="#1090788" title="CommonSubconditionElimination.this.TreeMaker =&gt; CommonSubconditionElimination.this.TreeMaker">reusedOrOrig</a><span class="delimiter">)</span>
      <a href="#1068820" title="(s: =&gt; String)Unit">patmatDebug</a><span class="delimiter">(</span><span title="String(&quot;after CSE:&quot;)" class="string">&quot;after CSE:&quot;</span><span class="delimiter">)</span>
      <a href="#1069161" title="(cases: List[List[CommonSubconditionElimination.this.TreeMaker]])Unit">showTreeMakers</a><span class="delimiter">(</span><a href="#1090790" title="List[List[CommonSubconditionElimination.this.TreeMaker]]">reusedMakers</a><span class="delimiter">)</span>
      <a href="#1090790" title="List[List[CommonSubconditionElimination.this.TreeMaker]]">reusedMakers</a>
    <span class="delimiter">}</span>

    <span class="keyword">object</span> <a title="CommonSubconditionElimination.this.ReusedCondTreeMaker.type" id="1069166">ReusedCondTreeMaker</a> <a href="#1069167" title="CommonSubconditionElimination.this.ReusedCondTreeMaker.type" class="delimiter">{</a>
      <span class="keyword">def</span> <a title="(orig: CommonSubconditionElimination.this.CondTreeMaker)CommonSubconditionElimination.this.ReusedCondTreeMaker" id="1091113">apply</a><span class="delimiter">(</span><a title="CommonSubconditionElimination.this.CondTreeMaker" id="1091114">orig</a>: <a href="#1069046" title="CommonSubconditionElimination.this.CondTreeMaker">CondTreeMaker</a><span class="delimiter">)</span> = <span title="CommonSubconditionElimination.this.ReusedCondTreeMaker" class="keyword">new</span> <a href="#1069168" title="CommonSubconditionElimination.this.ReusedCondTreeMaker">ReusedCondTreeMaker</a><span class="delimiter">(</span><a href="#1091114" title="CommonSubconditionElimination.this.CondTreeMaker">orig</a>.<a href="#1070669" title="=&gt; PatternMatching.this.global.Symbol">prevBinder</a>, <a href="#1091114" title="CommonSubconditionElimination.this.CondTreeMaker">orig</a>.<a href="#1070673" title="=&gt; PatternMatching.this.global.TermSymbol">nextBinder</a>, <a href="#1091114" title="CommonSubconditionElimination.this.CondTreeMaker">orig</a>.<a href="#1070671" title="=&gt; PatternMatching.this.global.Tree">cond</a>, <a href="#1091114" title="CommonSubconditionElimination.this.CondTreeMaker">orig</a>.<a href="#1070672" title="=&gt; PatternMatching.this.global.Tree">res</a>, <a href="#1091114" title="CommonSubconditionElimination.this.CondTreeMaker">orig</a>.<a href="#1070667" title="=&gt; PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">class</span> <a title="class ReusedCondTreeMaker extends CommonSubconditionElimination.this.TreeMaker" id="1069168">ReusedCondTreeMaker</a><a href="#1069168" title="CommonSubconditionElimination.this.ReusedCondTreeMaker" class="delimiter">(</a><a title="PatternMatching.this.global.Symbol" id="1091115">prevBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="1091116">nextBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Tree" id="1091117">cond</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Tree" id="1091118">res</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <span class="keyword">val</span> <a title="PatternMatching.this.global.Position" id="1091119">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#22953" title="PatternMatching.this.global.Position">Position</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069034" title="CommonSubconditionElimination.this.TreeMaker">TreeMaker</a> <span class="delimiter">{</span> <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._
      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="CommonSubconditionElimination.this.Substitution" id="1090996">localSubstitution</a>        = <a href="#1073002" title="(from: List[PatternMatching.this.global.Symbol], to: List[PatternMatching.this.global.Tree])CommonSubconditionElimination.this.Substitution">Substitution</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Symbol*)List[PatternMatching.this.global.Symbol]">List</a><span class="delimiter">(</span><a href="#1091115" title="PatternMatching.this.global.Symbol">prevBinder</a><span class="delimiter">)</span>, <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.gen.global.Tree*)List[PatternMatching.this.global.gen.global.Tree]">List</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1091116" title="=&gt; PatternMatching.this.global.Symbol">nextBinder</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.TermSymbol" id="1090998">storedCond</a>               = <a href="#1069013" title="(pos: PatternMatching.this.global.Position, tp: PatternMatching.this.global.Type, prefix: String)PatternMatching.this.global.TermSymbol">freshSym</a><span class="delimiter">(</span><a href="#1091119" title="=&gt; PatternMatching.this.global.Position">pos</a>, <a href="../../../reflect/internal/Definitions.scala.html#409369" title="=&gt; PatternMatching.this.global.ClassSymbol">BooleanClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a>, <span title="String(&quot;rc&quot;)" class="string">&quot;rc&quot;</span><span class="delimiter">)</span> <a href="../../../reflect/internal/Symbols.scala.html#411236" title="(mask: Long)PatternMatching.this.global.TermSymbol">setFlag</a> <span title="Long(4096L)">MUTABLE</span>
      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Tree]" id="1091000">treesToHoist</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> = <span class="delimiter">{</span>
        <a href="#1091116" title="=&gt; PatternMatching.this.global.Symbol">nextBinder</a> <a href="../../../reflect/internal/Symbols.scala.html#411236" title="(mask: Long)ReusedCondTreeMaker.this.nextBinder.type">setFlag</a> <span title="Long(4096L)">MUTABLE</span>
        <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.Symbol*)List[PatternMatching.this.global.Symbol]">List</a><span class="delimiter">(</span><a href="#1090997" title="=&gt; PatternMatching.this.global.TermSymbol">storedCond</a>, <a href="#1091116" title="=&gt; PatternMatching.this.global.Symbol">nextBinder</a><span class="delimiter">)</span> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.Symbol =&gt; PatternMatching.this.global.ValDef)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Symbol],PatternMatching.this.global.ValDef,List[PatternMatching.this.global.Tree]])List[PatternMatching.this.global.Tree]">map</a> <span class="delimiter">{</span> <a title="PatternMatching.this.global.Symbol" id="1091375">b</a> =&gt; <a href="../ast/TreeDSL.scala.html#624596" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.CODE.ValSymStart">VAL</a><span class="delimiter">(</span><a href="#1091375" title="PatternMatching.this.global.Symbol">b</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#663071" title="(rhs: PatternMatching.this.global.Tree)PatternMatching.this.global.ValDef">===</a> <a href="#1069196" title="=&gt; CommonSubconditionElimination.this.AbsCodegen">codegen</a>.<a href="#1071814" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Tree">mkZero</a><span class="delimiter">(</span><a href="#1091375" title="PatternMatching.this.global.Symbol">b</a>.<a href="../../../reflect/internal/Symbols.scala.html#411367" title="=&gt; PatternMatching.this.global.Type">info</a><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      // TODO: finer-grained duplication
      <span class="keyword">def</span> <a title="(next: PatternMatching.this.global.Tree)(casegen: CommonSubconditionElimination.this.Casegen)PatternMatching.this.global.Tree" id="1091001">chainBefore</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1091417">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="CommonSubconditionElimination.this.Casegen" id="1091418">casegen</a>: <a href="#1069016" title="CommonSubconditionElimination.this.Casegen">Casegen</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = // assert(codegen eq optimizedCodegen)
        <a href="../../../reflect/internal/Positions.scala.html#408315" title="(pos: PatternMatching.this.global.Position)(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">atPos</a><span class="delimiter">(</span><a href="#1091119" title="=&gt; PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1091418" title="CommonSubconditionElimination.this.Casegen">casegen</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="CommonSubconditionElimination.this.optimizedCodegen.OptimizedCasegen" class="delimiter">[</span>optimizedCodegen.<a href="#1091428" title="CommonSubconditionElimination.this.optimizedCodegen.OptimizedCasegen">OptimizedCasegen</a><span class="delimiter">]</span>.<a href="#1091440" title="(cond: PatternMatching.this.global.Tree, condSym: PatternMatching.this.global.Symbol, res: PatternMatching.this.global.Tree, nextBinder: PatternMatching.this.global.Symbol, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">flatMapCondStored</a><span class="delimiter">(</span><a href="#1091117" title="PatternMatching.this.global.Tree">cond</a>, <a href="#1090997" title="=&gt; PatternMatching.this.global.TermSymbol">storedCond</a>, <a href="#1091118" title="PatternMatching.this.global.Tree">res</a>, <a href="#1091116" title="=&gt; PatternMatching.this.global.Symbol">nextBinder</a>, <a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">substitution</a><span class="delimiter">(</span><a href="#1091417" title="PatternMatching.this.global.Tree">next</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/Trees.scala.html#408588" title="=&gt; PatternMatching.this.global.Tree">duplicate</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1091002">toString</a> = <span title="String(&quot;Memo&quot;)" class="string">&quot;Memo&quot;</span><a href="../../../Tuple5.scala.html#62980" title="(x$1: Any)String">+</a><span class="delimiter">(</span><a href="#1091116" title="=&gt; PatternMatching.this.global.Symbol">nextBinder</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; ReusedCondTreeMaker.this.nextBinder.NameType">name</a>, <a href="#1090997" title="=&gt; PatternMatching.this.global.TermSymbol">storedCond</a>.<a href="../../../reflect/internal/Symbols.scala.html#411609" title="=&gt; PatternMatching.this.global.TermName">name</a>, <a href="#1091117" title="PatternMatching.this.global.Tree">cond</a>, <a href="#1091118" title="PatternMatching.this.global.Tree">res</a>, <a href="#1069809" title="=&gt; CommonSubconditionElimination.this.Substitution">substitution</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    case <span class="keyword">class</span> <a title="class ReusingCondTreeMaker extends CommonSubconditionElimination.this.TreeMaker with Product with Serializable" id="1091860">ReusingCondTreeMaker</a><a href="../../../Product.scala.html#186" title="Product" class="delimiter">(</a><a title="List[CommonSubconditionElimination.this.Test]" id="1091166">sharedPrefix</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[CommonSubconditionElimination.this.Test]">List</a><span class="delimiter">[</span>Test<span class="delimiter">]</span>, <a title="CommonSubconditionElimination.this.TreeMaker =&gt; CommonSubconditionElimination.this.TreeMaker" id="1091167">toReused</a>: TreeMaker =&gt; TreeMaker<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069034" title="CommonSubconditionElimination.this.TreeMaker">TreeMaker</a> <span class="delimiter">{</span> <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._
      <span class="keyword">val</span> <a title="PatternMatching.this.global.Position" id="1091156">pos</a> = <a href="#1091166" title="=&gt; List[CommonSubconditionElimination.this.Test]">sharedPrefix</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86394" title="=&gt; CommonSubconditionElimination.this.Test">last</a>.<a href="#1076088" title="=&gt; CommonSubconditionElimination.this.TreeMaker">treeMaker</a>.<a href="#1069808" title="=&gt; PatternMatching.this.global.Position">pos</a>

      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="CommonSubconditionElimination.this.Substitution" id="1091159">localSubstitution</a> = <span class="delimiter">{</span>
        // replace binder of each dropped treemaker by corresponding binder bound by the most recent reused treemaker
        <span class="keyword">var</span> <a title="CommonSubconditionElimination.this.ReusedCondTreeMaker" id="1091475">mostRecentReusedMaker</a>: <a href="#1069168" title="CommonSubconditionElimination.this.ReusedCondTreeMaker">ReusedCondTreeMaker</a> = <span title="Null(null)" class="keyword">null</span>
        <span class="keyword">def</span> <a title="(droppedBinder: PatternMatching.this.global.Symbol)List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)]" id="1091476">mapToStored</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1091482">droppedBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span> = <span title="List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1091475" title="CommonSubconditionElimination.this.ReusedCondTreeMaker">mostRecentReusedMaker</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a> <span class="keyword">else</span> <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: (PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)*)List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)]">List</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Symbol, _2: PatternMatching.this.global.gen.global.Tree)(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)" class="delimiter">(</a><a href="#1091482" title="PatternMatching.this.global.Symbol">droppedBinder</a>, <a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1091475" title="CommonSubconditionElimination.this.ReusedCondTreeMaker">mostRecentReusedMaker</a>.<a href="#1091116" title="=&gt; PatternMatching.this.global.Symbol">nextBinder</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a href="#3370084" title="(x: (List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.gen.global.Tree]))(List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.gen.global.Tree])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="List[PatternMatching.this.global.Symbol]" id="1091478">from</a>, <a href="../../../Tuple2.scala.html#60637" title="List[PatternMatching.this.global.gen.global.Tree]" id="1091479">to</a><span class="delimiter">)</span> = <a href="#1091166" title="=&gt; List[CommonSubconditionElimination.this.Test]">sharedPrefix</a>.<a href="../../../collection/TraversableLike.scala.html#58068" title="(f: CommonSubconditionElimination.this.Test =&gt; scala.collection.GenTraversableOnce[(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)])(implicit bf: scala.collection.generic.CanBuildFrom[List[CommonSubconditionElimination.this.Test],(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree),List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)]])List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)]">flatMap</a> <a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree),List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)]]" class="delimiter">{</a> <a title="CommonSubconditionElimination.this.Test" id="1091514">dropped</a> =&gt;
          <a href="#1091514" title="CommonSubconditionElimination.this.Test">dropped</a>.<a href="#1076021" title="=&gt; Option[CommonSubconditionElimination.this.Test]">reuses</a>.<a href="../../../Option.scala.html#62865" title="(f: CommonSubconditionElimination.this.Test =&gt; CommonSubconditionElimination.this.TreeMaker)Option[CommonSubconditionElimination.this.TreeMaker]">map</a><span class="delimiter">(</span><a title="CommonSubconditionElimination.this.Test" id="1091518">test</a> =&gt; <a href="../../../Function1.scala.html#58642" title="(v1: CommonSubconditionElimination.this.TreeMaker)CommonSubconditionElimination.this.TreeMaker">toReused</a><span class="delimiter">(</span><a href="#1091518" title="CommonSubconditionElimination.this.Test">test</a>.<a href="#1076088" title="=&gt; CommonSubconditionElimination.this.TreeMaker">treeMaker</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../Option.scala.html#62884" title="(f: CommonSubconditionElimination.this.TreeMaker =&gt; Unit)Unit">foreach</a> <a href="#1091525" title="CommonSubconditionElimination.this.TreeMaker" class="delimiter">{</a>
            <span class="keyword">case</span> <a href="#3370064" title="Unit" id="3370066">reusedMaker</a>: ReusedCondTreeMaker =&gt;
              <a href="#1091475" title="CommonSubconditionElimination.this.ReusedCondTreeMaker">mostRecentReusedMaker</a> = reusedMaker
            <span class="keyword">case</span> _ =&gt;
          <span class="delimiter">}</span>

          // TODO: have super-trait for retrieving the variable that's operated on by a tree maker
          // and thus assumed in scope, either because it binds it or because it refers to it
          <a href="#1091514" title="CommonSubconditionElimination.this.Test">dropped</a>.<a href="#1076088" title="=&gt; CommonSubconditionElimination.this.TreeMaker">treeMaker</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a href="#3370073" title="List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)]" id="3370075">dropped</a>: FunTreeMaker =&gt;
              <a href="#1091476" title="(droppedBinder: PatternMatching.this.global.Symbol)List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)]">mapToStored</a><a href="#3370077" title="(x: List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)])List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)]" class="delimiter">(</a>dropped.<a href="#1070666" title="=&gt; PatternMatching.this.global.Symbol">nextBinder</a><span class="delimiter">)</span>
            <span class="keyword">case</span> _ =&gt; <a href="#3370077" title="(x: List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)])List[(PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)]">Nil</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>.<a href="../../../collection/generic/GenericTraversableTemplate.scala.html#58476" title="(implicit asPair: ((PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree)) =&gt; (PatternMatching.this.global.Symbol, PatternMatching.this.global.gen.global.Tree))(List[PatternMatching.this.global.Symbol], List[PatternMatching.this.global.gen.global.Tree])">unzip</a>
        <span class="keyword">val</span> <a title="CommonSubconditionElimination.this.Substitution" id="1091480">rerouteToReusedBinders</a> = <a href="#1073002" title="(from: List[PatternMatching.this.global.Symbol], to: List[PatternMatching.this.global.Tree])CommonSubconditionElimination.this.Substitution">Substitution</a><span class="delimiter">(</span><a href="#1091478" title="List[PatternMatching.this.global.Symbol]">from</a>, <a href="#1091479" title="List[PatternMatching.this.global.gen.global.Tree]">to</a><span class="delimiter">)</span>

        <span class="keyword">val</span> <a title="List[CommonSubconditionElimination.this.Substitution]" id="1091481">collapsedDroppedSubst</a> = <a href="#1091166" title="=&gt; List[CommonSubconditionElimination.this.Test]">sharedPrefix</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: CommonSubconditionElimination.this.Test =&gt; CommonSubconditionElimination.this.Substitution)(implicit bf: scala.collection.generic.CanBuildFrom[List[CommonSubconditionElimination.this.Test],CommonSubconditionElimination.this.Substitution,List[CommonSubconditionElimination.this.Substitution]])List[CommonSubconditionElimination.this.Substitution]">map</a> <span class="delimiter">(</span><a title="CommonSubconditionElimination.this.Test" id="1091599">t</a> =&gt; <span class="delimiter">(</span><a href="../../../Function1.scala.html#58642" title="(v1: CommonSubconditionElimination.this.TreeMaker)CommonSubconditionElimination.this.TreeMaker">toReused</a><span class="delimiter">(</span><a href="#1091599" title="CommonSubconditionElimination.this.Test">t</a>.<a href="#1076088" title="=&gt; CommonSubconditionElimination.this.TreeMaker">treeMaker</a><span class="delimiter">)</span>.<a href="#1069809" title="=&gt; CommonSubconditionElimination.this.Substitution">substitution</a><span class="delimiter">)</span><span class="delimiter">)</span>

        <a href="#1091481" title="List[CommonSubconditionElimination.this.Substitution]">collapsedDroppedSubst</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86382" title="(z: CommonSubconditionElimination.this.Substitution)(f: (CommonSubconditionElimination.this.Substitution, CommonSubconditionElimination.this.Substitution) =&gt; CommonSubconditionElimination.this.Substitution)CommonSubconditionElimination.this.Substitution">foldLeft</a><span class="delimiter">(</span><a href="#1091480" title="CommonSubconditionElimination.this.Substitution">rerouteToReusedBinders</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1091643" title="CommonSubconditionElimination.this.Substitution">_</a> <a href="#1069978" title="(other: CommonSubconditionElimination.this.Substitution)CommonSubconditionElimination.this.Substitution">&gt;&gt;</a> <a href="#1091644" title="CommonSubconditionElimination.this.Substitution">_</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="CommonSubconditionElimination.this.ReusedCondTreeMaker" id="1091161">lastReusedTreeMaker</a> = <a href="#1091166" title="=&gt; List[CommonSubconditionElimination.this.Test]">sharedPrefix</a>.<a href="../../../collection/immutable/List.scala.html#62716" title="=&gt; List[CommonSubconditionElimination.this.Test]">reverse</a>.<a href="../../../collection/TraversableLike.scala.html#58068" title="(f: CommonSubconditionElimination.this.Test =&gt; scala.collection.GenTraversableOnce[CommonSubconditionElimination.this.TreeMaker])(implicit bf: scala.collection.generic.CanBuildFrom[List[CommonSubconditionElimination.this.Test],CommonSubconditionElimination.this.TreeMaker,List[CommonSubconditionElimination.this.TreeMaker]])List[CommonSubconditionElimination.this.TreeMaker]">flatMap</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,CommonSubconditionElimination.this.TreeMaker,List[CommonSubconditionElimination.this.TreeMaker]]" class="delimiter">(</a><a title="CommonSubconditionElimination.this.Test" id="1091665">tm</a> =&gt; <a href="#1091665" title="CommonSubconditionElimination.this.Test">tm</a>.<a href="#1076021" title="=&gt; Option[CommonSubconditionElimination.this.Test]">reuses</a> <a href="../../../Option.scala.html#97396" title="(xo: Option[CommonSubconditionElimination.this.TreeMaker])Iterable[CommonSubconditionElimination.this.TreeMaker]">map</a> <span class="delimiter">(</span><a title="CommonSubconditionElimination.this.Test" id="1091669">test</a> =&gt; <a href="../../../Function1.scala.html#58642" title="(v1: CommonSubconditionElimination.this.TreeMaker)CommonSubconditionElimination.this.TreeMaker">toReused</a><span class="delimiter">(</span><a href="#1091669" title="CommonSubconditionElimination.this.Test">test</a>.<a href="#1076088" title="=&gt; CommonSubconditionElimination.this.TreeMaker">treeMaker</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../collection/TraversableOnce.scala.html#58193" title="(pf: PartialFunction[CommonSubconditionElimination.this.TreeMaker,CommonSubconditionElimination.this.ReusedCondTreeMaker])Option[CommonSubconditionElimination.this.ReusedCondTreeMaker]">collectFirst</a><a href="../../../Option.scala.html#97396" title="(xo: Option[CommonSubconditionElimination.this.ReusedCondTreeMaker])Iterable[CommonSubconditionElimination.this.ReusedCondTreeMaker]" id="1091715" class="delimiter">{</a><span class="keyword">case</span> <a href="#3370088" title="B1" id="3370102">x</a>: ReusedCondTreeMaker =&gt; <a href="#3370094" title="(x: B1)B1">x</a><span class="delimiter">}</span>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; CommonSubconditionElimination.this.ReusedCondTreeMaker">head</a>

      <span class="keyword">def</span> <a title="(next: PatternMatching.this.global.Tree)(casegen: CommonSubconditionElimination.this.Casegen)PatternMatching.this.global.Tree" id="1091162">chainBefore</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1091777">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="CommonSubconditionElimination.this.Casegen" id="1091778">casegen</a>: <a href="#1069016" title="CommonSubconditionElimination.this.Casegen">Casegen</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
        // TODO: finer-grained duplication -- MUST duplicate though, or we'll get VerifyErrors since sharing trees confuses lambdalift,
        // and in its confusion it emits illegal casts (diagnosed by Grzegorz: checkcast T ; invokevirtual S.m, where T not a subtype of S)
        <a href="#1091778" title="CommonSubconditionElimination.this.Casegen">casegen</a>.<a href="#1073531" title="(c: PatternMatching.this.global.Tree, then: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">ifThenElseZero</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1091160" title="=&gt; CommonSubconditionElimination.this.ReusedCondTreeMaker">lastReusedTreeMaker</a>.<a href="#1090997" title="=&gt; PatternMatching.this.global.TermSymbol">storedCond</a><span class="delimiter">)</span>, <a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">substitution</a><span class="delimiter">(</span><a href="#1091777" title="PatternMatching.this.global.Tree">next</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/Trees.scala.html#408588" title="=&gt; PatternMatching.this.global.Tree">duplicate</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="1091163">toString</a> = <span title="String(&quot;R&quot;)" class="string">&quot;R&quot;</span><a href="../../../Tuple2.scala.html#62849" title="(x$1: Any)String">+</a><span class="delimiter">(</span><a href="#1091160" title="=&gt; CommonSubconditionElimination.this.ReusedCondTreeMaker">lastReusedTreeMaker</a>.<a href="#1090997" title="=&gt; PatternMatching.this.global.TermSymbol">storedCond</a>.<a href="../../../reflect/internal/Symbols.scala.html#411609" title="=&gt; PatternMatching.this.global.TermName">name</a>, <a href="#1069809" title="=&gt; CommonSubconditionElimination.this.Substitution">substitution</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  //// DCE
  <span class="keyword">trait</span> <a title="trait DeadCodeElimination extends Object with PatternMatching.this.TreeMakers" id="621399">DeadCodeElimination</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621388" title="PatternMatching.this.TreeMakers">TreeMakers</a> <span class="delimiter">{</span> self: CodegenCore =&gt;
    // TODO: non-trivial dead-code elimination
    // e.g., the following match should compile to a simple instanceof:
    //   case class Ident(name: String)
    //   for (Ident(name) &lt;- ts) println(name)
    <span class="keyword">def</span> <a title="(prevBinder: PatternMatching.this.global.Symbol, cases: List[List[DeadCodeElimination.this.TreeMaker]], pt: PatternMatching.this.global.Type)List[List[DeadCodeElimination.this.TreeMaker]]" id="1069181">doDCE</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1091864">prevBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="List[List[DeadCodeElimination.this.TreeMaker]]" id="1091865">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[DeadCodeElimination.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="PatternMatching.this.global.Type" id="1091866">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[DeadCodeElimination.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      // do minimal DCE
      <a href="#1091865" title="List[List[DeadCodeElimination.this.TreeMaker]]">cases</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  //// SWITCHES -- TODO: operate on Tests rather than TreeMakers
  <span class="keyword">trait</span> <a title="trait SwitchEmission extends Object with PatternMatching.this.TreeMakers with PatternMatching.this.OptimizedMatchMonadInterface" id="621400">SwitchEmission</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621388" title="PatternMatching.this.TreeMakers">TreeMakers</a> <span class="keyword">with</span> <a href="#621401" title="PatternMatching.this.OptimizedMatchMonadInterface">OptimizedMatchMonadInterface</a> <span class="delimiter">{</span> self: CodegenCore =&gt;
    <span class="keyword">import</span> <a href="../ast/Trees.scala.html#537807" title="PatternMatching.this.global.treeInfo.type">treeInfo</a>.isGuardedCase

    <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SwitchMaker extends Object" id="1069185">SwitchMaker</a> <a href="#1069185" title="SwitchEmission.this.SwitchMaker" class="delimiter">{</a>
      <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SwitchableTreeMakerExtractor extends Object" id="1091873">SwitchableTreeMakerExtractor</a> <a href="#1091873" title="SwitchMaker.this.SwitchableTreeMakerExtractor" class="delimiter">{</a> <span class="keyword">def</span> <a title="(x: SwitchEmission.this.TreeMaker)Option[PatternMatching.this.global.Tree]" id="1091899">unapply</a><span class="delimiter">(</span><a title="SwitchEmission.this.TreeMaker" id="1091901">x</a>: <a href="#1069034" title="SwitchEmission.this.TreeMaker">TreeMaker</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> <span class="delimiter">}</span>
      <span class="keyword">val</span> <a title="=&gt; SwitchMaker.this.SwitchableTreeMakerExtractor" id="1091874">SwitchableTreeMaker</a>: <a href="#1091873" title="SwitchMaker.this.SwitchableTreeMakerExtractor">SwitchableTreeMakerExtractor</a>

      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1091875">alternativesSupported</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

      // when collapsing guarded switch cases we may sometimes need to jump to the default case
      // however, that's not supported in exception handlers, so when we can't jump when we need it, don't emit a switch
      // TODO: make more fine-grained, as we don't always need to jump
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1091876">canJump</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a>

      <span class="keyword">def</span> <a title="=&gt; Boolean" id="1091877">unchecked</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a>


      <span class="keyword">def</span> <a title="(x: PatternMatching.this.global.CaseDef)Boolean" id="1091878">isDefault</a><span class="delimiter">(</span><a title="PatternMatching.this.global.CaseDef" id="1091902">x</a>: <a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a>
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Symbol" id="1091879">defaultSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Tree" id="1091880">defaultBody</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>
      <span class="keyword">def</span> <a title="(scrutSym: PatternMatching.this.global.Symbol, guard: PatternMatching.this.global.Tree, body: PatternMatching.this.global.Tree)PatternMatching.this.global.CaseDef" id="1091881">defaultCase</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1091906">scrutSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a> = <a href="#1091879" title="=&gt; PatternMatching.this.global.Symbol">defaultSym</a>, <a title="PatternMatching.this.global.Tree" id="1091907">guard</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="../../../reflect/internal/Trees.scala.html#407946" title="PatternMatching.this.global.EmptyTree.type">EmptyTree</a>, <a title="PatternMatching.this.global.Tree" id="1091908">body</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="#1091880" title="=&gt; PatternMatching.this.global.Tree">defaultBody</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a>

      <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T](xs: List[Option[T]])Option[List[T]]" id="1091882">sequence</a><span class="delimiter">[</span><a title="" id="1091884">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[Option[T]]" id="1091909">xs</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[Option[T]]">List</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[List[T]]">Option</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
        <span title="Option[List[T]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1091909" title="List[Option[T]]">xs</a> <a href="../../../collection/LinearSeqOptimized.scala.html#86379" title="(p: Option[T] =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#1091917" title="Option[T]">_</a>.<a href="../../../Option.scala.html#62856" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../Option.scala.html#1585" title="None.type">None</a> <span class="keyword">else</span> <a href="../../../Option.scala.html#63128" title="(x: List[T])Some[List[T]]">Some</a><span class="delimiter">(</span><a href="#1091909" title="List[Option[T]]">xs</a>.<a href="../../../collection/generic/GenericTraversableTemplate.scala.html#58488" title="(implicit asTraversable: Option[T] =&gt; scala.collection.GenTraversableOnce[T])List[T]">flatten</a><span class="delimiter">)</span>

      <span class="keyword">object</span> <a title="SwitchMaker.this.GuardAndBodyTreeMakers.type" id="1091885">GuardAndBodyTreeMakers</a> <a href="#1091886" title="SwitchMaker.this.GuardAndBodyTreeMakers.type" class="delimiter">{</a>
          <span class="keyword">def</span> <a title="(tms: List[SwitchEmission.this.TreeMaker])Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]" id="1091940">unapply</a><span class="delimiter">(</span><a title="List[SwitchEmission.this.TreeMaker]" id="1091942">tms</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[SwitchEmission.this.TreeMaker]">List</a><span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
            <a href="#1091942" title="List[SwitchEmission.this.TreeMaker]">tms</a> <span class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#206583" title="SwitchEmission.this.TreeMaker" id="1091945">btm</a>@BodyTreeMaker<a href="#1091945" title="Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]" id="3370157" class="delimiter">(</a><a href="#1071266" title="PatternMatching.this.global.Tree" id="1091946">body</a>, <a href="#1071267" title="PatternMatching.this.global.Type" id="3370155">_</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#3370152" title="Boolean" id="3370154">::</a> <a href="../../../collection/immutable/List.scala.html#206584" title="List[SwitchEmission.this.TreeMaker]" id="3370169">Nil</a> =&gt; <a href="../../../Option.scala.html#63128" title="(x: (PatternMatching.this.global.EmptyTree.type, PatternMatching.this.global.Tree))Some[(PatternMatching.this.global.EmptyTree.type, PatternMatching.this.global.Tree)]">Some</a><a href="#3370173" title="(x: Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)])Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]" class="delimiter">(</a><a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.EmptyTree.type, _2: PatternMatching.this.global.Tree)(PatternMatching.this.global.EmptyTree.type, PatternMatching.this.global.Tree)" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#407946" title="PatternMatching.this.global.EmptyTree.type">EmptyTree</a>, btm.<a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">substitution</a><span class="delimiter">(</span><a href="#1091946" title="PatternMatching.this.global.Tree">body</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#206583" title="SwitchEmission.this.TreeMaker" id="1091958">gtm</a>@GuardTreeMaker<a href="#1091958" title="Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]" id="3370162" class="delimiter">(</a><a href="#1071247" title="PatternMatching.this.global.Tree" id="1091959">guard</a><span class="delimiter">)</span><span class="delimiter">)</span> :: <span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#206583" title="SwitchEmission.this.TreeMaker" id="1091962">btm</a>@BodyTreeMaker<a href="#1091962" title="Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]" id="3370167" class="delimiter">(</a><a href="#1071266" title="PatternMatching.this.global.Tree" id="1091963">body</a>, <a href="#1071267" title="PatternMatching.this.global.Type" id="3370165">_</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#206584" title="List[SwitchEmission.this.TreeMaker]" id="3370164">::</a> <a href="../../../collection/immutable/List.scala.html#206584" title="List[SwitchEmission.this.TreeMaker]" id="3370170">Nil</a> =&gt; <a href="../../../Option.scala.html#63128" title="(x: (PatternMatching.this.global.Tree, PatternMatching.this.global.Tree))Some[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]">Some</a><a href="#3370173" title="(x: Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)])Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]" class="delimiter">(</a><a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Tree, _2: PatternMatching.this.global.Tree)(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)" class="delimiter">(</a>gtm.<a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">substitution</a><span class="delimiter">(</span><a href="#1091959" title="PatternMatching.this.global.Tree">guard</a><span class="delimiter">)</span>, btm.<a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">substitution</a><span class="delimiter">(</span><a href="#1091963" title="PatternMatching.this.global.Tree">body</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">case</span> _ =&gt; <a href="#3370173" title="(x: Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)])Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]">None</a>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span class="keyword">private</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="1091887">defaultLabel</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a> =  <a href="#1069014" title="(name: String)PatternMatching.this.global.MethodSymbol">newSynthCaseLabel</a><span class="delimiter">(</span><span title="String(&quot;default&quot;)" class="string">&quot;default&quot;</span><span class="delimiter">)</span>

      /** Collapse guarded cases that switch on the same constant (the last case may be unguarded).
       *
       * Cases with patterns A and B switch on the same constant iff for all values x that match A also match B and vice versa.
       * (This roughly corresponds to equality on trees modulo alpha renaming and reordering of alternatives.)
       *
       * The rewrite only applies if some of the cases are guarded (this must be checked before invoking this method).
       *
       * The rewrite goes through the switch top-down and merges each case with the subsequent cases it is implied by
       * (i.e. it matches if they match, not taking guards into account)
       *
       * If there are no unreachable cases, all cases can be uniquely assigned to a partition of such 'overlapping' cases,
       * save for the default case (thus we jump to it rather than copying it several times).
       * (The cases in a partition are implied by the principal element of the partition.)
       *
       * The overlapping cases are merged into one case with their guards pushed into the body as follows
       * (with P the principal element of the overlapping patterns Pi):
       *
       *    `{case Pi if(G_i) =&gt; B_i }*` is rewritten to `case P =&gt; {if(G_i) B_i}*`
       *
       * The rewrite fails (and returns Nil) when:
       *   (1) there is a subsequence of overlapping cases that has an unguarded case in the middle;
       *       only the last case of each subsequence of overlapping cases may be unguarded (this is implied by unreachability)
       *
       *   (2) there are overlapping cases that differ (tested by `caseImpliedBy`)
       *       cases with patterns A and B are overlapping if for SOME value x, A matches x implies B matches y OR vice versa  &lt;-- note the difference with case equality defined above
       *       for example `case 'a' | 'b' =&gt;` and `case 'b' =&gt;` are different and overlapping (overlapping and equality disregard guards)
       *
       * The second component of the returned tuple indicates whether we'll need to emit a labeldef to jump to the default case.
       */
      <span class="keyword">private</span> <span class="keyword">def</span> <a title="(cases: List[PatternMatching.this.global.CaseDef])(List[PatternMatching.this.global.CaseDef], Boolean)" id="1091889">collapseGuardedCases</a><span class="delimiter">(</span><a title="List[PatternMatching.this.global.CaseDef]" id="1091973">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Tuple2.scala.html#783" title="(List[PatternMatching.this.global.CaseDef], Boolean)" class="delimiter">(</a>List<span class="delimiter">[</span>CaseDef<span class="delimiter">]</span>, Boolean<span class="delimiter">)</span> = <span class="delimiter">{</span>
        // requires(same.forall(caseEquals(same.head)))
        // requires(same.nonEmpty, same)
        <span class="keyword">def</span> <a title="(same: List[PatternMatching.this.global.CaseDef], isDefault: Boolean)PatternMatching.this.global.CaseDef" id="1091974">collapse</a><span class="delimiter">(</span><a title="List[PatternMatching.this.global.CaseDef]" id="1091979">same</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span>, <a title="Boolean" id="1091980">isDefault</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1091981">commonPattern</a> = <a href="#1091979" title="List[PatternMatching.this.global.CaseDef]">same</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; PatternMatching.this.global.CaseDef">head</a>.<a href="../../../reflect/internal/Trees.scala.html#410180" title="=&gt; PatternMatching.this.global.Tree">pat</a>
          // jump to default case (either the user-supplied one or the synthetic one)
          // unless we're collapsing the default case: then we re-use the same body as the synthetic catchall (throwing a matcherror, rethrowing the exception)
          <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1091982">jumpToDefault</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> =
            <span title="PatternMatching.this.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#1091980" title="Boolean">isDefault</a> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1091876" title="=&gt; Boolean">canJump</a><span class="delimiter">)</span> <a href="#1091880" title="=&gt; PatternMatching.this.global.Tree">defaultBody</a>
            <span class="keyword">else</span> <a href="../../../reflect/internal/Trees.scala.html#413581" title="(fun: PatternMatching.this.global.Tree, args: List[PatternMatching.this.global.Tree])PatternMatching.this.global.Apply">Apply</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#408127" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.Ident">Ident</a><span class="delimiter">(</span><a href="#1091887" title="=&gt; PatternMatching.this.global.Symbol">defaultLabel</a><span class="delimiter">)</span>, <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>

          <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1091983">guardedBody</a> = <a href="#1091979" title="List[PatternMatching.this.global.CaseDef]">same</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86385" title="(z: PatternMatching.this.global.Tree)(f: (PatternMatching.this.global.CaseDef, PatternMatching.this.global.Tree) =&gt; PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">foldRight</a><span class="delimiter">(</span><a href="#1091982" title="PatternMatching.this.global.Tree">jumpToDefault</a><span class="delimiter">)</span><a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.CaseDef, _2: PatternMatching.this.global.Tree)(PatternMatching.this.global.CaseDef, PatternMatching.this.global.Tree)" class="delimiter">{</a>
            // the last case may be un-guarded (we know it's the last one since fold's accum == jumpToDefault)
            // --&gt; replace jumpToDefault by the un-guarded case's body
            <span class="keyword">case</span> <span class="delimiter">(</span>CaseDef<a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.CaseDef" id="3370186" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410180" title="PatternMatching.this.global.Tree" id="3370188">_</a>, <a href="../../../reflect/internal/Trees.scala.html#410182" title="PatternMatching.this.global.Tree" id="3370194">EmptyTree</a>, <a href="../../../reflect/internal/Trees.scala.html#410184" title="PatternMatching.this.global.Tree" id="1092048">b</a><span class="delimiter">)</span>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="3370195">`jumpToDefault`</a><span class="delimiter">)</span>     =&gt; <a href="#3370197" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">b</a>
            <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.CaseDef" id="1092051">cd</a>@CaseDef<span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#410180" title="PatternMatching.this.global.Tree" id="3370193">_</a>, <a href="../../../reflect/internal/Trees.scala.html#410182" title="PatternMatching.this.global.Tree" id="1092057">g</a>, <a href="../../../reflect/internal/Trees.scala.html#410184" title="PatternMatching.this.global.Tree" id="1092058">b</a><span class="delimiter">)</span>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="1092059">els</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="../../../reflect/internal/TreeInfo.scala.html#479239" title="(cdef: PatternMatching.this.global.treeInfo.global.CaseDef)Boolean">isGuardedCase</a><span class="delimiter">(</span><a href="#1092051" title="PatternMatching.this.global.CaseDef">cd</a><span class="delimiter">)</span> =&gt; <a href="../../../reflect/internal/Trees.scala.html#453562" title="(cond: PatternMatching.this.global.Tree, thenp: PatternMatching.this.global.Tree, elsep: PatternMatching.this.global.Tree)PatternMatching.this.global.If">If</a><a href="#3370197" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="#1092057" title="PatternMatching.this.global.Tree">g</a>, <a href="#1092058" title="PatternMatching.this.global.Tree">b</a>, <a href="#1092059" title="PatternMatching.this.global.Tree">els</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>

          // if the cases that we're going to collapse bind variables,
          // must replace them by the single binder introduced by the collapsed case
          <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Symbol]" id="1091984">binders</a> = <a href="#1091979" title="List[PatternMatching.this.global.CaseDef]">same</a>.<a href="../../../collection/TraversableLike.scala.html#58075" title="(pf: PartialFunction[PatternMatching.this.global.CaseDef,PatternMatching.this.global.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.CaseDef],PatternMatching.this.global.Symbol,List[PatternMatching.this.global.Symbol]])List[PatternMatching.this.global.Symbol]">collect</a><a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[PatternMatching.this.global.CaseDef,PatternMatching.this.global.Symbol] with Serializable" id="1092101" class="delimiter">{</a><span class="keyword">case</span> CaseDef<span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#410180" title="PatternMatching.this.global.Tree" id="1092109">x</a>@Bind<a href="#1092109" title="B1" id="3370227" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410157" title="PatternMatching.this.global.Name" id="3370224">_</a>, <a href="../../../reflect/internal/Trees.scala.html#410159" title="PatternMatching.this.global.Tree" id="3370225">_</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#410182" title="PatternMatching.this.global.Tree" id="3370222">_</a>, <a href="../../../reflect/internal/Trees.scala.html#410184" title="PatternMatching.this.global.Tree" id="3370223">_</a><span class="delimiter">)</span> <span class="keyword">if</span> x.<a href="../../../reflect/internal/Trees.scala.html#409939" title="=&gt; PatternMatching.this.global.Symbol">symbol</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a> =&gt; x.<a href="#3370216" title="(x: B1)B1">symbol</a><span class="delimiter">}</span>
          <span class="keyword">val</span> <a href="#3370244" title="(x: (PatternMatching.this.global.Tree, PatternMatching.this.global.Tree))(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="1091986">pat</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="1091987">guardedBodySubst</a><span class="delimiter">)</span> =
            <a href="#3370242" title="(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)" class="keyword">if</a> <span class="delimiter">(</span><a href="#1091984" title="List[PatternMatching.this.global.Symbol]">binders</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Tree, _2: PatternMatching.this.global.Tree)(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)" class="delimiter">(</a><a href="#1091981" title="PatternMatching.this.global.Tree">commonPattern</a>, <a href="#1091983" title="PatternMatching.this.global.Tree">guardedBody</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <span class="delimiter">{</span>
              // create a single fresh binder to subsume the old binders (and their types)
              // TODO: I don't think the binder's types can actually be different (due to checks in caseEquals)
              // if they do somehow manage to diverge, the lub might not be precise enough and we could get a type error
              // TODO: reuse name exactly if there's only one binder in binders
              <span class="keyword">val</span> <a title="PatternMatching.this.global.TermSymbol" id="1092176">binder</a> = <a href="#1069013" title="(pos: PatternMatching.this.global.Position, tp: PatternMatching.this.global.Type, prefix: String)PatternMatching.this.global.TermSymbol">freshSym</a><span class="delimiter">(</span><a href="#1091984" title="List[PatternMatching.this.global.Symbol]">binders</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; PatternMatching.this.global.Symbol">head</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#409602" title="=&gt; PatternMatching.this.global.Position">pos</a>, <a href="../../../reflect/internal/Types.scala.html#407605" title="(ts: List[PatternMatching.this.global.Type])PatternMatching.this.global.Type">lub</a><span class="delimiter">(</span><a href="#1091984" title="List[PatternMatching.this.global.Symbol]">binders</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.Symbol =&gt; PatternMatching.this.global.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Symbol],PatternMatching.this.global.Type,List[PatternMatching.this.global.Type]])List[PatternMatching.this.global.Type]">map</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,PatternMatching.this.global.Type,List[PatternMatching.this.global.Type]]" class="delimiter">(</a><a href="#1092201" title="PatternMatching.this.global.Symbol">_</a>.<a href="../../../reflect/internal/Symbols.scala.html#411365" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#1091984" title="List[PatternMatching.this.global.Symbol]">binders</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; PatternMatching.this.global.Symbol">head</a>.<a href="../../../reflect/internal/Symbols.scala.html#411087" title="=&gt; PatternMatching.this.global.Symbol#NameType">name</a>.<span title="()String">toString</span><span class="delimiter">)</span>

              // the patterns in same are equal (according to caseEquals)
              // we can thus safely pick the first one arbitrarily, provided we correct binding
              <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1092177">origPatWithoutBind</a> = <a href="#1091981" title="PatternMatching.this.global.Tree">commonPattern</a> <span class="keyword">match</span> <span class="delimiter">{</span>
                <span class="keyword">case</span> Bind<a href="#3370233" title="PatternMatching.this.global.Tree" id="3370235" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410157" title="PatternMatching.this.global.Name" id="1092238">b</a>, <a href="../../../reflect/internal/Trees.scala.html#410159" title="PatternMatching.this.global.Tree" id="1092239">orig</a><span class="delimiter">)</span> =&gt; <a href="#3370237" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">orig</a>
                <span class="keyword">case</span> o =&gt; <a href="#3370237" title="(x: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">o</a>
              <span class="delimiter">}</span>
              // need to replace `defaultSym` as well -- it's used in `defaultBody` (see `jumpToDefault` above)
              <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1092178">unifiedBody</a> = <a href="#1091983" title="PatternMatching.this.global.Tree">guardedBody</a>.<a href="../../../reflect/internal/Trees.scala.html#408555" title="(from: List[PatternMatching.this.global.Symbol], to: List[PatternMatching.this.global.Symbol])PatternMatching.this.global.Tree">substituteSymbols</a><span class="delimiter">(</span><a href="#1091879" title="=&gt; PatternMatching.this.global.Symbol">defaultSym</a> <a href="../../../collection/immutable/List.scala.html#62685" title="(x: PatternMatching.this.global.Symbol)List[PatternMatching.this.global.Symbol]">::</a> <a href="#1091984" title="List[PatternMatching.this.global.Symbol]">binders</a>, <a href="#1092176" title="PatternMatching.this.global.TermSymbol">binder</a> <a href="../../../collection/immutable/List.scala.html#62685" title="(x: PatternMatching.this.global.TermSymbol)List[PatternMatching.this.global.TermSymbol]">::</a> <a href="#1091984" title="List[PatternMatching.this.global.Symbol]">binders</a>.<a href="../../../collection/TraversableLike.scala.html#58063" title="(f: PatternMatching.this.global.Symbol =&gt; PatternMatching.this.global.TermSymbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.Symbol],PatternMatching.this.global.TermSymbol,List[PatternMatching.this.global.TermSymbol]])List[PatternMatching.this.global.TermSymbol]">map</a><a href="../../../collection/immutable/List.scala.html#62442" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,PatternMatching.this.global.TermSymbol,List[PatternMatching.this.global.TermSymbol]]" class="delimiter">(</a><a title="PatternMatching.this.global.Symbol" id="1092262">_</a> =&gt; <a href="#1092176" title="PatternMatching.this.global.TermSymbol">binder</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Bind, _2: PatternMatching.this.global.Tree)(PatternMatching.this.global.Bind, PatternMatching.this.global.Tree)" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#408115" title="(sym: PatternMatching.this.global.Symbol, body: PatternMatching.this.global.Tree)PatternMatching.this.global.Bind">Bind</a><span class="delimiter">(</span><a href="#1092176" title="PatternMatching.this.global.TermSymbol">binder</a>, <a href="#1092177" title="PatternMatching.this.global.Tree">origPatWithoutBind</a><span class="delimiter">)</span>, <a href="#1092178" title="PatternMatching.this.global.Tree">unifiedBody</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>

          <a href="../../../reflect/internal/Positions.scala.html#408315" title="(pos: PatternMatching.this.global.Position)(tree: PatternMatching.this.global.CaseDef)PatternMatching.this.global.CaseDef">atPos</a><span class="delimiter">(</span><a href="#1091981" title="PatternMatching.this.global.Tree">commonPattern</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#453147" title="(pat: PatternMatching.this.global.Tree, guard: PatternMatching.this.global.Tree, body: PatternMatching.this.global.Tree)PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">(</span><a href="#1091986" title="PatternMatching.this.global.Tree">pat</a>, <a href="../../../reflect/internal/Trees.scala.html#407946" title="PatternMatching.this.global.EmptyTree.type">EmptyTree</a>, <a href="#1091987" title="PatternMatching.this.global.Tree">guardedBodySubst</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        // requires cases.exists(isGuardedCase) (otherwise the rewrite is pointless)
        <span class="keyword">var</span> <a title="List[PatternMatching.this.global.CaseDef]" id="1091975">remainingCases</a> = <a href="#1091973" title="List[PatternMatching.this.global.CaseDef]">cases</a>
        <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[PatternMatching.this.global.CaseDef]" id="1091976">collapsed</a>      = scala.collection.mutable.<a href="../../../collection/mutable/ListBuffer.scala.html#13348" title="scala.collection.mutable.ListBuffer.type">ListBuffer</a>.<a href="../../../collection/generic/GenericCompanion.scala.html#59930" title="[A]=&gt; scala.collection.mutable.ListBuffer[A]">empty</a><span title="scala.collection.mutable.ListBuffer[PatternMatching.this.global.CaseDef]" class="delimiter">[</span><a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">]</span>

        // when some of collapsed cases (except for the default case itself) did not include an un-guarded case
        // we'll need to emit a labeldef for the default case
        <span class="keyword">var</span> <a title="Boolean" id="1091977">needDefault</a>  = <span title="Boolean(false)" class="keyword">false</span>

        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#1091975" title="List[PatternMatching.this.global.CaseDef]">remainingCases</a>.<a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <a href="#1091978" title="()Unit" class="delimiter">{</a>
          <span class="keyword">val</span> <a title="PatternMatching.this.global.CaseDef" id="1092345">currCase</a>              = <a href="#1091975" title="List[PatternMatching.this.global.CaseDef]">remainingCases</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; PatternMatching.this.global.CaseDef">head</a>
          <span class="keyword">val</span> <a title="Boolean" id="1092346">currIsDefault</a>         = <a href="#1091878" title="(x: PatternMatching.this.global.CaseDef)Boolean">isDefault</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#453147" title="(pat: PatternMatching.this.global.Tree, guard: PatternMatching.this.global.Tree, body: PatternMatching.this.global.Tree)PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">(</span><a href="#1092345" title="PatternMatching.this.global.CaseDef">currCase</a>.<a href="../../../reflect/internal/Trees.scala.html#410180" title="=&gt; PatternMatching.this.global.Tree">pat</a>, <a href="../../../reflect/internal/Trees.scala.html#407946" title="PatternMatching.this.global.EmptyTree.type">EmptyTree</a>, <a href="../../../reflect/internal/Trees.scala.html#407946" title="PatternMatching.this.global.EmptyTree.type">EmptyTree</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a href="#3370250" title="(x: (List[PatternMatching.this.global.CaseDef], List[PatternMatching.this.global.CaseDef]))(List[PatternMatching.this.global.CaseDef], List[PatternMatching.this.global.CaseDef])" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="List[PatternMatching.this.global.CaseDef]" id="1092348">impliesCurr</a>, <a href="../../../Tuple2.scala.html#60637" title="List[PatternMatching.this.global.CaseDef]" id="1092349">others</a><span class="delimiter">)</span> =
            // the default case is implied by all cases, no need to partition (and remainingCases better all be default cases as well)
            <a href="#3370248" title="(List[PatternMatching.this.global.CaseDef], List[PatternMatching.this.global.CaseDef])" class="keyword">if</a> <span class="delimiter">(</span><a href="#1092346" title="Boolean">currIsDefault</a><span class="delimiter">)</span> <a href="../../../Tuple2.scala.html#62849" title="(_1: List[PatternMatching.this.global.CaseDef], _2: scala.collection.immutable.Nil.type)(List[PatternMatching.this.global.CaseDef], scala.collection.immutable.Nil.type)" class="delimiter">(</a><a href="#1091975" title="List[PatternMatching.this.global.CaseDef]">remainingCases</a>.<a href="../../../collection/TraversableLike.scala.html#58104" title="=&gt; List[PatternMatching.this.global.CaseDef]">tail</a>, <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <a href="#1091975" title="List[PatternMatching.this.global.CaseDef]">remainingCases</a>.<a href="../../../collection/TraversableLike.scala.html#58104" title="=&gt; List[PatternMatching.this.global.CaseDef]">tail</a> <a href="../../../collection/TraversableLike.scala.html#58080" title="(p: PatternMatching.this.global.CaseDef =&gt; Boolean)(List[PatternMatching.this.global.CaseDef], List[PatternMatching.this.global.CaseDef])">partition</a> <span class="delimiter">(</span><a href="#1091892" title="(x: PatternMatching.this.global.CaseDef)(y: PatternMatching.this.global.CaseDef)Boolean">caseImplies</a><a href="#1092377" title="PatternMatching.this.global.CaseDef" class="delimiter">(</a><a href="#1092345" title="PatternMatching.this.global.CaseDef">currCase</a><span class="delimiter">)</span><span class="delimiter">)</span>

          <span class="keyword">val</span> <a title="Boolean" id="1092350">unguardedComesLastOrAbsent</a> =
            <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="../../../reflect/internal/TreeInfo.scala.html#479239" title="(cdef: PatternMatching.this.global.treeInfo.global.CaseDef)Boolean">isGuardedCase</a><span class="delimiter">(</span><a href="#1092345" title="PatternMatching.this.global.CaseDef">currCase</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1092348" title="List[PatternMatching.this.global.CaseDef]">impliesCurr</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <span class="delimiter">{</span> <span class="keyword">val</span> <a title="Int" id="1092389">LastImpliesCurr</a> = <a href="#1092348" title="List[PatternMatching.this.global.CaseDef]">impliesCurr</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86373" title="=&gt; Int">length</a> <a href="../../../Int.scala.html#57161" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span>
            <a href="#1092348" title="List[PatternMatching.this.global.CaseDef]">impliesCurr</a>.<a href="../../../collection/GenSeqLike.scala.html#58688" title="(p: PatternMatching.this.global.CaseDef =&gt; Boolean)Int">indexWhere</a><span title="Boolean" class="delimiter">(</span><a title="PatternMatching.this.global.CaseDef" id="1092404">oc</a> =&gt; <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="../../../reflect/internal/TreeInfo.scala.html#479239" title="(cdef: PatternMatching.this.global.treeInfo.global.CaseDef)Boolean">isGuardedCase</a><span class="delimiter">(</span><a href="#1092404" title="PatternMatching.this.global.CaseDef">oc</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
              // if all cases are guarded we will have to jump to the default case in the final else
              // (except if we're collapsing the default case itself)
              <span class="keyword">case</span> <a href="../../../Int.scala.html#57097" title="Boolean" id="3370259">-</a><span class="int">1</span> =&gt;
                <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1092346" title="Boolean">currIsDefault</a><span class="delimiter">)</span> <a href="#1091977" title="Boolean">needDefault</a> = <span title="Boolean(true)" class="keyword">true</span>
                <span title="Boolean(true)" class="keyword">true</span>

              // last case is not guarded, no need to jump to the default here
              // note: must come after case -1 =&gt; (since LastImpliesCurr may be -1)
              <span class="keyword">case</span> <a href="../../../Int.scala.html#57097" title="Boolean" id="3370260">LastImpliesCurr</a> =&gt; <a href="#3370262" title="(x: Boolean)Boolean" class="keyword">true</a>

              <span class="keyword">case</span> _ =&gt; <a href="#3370262" title="(x: Boolean)Boolean" class="keyword">false</a>
            <span class="delimiter">}</span><span class="delimiter">}</span>

          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1092350" title="Boolean">unguardedComesLastOrAbsent</a> /*(1)*/ <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1092348" title="List[PatternMatching.this.global.CaseDef]">impliesCurr</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86378" title="(p: PatternMatching.this.global.CaseDef =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#1091890" title="(x: PatternMatching.this.global.CaseDef)(y: PatternMatching.this.global.CaseDef)Boolean">caseEquals</a><a href="#1092415" title="PatternMatching.this.global.CaseDef" class="delimiter">(</a><a href="#1092345" title="PatternMatching.this.global.CaseDef">currCase</a><span class="delimiter">)</span><span class="delimiter">)</span> /*(2)*/<span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="#1091976" title="scala.collection.mutable.ListBuffer[PatternMatching.this.global.CaseDef]">collapsed</a> <a href="../../../collection/mutable/ListBuffer.scala.html#79765" title="(x: PatternMatching.this.global.CaseDef)collapsed.type">+=</a> <span class="delimiter">(</span>
              <span title="PatternMatching.this.global.CaseDef" class="keyword">if</span> <span class="delimiter">(</span><a href="#1092348" title="List[PatternMatching.this.global.CaseDef]">impliesCurr</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="../../../reflect/internal/TreeInfo.scala.html#479239" title="(cdef: PatternMatching.this.global.treeInfo.global.CaseDef)Boolean">isGuardedCase</a><span class="delimiter">(</span><a href="#1092345" title="PatternMatching.this.global.CaseDef">currCase</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#1092345" title="PatternMatching.this.global.CaseDef">currCase</a>
              <span class="keyword">else</span> <a href="#1091974" title="(same: List[PatternMatching.this.global.CaseDef], isDefault: Boolean)PatternMatching.this.global.CaseDef">collapse</a><span class="delimiter">(</span><a href="#1092345" title="PatternMatching.this.global.CaseDef">currCase</a> <a href="../../../collection/immutable/List.scala.html#62685" title="(x: PatternMatching.this.global.CaseDef)List[PatternMatching.this.global.CaseDef]">::</a> <a href="#1092348" title="List[PatternMatching.this.global.CaseDef]">impliesCurr</a>, <a href="#1092346" title="Boolean">currIsDefault</a><span class="delimiter">)</span>
            <span class="delimiter">)</span>

            <a href="#1091975" title="List[PatternMatching.this.global.CaseDef]">remainingCases</a> = <a href="#1092349" title="List[PatternMatching.this.global.CaseDef]">others</a>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span> // fail
            <a href="#1091976" title="scala.collection.mutable.ListBuffer[PatternMatching.this.global.CaseDef]">collapsed</a>.<a href="../../../collection/mutable/ListBuffer.scala.html#79768" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
            <a href="#1091975" title="List[PatternMatching.this.global.CaseDef]">remainingCases</a> = <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        <a href="../../../Tuple2.scala.html#62849" title="(_1: List[PatternMatching.this.global.CaseDef], _2: Boolean)(List[PatternMatching.this.global.CaseDef], Boolean)" class="delimiter">(</a><a href="#1091976" title="scala.collection.mutable.ListBuffer[PatternMatching.this.global.CaseDef]">collapsed</a>.<a href="../../../collection/mutable/ListBuffer.scala.html#79773" title="=&gt; List[PatternMatching.this.global.CaseDef]">toList</a>, <a href="#1091977" title="Boolean">needDefault</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="keyword">private</span> <span class="keyword">def</span> <a title="(x: PatternMatching.this.global.CaseDef)(y: PatternMatching.this.global.CaseDef)Boolean" id="1091890">caseEquals</a><span class="delimiter">(</span><a title="PatternMatching.this.global.CaseDef" id="1092410">x</a>: <a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="PatternMatching.this.global.CaseDef" id="1092411">y</a>: <a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">)</span> = <a href="#1091891" title="(x: PatternMatching.this.global.Tree)(y: PatternMatching.this.global.Tree)Boolean">patternEquals</a><span class="delimiter">(</span><a href="#1092410" title="PatternMatching.this.global.CaseDef">x</a>.<a href="../../../reflect/internal/Trees.scala.html#410180" title="=&gt; PatternMatching.this.global.Tree">pat</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1092411" title="PatternMatching.this.global.CaseDef">y</a>.<a href="../../../reflect/internal/Trees.scala.html#410180" title="=&gt; PatternMatching.this.global.Tree">pat</a><span class="delimiter">)</span>
      <span class="keyword">private</span> <span class="keyword">def</span> <a title="(x: PatternMatching.this.global.Tree)(y: PatternMatching.this.global.Tree)Boolean" id="1091891">patternEquals</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1092412">x</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1092413">y</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Tree, _2: PatternMatching.this.global.Tree)(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)" class="delimiter">(</a><a href="#1092412" title="PatternMatching.this.global.Tree">x</a>, <a href="#1092413" title="PatternMatching.this.global.Tree">y</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span class="delimiter">(</span>Alternative<a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="3370278" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410172" title="List[PatternMatching.this.global.Tree]" id="1092446">xs</a><span class="delimiter">)</span>, Alternative<a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="3370280" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410172" title="List[PatternMatching.this.global.Tree]" id="1092448">ys</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
          <a href="#1092446" title="List[PatternMatching.this.global.Tree]">xs</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86378" title="(p: PatternMatching.this.global.Tree =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1092455">x</a> =&gt; <a href="#1092448" title="List[PatternMatching.this.global.Tree]">ys</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86379" title="(p: PatternMatching.this.global.Tree =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#1091891" title="(x: PatternMatching.this.global.Tree)(y: PatternMatching.this.global.Tree)Boolean">patternEquals</a><a href="#1092462" title="PatternMatching.this.global.Tree" class="delimiter">(</a><a href="#1092455" title="PatternMatching.this.global.Tree">x</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#3370341" title="(x: Boolean)Boolean">&amp;&amp;</a>
          <a href="#1092448" title="List[PatternMatching.this.global.Tree]">ys</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86378" title="(p: PatternMatching.this.global.Tree =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1092469">y</a> =&gt; <a href="#1092446" title="List[PatternMatching.this.global.Tree]">xs</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86379" title="(p: PatternMatching.this.global.Tree =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#1091891" title="(x: PatternMatching.this.global.Tree)(y: PatternMatching.this.global.Tree)Boolean">patternEquals</a><a href="#1092476" title="PatternMatching.this.global.Tree" class="delimiter">(</a><a href="#1092469" title="PatternMatching.this.global.Tree">y</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span class="delimiter">(</span>Alternative<a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="3370284" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410172" title="List[PatternMatching.this.global.Tree]" id="1092480">pats</a><span class="delimiter">)</span>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="3370282">_</a><span class="delimiter">)</span> =&gt; <a href="#1092480" title="List[PatternMatching.this.global.Tree]">pats</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86378" title="(p: PatternMatching.this.global.Tree =&gt; Boolean)Boolean">forall</a><a href="#3370341" title="(x: Boolean)Boolean" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1092487">p</a> =&gt; <a href="#1091891" title="(x: PatternMatching.this.global.Tree)(y: PatternMatching.this.global.Tree)Boolean">patternEquals</a><span class="delimiter">(</span><a href="#1092487" title="PatternMatching.this.global.Tree">p</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1092413" title="PatternMatching.this.global.Tree">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="3370285">_</a>, Alternative<a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="3370288" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410172" title="List[PatternMatching.this.global.Tree]" id="1092491">pats</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#1092491" title="List[PatternMatching.this.global.Tree]">pats</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86378" title="(p: PatternMatching.this.global.Tree =&gt; Boolean)Boolean">forall</a><a href="#3370341" title="(x: Boolean)Boolean" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1092498">q</a> =&gt; <a href="#1091891" title="(x: PatternMatching.this.global.Tree)(y: PatternMatching.this.global.Tree)Boolean">patternEquals</a><span class="delimiter">(</span><a href="#1092412" title="PatternMatching.this.global.Tree">x</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1092498" title="PatternMatching.this.global.Tree">q</a><span class="delimiter">)</span><span class="delimiter">)</span>
        // regular switch
        <span class="keyword">case</span> <span class="delimiter">(</span>Literal<a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="3370293" class="delimiter">(</a>Constant<a href="../../../reflect/internal/Trees.scala.html#409973" title="PatternMatching.this.global.Constant" id="3370291" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#409760" title="Any" id="1092502">cx</a><span class="delimiter">)</span><span class="delimiter">)</span>, Literal<a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="3370296" class="delimiter">(</a>Constant<a href="../../../reflect/internal/Trees.scala.html#409973" title="PatternMatching.this.global.Constant" id="3370294" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#409760" title="Any" id="1092504">cy</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#1092502" title="Any">cx</a> <a href="#3370341" title="(x: Boolean)Boolean">==</a> <a href="#1092504" title="Any">cy</a>
        <span class="keyword">case</span> <span class="delimiter">(</span>Ident<a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="3370301" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3370335">WILDCARD</a><span class="delimiter">)</span>, Ident<a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="3370306" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3370336">WILDCARD</a><span class="delimiter">)</span><span class="delimiter">)</span>     =&gt; <a href="#3370341" title="(x: Boolean)Boolean" class="keyword">true</a>
        // type-switch for catch
        <span class="keyword">case</span> <span class="delimiter">(</span>Bind<a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="3370314" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410157" title="PatternMatching.this.global.Name" id="3370311">_</a>, Typed<a href="../../../reflect/internal/Trees.scala.html#410159" title="PatternMatching.this.global.Tree" id="3370317" class="delimiter">(</a>Ident<a href="../../../reflect/internal/Trees.scala.html#410055" title="PatternMatching.this.global.Tree" id="3370320" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3370337">WILDCARD</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#410057" title="PatternMatching.this.global.Tree" id="1092524">tpX</a><span class="delimiter">)</span><span class="delimiter">)</span>, Bind<a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="3370326" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410157" title="PatternMatching.this.global.Name" id="3370323">_</a>, Typed<a href="../../../reflect/internal/Trees.scala.html#410159" title="PatternMatching.this.global.Tree" id="3370329" class="delimiter">(</a>Ident<a href="../../../reflect/internal/Trees.scala.html#410055" title="PatternMatching.this.global.Tree" id="3370332" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3370338">WILDCARD</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#410057" title="PatternMatching.this.global.Tree" id="1092534">tpY</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#1092524" title="PatternMatching.this.global.Tree">tpX</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a> <a href="#3370341" title="(x: Boolean)Boolean">=:=</a> <a href="#1092534" title="PatternMatching.this.global.Tree">tpY</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>
        <span class="keyword">case</span> _ =&gt; <a href="#3370341" title="(x: Boolean)Boolean" class="keyword">false</a>
      <span class="delimiter">}</span>

      // if y matches then x matches for sure (thus, if x comes before y, y is unreachable)
      <span class="keyword">private</span> <span class="keyword">def</span> <a title="(x: PatternMatching.this.global.CaseDef)(y: PatternMatching.this.global.CaseDef)Boolean" id="1091892">caseImplies</a><span class="delimiter">(</span><a title="PatternMatching.this.global.CaseDef" id="1092372">x</a>: <a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="PatternMatching.this.global.CaseDef" id="1092373">y</a>: <a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">)</span> = <a href="#1091893" title="(x: PatternMatching.this.global.Tree)(y: PatternMatching.this.global.Tree)Boolean">patternImplies</a><span class="delimiter">(</span><a href="#1092372" title="PatternMatching.this.global.CaseDef">x</a>.<a href="../../../reflect/internal/Trees.scala.html#410180" title="=&gt; PatternMatching.this.global.Tree">pat</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1092373" title="PatternMatching.this.global.CaseDef">y</a>.<a href="../../../reflect/internal/Trees.scala.html#410180" title="=&gt; PatternMatching.this.global.Tree">pat</a><span class="delimiter">)</span>
      <span class="keyword">private</span> <span class="keyword">def</span> <a title="(x: PatternMatching.this.global.Tree)(y: PatternMatching.this.global.Tree)Boolean" id="1091893">patternImplies</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1092374">x</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1092375">y</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Tree, _2: PatternMatching.this.global.Tree)(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)" class="delimiter">(</a><a href="#1092374" title="PatternMatching.this.global.Tree">x</a>, <a href="#1092375" title="PatternMatching.this.global.Tree">y</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
        // since alternatives are flattened, must treat them as separate cases
        <span class="keyword">case</span> <span class="delimiter">(</span>Alternative<a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="3370367" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410172" title="List[PatternMatching.this.global.Tree]" id="1092548">pats</a><span class="delimiter">)</span>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="3370365">_</a><span class="delimiter">)</span> =&gt; <a href="#1092548" title="List[PatternMatching.this.global.Tree]">pats</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86379" title="(p: PatternMatching.this.global.Tree =&gt; Boolean)Boolean">exists</a><a href="#3370418" title="(x: Boolean)Boolean" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1092555">p</a> =&gt; <a href="#1091893" title="(x: PatternMatching.this.global.Tree)(y: PatternMatching.this.global.Tree)Boolean">patternImplies</a><span class="delimiter">(</span><a href="#1092555" title="PatternMatching.this.global.Tree">p</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1092375" title="PatternMatching.this.global.Tree">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="3370368">_</a>, Alternative<a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="3370371" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410172" title="List[PatternMatching.this.global.Tree]" id="1092559">pats</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#1092559" title="List[PatternMatching.this.global.Tree]">pats</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86379" title="(p: PatternMatching.this.global.Tree =&gt; Boolean)Boolean">exists</a><a href="#3370418" title="(x: Boolean)Boolean" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1092566">q</a> =&gt; <a href="#1091893" title="(x: PatternMatching.this.global.Tree)(y: PatternMatching.this.global.Tree)Boolean">patternImplies</a><span class="delimiter">(</span><a href="#1092374" title="PatternMatching.this.global.Tree">x</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1092566" title="PatternMatching.this.global.Tree">q</a><span class="delimiter">)</span><span class="delimiter">)</span>
        // regular switch
        <span class="keyword">case</span> <span class="delimiter">(</span>Literal<a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="3370376" class="delimiter">(</a>Constant<a href="../../../reflect/internal/Trees.scala.html#409973" title="PatternMatching.this.global.Constant" id="3370374" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#409760" title="Any" id="1092570">cx</a><span class="delimiter">)</span><span class="delimiter">)</span>, Literal<a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="3370379" class="delimiter">(</a>Constant<a href="../../../reflect/internal/Trees.scala.html#409973" title="PatternMatching.this.global.Constant" id="3370377" class="delimiter">(</a><a href="../../../reflect/internal/Constants.scala.html#409760" title="Any" id="1092572">cy</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#1092570" title="Any">cx</a> <a href="#3370418" title="(x: Boolean)Boolean">==</a> <a href="#1092572" title="Any">cy</a>
        <span class="keyword">case</span> <span class="delimiter">(</span>Ident<a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="3370384" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3370413">WILDCARD</a><span class="delimiter">)</span>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="3370381">_</a><span class="delimiter">)</span>                       =&gt; <a href="#3370418" title="(x: Boolean)Boolean" class="keyword">true</a>
        // type-switch for catch
        <span class="keyword">case</span> <span class="delimiter">(</span>Bind<a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="3370392" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410157" title="PatternMatching.this.global.Name" id="3370389">_</a>, Typed<a href="../../../reflect/internal/Trees.scala.html#410159" title="PatternMatching.this.global.Tree" id="3370395" class="delimiter">(</a>Ident<a href="../../../reflect/internal/Trees.scala.html#410055" title="PatternMatching.this.global.Tree" id="3370398" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3370414">WILDCARD</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#410057" title="PatternMatching.this.global.Tree" id="1092589">tpX</a><span class="delimiter">)</span><span class="delimiter">)</span>,
              Bind<a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="3370404" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410157" title="PatternMatching.this.global.Name" id="3370401">_</a>, Typed<a href="../../../reflect/internal/Trees.scala.html#410159" title="PatternMatching.this.global.Tree" id="3370407" class="delimiter">(</a>Ident<a href="../../../reflect/internal/Trees.scala.html#410055" title="PatternMatching.this.global.Tree" id="3370410" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3370415">WILDCARD</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#410057" title="PatternMatching.this.global.Tree" id="1092599">tpY</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>     =&gt; <a href="#1069019" title="(tp: PatternMatching.this.global.Type, tpImplied: PatternMatching.this.global.Type)Boolean">instanceOfTpImplies</a><a href="#3370418" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#1092599" title="PatternMatching.this.global.Tree">tpY</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a>, <a href="#1092589" title="PatternMatching.this.global.Tree">tpX</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt; <a href="#3370418" title="(x: Boolean)Boolean" class="keyword">false</a>
      <span class="delimiter">}</span>

      <span class="keyword">private</span> <span class="keyword">def</span> <a title="(cs: List[PatternMatching.this.global.CaseDef])Boolean" id="1091894">noGuards</a><span class="delimiter">(</span><a title="List[PatternMatching.this.global.CaseDef]" id="1092600">cs</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1092600" title="List[PatternMatching.this.global.CaseDef]">cs</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86379" title="(p: PatternMatching.this.global.CaseDef =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="../../../reflect/internal/TreeInfo.scala.html#479239" title="(cdef: PatternMatching.this.global.treeInfo.global.CaseDef)Boolean">isGuardedCase</a><span class="delimiter">)</span>

      // must do this before removing guards from cases and collapsing (SI-6011, SI-6048)
      <span class="keyword">private</span> <span class="keyword">def</span> <a title="(cs: List[PatternMatching.this.global.CaseDef])Option[PatternMatching.this.global.CaseDef]" id="1091895">unreachableCase</a><span class="delimiter">(</span><a title="List[PatternMatching.this.global.CaseDef]" id="1092608">cs</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.CaseDef]">Option</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span> = <span class="delimiter">{</span>
        <span class="keyword">var</span> <a title="List[PatternMatching.this.global.CaseDef]" id="1092609">cases</a> = <a href="#1092608" title="List[PatternMatching.this.global.CaseDef]">cs</a>
        <span class="keyword">var</span> <a title="Option[PatternMatching.this.global.CaseDef]" id="1092610">unreachable</a>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.CaseDef]">Option</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span> = <a href="../../../Option.scala.html#1585" title="None.type">None</a>

        <span title="Unit" class="keyword">while</span> <span class="delimiter">(</span><a href="#1092609" title="List[PatternMatching.this.global.CaseDef]">cases</a>.<a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1092610" title="Option[PatternMatching.this.global.CaseDef]">unreachable</a>.<a href="../../../Option.scala.html#62856" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#1092611" title="()Unit" class="delimiter">{</a>
          <span class="keyword">val</span> <a title="PatternMatching.this.global.CaseDef" id="1092613">currCase</a> = <a href="#1092609" title="List[PatternMatching.this.global.CaseDef]">cases</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; PatternMatching.this.global.CaseDef">head</a>
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1091878" title="(x: PatternMatching.this.global.CaseDef)Boolean">isDefault</a><span class="delimiter">(</span><a href="#1092613" title="PatternMatching.this.global.CaseDef">currCase</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#1092609" title="List[PatternMatching.this.global.CaseDef]">cases</a>.<a href="../../../collection/TraversableLike.scala.html#58104" title="=&gt; List[PatternMatching.this.global.CaseDef]">tail</a>.<a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> // subsumed by the `else if` that follows, but faster
            <a href="#1092610" title="Option[PatternMatching.this.global.CaseDef]">unreachable</a> = <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.CaseDef)Some[PatternMatching.this.global.CaseDef]">Some</a><span class="delimiter">(</span><a href="#1092609" title="List[PatternMatching.this.global.CaseDef]">cases</a>.<a href="../../../collection/TraversableLike.scala.html#58104" title="=&gt; List[PatternMatching.this.global.CaseDef]">tail</a>.<a href="../../../collection/IterableLike.scala.html#58577" title="=&gt; PatternMatching.this.global.CaseDef">head</a><span class="delimiter">)</span>
          <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="../../../reflect/internal/TreeInfo.scala.html#479239" title="(cdef: PatternMatching.this.global.treeInfo.global.CaseDef)Boolean">isGuardedCase</a><span class="delimiter">(</span><a href="#1092613" title="PatternMatching.this.global.CaseDef">currCase</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="#1092613" title="PatternMatching.this.global.CaseDef">currCase</a>.<a href="../../../reflect/internal/Trees.scala.html#410182" title="=&gt; PatternMatching.this.global.Tree">guard</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a> <a href="../../../reflect/internal/Types.scala.html#408485" title="(that: PatternMatching.this.global.Type)Boolean">=:=</a> <a href="../../../reflect/internal/Types.scala.html#441752" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.UniqueConstantType">ConstantType</a><span class="delimiter">(</span><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#1092610" title="Option[PatternMatching.this.global.CaseDef]">unreachable</a> = <a href="#1092609" title="List[PatternMatching.this.global.CaseDef]">cases</a>.<a href="../../../collection/TraversableLike.scala.html#58104" title="=&gt; List[PatternMatching.this.global.CaseDef]">tail</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86381" title="(p: PatternMatching.this.global.CaseDef =&gt; Boolean)Option[PatternMatching.this.global.CaseDef]">find</a><span class="delimiter">(</span><a href="#1091892" title="(x: PatternMatching.this.global.CaseDef)(y: PatternMatching.this.global.CaseDef)Boolean">caseImplies</a><a href="#1092635" title="PatternMatching.this.global.CaseDef" class="delimiter">(</a><a href="#1092613" title="PatternMatching.this.global.CaseDef">currCase</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">else</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1092613" title="PatternMatching.this.global.CaseDef">currCase</a>.<a href="../../../reflect/internal/Trees.scala.html#410182" title="=&gt; PatternMatching.this.global.Tree">guard</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a> <a href="../../../reflect/internal/Types.scala.html#408485" title="(that: PatternMatching.this.global.Type)Boolean">=:=</a> <a href="../../../reflect/internal/Types.scala.html#441752" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.UniqueConstantType">ConstantType</a><span class="delimiter">(</span><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#1092610" title="Option[PatternMatching.this.global.CaseDef]">unreachable</a> = <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.CaseDef)Some[PatternMatching.this.global.CaseDef]">Some</a><span class="delimiter">(</span><a href="#1092613" title="PatternMatching.this.global.CaseDef">currCase</a><span class="delimiter">)</span>

          <a href="#1092609" title="List[PatternMatching.this.global.CaseDef]">cases</a> = <a href="#1092609" title="List[PatternMatching.this.global.CaseDef]">cases</a>.<a href="../../../collection/TraversableLike.scala.html#58104" title="=&gt; List[PatternMatching.this.global.CaseDef]">tail</a>
        <span class="delimiter">}</span>

        <a href="#1092610" title="Option[PatternMatching.this.global.CaseDef]">unreachable</a>
      <span class="delimiter">}</span>

      // empty list ==&gt; failure
      <span class="keyword">def</span> <a title="(cases: List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])], pt: PatternMatching.this.global.Type)List[PatternMatching.this.global.CaseDef]" id="1091896">apply</a><span class="delimiter">(</span><a title="List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])]" id="1092644">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])]">List</a><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>, <a title="PatternMatching.this.global.Type" id="1092645">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[PatternMatching.this.global.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span> =
        // generate if-then-else for 1 case switch (avoids verify error... can't imagine a one-case switch being faster than if-then-else anyway)
        <span title="List[PatternMatching.this.global.CaseDef]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1092644" title="List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])]">cases</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <a href="#1092644" title="List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])]">cases</a>.<a href="../../../collection/TraversableLike.scala.html#58104" title="=&gt; List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])]">tail</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="List[Option[PatternMatching.this.global.CaseDef]]" id="1092647">caseDefs</a> = <a href="#1092644" title="List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])]">cases</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: ((PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])) =&gt; Option[PatternMatching.this.global.CaseDef])(implicit bf: scala.collection.generic.CanBuildFrom[List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])],Option[PatternMatching.this.global.CaseDef],List[Option[PatternMatching.this.global.CaseDef]]])List[Option[PatternMatching.this.global.CaseDef]]">map</a> <a href="#1092666" title="(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Symbol" id="1092669">scrutSym</a>, <a href="../../../Tuple2.scala.html#60637" title="List[SwitchEmission.this.TreeMaker]" id="1092670">makers</a><span class="delimiter">)</span> =&gt;
            <a href="#3370489" title="(x: Option[PatternMatching.this.global.CaseDef])Option[PatternMatching.this.global.CaseDef]">makers</a> <span class="keyword">match</span> <span class="delimiter">{</span>
              // default case
              <span class="keyword">case</span> <a href="#1091940" title="Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]" id="3370474">GuardAndBodyTreeMakers</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="1092672">guard</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="1092673">body</a><span class="delimiter">)</span> =&gt;
                <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.CaseDef)Some[PatternMatching.this.global.CaseDef]">Some</a><a href="#3370470" title="(x: Option[PatternMatching.this.global.CaseDef])Option[PatternMatching.this.global.CaseDef]" class="delimiter">(</a><a href="#1091881" title="(scrutSym: PatternMatching.this.global.Symbol, guard: PatternMatching.this.global.Tree, body: PatternMatching.this.global.Tree)PatternMatching.this.global.CaseDef">defaultCase</a><span class="delimiter">(</span><a href="#1092669" title="PatternMatching.this.global.Symbol">scrutSym</a>, <a href="#1092672" title="PatternMatching.this.global.Tree">guard</a>, <a href="#1092673" title="PatternMatching.this.global.Tree">body</a><span class="delimiter">)</span><span class="delimiter">)</span>
              // constant (or typetest for typeSwitch)
              <span class="keyword">case</span> <a href="#1091899" title="Option[PatternMatching.this.global.Tree]" id="3370477">SwitchableTreeMaker</a><a href="../../../collection/immutable/List.scala.html#206583" title="SwitchEmission.this.TreeMaker" id="3370455" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1092680">pattern</a><span class="delimiter">)</span> <a href="#3370453" title="Boolean" id="3370457">::</a> <a href="#1091940" title="Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]" id="3370476">GuardAndBodyTreeMakers</a><a href="../../../collection/immutable/List.scala.html#206584" title="List[SwitchEmission.this.TreeMaker]" id="3370456" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="1092682">guard</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="1092683">body</a><span class="delimiter">)</span> =&gt;
                <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.CaseDef)Some[PatternMatching.this.global.CaseDef]">Some</a><a href="#3370470" title="(x: Option[PatternMatching.this.global.CaseDef])Option[PatternMatching.this.global.CaseDef]" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#453147" title="(pat: PatternMatching.this.global.Tree, guard: PatternMatching.this.global.Tree, body: PatternMatching.this.global.Tree)PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">(</span><a href="#1092680" title="PatternMatching.this.global.Tree">pattern</a>, <a href="#1092682" title="PatternMatching.this.global.Tree">guard</a>, <a href="#1092683" title="PatternMatching.this.global.Tree">body</a><span class="delimiter">)</span><span class="delimiter">)</span>
              // alternatives
              <span class="keyword">case</span> AlternativesTreeMaker<a href="../../../collection/immutable/List.scala.html#206583" title="SwitchEmission.this.TreeMaker" id="3370466" class="delimiter">(</a><a href="#1071043" title="PatternMatching.this.global.Symbol" id="3370463">_</a>, <a href="#1071044" title="List[List[SwitchEmission.this.TreeMaker]]" id="1092700">altss</a>, <a href="#1071045" title="PatternMatching.this.global.Position" id="3370464">_</a><span class="delimiter">)</span> :: <a href="#1091940" title="Option[(PatternMatching.this.global.Tree, PatternMatching.this.global.Tree)]" id="3370479">GuardAndBodyTreeMakers</a><a href="../../../collection/immutable/List.scala.html#206584" title="List[SwitchEmission.this.TreeMaker]" id="3370461" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="PatternMatching.this.global.Tree" id="1092702">guard</a>, <a href="../../../Tuple2.scala.html#60637" title="PatternMatching.this.global.Tree" id="1092703">body</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#1091875" title="=&gt; Boolean">alternativesSupported</a> =&gt;
                <span class="keyword">val</span> <a title="List[Option[PatternMatching.this.global.Tree]]" id="1092704">switchableAlts</a> = <a href="#1092700" title="List[List[SwitchEmission.this.TreeMaker]]">altss</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[SwitchEmission.this.TreeMaker] =&gt; Option[PatternMatching.this.global.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[SwitchEmission.this.TreeMaker]],Option[PatternMatching.this.global.Tree],List[Option[PatternMatching.this.global.Tree]]])List[Option[PatternMatching.this.global.Tree]]">map</a> <a href="#1092721" title="List[SwitchEmission.this.TreeMaker]" class="delimiter">{</a>
                  <span class="keyword">case</span> <a href="#1091899" title="Option[PatternMatching.this.global.Tree]" id="3370448">SwitchableTreeMaker</a><a href="../../../collection/immutable/List.scala.html#206583" title="SwitchEmission.this.TreeMaker" id="3370437" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1092725">pattern</a><span class="delimiter">)</span> <a href="#3370436" title="Option[PatternMatching.this.global.Tree]" id="3370439">::</a> <a href="../../../collection/immutable/List.scala.html#206584" title="List[SwitchEmission.this.TreeMaker]" id="3370442">Nil</a> =&gt;
                    <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.Tree)Some[PatternMatching.this.global.Tree]">Some</a><a href="#3370444" title="(x: Option[PatternMatching.this.global.Tree])Option[PatternMatching.this.global.Tree]" class="delimiter">(</a><a href="#1092725" title="PatternMatching.this.global.Tree">pattern</a><span class="delimiter">)</span>
                  <span class="keyword">case</span> _ =&gt;
                    <a href="#3370444" title="(x: Option[PatternMatching.this.global.Tree])Option[PatternMatching.this.global.Tree]">None</a>
                <span class="delimiter">}</span>

                // succeed if they were all switchable
                <a href="#1091882" title="(xs: List[Option[PatternMatching.this.global.Tree]])Option[List[PatternMatching.this.global.Tree]]">sequence</a><span class="delimiter">(</span><a href="#1092704" title="List[Option[PatternMatching.this.global.Tree]]">switchableAlts</a><span class="delimiter">)</span> <a href="../../../Option.scala.html#62865" title="(f: List[PatternMatching.this.global.Tree] =&gt; PatternMatching.this.global.CaseDef)Option[PatternMatching.this.global.CaseDef]">map</a> <span class="delimiter">{</span> <a title="List[PatternMatching.this.global.Tree]" id="1092778">switchableAlts</a> =&gt;
                  <a href="../../../reflect/internal/Trees.scala.html#453147" title="(pat: PatternMatching.this.global.Tree, guard: PatternMatching.this.global.Tree, body: PatternMatching.this.global.Tree)PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#453179" title="(trees: List[PatternMatching.this.global.Tree])PatternMatching.this.global.Alternative">Alternative</a><span class="delimiter">(</span><a href="#1092778" title="List[PatternMatching.this.global.Tree]">switchableAlts</a><span class="delimiter">)</span>, <a href="#1092702" title="PatternMatching.this.global.Tree">guard</a>, <a href="#1092703" title="PatternMatching.this.global.Tree">body</a><span class="delimiter">)</span>
                <span class="delimiter">}</span>
              <span class="keyword">case</span> _ =&gt;
                // patmatDebug(&quot;can't emit switch for &quot;+ makers)
                <a href="#3370470" title="(x: Option[PatternMatching.this.global.CaseDef])Option[PatternMatching.this.global.CaseDef]">None</a> //failure (can't translate pattern to a switch)
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>

          <span class="keyword">val</span> <a title="List[PatternMatching.this.global.CaseDef]" id="1092648">caseDefsWithGuards</a> = <a href="#1091882" title="(xs: List[Option[PatternMatching.this.global.CaseDef]])Option[List[PatternMatching.this.global.CaseDef]]">sequence</a><a href="#3370498" title="(x: List[PatternMatching.this.global.CaseDef])List[PatternMatching.this.global.CaseDef]" class="delimiter">(</a><a href="#1092647" title="List[Option[PatternMatching.this.global.CaseDef]]">caseDefs</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a href="../../../Option.scala.html#1585" title="List[PatternMatching.this.global.CaseDef]" id="3370496">None</a>      =&gt; <a href="#3370498" title="(x: List[PatternMatching.this.global.CaseDef])List[PatternMatching.this.global.CaseDef]" class="keyword">return</a> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>
            <span class="keyword">case</span> Some<a href="#3370493" title="List[PatternMatching.this.global.CaseDef]" id="3370495" class="delimiter">(</a><a href="../../../Option.scala.html#63132" title="List[PatternMatching.this.global.CaseDef]" id="1092827">cds</a><span class="delimiter">)</span> =&gt; <a href="#3370498" title="(x: List[PatternMatching.this.global.CaseDef])List[PatternMatching.this.global.CaseDef]">cds</a>
          <span class="delimiter">}</span>

          <span class="keyword">val</span> <a title="Boolean" id="1092649">allReachable</a> = <a href="#1091877" title="=&gt; Boolean">unchecked</a> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <span class="delimiter">{</span>
            // a switch with duplicate cases yields a verify error,
            // and a switch with duplicate cases and guards cannot soundly be rewritten to an unguarded switch
            // (even though the verify error would disappear, the behaviour would change)
            <a href="#1091895" title="(cs: List[PatternMatching.this.global.CaseDef])Option[PatternMatching.this.global.CaseDef]">unreachableCase</a><span class="delimiter">(</span><a href="#1092648" title="List[PatternMatching.this.global.CaseDef]">caseDefsWithGuards</a><span class="delimiter">)</span> <a href="../../../Option.scala.html#62865" title="(f: PatternMatching.this.global.CaseDef =&gt; Unit)Option[Unit]">map</a> <span class="delimiter">(</span><a title="PatternMatching.this.global.CaseDef" id="1092832">cd</a> =&gt; <a href="#1068982" title="(pos: PatternMatching.this.global.Position)Unit">reportUnreachable</a><span class="delimiter">(</span><a href="#1092832" title="PatternMatching.this.global.CaseDef">cd</a>.<a href="../../../reflect/internal/Trees.scala.html#410184" title="=&gt; PatternMatching.this.global.Tree">body</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../Option.scala.html#62856" title="=&gt; Boolean">isEmpty</a>
          <span class="delimiter">}</span>

          <span title="List[PatternMatching.this.global.CaseDef]" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1092649" title="Boolean">allReachable</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>
          <span class="keyword">else</span> <span title="List[PatternMatching.this.global.CaseDef]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1091894" title="(cs: List[PatternMatching.this.global.CaseDef])Boolean">noGuards</a><span class="delimiter">(</span><a href="#1092648" title="List[PatternMatching.this.global.CaseDef]">caseDefsWithGuards</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span title="List[PatternMatching.this.global.CaseDef]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1091878" title="(x: PatternMatching.this.global.CaseDef)Boolean">isDefault</a><span class="delimiter">(</span><a href="#1092648" title="List[PatternMatching.this.global.CaseDef]">caseDefsWithGuards</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86394" title="=&gt; PatternMatching.this.global.CaseDef">last</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#1092648" title="List[PatternMatching.this.global.CaseDef]">caseDefsWithGuards</a>
            <span class="keyword">else</span> <a href="#1092648" title="List[PatternMatching.this.global.CaseDef]">caseDefsWithGuards</a> <a href="../../../collection/SeqLike.scala.html#58855" title="(elem: PatternMatching.this.global.CaseDef)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.CaseDef],PatternMatching.this.global.CaseDef,List[PatternMatching.this.global.CaseDef]])List[PatternMatching.this.global.CaseDef]">:+</a> <a href="#1091881" title="(scrutSym: PatternMatching.this.global.Symbol, guard: PatternMatching.this.global.Tree, body: PatternMatching.this.global.Tree)PatternMatching.this.global.CaseDef">defaultCase</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            // collapse identical cases with different guards, push guards into body for all guarded cases
            // this translation is only sound if there are no unreachable (duplicate) cases
            // it should only be run if there are guarded cases, and on failure it returns Nil
            <span class="keyword">val</span> <a href="#3370508" title="(x: (List[PatternMatching.this.global.CaseDef], Boolean))(List[PatternMatching.this.global.CaseDef], Boolean)" class="delimiter">(</a><a href="../../../Tuple2.scala.html#60635" title="List[PatternMatching.this.global.CaseDef]" id="1092881">collapsed</a>, <a href="../../../Tuple2.scala.html#60637" title="Boolean" id="1092882">needDefaultLabel</a><span class="delimiter">)</span> = <a href="#1091889" title="(cases: List[PatternMatching.this.global.CaseDef])(List[PatternMatching.this.global.CaseDef], Boolean)">collapseGuardedCases</a><a href="../../../Tuple2.scala.html#783" title="(List[PatternMatching.this.global.CaseDef], Boolean) @unchecked" class="delimiter">(</a><a href="#1092648" title="List[PatternMatching.this.global.CaseDef]">caseDefsWithGuards</a><span class="delimiter">)</span>

            <span title="List[PatternMatching.this.global.CaseDef]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1092881" title="List[PatternMatching.this.global.CaseDef]">collapsed</a>.<a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a> <a href="../../../Boolean.scala.html#57825" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#1092882" title="Boolean">needDefaultLabel</a> <a href="../../../Boolean.scala.html#57826" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1091876" title="=&gt; Boolean">canJump</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>
            <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="keyword">def</span> <a title="(cd: PatternMatching.this.global.CaseDef)PatternMatching.this.global.CaseDef" id="1092894">wrapInDefaultLabelDef</a><span class="delimiter">(</span><a title="PatternMatching.this.global.CaseDef" id="1092896">cd</a>: <a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a> =
                <span title="PatternMatching.this.global.CaseDef" class="keyword">if</span> <span class="delimiter">(</span><a href="#1092882" title="Boolean">needDefaultLabel</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Trees.scala.html#408161" title="(cdef: PatternMatching.this.global.Tree)(applyToBody: PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree)PatternMatching.this.global.CaseDef">deriveCaseDef</a><span class="delimiter">(</span><a href="#1092896" title="PatternMatching.this.global.CaseDef">cd</a><span class="delimiter">)</span><span class="delimiter">{</span> <a title="PatternMatching.this.global.Tree" id="1092900">b</a> =&gt;
                  // TODO: can b.tpe ever be null? can't really use pt, see e.g. pos/t2683 or cps/match1.scala
                  <a href="#1091887" title="=&gt; PatternMatching.this.global.Symbol">defaultLabel</a> <a href="../../../reflect/internal/Symbols.scala.html#411369" title="(info: PatternMatching.this.global.Type)SwitchMaker.this.defaultLabel.type">setInfo</a> <a href="../../../reflect/internal/Types.scala.html#420479" title="(params: List[PatternMatching.this.global.Symbol], resultType: PatternMatching.this.global.Type)PatternMatching.this.global.MethodType">MethodType</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>, <span title="PatternMatching.this.global.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#1092900" title="PatternMatching.this.global.Tree">b</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <a href="#1092900" title="PatternMatching.this.global.Tree">b</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a> <span class="keyword">else</span> <a href="#1092645" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span>
                  <a href="../../../reflect/internal/Trees.scala.html#408113" title="(sym: PatternMatching.this.global.Symbol, params: List[PatternMatching.this.global.Symbol], rhs: PatternMatching.this.global.Tree)PatternMatching.this.global.LabelDef">LabelDef</a><span class="delimiter">(</span><a href="#1091887" title="=&gt; PatternMatching.this.global.Symbol">defaultLabel</a>, <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#1092900" title="PatternMatching.this.global.Tree">b</a><span class="delimiter">)</span>
                <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#1092896" title="PatternMatching.this.global.CaseDef">cd</a>

              <span class="keyword">val</span> <a title="PatternMatching.this.global.CaseDef" id="1092895">last</a> = <a href="#1092881" title="List[PatternMatching.this.global.CaseDef]">collapsed</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#86394" title="=&gt; PatternMatching.this.global.CaseDef">last</a>
              <span title="List[PatternMatching.this.global.CaseDef]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1091878" title="(x: PatternMatching.this.global.CaseDef)Boolean">isDefault</a><span class="delimiter">(</span><a href="#1092895" title="PatternMatching.this.global.CaseDef">last</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span title="List[PatternMatching.this.global.CaseDef]" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1092882" title="Boolean">needDefaultLabel</a><span class="delimiter">)</span> <a href="#1092881" title="List[PatternMatching.this.global.CaseDef]">collapsed</a>
                <span class="keyword">else</span> <a href="#1092881" title="List[PatternMatching.this.global.CaseDef]">collapsed</a>.<a href="../../../collection/TraversableLike.scala.html#58107" title="=&gt; List[PatternMatching.this.global.CaseDef]">init</a> <a href="../../../collection/SeqLike.scala.html#58855" title="(elem: PatternMatching.this.global.CaseDef)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.CaseDef],PatternMatching.this.global.CaseDef,List[PatternMatching.this.global.CaseDef]])List[PatternMatching.this.global.CaseDef]">:+</a> <a href="#1092894" title="(cd: PatternMatching.this.global.CaseDef)PatternMatching.this.global.CaseDef">wrapInDefaultLabelDef</a><span class="delimiter">(</span><a href="#1092895" title="PatternMatching.this.global.CaseDef">last</a><span class="delimiter">)</span>
              <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#1092881" title="List[PatternMatching.this.global.CaseDef]">collapsed</a> <a href="../../../collection/SeqLike.scala.html#58855" title="(elem: PatternMatching.this.global.CaseDef)(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.CaseDef],PatternMatching.this.global.CaseDef,List[PatternMatching.this.global.CaseDef]])List[PatternMatching.this.global.CaseDef]">:+</a> <a href="#1092894" title="(cd: PatternMatching.this.global.CaseDef)PatternMatching.this.global.CaseDef">wrapInDefaultLabelDef</a><span class="delimiter">(</span><a href="#1091881" title="(scrutSym: PatternMatching.this.global.Symbol, guard: PatternMatching.this.global.Tree, body: PatternMatching.this.global.Tree)PatternMatching.this.global.CaseDef">defaultCase</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">class</span> <a title="class RegularSwitchMaker extends SwitchEmission.this.SwitchMaker" id="1069186">RegularSwitchMaker</a><a href="#1069186" title="SwitchEmission.this.RegularSwitchMaker" class="delimiter">(</a><a title="PatternMatching.this.global.Symbol" id="1093067">scrutSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]" id="1093068">matchFailGenOverride</a>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree =&gt; Tree<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Boolean" id="1093069">unchecked</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069185" title="SwitchEmission.this.SwitchMaker">SwitchMaker</a> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.collection.immutable.Set[PatternMatching.this.global.Type]" id="1093046">switchableTpe</a> = <a href="../../../collection/generic/GenericCompanion.scala.html#59933" title="(elems: PatternMatching.this.global.Type*)scala.collection.immutable.Set[PatternMatching.this.global.Type]">Set</a><span class="delimiter">(</span><a href="../../../reflect/internal/Definitions.scala.html#409355" title="=&gt; PatternMatching.this.global.ClassSymbol">ByteClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a>, <a href="../../../reflect/internal/Definitions.scala.html#409357" title="=&gt; PatternMatching.this.global.ClassSymbol">ShortClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a>, <a href="../../../reflect/internal/Definitions.scala.html#409361" title="=&gt; PatternMatching.this.global.ClassSymbol">IntClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a>, <a href="../../../reflect/internal/Definitions.scala.html#409359" title="=&gt; PatternMatching.this.global.ClassSymbol">CharClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Boolean" id="1093048">alternativesSupported</a> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">val</span> <a title="Boolean" id="1093050">canJump</a> = <span title="Boolean(true)" class="keyword">true</span>

      <span class="keyword">object</span> <a title="RegularSwitchMaker.this.SwitchablePattern.type" id="1093052">SwitchablePattern</a> <a href="#1093053" title="RegularSwitchMaker.this.SwitchablePattern.type" class="delimiter">{</a> <span class="keyword">def</span> <a title="(pat: PatternMatching.this.global.Tree)Option[PatternMatching.this.global.Tree]" id="1093071">unapply</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1093073">pat</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> = <a href="#1093073" title="PatternMatching.this.global.Tree">pat</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Literal<a href="#3370512" title="Option[PatternMatching.this.global.Tree]" id="3370514" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#409973" title="PatternMatching.this.global.Constant" id="1093075">const</a>@Constant<span class="delimiter">(</span><a href="../../../reflect/internal/Constants.scala.html#409760" title="Any" id="3370515" class="delimiter">(</a>_: Byte <span class="delimiter">)</span> | <span class="delimiter">(</span>_: Short<span class="delimiter">)</span> | <span class="delimiter">(</span>_: Int  <span class="delimiter">)</span> | <span class="delimiter">(</span>_: Char <span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
          <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.Literal)Some[PatternMatching.this.global.Literal]">Some</a><a href="#3370521" title="(x: Option[PatternMatching.this.global.Tree])Option[PatternMatching.this.global.Tree]" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#413609" title="(value: PatternMatching.this.global.Constant)PatternMatching.this.global.Literal">Literal</a><span class="delimiter">(</span><a href="../../../reflect/internal/Constants.scala.html#415091" title="(value: Any)PatternMatching.this.global.Constant">Constant</a><span class="delimiter">(</span><a href="#1093075" title="PatternMatching.this.global.Constant">const</a>.<a href="../../../reflect/internal/Constants.scala.html#409783" title="=&gt; Int">intValue</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> // TODO: Java 7 allows strings in switches
        <span class="keyword">case</span> _ =&gt; <a href="#3370521" title="(x: Option[PatternMatching.this.global.Tree])Option[PatternMatching.this.global.Tree]">None</a>
      <span class="delimiter">}</span><span class="delimiter">}</span>

      <span class="keyword">object</span> <a title="RegularSwitchMaker.this.SwitchableTreeMaker.type" id="1093054">SwitchableTreeMaker</a> <a href="#1093055" title="RegularSwitchMaker.this.SwitchableTreeMaker.type" class="keyword">extends</a> <a href="#1091873" title="RegularSwitchMaker.this.SwitchableTreeMakerExtractor">SwitchableTreeMakerExtractor</a> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(x: SwitchEmission.this.TreeMaker)Option[PatternMatching.this.global.Tree]" id="1093080">unapply</a><span class="delimiter">(</span><a title="SwitchEmission.this.TreeMaker" id="1093082">x</a>: <a href="#1069034" title="SwitchEmission.this.TreeMaker">TreeMaker</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> = <a href="#1093082" title="SwitchEmission.this.TreeMaker">x</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> EqualityTestTreeMaker<a href="#3370533" title="Option[PatternMatching.this.global.Tree]" id="3370538" class="delimiter">(</a><a href="#1071011" title="PatternMatching.this.global.Symbol" id="3370534">_</a>, <a href="#1093071" title="Option[PatternMatching.this.global.Tree]" id="3370545">SwitchablePattern</a><a href="#1071012" title="PatternMatching.this.global.Tree" id="3370535" class="delimiter">(</a><a title="PatternMatching.this.global.Tree" id="1093084">const</a><span class="delimiter">)</span>, <a href="#1071013" title="PatternMatching.this.global.Position" id="3370536">_</a><span class="delimiter">)</span> =&gt; <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.Tree)Some[PatternMatching.this.global.Tree]">Some</a><a href="#3370541" title="(x: Option[PatternMatching.this.global.Tree])Option[PatternMatching.this.global.Tree]" class="delimiter">(</a><a href="#1093084" title="PatternMatching.this.global.Tree">const</a><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt; <a href="#3370541" title="(x: Option[PatternMatching.this.global.Tree])Option[PatternMatching.this.global.Tree]">None</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span class="keyword">def</span> <a title="(x: PatternMatching.this.global.CaseDef)Boolean" id="1093056">isDefault</a><span class="delimiter">(</span><a title="PatternMatching.this.global.CaseDef" id="1093088">x</a>: <a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <a href="#1093088" title="PatternMatching.this.global.CaseDef">x</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> CaseDef<span class="delimiter">(</span>Ident<a href="../../../reflect/internal/Trees.scala.html#410180" title="PatternMatching.this.global.Tree" id="3370553" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3370557">WILDCARD</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#410182" title="PatternMatching.this.global.Tree" id="3370558">EmptyTree</a>, <a href="../../../reflect/internal/Trees.scala.html#410184" title="PatternMatching.this.global.Tree" id="3370550">_</a><span class="delimiter">)</span> =&gt; <a href="#3370561" title="(x: Boolean)Boolean" class="keyword">true</a>
        <span class="keyword">case</span> _ =&gt; <a href="#3370561" title="(x: Boolean)Boolean" class="keyword">false</a>
      <span class="delimiter">}</span>

      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Symbol" id="1093057">defaultSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a> = <a href="#1093067" title="PatternMatching.this.global.Symbol">scrutSym</a>
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Tree" id="1093058">defaultBody</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>  = <span class="delimiter">{</span> <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._; <a href="#1093068" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">matchFailGenOverride</a> <a href="../../../Option.scala.html#62865" title="(f: (PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree) =&gt; PatternMatching.this.global.Tree)Option[PatternMatching.this.global.Tree]">map</a> <span class="delimiter">(</span><a title="PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree" id="1093102">gen</a> =&gt; <a href="../../../Function1.scala.html#58642" title="(v1: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">gen</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1093067" title="PatternMatching.this.global.Symbol">scrutSym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../Option.scala.html#62859" title="(default: =&gt; PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">getOrElse</a> <a href="../ast/TreeDSL.scala.html#624587" title="(arg: PatternMatching.this.global.Tree)PatternMatching.this.global.Throw">MATCHERROR</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1093067" title="PatternMatching.this.global.Symbol">scrutSym</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="keyword">def</span> <a title="(scrutSym: PatternMatching.this.global.Symbol, guard: PatternMatching.this.global.Tree, body: PatternMatching.this.global.Tree)PatternMatching.this.global.CaseDef" id="1093059">defaultCase</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1093117">scrutSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a> = <a href="#1093057" title="=&gt; PatternMatching.this.global.Symbol">defaultSym</a>, <a title="PatternMatching.this.global.Tree" id="1093118">guard</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="../../../reflect/internal/Trees.scala.html#407946" title="PatternMatching.this.global.EmptyTree.type">EmptyTree</a>, <a title="PatternMatching.this.global.Tree" id="1093119">body</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="#1093058" title="=&gt; PatternMatching.this.global.Tree">defaultBody</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a> = <span class="delimiter">{</span> <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._; <a href="../../../reflect/internal/Positions.scala.html#408315" title="(pos: PatternMatching.this.global.Position)(tree: PatternMatching.this.global.CaseDef)PatternMatching.this.global.CaseDef">atPos</a><span class="delimiter">(</span><a href="#1093119" title="PatternMatching.this.global.Tree">body</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624585" title="=&gt; PatternMatching.this.CODE.CaseStart">DEFAULT</a> <a href="../ast/TreeDSL.scala.html#662967" title="(g: PatternMatching.this.global.Tree)PatternMatching.this.CODE.CaseStart">IF</a> <a href="#1093118" title="PatternMatching.this.global.Tree">guard</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#662968" title="(body: PatternMatching.this.global.Tree)PatternMatching.this.global.CaseDef">==&gt;</a> <a href="#1093119" title="PatternMatching.this.global.Tree">body</a>
      <span class="delimiter">}</span><span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, cases: List[List[SwitchEmission.this.TreeMaker]], pt: PatternMatching.this.global.Type, matchFailGenOverride: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree], unchecked: Boolean)Option[PatternMatching.this.global.Tree]" id="1069187">emitSwitch</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1093130">scrut</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1093131">scrutSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="List[List[SwitchEmission.this.TreeMaker]]" id="1093132">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[SwitchEmission.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="PatternMatching.this.global.Type" id="1093133">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <a title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]" id="1093134">matchFailGenOverride</a>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree =&gt; Tree<span class="delimiter">]</span>, <a title="Boolean" id="1093135">unchecked</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> = <span class="delimiter">{</span> <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._
      <span class="keyword">val</span> <a title="SwitchEmission.this.RegularSwitchMaker" id="1093144">regularSwitchMaker</a> = <span title="SwitchEmission.this.RegularSwitchMaker" class="keyword">new</span> <a href="#1069186" title="SwitchEmission.this.RegularSwitchMaker">RegularSwitchMaker</a><span class="delimiter">(</span><a href="#1093131" title="PatternMatching.this.global.Symbol">scrutSym</a>, <a href="#1093134" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">matchFailGenOverride</a>, <a href="#1093135" title="Boolean">unchecked</a><span class="delimiter">)</span>
      // TODO: if patterns allow switch but the type of the scrutinee doesn't, cast (type-test) the scrutinee to the corresponding switchable type and switch on the result
      <span title="Option[PatternMatching.this.global.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1093144" title="SwitchEmission.this.RegularSwitchMaker">regularSwitchMaker</a>.<a href="../../../collection/GenSetLike.scala.html#66403" title="(elem: PatternMatching.this.global.Type)Boolean">switchableTpe</a><span class="delimiter">(</span><a href="#1093131" title="PatternMatching.this.global.Symbol">scrutSym</a>.<a href="../../../reflect/internal/Symbols.scala.html#411365" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="List[PatternMatching.this.global.CaseDef]" id="1093156">caseDefsWithDefault</a> = <a href="#1091896" title="(cases: List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])], pt: PatternMatching.this.global.Type)List[PatternMatching.this.global.CaseDef]">regularSwitchMaker</a><span class="delimiter">(</span><a href="#1093132" title="List[List[SwitchEmission.this.TreeMaker]]">cases</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[SwitchEmission.this.TreeMaker] =&gt; (PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker]))(implicit bf: scala.collection.generic.CanBuildFrom[List[List[SwitchEmission.this.TreeMaker]],(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker]),List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])]])List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])]">map</a> <span class="delimiter">{</span><a title="List[SwitchEmission.this.TreeMaker]" id="1093173">c</a> =&gt; <a href="../../../Tuple2.scala.html#62849" title="(_1: PatternMatching.this.global.Symbol, _2: List[SwitchEmission.this.TreeMaker])(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])" class="delimiter">(</a><a href="#1093131" title="PatternMatching.this.global.Symbol">scrutSym</a>, <a href="#1093173" title="List[SwitchEmission.this.TreeMaker]">c</a><span class="delimiter">)</span><span class="delimiter">}</span>, <a href="#1093133" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span>
        <span title="Option[PatternMatching.this.global.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1093156" title="List[PatternMatching.this.global.CaseDef]">caseDefsWithDefault</a> <a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../../../Option.scala.html#1585" title="None.type">None</a> // not worth emitting a switch.
        <span class="keyword">else</span> <span class="delimiter">{</span>
          // match on scrutSym -- converted to an int if necessary -- not on scrut directly (to avoid duplicating scrut)
          <span class="keyword">val</span> <a title="PatternMatching.this.global.Tree" id="1093216">scrutToInt</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> =
            <span title="PatternMatching.this.global.Tree" class="keyword">if</span> <span class="delimiter">(</span><a href="#1093131" title="PatternMatching.this.global.Symbol">scrutSym</a>.<a href="../../../reflect/internal/Symbols.scala.html#411365" title="=&gt; PatternMatching.this.global.Type">tpe</a> <a href="../../../reflect/internal/Types.scala.html#408485" title="(that: PatternMatching.this.global.Type)Boolean">=:=</a> <a href="../../../reflect/internal/Definitions.scala.html#409361" title="=&gt; PatternMatching.this.global.ClassSymbol">IntClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1093131" title="PatternMatching.this.global.Symbol">scrutSym</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><a href="../ast/TreeDSL.scala.html#624616" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethods : (target: PatternMatching.this.global.Tree)PatternMatching.this.CODE.TreeMethods" class="delimiter">(</a><a href="#1093131" title="PatternMatching.this.global.Symbol">scrutSym</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#624619" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeFromSelectStart : (ss: PatternMatching.this.CODE.SelectStart)PatternMatching.this.global.Select">DOT</a> <span class="delimiter">(</span><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/StdNames.scala.html#414613" title="=&gt; PatternMatching.this.global.nme.NameType">toInt</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.Block)Some[PatternMatching.this.global.Block]">Some</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624607" title="(xs: PatternMatching.this.global.Tree*)PatternMatching.this.global.Block">BLOCK</a><span class="delimiter">(</span>
            <a href="../ast/TreeDSL.scala.html#624596" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.CODE.ValSymStart">VAL</a><span class="delimiter">(</span><a href="#1093131" title="PatternMatching.this.global.Symbol">scrutSym</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#663071" title="(rhs: PatternMatching.this.global.Tree)PatternMatching.this.global.ValDef">===</a> <a href="#1093130" title="PatternMatching.this.global.Tree">scrut</a>,
            <a href="../../../reflect/internal/Trees.scala.html#453592" title="(selector: PatternMatching.this.global.Tree, cases: List[PatternMatching.this.global.CaseDef])PatternMatching.this.global.Match">Match</a><span class="delimiter">(</span><a href="#1093216" title="PatternMatching.this.global.Tree">scrutToInt</a>, <a href="#1093156" title="List[PatternMatching.this.global.CaseDef]">caseDefsWithDefault</a><span class="delimiter">)</span> // a switch
          <span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <a href="../../../Option.scala.html#1585" title="None.type">None</a>
    <span class="delimiter">}</span>

    // for the catch-cases in a try/catch
    <span class="keyword">private</span> <span class="keyword">object</span> <a title="SwitchEmission.this.typeSwitchMaker.type" id="1069188">typeSwitchMaker</a> <a href="#1069189" title="SwitchEmission.this.typeSwitchMaker.type" class="keyword">extends</a> <a href="#1069185" title="SwitchEmission.this.SwitchMaker">SwitchMaker</a> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Boolean" id="1093255">unchecked</a> = <span title="Boolean(false)" class="keyword">false</span>
      <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)Boolean" id="1093257">switchableTpe</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1093270">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">val</span> <a title="Boolean" id="1093258">alternativesSupported</a> = <span title="Boolean(false)" class="keyword">false</span> // TODO: needs either back-end support of flattening of alternatives during typers
      <span class="keyword">val</span> <a title="Boolean" id="1093260">canJump</a> = <span title="Boolean(false)" class="keyword">false</span>

      // TODO: there are more treemaker-sequences that can be handled by type tests
      // analyze the result of approximateTreeMaker rather than the TreeMaker itself
      <span class="keyword">object</span> <a title="scala.tools.nsc.typechecker.PatternMatching.SwitchEmission.typeSwitchMaker.SwitchableTreeMaker.type" id="1093262">SwitchableTreeMaker</a> <a href="#1093263" title="scala.tools.nsc.typechecker.PatternMatching.SwitchEmission.typeSwitchMaker.SwitchableTreeMaker.type" class="keyword">extends</a> <a href="#1091873" title="scala.tools.nsc.typechecker.PatternMatching.SwitchEmission.typeSwitchMaker.SwitchableTreeMakerExtractor">SwitchableTreeMakerExtractor</a> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(x: SwitchEmission.this.TreeMaker)Option[PatternMatching.this.global.Tree]" id="1093272">unapply</a><span class="delimiter">(</span><a title="SwitchEmission.this.TreeMaker" id="1093274">x</a>: <a href="#1069034" title="SwitchEmission.this.TreeMaker">TreeMaker</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> = <a href="#1093274" title="SwitchEmission.this.TreeMaker">x</a> <span class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> tm@TypeTestTreeMaker<a href="#3370572" title="Option[PatternMatching.this.global.Tree]" id="3370577" class="delimiter">(</a><a href="#1074597" title="PatternMatching.this.global.Symbol" id="3370573">_</a>, <a href="#1074598" title="PatternMatching.this.global.Symbol" id="3370574">_</a>, <a href="#1074599" title="PatternMatching.this.global.Type" id="1093276">pt</a>, <a href="#1074600" title="PatternMatching.this.global.Type" id="3370575">_</a><span class="delimiter">)</span> <span class="keyword">if</span> tm.<a href="#1070704" title="=&gt; SwitchEmission.this.TypeTestTreeMaker.pureTypeTestChecker.Result">isPureTypeTest</a> =&gt; //  -- TODO: use this if binder does not occur in the body
            <a href="../../../Option.scala.html#63128" title="(x: PatternMatching.this.global.Bind)Some[PatternMatching.this.global.Bind]">Some</a><a href="#3370579" title="(x: Option[PatternMatching.this.global.Tree])Option[PatternMatching.this.global.Tree]" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#408115" title="(sym: PatternMatching.this.global.Symbol, body: PatternMatching.this.global.Tree)PatternMatching.this.global.Bind">Bind</a><span class="delimiter">(</span>tm.<a href="#1070673" title="=&gt; PatternMatching.this.global.TermSymbol">nextBinder</a>, <a href="../../../reflect/internal/Trees.scala.html#453846" title="(expr: PatternMatching.this.global.Tree, tpt: PatternMatching.this.global.Tree)PatternMatching.this.global.Typed">Typed</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#418125" title="(name: PatternMatching.this.global.Name)PatternMatching.this.global.Ident">Ident</a><span class="delimiter">(</span><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/StdNames.scala.html#413714" title="=&gt; PatternMatching.this.global.nme.NameType">WILDCARD</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#408087" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#1093276" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span><span class="delimiter">)</span> /* not used by back-end */<span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> _ =&gt;
            <a href="#3370579" title="(x: Option[PatternMatching.this.global.Tree])Option[PatternMatching.this.global.Tree]">None</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span class="keyword">def</span> <a title="(x: PatternMatching.this.global.CaseDef)Boolean" id="1093264">isDefault</a><span class="delimiter">(</span><a title="PatternMatching.this.global.CaseDef" id="1093309">x</a>: <a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a> = <a href="#1093309" title="PatternMatching.this.global.CaseDef">x</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> CaseDef<span class="delimiter">(</span>Typed<a href="../../../reflect/internal/Trees.scala.html#410180" title="PatternMatching.this.global.Tree" id="3370590" class="delimiter">(</a>Ident<a href="../../../reflect/internal/Trees.scala.html#410055" title="PatternMatching.this.global.Tree" id="3370593" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3370622">WILDCARD</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#410057" title="PatternMatching.this.global.Tree" id="1093320">tpt</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#410182" title="PatternMatching.this.global.Tree" id="3370623">EmptyTree</a>, <a href="../../../reflect/internal/Trees.scala.html#410184" title="PatternMatching.this.global.Tree" id="3370587">_</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#1093320" title="PatternMatching.this.global.Tree">tpt</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a> <a href="../../../reflect/internal/Types.scala.html#408485" title="(that: PatternMatching.this.global.Type)Boolean">=:=</a> <a href="../../../reflect/internal/Definitions.scala.html#408712" title="=&gt; PatternMatching.this.global.ClassSymbol">ThrowableClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span>          =&gt; <a href="#3370630" title="(x: Boolean)Boolean" class="keyword">true</a>
        <span class="keyword">case</span> CaseDef<span class="delimiter">(</span>Bind<a href="../../../reflect/internal/Trees.scala.html#410180" title="PatternMatching.this.global.Tree" id="3370603" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#410157" title="PatternMatching.this.global.Name" id="3370600">_</a>, Typed<a href="../../../reflect/internal/Trees.scala.html#410159" title="PatternMatching.this.global.Tree" id="3370606" class="delimiter">(</a>Ident<a href="../../../reflect/internal/Trees.scala.html#410055" title="PatternMatching.this.global.Tree" id="3370609" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3370624">WILDCARD</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#410057" title="PatternMatching.this.global.Tree" id="1093339">tpt</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#410182" title="PatternMatching.this.global.Tree" id="3370625">EmptyTree</a>, <a href="../../../reflect/internal/Trees.scala.html#410184" title="PatternMatching.this.global.Tree" id="3370599">_</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#1093339" title="PatternMatching.this.global.Tree">tpt</a>.<a href="../../../reflect/internal/Trees.scala.html#408573" title="=&gt; PatternMatching.this.global.Type">tpe</a> <a href="../../../reflect/internal/Types.scala.html#408485" title="(that: PatternMatching.this.global.Type)Boolean">=:=</a> <a href="../../../reflect/internal/Definitions.scala.html#408712" title="=&gt; PatternMatching.this.global.ClassSymbol">ThrowableClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span> =&gt; <a href="#3370630" title="(x: Boolean)Boolean" class="keyword">true</a>
        <span class="keyword">case</span> CaseDef<span class="delimiter">(</span>Ident<a href="../../../reflect/internal/Trees.scala.html#410180" title="PatternMatching.this.global.Tree" id="3370618" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/Trees.scala.html#409987" title="PatternMatching.this.global.Name" id="3370626">WILDCARD</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#410182" title="PatternMatching.this.global.Tree" id="3370627">EmptyTree</a>, <a href="../../../reflect/internal/Trees.scala.html#410184" title="PatternMatching.this.global.Tree" id="3370615">_</a><span class="delimiter">)</span>                                                          =&gt; <a href="#3370630" title="(x: Boolean)Boolean" class="keyword">true</a>
        <span class="keyword">case</span> _ =&gt; <a href="#3370630" title="(x: Boolean)Boolean" class="keyword">false</a>
      <span class="delimiter">}</span>

      <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="1093266">defaultSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a> = <a href="#1069013" title="(pos: PatternMatching.this.global.Position, tp: PatternMatching.this.global.Type, prefix: String)PatternMatching.this.global.TermSymbol">freshSym</a><span class="delimiter">(</span><a href="../../../reflect/internal/Positions.scala.html#408302" title="=&gt; reflect.internal.util.NoPosition.type">NoPosition</a>, <a href="../../../reflect/internal/Definitions.scala.html#408712" title="=&gt; PatternMatching.this.global.ClassSymbol">ThrowableClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Tree" id="1093267">defaultBody</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>       = <a href="../../../reflect/internal/Trees.scala.html#453782" title="(expr: PatternMatching.this.global.Tree)PatternMatching.this.global.Throw">Throw</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>.<a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1093265" title="=&gt; PatternMatching.this.global.Symbol">defaultSym</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="(scrutSym: PatternMatching.this.global.Symbol, guard: PatternMatching.this.global.Tree, body: PatternMatching.this.global.Tree)PatternMatching.this.global.CaseDef" id="1093268">defaultCase</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1093367">scrutSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a> = <a href="#1093265" title="=&gt; PatternMatching.this.global.Symbol">defaultSym</a>, <a title="PatternMatching.this.global.Tree" id="1093368">guard</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="../../../reflect/internal/Trees.scala.html#407946" title="PatternMatching.this.global.EmptyTree.type">EmptyTree</a>, <a title="PatternMatching.this.global.Tree" id="1093369">body</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="#1093267" title="=&gt; PatternMatching.this.global.Tree">defaultBody</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407984" title="PatternMatching.this.global.CaseDef">CaseDef</a> = <span class="delimiter">{</span> <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._; <a href="../../../reflect/internal/Positions.scala.html#408315" title="(pos: PatternMatching.this.global.Position)(tree: PatternMatching.this.global.CaseDef)PatternMatching.this.global.CaseDef">atPos</a><span class="delimiter">(</span><a href="#1093369" title="PatternMatching.this.global.Tree">body</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624584" title="(pat: PatternMatching.this.global.Tree)PatternMatching.this.CODE.CaseStart">CASE</a> <span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#408115" title="(sym: PatternMatching.this.global.Symbol, body: PatternMatching.this.global.Tree)PatternMatching.this.global.Bind">Bind</a><span class="delimiter">(</span><a href="#1093367" title="PatternMatching.this.global.Symbol">scrutSym</a>, <a href="../../../reflect/internal/Trees.scala.html#453846" title="(expr: PatternMatching.this.global.Tree, tpt: PatternMatching.this.global.Tree)PatternMatching.this.global.Typed">Typed</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#418125" title="(name: PatternMatching.this.global.Name)PatternMatching.this.global.Ident">Ident</a><span class="delimiter">(</span><a href="../../../reflect/internal/StdNames.scala.html#407871" title="PatternMatching.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/StdNames.scala.html#413714" title="=&gt; PatternMatching.this.global.nme.NameType">WILDCARD</a><span class="delimiter">)</span>, <a href="../../../reflect/internal/Trees.scala.html#408087" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="../../../reflect/internal/Definitions.scala.html#408712" title="=&gt; PatternMatching.this.global.ClassSymbol">ThrowableClass</a>.<a href="../../../reflect/internal/Symbols.scala.html#411559" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#662967" title="(g: PatternMatching.this.global.Tree)PatternMatching.this.CODE.CaseStart">IF</a> <a href="#1093368" title="PatternMatching.this.global.Tree">guard</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#662968" title="(body: PatternMatching.this.global.Tree)PatternMatching.this.global.CaseDef">==&gt;</a> <a href="#1093369" title="PatternMatching.this.global.Tree">body</a>
      <span class="delimiter">}</span><span class="delimiter">}</span>
    <span class="delimiter">}</span>

    // TODO: drop null checks
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(bindersAndCases: List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])], pt: PatternMatching.this.global.Type)Option[List[PatternMatching.this.global.CaseDef]]" id="1069190">emitTypeSwitch</a><span class="delimiter">(</span><a title="List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])]" id="1093407">bindersAndCases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])]">List</a><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>, <a title="PatternMatching.this.global.Type" id="1093408">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#978" title="Option[List[PatternMatching.this.global.CaseDef]]">Option</a><span class="delimiter">[</span>List<span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[PatternMatching.this.global.CaseDef]" id="1093412">caseDefsWithDefault</a> = <a href="#1091896" title="(cases: List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])], pt: PatternMatching.this.global.Type)List[PatternMatching.this.global.CaseDef]">typeSwitchMaker</a><span class="delimiter">(</span><a href="#1093407" title="List[(PatternMatching.this.global.Symbol, List[SwitchEmission.this.TreeMaker])]">bindersAndCases</a>, <a href="#1093408" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span>
      <span title="Option[List[PatternMatching.this.global.CaseDef]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#1093412" title="List[PatternMatching.this.global.CaseDef]">caseDefsWithDefault</a> <a href="../../../collection/SeqLike.scala.html#58787" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../../../Option.scala.html#1585" title="None.type">None</a>
      <span class="keyword">else</span> <a href="../../../Option.scala.html#63128" title="(x: List[PatternMatching.this.global.CaseDef])Some[List[PatternMatching.this.global.CaseDef]]">Some</a><span class="delimiter">(</span><a href="#1093412" title="List[PatternMatching.this.global.CaseDef]">caseDefsWithDefault</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait OptimizedMatchMonadInterface extends Object with PatternMatching.this.MatchMonadInterface" id="621401">OptimizedMatchMonadInterface</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621385" title="PatternMatching.this.MatchMonadInterface">MatchMonadInterface</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type" id="1069192">inMatchMonad</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1093417">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a> = <a href="../../../reflect/internal/Definitions.scala.html#409029" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">optionType</a><span class="delimiter">(</span><a href="#1093417" title="PatternMatching.this.global.Type">tp</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type" id="1069193">pureType</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Type" id="1093420">tp</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>     = <a href="#1093420" title="PatternMatching.this.global.Type">tp</a>
    <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.ClassSymbol" id="1069194">matchMonadSym</a>      = <a href="../../../reflect/internal/Definitions.scala.html#408955" title="=&gt; PatternMatching.this.global.ClassSymbol">OptionClass</a>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait OptimizedCodegen extends Object with PatternMatching.this.CodegenCore with PatternMatching.this.TypedSubstitution with PatternMatching.this.OptimizedMatchMonadInterface" id="621402">OptimizedCodegen</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621389" title="PatternMatching.this.CodegenCore">CodegenCore</a> <span class="keyword">with</span> <a href="#621387" title="PatternMatching.this.TypedSubstitution">TypedSubstitution</a> <span class="keyword">with</span> <a href="#621401" title="PatternMatching.this.OptimizedMatchMonadInterface">OptimizedMatchMonadInterface</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; OptimizedCodegen.this.AbsCodegen" id="1069196">codegen</a>: <a href="#1069015" title="OptimizedCodegen.this.AbsCodegen">AbsCodegen</a> = <a href="#1069197" title="OptimizedCodegen.this.optimizedCodegen.type">optimizedCodegen</a>

    // trait AbsOptimizedCodegen extends AbsCodegen {
    //   def flatMapCondStored(cond: Tree, condSym: Symbol, res: Tree, nextBinder: Symbol, next: Tree): Tree
    // }
    // def optimizedCodegen: AbsOptimizedCodegen

    // when we know we're targetting Option, do some inlining the optimizer won't do
    // for example, `o.flatMap(f)` becomes `if(o == None) None else f(o.get)`, similarly for orElse and guard
    //   this is a special instance of the advanced inlining optimization that takes a method call on
    //   an object of a type that only has two concrete subclasses, and inlines both bodies, guarded by an if to distinguish the two cases
    <span class="keyword">object</span> <a title="OptimizedCodegen.this.optimizedCodegen.type" id="1069197">optimizedCodegen</a> <a href="#1069198" title="OptimizedCodegen.this.optimizedCodegen.type" class="keyword">extends</a> <a href="#1069020" title="OptimizedCodegen.this.CommonCodegen">CommonCodegen</a> <span class="delimiter">{</span> <span class="keyword">import</span> <a href="../ast/TreeDSL.scala.html#538235" title="PatternMatching.this.CODE.type">CODE</a>._

      /** Inline runOrElse and get rid of Option allocations
       *
       * runOrElse(scrut: scrutTp)(matcher): resTp = matcher(scrut) getOrElse ${catchAll(`scrut`)}
       * the matcher's optional result is encoded as a flag, keepGoing, where keepGoing == true encodes result.isEmpty,
       * if keepGoing is false, the result Some(x) of the naive translation is encoded as matchRes == x
       */
      <span class="keyword">def</span> <a title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, restpe: PatternMatching.this.global.Type)(cases: List[OptimizedCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree], matchFailGen: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree])PatternMatching.this.global.Tree" id="1091427">matcher</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1093428">scrut</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1093429">scrutSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1093430">restpe</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="List[OptimizedCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree]" id="1093431">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[OptimizedCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Casegen =&gt; Tree<span class="delimiter">]</span>, <a title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]" id="1093432">matchFailGen</a>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree =&gt; Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="PatternMatching.this.global.MethodSymbol" id="1093435">matchEnd</a> = <a href="#1069014" title="(name: String)PatternMatching.this.global.MethodSymbol">newSynthCaseLabel</a><span class="delimiter">(</span><span title="String(&quot;matchEnd&quot;)" class="string">&quot;matchEnd&quot;</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="PatternMatching.this.global.TermSymbol" id="1093436">matchRes</a> = <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#411111" title="(name: PatternMatching.this.global.TermName, pos: PatternMatching.this.global.Position, newFlags: Long)PatternMatching.this.global.TermSymbol">newValueParameter</a><span class="delimiter">(</span><a href="../../../reflect/internal/Names.scala.html#406859" title="(s: String)PatternMatching.this.global.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;x&quot;)" class="string">&quot;x&quot;</span><span class="delimiter">)</span>, <a href="../../../reflect/internal/Positions.scala.html#408302" title="=&gt; reflect.internal.util.NoPosition.type">NoPosition</a>, <span title="Long(2097152L)">SYNTHETIC</span><span class="delimiter">)</span> <a href="../../../reflect/internal/Symbols.scala.html#411369" title="(info: PatternMatching.this.global.Type)PatternMatching.this.global.TermSymbol">setInfo</a> <a href="#1093430" title="PatternMatching.this.global.Type">restpe</a>.<a href="../../../reflect/internal/Types.scala.html#408510" title="=&gt; PatternMatching.this.global.Type">withoutAnnotations</a>
        <a href="#1093435" title="PatternMatching.this.global.MethodSymbol">matchEnd</a> <a href="../../../reflect/internal/Symbols.scala.html#411369" title="(info: PatternMatching.this.global.Type)matchEnd.type">setInfo</a> <a href="../../../reflect/internal/Types.scala.html#420479" title="(params: List[PatternMatching.this.global.Symbol], resultType: PatternMatching.this.global.Type)PatternMatching.this.global.MethodType">MethodType</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.TermSymbol*)List[PatternMatching.this.global.TermSymbol]">List</a><span class="delimiter">(</span><a href="#1093436" title="PatternMatching.this.global.TermSymbol">matchRes</a><span class="delimiter">)</span>, <a href="#1093430" title="PatternMatching.this.global.Type">restpe</a><span class="delimiter">)</span>

        <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.MethodSymbol" id="1093437">newCaseSym</a> = <a href="#1069014" title="(name: String)PatternMatching.this.global.MethodSymbol">newSynthCaseLabel</a><span class="delimiter">(</span><span title="String(&quot;case&quot;)" class="string">&quot;case&quot;</span><span class="delimiter">)</span> <a href="../../../reflect/internal/Symbols.scala.html#411369" title="(info: PatternMatching.this.global.Type)PatternMatching.this.global.MethodSymbol">setInfo</a> <a href="../../../reflect/internal/Types.scala.html#420479" title="(params: List[PatternMatching.this.global.Symbol], resultType: PatternMatching.this.global.Type)PatternMatching.this.global.MethodType">MethodType</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#1093430" title="PatternMatching.this.global.Type">restpe</a><span class="delimiter">)</span>
        <span class="keyword">var</span> <a title="PatternMatching.this.global.MethodSymbol" id="1093438">_currCase</a> = <a href="#1093437" title="=&gt; PatternMatching.this.global.MethodSymbol">newCaseSym</a>

        <span class="keyword">val</span> <a title="List[PatternMatching.this.global.LabelDef]" id="1093439">caseDefs</a> = <a href="#1093431" title="List[OptimizedCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree]">cases</a> <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: (OptimizedCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree) =&gt; PatternMatching.this.global.LabelDef)(implicit bf: scala.collection.generic.CanBuildFrom[List[OptimizedCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree],PatternMatching.this.global.LabelDef,List[PatternMatching.this.global.LabelDef]])List[PatternMatching.this.global.LabelDef]">map</a> <span class="delimiter">{</span> <span class="delimiter">(</span>mkCase: Casegen =&gt; Tree<span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="PatternMatching.this.global.MethodSymbol" id="1093480">currCase</a> = <a href="#1093438" title="PatternMatching.this.global.MethodSymbol">_currCase</a>
          <span class="keyword">val</span> <a title="PatternMatching.this.global.MethodSymbol" id="1093481">nextCase</a> = <a href="#1093437" title="=&gt; PatternMatching.this.global.MethodSymbol">newCaseSym</a>
          <a href="#1093438" title="PatternMatching.this.global.MethodSymbol">_currCase</a> = <a href="#1093481" title="PatternMatching.this.global.MethodSymbol">nextCase</a>

          <a href="../../../reflect/internal/Trees.scala.html#408113" title="(sym: PatternMatching.this.global.Symbol, params: List[PatternMatching.this.global.Symbol], rhs: PatternMatching.this.global.Tree)PatternMatching.this.global.LabelDef">LabelDef</a><span class="delimiter">(</span><a href="#1093480" title="PatternMatching.this.global.MethodSymbol">currCase</a>, <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="../../../Function1.scala.html#58642" title="(v1: OptimizedCodegen.this.Casegen)PatternMatching.this.global.Tree">mkCase</a><span class="delimiter">(</span><span title="scala.tools.nsc.typechecker.PatternMatching.OptimizedCodegen.optimizedCodegen.OptimizedCasegen" class="keyword">new</span> <a href="#1091428" title="scala.tools.nsc.typechecker.PatternMatching.OptimizedCodegen.optimizedCodegen.OptimizedCasegen">OptimizedCasegen</a><span class="delimiter">(</span><a href="#1093435" title="PatternMatching.this.global.MethodSymbol">matchEnd</a>, <a href="#1093481" title="PatternMatching.this.global.MethodSymbol">nextCase</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        // must compute catchAll after caseLabels (side-effects nextCase)
        // catchAll.isEmpty iff no synthetic default case needed (the (last) user-defined case is a default)
        // if the last user-defined case is a default, it will never jump to the next case; it will go immediately to matchEnd
        <span class="keyword">val</span> <a title="List[PatternMatching.this.global.LabelDef]" id="1093440">catchAllDef</a> = <a href="#1093432" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">matchFailGen</a> <a href="../../../Option.scala.html#62865" title="(f: (PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree) =&gt; PatternMatching.this.global.LabelDef)Option[PatternMatching.this.global.LabelDef]">map</a> <span class="delimiter">{</span> <a title="PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree" id="1093540">matchFailGen</a> =&gt;
          <span class="keyword">val</span> <a title="PatternMatching.this.global.gen.global.Tree" id="1093541">scrutRef</a> = <span title="PatternMatching.this.global.gen.global.Tree" class="keyword">if</span><span class="delimiter">(</span><a href="#1093429" title="PatternMatching.this.global.Symbol">scrutSym</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1093429" title="PatternMatching.this.global.Symbol">scrutSym</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../../reflect/internal/Trees.scala.html#407946" title="PatternMatching.this.global.EmptyTree.type">EmptyTree</a> // for alternatives

          <a href="../../../reflect/internal/Trees.scala.html#408113" title="(sym: PatternMatching.this.global.Symbol, params: List[PatternMatching.this.global.Symbol], rhs: PatternMatching.this.global.Tree)PatternMatching.this.global.LabelDef">LabelDef</a><span class="delimiter">(</span><a href="#1093438" title="PatternMatching.this.global.MethodSymbol">_currCase</a>, <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="../ast/TreeDSL.scala.html#624617" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethodsFromSymbol : (target: PatternMatching.this.global.Symbol)PatternMatching.this.CODE.TreeMethods">matchEnd</a> <a href="../ast/TreeDSL.scala.html#662336" title="(params: PatternMatching.this.global.Tree*)PatternMatching.this.global.Apply">APPLY</a> <span class="delimiter">(</span><a href="../../../Function1.scala.html#58642" title="(v1: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">matchFailGen</a><span class="delimiter">(</span><a href="#1093541" title="PatternMatching.this.global.gen.global.Tree">scrutRef</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span> <a href="../../../Option.scala.html#62894" title="=&gt; List[PatternMatching.this.global.LabelDef]">toList</a> // at most 1 element

        // scrutSym == NoSymbol when generating an alternatives matcher
        <span class="keyword">val</span> <a title="List[PatternMatching.this.global.ValDef]" id="1093441">scrutDef</a> = <span title="List[PatternMatching.this.global.ValDef]" class="keyword">if</span><span class="delimiter">(</span><a href="#1093429" title="PatternMatching.this.global.Symbol">scrutSym</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../../../reflect/internal/Symbols.scala.html#407184" title="=&gt; PatternMatching.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.ValDef*)List[PatternMatching.this.global.ValDef]">List</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624596" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.CODE.ValSymStart">VAL</a><span class="delimiter">(</span><a href="#1093429" title="PatternMatching.this.global.Symbol">scrutSym</a><span class="delimiter">)</span>  <a href="../ast/TreeDSL.scala.html#663071" title="(rhs: PatternMatching.this.global.Tree)PatternMatching.this.global.ValDef">===</a> <a href="#1093428" title="PatternMatching.this.global.Tree">scrut</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="../../../collection/immutable/List.scala.html#11188" title="scala.collection.immutable.Nil.type">Nil</a> // for alternatives

        // the generated block is taken apart in TailCalls under the following assumptions
          // the assumption is once we encounter a case, the remainder of the block will consist of cases
          // the prologue may be empty, usually it is the valdef that stores the scrut
          // val (prologue, cases) = stats span (s =&gt; !s.isInstanceOf[LabelDef])
        <a href="../../../reflect/internal/Trees.scala.html#453067" title="(stats: List[PatternMatching.this.global.Tree], expr: PatternMatching.this.global.Tree)PatternMatching.this.global.Block">Block</a><span class="delimiter">(</span>
          <a href="#1093441" title="List[PatternMatching.this.global.ValDef]">scrutDef</a> <a href="../../../collection/immutable/List.scala.html#62697" title="(that: scala.collection.GenTraversableOnce[PatternMatching.this.global.DefTree with Serializable{def name: PatternMatching.this.global.TermName}])(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.ValDef],PatternMatching.this.global.DefTree with Serializable{def name: PatternMatching.this.global.TermName},List[PatternMatching.this.global.DefTree with Serializable{def name: PatternMatching.this.global.TermName}]])List[PatternMatching.this.global.DefTree with Serializable{def name: PatternMatching.this.global.TermName}]">++</a> <a href="#1093439" title="List[PatternMatching.this.global.LabelDef]">caseDefs</a> <a href="../../../collection/immutable/List.scala.html#62697" title="(that: scala.collection.GenTraversableOnce[PatternMatching.this.global.DefTree with Serializable{def name: PatternMatching.this.global.TermName}])(implicit bf: scala.collection.generic.CanBuildFrom[List[PatternMatching.this.global.DefTree with Serializable{def name: PatternMatching.this.global.TermName}],PatternMatching.this.global.DefTree with Serializable{def name: PatternMatching.this.global.TermName},List[PatternMatching.this.global.DefTree with Serializable{def name: PatternMatching.this.global.TermName}]])List[PatternMatching.this.global.DefTree with Serializable{def name: PatternMatching.this.global.TermName}]">++</a> <a href="#1093440" title="List[PatternMatching.this.global.LabelDef]">catchAllDef</a>,
          <a href="../../../reflect/internal/Trees.scala.html#408113" title="(sym: PatternMatching.this.global.Symbol, params: List[PatternMatching.this.global.Symbol], rhs: PatternMatching.this.global.Tree)PatternMatching.this.global.LabelDef">LabelDef</a><span class="delimiter">(</span><a href="#1093435" title="PatternMatching.this.global.MethodSymbol">matchEnd</a>, <a href="../../../collection/immutable/List.scala.html#62451" title="(xs: PatternMatching.this.global.TermSymbol*)List[PatternMatching.this.global.TermSymbol]">List</a><span class="delimiter">(</span><a href="#1093436" title="PatternMatching.this.global.TermSymbol">matchRes</a><span class="delimiter">)</span>, <a href="../ast/TreeDSL.scala.html#624612" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.global.gen.global.Tree">REF</a><span class="delimiter">(</span><a href="#1093436" title="PatternMatching.this.global.TermSymbol">matchRes</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="keyword">class</span> <a title="class OptimizedCasegen extends OptimizedCodegen.this.CommonCodegen with OptimizedCodegen.this.Casegen" id="1091428">OptimizedCasegen</a><a href="#1091428" title="scala.tools.nsc.typechecker.PatternMatching.OptimizedCodegen.optimizedCodegen.OptimizedCasegen" class="delimiter">(</a><a title="PatternMatching.this.global.Symbol" id="1093496">matchEnd</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Symbol" id="1093497">nextCase</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#1069020" title="OptimizedCodegen.this.CommonCodegen">CommonCodegen</a> <span class="keyword">with</span> <a href="#1069016" title="OptimizedCodegen.this.Casegen">Casegen</a> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, restpe: PatternMatching.this.global.Type)(cases: List[OptimizedCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree], matchFailGen: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree])PatternMatching.this.global.Tree" id="1091434">matcher</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1093903">scrut</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1093904">scrutSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Type" id="1093905">restpe</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="List[OptimizedCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree]" id="1093906">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[OptimizedCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree]">List</a><span class="delimiter">[</span>Casegen =&gt; Tree<span class="delimiter">]</span>, <a title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]" id="1093907">matchFailGen</a>: <a href="../../../Option.scala.html#978" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree =&gt; Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> =
          <a href="#1069197" title="OptimizedCodegen.this.optimizedCodegen.type">optimizedCodegen</a>.<a href="#1091427" title="(scrut: PatternMatching.this.global.Tree, scrutSym: PatternMatching.this.global.Symbol, restpe: PatternMatching.this.global.Type)(cases: List[OptimizedCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree], matchFailGen: Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree])PatternMatching.this.global.Tree">matcher</a><span class="delimiter">(</span><a href="#1093903" title="PatternMatching.this.global.Tree">scrut</a>, <a href="#1093904" title="PatternMatching.this.global.Symbol">scrutSym</a>, <a href="#1093905" title="PatternMatching.this.global.Type">restpe</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1093906" title="List[OptimizedCodegen.this.Casegen =&gt; PatternMatching.this.global.Tree]">cases</a>, <a href="#1093907" title="Option[PatternMatching.this.global.Tree =&gt; PatternMatching.this.global.Tree]">matchFailGen</a><span class="delimiter">)</span>

        // only used to wrap the RHS of a body
        // res: T
        // returns MatchMonad[T]
        <span class="keyword">def</span> <a title="(res: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1091435">one</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1093913">res</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="../ast/TreeDSL.scala.html#624617" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethodsFromSymbol : (target: PatternMatching.this.global.Symbol)PatternMatching.this.CODE.TreeMethods">matchEnd</a> <a href="../ast/TreeDSL.scala.html#662336" title="(params: PatternMatching.this.global.Tree*)PatternMatching.this.global.Apply">APPLY</a> <span class="delimiter">(</span><a href="#1093913" title="PatternMatching.this.global.Tree">res</a><span class="delimiter">)</span> // a jump to a case label is special-cased in typedApply
        <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; PatternMatching.this.global.Tree" id="1091436">zero</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <a href="../ast/TreeDSL.scala.html#624617" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethodsFromSymbol : (target: PatternMatching.this.global.Symbol)PatternMatching.this.CODE.TreeMethods">nextCase</a> <a href="../ast/TreeDSL.scala.html#662336" title="(params: PatternMatching.this.global.Tree*)PatternMatching.this.global.Apply">APPLY</a> <span class="delimiter">(</span><span class="delimiter">)</span>

        // prev: MatchMonad[T]
        // b: T
        // next: MatchMonad[U]
        // returns MatchMonad[U]
        <span class="keyword">def</span> <a title="(prev: PatternMatching.this.global.Tree, b: PatternMatching.this.global.Symbol, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1091437">flatMap</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1093937">prev</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1093938">b</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Tree" id="1093939">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="PatternMatching.this.global.Type" id="1093941">tp</a>      = <a href="#1069192" title="(tp: PatternMatching.this.global.Type)PatternMatching.this.global.Type">inMatchMonad</a><span class="delimiter">(</span><a href="#1093938" title="PatternMatching.this.global.Symbol">b</a>.<a href="../../../reflect/internal/Symbols.scala.html#411365" title="=&gt; PatternMatching.this.global.Type">tpe</a><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="PatternMatching.this.global.TermSymbol" id="1093942">prevSym</a> = <a href="#1069013" title="(pos: PatternMatching.this.global.Position, tp: PatternMatching.this.global.Type, prefix: String)PatternMatching.this.global.TermSymbol">freshSym</a><span class="delimiter">(</span><a href="#1093937" title="PatternMatching.this.global.Tree">prev</a>.<a href="../../../reflect/internal/Trees.scala.html#408571" title="=&gt; PatternMatching.this.global.Position">pos</a>, <a href="#1093941" title="PatternMatching.this.global.Type">tp</a>, <span title="String(&quot;o&quot;)" class="string">&quot;o&quot;</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="1093943">isEmpty</a> = <a href="#1093941" title="PatternMatching.this.global.Type">tp</a> <a href="../../../reflect/internal/Types.scala.html#408451" title="(name: PatternMatching.this.global.Name)PatternMatching.this.global.Symbol">member</a> <a href="#621381" title="PatternMatching.this.vpmName.type">vpmName</a>.<a href="#1069373" title="=&gt; PatternMatching.this.global.TermName">isEmpty</a>
          <span class="keyword">val</span> <a title="PatternMatching.this.global.Symbol" id="1093944">get</a>     = <a href="#1093941" title="PatternMatching.this.global.Type">tp</a> <a href="../../../reflect/internal/Types.scala.html#408451" title="(name: PatternMatching.this.global.Name)PatternMatching.this.global.Symbol">member</a> <a href="#621381" title="PatternMatching.this.vpmName.type">vpmName</a>.<a href="#1069369" title="=&gt; PatternMatching.this.global.TermName">get</a>

          <a href="../ast/TreeDSL.scala.html#624607" title="(xs: PatternMatching.this.global.Tree*)PatternMatching.this.global.Block">BLOCK</a><span class="delimiter">(</span>
            <a href="../ast/TreeDSL.scala.html#624596" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.CODE.ValSymStart">VAL</a><span class="delimiter">(</span><a href="#1093942" title="PatternMatching.this.global.TermSymbol">prevSym</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#663071" title="(rhs: PatternMatching.this.global.Tree)PatternMatching.this.global.ValDef">===</a> <a href="#1093937" title="PatternMatching.this.global.Tree">prev</a>,
            // must be isEmpty and get as we don't control the target of the call (prev is an extractor call)
            <a href="#1073531" title="(c: PatternMatching.this.global.Tree, then: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">ifThenElseZero</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624608" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Select">NOT</a><span class="delimiter">(</span><a href="../ast/TreeDSL.scala.html#624617" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethodsFromSymbol : (target: PatternMatching.this.global.Symbol)PatternMatching.this.CODE.TreeMethods">prevSym</a> <a href="../ast/TreeDSL.scala.html#624619" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeFromSelectStart : (ss: PatternMatching.this.CODE.SelectStart)PatternMatching.this.global.Select">DOT</a> <a href="#1093943" title="PatternMatching.this.global.Symbol">isEmpty</a><span class="delimiter">)</span>, <a href="#1073001" title="(from: PatternMatching.this.global.Symbol, to: PatternMatching.this.global.Tree)OptimizedCodegen.this.Substitution">Substitution</a><a href="#1069977" title="(tree: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" class="delimiter">(</a><a href="#1093938" title="PatternMatching.this.global.Symbol">b</a>, <a href="../ast/TreeDSL.scala.html#624617" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethodsFromSymbol : (target: PatternMatching.this.global.Symbol)PatternMatching.this.CODE.TreeMethods">prevSym</a> <a href="../ast/TreeDSL.scala.html#624619" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeFromSelectStart : (ss: PatternMatching.this.CODE.SelectStart)PatternMatching.this.global.Select">DOT</a> <a href="#1093944" title="PatternMatching.this.global.Symbol">get</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#1093939" title="PatternMatching.this.global.Tree">next</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">)</span>
        <span class="delimiter">}</span>

        // cond: Boolean
        // res: T
        // nextBinder: T
        // next == MatchMonad[U]
        // returns MatchMonad[U]
        <span class="keyword">def</span> <a title="(cond: PatternMatching.this.global.Tree, res: PatternMatching.this.global.Tree, nextBinder: PatternMatching.this.global.Symbol, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1091438">flatMapCond</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1093988">cond</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Tree" id="1093989">res</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1093990">nextBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Tree" id="1093991">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> =
          <a href="#1073531" title="(c: PatternMatching.this.global.Tree, then: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">ifThenElseZero</a><span class="delimiter">(</span><a href="#1093988" title="PatternMatching.this.global.Tree">cond</a>, <a href="../ast/TreeDSL.scala.html#624607" title="(xs: PatternMatching.this.global.Tree*)PatternMatching.this.global.Block">BLOCK</a><span class="delimiter">(</span>
            <a href="../ast/TreeDSL.scala.html#624596" title="(sym: PatternMatching.this.global.Symbol)PatternMatching.this.CODE.ValSymStart">VAL</a><span class="delimiter">(</span><a href="#1093990" title="PatternMatching.this.global.Symbol">nextBinder</a><span class="delimiter">)</span> <a href="../ast/TreeDSL.scala.html#663071" title="(rhs: PatternMatching.this.global.Tree)PatternMatching.this.global.ValDef">===</a> <a href="#1093989" title="PatternMatching.this.global.Tree">res</a>,
            <a href="#1093991" title="PatternMatching.this.global.Tree">next</a>
          <span class="delimiter">)</span><span class="delimiter">)</span>

        // guardTree: Boolean
        // next: MatchMonad[T]
        // returns MatchMonad[T]
        <span class="keyword">def</span> <a title="(guardTree: PatternMatching.this.global.Tree, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1091439">flatMapGuard</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1094003">guardTree</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Tree" id="1094004">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> =
          <a href="#1073531" title="(c: PatternMatching.this.global.Tree, then: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">ifThenElseZero</a><span class="delimiter">(</span><a href="#1094003" title="PatternMatching.this.global.Tree">guardTree</a>, <a href="#1094004" title="PatternMatching.this.global.Tree">next</a><span class="delimiter">)</span>

        <span class="keyword">def</span> <a title="(cond: PatternMatching.this.global.Tree, condSym: PatternMatching.this.global.Symbol, res: PatternMatching.this.global.Tree, nextBinder: PatternMatching.this.global.Symbol, next: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree" id="1091440">flatMapCondStored</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Tree" id="1091441">cond</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1091442">condSym</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Tree" id="1091443">res</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a>, <a title="PatternMatching.this.global.Symbol" id="1091444">nextBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="PatternMatching.this.global.Tree" id="1091445">next</a>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#407938" title="PatternMatching.this.global.Tree">Tree</a> =
          <a href="#1073531" title="(c: PatternMatching.this.global.Tree, then: PatternMatching.this.global.Tree)PatternMatching.this.global.Tree">ifThenElseZero</a><span class="delimiter">(</span><a href="#1091441" title="PatternMatching.this.global.Tree">cond</a>, <a href="../ast/TreeDSL.scala.html#624607" title="(xs: PatternMatching.this.global.Tree*)PatternMatching.this.global.Block">BLOCK</a><span class="delimiter">(</span>
            <a href="../ast/TreeDSL.scala.html#624617" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethodsFromSymbol : (target: PatternMatching.this.global.Symbol)PatternMatching.this.CODE.TreeMethods">condSym</a>    <a href="../ast/TreeDSL.scala.html#662341" title="(rhs: PatternMatching.this.global.Tree)PatternMatching.this.global.Assign">===</a> <a href="../ast/TreeDSL.scala.html#624562" title="=&gt; PatternMatching.this.global.Literal">TRUE_typed</a>,
            <a href="../ast/TreeDSL.scala.html#624617" title="implicit scala.tools.nsc.ast.TreeDSL.CODE.mkTreeMethodsFromSymbol : (target: PatternMatching.this.global.Symbol)PatternMatching.this.CODE.TreeMethods">nextBinder</a> <a href="../ast/TreeDSL.scala.html#662341" title="(rhs: PatternMatching.this.global.Tree)PatternMatching.this.global.Assign">===</a> <a href="#1091443" title="PatternMatching.this.global.Tree">res</a>,
            <a href="#1091445" title="PatternMatching.this.global.Tree">next</a>
          <span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="delimiter">}</span>
  <span class="delimiter">}</span>


  <span class="keyword">trait</span> <a title="trait MatchOptimizations extends Object with PatternMatching.this.CommonSubconditionElimination with PatternMatching.this.DeadCodeElimination with PatternMatching.this.SwitchEmission with PatternMatching.this.OptimizedCodegen with PatternMatching.this.SymbolicMatchAnalysis with PatternMatching.this.DPLLSolver" id="621403">MatchOptimizations</a> <a href="../../../Unit.scala.html#1515" title="Unit" class="keyword">extends</a> <a href="#621398" title="PatternMatching.this.CommonSubconditionElimination">CommonSubconditionElimination</a>
                              <span class="keyword">with</span> <a href="#621399" title="PatternMatching.this.DeadCodeElimination">DeadCodeElimination</a>
                              <span class="keyword">with</span> <a href="#621400" title="PatternMatching.this.SwitchEmission">SwitchEmission</a>
                              <span class="keyword">with</span> <a href="#621402" title="PatternMatching.this.OptimizedCodegen">OptimizedCodegen</a>
                              <span class="keyword">with</span> <a href="#621397" title="PatternMatching.this.SymbolicMatchAnalysis">SymbolicMatchAnalysis</a>
                              <span class="keyword">with</span> <a href="#621396" title="PatternMatching.this.DPLLSolver">DPLLSolver</a> <span class="delimiter">{</span> self: TreeMakers =&gt;
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(prevBinder: PatternMatching.this.global.Symbol, cases: List[List[MatchOptimizations.this.TreeMaker]], pt: PatternMatching.this.global.Type, unchecked: Boolean)(List[List[MatchOptimizations.this.TreeMaker]], List[PatternMatching.this.global.Tree])" id="1069174">optimizeCases</a><span class="delimiter">(</span><a title="PatternMatching.this.global.Symbol" id="1094017">prevBinder</a>: <a href="../../../reflect/internal/Symbols.scala.html#407146" title="PatternMatching.this.global.Symbol">Symbol</a>, <a title="List[List[MatchOptimizations.this.TreeMaker]]" id="1094018">cases</a>: <a href="../../../collection/immutable/List.scala.html#11952" title="List[List[MatchOptimizations.this.TreeMaker]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="PatternMatching.this.global.Type" id="1094019">pt</a>: <a href="../../../reflect/internal/Types.scala.html#407270" title="PatternMatching.this.global.Type">Type</a>, <a title="Boolean" id="1094020">unchecked</a>: <a href="../../../Boolean.scala.html#1425" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="../../../Tuple2.scala.html#783" title="(List[List[MatchOptimizations.this.TreeMaker]], List[PatternMatching.this.global.Tree])" class="delimiter">(</a>List<span class="delimiter">[</span>List<span class="delimiter">[</span>TreeMaker<span class="delimiter">]</span><span class="delimiter">]</span>, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="../../../Boolean.scala.html#57822" title="=&gt; Boolean">!</a><a href="#1094020" title="Boolean">unchecked</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#1069220" title="(prevBinder: PatternMatching.this.global.Symbol, cases: List[List[MatchOptimizations.this.TreeMaker]], pt: PatternMatching.this.global.Type)Option[Int]">unreachableCase</a><span class="delimiter">(</span><a href="#1094017" title="PatternMatching.this.global.Symbol">prevBinder</a>, <a href="#1094018" title="List[List[MatchOptimizations.this.TreeMaker]]">cases</a>, <a href="#1094019" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span> <a href="../../../Option.scala.html#62884" title="(f: Int =&gt; Unit)Unit">foreach</a> <span class="delimiter">{</span> <a title="Int" id="1094036">caseIndex</a> =&gt;
          <a href="#1068982" title="(pos: PatternMatching.this.global.Position)Unit">reportUnreachable</a><span class="delimiter">(</span><a href="../../../collection/LinearSeqOptimized.scala.html#86374" title="(n: Int)List[MatchOptimizations.this.TreeMaker]">cases</a><span class="delimiter">(</span><a href="#1094036" title="Int">caseIndex</a><span class="delimiter">)</span>.<a href="../../../collection/LinearSeqOptimized.scala.html#86394" title="=&gt; MatchOptimizations.this.TreeMaker">last</a>.<a href="#1069808" title="=&gt; PatternMatching.this.global.Position">pos</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="keyword">val</span> <a title="List[String]" id="1094028">counterExamples</a> = <a href="#1069224" title="(prevBinder: PatternMatching.this.global.Symbol, cases: List[List[MatchOptimizations.this.TreeMaker]], pt: PatternMatching.this.global.Type)List[String]">exhaustive</a><span class="delimiter">(</span><a href="#1094017" title="PatternMatching.this.global.Symbol">prevBinder</a>, <a href="#1094018" title="List[List[MatchOptimizations.this.TreeMaker]]">cases</a>, <a href="#1094019" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#1094028" title="List[String]">counterExamples</a>.<a href="../../../collection/TraversableOnce.scala.html#58191" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span>
          <a href="#1068983" title="(pos: PatternMatching.this.global.Position, counterExamples: List[String])Unit">reportMissingCases</a><span class="delimiter">(</span><a href="#1094017" title="PatternMatching.this.global.Symbol">prevBinder</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#409602" title="=&gt; PatternMatching.this.global.Position">pos</a>, <a href="#1094028" title="List[String]">counterExamples</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="keyword">val</span> <a title="List[List[MatchOptimizations.this.TreeMaker]]" id="1094026">optCases</a> = <a href="#1069165" title="(prevBinder: PatternMatching.this.global.Symbol, cases: List[List[MatchOptimizations.this.TreeMaker]], pt: PatternMatching.this.global.Type)List[List[MatchOptimizations.this.TreeMaker]]">doCSE</a><span class="delimiter">(</span><a href="#1094017" title="PatternMatching.this.global.Symbol">prevBinder</a>, <a href="#1069181" title="(prevBinder: PatternMatching.this.global.Symbol, cases: List[List[MatchOptimizations.this.TreeMaker]], pt: PatternMatching.this.global.Type)List[List[MatchOptimizations.this.TreeMaker]]">doDCE</a><span class="delimiter">(</span><a href="#1094017" title="PatternMatching.this.global.Symbol">prevBinder</a>, <a href="#1094018" title="List[List[MatchOptimizations.this.TreeMaker]]">cases</a>, <a href="#1094019" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span>, <a href="#1094019" title="PatternMatching.this.global.Type">pt</a><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="List[PatternMatching.this.global.Tree]" id="1094027">toHoist</a> = <span class="delimiter">(</span>
        <span class="keyword">for</span> <span class="delimiter">(</span><a title="List[MatchOptimizations.this.TreeMaker]" id="1094071">treeMakers</a> &lt;- <a href="../../../collection/TraversableLike.scala.html#58063" title="(f: List[MatchOptimizations.this.TreeMaker] =&gt; List[List[PatternMatching.this.global.Tree]])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[MatchOptimizations.this.TreeMaker]],List[List[PatternMatching.this.global.Tree]],List[List[List[PatternMatching.this.global.Tree]]]])List[List[List[PatternMatching.this.global.Tree]]]">optCases</a><span class="delimiter">)</span>
          <span class="keyword">yield</span> <a href="#1094071" title="List[MatchOptimizations.this.TreeMaker]">treeMakers</a>.<a href="../../../collection/TraversableLike.scala.html#58075" title="(pf: PartialFunction[MatchOptimizations.this.TreeMaker,List[PatternMatching.this.global.Tree]])(implicit bf: scala.collection.generic.CanBuildFrom[List[MatchOptimizations.this.TreeMaker],List[PatternMatching.this.global.Tree],List[List[PatternMatching.this.global.Tree]]])List[List[PatternMatching.this.global.Tree]]">collect</a><a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[MatchOptimizations.this.TreeMaker,List[PatternMatching.this.global.Tree]] with Serializable" id="1094091" class="delimiter">{</a><span class="keyword">case</span> <a href="#3370655" title="B1" id="3370668">tm</a>: ReusedCondTreeMaker =&gt; tm.<a href="#3370661" title="(x: B1)B1">treesToHoist</a><span class="delimiter">}</span>
        <span class="delimiter">)</span>.<a href="../../../collection/generic/GenericTraversableTemplate.scala.html#58488" title="(implicit asTraversable: List[List[PatternMatching.this.global.Tree]] =&gt; scala.collection.GenTraversableOnce[List[PatternMatching.this.global.Tree]])List[List[PatternMatching.this.global.Tree]]">flatten</a>.<a href="../../../collection/generic/GenericTraversableTemplate.scala.html#58488" title="(implicit asTraversable: List[PatternMatching.this.global.Tree] =&gt; scala.collection.GenTraversableOnce[PatternMatching.this.global.Tree])List[PatternMatching.this.global.Tree]">flatten</a>.<a href="../../../collection/immutable/List.scala.html#62707" title="=&gt; List[PatternMatching.this.global.Tree]">toList</a>
      <a href="../../../Tuple2.scala.html#62849" title="(_1: List[List[MatchOptimizations.this.TreeMaker]], _2: List[PatternMatching.this.global.Tree])(List[List[MatchOptimizations.this.TreeMaker]], List[PatternMatching.this.global.Tree])" class="delimiter">(</a><a href="#1094026" title="List[List[MatchOptimizations.this.TreeMaker]]">optCases</a>, <a href="#1094027" title="List[PatternMatching.this.global.Tree]">toHoist</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="scala.tools.nsc.typechecker.PatternMatchingStats.type" id="45753">PatternMatchingStats</a> <a href="#45754" title="scala.tools.nsc.typechecker.PatternMatchingStats.type" class="delimiter">{</a>
  <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.Timer" id="624634">patmatNanos</a>         = <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415240" title="(prefix: String, phases: String*)scala.reflect.internal.util.Statistics.Timer">newTimer</a>     <span class="delimiter">(</span><span title="String(&quot;time spent in patmat&quot;)" class="string">&quot;time spent in patmat&quot;</span>, <span title="String(&quot;patmat&quot;)" class="string">&quot;patmat&quot;</span><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.Timer" id="624636">patmatAnaDPLL</a>       = <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415241" title="(prefix: String, timer: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.Timer">newSubTimer</a>  <span class="delimiter">(</span><span title="String(&quot;  of which DPLL&quot;)" class="string">&quot;  of which DPLL&quot;</span>, <a href="#624634" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatNanos</a><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.Timer" id="624638">patmatCNF</a>           = <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415241" title="(prefix: String, timer: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.Timer">newSubTimer</a>  <span class="delimiter">(</span><span title="String(&quot;  of which in CNF conversion&quot;)" class="string">&quot;  of which in CNF conversion&quot;</span>, <a href="#624634" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatNanos</a><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.QuantMap[Int,scala.reflect.internal.util.Statistics.Counter]" id="624640">patmatCNFSizes</a>      = <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415244" title="[K, V](prefix: String, phases: String*)(initValue: =&gt; V)(implicit evidence$1: V =&gt; Ordered[V])scala.reflect.internal.util.Statistics.QuantMap[K,V]">newQuantMap</a><span title="(prefix: String, phases: String*)(initValue: =&gt; scala.reflect.internal.util.Statistics.Counter)(implicit evidence$1: scala.reflect.internal.util.Statistics.Counter =&gt; Ordered[scala.reflect.internal.util.Statistics.Counter])scala.reflect.internal.util.Statistics.QuantMap[Int,scala.reflect.internal.util.Statistics.Counter]" class="delimiter">[</span><a href="../../../Int.scala.html#321" title="Int">Int</a>, Statistics.<a href="../../../reflect/internal/util/Statistics.scala.html#415257" title="scala.reflect.internal.util.Statistics.Counter">Counter</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="String(&quot;  CNF size counts&quot;)" class="string">&quot;  CNF size counts&quot;</span>, <span title="String(&quot;patmat&quot;)" class="string">&quot;patmat&quot;</span><span class="delimiter">)</span><a href="../../../Predef.scala.html#7614" title="&lt;:&lt;[scala.reflect.internal.util.Statistics.Counter,scala.reflect.internal.util.Statistics.Counter]" class="delimiter">(</a><a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415237" title="(prefix: String, phases: String*)scala.reflect.internal.util.Statistics.Counter">newCounter</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.Timer" id="624642">patmatAnaVarEq</a>      = <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415241" title="(prefix: String, timer: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.Timer">newSubTimer</a>  <span class="delimiter">(</span><span title="String(&quot;  of which variable equality&quot;)" class="string">&quot;  of which variable equality&quot;</span>, <a href="#624634" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatNanos</a><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.Timer" id="624644">patmatAnaExhaust</a>    = <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415241" title="(prefix: String, timer: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.Timer">newSubTimer</a>  <span class="delimiter">(</span><span title="String(&quot;  of which in exhaustivity&quot;)" class="string">&quot;  of which in exhaustivity&quot;</span>, <a href="#624634" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatNanos</a><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="scala.reflect.internal.util.Statistics.Timer" id="624646">patmatAnaReach</a>      = <a href="../../../reflect/internal/util/Statistics.scala.html#22672" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../reflect/internal/util/Statistics.scala.html#415241" title="(prefix: String, timer: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.Timer">newSubTimer</a>  <span class="delimiter">(</span><span title="String(&quot;  of which in unreachability&quot;)" class="string">&quot;  of which in unreachability&quot;</span>, <a href="#624634" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatNanos</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>