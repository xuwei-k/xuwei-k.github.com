<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/collection/immutable/List.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2003-2013, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

package scala
package collection
package immutable

import generic._
import mutable.<span class="delimiter">{</span>Builder, ListBuffer<span class="delimiter">}</span>
import scala.annotation.tailrec
import java.io._

<span class="comment">/** A class for immutable linked lists representing ordered collections
 *  of elements of type.
 *
 *  This class comes with two implementing case classes `scala.Nil`
 *  and `scala.::` that implement the abstract members `isEmpty`,
 *  `head` and `tail`.
 *
 *  This class is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access
 *  pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.
 *
 *  @example {{{
 *  // Make a list via the companion object factory
 *  val days = List(&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;)
 *
 *  // Make a list element-by-element
 *  val when = &quot;AM&quot; :: &quot;PM&quot; :: List()
 *
 *  // Pattern match
 *  days match {
 *    case firstDay :: otherDays =&gt;
 *      println(&quot;The first day of the week is: &quot; + firstDay)
 *    case List() =&gt;
 *      println(&quot;There don't seem to be any week days.&quot;)
 *  }
 *  }}}
 *
 *  ==Performance==
 *  '''Time:''' `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list.
 *  This includes the index-based lookup of elements, `length`, `append` and `reverse`.
 *
 *  '''Space:''' `List` implements '''structural sharing''' of the tail list. This means that many operations are either
 *  zero- or constant-memory cost.
 *  {{{
 *  val mainList = List(3, 2, 1)
 *  val with4 =    4 :: mainList  // re-uses mainList, costs one :: instance
 *  val with42 =   42 :: mainList // also re-uses mainList, cost one :: instance
 *  val shorter =  mainList.tail  // costs nothing as it uses the same 2::1::Nil instances as mainList
 *  }}}
 *
 *  @note The functional list is characterized by persistence and structural sharing, thus offering considerable
 *        performance and space consumption benefits in some scenarios if used correctly.
 *        However, note that objects having multiple references into the same functional list (that is,
 *        objects that rely on structural sharing), will be serialized and deserialized with multiple lists, one for
 *        each reference to it. I.e. structural sharing is lost after serialization/deserialization.
 *
 *  @author  Martin Odersky and others
 *  @version 2.8
 *  @since   1.0
 *  @see  [[http://docs.scala-lang.org/overviews/collections/concrete-immutable-collection-classes.html#lists &quot;Scala's Collection Library overview&quot;]]
 *  section on `Lists` for more information.
 *
 *  @define coll list
 *  @define Coll `List`
 *  @define thatinfo the class of the returned collection. In the standard library configuration,
 *    `That` is always `List[B]` because an implicit of type `CanBuildFrom[List, B, That]`
 *    is defined in object `List`.
 *  @define bfinfo an implicit value of class `CanBuildFrom` which determines the
 *    result class `That` from the current representation type `Repr`
 *    and the new element type `B`. This is usually the `canBuildFrom` value
 *    defined in object `List`.
 *  @define orderDependent
 *  @define orderDependentFold
 *  @define mayNotTerminateInf
 *  @define willNotTerminateInf
 */</span>
sealed abstract class <a title="class List[+A] extends scala.collection.AbstractSeq[A] with scala.collection.immutable.LinearSeq[A] with Product with scala.collection.generic.GenericTraversableTemplate[A,List] with scala.collection.LinearSeqOptimized[A,List[A]] with java.io.Serializable" id="scala.collection.immutable;List">List</a><span class="delimiter">[</span>+<a title="" id="scala.collection.immutable;List;A">A</a><span class="delimiter">]</span> extends <a href="../Seq.scala.html#scala.collection;AbstractSeq" title="scala.collection.AbstractSeq[A]">AbstractSeq</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
                                  with <a href="LinearSeq.scala.html#scala.collection.immutable;LinearSeq" title="scala.collection.immutable.LinearSeq[A]">LinearSeq</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
                                  with <a href="../../Product.scala.html#scala;Product" title="Product">Product</a>
                                  with <a href="../generic/GenericTraversableTemplate.scala.html#scala.collection.generic;GenericTraversableTemplate" title="scala.collection.generic.GenericTraversableTemplate[A,List]">GenericTraversableTemplate</a><span class="delimiter">[</span>A, List<span class="delimiter">]</span>
                                  with <a href="../LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized" title="scala.collection.LinearSeqOptimized[A,List[A]]">LinearSeqOptimized</a><span class="delimiter">[</span>A, List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>
                                  with <span title="java.io.Serializable">Serializable</span> <span class="delimiter">{</span>
  override def <a title="=&gt; scala.collection.generic.GenericCompanion[List]" id="scala.collection.immutable;List.companion">companion</a>: <a href="../generic/GenericCompanion.scala.html#scala.collection.generic;GenericCompanion" title="scala.collection.generic.GenericCompanion[List]">GenericCompanion</a><span class="delimiter">[</span>List<span class="delimiter">]</span> = <a href="#scala.collection.immutable.List.readResolve" title="scala.collection.immutable.List.type">List</a>

  import scala.collection.<span class="delimiter">{</span>Iterable, Traversable, Seq, IndexedSeq<span class="delimiter">}</span>

  def <a title="=&gt; Boolean" id="scala.collection.immutable;List.isEmpty">isEmpty</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>
  def <a title="=&gt; A" id="scala.collection.immutable;List.head">head</a>: <a href="#scala.collection.immutable;List;A" title="A">A</a>
  def <a title="=&gt; List[A]" id="scala.collection.immutable;List.tail">tail</a>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  <span class="comment">// New methods in List</span>

  <span class="comment">/** Adds an element at the beginning of this list.
   *  @param x the element to prepend.
   *  @return  a list which contains `x` as first element and
   *           which continues with this list.
   *
   *  @usecase def ::(x: A): List[A]
   *    @inheritdoc
   *
   *    Example:
   *    {{{1 :: List(2, 3) = List(2, 3).::(1) = List(1, 2, 3)}}}
   */</span>
  def <a title="[B &gt;: A](x: B)List[B]" id="scala.collection.immutable;List.::">::</a><span class="delimiter">[</span><a title=" &gt;: A" id="scala.collection.immutable;List.::;B">B</a> &gt;: A<span class="delimiter">]</span> <span class="delimiter">(</span><a title="B" id="scala.collection.immutable;List.::.x">x</a>: <a href="#scala.collection.immutable;List.::;B" title="B">B</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List" title="List[B]">List</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
    new scala.collection.immutable.<a href="#scala.collection.immutable.::.readResolve" title="scala.collection.immutable.::[B]">::</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.::.x" title="B">x</a>, this<span class="delimiter">)</span>

  <span class="comment">/** Adds the elements of a given list in front of this list.
   *  @param prefix  The list elements to prepend.
   *  @return a list resulting from the concatenation of the given
   *    list `prefix` and this list.
   *
   *  @usecase def :::(prefix: List[A]): List[A]
   *    @inheritdoc
   *
   *    Example:
   *    {{{List(1, 2) ::: List(3, 4) = List(3, 4).:::(List(1, 2)) = List(1, 2, 3, 4)}}}
   */</span>
  def <a title="[B &gt;: A](prefix: List[B])List[B]" id="scala.collection.immutable;List.:::">:::</a><span class="delimiter">[</span><a title=" &gt;: A" id="scala.collection.immutable;List.:::;B">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="List[B]" id="scala.collection.immutable;List.:::.prefix">prefix</a>: <a href="#scala.collection.immutable;List" title="List[B]">List</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List" title="List[B]">List</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;List.:::.prefix" title="List[B]">prefix</a>
    else if <span class="delimiter">(</span><a href="#scala.collection.immutable;List.:::.prefix" title="List[B]">prefix</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> this
    else <span class="delimiter">(</span>new <a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer" title="scala.collection.mutable.ListBuffer[B]">ListBuffer</a><span class="delimiter">[</span>B<span class="delimiter">]</span> <a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.++=" title="(xs: scala.collection.TraversableOnce[B])scala.collection.mutable.ListBuffer[B]">++=</a> <a href="#scala.collection.immutable;List.:::.prefix" title="List[B]">prefix</a><span class="delimiter">)</span>.<a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.prependToList" title="(xs: List[B])List[B]">prependToList</a><span class="delimiter">(</span>this<span class="delimiter">)</span>

  <span class="comment">/** Adds the elements of a given list in reverse order in front of this list.
   *  `xs reverse_::: ys` is equivalent to
   *  `xs.reverse ::: ys` but is more efficient.
   *
   *  @param prefix the prefix to reverse and then prepend
   *  @return       the concatenation of the reversed prefix and the current list.
   *
   *  @usecase def reverse_:::(prefix: List[A]): List[A]
   *    @inheritdoc
   */</span>
  def <a title="[B &gt;: A](prefix: List[B])List[B]" id="scala.collection.immutable;List.reverse_:::">reverse_:::</a><span class="delimiter">[</span><a title=" &gt;: A" id="scala.collection.immutable;List.reverse_:::;B">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="List[B]" id="scala.collection.immutable;List.reverse_:::.prefix">prefix</a>: <a href="#scala.collection.immutable;List" title="List[B]">List</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List" title="List[B]">List</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <span class="delimiter">{</span>
    var <a title="List[B]" id="scala.collection.immutable;List.reverse_:::.these">these</a>: <a href="#scala.collection.immutable;List" title="List[B]">List</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = this
    var <a title="List[B]" id="scala.collection.immutable;List.reverse_:::.pres">pres</a> = <a href="#scala.collection.immutable;List.reverse_:::.prefix" title="List[B]">prefix</a>
    while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;List.reverse_:::.pres" title="List[B]">pres</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;List.reverse_:::.while$1" title="()Unit" class="delimiter">{</a>
      <a href="#scala.collection.immutable;List.reverse_:::.these" title="List[B]">these</a> = <a href="#scala.collection.immutable;List.reverse_:::.pres" title="List[B]">pres</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; B">head</a> <a href="#scala.collection.immutable;List.::" title="(x: B)List[B]">::</a> <a href="#scala.collection.immutable;List.reverse_:::.these" title="List[B]">these</a>
      <a href="#scala.collection.immutable;List.reverse_:::.pres" title="List[B]">pres</a> = <a href="#scala.collection.immutable;List.reverse_:::.pres" title="List[B]">pres</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[B]">tail</a>
    <span class="delimiter">}</span>
    <a href="#scala.collection.immutable;List.reverse_:::.these" title="List[B]">these</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Builds a new list by applying a function to all elements of this list.
   *  Like `xs map f`, but returns `xs` unchanged if function
   *  `f` maps all elements to themselves (as determined by `eq`).
   *
   *  @param f      the function to apply to each element.
   *  @tparam B     the element type of the returned collection.
   *  @return       a list resulting from applying the given function
   *                `f` to each element of this list and collecting the results.
   *
   *  @usecase def mapConserve(f: A =&gt; A): List[A]
   *    @inheritdoc
   */</span>
  @inline final def <a title="[B &gt;: A &lt;: AnyRef](f: A =&gt; B)List[B]" id="scala.collection.immutable;List.mapConserve">mapConserve</a><span class="delimiter">[</span><a title=" &gt;: A &lt;: AnyRef" id="scala.collection.immutable;List.mapConserve;B">B</a> &gt;: A &lt;: AnyRef<span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scala.collection.immutable;List.mapConserve.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#scala.collection.immutable;List" title="List[B]">List</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">// Note to developers: there exists a duplication between this function and `reflect.internal.util.Collections#map2Conserve`.</span>
    <span class="comment">// If any successful optimization attempts or other changes are made, please rehash them there too.</span>
    @tailrec
    def <a title="(mapped: scala.collection.mutable.ListBuffer[B], unchanged: List[A], pending: List[A])List[B]" id="scala.collection.immutable;List.mapConserve.loop">loop</a><span class="delimiter">(</span><a title="scala.collection.mutable.ListBuffer[B]" id="scala.collection.immutable;List.mapConserve.loop.mapped">mapped</a>: <a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer" title="scala.collection.mutable.ListBuffer[B]">ListBuffer</a><span class="delimiter">[</span>B<span class="delimiter">]</span>, <a title="List[A]" id="scala.collection.immutable;List.mapConserve.loop.unchanged">unchanged</a>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="List[A]" id="scala.collection.immutable;List.mapConserve.loop.pending">pending</a>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List" title="List[B]">List</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#scala.collection.immutable;List.mapConserve.loop.pending" title="List[A]">pending</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#scala.collection.immutable;List.mapConserve.loop.mapped" title="scala.collection.mutable.ListBuffer[B]">mapped</a> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span> <a href="#scala.collection.immutable;List.mapConserve.loop.unchanged" title="List[A]">unchanged</a>
        else <a href="#scala.collection.immutable;List.mapConserve.loop.mapped" title="scala.collection.mutable.ListBuffer[B]">mapped</a>.<a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.prependToList" title="(xs: List[B])List[B]">prependToList</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.mapConserve.loop.unchanged" title="List[A]">unchanged</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      else <span class="delimiter">{</span>
        val <a title="A" id="scala.collection.immutable;List.mapConserve.loop.head0">head0</a> = <a href="#scala.collection.immutable;List.mapConserve.loop.pending" title="List[A]">pending</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>
        val <a title="B" id="scala.collection.immutable;List.mapConserve.loop.head1">head1</a> = <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.mapConserve.loop.head0" title="A">head0</a><span class="delimiter">)</span>

        if <span class="delimiter">(</span><a href="#scala.collection.immutable;List.mapConserve.loop.head1" title="B">head1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.collection.immutable;List.mapConserve.loop.head0" title="A">head0</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="AnyRef" class="delimiter">[</span><span title="AnyRef">AnyRef</span><span class="delimiter">]</span><span class="delimiter">)</span>
          <a href="#scala.collection.immutable;List.mapConserve.loop" title="(mapped: scala.collection.mutable.ListBuffer[B], unchanged: List[A], pending: List[A])List[B]">loop</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.mapConserve.loop.mapped" title="scala.collection.mutable.ListBuffer[B]">mapped</a>, <a href="#scala.collection.immutable;List.mapConserve.loop.unchanged" title="List[A]">unchanged</a>, <a href="#scala.collection.immutable;List.mapConserve.loop.pending" title="List[A]">pending</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a><span class="delimiter">)</span>
        else <span class="delimiter">{</span>
          val <a title="scala.collection.mutable.ListBuffer[B]" id="scala.collection.immutable;List.mapConserve.loop.b">b</a> = if <span class="delimiter">(</span><a href="#scala.collection.immutable;List.mapConserve.loop.mapped" title="scala.collection.mutable.ListBuffer[B]">mapped</a> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span> new <a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer" title="scala.collection.mutable.ListBuffer[B]">ListBuffer</a><span class="delimiter">[</span>B<span class="delimiter">]</span> else <a href="#scala.collection.immutable;List.mapConserve.loop.mapped" title="scala.collection.mutable.ListBuffer[B]">mapped</a>
          var <a title="List[A]" id="scala.collection.immutable;List.mapConserve.loop.xc">xc</a> = <a href="#scala.collection.immutable;List.mapConserve.loop.unchanged" title="List[A]">unchanged</a>
          while <span class="delimiter">(</span><a href="#scala.collection.immutable;List.mapConserve.loop.xc" title="List[A]">xc</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.collection.immutable;List.mapConserve.loop.pending" title="List[A]">pending</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;List.mapConserve.loop.while$2" title="()Unit" class="delimiter">{</a>
            <a href="#scala.collection.immutable;List.mapConserve.loop.b" title="scala.collection.mutable.ListBuffer[B]">b</a> <a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.+=(f93df146a4)" title="(x: B)b.type">+=</a> <a href="#scala.collection.immutable;List.mapConserve.loop.xc" title="List[A]">xc</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>
            <a href="#scala.collection.immutable;List.mapConserve.loop.xc" title="List[A]">xc</a> = <a href="#scala.collection.immutable;List.mapConserve.loop.xc" title="List[A]">xc</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
          <span class="delimiter">}</span>
          <a href="#scala.collection.immutable;List.mapConserve.loop.b" title="scala.collection.mutable.ListBuffer[B]">b</a> <a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.+=(f93df146a4)" title="(x: B)b.type">+=</a> <a href="#scala.collection.immutable;List.mapConserve.loop.head1" title="B">head1</a>
          val <a title="List[A]" id="scala.collection.immutable;List.mapConserve.loop.tail0">tail0</a> = <a href="#scala.collection.immutable;List.mapConserve.loop.pending" title="List[A]">pending</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
          <a href="#scala.collection.immutable;List.mapConserve.loop" title="(mapped: scala.collection.mutable.ListBuffer[B], unchanged: List[A], pending: List[A])List[B]">loop</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.mapConserve.loop.b" title="scala.collection.mutable.ListBuffer[B]">b</a>, <a href="#scala.collection.immutable;List.mapConserve.loop.tail0" title="List[A]">tail0</a>, <a href="#scala.collection.immutable;List.mapConserve.loop.tail0" title="List[A]">tail0</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <a href="#scala.collection.immutable;List.mapConserve.loop" title="(mapped: scala.collection.mutable.ListBuffer[B], unchanged: List[A], pending: List[A])List[B]">loop</a><span class="delimiter">(</span>null, this, this<span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// Overridden methods from IterableLike and SeqLike or overloaded variants of such methods</span>

  override def <a title="[B &gt;: A, That](that: scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That])That" id="scala.collection.immutable;List.++">++</a><span class="delimiter">[</span><a title=" &gt;: A" id="scala.collection.immutable;List.++;B">B</a> &gt;: A, <a title="" id="scala.collection.immutable;List.++;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.collection.GenTraversableOnce[B]" id="scala.collection.immutable;List.++.that">that</a>: <a href="../GenTraversableOnce.scala.html#scala.collection;GenTraversableOnce" title="scala.collection.GenTraversableOnce[B]">GenTraversableOnce</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[List[A],B,That]" id="scala.collection.immutable;List.++.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[List[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List.++;That" title="That">That</a> =
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;List.++.bf" title="scala.collection.generic.CanBuildFrom[List[A],B,That]">bf</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.collection.immutable.List.readResolve" title="scala.collection.immutable.List.type">List</a>.<a href="../generic/GenTraversableFactory.scala.html#scala.collection.generic;GenTraversableFactory.ReusableCBF" title="=&gt; scala.collection.immutable.List.GenericCanBuildFrom[Nothing]">ReusableCBF</a><span class="delimiter">)</span> <span class="delimiter">(</span>this <a href="#scala.collection.immutable;List.:::" title="(prefix: List[B])List[B]">:::</a> <a href="#scala.collection.immutable;List.++.that" title="scala.collection.GenTraversableOnce[B]">that</a>.<a href="../GenTraversableOnce.scala.html#scala.collection;GenTraversableOnce.seq" title="=&gt; scala.collection.TraversableOnce[B]">seq</a>.<a href="../TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[B]">toList</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="That" class="delimiter">[</span><a href="#scala.collection.immutable;List.++;That" title="That">That</a><span class="delimiter">]</span>
    else super.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.++" title="(that: scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That])That">++</a><a href="#scala.collection.immutable;List.++.bf" title="scala.collection.generic.CanBuildFrom[List[A],B,That]" class="delimiter">(</a><a href="#scala.collection.immutable;List.++.that" title="scala.collection.GenTraversableOnce[B]">that</a><span class="delimiter">)</span>

  override def <a title="[B &gt;: A, That](elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That])That" id="scala.collection.immutable;List.+:">+:</a><span class="delimiter">[</span><a title=" &gt;: A" id="scala.collection.immutable;List.+:;B">B</a> &gt;: A, <a title="" id="scala.collection.immutable;List.+:;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scala.collection.immutable;List.+:.elem">elem</a>: <a href="#scala.collection.immutable;List.+:;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[List[A],B,That]" id="scala.collection.immutable;List.+:.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[List[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List.+:;That" title="That">That</a> = <a href="#scala.collection.immutable;List.+:.bf" title="scala.collection.generic.CanBuildFrom[List[A],B,That]">bf</a> match <span class="delimiter">{</span>
    case _: List.<a href="../generic/GenTraversableFactory.scala.html#scala.collection.generic;GenTraversableFactory;GenericCanBuildFrom" title="scala.collection.immutable.List.GenericCanBuildFrom[_]">GenericCanBuildFrom</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <span class="delimiter">(</span><a href="#scala.collection.immutable;List.+:.elem" title="B">elem</a> <a href="#scala.collection.immutable;List.::" title="(x: B)List[B]">::</a> this<span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="That" class="delimiter">[</span><a href="#scala.collection.immutable;List.+:;That" title="That">That</a><span class="delimiter">]</span>
    case _ =&gt; super.<a href="../SeqLike.scala.html#scala.collection;SeqLike.+:" title="(elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That])That">+:</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.+:.elem" title="B">elem</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable;List.+:.bf" title="scala.collection.generic.CanBuildFrom[List[A],B,That]">bf</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  override def <a title="=&gt; List[A]" id="scala.collection.immutable;List.toList">toList</a>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = this

  override def <a title="(n: Int)List[A]" id="scala.collection.immutable;List.take">take</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable;List.take.n">n</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = if <span class="delimiter">(</span><a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.collection.immutable;List.take.n" title="Int">n</a> <a href="../../Int.scala.html#scala;Int.<=(5f58a84eb3)" title="(x: Int)Boolean">&lt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a> else <span class="delimiter">{</span>
    val <a title="scala.collection.immutable.::[A]" id="scala.collection.immutable;List.take.h">h</a> = new <a href="#scala.collection.immutable.::.readResolve" title="scala.collection.immutable.::[A]">::</a><span class="delimiter">(</span><a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
    var <a title="scala.collection.immutable.::[A]" id="scala.collection.immutable;List.take.t">t</a> = <a href="#scala.collection.immutable;List.take.h" title="scala.collection.immutable.::[A]">h</a>
    var <a title="List[A]" id="scala.collection.immutable;List.take.rest">rest</a> = <a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
    var <a title="Int" id="scala.collection.immutable;List.take.i">i</a> = <span title="Int(1)" class="int">1</span>
    while <span class="delimiter">(</span><span class="delimiter">{</span>if <span class="delimiter">(</span><a href="#scala.collection.immutable;List.take.rest" title="List[A]">rest</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> return this; <a href="#scala.collection.immutable;List.take.i" title="Int">i</a> <a href="../../Int.scala.html#scala;Int.<(5f58a84eb3)" title="(x: Int)Boolean">&lt;</a> <a href="#scala.collection.immutable;List.take.n" title="Int">n</a><span class="delimiter">}</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;List.take.while$3" title="()Unit" class="delimiter">{</a>
      <a href="#scala.collection.immutable;List.take.i" title="Int">i</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
      val <a title="scala.collection.immutable.::[A]" id="scala.collection.immutable;List.take.nx">nx</a> = new <a href="#scala.collection.immutable.::.readResolve" title="scala.collection.immutable.::[A]">::</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.take.rest" title="List[A]">rest</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
      <a href="#scala.collection.immutable;List.take.t" title="scala.collection.immutable.::[A]">t</a>.<a href="#scala.collection.immutable;::.tl" title="(x$1: List[A])Unit">tl</a> = <a href="#scala.collection.immutable;List.take.nx" title="scala.collection.immutable.::[A]">nx</a>
      <a href="#scala.collection.immutable;List.take.t" title="scala.collection.immutable.::[A]">t</a> = <a href="#scala.collection.immutable;List.take.nx" title="scala.collection.immutable.::[A]">nx</a>
      <a href="#scala.collection.immutable;List.take.rest" title="List[A]">rest</a> = <a href="#scala.collection.immutable;List.take.rest" title="List[A]">rest</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
    <span class="delimiter">}</span>
    <a href="#scala.collection.immutable;List.take.h" title="scala.collection.immutable.::[A]">h</a>
  <span class="delimiter">}</span>

  override def <a title="(n: Int)List[A]" id="scala.collection.immutable;List.drop">drop</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable;List.drop.n">n</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    var <a title="List[A]" id="scala.collection.immutable;List.drop.these">these</a> = this
    var <a title="Int" id="scala.collection.immutable;List.drop.count">count</a> = <a href="#scala.collection.immutable;List.drop.n" title="Int">n</a>
    while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;List.drop.these" title="List[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.collection.immutable;List.drop.count" title="Int">count</a> <a href="../../Int.scala.html#scala;Int.>(5f58a84eb3)" title="(x: Int)Boolean">&gt;</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;List.drop.while$4" title="()Unit" class="delimiter">{</a>
      <a href="#scala.collection.immutable;List.drop.these" title="List[A]">these</a> = <a href="#scala.collection.immutable;List.drop.these" title="List[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
      <a href="#scala.collection.immutable;List.drop.count" title="Int">count</a> <a href="../../Int.scala.html#scala;Int.-(1409840560)" title="(x: Int)Int">-=</a> <span title="Int(1)" class="int">1</span>
    <span class="delimiter">}</span>
    <a href="#scala.collection.immutable;List.drop.these" title="List[A]">these</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   *  @example {{{
   *  // Given a list
   *  val letters = List('a','b','c','d','e')
   *
   *  // `slice` returns all elements beginning at index `from` and afterwards,
   *  // up until index `until` (excluding index `until`.)
   *  letters.slice(1,3) // Returns List('b','c')
   *  }}}
   */</span>
  override def <a title="(from: Int, until: Int)List[A]" id="scala.collection.immutable;List.slice">slice</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable;List.slice.from">from</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>, <a title="Int" id="scala.collection.immutable;List.slice.until">until</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Int" id="scala.collection.immutable;List.slice.lo">lo</a> = scala.math.<a href="../../math/package.scala.html#scala.math.package.max(8c1ad44065)" title="(x: Int, y: Int)Int">max</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.slice.from" title="Int">from</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;List.slice.until" title="Int">until</a> <a href="../../Int.scala.html#scala;Int.<=(5f58a84eb3)" title="(x: Int)Boolean">&lt;=</a> <a href="#scala.collection.immutable;List.slice.lo" title="Int">lo</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a>
    else this <a href="#scala.collection.immutable;List.drop" title="(n: Int)List[A]">drop</a> <a href="#scala.collection.immutable;List.slice.lo" title="Int">lo</a> <a href="#scala.collection.immutable;List.take" title="(n: Int)List[A]">take</a> <span class="delimiter">(</span><a href="#scala.collection.immutable;List.slice.until" title="Int">until</a> <a href="../../Int.scala.html#scala;Int.-(1409840560)" title="(x: Int)Int">-</a> <a href="#scala.collection.immutable;List.slice.lo" title="Int">lo</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  override def <a title="(n: Int)List[A]" id="scala.collection.immutable;List.takeRight">takeRight</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable;List.takeRight.n">n</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(lead: List[A], lag: List[A])List[A]" id="scala.collection.immutable;List.takeRight.loop">loop</a><span class="delimiter">(</span><a title="List[A]" id="scala.collection.immutable;List.takeRight.loop.lead">lead</a>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="List[A]" id="scala.collection.immutable;List.takeRight.loop.lag">lag</a>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scala.collection.immutable;List.takeRight.loop.lead" title="List[A]">lead</a> match <span class="delimiter">{</span>
      case <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a> =&gt; <a href="#scala.collection.immutable;List.takeRight.loop.lag" title="List[A]">lag</a>
      case _ :: <a title="List[A]" id="scala.collection.immutable;List.takeRight.loop.tail">tail</a> =&gt; <a href="#scala.collection.immutable;List.takeRight.loop" title="(lead: List[A], lag: List[A])List[A]">loop</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.takeRight.loop.tail" title="List[A]">tail</a>, <a href="#scala.collection.immutable;List.takeRight.loop.lag" title="List[A]">lag</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#scala.collection.immutable;List.takeRight.loop" title="(lead: List[A], lag: List[A])List[A]">loop</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.drop" title="(n: Int)List[A]">drop</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.takeRight.n" title="Int">n</a><span class="delimiter">)</span>, this<span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// dropRight is inherited from LinearSeq</span>

  override def <a title="(n: Int)(List[A], List[A])" id="scala.collection.immutable;List.splitAt">splitAt</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable;List.splitAt.n">n</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Tuple2.scala.html#scala;Tuple2" title="(List[A], List[A])" class="delimiter">(</a>List<span class="delimiter">[</span>A<span class="delimiter">]</span>, List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="scala.collection.mutable.ListBuffer[A]" id="scala.collection.immutable;List.splitAt.b">b</a> = new <a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer" title="scala.collection.mutable.ListBuffer[A]">ListBuffer</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
    var <a title="Int" id="scala.collection.immutable;List.splitAt.i">i</a> = <span title="Int(0)" class="int">0</span>
    var <a title="List[A]" id="scala.collection.immutable;List.splitAt.these">these</a> = this
    while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;List.splitAt.these" title="List[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.collection.immutable;List.splitAt.i" title="Int">i</a> <a href="../../Int.scala.html#scala;Int.<(5f58a84eb3)" title="(x: Int)Boolean">&lt;</a> <a href="#scala.collection.immutable;List.splitAt.n" title="Int">n</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;List.splitAt.while$5" title="()Unit" class="delimiter">{</a>
      <a href="#scala.collection.immutable;List.splitAt.i" title="Int">i</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
      <a href="#scala.collection.immutable;List.splitAt.b" title="scala.collection.mutable.ListBuffer[A]">b</a> <a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.+=(f93df146a4)" title="(x: A)b.type">+=</a> <a href="#scala.collection.immutable;List.splitAt.these" title="List[A]">these</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>
      <a href="#scala.collection.immutable;List.splitAt.these" title="List[A]">these</a> = <a href="#scala.collection.immutable;List.splitAt.these" title="List[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
    <span class="delimiter">}</span>
    <a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: List[A], _2: List[A])(List[A], List[A])" class="delimiter">(</a><a href="#scala.collection.immutable;List.splitAt.b" title="scala.collection.mutable.ListBuffer[A]">b</a>.<a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.toList" title="=&gt; List[A]">toList</a>, <a href="#scala.collection.immutable;List.splitAt.these" title="List[A]">these</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  @noinline <span class="comment">// TODO - fix optimizer bug that requires noinline (see SI-8334)</span>
  final override def <a title="[B, That](f: A =&gt; B)(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That])That" id="scala.collection.immutable;List.map">map</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;List.map;B">B</a>, <a title="" id="scala.collection.immutable;List.map;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scala.collection.immutable;List.map.f">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[List[A],B,That]" id="scala.collection.immutable;List.map.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[List[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List.map;That" title="That">That</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;List.map.bf" title="scala.collection.generic.CanBuildFrom[List[A],B,That]">bf</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.collection.immutable.List.readResolve" title="scala.collection.immutable.List.type">List</a>.<a href="../generic/GenTraversableFactory.scala.html#scala.collection.generic;GenTraversableFactory.ReusableCBF" title="=&gt; scala.collection.immutable.List.GenericCanBuildFrom[Nothing]">ReusableCBF</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="That" class="delimiter">[</span><a href="#scala.collection.immutable;List.map;That" title="That">That</a><span class="delimiter">]</span> else <span class="delimiter">{</span>
        val <a title="scala.collection.immutable.::[B]" id="scala.collection.immutable;List.map.h">h</a> = new <a href="#scala.collection.immutable.::.readResolve" title="scala.collection.immutable.::[B]">::</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span>, <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
        var <a title="scala.collection.immutable.::[B]" id="scala.collection.immutable;List.map.t">t</a>: <a href="#scala.collection.immutable.::.readResolve" title="scala.collection.immutable.::[B]">::</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <a href="#scala.collection.immutable;List.map.h" title="scala.collection.immutable.::[B]">h</a>
        var <a title="List[A]" id="scala.collection.immutable;List.map.rest">rest</a> = <a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
        while <span class="delimiter">(</span><a href="#scala.collection.immutable;List.map.rest" title="List[A]">rest</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;List.map.while$6" title="()Unit" class="delimiter">{</a>
          val <a title="scala.collection.immutable.::[B]" id="scala.collection.immutable;List.map.nx">nx</a> = new <a href="#scala.collection.immutable.::.readResolve" title="scala.collection.immutable.::[B]">::</a><span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.map.rest" title="List[A]">rest</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span>, <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
          <a href="#scala.collection.immutable;List.map.t" title="scala.collection.immutable.::[B]">t</a>.<a href="#scala.collection.immutable;::.tl" title="(x$1: List[B])Unit">tl</a> = <a href="#scala.collection.immutable;List.map.nx" title="scala.collection.immutable.::[B]">nx</a>
          <a href="#scala.collection.immutable;List.map.t" title="scala.collection.immutable.::[B]">t</a> = <a href="#scala.collection.immutable;List.map.nx" title="scala.collection.immutable.::[B]">nx</a>
          <a href="#scala.collection.immutable;List.map.rest" title="List[A]">rest</a> = <a href="#scala.collection.immutable;List.map.rest" title="List[A]">rest</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
        <span class="delimiter">}</span>
        <a href="#scala.collection.immutable;List.map.h" title="scala.collection.immutable.::[B]">h</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="That" class="delimiter">[</span><a href="#scala.collection.immutable;List.map;That" title="That">That</a><span class="delimiter">]</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    else super.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.map" title="(f: A =&gt; B)(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That])That">map</a><a href="#scala.collection.immutable;List.map.bf" title="scala.collection.generic.CanBuildFrom[List[A],B,That]" class="delimiter">(</a><a href="#scala.collection.immutable;List.map.f" title="A =&gt; B">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  @noinline <span class="comment">// TODO - fix optimizer bug that requires noinline for map; applied here to be safe (see SI-8334)</span>
  final override def <a title="[B, That](pf: PartialFunction[A,B])(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That])That" id="scala.collection.immutable;List.collect">collect</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;List.collect;B">B</a>, <a title="" id="scala.collection.immutable;List.collect;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[A,B]" id="scala.collection.immutable;List.collect.pf">pf</a>: <a href="../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[A,B]">PartialFunction</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[List[A],B,That]" id="scala.collection.immutable;List.collect.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[List[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List.collect;That" title="That">That</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;List.collect.bf" title="scala.collection.generic.CanBuildFrom[List[A],B,That]">bf</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.collection.immutable.List.readResolve" title="scala.collection.immutable.List.type">List</a>.<a href="../generic/GenTraversableFactory.scala.html#scala.collection.generic;GenTraversableFactory.ReusableCBF" title="=&gt; scala.collection.immutable.List.GenericCanBuildFrom[Nothing]">ReusableCBF</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="That" class="delimiter">[</span><a href="#scala.collection.immutable;List.collect;That" title="That">That</a><span class="delimiter">]</span> else <span class="delimiter">{</span>
        var <a title="List[A]" id="scala.collection.immutable;List.collect.rest">rest</a> = this
        var <a title="scala.collection.immutable.::[B]" id="scala.collection.immutable;List.collect.h">h</a>: <a href="#scala.collection.immutable.::.readResolve" title="scala.collection.immutable.::[B]">::</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = null
        var <span title="A">x</span>: <a href="#scala.collection.immutable;List;A" title="A">A</a> = null.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="A" class="delimiter">[</span><a href="#scala.collection.immutable;List;A" title="A">A</a><span class="delimiter">]</span>
        <span class="comment">// Special case for first element</span>
        do <span class="delimiter">{</span>
          val <span title="Any">x</span>: <span title="Any">Any</span> = <a href="#scala.collection.immutable;List.collect.pf" title="PartialFunction[A,B]">pf</a>.<a href="../../PartialFunction.scala.html#scala;PartialFunction.applyOrElse" title="(x: A, default: A =&gt; Any)Any">applyOrElse</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.collect.rest" title="List[A]">rest</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="#scala.collection.immutable.List.readResolve" title="scala.collection.immutable.List.type">List</a>.<a href="#scala.collection.immutable.List.partialNotApplied" title="=&gt; Any =&gt; Any">partialNotApplied</a><span class="delimiter">)</span>
          if <span class="delimiter">(</span><span title="Any">x</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="AnyRef" class="delimiter">[</span><span title="AnyRef">AnyRef</span><span class="delimiter">]</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.collection.immutable.List.readResolve" title="scala.collection.immutable.List.type">List</a>.<a href="#scala.collection.immutable.List.partialNotApplied" title="=&gt; Any =&gt; Any">partialNotApplied</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;List.collect.h" title="scala.collection.immutable.::[B]">h</a> = new <a href="#scala.collection.immutable.::.readResolve" title="scala.collection.immutable.::[B]">::</a><span class="delimiter">(</span><span title="Any">x</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="B" class="delimiter">[</span><a href="#scala.collection.immutable;List.collect;B" title="B">B</a><span class="delimiter">]</span>, <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
          <a href="#scala.collection.immutable;List.collect.rest" title="List[A]">rest</a> = <a href="#scala.collection.immutable;List.collect.rest" title="List[A]">rest</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
          if <span class="delimiter">(</span><a href="#scala.collection.immutable;List.collect.rest" title="List[A]">rest</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> return <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#scala.collection.immutable;List.collect.h" title="scala.collection.immutable.::[B]">h</a> <span title="(x$1: AnyRef)Boolean">eq</span> null <span class="delimiter">)</span> <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a> else <a href="#scala.collection.immutable;List.collect.h" title="scala.collection.immutable.::[B]">h</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="That" class="delimiter">[</span><a href="#scala.collection.immutable;List.collect;That" title="That">That</a><span class="delimiter">]</span>
        <span class="delimiter">}</span> while <span class="delimiter">(</span><a href="#scala.collection.immutable;List.collect.h" title="scala.collection.immutable.::[B]">h</a> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span>
        var <a title="scala.collection.immutable.::[B]" id="scala.collection.immutable;List.collect.t">t</a> = <a href="#scala.collection.immutable;List.collect.h" title="scala.collection.immutable.::[B]">h</a>
        <span class="comment">// Remaining elements</span>
        do <span class="delimiter">{</span>
          val <span title="Any">x</span>: <span title="Any">Any</span> = <a href="#scala.collection.immutable;List.collect.pf" title="PartialFunction[A,B]">pf</a>.<a href="../../PartialFunction.scala.html#scala;PartialFunction.applyOrElse" title="(x: A, default: A =&gt; Any)Any">applyOrElse</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.collect.rest" title="List[A]">rest</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="#scala.collection.immutable.List.readResolve" title="scala.collection.immutable.List.type">List</a>.<a href="#scala.collection.immutable.List.partialNotApplied" title="=&gt; Any =&gt; Any">partialNotApplied</a><span class="delimiter">)</span>
          if <span class="delimiter">(</span><span title="Any">x</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="AnyRef" class="delimiter">[</span><span title="AnyRef">AnyRef</span><span class="delimiter">]</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.collection.immutable.List.readResolve" title="scala.collection.immutable.List.type">List</a>.<a href="#scala.collection.immutable.List.partialNotApplied" title="=&gt; Any =&gt; Any">partialNotApplied</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            val <a title="scala.collection.immutable.::[B]" id="scala.collection.immutable;List.collect.nx">nx</a> = new <a href="#scala.collection.immutable.::.readResolve" title="scala.collection.immutable.::[B]">::</a><span class="delimiter">(</span><span title="Any">x</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="B" class="delimiter">[</span><a href="#scala.collection.immutable;List.collect;B" title="B">B</a><span class="delimiter">]</span>, <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
            <a href="#scala.collection.immutable;List.collect.t" title="scala.collection.immutable.::[B]">t</a>.<a href="#scala.collection.immutable;::.tl" title="(x$1: List[B])Unit">tl</a> = <a href="#scala.collection.immutable;List.collect.nx" title="scala.collection.immutable.::[B]">nx</a>
            <a href="#scala.collection.immutable;List.collect.t" title="scala.collection.immutable.::[B]">t</a> = <a href="#scala.collection.immutable;List.collect.nx" title="scala.collection.immutable.::[B]">nx</a>
          <span class="delimiter">}</span>
          <a href="#scala.collection.immutable;List.collect.rest" title="List[A]">rest</a> = <a href="#scala.collection.immutable;List.collect.rest" title="List[A]">rest</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
        <span class="delimiter">}</span> while <span class="delimiter">(</span><a href="#scala.collection.immutable;List.collect.rest" title="List[A]">rest</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
        <a href="#scala.collection.immutable;List.collect.h" title="scala.collection.immutable.::[B]">h</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="That" class="delimiter">[</span><a href="#scala.collection.immutable;List.collect;That" title="That">That</a><span class="delimiter">]</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    else super.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.collect" title="(pf: PartialFunction[A,B])(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That])That">collect</a><a href="#scala.collection.immutable;List.collect.bf" title="scala.collection.generic.CanBuildFrom[List[A],B,That]" class="delimiter">(</a><a href="#scala.collection.immutable;List.collect.pf" title="PartialFunction[A,B]">pf</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  @noinline <span class="comment">// TODO - fix optimizer bug that requires noinline for map; applied here to be safe (see SI-8334)</span>
  final override def <a title="[B, That](f: A =&gt; scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That])That" id="scala.collection.immutable;List.flatMap">flatMap</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;List.flatMap;B">B</a>, <a title="" id="scala.collection.immutable;List.flatMap;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scala.collection.GenTraversableOnce[B]" id="scala.collection.immutable;List.flatMap.f">f</a>: A =&gt; GenTraversableOnce<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[List[A],B,That]" id="scala.collection.immutable;List.flatMap.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[List[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List.flatMap;That" title="That">That</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;List.flatMap.bf" title="scala.collection.generic.CanBuildFrom[List[A],B,That]">bf</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.collection.immutable.List.readResolve" title="scala.collection.immutable.List.type">List</a>.<a href="../generic/GenTraversableFactory.scala.html#scala.collection.generic;GenTraversableFactory.ReusableCBF" title="=&gt; scala.collection.immutable.List.GenericCanBuildFrom[Nothing]">ReusableCBF</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="That" class="delimiter">[</span><a href="#scala.collection.immutable;List.flatMap;That" title="That">That</a><span class="delimiter">]</span> else <span class="delimiter">{</span>
        var <a title="List[A]" id="scala.collection.immutable;List.flatMap.rest">rest</a> = this
        var <a title="Boolean" id="scala.collection.immutable;List.flatMap.found">found</a> = false
        var <a title="scala.collection.immutable.::[B]" id="scala.collection.immutable;List.flatMap.h">h</a>: <a href="#scala.collection.immutable.::.readResolve" title="scala.collection.immutable.::[B]">::</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = null
        var <a title="scala.collection.immutable.::[B]" id="scala.collection.immutable;List.flatMap.t">t</a>: <a href="#scala.collection.immutable.::.readResolve" title="scala.collection.immutable.::[B]">::</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = null
        while <span class="delimiter">(</span><a href="#scala.collection.immutable;List.flatMap.rest" title="List[A]">rest</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;List.flatMap.while$7" title="()Unit" class="delimiter">{</a>
          <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)scala.collection.GenTraversableOnce[B]">f</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.flatMap.rest" title="List[A]">rest</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span>.<a href="../GenTraversableOnce.scala.html#scala.collection;GenTraversableOnce.foreach" title="(f: B =&gt; Unit)Unit">foreach</a><span class="delimiter">{</span> <a title="B" id="scala.collection.immutable;List.flatMap.$anonfun.b">b</a> =&gt;
            if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;List.flatMap.found" title="Boolean">found</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#scala.collection.immutable;List.flatMap.h" title="scala.collection.immutable.::[B]">h</a> = new <a href="#scala.collection.immutable.::.readResolve" title="scala.collection.immutable.::[B]">::</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.flatMap.$anonfun.b" title="B">b</a>, <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
              <a href="#scala.collection.immutable;List.flatMap.t" title="scala.collection.immutable.::[B]">t</a> = <a href="#scala.collection.immutable;List.flatMap.h" title="scala.collection.immutable.::[B]">h</a>
              <a href="#scala.collection.immutable;List.flatMap.found" title="Boolean">found</a> = true
            <span class="delimiter">}</span>
            else <span class="delimiter">{</span>
              val <a title="scala.collection.immutable.::[B]" id="scala.collection.immutable;List.flatMap.$anonfun.nx">nx</a> = new <a href="#scala.collection.immutable.::.readResolve" title="scala.collection.immutable.::[B]">::</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.flatMap.$anonfun.b" title="B">b</a>, <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
              <a href="#scala.collection.immutable;List.flatMap.t" title="scala.collection.immutable.::[B]">t</a>.<a href="#scala.collection.immutable;::.tl" title="(x$1: List[B])Unit">tl</a> = <a href="#scala.collection.immutable;List.flatMap.$anonfun.nx" title="scala.collection.immutable.::[B]">nx</a>
              <a href="#scala.collection.immutable;List.flatMap.t" title="scala.collection.immutable.::[B]">t</a> = <a href="#scala.collection.immutable;List.flatMap.$anonfun.nx" title="scala.collection.immutable.::[B]">nx</a>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          <a href="#scala.collection.immutable;List.flatMap.rest" title="List[A]">rest</a> = <a href="#scala.collection.immutable;List.flatMap.rest" title="List[A]">rest</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
        <span class="delimiter">}</span>
        <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;List.flatMap.found" title="Boolean">found</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a> else <a href="#scala.collection.immutable;List.flatMap.h" title="scala.collection.immutable.::[B]">h</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="That" class="delimiter">[</span><a href="#scala.collection.immutable;List.flatMap;That" title="That">That</a><span class="delimiter">]</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    else super.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.flatMap" title="(f: A =&gt; scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[List[A],B,That])That">flatMap</a><a href="#scala.collection.immutable;List.flatMap.bf" title="scala.collection.generic.CanBuildFrom[List[A],B,That]" class="delimiter">(</a><a href="#scala.collection.immutable;List.flatMap.f" title="A =&gt; scala.collection.GenTraversableOnce[B]">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  @inline final override def <a title="(p: A =&gt; Boolean)List[A]" id="scala.collection.immutable;List.takeWhile">takeWhile</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="scala.collection.immutable;List.takeWhile.p">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scala.collection.mutable.ListBuffer[A]" id="scala.collection.immutable;List.takeWhile.b">b</a> = new <a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer" title="scala.collection.mutable.ListBuffer[A]">ListBuffer</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
    var <a title="List[A]" id="scala.collection.immutable;List.takeWhile.these">these</a> = this
    while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;List.takeWhile.these" title="List[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.takeWhile.these" title="List[A]">these</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;List.takeWhile.while$8" title="()Unit" class="delimiter">{</a>
      <a href="#scala.collection.immutable;List.takeWhile.b" title="scala.collection.mutable.ListBuffer[A]">b</a> <a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.+=(f93df146a4)" title="(x: A)b.type">+=</a> <a href="#scala.collection.immutable;List.takeWhile.these" title="List[A]">these</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>
      <a href="#scala.collection.immutable;List.takeWhile.these" title="List[A]">these</a> = <a href="#scala.collection.immutable;List.takeWhile.these" title="List[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
    <span class="delimiter">}</span>
    <a href="#scala.collection.immutable;List.takeWhile.b" title="scala.collection.mutable.ListBuffer[A]">b</a>.<a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.toList" title="=&gt; List[A]">toList</a>
  <span class="delimiter">}</span>

  @inline final override def <a title="(p: A =&gt; Boolean)List[A]" id="scala.collection.immutable;List.dropWhile">dropWhile</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="scala.collection.immutable;List.dropWhile.p">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    @tailrec
    def <a title="(xs: List[A])List[A]" id="scala.collection.immutable;List.dropWhile.loop">loop</a><span class="delimiter">(</span><a title="List[A]" id="scala.collection.immutable;List.dropWhile.loop.xs">xs</a>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#scala.collection.immutable;List.dropWhile.loop.xs" title="List[A]">xs</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.dropWhile.loop.xs" title="List[A]">xs</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;List.dropWhile.loop.xs" title="List[A]">xs</a>
      else <a href="#scala.collection.immutable;List.dropWhile.loop" title="(xs: List[A])List[A]">loop</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.dropWhile.loop.xs" title="List[A]">xs</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a><span class="delimiter">)</span>

    <a href="#scala.collection.immutable;List.dropWhile.loop" title="(xs: List[A])List[A]">loop</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
  <span class="delimiter">}</span>

  @inline final override def <a title="(p: A =&gt; Boolean)(List[A], List[A])" id="scala.collection.immutable;List.span">span</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="scala.collection.immutable;List.span.p">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Tuple2.scala.html#scala;Tuple2" title="(List[A], List[A])" class="delimiter">(</a>List<span class="delimiter">[</span>A<span class="delimiter">]</span>, List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="scala.collection.mutable.ListBuffer[A]" id="scala.collection.immutable;List.span.b">b</a> = new <a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer" title="scala.collection.mutable.ListBuffer[A]">ListBuffer</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
    var <a title="List[A]" id="scala.collection.immutable;List.span.these">these</a> = this
    while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;List.span.these" title="List[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.span.these" title="List[A]">these</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;List.span.while$9" title="()Unit" class="delimiter">{</a>
      <a href="#scala.collection.immutable;List.span.b" title="scala.collection.mutable.ListBuffer[A]">b</a> <a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.+=(f93df146a4)" title="(x: A)b.type">+=</a> <a href="#scala.collection.immutable;List.span.these" title="List[A]">these</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>
      <a href="#scala.collection.immutable;List.span.these" title="List[A]">these</a> = <a href="#scala.collection.immutable;List.span.these" title="List[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
    <span class="delimiter">}</span>
    <a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: List[A], _2: List[A])(List[A], List[A])" class="delimiter">(</a><a href="#scala.collection.immutable;List.span.b" title="scala.collection.mutable.ListBuffer[A]">b</a>.<a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.toList" title="=&gt; List[A]">toList</a>, <a href="#scala.collection.immutable;List.span.these" title="List[A]">these</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// Overridden with an implementation identical to the inherited one (at this time)</span>
  <span class="comment">// solely so it can be finalized and thus inlinable.</span>
  @inline final override def <a title="[U](f: A =&gt; U)Unit" id="scala.collection.immutable;List.foreach">foreach</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;List.foreach;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; U" id="scala.collection.immutable;List.foreach.f">f</a>: A =&gt; U<span class="delimiter">)</span> <span class="delimiter">{</span>
    var <a title="List[A]" id="scala.collection.immutable;List.foreach.these">these</a> = this
    while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;List.foreach.these" title="List[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;List.foreach.while$10" title="()Unit" class="delimiter">{</a>
      <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)U">f</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.foreach.these" title="List[A]">these</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span>
      <a href="#scala.collection.immutable;List.foreach.these" title="List[A]">these</a> = <a href="#scala.collection.immutable;List.foreach.these" title="List[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  override def <a title="=&gt; List[A]" id="scala.collection.immutable;List.reverse">reverse</a>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    var <a title="List[A]" id="scala.collection.immutable;List.reverse.result">result</a>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a>
    var <a title="List[A]" id="scala.collection.immutable;List.reverse.these">these</a> = this
    while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;List.reverse.these" title="List[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;List.reverse.while$11" title="()Unit" class="delimiter">{</a>
      <a href="#scala.collection.immutable;List.reverse.result" title="List[A]">result</a> = <a href="#scala.collection.immutable;List.reverse.these" title="List[A]">these</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a> <a href="#scala.collection.immutable;List.::" title="(x: A)List[A]">::</a> <a href="#scala.collection.immutable;List.reverse.result" title="List[A]">result</a>
      <a href="#scala.collection.immutable;List.reverse.these" title="List[A]">these</a> = <a href="#scala.collection.immutable;List.reverse.these" title="List[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
    <span class="delimiter">}</span>
    <a href="#scala.collection.immutable;List.reverse.result" title="List[A]">result</a>
  <span class="delimiter">}</span>

  override def <a title="[B](z: B)(op: (A, B) =&gt; B)B" id="scala.collection.immutable;List.foldRight">foldRight</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;List.foldRight;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scala.collection.immutable;List.foldRight.z">z</a>: <a href="#scala.collection.immutable;List.foldRight;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; B" id="scala.collection.immutable;List.foldRight.op">op</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#scala.collection.immutable;List.foldRight;B" title="B">B</a> =
    <a href="#scala.collection.immutable;List.reverse" title="=&gt; List[A]">reverse</a>.<a href="../LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.foldLeft" title="(z: B)(f: (B, A) =&gt; B)B">foldLeft</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.foldRight.z" title="B">z</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="B" id="scala.collection.immutable;List.foldRight.$anonfun.right">right</a>, <a title="A" id="scala.collection.immutable;List.foldRight.$anonfun.left">left</a><span class="delimiter">)</span> =&gt; <a href="../../Function2.scala.html#scala;Function2.apply" title="(v1: A, v2: B)B">op</a><span class="delimiter">(</span><a href="#scala.collection.immutable;List.foldRight.$anonfun.left" title="A">left</a>, <a href="#scala.collection.immutable;List.foldRight.$anonfun.right" title="B">right</a><span class="delimiter">)</span><span class="delimiter">)</span>

  override def <a title="=&gt; String" id="scala.collection.immutable;List.stringPrefix">stringPrefix</a> = <span title="String(&quot;List&quot;)" class="string">&quot;List&quot;</span>

  override def <a title="=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable;List.toStream">toStream</a> : <a href="Stream.scala.html#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="Stream.scala.html#scala.collection.immutable.Stream" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="Stream.scala.html#scala.collection.immutable.Stream.Empty" title="scala.collection.immutable.Stream.Empty.type">Empty</a>
    else new Stream.<a href="Stream.scala.html#scala.collection.immutable.Stream;Cons" title="scala.collection.immutable.Stream.Cons[A]">Cons</a><span class="delimiter">(</span><a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>.<a href="#scala.collection.immutable;List.toStream" title="=&gt; scala.collection.immutable.Stream[A]">toStream</a><span class="delimiter">)</span>

  <span class="comment">// Create a proxy for Java serialization that allows us to avoid mutation</span>
  <span class="comment">// during de-serialization.  This is the Serialization Proxy Pattern.</span>
  protected final def <a title="()AnyRef" id="scala.collection.immutable;List.writeReplace">writeReplace</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="AnyRef">AnyRef</span> = new List.<a href="#scala.collection.immutable.List;SerializationProxy" title="scala.collection.immutable.List.SerializationProxy[A]">SerializationProxy</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/** The empty list.
 *
 *  @author  Martin Odersky
 *  @version 1.0, 15/07/2003
 *  @since   2.8
 */</span>
@SerialVersionUID<span class="delimiter">(</span><span class="int">0</span> - <span class="long">8256821097970055419L</span><span class="delimiter">)</span>
case object <a href="#scala.collection.immutable.Nil.productElement.x$1" title="scala.collection.immutable.Nil.type" id="scala.collection.immutable.Nil.readResolve">Nil</a> extends <a href="#scala.collection.immutable;List" title="List[Nothing]">List</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> <span class="delimiter">{</span>
  override def <a title="=&gt; Boolean" id="scala.collection.immutable.Nil.isEmpty">isEmpty</a> = true
  override def <a title="=&gt; Nothing" id="scala.collection.immutable.Nil.head">head</a>: <span title="Nothing">Nothing</span> =
    throw new <a href="../../package.scala.html#scala.package;NoSuchElementException" title="java.util.NoSuchElementException">NoSuchElementException</a><span class="delimiter">(</span><span title="String(&quot;head of empty list&quot;)" class="string">&quot;head of empty list&quot;</span><span class="delimiter">)</span>
  override def <a title="=&gt; List[Nothing]" id="scala.collection.immutable.Nil.tail">tail</a>: <a href="#scala.collection.immutable;List" title="List[Nothing]">List</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> =
    throw new <a href="../../package.scala.html#scala.package;UnsupportedOperationException" title="UnsupportedOperationException">UnsupportedOperationException</a><span class="delimiter">(</span><span title="String(&quot;tail of empty list&quot;)" class="string">&quot;tail of empty list&quot;</span><span class="delimiter">)</span>
  <span class="comment">// Removal of equals method here might lead to an infinite recursion similar to IntMap.equals.</span>
  override def <a title="(that: Any)Boolean" id="scala.collection.immutable.Nil.equals">equals</a><span class="delimiter">(</span><a title="Any" id="scala.collection.immutable.Nil.equals.that">that</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <a href="#scala.collection.immutable.Nil.equals.that" title="Any">that</a> match <span class="delimiter">{</span>
    case <a title="scala.collection.GenSeq[_]" id="scala.collection.immutable.Nil.equals.that1">that1</a>: scala.collection.<a href="../GenSeq.scala.html#scala.collection;GenSeq" title="scala.collection.GenSeq[_]">GenSeq</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="#scala.collection.immutable.Nil.equals.that1" title="scala.collection.GenSeq[_]">that1</a>.<a href="../generic/GenericTraversableTemplate.scala.html#scala.collection.generic;GenericTraversableTemplate.isEmpty" title="=&gt; Boolean">isEmpty</a>
    case _ =&gt; false
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/** A non empty list characterized by a head and a tail.
 *  @param hd   the first element of the list
 *  @param tl   the list containing the remaining elements of this list after the first one.
 *  @tparam B   the type of the list elements.
 *  @author  Martin Odersky
 *  @version 1.0, 15/07/2003
 *  @since   2.8
 */</span>
final case class <a href="#scala.collection.immutable;::.productElement.x$1" title="class ::[B] extends List[B] with Product with Serializable" id="scala.collection.immutable.::.readResolve">::</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;::;B">B</a><span class="delimiter">]</span><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a>override val <a title="B" id="scala.collection.immutable;::.head">head</a>: <a href="#scala.collection.immutable;::;B" title="B">B</a>, private<span class="delimiter">[</span>scala<span class="delimiter">]</span> var <a title="List[B]" id="scala.collection.immutable;::.tl">tl</a>: <a href="#scala.collection.immutable;List" title="List[B]">List</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.collection.immutable;List" title="List[B]">List</a><span class="delimiter">[</span>B<span class="delimiter">]</span> <span class="delimiter">{</span>
  override def <a title="=&gt; List[B]" id="scala.collection.immutable;::.tail">tail</a> : <a href="#scala.collection.immutable;List" title="List[B]">List</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <a href="#scala.collection.immutable;::.tl" title="=&gt; List[B]">tl</a>
  override def <a title="=&gt; Boolean" id="scala.collection.immutable;::.isEmpty">isEmpty</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false
<span class="delimiter">}</span>

<span class="comment">/** $factoryInfo
 *  @define coll list
 *  @define Coll `List`
 */</span>
object <a title="scala.collection.immutable.List.type" id="scala.collection.immutable.List.readResolve">List</a> extends <a href="../generic/SeqFactory.scala.html#scala.collection.generic;SeqFactory" title="scala.collection.generic.SeqFactory[List]">SeqFactory</a><span class="delimiter">[</span>List<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="comment">/** $genericCanBuildFromInfo */</span>
  implicit def <a title="[A]=&gt; scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,A,List[A]]" id="scala.collection.immutable.List.canBuildFrom">canBuildFrom</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.List.canBuildFrom;A">A</a><span class="delimiter">]</span>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,A,List[A]]">CanBuildFrom</a><span class="delimiter">[</span>Coll, A, List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="../generic/GenTraversableFactory.scala.html#scala.collection.generic;GenTraversableFactory.ReusableCBF" title="=&gt; scala.collection.immutable.List.GenericCanBuildFrom[Nothing]">ReusableCBF</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.collection.immutable.List.GenericCanBuildFrom[A]" class="delimiter">[</span><a href="../generic/GenTraversableFactory.scala.html#scala.collection.generic;GenTraversableFactory;GenericCanBuildFrom" title="scala.collection.immutable.List.GenericCanBuildFrom[A]">GenericCanBuildFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>

  def <a title="[A]=&gt; scala.collection.mutable.Builder[A,List[A]]" id="scala.collection.immutable.List.newBuilder">newBuilder</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.List.newBuilder;A">A</a><span class="delimiter">]</span>: <a href="../mutable/Builder.scala.html#scala.collection.mutable;Builder" title="scala.collection.mutable.Builder[A,List[A]]">Builder</a><span class="delimiter">[</span>A, List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = new <a href="../mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer" title="scala.collection.mutable.ListBuffer[A]">ListBuffer</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  override def <a title="[A]=&gt; List[A]" id="scala.collection.immutable.List.empty">empty</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.List.empty;A">A</a><span class="delimiter">]</span>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scala.collection.immutable.Nil.readResolve" title="scala.collection.immutable.Nil.type">Nil</a>

  override def <a title="[A](xs: A*)List[A]" id="scala.collection.immutable.List.apply">apply</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.List.apply;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A*" id="scala.collection.immutable.List.apply.xs">xs</a>: <span title="A*">A</span>*<span class="delimiter">)</span>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scala.collection.immutable.List.apply.xs" title="A*">xs</a>.<a href="../TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[A]">toList</a>
  
  private<span class="delimiter">[</span>collection<span class="delimiter">]</span> val <a title="&lt;refinement of Any =&gt; Any&gt; extends AnyRef with Any =&gt; Any" id="scala.collection.immutable.List.partialNotApplied">partialNotApplied</a> = new <a title="&lt;$anon: Any =&gt; Any&gt; extends AnyRef with Any =&gt; Any" id="scala.collection.immutable.List.partialNotApplied;$anon">Function1</a><span class="delimiter">[</span>Any, Any<span class="delimiter">]</span> <span class="delimiter">{</span> def <a title="(x: Any)Any" id="scala.collection.immutable.List.partialNotApplied;$anon.apply">apply</a><span class="delimiter">(</span><a title="Any" id="scala.collection.immutable.List.partialNotApplied;$anon.apply.x">x</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <span title="Any">Any</span> = this <span class="delimiter">}</span>

  @SerialVersionUID<span class="delimiter">(</span><span class="long">1L</span><span class="delimiter">)</span>
  private class <a title="class SerializationProxy[A] extends AnyRef with java.io.Serializable" id="scala.collection.immutable.List;SerializationProxy">SerializationProxy</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.List;SerializationProxy;A">A</a><span class="delimiter">]</span><a href="#scala.collection.immutable.List;SerializationProxy" title="scala.collection.immutable.List.SerializationProxy[A]" class="delimiter">(</a>@transient private var <a title="List[A]" id="scala.collection.immutable.List;SerializationProxy.orig">orig</a>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.collection.immutable.List;SerializationProxy" title="java.io.Serializable">Serializable</a> <span class="delimiter">{</span>

    private def <a title="(out: java.io.ObjectOutputStream)Unit" id="scala.collection.immutable.List;SerializationProxy.writeObject">writeObject</a><span class="delimiter">(</span><a title="java.io.ObjectOutputStream" id="scala.collection.immutable.List;SerializationProxy.writeObject.out">out</a>: <span title="java.io.ObjectOutputStream">ObjectOutputStream</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      var <a title="List[A]" id="scala.collection.immutable.List;SerializationProxy.writeObject.xs">xs</a>: <a href="#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scala.collection.immutable.List;SerializationProxy.orig" title="=&gt; List[A]">orig</a>
      while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable.List;SerializationProxy.writeObject.xs" title="List[A]">xs</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.List;SerializationProxy.writeObject.while$12" title="()Unit" class="delimiter">{</a>
        <a href="#scala.collection.immutable.List;SerializationProxy.writeObject.out" title="java.io.ObjectOutputStream">out</a>.<span title="(x$1: Any)Unit">writeObject</span><span class="delimiter">(</span><a href="#scala.collection.immutable.List;SerializationProxy.writeObject.xs" title="List[A]">xs</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span>
        <a href="#scala.collection.immutable.List;SerializationProxy.writeObject.xs" title="List[A]">xs</a> = <a href="#scala.collection.immutable.List;SerializationProxy.writeObject.xs" title="List[A]">xs</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>
      <span class="delimiter">}</span>
      <a href="#scala.collection.immutable.List;SerializationProxy.writeObject.out" title="java.io.ObjectOutputStream">out</a>.<span title="(x$1: Any)Unit">writeObject</span><span class="delimiter">(</span><a href="#scala.collection.immutable.ListSerializeEnd.readResolve" title="scala.collection.immutable.ListSerializeEnd.type">ListSerializeEnd</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// Java serialization calls this before readResolve during de-serialization.</span>
    <span class="comment">// Read the whole list and store it in `orig`.</span>
    private def <a title="(in: java.io.ObjectInputStream)Unit" id="scala.collection.immutable.List;SerializationProxy.readObject">readObject</a><span class="delimiter">(</span><a title="java.io.ObjectInputStream" id="scala.collection.immutable.List;SerializationProxy.readObject.in">in</a>: <span title="java.io.ObjectInputStream">ObjectInputStream</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="scala.collection.mutable.Builder[A,List[A]]" id="scala.collection.immutable.List;SerializationProxy.readObject.builder">builder</a> = <a href="#scala.collection.immutable.List.readResolve" title="scala.collection.immutable.List.type">List</a>.<a href="#scala.collection.immutable.List.newBuilder" title="[A]=&gt; scala.collection.mutable.Builder[A,List[A]]">newBuilder</a><span title="scala.collection.mutable.Builder[A,List[A]]" class="delimiter">[</span><a href="#scala.collection.immutable.List;SerializationProxy;A" title="A">A</a><span class="delimiter">]</span>
      while <span class="delimiter">(</span>true<span class="delimiter">)</span> <a href="#scala.collection.immutable.List;SerializationProxy.readObject.in" title="java.io.ObjectInputStream">in</a>.<span title="()Object">readObject</span> match <span class="delimiter">{</span>
        case <a href="#scala.collection.immutable.ListSerializeEnd.readResolve" title="scala.collection.immutable.ListSerializeEnd.type">ListSerializeEnd</a> =&gt;
          <a href="#scala.collection.immutable.List;SerializationProxy.orig" title="(x$1: List[A])Unit">orig</a> = <a href="#scala.collection.immutable.List;SerializationProxy.readObject.builder" title="scala.collection.mutable.Builder[A,List[A]]">builder</a>.<a href="../mutable/Builder.scala.html#scala.collection.mutable;Builder.result" title="()List[A]">result</a><span class="delimiter">(</span><span class="delimiter">)</span>
          return
        case <a title="Object" id="scala.collection.immutable.List;SerializationProxy.readObject.a">a</a> =&gt;
          <a href="#scala.collection.immutable.List;SerializationProxy.readObject.builder" title="scala.collection.mutable.Builder[A,List[A]]">builder</a> <a href="../mutable/Builder.scala.html#scala.collection.mutable;Builder.+=(f886548160)" title="(elem: A)builder.type">+=</a> <a href="#scala.collection.immutable.List;SerializationProxy.readObject.a" title="Object">a</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="A" class="delimiter">[</span><a href="#scala.collection.immutable.List;SerializationProxy;A" title="A">A</a><span class="delimiter">]</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">// Provide the result stored in `orig` for Java serialization</span>
    private def <a title="()AnyRef" id="scala.collection.immutable.List;SerializationProxy.readResolve">readResolve</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="AnyRef">AnyRef</span> = <a href="#scala.collection.immutable.List;SerializationProxy.orig" title="=&gt; List[A]">orig</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/** Only used for list serialization */</span>
@SerialVersionUID<span class="delimiter">(</span><span class="long">0L</span> - <span class="long">8476791151975527571L</span><span class="delimiter">)</span>
private<span class="delimiter">[</span>scala<span class="delimiter">]</span> case object <a href="#scala.collection.immutable.ListSerializeEnd.productElement.x$1" title="scala.collection.immutable.ListSerializeEnd.type" id="scala.collection.immutable.ListSerializeEnd.readResolve">ListSerializeEnd</a>

        </pre>
    </body>
</html>
