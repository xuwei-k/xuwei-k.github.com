<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/collection/immutable/Stream.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2003-2013, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

package scala
package collection
package immutable

import generic._
import mutable.<span class="delimiter">{</span>Builder, StringBuilder, LazyBuilder, ListBuffer<span class="delimiter">}</span>
import scala.annotation.tailrec
import <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.cons
import scala.<a href="../../language.scala.html#scala.language" title="language.type">language</a>.implicitConversions

<span class="comment">/** The class `Stream` implements lazy lists where elements
 *  are only evaluated when they are needed. Here is an example:
 *
 *  {{{
 *  import scala.math.BigInt
 *  object Main extends App {
 *
 *    val fibs: Stream[BigInt] = BigInt(0) #:: BigInt(1) #:: fibs.zip(fibs.tail).map { n =&gt; n._1 + n._2 }
 *
 *    fibs take 5 foreach println
 *  }
 *
 *  // prints
 *  //
 *  // 0
 *  // 1
 *  // 1
 *  // 2
 *  // 3
 *  }}}
 *
 *  The `Stream` class also employs memoization such that previously computed
 *  values are converted from `Stream` elements to concrete values of type `A`.
 *  To illustrate, we will alter body of the `fibs` value above and take some
 *  more values:
 *
 *  {{{
 *  import scala.math.BigInt
 *  object Main extends App {
 *
 *    val fibs: Stream[BigInt] = BigInt(0) #:: BigInt(1) #:: fibs.zip(
 *      fibs.tail).map(n =&gt; {
 *        println(&quot;Adding %d and %d&quot;.format(n._1, n._2))
 *        n._1 + n._2
 *      })
 *
 *    fibs take 5 foreach println
 *    fibs take 6 foreach println
 *  }
 *
 *  // prints
 *  //
 *  // 0
 *  // 1
 *  // Adding 0 and 1
 *  // 1
 *  // Adding 1 and 1
 *  // 2
 *  // Adding 1 and 2
 *  // 3
 *
 *  // And then prints
 *  //
 *  // 0
 *  // 1
 *  // 1
 *  // 2
 *  // 3
 *  // Adding 2 and 3
 *  // 5
 *  }}}
 *
 *  There are a number of subtle points to the above example.
 *
 *  - The definition of `fibs` is a `val` not a method.  The memoization of the
 *  `Stream` requires us to have somewhere to store the information and a `val`
 *  allows us to do that.
 *
 *  - While the `Stream` is actually being modified during access, this does not
 *  change the notion of its immutability.  Once the values are memoized they do
 *  not change and values that have yet to be memoized still &quot;exist&quot;, they
 *  simply haven't been realized yet.
 *
 *  - One must be cautious of memoization; you can very quickly eat up large
 *  amounts of memory if you're not careful.  The reason for this is that the
 *  memoization of the `Stream` creates a structure much like
 *  [[scala.collection.immutable.List]].  So long as something is holding on to
 *  the head, the head holds on to the tail, and so it continues recursively.
 *  If, on the other hand, there is nothing holding on to the head (e.g. we used
 *  `def` to define the `Stream`) then once it is no longer being used directly,
 *  it disappears.
 *
 *  - Note that some operations, including [[drop]], [[dropWhile]],
 *  [[flatMap]] or [[collect]] may process a large number of intermediate
 *  elements before returning.  These necessarily hold onto the head, since
 *  they are methods on `Stream`, and a stream holds its own head.  For
 *  computations of this sort where memoization is not desired, use
 *  `Iterator` when possible.
 *
 *  {{{
 *  // For example, let's build the natural numbers and do some silly iteration
 *  // over them.
 *
 *  // We'll start with a silly iteration
 *  def loop(s: String, i: Int, iter: Iterator[Int]): Unit = {
 *    // Stop after 200,000
 *    if (i &lt; 200001) {
 *      if (i % 50000 == 0) println(s + i)
 *      loop(s, iter.next, iter)
 *    }
 *  }
 *
 *  // Our first Stream definition will be a val definition
 *  val stream1: Stream[Int] = {
 *    def loop(v: Int): Stream[Int] = v #:: loop(v + 1)
 *    loop(0)
 *  }
 *
 *  // Because stream1 is a val, everything that the iterator produces is held
 *  // by virtue of the fact that the head of the Stream is held in stream1
 *  val it1 = stream1.iterator
 *  loop(&quot;Iterator1: &quot;, it1.next, it1)
 *
 *  // We can redefine this Stream such that all we have is the Iterator left
 *  // and allow the Stream to be garbage collected as required.  Using a def
 *  // to provide the Stream ensures that no val is holding onto the head as
 *  // is the case with stream1
 *  def stream2: Stream[Int] = {
 *    def loop(v: Int): Stream[Int] = v #:: loop(v + 1)
 *    loop(0)
 *  }
 *  val it2 = stream2.iterator
 *  loop(&quot;Iterator2: &quot;, it2.next, it2)
 *
 *  // And, of course, we don't actually need a Stream at all for such a simple
 *  // problem.  There's no reason to use a Stream if you don't actually need
 *  // one.
 *  val it3 = new Iterator[Int] {
 *    var i = -1
 *    def hasNext = true
 *    def next(): Int = { i += 1; i }
 *  }
 *  loop(&quot;Iterator3: &quot;, it3.next, it3)
 *  }}}
 *
 *  - The fact that `tail` works at all is of interest.  In the definition of
 *  `fibs` we have an initial `(0, 1, Stream(...))` so `tail` is deterministic.
 *  If we deinfed `fibs` such that only `0` were concretely known then the act
 *  of determining `tail` would require the evaluation of `tail` which would
 *  cause an infinite recursion and stack overflow.  If we define a definition
 *  where the tail is not initially computable then we're going to have an
 *  infinite recursion:
 *  {{{
 *  // The first time we try to access the tail we're going to need more
 *  // information which will require us to recurse, which will require us to
 *  // recurse, which...
 *  val sov: Stream[Vector[Int]] = Vector(0) #:: sov.zip(sov.tail).map { n =&gt; n._1 ++ n._2 }
 *  }}}
 *
 *  The definition of `fibs` above creates a larger number of objects than
 *  necessary depending on how you might want to implement it.  The following
 *  implementation provides a more &quot;cost effective&quot; implementation due to the
 *  fact that it has a more direct route to the numbers themselves:
 *
 *  {{{
 *  lazy val fib: Stream[Int] = {
 *    def loop(h: Int, n: Int): Stream[Int] = h #:: loop(n, h + n)
 *    loop(1, 1)
 *  }
 *  }}}
 * 
 *  Note that `mkString` forces evaluation of a `Stream`, but `addString` does
 *  not.  In both cases, a `Stream` that is or ends in a cycle 
 *  (e.g. `lazy val s: Stream[Int] = 0 #:: s`) will convert additional trips
 *  through the cycle to `...`.  Additionally, `addString` will display an
 *  un-memoized tail as `?`.
 *
 *  @tparam A    the type of the elements contained in this stream.
 *
 *  @author Martin Odersky, Matthias Zenger
 *  @version 1.1 08/08/03
 *  @since   2.8
 *  @see [[http://docs.scala-lang.org/overviews/collections/concrete-immutable-collection-classes.html#streams &quot;Scala's Collection Library overview&quot;]]
 *  section on `Streams` for more information.

 *  @define naturalsEx def naturalsFrom(i: Int): Stream[Int] = i #:: naturalsFrom(i + 1)
 *  @define Coll `Stream`
 *  @define coll stream
 *  @define orderDependent
 *  @define orderDependentFold
 *  @define willTerminateInf Note: lazily evaluated; will terminate for infinite-sized collections.
 */</span>
@deprecatedInheritance<span class="delimiter">(</span><span class="string">&quot;This class will be sealed.&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
abstract class <a title="class Stream[+A] extends scala.collection.AbstractSeq[A] with scala.collection.immutable.LinearSeq[A] with scala.collection.generic.GenericTraversableTemplate[A,scala.collection.immutable.Stream] with scala.collection.LinearSeqOptimized[A,scala.collection.immutable.Stream[A]] with Serializable" id="scala.collection.immutable;Stream">Stream</a><span class="delimiter">[</span>+<a title="" id="scala.collection.immutable;Stream;A">A</a><span class="delimiter">]</span> extends <a href="../Seq.scala.html#scala.collection;AbstractSeq" title="scala.collection.AbstractSeq[A]">AbstractSeq</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
                             with <a href="LinearSeq.scala.html#scala.collection.immutable;LinearSeq" title="scala.collection.immutable.LinearSeq[A]">LinearSeq</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
                             with <a href="../generic/GenericTraversableTemplate.scala.html#scala.collection.generic;GenericTraversableTemplate" title="scala.collection.generic.GenericTraversableTemplate[A,scala.collection.immutable.Stream]">GenericTraversableTemplate</a><span class="delimiter">[</span>A, Stream<span class="delimiter">]</span>
                             with <a href="../LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized" title="scala.collection.LinearSeqOptimized[A,scala.collection.immutable.Stream[A]]">LinearSeqOptimized</a><span class="delimiter">[</span>A, Stream<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>
                             with <a href="../../Serializable.scala.html#scala;Serializable" title="Serializable">Serializable</a> <span class="delimiter">{</span>
self =&gt;
  override def <a title="=&gt; scala.collection.generic.GenericCompanion[scala.collection.immutable.Stream]" id="scala.collection.immutable;Stream.companion">companion</a>: <a href="../generic/GenericCompanion.scala.html#scala.collection.generic;GenericCompanion" title="scala.collection.generic.GenericCompanion[scala.collection.immutable.Stream]">GenericCompanion</a><span class="delimiter">[</span>Stream<span class="delimiter">]</span> = <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>

  import scala.collection.<span class="delimiter">{</span>Traversable, Iterable, Seq, IndexedSeq<span class="delimiter">}</span>

  <span class="comment">/** Indicates whether or not the `Stream` is empty.
   *
   * @return `true` if the `Stream` is empty and `false` otherwise.
   */</span>
  def <a title="=&gt; Boolean" id="scala.collection.immutable;Stream.isEmpty">isEmpty</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

  <span class="comment">/** Gives constant time access to the first element of this `Stream`.  Using
   * the `fibs` example from earlier:
   *
   * {{{
   * println(fibs head)
   * // prints
   * // 0
   * }}}
   *
   *  @return The first element of the `Stream`.
   *  @throws Predef.NoSuchElementException if the stream is empty.
   */</span>
  def <a title="=&gt; A" id="scala.collection.immutable;Stream.head">head</a>: <a href="#scala.collection.immutable;Stream;A" title="A">A</a>

  <span class="comment">/** A stream consisting of the remaining elements of this stream after the
   *  first one.
   *
   *  Note that this method does not force evaluation of the `Stream` but merely
   *  returns the lazy result.
   *
   *  @return The tail of the `Stream`.
   *  @throws Predef.UnsupportedOperationException if the stream is empty.
   */</span>
  def <a title="=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.tail">tail</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  <span class="comment">/** Is the tail of this stream defined? */</span>
  protected def <a title="=&gt; Boolean" id="scala.collection.immutable;Stream.tailDefined">tailDefined</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

  <span class="comment">// Implementation of abstract method in Traversable</span>

  <span class="comment">// New methods in Stream</span>

  <span class="comment">/** The stream resulting from the concatenation of this stream with the argument stream.
   *  @param rest   The stream that gets appended to this stream
   *  @return       The stream containing elements of this stream and the traversable object.
   */</span>
  def <a title="[B &gt;: A](rest: =&gt; scala.collection.TraversableOnce[B])scala.collection.immutable.Stream[B]" id="scala.collection.immutable;Stream.append">append</a><span class="delimiter">[</span><a title=" &gt;: A" id="scala.collection.immutable;Stream.append;B">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scala.collection.TraversableOnce[B]" id="scala.collection.immutable;Stream.append.rest">rest</a>: =&gt; TraversableOnce<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[B]">Stream</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.append.rest" title="=&gt; scala.collection.TraversableOnce[B]">rest</a>.<a href="../GenTraversableOnce.scala.html#scala.collection;GenTraversableOnce.toStream" title="=&gt; Stream[B]">toStream</a> else <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: B, tl: =&gt; scala.collection.immutable.Stream[B])scala.collection.immutable.Stream.Cons[B]">cons</a><span class="delimiter">(</span><a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a> <a href="#scala.collection.immutable;Stream.append" title="(rest: =&gt; scala.collection.TraversableOnce[B])scala.collection.immutable.Stream[B]">append</a> <a href="#scala.collection.immutable;Stream.append.rest" title="=&gt; scala.collection.TraversableOnce[B]">rest</a><span class="delimiter">)</span>

  <span class="comment">/** Forces evaluation of the whole stream and returns it.
   *
   * @note Often we use `Stream`s to represent an infinite set or series.  If
   * that's the case for your particular `Stream` then this function will never
   * return and will probably crash the VM with an `OutOfMemory` exception.
   * This function will not hang on a finite cycle, however.
   *
   *  @return The fully realized `Stream`.
   */</span>
  def <a title="=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.force">force</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">// Use standard 2x 1x iterator trick for cycle detection (&quot;those&quot; is slow one)</span>
    var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.force.these">these</a>, <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.force.those">those</a> = this
    if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.force.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.force.these" title="scala.collection.immutable.Stream[A]">these</a> = <a href="#scala.collection.immutable;Stream.force.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
    while <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.force.those" title="scala.collection.immutable.Stream[A]">those</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.collection.immutable;Stream.force.these" title="scala.collection.immutable.Stream[A]">these</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.force.while$1" title="()Unit" class="delimiter">{</a>
      if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.force.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> return this
      <a href="#scala.collection.immutable;Stream.force.these" title="scala.collection.immutable.Stream[A]">these</a> = <a href="#scala.collection.immutable;Stream.force.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
      if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.force.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> return this
      <a href="#scala.collection.immutable;Stream.force.these" title="scala.collection.immutable.Stream[A]">these</a> = <a href="#scala.collection.immutable;Stream.force.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
      if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.force.these" title="scala.collection.immutable.Stream[A]">these</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.collection.immutable;Stream.force.those" title="scala.collection.immutable.Stream[A]">those</a><span class="delimiter">)</span> return this
      <a href="#scala.collection.immutable;Stream.force.those" title="scala.collection.immutable.Stream[A]">those</a> = <a href="#scala.collection.immutable;Stream.force.those" title="scala.collection.immutable.Stream[A]">those</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
    <span class="delimiter">}</span>
    this
  <span class="delimiter">}</span>

  <span class="comment">/** Prints elements of this stream one by one, separated by commas. */</span>
  def <a title="()Unit" id="scala.collection.immutable;Stream.print(aa97cb1b3d)">print</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#scala.collection.immutable;Stream.print(d06927cbd5)" title="(sep: String)Unit">print</a><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/** Prints elements of this stream one by one, separated by `sep`.
   *  @param sep   The separator string printed between consecutive elements.
   */</span>
  def <a title="(sep: String)Unit" id="scala.collection.immutable;Stream.print(d06927cbd5)">print</a><span class="delimiter">(</span><a title="String" id="scala.collection.immutable;Stream.print(d06927cbd5).sep">sep</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="(these: scala.collection.immutable.Stream[A], start: String)Unit" id="scala.collection.immutable;Stream.print(d06927cbd5).loop">loop</a><span class="delimiter">(</span><a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.print(d06927cbd5).loop.these">these</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="String" id="scala.collection.immutable;Stream.print(d06927cbd5).loop.start">start</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../Console.scala.html#scala.Console" title="Console.type">Console</a>.<a href="../../Console.scala.html#scala.Console.print" title="(obj: Any)Unit">print</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.print(d06927cbd5).loop.start" title="String">start</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.print(d06927cbd5).loop.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../../Console.scala.html#scala.Console" title="Console.type">Console</a>.<a href="../../Console.scala.html#scala.Console.print" title="(obj: Any)Unit">print</a><span class="delimiter">(</span><span title="String(&quot;empty&quot;)" class="string">&quot;empty&quot;</span><span class="delimiter">)</span>
      else <span class="delimiter">{</span>
        <a href="../../Console.scala.html#scala.Console" title="Console.type">Console</a>.<a href="../../Console.scala.html#scala.Console.print" title="(obj: Any)Unit">print</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.print(d06927cbd5).loop.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span>
        <a href="#scala.collection.immutable;Stream.print(d06927cbd5).loop" title="(these: scala.collection.immutable.Stream[A], start: String)Unit">loop</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.print(d06927cbd5).loop.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>, <a href="#scala.collection.immutable;Stream.print(d06927cbd5).sep" title="String">sep</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#scala.collection.immutable;Stream.print(d06927cbd5).loop" title="(these: scala.collection.immutable.Stream[A], start: String)Unit">loop</a><span class="delimiter">(</span>this, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Returns the length of this `Stream`.
   *
   * @note In order to compute the length of the `Stream`, it must first be
   * fully realized, which could cause the complete evaluation of an infinite
   * series, assuming that's what your `Stream` represents.
   *
   * @return The length of this `Stream`.
   */</span>
  override def <a title="=&gt; Int" id="scala.collection.immutable;Stream.length">length</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> = <span class="delimiter">{</span>
    var <a title="Int" id="scala.collection.immutable;Stream.length.len">len</a> = <span title="Int(0)" class="int">0</span>
    var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.length.left">left</a> = this
    while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.length.left" title="scala.collection.immutable.Stream[A]">left</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.length.while$2" title="()Unit" class="delimiter">{</a>
      <a href="#scala.collection.immutable;Stream.length.len" title="Int">len</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
      <a href="#scala.collection.immutable;Stream.length.left" title="scala.collection.immutable.Stream[A]">left</a> = <a href="#scala.collection.immutable;Stream.length.left" title="scala.collection.immutable.Stream[A]">left</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
    <span class="delimiter">}</span>
    <a href="#scala.collection.immutable;Stream.length.len" title="Int">len</a>
  <span class="delimiter">}</span>

  <span class="comment">// It's an imperfect world, but at least we can bottle up the</span>
  <span class="comment">// imperfection in a capsule.</span>
  @inline private def <a title="[That](x: AnyRef)That" id="scala.collection.immutable;Stream.asThat">asThat</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;Stream.asThat;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="AnyRef" id="scala.collection.immutable;Stream.asThat.x">x</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream.asThat;That" title="That">That</a>     = <a href="#scala.collection.immutable;Stream.asThat.x" title="AnyRef">x</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="That" class="delimiter">[</span><a href="#scala.collection.immutable;Stream.asThat;That" title="That">That</a><span class="delimiter">]</span>
  @inline private def <a title="[B](x: AnyRef)scala.collection.immutable.Stream[B]" id="scala.collection.immutable;Stream.asStream">asStream</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;Stream.asStream;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="AnyRef" id="scala.collection.immutable;Stream.asStream.x">x</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[B]">Stream</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <a href="#scala.collection.immutable;Stream.asStream.x" title="AnyRef">x</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.collection.immutable.Stream[B]" class="delimiter">[</span><a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[B]">Stream</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span>
  @inline private def <a title="[B, That](bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])Boolean" id="scala.collection.immutable;Stream.isStreamBuilder">isStreamBuilder</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;Stream.isStreamBuilder;B">B</a>, <a title="" id="scala.collection.immutable;Stream.isStreamBuilder;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]" id="scala.collection.immutable;Stream.isStreamBuilder.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom.apply(e597f0c40a)" title="(from: scala.collection.immutable.Stream[A])scala.collection.mutable.Builder[B,That]">bf</a><span class="delimiter">(</span><a href="../TraversableLike.scala.html#scala.collection;TraversableLike.repr" title="=&gt; scala.collection.immutable.Stream[A]">repr</a><span class="delimiter">)</span>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span>Stream.<a href="#scala.collection.immutable.Stream;StreamBuilder" title="scala.collection.immutable.Stream.StreamBuilder[_]">StreamBuilder</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="comment">// Overridden methods from Traversable</span>

  override def <a title="=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.toStream">toStream</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = this

  override def <a title="=&gt; Boolean" id="scala.collection.immutable;Stream.hasDefiniteSize">hasDefiniteSize</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.tailDefined" title="=&gt; Boolean">tailDefined</a><span class="delimiter">)</span> false
    else <span class="delimiter">{</span>
      <span class="comment">// Two-iterator trick (2x &amp; 1x speed) for cycle detection.</span>
      var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.hasDefiniteSize.those">those</a> = this
      var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.hasDefiniteSize.these">these</a> = <a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
      while <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.hasDefiniteSize.those" title="scala.collection.immutable.Stream[A]">those</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.collection.immutable;Stream.hasDefiniteSize.these" title="scala.collection.immutable.Stream[A]">these</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.hasDefiniteSize.while$3" title="()Unit" class="delimiter">{</a>
        if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.hasDefiniteSize.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> return true
        if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.hasDefiniteSize.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="#scala.collection.immutable;Stream.tailDefined" title="=&gt; Boolean">tailDefined</a><span class="delimiter">)</span> return false
        <a href="#scala.collection.immutable;Stream.hasDefiniteSize.these" title="scala.collection.immutable.Stream[A]">these</a> = <a href="#scala.collection.immutable;Stream.hasDefiniteSize.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
        if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.hasDefiniteSize.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> return true
        if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.hasDefiniteSize.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="#scala.collection.immutable;Stream.tailDefined" title="=&gt; Boolean">tailDefined</a><span class="delimiter">)</span> return false
        <a href="#scala.collection.immutable;Stream.hasDefiniteSize.these" title="scala.collection.immutable.Stream[A]">these</a> = <a href="#scala.collection.immutable;Stream.hasDefiniteSize.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
        if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.hasDefiniteSize.those" title="scala.collection.immutable.Stream[A]">those</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.collection.immutable;Stream.hasDefiniteSize.these" title="scala.collection.immutable.Stream[A]">these</a><span class="delimiter">)</span> return false
        <a href="#scala.collection.immutable;Stream.hasDefiniteSize.those" title="scala.collection.immutable.Stream[A]">those</a> = <a href="#scala.collection.immutable;Stream.hasDefiniteSize.those" title="scala.collection.immutable.Stream[A]">those</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
      <span class="delimiter">}</span>
      false  <span class="comment">// Cycle detected</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Create a new stream which contains all elements of this stream followed by
   * all elements of Traversable `that`.
   *
   * @note It's subtle why this works. We know that if the target type of the
   * [[scala.collection.mutable.Builder]] `That` is either a `Stream`, or one of
   * its supertypes, or undefined, then `StreamBuilder` will be chosen for the
   * implicit.  We recognize that fact and optimize to get more laziness.
   *
   * @note This method doesn't cause the `Stream` to be fully realized but it
   * should be noted that using the `++` operator from another collection type
   * could cause infinite realization of a `Stream`.  For example, referring to
   * the definition of `fibs` in the preamble, the following would never return:
   * `List(BigInt(12)) ++ fibs`.
   *
   * @tparam B The element type of the returned collection.'''That'''
   * @param that The [[scala.collection.GenTraversableOnce]] the be contatenated
   * to this `Stream`.
   * @return A new collection containing the result of concatenating `this` with
   * `that`.
   */</span>
  override def <a title="[B &gt;: A, That](that: scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That" id="scala.collection.immutable;Stream.++">++</a><span class="delimiter">[</span><a title=" &gt;: A" id="scala.collection.immutable;Stream.++;B">B</a> &gt;: A, <a title="" id="scala.collection.immutable;Stream.++;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.collection.GenTraversableOnce[B]" id="scala.collection.immutable;Stream.++.that">that</a>: <a href="../GenTraversableOnce.scala.html#scala.collection;GenTraversableOnce" title="scala.collection.GenTraversableOnce[B]">GenTraversableOnce</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]" id="scala.collection.immutable;Stream.++.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream.++;That" title="That">That</a> =
    <span class="comment">// we assume there is no other builder factory on streams and therefore know that That = Stream[A]</span>
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.isStreamBuilder" title="(bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])Boolean">isStreamBuilder</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.++.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.asThat" title="(x: AnyRef)Nothing">asThat</a><span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.++.that" title="scala.collection.GenTraversableOnce[B]">that</a>.<a href="../GenTraversableOnce.scala.html#scala.collection;GenTraversableOnce.toStream" title="=&gt; Stream[B]">toStream</a>
      else <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: A, tl: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.Cons[A]">cons</a><span class="delimiter">(</span><a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="#scala.collection.immutable;Stream.asStream" title="[B](x: AnyRef)scala.collection.immutable.Stream[B]">asStream</a><span title="(x: AnyRef)scala.collection.immutable.Stream[A]" class="delimiter">[</span><a href="#scala.collection.immutable;Stream;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a> <a href="#scala.collection.immutable;Stream.++" title="(that: scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,AnyRef])AnyRef">++</a> <a href="#scala.collection.immutable;Stream.++.that" title="scala.collection.GenTraversableOnce[B]">that</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    else super.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.++" title="(that: scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That">++</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.++.that" title="scala.collection.GenTraversableOnce[B]">that</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.++.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span>

  override def <a title="[B &gt;: A, That](elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That" id="scala.collection.immutable;Stream.+:">+:</a><span class="delimiter">[</span><a title=" &gt;: A" id="scala.collection.immutable;Stream.+:;B">B</a> &gt;: A, <a title="" id="scala.collection.immutable;Stream.+:;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scala.collection.immutable;Stream.+:.elem">elem</a>: <a href="#scala.collection.immutable;Stream.+:;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]" id="scala.collection.immutable;Stream.+:.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream.+:;That" title="That">That</a> =
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.isStreamBuilder" title="(bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])Boolean">isStreamBuilder</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.+:.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.asThat" title="(x: AnyRef)Nothing">asThat</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: B, tl: =&gt; scala.collection.immutable.Stream[B])scala.collection.immutable.Stream.Cons[B]">cons</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.+:.elem" title="B">elem</a>, this<span class="delimiter">)</span><span class="delimiter">)</span>
    else super.<a href="../SeqLike.scala.html#scala.collection;SeqLike.+:" title="(elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That">+:</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.+:.elem" title="B">elem</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.+:.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Create a new stream which contains all intermediate results of applying the
   * operator to subsequent elements left to right.  `scanLeft` is analogous to
   * `foldLeft`.
   *
   * @note This works because the target type of the
   * [[scala.collection.mutable.Builder]] `That` is a `Stream`.
   *
   * @param z The initial value for the scan.
   * @param op A function that will apply operations to successive values in the
   * `Stream` against previous accumulated results.
   * @return A new collection containing the modifications from the application
   * of `op`.
   */</span>
  override final def <a title="[B, That](z: B)(op: (B, A) =&gt; B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That" id="scala.collection.immutable;Stream.scanLeft">scanLeft</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;Stream.scanLeft;B">B</a>, <a title="" id="scala.collection.immutable;Stream.scanLeft;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scala.collection.immutable;Stream.scanLeft.z">z</a>: <a href="#scala.collection.immutable;Stream.scanLeft;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, A) =&gt; B" id="scala.collection.immutable;Stream.scanLeft.op">op</a>: <span class="delimiter">(</span>B, A<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]" id="scala.collection.immutable;Stream.scanLeft.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream.scanLeft;That" title="That">That</a> =
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.isStreamBuilder" title="(bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])Boolean">isStreamBuilder</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.scanLeft.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.asThat" title="(x: AnyRef)Nothing">asThat</a><span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.apply" title="(xs: B*)scala.collection.immutable.Stream[B]">Stream</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.scanLeft.z" title="B">z</a><span class="delimiter">)</span>
      else <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: B, tl: =&gt; scala.collection.immutable.Stream[B])scala.collection.immutable.Stream.Cons[B]">cons</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.scanLeft.z" title="B">z</a>, <a href="#scala.collection.immutable;Stream.asStream" title="[B](x: AnyRef)scala.collection.immutable.Stream[B]">asStream</a><span title="(x: AnyRef)scala.collection.immutable.Stream[B]" class="delimiter">[</span><a href="#scala.collection.immutable;Stream.scanLeft;B" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>.<a href="#scala.collection.immutable;Stream.scanLeft" title="(z: B)(op: (B, A) =&gt; B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,AnyRef])AnyRef">scanLeft</a><span class="delimiter">(</span><a href="../../Function2.scala.html#scala;Function2.apply" title="(v1: B, v2: A)B">op</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.scanLeft.z" title="B">z</a>, <a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span><span class="delimiter">)</span><a href="#scala.collection.immutable.Stream.canBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream.Coll,B,scala.collection.immutable.Stream[B]]" class="delimiter">(</a><a href="#scala.collection.immutable;Stream.scanLeft.op" title="(B, A) =&gt; B">op</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    else super.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.scanLeft" title="(z: B)(op: (B, A) =&gt; B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That">scanLeft</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.scanLeft.z" title="B">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.scanLeft.op" title="(B, A) =&gt; B">op</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.scanLeft.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span>

  <span class="comment">/** Returns the stream resulting from applying the given function `f` to each
   * element of this stream.  This returns a lazy `Stream` such that it does not
   * need to be fully realized.
   *
   * @example {{{
   * $naturalsEx
   * naturalsFrom(1).map(_ + 10) take 5 mkString(&quot;, &quot;)
   * // produces: &quot;11, 12, 13, 14, 15&quot;
   * }}}
   *
   * @tparam B The element type of the returned collection '''That'''.
   * @param f function to apply to each element.
   * @return  `f(a,,0,,), ..., f(a,,n,,)` if this sequence is `a,,0,,, ..., a,,n,,`.
   */</span>
  override final def <a title="[B, That](f: A =&gt; B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That" id="scala.collection.immutable;Stream.map">map</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;Stream.map;B">B</a>, <a title="" id="scala.collection.immutable;Stream.map;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scala.collection.immutable;Stream.map.f">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]" id="scala.collection.immutable;Stream.map.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream.map;That" title="That">That</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.isStreamBuilder" title="(bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])Boolean">isStreamBuilder</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.map.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.asThat" title="(x: AnyRef)Nothing">asThat</a><span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.Empty.readResolve" title="scala.collection.immutable.Stream.Empty.type">Empty</a>
      else <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: B, tl: =&gt; scala.collection.immutable.Stream[B])scala.collection.immutable.Stream.Cons[B]">cons</a><span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span>, <a href="#scala.collection.immutable;Stream.asStream" title="[B](x: AnyRef)scala.collection.immutable.Stream[B]">asStream</a><span title="(x: AnyRef)scala.collection.immutable.Stream[B]" class="delimiter">[</span><a href="#scala.collection.immutable;Stream.map;B" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a> <a href="#scala.collection.immutable;Stream.map" title="(f: A =&gt; B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,AnyRef])AnyRef">map</a> <a href="#scala.collection.immutable;Stream.map.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    else super.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.map" title="(f: A =&gt; B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That">map</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.map.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.map.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  override final def <a title="[B, That](pf: PartialFunction[A,B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That" id="scala.collection.immutable;Stream.collect">collect</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;Stream.collect;B">B</a>, <a title="" id="scala.collection.immutable;Stream.collect;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[A,B]" id="scala.collection.immutable;Stream.collect.pf">pf</a>: <a href="../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[A,B]">PartialFunction</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]" id="scala.collection.immutable;Stream.collect.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream.collect;That" title="That">That</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.isStreamBuilder" title="(bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])Boolean">isStreamBuilder</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.collect.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span><span class="delimiter">)</span> super.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.collect" title="(pf: PartialFunction[A,B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That">collect</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.collect.pf" title="PartialFunction[A,B]">pf</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.collect.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span>
    else <span class="delimiter">{</span>
      <span class="comment">// this implementation avoids:</span>
      <span class="comment">// 1) stackoverflows (could be achieved with tailrec, too)</span>
      <span class="comment">// 2) out of memory errors for big streams (`this` reference can be eliminated from the stack)</span>
      var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.collect.rest">rest</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = this

      <span class="comment">// Avoids calling both `pf.isDefined` and `pf.apply`.</span>
      var <a title="B" id="scala.collection.immutable;Stream.collect.newHead">newHead</a>: <a href="#scala.collection.immutable;Stream.collect;B" title="B">B</a> = null.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="B" class="delimiter">[</span><a href="#scala.collection.immutable;Stream.collect;B" title="B">B</a><span class="delimiter">]</span>
      val <a title="A =&gt; Boolean" id="scala.collection.immutable;Stream.collect.runWith">runWith</a> = <a href="#scala.collection.immutable;Stream.collect.pf" title="PartialFunction[A,B]">pf</a>.<a href="../../PartialFunction.scala.html#scala;PartialFunction.runWith" title="(action: B =&gt; Unit)A =&gt; Boolean">runWith</a><span class="delimiter">(</span><span class="delimiter">(</span>b: <a href="#scala.collection.immutable;Stream.collect;B" title="B">B</a><span class="delimiter">)</span> =&gt; <a href="#scala.collection.immutable;Stream.collect.newHead" title="B">newHead</a> = <a href="#scala.collection.immutable;Stream.collect.runWith.$anonfun.b" title="B">b</a><span class="delimiter">)</span>

      while <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.collect.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)Boolean">runWith</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.collect.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.collect.rest" title="scala.collection.immutable.Stream[A]">rest</a> = <a href="#scala.collection.immutable;Stream.collect.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>

      <span class="comment">//  without the call to the companion object, a thunk is created for the tail of the new stream,</span>
      <span class="comment">//  and the closure of the thunk will reference `this`</span>
      if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.collect.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.Empty.readResolve" title="scala.collection.immutable.Stream.Empty.type">Empty</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="That" class="delimiter">[</span><a href="#scala.collection.immutable;Stream.collect;That" title="That">That</a><span class="delimiter">]</span>
      else <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.collectedTail" title="(head: B, stream: scala.collection.immutable.Stream[A], pf: PartialFunction[A,B], bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])scala.collection.immutable.Stream.Cons[B]">collectedTail</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.collect.newHead" title="B">newHead</a>, <a href="#scala.collection.immutable;Stream.collect.rest" title="scala.collection.immutable.Stream[A]">rest</a>, <a href="#scala.collection.immutable;Stream.collect.pf" title="PartialFunction[A,B]">pf</a>, <a href="#scala.collection.immutable;Stream.collect.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="That" class="delimiter">[</span><a href="#scala.collection.immutable;Stream.collect;That" title="That">That</a><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Applies the given function `f` to each element of this stream, then
   * concatenates the results.  As with `map` this function does not need to
   * realize the entire `Stream` but continues to keep it as a lazy `Stream`.
   *
   * @example {{{
   * // Let's create a Stream of Vectors, each of which contains the
   * // collection of Fibonacci numbers up to the current value.  We
   * // can then 'flatMap' that Stream.
   *
   * val fibVec: Stream[Vector[Int]] = Vector(0) #:: Vector(0, 1) #:: fibVec.zip(fibVec.tail).map(n =&gt; {
   *   n._2 ++ Vector(n._1.last + n._2.last)
   * })
   *
   * fibVec take 5 foreach println
   * // prints
   * // Vector(0)
   * // Vector(0, 1)
   * // Vector(0, 1, 1)
   * // Vector(0, 1, 1, 2)
   * // Vector(0, 1, 1, 2, 3)
   *
   * // If we now want to `flatMap` across that stream by adding 10
   * // we can see what the series turns into:
   *
   * fibVec.flatMap(_.map(_ + 10)) take 15 mkString(&quot;, &quot;)
   * // produces: 10, 10, 11, 10, 11, 11, 10, 11, 11, 12, 10, 11, 11, 12, 13
   * }}}
   *
   * ''Note:''  Currently `flatMap` will evaluate as much of the Stream as needed
   * until it finds a non-empty element for the head, which is non-lazy.
   *
   * @tparam B The element type of the returned collection '''That'''.
   * @param f  the function to apply on each element.
   * @return  `f(a,,0,,) ::: ... ::: f(a,,n,,)` if
   *           this stream is `[a,,0,,, ..., a,,n,,]`.
   */</span>
  override final def <a title="[B, That](f: A =&gt; scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That" id="scala.collection.immutable;Stream.flatMap">flatMap</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;Stream.flatMap;B">B</a>, <a title="" id="scala.collection.immutable;Stream.flatMap;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scala.collection.GenTraversableOnce[B]" id="scala.collection.immutable;Stream.flatMap.f">f</a>: A =&gt; GenTraversableOnce<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]" id="scala.collection.immutable;Stream.flatMap.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream.flatMap;That" title="That">That</a> =
    <span class="comment">// we assume there is no other builder factory on streams and therefore know that That = Stream[B]</span>
    <span class="comment">// optimisations are not for speed, but for functionality</span>
    <span class="comment">// see tickets #153, #498, #2147, and corresponding tests in run/ (as well as run/stream_flatmap_odds.scala)</span>
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.isStreamBuilder" title="(bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])Boolean">isStreamBuilder</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.flatMap.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.asThat" title="(x: AnyRef)Nothing">asThat</a><span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.Empty.readResolve" title="scala.collection.immutable.Stream.Empty.type">Empty</a>
      else <span class="delimiter">{</span>
        <span class="comment">// establish !prefix.isEmpty || nonEmptyPrefix.isEmpty</span>
        var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.flatMap.nonEmptyPrefix">nonEmptyPrefix</a> = this
        var <a title="Stream[B]" id="scala.collection.immutable;Stream.flatMap.prefix">prefix</a> = <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)scala.collection.GenTraversableOnce[B]">f</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.flatMap.nonEmptyPrefix" title="scala.collection.immutable.Stream[A]">nonEmptyPrefix</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span>.<a href="../GenTraversableOnce.scala.html#scala.collection;GenTraversableOnce.toStream" title="=&gt; Stream[B]">toStream</a>
        while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.flatMap.nonEmptyPrefix" title="scala.collection.immutable.Stream[A]">nonEmptyPrefix</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.collection.immutable;Stream.flatMap.prefix" title="Stream[B]">prefix</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.flatMap.while$5" title="()Unit" class="delimiter">{</a>
          <a href="#scala.collection.immutable;Stream.flatMap.nonEmptyPrefix" title="scala.collection.immutable.Stream[A]">nonEmptyPrefix</a> = <a href="#scala.collection.immutable;Stream.flatMap.nonEmptyPrefix" title="scala.collection.immutable.Stream[A]">nonEmptyPrefix</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
          if<span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.flatMap.nonEmptyPrefix" title="scala.collection.immutable.Stream[A]">nonEmptyPrefix</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
            <a href="#scala.collection.immutable;Stream.flatMap.prefix" title="Stream[B]">prefix</a> = <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)scala.collection.GenTraversableOnce[B]">f</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.flatMap.nonEmptyPrefix" title="scala.collection.immutable.Stream[A]">nonEmptyPrefix</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span>.<a href="../GenTraversableOnce.scala.html#scala.collection;GenTraversableOnce.toStream" title="=&gt; Stream[B]">toStream</a>
        <span class="delimiter">}</span>

        if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.flatMap.nonEmptyPrefix" title="scala.collection.immutable.Stream[A]">nonEmptyPrefix</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.empty" title="scala.collection.immutable.Stream[Nothing]">empty</a>
        else <a href="#scala.collection.immutable;Stream.flatMap.prefix" title="Stream[B]">prefix</a> <a href="#scala.collection.immutable;Stream.append" title="(rest: =&gt; scala.collection.TraversableOnce[B])scala.collection.immutable.Stream[B]">append</a> <a href="#scala.collection.immutable;Stream.asStream" title="[B](x: AnyRef)scala.collection.immutable.Stream[B]">asStream</a><span title="(x: AnyRef)scala.collection.immutable.Stream[B]" class="delimiter">[</span><a href="#scala.collection.immutable;Stream.flatMap;B" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.flatMap.nonEmptyPrefix" title="scala.collection.immutable.Stream[A]">nonEmptyPrefix</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a> <a href="#scala.collection.immutable;Stream.flatMap" title="(f: A =&gt; scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,AnyRef])AnyRef">flatMap</a> <a href="#scala.collection.immutable;Stream.flatMap.f" title="A =&gt; scala.collection.GenTraversableOnce[B]">f</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">)</span>
    else super.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.flatMap" title="(f: A =&gt; scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That">flatMap</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.flatMap.f" title="A =&gt; scala.collection.GenTraversableOnce[B]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.flatMap.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span>

  <span class="comment">/** Returns all the elements of this `Stream` that satisfy the predicate `p`
   * in a new `Stream` - i.e., it is still a lazy data structure. The order of
   * the elements is preserved
   *
   *  @param p the predicate used to filter the stream.
   *  @return the elements of this stream satisfying `p`.
   *
   * @example {{{
   * $naturalsEx
   * naturalsFrom(1)  10 } filter { _ % 5 == 0 } take 10 mkString(&quot;, &quot;)
   * // produces
   * }}}
   */</span>
  override def <a title="(p: A =&gt; Boolean)scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.filter">filter</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="scala.collection.immutable;Stream.filter.p">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">// optimization: drop leading prefix of elems for which f returns false</span>
    <span class="comment">// var rest = this dropWhile (!p(_)) - forget DRY principle - GC can't collect otherwise</span>
    var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.filter.rest">rest</a> = this
    while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.filter.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.filter.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.filter.rest" title="scala.collection.immutable.Stream[A]">rest</a> = <a href="#scala.collection.immutable;Stream.filter.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
    <span class="comment">// private utility func to avoid `this` on stack (would be needed for the lazy arg)</span>
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.filter.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.filteredTail" title="(stream: scala.collection.immutable.Stream[A], p: A =&gt; Boolean)scala.collection.immutable.Stream.Cons[A]">filteredTail</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.filter.rest" title="scala.collection.immutable.Stream[A]">rest</a>, <a href="#scala.collection.immutable;Stream.filter.p" title="A =&gt; Boolean">p</a><span class="delimiter">)</span>
    else <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.Empty.readResolve" title="scala.collection.immutable.Stream.Empty.type">Empty</a>
  <span class="delimiter">}</span>

  override final def <a title="(p: A =&gt; Boolean)Stream.this.StreamWithFilter" id="scala.collection.immutable;Stream.withFilter">withFilter</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="scala.collection.immutable;Stream.withFilter.p">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream;StreamWithFilter" title="Stream.this.StreamWithFilter">StreamWithFilter</a> = new <a href="#scala.collection.immutable;Stream;StreamWithFilter" title="Stream.this.StreamWithFilter">StreamWithFilter</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.withFilter.p" title="A =&gt; Boolean">p</a><span class="delimiter">)</span>

  <span class="comment">/** A lazier implementation of WithFilter than TraversableLike's.
   */</span>
  final class <a title="class StreamWithFilter extends Stream.this.WithFilter" id="scala.collection.immutable;Stream;StreamWithFilter">StreamWithFilter</a><a href="#scala.collection.immutable;Stream;StreamWithFilter" title="Stream.this.StreamWithFilter" class="delimiter">(</a><a title="A =&gt; Boolean" id="scala.collection.immutable;Stream;StreamWithFilter.p">p</a>: A =&gt; Boolean<span class="delimiter">)</span> extends <a href="../TraversableLike.scala.html#scala.collection;TraversableLike;WithFilter" title="Stream.this.WithFilter">WithFilter</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.p" title="A =&gt; Boolean">p</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    override def <a title="[B, That](f: A =&gt; B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That" id="scala.collection.immutable;Stream;StreamWithFilter.map">map</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;Stream;StreamWithFilter.map;B">B</a>, <a title="" id="scala.collection.immutable;Stream;StreamWithFilter.map;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scala.collection.immutable;Stream;StreamWithFilter.map.f">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]" id="scala.collection.immutable;Stream;StreamWithFilter.map.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream;StreamWithFilter.map;That" title="That">That</a> = <span class="delimiter">{</span>
      def <a title="(coll: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[B]" id="scala.collection.immutable;Stream;StreamWithFilter.map.tailMap">tailMap</a><span class="delimiter">(</span><a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream;StreamWithFilter.map.tailMap.coll">coll</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[B]">Stream</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <span class="delimiter">{</span>
        var <a title="A" id="scala.collection.immutable;Stream;StreamWithFilter.map.tailMap.head">head</a>: <a href="#scala.collection.immutable;Stream;A" title="A">A</a> = null.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="A" class="delimiter">[</span><a href="#scala.collection.immutable;Stream;A" title="A">A</a><span class="delimiter">]</span>
        var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream;StreamWithFilter.map.tailMap.tail">tail</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scala.collection.immutable;Stream;StreamWithFilter.map.tailMap.coll" title="scala.collection.immutable.Stream[A]">coll</a>
        while <span class="delimiter">(</span>true<span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream;StreamWithFilter.map.tailMap.while$7" title="()Unit" class="delimiter">{</a>
          if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.map.tailMap.tail" title="scala.collection.immutable.Stream[A]">tail</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
            return <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.Empty.readResolve" title="scala.collection.immutable.Stream.Empty.type">Empty</a>
          <a href="#scala.collection.immutable;Stream;StreamWithFilter.map.tailMap.head" title="A">head</a> = <a href="#scala.collection.immutable;Stream;StreamWithFilter.map.tailMap.tail" title="scala.collection.immutable.Stream[A]">tail</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>
          <a href="#scala.collection.immutable;Stream;StreamWithFilter.map.tailMap.tail" title="scala.collection.immutable.Stream[A]">tail</a> = <a href="#scala.collection.immutable;Stream;StreamWithFilter.map.tailMap.tail" title="scala.collection.immutable.Stream[A]">tail</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
          if <span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.map.tailMap.head" title="A">head</a><span class="delimiter">)</span><span class="delimiter">)</span>
            return <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: B, tl: =&gt; scala.collection.immutable.Stream[B])scala.collection.immutable.Stream.Cons[B]">cons</a><span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.map.tailMap.head" title="A">head</a><span class="delimiter">)</span>, <a href="#scala.collection.immutable;Stream;StreamWithFilter.map.tailMap" title="(coll: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[B]">tailMap</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.map.tailMap.tail" title="scala.collection.immutable.Stream[A]">tail</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        throw new <a href="../../package.scala.html#scala.package;RuntimeException" title="RuntimeException">RuntimeException</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.isStreamBuilder" title="(bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])Boolean">isStreamBuilder</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.map.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.asThat" title="(x: AnyRef)Nothing">asThat</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.map.tailMap" title="(coll: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[B]">tailMap</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a>.this<span class="delimiter">)</span><span class="delimiter">)</span>
      else super.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike;WithFilter.map" title="(f: A =&gt; B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That">map</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.map.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.map.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    override def <a title="[B, That](f: A =&gt; scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That" id="scala.collection.immutable;Stream;StreamWithFilter.flatMap">flatMap</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;Stream;StreamWithFilter.flatMap;B">B</a>, <a title="" id="scala.collection.immutable;Stream;StreamWithFilter.flatMap;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scala.collection.GenTraversableOnce[B]" id="scala.collection.immutable;Stream;StreamWithFilter.flatMap.f">f</a>: A =&gt; GenTraversableOnce<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]" id="scala.collection.immutable;Stream;StreamWithFilter.flatMap.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap;That" title="That">That</a> = <span class="delimiter">{</span>
      def <a title="(coll: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[B]" id="scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap">tailFlatMap</a><span class="delimiter">(</span><a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap.coll">coll</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[B]">Stream</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <span class="delimiter">{</span>
        var <a title="A" id="scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap.head">head</a>: <a href="#scala.collection.immutable;Stream;A" title="A">A</a> = null.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="A" class="delimiter">[</span><a href="#scala.collection.immutable;Stream;A" title="A">A</a><span class="delimiter">]</span>
        var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap.tail">tail</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap.coll" title="scala.collection.immutable.Stream[A]">coll</a>
        while <span class="delimiter">(</span>true<span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap.while$8" title="()Unit" class="delimiter">{</a>
          if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap.tail" title="scala.collection.immutable.Stream[A]">tail</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
            return <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.Empty.readResolve" title="scala.collection.immutable.Stream.Empty.type">Empty</a>
          <a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap.head" title="A">head</a> = <a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap.tail" title="scala.collection.immutable.Stream[A]">tail</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>
          <a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap.tail" title="scala.collection.immutable.Stream[A]">tail</a> = <a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap.tail" title="scala.collection.immutable.Stream[A]">tail</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
          if <span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap.head" title="A">head</a><span class="delimiter">)</span><span class="delimiter">)</span>
            return <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)scala.collection.GenTraversableOnce[B]">f</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap.head" title="A">head</a><span class="delimiter">)</span>.<a href="../GenTraversableOnce.scala.html#scala.collection;GenTraversableOnce.toStream" title="=&gt; Stream[B]">toStream</a> <a href="#scala.collection.immutable;Stream.append" title="(rest: =&gt; scala.collection.TraversableOnce[B])scala.collection.immutable.Stream[B]">append</a> <a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap" title="(coll: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[B]">tailFlatMap</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap.tail" title="scala.collection.immutable.Stream[A]">tail</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        throw new <a href="../../package.scala.html#scala.package;RuntimeException" title="RuntimeException">RuntimeException</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.isStreamBuilder" title="(bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])Boolean">isStreamBuilder</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.asThat" title="(x: AnyRef)Nothing">asThat</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.tailFlatMap" title="(coll: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[B]">tailFlatMap</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a>.this<span class="delimiter">)</span><span class="delimiter">)</span>
      else super.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike;WithFilter.flatMap" title="(f: A =&gt; scala.collection.GenTraversableOnce[B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That">flatMap</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.f" title="A =&gt; scala.collection.GenTraversableOnce[B]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.flatMap.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    override def <a title="[B](f: A =&gt; B)Unit" id="scala.collection.immutable;Stream;StreamWithFilter.foreach">foreach</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;Stream;StreamWithFilter.foreach;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scala.collection.immutable;Stream;StreamWithFilter.foreach.f">f</a>: A =&gt; B<span class="delimiter">)</span> =
      for <span class="delimiter">(</span><a title="A" id="scala.collection.immutable;Stream;StreamWithFilter.foreach.$anonfun.x">x</a> &lt;- <a href="#scala.collection.immutable;Stream.foreach" title="(f: A =&gt; Any)Unit">self</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.foreach.$anonfun.x" title="A">x</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.foreach.$anonfun.x" title="A">x</a><span class="delimiter">)</span>

    override def <a title="(q: A =&gt; Boolean)Stream.this.StreamWithFilter" id="scala.collection.immutable;Stream;StreamWithFilter.withFilter">withFilter</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="scala.collection.immutable;Stream;StreamWithFilter.withFilter.q">q</a>: A =&gt; Boolean<span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream;StreamWithFilter" title="Stream.this.StreamWithFilter">StreamWithFilter</a> =
      new <a href="#scala.collection.immutable;Stream;StreamWithFilter" title="Stream.this.StreamWithFilter">StreamWithFilter</a><span class="delimiter">(</span><a title="A" id="scala.collection.immutable;Stream;StreamWithFilter.withFilter.$anonfun.x">x</a> =&gt; <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.withFilter.$anonfun.x" title="A">x</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)Boolean">q</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream;StreamWithFilter.withFilter.$anonfun.x" title="A">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A lazier Iterator than LinearSeqLike's. */</span>
  override def <a title="=&gt; Iterator[A]" id="scala.collection.immutable;Stream.iterator">iterator</a>: <a href="../Iterator.scala.html#scala.collection;Iterator" title="Iterator[A]">Iterator</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = new <a href="#scala.collection.immutable;StreamIterator" title="scala.collection.immutable.StreamIterator[A]">StreamIterator</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">self</a><span class="delimiter">)</span>

  <span class="comment">/** Apply the given function `f` to each element of this linear sequence
   * (while respecting the order of the elements).
   *
   *  @param f The treatment to apply to each element.
   *  @note  Overridden here as final to trigger tail-call optimization, which
   *  replaces 'this' with 'tail' at each iteration. This is absolutely
   *  necessary for allowing the GC to collect the underlying stream as elements
   *  are consumed.
   *  @note  This function will force the realization of the entire stream
   *  unless the `f` throws an exception.
   */</span>
  @tailrec
  override final def <a title="[B](f: A =&gt; B)Unit" id="scala.collection.immutable;Stream.foreach">foreach</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;Stream.foreach;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="scala.collection.immutable;Stream.foreach.f">f</a>: A =&gt; B<span class="delimiter">)</span> <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a>this.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span>
      <a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>.<a href="#scala.collection.immutable;Stream.foreach" title="(f: A =&gt; B)Unit">foreach</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.foreach.f" title="A =&gt; B">f</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Stream specialization of foldLeft which allows GC to collect along the
   * way.
   *
   * @tparam B The type of value being accumulated.
   * @param z The initial value seeded into the function `op`.
   * @param op The operation to perform on successive elements of the `Stream`.
   * @return The accumulated value from successive applications of `op`.
   */</span>
  @tailrec
  override final def <a title="[B](z: B)(op: (B, A) =&gt; B)B" id="scala.collection.immutable;Stream.foldLeft">foldLeft</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;Stream.foldLeft;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scala.collection.immutable;Stream.foldLeft.z">z</a>: <a href="#scala.collection.immutable;Stream.foldLeft;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, A) =&gt; B" id="scala.collection.immutable;Stream.foldLeft.op">op</a>: <span class="delimiter">(</span>B, A<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream.foldLeft;B" title="B">B</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span>this.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.foldLeft.z" title="B">z</a>
    else <a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>.<a href="#scala.collection.immutable;Stream.foldLeft" title="(z: B)(op: (B, A) =&gt; B)B">foldLeft</a><span class="delimiter">(</span><a href="../../Function2.scala.html#scala;Function2.apply" title="(v1: B, v2: A)B">op</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.foldLeft.z" title="B">z</a>, <a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.foldLeft.op" title="(B, A) =&gt; B">op</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Stream specialization of reduceLeft which allows GC to collect
   *  along the way.
   *
   * @tparam B The type of value being accumulated.
   * @param f The operation to perform on successive elements of the `Stream`.
   * @return The accumulated value from successive applications of `f`.
   */</span>
  override final def <a title="[B &gt;: A](f: (B, A) =&gt; B)B" id="scala.collection.immutable;Stream.reduceLeft">reduceLeft</a><span class="delimiter">[</span><a title=" &gt;: A" id="scala.collection.immutable;Stream.reduceLeft;B">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="(B, A) =&gt; B" id="scala.collection.immutable;Stream.reduceLeft.f">f</a>: <span class="delimiter">(</span>B, A<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream.reduceLeft;B" title="B">B</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span>this.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> throw new <a href="../../package.scala.html#scala.package;UnsupportedOperationException" title="UnsupportedOperationException">UnsupportedOperationException</a><span class="delimiter">(</span><span title="String(&quot;empty.reduceLeft&quot;)" class="string">&quot;empty.reduceLeft&quot;</span><span class="delimiter">)</span>
    else <span class="delimiter">{</span>
      var <a title="B" id="scala.collection.immutable;Stream.reduceLeft.reducedRes">reducedRes</a>: <a href="#scala.collection.immutable;Stream.reduceLeft;B" title="B">B</a> = this.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>
      var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.reduceLeft.left">left</a> = this.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
      while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.reduceLeft.left" title="scala.collection.immutable.Stream[A]">left</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.reduceLeft.while$9" title="()Unit" class="delimiter">{</a>
        <a href="#scala.collection.immutable;Stream.reduceLeft.reducedRes" title="B">reducedRes</a> = <a href="../../Function2.scala.html#scala;Function2.apply" title="(v1: B, v2: A)B">f</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.reduceLeft.reducedRes" title="B">reducedRes</a>, <a href="#scala.collection.immutable;Stream.reduceLeft.left" title="scala.collection.immutable.Stream[A]">left</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span>
        <a href="#scala.collection.immutable;Stream.reduceLeft.left" title="scala.collection.immutable.Stream[A]">left</a> = <a href="#scala.collection.immutable;Stream.reduceLeft.left" title="scala.collection.immutable.Stream[A]">left</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
      <span class="delimiter">}</span>
      <a href="#scala.collection.immutable;Stream.reduceLeft.reducedRes" title="B">reducedRes</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Returns all the elements of this stream that satisfy the predicate `p`
   * returning of [[scala.Tuple2]] of `Stream`s obeying the partition predicate
   * `p`. The order of the elements is preserved.
   *
   * @param p the predicate used to filter the stream.
   * @return the elements of this stream satisfying `p`.
   *
   * @example {{{
   * $naturalsEx
   * val parts = naturalsFrom(1) partition { _ % 2 == 0 }
   * parts._1 take 10 mkString &quot;, &quot;
   * // produces: &quot;2, 4, 6, 8, 10, 12, 14, 16, 18, 20&quot;
   * parts._2 take 10 mkString &quot;, &quot;
   * // produces: &quot;1, 3, 5, 7, 9, 11, 13, 15, 17, 19&quot;
   * }}}
   *
   */</span>
  override def <a title="(p: A =&gt; Boolean)(scala.collection.immutable.Stream[A], scala.collection.immutable.Stream[A])" id="scala.collection.immutable;Stream.partition">partition</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="scala.collection.immutable;Stream.partition.p">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Tuple2.scala.html#scala;Tuple2" title="(scala.collection.immutable.Stream[A], scala.collection.immutable.Stream[A])" class="delimiter">(</a>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, Stream<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: scala.collection.immutable.Stream[A], _2: scala.collection.immutable.Stream[A])(scala.collection.immutable.Stream[A], scala.collection.immutable.Stream[A])" class="delimiter">(</a><a href="#scala.collection.immutable;Stream.filter" title="(p: A =&gt; Boolean)scala.collection.immutable.Stream[A]">filter</a><span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.partition.$anonfun.x$1" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="../TraversableLike.scala.html#scala.collection;TraversableLike.filterNot" title="(p: A =&gt; Boolean)scala.collection.immutable.Stream[A]">filterNot</a><span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.partition.$anonfun.x$2" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Returns a stream formed from this stream and the specified stream `that`
   * by associating each element of the former with the element at the same
   * position in the latter.
   *
   * If one of the two streams is longer than the other, its remaining elements
   * are ignored.
   *
   * The return type of this function may not be obvious.  The lazy aspect of
   * the returned value is different than that of `partition`.  In `partition`
   * we get back a [[scala.Tuple2]] of two lazy `Stream`s whereas here we get
   * back a single lazy `Stream` of [[scala.Tuple2]]s where the
   * [[scala.Tuple2]]'s type signature is `(A1, B)`.
   *
   * @tparam A1 The type of the first parameter of the zipped tuple
   * @tparam B The type of the second parameter of the zipped tuple
   * @tparam That The type of the returned `Stream`.
   * @return `Stream({a,,0,,,b,,0,,}, ...,
   *         {a,,min(m,n),,,b,,min(m,n),,)}` when
   *         `Stream(a,,0,,, ..., a,,m,,)
   *         zip Stream(b,,0,,, ..., b,,n,,)` is invoked.
   *
   * @example {{{
   * $naturalsEx
   * naturalsFrom(1) zip naturalsFrom(2) take 5 foreach println
   * // prints
   * // (1,2)
   * // (2,3)
   * // (3,4)
   * // (4,5)
   * // (5,6)
   * }}}
   */</span>
  override final def <a title="[A1 &gt;: A, B, That](that: scala.collection.GenIterable[B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],(A1, B),That])That" id="scala.collection.immutable;Stream.zip">zip</a><span class="delimiter">[</span><a title=" &gt;: A" id="scala.collection.immutable;Stream.zip;A1">A1</a> &gt;: A, <a title="" id="scala.collection.immutable;Stream.zip;B">B</a>, <a title="" id="scala.collection.immutable;Stream.zip;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.collection.GenIterable[B]" id="scala.collection.immutable;Stream.zip.that">that</a>: scala.collection.<a href="../GenIterable.scala.html#scala.collection;GenIterable" title="scala.collection.GenIterable[B]">GenIterable</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],(A1, B),That]" id="scala.collection.immutable;Stream.zip.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],(A1, B),That]">CanBuildFrom</a><span class="delimiter">[</span>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, <span class="delimiter">(</span>A1, B<span class="delimiter">)</span>, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream.zip;That" title="That">That</a> =
    <span class="comment">// we assume there is no other builder factory on streams and therefore know that That = Stream[(A1, B)]</span>
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.isStreamBuilder" title="(bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],(A1, B),That])Boolean">isStreamBuilder</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.zip.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],(A1, B),That]">bf</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.asThat" title="(x: AnyRef)Nothing">asThat</a><span class="delimiter">(</span>
      if <span class="delimiter">(</span>this.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.collection.immutable;Stream.zip.that" title="scala.collection.GenIterable[B]">that</a>.<a href="../generic/GenericTraversableTemplate.scala.html#scala.collection.generic;GenericTraversableTemplate.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.Empty.readResolve" title="scala.collection.immutable.Stream.Empty.type">Empty</a>
      else <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: (A1, B), tl: =&gt; scala.collection.immutable.Stream[(A1, B)])scala.collection.immutable.Stream.Cons[(A1, B)]">cons</a><span class="delimiter">(</span><a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: A, _2: B)(A, B)" class="delimiter">(</a>this.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="#scala.collection.immutable;Stream.zip.that" title="scala.collection.GenIterable[B]">that</a>.<a href="../generic/GenericTraversableTemplate.scala.html#scala.collection.generic;GenericTraversableTemplate.head" title="=&gt; B">head</a><span class="delimiter">)</span>, <a href="#scala.collection.immutable;Stream.asStream" title="[B](x: AnyRef)scala.collection.immutable.Stream[B]">asStream</a><span title="(x: AnyRef)scala.collection.immutable.Stream[(A1, B)]" class="delimiter">[</span><a href="../../Tuple2.scala.html#scala;Tuple2" title="(A1, B)" class="delimiter">(</a>A1, B<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">(</span>this.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a> <a href="#scala.collection.immutable;Stream.zip" title="(that: scala.collection.GenIterable[B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],(A, B),AnyRef])AnyRef">zip</a> <a href="#scala.collection.immutable;Stream.zip.that" title="scala.collection.GenIterable[B]">that</a>.<a href="../GenTraversableLike.scala.html#scala.collection;GenTraversableLike.tail" title="=&gt; scala.collection.GenIterable[B]">tail</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    else super.<a href="../IterableLike.scala.html#scala.collection;IterableLike.zip" title="(that: scala.collection.GenIterable[B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],(A, B),That])That">zip</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.zip.that" title="scala.collection.GenIterable[B]">that</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.zip.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],(A1, B),That]">bf</a><span class="delimiter">)</span>

  <span class="comment">/** Zips this iterable with its indices. `s.zipWithIndex` is equivalent to `s
   * zip s.indices`.
   *
   * This method is much like `zip` in that it returns a single lazy `Stream` of
   * [[scala.Tuple2]].
   *
   * @tparam A1 The type of the first element of the [[scala.Tuple2]] in the
   * resulting stream.
   * @tparam That The type of the resulting `Stream`.
   * @return `Stream({a,,0,,,0}, ..., {a,,n,,,n)}`
   *
   * @example {{{
   * $naturalsEx
   * (naturalsFrom(1) zipWithIndex) take 5 foreach println
   * // prints
   * // (1,0)
   * // (2,1)
   * // (3,2)
   * // (4,3)
   * // (5,4)
   * }}}
   */</span>
  override def <a title="[A1 &gt;: A, That](implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],(A1, Int),That])That" id="scala.collection.immutable;Stream.zipWithIndex">zipWithIndex</a><span class="delimiter">[</span><a title=" &gt;: A" id="scala.collection.immutable;Stream.zipWithIndex;A1">A1</a> &gt;: A, <a title="" id="scala.collection.immutable;Stream.zipWithIndex;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],(A1, Int),That]" id="scala.collection.immutable;Stream.zipWithIndex.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],(A1, Int),That]">CanBuildFrom</a><span class="delimiter">[</span>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, <span class="delimiter">(</span>A1, Int<span class="delimiter">)</span>, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream.zipWithIndex;That" title="That">That</a> =
    this.<a href="#scala.collection.immutable;Stream.zip" title="[A1 &gt;: A, B, That](that: scala.collection.GenIterable[B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],(A1, B),That])That">zip</a><span title="(that: scala.collection.GenIterable[Int])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],(A1, Int),That])That" class="delimiter">[</span><a href="#scala.collection.immutable;Stream.zipWithIndex;A1" title="A1">A1</a>, <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>, <a href="#scala.collection.immutable;Stream.zipWithIndex;That" title="That">That</a><span class="delimiter">]</span><a href="#scala.collection.immutable;Stream.zipWithIndex.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],(A1, Int),That]" class="delimiter">(</a><a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.from(c7b665afb0)" title="(start: Int)scala.collection.immutable.Stream[Int]">from</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Write all defined elements of this iterable into given string builder.
   *  The written text begins with the string `start` and is finished by the string
   *  `end`. Inside, the string representations of defined elements (w.r.t.
   *  the method `toString()`) are separated by the string `sep`. The method will
   *  not force evaluation of undefined elements. A tail of such elements will be
   * represented by a `&quot;?&quot;` instead.  A cyclic stream is represented by a `&quot;...&quot;`
   * at the point where the cycle repeats.
   *
   * @param b The [[collection.mutable.StringBuilder]] factory to which we need
   * to add the string elements.
   * @param start The prefix of the resulting string (e.g. &quot;Stream(&quot;)
   * @param sep The separator between elements of the resulting string (e.g. &quot;,&quot;)
   * @param end The end of the resulting string (e.g. &quot;)&quot;)
   * @return The original [[collection.mutable.StringBuilder]] containing the
   * resulting string.
   */</span>
  override def <a title="(b: StringBuilder, start: String, sep: String, end: String)StringBuilder" id="scala.collection.immutable;Stream.addString(c6cfc8eaba)">addString</a><span class="delimiter">(</span><a title="StringBuilder" id="scala.collection.immutable;Stream.addString(c6cfc8eaba).b">b</a>: <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder" title="StringBuilder">StringBuilder</a>, <a title="String" id="scala.collection.immutable;Stream.addString(c6cfc8eaba).start">start</a>: <span title="String">String</span>, <a title="String" id="scala.collection.immutable;Stream.addString(c6cfc8eaba).sep">sep</a>: <span title="String">String</span>, <a title="String" id="scala.collection.immutable;Stream.addString(c6cfc8eaba).end">end</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder" title="StringBuilder">StringBuilder</a> = <span class="delimiter">{</span>
    <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).b" title="StringBuilder">b</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(85e140e908)" title="(s: String)StringBuilder">append</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).start" title="String">start</a>
    if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).b" title="StringBuilder">b</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(434f984b99)" title="(x: Any)StringBuilder">append</a> <a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>
      var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor">cursor</a> = this
      var <a title="Int" id="scala.collection.immutable;Stream.addString(c6cfc8eaba).n">n</a> = <span title="Int(1)" class="int">1</span>
      if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a>.<a href="#scala.collection.immutable;Stream.tailDefined" title="=&gt; Boolean">tailDefined</a><span class="delimiter">)</span> <span class="delimiter">{</span>  <span class="comment">// If tailDefined, also !isEmpty</span>
        var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.addString(c6cfc8eaba).scout">scout</a> = <a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
        if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="comment">// Single element.  Bail out early.</span>
          <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).b" title="StringBuilder">b</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(85e140e908)" title="(s: String)StringBuilder">append</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).end" title="String">end</a>
          return <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).b" title="StringBuilder">b</a>
        <span class="delimiter">}</span>
        if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a>.<a href="#scala.collection.immutable;Stream.tailDefined" title="=&gt; Boolean">tailDefined</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a> = <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a>
          <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a> = <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>        
          <span class="comment">// Use 2x 1x iterator trick for cycle detection; slow iterator can add strings</span>
          while <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a>.<a href="#scala.collection.immutable;Stream.tailDefined" title="=&gt; Boolean">tailDefined</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).while$10" title="()Unit" class="delimiter">{</a>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).b" title="StringBuilder">b</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(85e140e908)" title="(s: String)StringBuilder">append</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).sep" title="String">sep</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(434f984b99)" title="(x: Any)StringBuilder">append</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).n" title="Int">n</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a> = <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a> = <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
            if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a>.<a href="#scala.collection.immutable;Stream.tailDefined" title="=&gt; Boolean">tailDefined</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a> = <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a>.<a href="#scala.collection.immutable;Stream.tailDefined" title="=&gt; Boolean">tailDefined</a><span class="delimiter">)</span> <span class="delimiter">{</span>  <span class="comment">// Not a cycle, scout hit an end</span>
          while <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).while$11" title="()Unit" class="delimiter">{</a>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).b" title="StringBuilder">b</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(85e140e908)" title="(s: String)StringBuilder">append</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).sep" title="String">sep</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(434f984b99)" title="(x: Any)StringBuilder">append</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).n" title="Int">n</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a> = <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        else <span class="delimiter">{</span>
          <span class="comment">// Cycle.</span>
          <span class="comment">// If we have a prefix of length P followed by a cycle of length C,</span>
          <span class="comment">// the scout will be at position (P%C) in the cycle when the cursor</span>
          <span class="comment">// enters it at P.  They'll then collide when the scout advances another</span>
          <span class="comment">// C - (P%C) ahead of the cursor.</span>
          <span class="comment">// If we run the scout P farther, then it will be at the start of</span>
          <span class="comment">// the cycle: (C - (P%C) + (P%C)) == C == 0.  So if another runner</span>
          <span class="comment">// starts at the beginning of the prefix, they'll collide exactly at</span>
          <span class="comment">// the start of the loop.</span>
          var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.addString(c6cfc8eaba).runner">runner</a> = this
          var <a title="Int" id="scala.collection.immutable;Stream.addString(c6cfc8eaba).k">k</a> = <span title="Int(0)" class="int">0</span>
          while <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).runner" title="scala.collection.immutable.Stream[A]">runner</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).while$12" title="()Unit" class="delimiter">{</a>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).runner" title="scala.collection.immutable.Stream[A]">runner</a> = <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).runner" title="scala.collection.immutable.Stream[A]">runner</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a> = <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).k" title="Int">k</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
          <span class="delimiter">}</span>
          <span class="comment">// Now runner and scout are at the beginning of the cycle.  Advance</span>
          <span class="comment">// cursor, adding to string, until it hits; then we'll have covered</span>
          <span class="comment">// everything once.  If cursor is already at beginning, we'd better</span>
          <span class="comment">// advance one first unless runner didn't go anywhere (in which case</span>
          <span class="comment">// we've already looped once).</span>
          if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).k" title="Int">k</a> <a href="../../Int.scala.html#scala;Int.>(5f58a84eb3)" title="(x: Int)Boolean">&gt;</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).b" title="StringBuilder">b</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(85e140e908)" title="(s: String)StringBuilder">append</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).sep" title="String">sep</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(434f984b99)" title="(x: Any)StringBuilder">append</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).n" title="Int">n</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a> = <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
          <span class="delimiter">}</span>
          while <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).scout" title="scala.collection.immutable.Stream[A]">scout</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).while$13" title="()Unit" class="delimiter">{</a>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).b" title="StringBuilder">b</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(85e140e908)" title="(s: String)StringBuilder">append</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).sep" title="String">sep</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(434f984b99)" title="(x: Any)StringBuilder">append</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).n" title="Int">n</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
            <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a> = <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
          <span class="delimiter">}</span>
          <span class="comment">// Subtract prefix length from total length for cycle reporting.</span>
          <span class="comment">// (Not currently used, but probably a good idea for the future.)</span>
          <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).n" title="Int">n</a> <a href="../../Int.scala.html#scala;Int.-(1409840560)" title="(x: Int)Int">-=</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).k" title="Int">k</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// Either undefined or cyclic; we can check with tailDefined</span>
        if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).cursor" title="scala.collection.immutable.Stream[A]">cursor</a>.<a href="#scala.collection.immutable;Stream.tailDefined" title="=&gt; Boolean">tailDefined</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).b" title="StringBuilder">b</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(85e140e908)" title="(s: String)StringBuilder">append</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).sep" title="String">sep</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(85e140e908)" title="(s: String)StringBuilder">append</a> <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span>
        else <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).b" title="StringBuilder">b</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(85e140e908)" title="(s: String)StringBuilder">append</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).sep" title="String">sep</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(85e140e908)" title="(s: String)StringBuilder">append</a> <span title="String(&quot;...&quot;)" class="string">&quot;...&quot;</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).b" title="StringBuilder">b</a> <a href="../mutable/StringBuilder.scala.html#scala.collection.mutable;StringBuilder.append(85e140e908)" title="(s: String)StringBuilder">append</a> <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).end" title="String">end</a>
    <a href="#scala.collection.immutable;Stream.addString(c6cfc8eaba).b" title="StringBuilder">b</a>
  <span class="delimiter">}</span>

  override def <a title="(sep: String)String" id="scala.collection.immutable;Stream.mkString(f5d728d244)">mkString</a><span class="delimiter">(</span><a title="String" id="scala.collection.immutable;Stream.mkString(f5d728d244).sep">sep</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <a href="#scala.collection.immutable;Stream.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <a href="#scala.collection.immutable;Stream.mkString(f5d728d244).sep" title="String">sep</a>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
  override def <a title="=&gt; String" id="scala.collection.immutable;Stream.mkString(3bf7c90be7)">mkString</a>: <span title="String">String</span> = <a href="#scala.collection.immutable;Stream.mkString(f5d728d244)" title="(sep: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
  override def <a title="(start: String, sep: String, end: String)String" id="scala.collection.immutable;Stream.mkString(581ef61a02)">mkString</a><span class="delimiter">(</span><a title="String" id="scala.collection.immutable;Stream.mkString(581ef61a02).start">start</a>: <span title="String">String</span>, <a title="String" id="scala.collection.immutable;Stream.mkString(581ef61a02).sep">sep</a>: <span title="String">String</span>, <a title="String" id="scala.collection.immutable;Stream.mkString(581ef61a02).end">end</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    this.<a href="#scala.collection.immutable;Stream.force" title="=&gt; scala.collection.immutable.Stream[A]">force</a>
    super.<a href="../TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.mkString(581ef61a02).start" title="String">start</a>, <a href="#scala.collection.immutable;Stream.mkString(581ef61a02).sep" title="String">sep</a>, <a href="#scala.collection.immutable;Stream.mkString(581ef61a02).end" title="String">end</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  override def <a title="()String" id="scala.collection.immutable;Stream.toString">toString</a> = super.<a href="../TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.stringPrefix" title="=&gt; String">stringPrefix</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>

  override def <a title="(n: Int)(scala.collection.immutable.Stream[A], scala.collection.immutable.Stream[A])" id="scala.collection.immutable;Stream.splitAt">splitAt</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable;Stream.splitAt.n">n</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Tuple2.scala.html#scala;Tuple2" title="(scala.collection.immutable.Stream[A], scala.collection.immutable.Stream[A])" class="delimiter">(</a>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, Stream<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: scala.collection.immutable.Stream[A], _2: scala.collection.immutable.Stream[A])(scala.collection.immutable.Stream[A], scala.collection.immutable.Stream[A])" class="delimiter">(</a><a href="#scala.collection.immutable;Stream.take" title="(n: Int)scala.collection.immutable.Stream[A]">take</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.splitAt.n" title="Int">n</a><span class="delimiter">)</span>, <a href="#scala.collection.immutable;Stream.drop" title="(n: Int)scala.collection.immutable.Stream[A]">drop</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.splitAt.n" title="Int">n</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Returns the `n` first elements of this `Stream` as another `Stream`, or
   * else the whole `Stream`, if it has less than `n` elements.
   *
   * The result of `take` is, again, a `Stream` meaning that it also does not
   * make any needless evaluations of the `Stream` itself, delaying that until
   * the usage of the resulting `Stream`.
   *
   * @param n the number of elements to take.
   * @return the `n` first elements of this stream.
   *
   * @example {{{
   * $naturalsEx
   * scala&gt; naturalsFrom(5) take 5
   * res1: scala.collection.immutable.Stream[Int] = Stream(5, ?)
   *
   * scala&gt; naturalsFrom(5) take 5 mkString &quot;, &quot;
   * // produces: &quot;5, 6, 7, 8, 9&quot;
   * }}}
   */</span>
  override def <a title="(n: Int)scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.take">take</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable;Stream.take.n">n</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">(</span>
    <span class="comment">// Note that the n == 1 condition appears redundant but is not.</span>
    <span class="comment">// It prevents &quot;tail&quot; from being referenced (and its head being evaluated)</span>
    <span class="comment">// when obtaining the last element of the result. Such are the challenges</span>
    <span class="comment">// of working with a lazy-but-not-really sequence.</span>
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.take.n" title="Int">n</a> <a href="../../Int.scala.html#scala;Int.<=(5f58a84eb3)" title="(x: Int)Boolean">&lt;=</a> <span title="Int(0)" class="int">0</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.empty" title="scala.collection.immutable.Stream[Nothing]">empty</a>
    else if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.take.n" title="Int">n</a> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: A, tl: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.Cons[A]">cons</a><span class="delimiter">(</span><a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.empty" title="scala.collection.immutable.Stream[Nothing]">empty</a><span class="delimiter">)</span>
    else <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: A, tl: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.Cons[A]">cons</a><span class="delimiter">(</span><a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a> <a href="#scala.collection.immutable;Stream.take" title="(n: Int)scala.collection.immutable.Stream[A]">take</a> <a href="#scala.collection.immutable;Stream.take.n" title="Int">n</a><a href="../../Int.scala.html#scala;Int.-(1409840560)" title="(x: Int)Int">-</a><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
  <span class="delimiter">)</span>

  @tailrec final override def <a title="(n: Int)scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.drop">drop</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable;Stream.drop.n">n</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.drop.n" title="Int">n</a> <a href="../../Int.scala.html#scala;Int.<=(5f58a84eb3)" title="(x: Int)Boolean">&lt;=</a> <span title="Int(0)" class="int">0</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> this
    else <a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a> <a href="#scala.collection.immutable;Stream.drop" title="(n: Int)scala.collection.immutable.Stream[A]">drop</a> <a href="#scala.collection.immutable;Stream.drop.n" title="Int">n</a><a href="../../Int.scala.html#scala;Int.-(1409840560)" title="(x: Int)Int">-</a><span title="Int(1)" class="int">1</span>

  <span class="comment">/** A substream starting at index `from` and extending up to (but not including)
   *  index `until`.  This returns a `Stream` that is lazily evaluated.
   *
   * @param from    The index of the first element of the returned subsequence
   * @param until   The index of the element following the returned subsequence
   * @return A new string containing the elements requested from `start` until
   * `end`.
   *
   * @example {{{
   * naturalsFrom(0) slice(50, 60) mkString &quot;, &quot;
   * // produces: &quot;50, 51, 52, 53, 54, 55, 56, 57, 58, 59&quot;
   * }}}
   */</span>
  override def <a title="(from: Int, until: Int)scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.slice">slice</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable;Stream.slice.from">from</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>, <a title="Int" id="scala.collection.immutable;Stream.slice.until">until</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val lo = <a href="../../Predef.scala.html#scala;LowPriorityImplicits.intWrapper" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">from</a> <a href="../../runtime/RichInt.scala.html#scala.runtime;RichInt.max" title="Int" id="scala.collection.immutable;Stream.slice.lo">max</a> <span title="Int(0)" class="int">0</span>
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.slice.until" title="Int">until</a> <a href="../../Int.scala.html#scala;Int.<=(5f58a84eb3)" title="(x: Int)Boolean">&lt;=</a> <a href="#scala.collection.immutable;Stream.slice.lo" title="Int">lo</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.empty" title="scala.collection.immutable.Stream[Nothing]">empty</a>
    else this <a href="#scala.collection.immutable;Stream.drop" title="(n: Int)scala.collection.immutable.Stream[A]">drop</a> <a href="#scala.collection.immutable;Stream.slice.lo" title="Int">lo</a> <a href="#scala.collection.immutable;Stream.take" title="(n: Int)scala.collection.immutable.Stream[A]">take</a> <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.slice.until" title="Int">until</a> <a href="../../Int.scala.html#scala;Int.-(1409840560)" title="(x: Int)Int">-</a> <a href="#scala.collection.immutable;Stream.slice.lo" title="Int">lo</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The stream without its last element.
   *
   * @return A new `Stream` containing everything but the last element.  If your
   * `Stream` represents an infinite series, this method will not return.
   *
   *  @throws `Predef.UnsupportedOperationException` if the stream is empty.
   */</span>
  override def <a title="=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.init">init</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> super.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.init" title="=&gt; scala.collection.immutable.Stream[A]">init</a>
    else if <span class="delimiter">(</span><a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.Empty.readResolve" title="scala.collection.immutable.Stream.Empty.type">Empty</a>
    else <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: A, tl: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.Cons[A]">cons</a><span class="delimiter">(</span><a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>.<a href="#scala.collection.immutable;Stream.init" title="=&gt; scala.collection.immutable.Stream[A]">init</a><span class="delimiter">)</span>

  <span class="comment">/** Returns the rightmost `n` elements from this iterable.
   *
   * @note Take serious caution here.  If the `Stream` represents an infinite
   * series then this function ''will not return''.  The right most elements of
   * an infinite series takes an infinite amount of time to produce.
   *
   *  @param n the number of elements to take
   *  @return The last `n` elements from this `Stream`.
   */</span>
  override def <a title="(n: Int)scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.takeRight">takeRight</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable;Stream.takeRight.n">n</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.takeRight.these">these</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = this
    var lead = this <a href="#scala.collection.immutable;Stream.drop" title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.takeRight.lead">drop</a> <a href="#scala.collection.immutable;Stream.takeRight.n" title="Int">n</a>
    while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.takeRight.lead" title="scala.collection.immutable.Stream[A]">lead</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.takeRight.while$14" title="()Unit" class="delimiter">{</a>
      <a href="#scala.collection.immutable;Stream.takeRight.these" title="scala.collection.immutable.Stream[A]">these</a> = <a href="#scala.collection.immutable;Stream.takeRight.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
      <a href="#scala.collection.immutable;Stream.takeRight.lead" title="scala.collection.immutable.Stream[A]">lead</a> = <a href="#scala.collection.immutable;Stream.takeRight.lead" title="scala.collection.immutable.Stream[A]">lead</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
    <span class="delimiter">}</span>
    <a href="#scala.collection.immutable;Stream.takeRight.these" title="scala.collection.immutable.Stream[A]">these</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * @inheritdoc
   * $willTerminateInf
   */</span>
  override def <a title="(n: Int)scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.dropRight">dropRight</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable;Stream.dropRight.n">n</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">// We make dropRight work for possibly infinite streams by carrying</span>
    <span class="comment">// a buffer of the dropped size. As long as the buffer is full and the</span>
    <span class="comment">// rest is non-empty, we can feed elements off the buffer head.  When</span>
    <span class="comment">// the rest becomes empty, the full buffer is the dropped elements.</span>
    def <a title="(stub0: List[A], stub1: List[A], rest: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.dropRight.advance">advance</a><span class="delimiter">(</span><a title="List[A]" id="scala.collection.immutable;Stream.dropRight.advance.stub0">stub0</a>: <a href="List.scala.html#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="List[A]" id="scala.collection.immutable;Stream.dropRight.advance.stub1">stub1</a>: <a href="List.scala.html#scala.collection.immutable;List" title="List[A]">List</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.dropRight.advance.rest">rest</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.dropRight.advance.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.empty" title="scala.collection.immutable.Stream[Nothing]">empty</a>
      else if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.dropRight.advance.stub0" title="List[A]">stub0</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.dropRight.advance" title="(stub0: List[A], stub1: List[A], rest: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[A]">advance</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.dropRight.advance.stub1" title="List[A]">stub1</a>.<a href="List.scala.html#scala.collection.immutable;List.reverse" title="=&gt; List[A]">reverse</a>, <a href="List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#scala.collection.immutable;Stream.dropRight.advance.rest" title="scala.collection.immutable.Stream[A]">rest</a><span class="delimiter">)</span>
      else <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: A, tl: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.Cons[A]">cons</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.dropRight.advance.stub0" title="List[A]">stub0</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="#scala.collection.immutable;Stream.dropRight.advance" title="(stub0: List[A], stub1: List[A], rest: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[A]">advance</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.dropRight.advance.stub0" title="List[A]">stub0</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[A]">tail</a>, <a href="#scala.collection.immutable;Stream.dropRight.advance.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a> <a href="List.scala.html#scala.collection.immutable;List.::" title="(x: A)List[A]">::</a> <a href="#scala.collection.immutable;Stream.dropRight.advance.stub1" title="List[A]">stub1</a>, <a href="#scala.collection.immutable;Stream.dropRight.advance.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.dropRight.n" title="Int">n</a> <a href="../../Int.scala.html#scala;Int.<=(5f58a84eb3)" title="(x: Int)Boolean">&lt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> this
    else <a href="#scala.collection.immutable;Stream.dropRight.advance" title="(stub0: List[A], stub1: List[A], rest: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[A]">advance</a><span class="delimiter">(</span><span class="delimiter">(</span>this <a href="#scala.collection.immutable;Stream.take" title="(n: Int)scala.collection.immutable.Stream[A]">take</a> <a href="#scala.collection.immutable;Stream.dropRight.n" title="Int">n</a><span class="delimiter">)</span>.<a href="../TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[A]">toList</a>, <a href="List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, this <a href="#scala.collection.immutable;Stream.drop" title="(n: Int)scala.collection.immutable.Stream[A]">drop</a> <a href="#scala.collection.immutable;Stream.dropRight.n" title="Int">n</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Returns the longest prefix of this `Stream` whose elements satisfy the
   * predicate `p`.
   *
   * @param p the test predicate.
   * @return A new `Stream` representing the values that satisfy the predicate
   * `p`.
   *
   * @example {{{
   + naturalsFrom(0) takeWhile { _ &lt; 5 } mkString &quot;, &quot;
   * produces: &quot;0, 1, 2, 3, 4&quot;
   * }}}
   */</span>
  override def <a title="(p: A =&gt; Boolean)scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.takeWhile">takeWhile</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="scala.collection.immutable;Stream.takeWhile.p">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: A, tl: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.Cons[A]">cons</a><span class="delimiter">(</span><a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a> <a href="#scala.collection.immutable;Stream.takeWhile" title="(p: A =&gt; Boolean)scala.collection.immutable.Stream[A]">takeWhile</a> <a href="#scala.collection.immutable;Stream.takeWhile.p" title="A =&gt; Boolean">p</a><span class="delimiter">)</span>
    else <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.Empty.readResolve" title="scala.collection.immutable.Stream.Empty.type">Empty</a>

  <span class="comment">/** Returns the a `Stream` representing the longest suffix of this iterable
   * whose first element does not satisfy the predicate `p`.
   *
   * @note This method realizes the entire `Stream` beyond the truth value of
   * the predicate `p`.
   *
   * @param p the test predicate.
   * @return A new `Stream` representing the results of applying `p` to the
   * oringal `Stream`.
   *
   * @example {{{
   * // Assume we have a Stream that takes the first 20 natural numbers
   * def naturalsLt50(i: Int): Stream[Int] = i #:: { if (i &lt; 20) naturalsLt50(i * + 1) else Stream.Empty }
   * naturalsLt50(0) dropWhile { _ &lt; 10 }
   * // produces: &quot;10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20&quot;
   * }}}
   */</span>
  override def <a title="(p: A =&gt; Boolean)scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.dropWhile">dropWhile</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="scala.collection.immutable;Stream.dropWhile.p">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.dropWhile.these">these</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = this
    while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.dropWhile.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.dropWhile.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.dropWhile.these" title="scala.collection.immutable.Stream[A]">these</a> = <a href="#scala.collection.immutable;Stream.dropWhile.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
    <a href="#scala.collection.immutable;Stream.dropWhile.these" title="scala.collection.immutable.Stream[A]">these</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Builds a new stream from this stream in which any duplicates (as
   * determined by `==`) have been removed. Among duplicate elements, only the
   * first one is retained in the resulting `Stream`.
   *
   * @return A new `Stream` representing the result of applying distinctness to
   * the original `Stream`.
   * @example {{{
   * // Creates a Stream where every element is duplicated
   * def naturalsFrom(i: Int): Stream[Int] = i #:: { i #:: naturalsFrom(i + 1) }
   * naturalsFrom(1) take 6 mkString &quot;, &quot;
   * // produces: &quot;1, 1, 2, 2, 3, 3&quot;
   * (naturalsFrom(1) distinct) take 6 mkString &quot;, &quot;
   * // produces: &quot;1, 2, 3, 4, 5, 6&quot;
   * }}}
   */</span>
  override def <a title="=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.distinct">distinct</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="comment">// This should use max memory proportional to N, whereas</span>
    <span class="comment">// recursively calling distinct on the tail is N^2.</span>
    def <a title="(seen: scala.collection.immutable.Set[A], rest: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.distinct.loop">loop</a><span class="delimiter">(</span><a title="scala.collection.immutable.Set[A]" id="scala.collection.immutable;Stream.distinct.loop.seen">seen</a>: <a href="Set.scala.html#scala.collection.immutable;Set" title="scala.collection.immutable.Set[A]">Set</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.distinct.loop.rest">rest</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.distinct.loop.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.distinct.loop.rest" title="scala.collection.immutable.Stream[A]">rest</a>
      else if <span class="delimiter">(</span><a href="../GenSetLike.scala.html#scala.collection;GenSetLike.apply" title="(elem: A)Boolean">seen</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.distinct.loop.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.distinct.loop" title="(seen: scala.collection.immutable.Set[A], rest: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[A]">loop</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.distinct.loop.seen" title="scala.collection.immutable.Set[A]">seen</a>, <a href="#scala.collection.immutable;Stream.distinct.loop.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a><span class="delimiter">)</span>
      else <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: A, tl: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.Cons[A]">cons</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.distinct.loop.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="#scala.collection.immutable;Stream.distinct.loop" title="(seen: scala.collection.immutable.Set[A], rest: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[A]">loop</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.distinct.loop.seen" title="scala.collection.immutable.Set[A]">seen</a> <a href="../SetLike.scala.html#scala.collection;SetLike.+(daf7108c0f)" title="(elem: A)scala.collection.immutable.Set[A]">+</a> <a href="#scala.collection.immutable;Stream.distinct.loop.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="#scala.collection.immutable;Stream.distinct.loop.rest" title="scala.collection.immutable.Stream[A]">rest</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#scala.collection.immutable;Stream.distinct.loop" title="(seen: scala.collection.immutable.Set[A], rest: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[A]">loop</a><span class="delimiter">(</span><a href="../generic/GenericCompanion.scala.html#scala.collection.generic;GenericCompanion.apply" title="(elems: A*)scala.collection.immutable.Set[A]">Set</a><span class="delimiter">(</span><span class="delimiter">)</span>, this<span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Returns a new sequence of given length containing the elements of this
   * sequence followed by zero or more occurrences of given elements.
   *
   * @tparam B The type of the value to pad with.
   * @tparam That The type contained within the resulting `Stream`.
   * @param len The number of elements to pad into the `Stream`.
   * @param elem The value of the type `B` to use for padding.
   * @return A new `Stream` representing the collection with values padding off
   * to the end. If your `Stream` represents an infinite series, this method will
   * not return.
   * @example {{{
   * def naturalsFrom(i: Int): Stream[Int] = i #:: { if (i &lt; 5) naturalsFrom(i + 1) else Stream.Empty }
   * naturalsFrom(1) padTo(10, 0) foreach println
   * // prints
   * // 1
   * // 2
   * // 3
   * // 4
   * // 5
   * // 0
   * // 0
   * // 0
   * // 0
   * // 0
   * }}}
   */</span>
  override def <a title="[B &gt;: A, That](len: Int, elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That" id="scala.collection.immutable;Stream.padTo">padTo</a><span class="delimiter">[</span><a title=" &gt;: A" id="scala.collection.immutable;Stream.padTo;B">B</a> &gt;: A, <a title="" id="scala.collection.immutable;Stream.padTo;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable;Stream.padTo.len">len</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>, <a title="B" id="scala.collection.immutable;Stream.padTo.elem">elem</a>: <a href="#scala.collection.immutable;Stream.padTo;B" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]" id="scala.collection.immutable;Stream.padTo.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream.padTo;That" title="That">That</a> = <span class="delimiter">{</span>
    def <a title="(len: Int, these: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[B]" id="scala.collection.immutable;Stream.padTo.loop">loop</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable;Stream.padTo.loop.len">len</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>, <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.padTo.loop.these">these</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[B]">Stream</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.padTo.loop.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.fill(b6903c04dd)" title="(n: Int)(elem: =&gt; B)scala.collection.immutable.Stream[B]">fill</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.padTo.loop.len" title="Int">len</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.padTo.elem" title="B">elem</a><span class="delimiter">)</span>
      else <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: B, tl: =&gt; scala.collection.immutable.Stream[B])scala.collection.immutable.Stream.Cons[B]">cons</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.padTo.loop.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="#scala.collection.immutable;Stream.padTo.loop" title="(len: Int, these: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[B]">loop</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.padTo.loop.len" title="Int">len</a> <a href="../../Int.scala.html#scala;Int.-(1409840560)" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span>, <a href="#scala.collection.immutable;Stream.padTo.loop.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a><span class="delimiter">)</span><span class="delimiter">)</span>

    if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.isStreamBuilder" title="(bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])Boolean">isStreamBuilder</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.padTo.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.asThat" title="(x: AnyRef)Nothing">asThat</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.padTo.loop" title="(len: Int, these: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[B]">loop</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.padTo.len" title="Int">len</a>, this<span class="delimiter">)</span><span class="delimiter">)</span>
    else super.<a href="../SeqLike.scala.html#scala.collection;SeqLike.padTo" title="(len: Int, elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That">padTo</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.padTo.len" title="Int">len</a>, <a href="#scala.collection.immutable;Stream.padTo.elem" title="B">elem</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.padTo.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A list consisting of all elements of this list in reverse order.
   *
   * @note This function must realize the entire `Stream` in order to perform
   * this operation so if your `Stream` represents an infinite sequence then
   * this function will never return.
   *
   * @return A new `Stream` containing the representing of the original `Stream`
   * in reverse order.
   *
   * @example {{{
   * def naturalsFrom(i: Int): Stream[Int] = i #:: { if (i &lt; 5) naturalsFrom(i + 1) else Stream.Empty }
   * (naturalsFrom(1) reverse) foreach println
   * // prints
   * // 5
   * // 4
   * // 3
   * // 2
   * // 1
   * }}}
   */</span>
  override def <a title="=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.reverse">reverse</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.reverse.result">result</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.Empty.readResolve" title="scala.collection.immutable.Stream.Empty.type">Empty</a>
    var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.reverse.these">these</a> = this
    while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable;Stream.reverse.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.reverse.while$16" title="()Unit" class="delimiter">{</a>
      val <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.reverse.r">r</a> = <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.consWrapper" title="(stream: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.ConsWrapper[A]">consWrapper</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.reverse.result" title="scala.collection.immutable.Stream[A]">result</a><span class="delimiter">)</span>.<a href="#scala.collection.immutable.Stream;ConsWrapper.#::" title="(hd: A)scala.collection.immutable.Stream[A]">#::</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.reverse.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span>
      <a href="#scala.collection.immutable;Stream.reverse.r" title="scala.collection.immutable.Stream[A]">r</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a> <span class="comment">// force it!</span>
      <a href="#scala.collection.immutable;Stream.reverse.result" title="scala.collection.immutable.Stream[A]">result</a> = <a href="#scala.collection.immutable;Stream.reverse.r" title="scala.collection.immutable.Stream[A]">r</a>
      <a href="#scala.collection.immutable;Stream.reverse.these" title="scala.collection.immutable.Stream[A]">these</a> = <a href="#scala.collection.immutable;Stream.reverse.these" title="scala.collection.immutable.Stream[A]">these</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
    <span class="delimiter">}</span>
    <a href="#scala.collection.immutable;Stream.reverse.result" title="scala.collection.immutable.Stream[A]">result</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Evaluates and concatenates all elements within the `Stream` into a new
   * flattened `Stream`.
   *
   * @tparam B The type of the elements of the resulting `Stream`.
   * @return A new `Stream` of type `B` of the flattened elements of `this`
   * `Stream`.
   * @example {{{
   * val sov: Stream[Vector[Int]] = Vector(0) #:: Vector(0, 0) #:: sov.zip(sov.tail).map { n =&gt; n._1 ++ n._2 }
   * sov.flatten take 10 mkString &quot;, &quot;
   * // produces: &quot;0, 0, 0, 0, 0, 0, 0, 0, 0, 0&quot;
   * }}}
   */</span>
  override def <a title="[B](implicit asTraversable: A =&gt; scala.collection.GenTraversableOnce[B])scala.collection.immutable.Stream[B]" id="scala.collection.immutable;Stream.flatten">flatten</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable;Stream.flatten;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="A =&gt; scala.collection.GenTraversableOnce[B]" id="scala.collection.immutable;Stream.flatten.asTraversable">asTraversable</a>: A =&gt; <span class="comment">/*&lt;:&lt;!!!*/</span> GenTraversableOnce<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[B]">Stream</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <span class="delimiter">{</span>
    var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.flatten.st">st</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = this
    while <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.flatten.st" title="scala.collection.immutable.Stream[A]">st</a>.<a href="../TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.flatten.while$17" title="()Unit" class="delimiter">{</a>
      val <a title="scala.collection.GenTraversableOnce[B]" id="scala.collection.immutable;Stream.flatten.h">h</a> = <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)scala.collection.GenTraversableOnce[B]">asTraversable</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.flatten.st" title="scala.collection.immutable.Stream[A]">st</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.flatten.h" title="scala.collection.GenTraversableOnce[B]">h</a>.<a href="../GenTraversableOnce.scala.html#scala.collection;GenTraversableOnce.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.collection.immutable;Stream.flatten.st" title="scala.collection.immutable.Stream[A]">st</a> = <a href="#scala.collection.immutable;Stream.flatten.st" title="scala.collection.immutable.Stream[A]">st</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        return <a href="#scala.collection.immutable;Stream.flatten.h" title="scala.collection.GenTraversableOnce[B]">h</a>.<a href="../GenTraversableOnce.scala.html#scala.collection;GenTraversableOnce.toStream" title="=&gt; Stream[B]">toStream</a> <a href="#scala.collection.immutable.Stream;ConsWrapper.#:::" title="(prefix: scala.collection.immutable.Stream[B])scala.collection.immutable.Stream[B]">#:::</a> <a href="#scala.collection.immutable;Stream.flatten.st" title="scala.collection.immutable.Stream[A]">st</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>.<a href="#scala.collection.immutable.Stream.consWrapper" title="(stream: =&gt; scala.collection.immutable.Stream[B])scala.collection.immutable.Stream.ConsWrapper[B]">flatten</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.empty" title="scala.collection.immutable.Stream[Nothing]">empty</a>
  <span class="delimiter">}</span>

  override def <a title="=&gt; scala.collection.immutable.StreamView[A,scala.collection.immutable.Stream[A]]" id="scala.collection.immutable;Stream.view(ead061e64d)">view</a> = new <a title="&lt;$anon: Int =&gt; A&gt; extends AnyRef with scala.collection.immutable.StreamView[A,scala.collection.immutable.Stream[A]]" id="scala.collection.immutable;Stream.view(ead061e64d);$anon">StreamView</a><span class="delimiter">[</span>A, Stream<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    protected lazy val <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;Stream.view(ead061e64d);$anon.underlying">underlying</a> = <a href="#scala.collection.immutable;Stream" title="Stream.this.type">self</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.repr" title="=&gt; scala.collection.immutable.Stream[A]">repr</a>
    override def <a title="=&gt; Iterator[A]" id="scala.collection.immutable;Stream.view(ead061e64d);$anon.iterator">iterator</a> = <a href="#scala.collection.immutable;Stream" title="Stream.this.type">self</a>.<a href="#scala.collection.immutable;Stream.iterator" title="=&gt; Iterator[A]">iterator</a>
    override def <a title="=&gt; Int" id="scala.collection.immutable;Stream.view(ead061e64d);$anon.length">length</a> = <a href="#scala.collection.immutable;Stream" title="Stream.this.type">self</a>.<a href="#scala.collection.immutable;Stream.length" title="=&gt; Int">length</a>
    override def <a title="(idx: Int)A" id="scala.collection.immutable;Stream.view(ead061e64d);$anon.apply">apply</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable;Stream.view(ead061e64d);$anon.apply.idx">idx</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span> = <a href="#scala.collection.immutable;Stream" title="Stream.this.type">self</a>.<a href="../LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.apply" title="(n: Int)A">apply</a><span class="delimiter">(</span><a href="#scala.collection.immutable;Stream.view(ead061e64d);$anon.apply.idx" title="Int">idx</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Defines the prefix of this object's `toString` representation as `Stream`.
   */</span>
  override def <a title="=&gt; String" id="scala.collection.immutable;Stream.stringPrefix">stringPrefix</a> = <span title="String(&quot;Stream&quot;)" class="string">&quot;Stream&quot;</span>

<span class="delimiter">}</span>

<span class="comment">/** A specialized, extra-lazy implementation of a stream iterator, so it can
 *  iterate as lazily as it traverses the tail.
 */</span>
final class <a title="class StreamIterator[+A] extends scala.collection.AbstractIterator[A] with Iterator[A]" id="scala.collection.immutable;StreamIterator">StreamIterator</a><span class="delimiter">[</span>+<a title="" id="scala.collection.immutable;StreamIterator;A">A</a><span class="delimiter">]</span> private<span class="delimiter">(</span><span class="delimiter">)</span> extends <a href="../Iterator.scala.html#scala.collection;AbstractIterator" title="scala.collection.AbstractIterator[A]">AbstractIterator</a><span class="delimiter">[</span>A<span class="delimiter">]</span> with <a href="../Iterator.scala.html#scala.collection;Iterator" title="Iterator[A]">Iterator</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
  def this<span class="delimiter">(</span><a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;StreamIterator.<init>(ebd91abfeb).self">self</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span>
    this<span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#scala.collection.immutable;StreamIterator.these_=" title="(x$1: StreamIterator.this.LazyCell)Unit">these</a> = new <a href="#scala.collection.immutable;StreamIterator;LazyCell" title="StreamIterator.this.LazyCell">LazyCell</a><span class="delimiter">(</span><a href="#scala.collection.immutable;StreamIterator.<init>(ebd91abfeb).self" title="scala.collection.immutable.Stream[A]">self</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// A call-by-need cell.</span>
  class <a title="class LazyCell extends AnyRef" id="scala.collection.immutable;StreamIterator;LazyCell">LazyCell</a><a href="#scala.collection.immutable;StreamIterator;LazyCell" title="StreamIterator.this.LazyCell" class="delimiter">(</a><a title="=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable;StreamIterator;LazyCell.st">st</a>: =&gt; Stream<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    lazy val <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;StreamIterator;LazyCell.v">v</a> = <a href="#scala.collection.immutable;StreamIterator;LazyCell.st" title="=&gt; scala.collection.immutable.Stream[A]">st</a>
  <span class="delimiter">}</span>

  private var <a title="StreamIterator.this.LazyCell" id="scala.collection.immutable;StreamIterator.these_=">these</a>: <a href="#scala.collection.immutable;StreamIterator;LazyCell" title="StreamIterator.this.LazyCell">LazyCell</a> = _

  def <a title="=&gt; Boolean" id="scala.collection.immutable;StreamIterator.hasNext">hasNext</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.collection.immutable;StreamIterator.these_=" title="=&gt; StreamIterator.this.LazyCell">these</a>.<a href="#scala.collection.immutable;StreamIterator;LazyCell.v" title="=&gt; scala.collection.immutable.Stream[A]">v</a>.<a href="../TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a>
  def <a title="()A" id="scala.collection.immutable;StreamIterator.next">next</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;StreamIterator;A" title="A">A</a> =
    if <span class="delimiter">(</span><a href="../Iterator.scala.html#scala.collection;Iterator.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../Iterator.scala.html#scala.collection.Iterator" title="scala.collection.Iterator.type">Iterator</a>.<a href="../Iterator.scala.html#scala.collection.Iterator.empty" title="=&gt; Iterator[Nothing]">empty</a>.<a href="../Iterator.scala.html#scala.collection;Iterator.next" title="()Nothing">next</a><span class="delimiter">(</span><span class="delimiter">)</span>
    else <span class="delimiter">{</span>
      val <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;StreamIterator.next.cur">cur</a>    = <a href="#scala.collection.immutable;StreamIterator.these_=" title="=&gt; StreamIterator.this.LazyCell">these</a>.<a href="#scala.collection.immutable;StreamIterator;LazyCell.v" title="=&gt; scala.collection.immutable.Stream[A]">v</a>
      val <a title="A" id="scala.collection.immutable;StreamIterator.next.result">result</a> = <a href="#scala.collection.immutable;StreamIterator.next.cur" title="scala.collection.immutable.Stream[A]">cur</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>
      <a href="#scala.collection.immutable;StreamIterator.these_=" title="(x$1: StreamIterator.this.LazyCell)Unit">these</a> = new <a href="#scala.collection.immutable;StreamIterator;LazyCell" title="StreamIterator.this.LazyCell">LazyCell</a><span class="delimiter">(</span><a href="#scala.collection.immutable;StreamIterator.next.cur" title="scala.collection.immutable.Stream[A]">cur</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a><span class="delimiter">)</span>
      <a href="#scala.collection.immutable;StreamIterator.next.result" title="A">result</a>
    <span class="delimiter">}</span>
  override def <a title="=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable;StreamIterator.toStream">toStream</a> = <span class="delimiter">{</span>
    val <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable;StreamIterator.toStream.result">result</a> = <a href="#scala.collection.immutable;StreamIterator.these_=" title="=&gt; StreamIterator.this.LazyCell">these</a>.<a href="#scala.collection.immutable;StreamIterator;LazyCell.v" title="=&gt; scala.collection.immutable.Stream[A]">v</a>
    <a href="#scala.collection.immutable;StreamIterator.these_=" title="(x$1: StreamIterator.this.LazyCell)Unit">these</a> = new <a href="#scala.collection.immutable;StreamIterator;LazyCell" title="StreamIterator.this.LazyCell">LazyCell</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.readResolve" title="scala.collection.immutable.Stream.type">Stream</a>.<a href="#scala.collection.immutable.Stream.empty" title="scala.collection.immutable.Stream[Nothing]">empty</a><span class="delimiter">)</span>
    <a href="#scala.collection.immutable;StreamIterator.toStream.result" title="scala.collection.immutable.Stream[A]">result</a>
  <span class="delimiter">}</span>
  override def <a title="=&gt; List[A]" id="scala.collection.immutable;StreamIterator.toList">toList</a>   = <a href="#scala.collection.immutable;StreamIterator.toStream" title="=&gt; scala.collection.immutable.Stream[A]">toStream</a>.<a href="../TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[A]">toList</a>
<span class="delimiter">}</span>

<span class="comment">/**
 * The object `Stream` provides helper functions to manipulate streams.
 *
 * @author Martin Odersky, Matthias Zenger
 * @version 1.1 08/08/03
 * @since   2.8
 */</span>
object <a title="scala.collection.immutable.Stream.type" id="scala.collection.immutable.Stream.readResolve">Stream</a> extends <a href="../generic/SeqFactory.scala.html#scala.collection.generic;SeqFactory" title="scala.collection.generic.SeqFactory[scala.collection.immutable.Stream]">SeqFactory</a><span class="delimiter">[</span>Stream<span class="delimiter">]</span> <span class="delimiter">{</span>

  <span class="comment">/** The factory for streams.
   *  @note Methods such as map/flatMap will not invoke the `Builder` factory,
   *        but will return a new stream directly, to preserve laziness.
   *        The new stream is then cast to the factory's result type.
   *        This means that every CanBuildFrom that takes a
   *        Stream as its From type parameter must yield a stream as its result parameter.
   *        If that assumption is broken, cast errors might result.
   */</span>
  class <a title="class StreamCanBuildFrom[A] extends scala.collection.immutable.Stream.GenericCanBuildFrom[A]" id="scala.collection.immutable.Stream;StreamCanBuildFrom">StreamCanBuildFrom</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream;StreamCanBuildFrom;A">A</a><span class="delimiter">]</span> extends <a href="../generic/GenTraversableFactory.scala.html#scala.collection.generic;GenTraversableFactory;GenericCanBuildFrom" title="scala.collection.immutable.Stream.GenericCanBuildFrom[A]">GenericCanBuildFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  implicit def <a title="[A]=&gt; scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream.Coll,A,scala.collection.immutable.Stream[A]]" id="scala.collection.immutable.Stream.canBuildFrom">canBuildFrom</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.canBuildFrom;A">A</a><span class="delimiter">]</span>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream.Coll,A,scala.collection.immutable.Stream[A]]">CanBuildFrom</a><span class="delimiter">[</span>Coll, A, Stream<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = new <a href="#scala.collection.immutable.Stream;StreamCanBuildFrom" title="scala.collection.immutable.Stream.StreamCanBuildFrom[A]">StreamCanBuildFrom</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  <span class="comment">/** Creates a new builder for a stream */</span>
  def <a title="[A]=&gt; scala.collection.mutable.Builder[A,scala.collection.immutable.Stream[A]]" id="scala.collection.immutable.Stream.newBuilder">newBuilder</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.newBuilder;A">A</a><span class="delimiter">]</span>: <a href="../mutable/Builder.scala.html#scala.collection.mutable;Builder" title="scala.collection.mutable.Builder[A,scala.collection.immutable.Stream[A]]">Builder</a><span class="delimiter">[</span>A, Stream<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = new <a href="#scala.collection.immutable.Stream;StreamBuilder" title="scala.collection.immutable.Stream.StreamBuilder[A]">StreamBuilder</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  import scala.collection.<span class="delimiter">{</span>Iterable, Seq, IndexedSeq<span class="delimiter">}</span>

  <span class="comment">/** A builder for streams
   *  @note This builder is lazy only in the sense that it does not go downs the spine
   *        of traversables that are added as a whole. If more laziness can be achieved,
   *        this builder should be bypassed.
   */</span>
  class <a title="class StreamBuilder[A] extends scala.collection.mutable.LazyBuilder[A,scala.collection.immutable.Stream[A]]" id="scala.collection.immutable.Stream;StreamBuilder">StreamBuilder</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream;StreamBuilder;A">A</a><span class="delimiter">]</span> extends scala.collection.mutable.<a href="../mutable/LazyBuilder.scala.html#scala.collection.mutable;LazyBuilder" title="scala.collection.mutable.LazyBuilder[A,scala.collection.immutable.Stream[A]]">LazyBuilder</a><span class="delimiter">[</span>A, Stream<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="()scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream;StreamBuilder.result">result</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="../mutable/LazyBuilder.scala.html#scala.collection.mutable;LazyBuilder.parts" title="=&gt; scala.collection.mutable.ListBuffer[scala.collection.TraversableOnce[A]]">parts</a>.<a href="../generic/TraversableForwarder.scala.html#scala.collection.generic;TraversableForwarder.toStream" title="=&gt; scala.collection.immutable.Stream[scala.collection.TraversableOnce[A]]">toStream</a> <a href="#scala.collection.immutable;Stream.flatMap" title="(f: scala.collection.TraversableOnce[A] =&gt; scala.collection.GenTraversableOnce[A])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[scala.collection.TraversableOnce[A]],A,scala.collection.immutable.Stream[A]])scala.collection.immutable.Stream[A]">flatMap</a> <span class="delimiter">(</span><a href="#scala.collection.immutable.Stream;StreamBuilder.result.$anonfun.x$5" title="scala.collection.TraversableOnce[A]">_</a>.<a href="../GenTraversableOnce.scala.html#scala.collection;GenTraversableOnce.toStream" title="=&gt; Stream[A]">toStream</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  object <a title="scala.collection.immutable.Stream.Empty.type" id="scala.collection.immutable.Stream.Empty.readResolve">Empty</a> extends <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[Nothing]">Stream</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> <span class="delimiter">{</span>
    override def <a title="=&gt; Boolean" id="scala.collection.immutable.Stream.Empty.isEmpty">isEmpty</a> = true
    override def <a title="=&gt; Nothing" id="scala.collection.immutable.Stream.Empty.head">head</a> = throw new <a href="../../package.scala.html#scala.package;NoSuchElementException" title="java.util.NoSuchElementException">NoSuchElementException</a><span class="delimiter">(</span><span title="String(&quot;head of empty stream&quot;)" class="string">&quot;head of empty stream&quot;</span><span class="delimiter">)</span>
    override def <a title="=&gt; Nothing" id="scala.collection.immutable.Stream.Empty.tail">tail</a> = throw new <a href="../../package.scala.html#scala.package;UnsupportedOperationException" title="UnsupportedOperationException">UnsupportedOperationException</a><span class="delimiter">(</span><span title="String(&quot;tail of empty stream&quot;)" class="string">&quot;tail of empty stream&quot;</span><span class="delimiter">)</span>
    def <a title="=&gt; Boolean" id="scala.collection.immutable.Stream.Empty.tailDefined">tailDefined</a> = false
  <span class="delimiter">}</span>

  <span class="comment">/** The empty stream */</span>
  override def <a title="[A]=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream.empty">empty</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.empty;A">A</a><span class="delimiter">]</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scala.collection.immutable.Stream.Empty.readResolve" title="scala.collection.immutable.Stream.Empty.type">Empty</a>

  <span class="comment">/** A stream consisting of given elements */</span>
  override def <a title="[A](xs: A*)scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream.apply">apply</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.apply;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A*" id="scala.collection.immutable.Stream.apply.xs">xs</a>: <span title="A*">A</span>*<span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scala.collection.immutable.Stream.apply.xs" title="A*">xs</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.toStream" title="=&gt; scala.collection.immutable.Stream[A]">toStream</a>

  <span class="comment">/** A wrapper class that adds `#::` for cons and `#:::` for concat as operations
   *  to streams.
   */</span>
  class <a title="class ConsWrapper[A] extends AnyRef" id="scala.collection.immutable.Stream;ConsWrapper">ConsWrapper</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream;ConsWrapper;A">A</a><span class="delimiter">]</span><a href="#scala.collection.immutable.Stream;ConsWrapper" title="scala.collection.immutable.Stream.ConsWrapper[A]" class="delimiter">(</a><a title="=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream;ConsWrapper.tl">tl</a>: =&gt; Stream<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="(hd: A)scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream;ConsWrapper.#::">#::</a><span class="delimiter">(</span><a title="A" id="scala.collection.immutable.Stream;ConsWrapper.#::.hd">hd</a>: <a href="#scala.collection.immutable.Stream;ConsWrapper;A" title="A">A</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: A, tl: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.Cons[A]">cons</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream;ConsWrapper.#::.hd" title="A">hd</a>, <a href="#scala.collection.immutable.Stream;ConsWrapper.tl" title="=&gt; scala.collection.immutable.Stream[A]">tl</a><span class="delimiter">)</span>
    def <a title="(prefix: scala.collection.immutable.Stream[A])scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream;ConsWrapper.#:::">#:::</a><span class="delimiter">(</span><a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream;ConsWrapper.#:::.prefix">prefix</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scala.collection.immutable.Stream;ConsWrapper.#:::.prefix" title="scala.collection.immutable.Stream[A]">prefix</a> <a href="#scala.collection.immutable;Stream.append" title="(rest: =&gt; scala.collection.TraversableOnce[A])scala.collection.immutable.Stream[A]">append</a> <a href="#scala.collection.immutable.Stream;ConsWrapper.tl" title="=&gt; scala.collection.immutable.Stream[A]">tl</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A wrapper method that adds `#::` for cons and `#::: for concat as operations
   *  to streams.
   */</span>
  implicit def <a title="[A](stream: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.ConsWrapper[A]" id="scala.collection.immutable.Stream.consWrapper">consWrapper</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.consWrapper;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream.consWrapper.stream">stream</a>: =&gt; Stream<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.collection.immutable.Stream;ConsWrapper" title="scala.collection.immutable.Stream.ConsWrapper[A]">ConsWrapper</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    new <a href="#scala.collection.immutable.Stream;ConsWrapper" title="scala.collection.immutable.Stream.ConsWrapper[A]">ConsWrapper</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.consWrapper.stream" title="=&gt; scala.collection.immutable.Stream[A]">stream</a><span class="delimiter">)</span>

  <span class="comment">/** An extractor that allows to pattern match streams with `#::`.
   */</span>
  object <a title="scala.collection.immutable.Stream.#::.type" id="scala.collection.immutable.Stream.#::">#::</a> <a href="#scala.collection.immutable.Stream.#::" title="scala.collection.immutable.Stream.#::.type" class="delimiter">{</a>
    def <a title="[A](xs: scala.collection.immutable.Stream[A])Option[(A, scala.collection.immutable.Stream[A])]" id="scala.collection.immutable.Stream.#::.unapply">unapply</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.#::.unapply;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream.#::.unapply.xs">xs</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(A, scala.collection.immutable.Stream[A])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>A, Stream<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.#::.unapply.xs" title="scala.collection.immutable.Stream[A]">xs</a>.<a href="../SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
      else <a href="../../Option.scala.html#scala;Some" title="(x: (A, scala.collection.immutable.Stream[A]))Some[(A, scala.collection.immutable.Stream[A])]">Some</a><span class="delimiter">(</span><a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: A, _2: scala.collection.immutable.Stream[A])(A, scala.collection.immutable.Stream[A])" class="delimiter">(</a><a href="#scala.collection.immutable.Stream.#::.unapply.xs" title="scala.collection.immutable.Stream[A]">xs</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="#scala.collection.immutable.Stream.#::.unapply.xs" title="scala.collection.immutable.Stream[A]">xs</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An alternative way of building and matching Streams using Stream.cons(hd, tl).
   */</span>
  object <a title="scala.collection.immutable.Stream.cons.type" id="scala.collection.immutable.Stream.cons">cons</a> <a href="#scala.collection.immutable.Stream.cons" title="scala.collection.immutable.Stream.cons.type" class="delimiter">{</a>

    <span class="comment">/** A stream consisting of a given first element and remaining elements
     *  @param hd   The first element of the result stream
     *  @param tl   The remaining elements of the result stream
     */</span>
    def <a title="[A](hd: A, tl: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.Cons[A]" id="scala.collection.immutable.Stream.cons.apply">apply</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.cons.apply;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="scala.collection.immutable.Stream.cons.apply.hd">hd</a>: <a href="#scala.collection.immutable.Stream.cons.apply;A" title="A">A</a>, <a title="=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream.cons.apply.tl">tl</a>: =&gt; Stream<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = new <a href="#scala.collection.immutable.Stream;Cons" title="scala.collection.immutable.Stream.Cons[A]">Cons</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.cons.apply.hd" title="A">hd</a>, <a href="#scala.collection.immutable.Stream.cons.apply.tl" title="=&gt; scala.collection.immutable.Stream[A]">tl</a><span class="delimiter">)</span>

    <span class="comment">/** Maps a stream to its head and tail */</span>
    def <a title="[A](xs: scala.collection.immutable.Stream[A])Option[(A, scala.collection.immutable.Stream[A])]" id="scala.collection.immutable.Stream.cons.unapply">unapply</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.cons.unapply;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream.cons.unapply.xs">xs</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(A, scala.collection.immutable.Stream[A])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>A, Stream<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#scala.collection.immutable.Stream.#::" title="scala.collection.immutable.Stream.#::.type">#::</a>.<a href="#scala.collection.immutable.Stream.#::.unapply" title="(xs: scala.collection.immutable.Stream[A])Option[(A, scala.collection.immutable.Stream[A])]">unapply</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.cons.unapply.xs" title="scala.collection.immutable.Stream[A]">xs</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A lazy cons cell, from which streams are built. */</span>
  @SerialVersionUID<span class="delimiter">(</span>-<span class="long">602202424901551803L</span><span class="delimiter">)</span>
  final class <a title="class Cons[+A] extends scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream;Cons">Cons</a><span class="delimiter">[</span>+<a title="" id="scala.collection.immutable.Stream;Cons;A">A</a><span class="delimiter">]</span><a href="#scala.collection.immutable.Stream;Cons" title="scala.collection.immutable.Stream.Cons[A]" class="delimiter">(</a><a title="A" id="scala.collection.immutable.Stream;Cons.hd">hd</a>: <a href="#scala.collection.immutable.Stream;Cons;A" title="A">A</a>, <a title="=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream;Cons.tl">tl</a>: =&gt; Stream<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> <span class="delimiter">{</span>
    override def <a title="=&gt; Boolean" id="scala.collection.immutable.Stream;Cons.isEmpty">isEmpty</a> = false
    override def <a title="=&gt; A" id="scala.collection.immutable.Stream;Cons.head">head</a> = <a href="#scala.collection.immutable.Stream;Cons.hd" title="A">hd</a>
    @volatile private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream;Cons.tlVal">tlVal</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = _
    @volatile private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="() =&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream;Cons.tlGen">tlGen</a> = <a href="#scala.collection.immutable.Stream;Cons.tl" title="=&gt; scala.collection.immutable.Stream[A]">tl</a> _
    def <a title="=&gt; Boolean" id="scala.collection.immutable.Stream;Cons.tailDefined">tailDefined</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.collection.immutable.Stream;Cons.tlGen" title="() =&gt; scala.collection.immutable.Stream[A]">tlGen</a> <span title="(x$1: AnyRef)Boolean">eq</span> null
    override def <a title="=&gt; scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream;Cons.tail">tail</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable.Stream;Cons.tailDefined" title="=&gt; Boolean">tailDefined</a><span class="delimiter">)</span>
        <a href="#scala.collection.immutable.Stream;Cons" title="(x$1: Unit)Unit">synchronized</a> <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.collection.immutable.Stream;Cons.tailDefined" title="=&gt; Boolean">tailDefined</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="#scala.collection.immutable.Stream;Cons.tlVal" title="scala.collection.immutable.Stream[A]">tlVal</a> = <a href="../../Function0.scala.html#scala;Function0.apply" title="()scala.collection.immutable.Stream[A]">tlGen</a><span class="delimiter">(</span><span class="delimiter">)</span>
            <a href="#scala.collection.immutable.Stream;Cons.tlGen" title="() =&gt; scala.collection.immutable.Stream[A]">tlGen</a> = null
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>

      <a href="#scala.collection.immutable.Stream;Cons.tlVal" title="scala.collection.immutable.Stream[A]">tlVal</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An infinite stream that repeatedly applies a given function to a start value.
   *
   *  @param start the start value of the stream
   *  @param f     the function that's repeatedly applied
   *  @return      the stream returning the infinite sequence of values `start, f(start), f(f(start)), ...`
   */</span>
  def <a title="[A](start: A)(f: A =&gt; A)scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream.iterate(ea351861e8)">iterate</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.iterate(ea351861e8);A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="scala.collection.immutable.Stream.iterate(ea351861e8).start">start</a>: <a href="#scala.collection.immutable.Stream.iterate(ea351861e8);A" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; A" id="scala.collection.immutable.Stream.iterate(ea351861e8).f">f</a>: A =&gt; A<span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: A, tl: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.Cons[A]">cons</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.iterate(ea351861e8).start" title="A">start</a>, <a href="#scala.collection.immutable.Stream.iterate(ea351861e8)" title="(start: A)(f: A =&gt; A)scala.collection.immutable.Stream[A]">iterate</a><span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: A)A">f</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.iterate(ea351861e8).start" title="A">start</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.iterate(ea351861e8).f" title="A =&gt; A">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  override def <a title="[A](start: A, len: Int)(f: A =&gt; A)scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream.iterate(f787791541)">iterate</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.iterate(f787791541);A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="scala.collection.immutable.Stream.iterate(f787791541).start">start</a>: <a href="#scala.collection.immutable.Stream.iterate(f787791541);A" title="A">A</a>, <a title="Int" id="scala.collection.immutable.Stream.iterate(f787791541).len">len</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; A" id="scala.collection.immutable.Stream.iterate(f787791541).f">f</a>: A =&gt; A<span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#scala.collection.immutable.Stream.iterate(ea351861e8)" title="(start: A)(f: A =&gt; A)scala.collection.immutable.Stream[A]">iterate</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.iterate(f787791541).start" title="A">start</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.iterate(f787791541).f" title="A =&gt; A">f</a><span class="delimiter">)</span> <a href="#scala.collection.immutable;Stream.take" title="(n: Int)scala.collection.immutable.Stream[A]">take</a> <a href="#scala.collection.immutable.Stream.iterate(f787791541).len" title="Int">len</a>

  <span class="comment">/**
   * Create an infinite stream starting at `start` and incrementing by
   * step `step`.
   *
   * @param start the start value of the stream
   * @param step the increment value of the stream
   * @return the stream starting at value `start`.
   */</span>
  def <a title="(start: Int, step: Int)scala.collection.immutable.Stream[Int]" id="scala.collection.immutable.Stream.from(3e397969ee)">from</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable.Stream.from(3e397969ee).start">start</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>, <a title="Int" id="scala.collection.immutable.Stream.from(3e397969ee).step">step</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[Int]">Stream</a><span class="delimiter">[</span>Int<span class="delimiter">]</span> =
    <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: Int, tl: =&gt; scala.collection.immutable.Stream[Int])scala.collection.immutable.Stream.Cons[Int]">cons</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.from(3e397969ee).start" title="Int">start</a>, <a href="#scala.collection.immutable.Stream.from(3e397969ee)" title="(start: Int, step: Int)scala.collection.immutable.Stream[Int]">from</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.from(3e397969ee).start" title="Int">start</a><a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+</a><a href="#scala.collection.immutable.Stream.from(3e397969ee).step" title="Int">step</a>, <a href="#scala.collection.immutable.Stream.from(3e397969ee).step" title="Int">step</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Create an infinite stream starting at `start` and incrementing by `1`.
   *
   * @param start the start value of the stream
   * @return the stream starting at value `start`.
   */</span>
  def <a title="(start: Int)scala.collection.immutable.Stream[Int]" id="scala.collection.immutable.Stream.from(c7b665afb0)">from</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable.Stream.from(c7b665afb0).start">start</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[Int]">Stream</a><span class="delimiter">[</span>Int<span class="delimiter">]</span> = <a href="#scala.collection.immutable.Stream.from(3e397969ee)" title="(start: Int, step: Int)scala.collection.immutable.Stream[Int]">from</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.from(c7b665afb0).start" title="Int">start</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Create an infinite stream containing the given element expression (which
   * is computed for each occurrence).
   *
   * @param elem the element composing the resulting stream
   * @return the stream containing an infinite number of elem
   */</span>
  def <a title="[A](elem: =&gt; A)scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream.continually">continually</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.continually;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="scala.collection.immutable.Stream.continually.elem">elem</a>: =&gt; A<span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: A, tl: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.Cons[A]">cons</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.continually.elem" title="=&gt; A">elem</a>, <a href="#scala.collection.immutable.Stream.continually" title="(elem: =&gt; A)scala.collection.immutable.Stream[A]">continually</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.continually.elem" title="=&gt; A">elem</a><span class="delimiter">)</span><span class="delimiter">)</span>

  override def <a title="[A](n: Int)(elem: =&gt; A)scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream.fill(b6903c04dd)">fill</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.fill(b6903c04dd);A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable.Stream.fill(b6903c04dd).n">n</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; A" id="scala.collection.immutable.Stream.fill(b6903c04dd).elem">elem</a>: =&gt; A<span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.fill(b6903c04dd).n" title="Int">n</a> <a href="../../Int.scala.html#scala;Int.<=(5f58a84eb3)" title="(x: Int)Boolean">&lt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.Empty.readResolve" title="scala.collection.immutable.Stream.Empty.type">Empty</a> else <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: A, tl: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.Cons[A]">cons</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.fill(b6903c04dd).elem" title="=&gt; A">elem</a>, <a href="#scala.collection.immutable.Stream.fill(b6903c04dd)" title="(n: Int)(elem: =&gt; A)scala.collection.immutable.Stream[A]">fill</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.fill(b6903c04dd).n" title="Int">n</a><a href="../../Int.scala.html#scala;Int.-(1409840560)" title="(x: Int)Int">-</a><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.fill(b6903c04dd).elem" title="=&gt; A">elem</a><span class="delimiter">)</span><span class="delimiter">)</span>

  override def <a title="[A](n: Int)(f: Int =&gt; A)scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream.tabulate(70864d9074)">tabulate</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.tabulate(70864d9074);A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable.Stream.tabulate(70864d9074).n">n</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Int =&gt; A" id="scala.collection.immutable.Stream.tabulate(70864d9074).f">f</a>: Int =&gt; A<span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(i: Int)scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream.tabulate(70864d9074).loop">loop</a><span class="delimiter">(</span><a title="Int" id="scala.collection.immutable.Stream.tabulate(70864d9074).loop.i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.tabulate(70864d9074).loop.i" title="Int">i</a> <a href="../../Int.scala.html#scala;Int.>=(5f58a84eb3)" title="(x: Int)Boolean">&gt;=</a> <a href="#scala.collection.immutable.Stream.tabulate(70864d9074).n" title="Int">n</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.Empty.readResolve" title="scala.collection.immutable.Stream.Empty.type">Empty</a> else <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: A, tl: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.Cons[A]">cons</a><span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Int)A">f</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.tabulate(70864d9074).loop.i" title="Int">i</a><span class="delimiter">)</span>, <a href="#scala.collection.immutable.Stream.tabulate(70864d9074).loop" title="(i: Int)scala.collection.immutable.Stream[A]">loop</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.tabulate(70864d9074).loop.i" title="Int">i</a><a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+</a><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#scala.collection.immutable.Stream.tabulate(70864d9074).loop" title="(i: Int)scala.collection.immutable.Stream[A]">loop</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  override def <a title="[T](start: T, end: T, step: T)(implicit evidence$1: Integral[T])scala.collection.immutable.Stream[T]" id="scala.collection.immutable.Stream.range(cca71ea0b7)">range</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.range(cca71ea0b7);T">T</a>: Integral<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="scala.collection.immutable.Stream.range(cca71ea0b7).start">start</a>: <a href="#scala.collection.immutable.Stream.range(cca71ea0b7);T" title="T">T</a>, <a title="T" id="scala.collection.immutable.Stream.range(cca71ea0b7).end">end</a>: <a href="#scala.collection.immutable.Stream.range(cca71ea0b7);T" title="T">T</a>, <a title="T" id="scala.collection.immutable.Stream.range(cca71ea0b7).step">step</a>: <a href="#scala.collection.immutable.Stream.range(cca71ea0b7);T" title="T">T</a><span class="delimiter">)</span>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[T]">Stream</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Integral[T]" id="scala.collection.immutable.Stream.range(cca71ea0b7).num">num</a> = <a href="../../Predef.scala.html#scala.Predef.implicitly" title="[T](implicit e: T)T">implicitly</a><a href="#scala.collection.immutable.Stream.range(cca71ea0b7).evidence$1" title="(implicit e: Integral[T])Integral[T]" class="delimiter">[</a><a href="../../math/Integral.scala.html#scala.math;Integral" title="Integral[T]">Integral</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
    import <a href="#scala.collection.immutable.Stream.range(cca71ea0b7).num" title="Integral[T]">num</a>._

    if <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="../../math/Ordering.scala.html#scala.math;Ordering.mkOrderingOps" title="implicit scala.math.Ordering.mkOrderingOps : (lhs: T)num.Ops">step</a> <a href="../../math/Ordering.scala.html#scala.math;Ordering;Ops.<" title="(rhs: T)Boolean">&lt;</a> <a href="../../math/Numeric.scala.html#scala.math;Numeric.zero" title="=&gt; T">zero</a><span class="delimiter">)</span> <a href="../../math/Ordering.scala.html#scala.math;Ordering.mkOrderingOps" title="implicit scala.math.Ordering.mkOrderingOps : (lhs: T)num.Ops">start</a> <a href="../../math/Ordering.scala.html#scala.math;Ordering;Ops.<=" title="(rhs: T)Boolean">&lt;=</a> <a href="#scala.collection.immutable.Stream.range(cca71ea0b7).end" title="T">end</a> else <a href="../../math/Ordering.scala.html#scala.math;Ordering.mkOrderingOps" title="implicit scala.math.Ordering.mkOrderingOps : (lhs: T)num.Ops">end</a> <a href="../../math/Ordering.scala.html#scala.math;Ordering;Ops.<=" title="(rhs: T)Boolean">&lt;=</a> <a href="#scala.collection.immutable.Stream.range(cca71ea0b7).start" title="T">start</a><span class="delimiter">)</span> <a href="#scala.collection.immutable.Stream.Empty.readResolve" title="scala.collection.immutable.Stream.Empty.type">Empty</a>
    else <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: T, tl: =&gt; scala.collection.immutable.Stream[T])scala.collection.immutable.Stream.Cons[T]">cons</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.range(cca71ea0b7).start" title="T">start</a>, <a href="#scala.collection.immutable.Stream.range(cca71ea0b7)" title="(start: T, end: T, step: T)(implicit evidence$1: Integral[T])scala.collection.immutable.Stream[T]">range</a><a href="#scala.collection.immutable.Stream.range(cca71ea0b7).evidence$1" title="Integral[T]" class="delimiter">(</a><a href="../../math/Integral.scala.html#scala.math;Integral.mkNumericOps" title="implicit scala.math.Integral.mkNumericOps : (lhs: T)num.IntegralOps">start</a> <a href="../../math/Numeric.scala.html#scala.math;Numeric;Ops.+" title="(rhs: T)T">+</a> <a href="#scala.collection.immutable.Stream.range(cca71ea0b7).step" title="T">step</a>, <a href="#scala.collection.immutable.Stream.range(cca71ea0b7).end" title="T">end</a>, <a href="#scala.collection.immutable.Stream.range(cca71ea0b7).step" title="T">step</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private<span class="delimiter">[</span>immutable<span class="delimiter">]</span> def <a title="[A](stream: scala.collection.immutable.Stream[A], p: A =&gt; Boolean)scala.collection.immutable.Stream.Cons[A]" id="scala.collection.immutable.Stream.filteredTail">filteredTail</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.filteredTail;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream.filteredTail.stream">stream</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A =&gt; Boolean" id="scala.collection.immutable.Stream.filteredTail.p">p</a>: A =&gt; Boolean<span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: A, tl: =&gt; scala.collection.immutable.Stream[A])scala.collection.immutable.Stream.Cons[A]">cons</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.filteredTail.stream" title="scala.collection.immutable.Stream[A]">stream</a>.<a href="../IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; A">head</a>, <a href="#scala.collection.immutable.Stream.filteredTail.stream" title="scala.collection.immutable.Stream[A]">stream</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a> <a href="#scala.collection.immutable;Stream.filter" title="(p: A =&gt; Boolean)scala.collection.immutable.Stream[A]">filter</a> <a href="#scala.collection.immutable.Stream.filteredTail.p" title="A =&gt; Boolean">p</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private<span class="delimiter">[</span>immutable<span class="delimiter">]</span> def <a title="[A, B, That](head: B, stream: scala.collection.immutable.Stream[A], pf: PartialFunction[A,B], bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])scala.collection.immutable.Stream.Cons[B]" id="scala.collection.immutable.Stream.collectedTail">collectedTail</a><span class="delimiter">[</span><a title="" id="scala.collection.immutable.Stream.collectedTail;A">A</a>, <a title="" id="scala.collection.immutable.Stream.collectedTail;B">B</a>, <a title="" id="scala.collection.immutable.Stream.collectedTail;That">That</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="scala.collection.immutable.Stream.collectedTail.head">head</a>: <a href="#scala.collection.immutable.Stream.collectedTail;B" title="B">B</a>, <a title="scala.collection.immutable.Stream[A]" id="scala.collection.immutable.Stream.collectedTail.stream">stream</a>: <a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[A]">Stream</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="PartialFunction[A,B]" id="scala.collection.immutable.Stream.collectedTail.pf">pf</a>: <a href="../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[A,B]">PartialFunction</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>, <a title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]" id="scala.collection.immutable.Stream.collectedTail.bf">bf</a>: <a href="../generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">CanBuildFrom</a><span class="delimiter">[</span>Stream<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, That<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#scala.collection.immutable.Stream.cons.apply" title="(hd: B, tl: =&gt; scala.collection.immutable.Stream[B])scala.collection.immutable.Stream.Cons[B]">cons</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.collectedTail.head" title="B">head</a>, <a href="#scala.collection.immutable.Stream.collectedTail.stream" title="scala.collection.immutable.Stream[A]">stream</a>.<a href="../TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; scala.collection.immutable.Stream[A]">tail</a>.<a href="#scala.collection.immutable;Stream.collect" title="(pf: PartialFunction[A,B])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That])That">collect</a><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.collectedTail.pf" title="PartialFunction[A,B]">pf</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.collection.immutable.Stream.collectedTail.bf" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[A],B,That]">bf</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.collection.immutable.Stream[B]" class="delimiter">[</span><a href="#scala.collection.immutable;Stream" title="scala.collection.immutable.Stream[B]">Stream</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>



        </pre>
    </body>
</html>
