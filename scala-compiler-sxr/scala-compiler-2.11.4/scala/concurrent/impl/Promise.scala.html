<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/concurrent/impl/Promise.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2003-2013, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

package scala.concurrent.impl

import scala.concurrent.<span class="delimiter">{</span> ExecutionContext, CanAwait, OnCompleteRunnable, TimeoutException, ExecutionException, blocking <span class="delimiter">}</span>
import scala.concurrent.<a href="../Future.scala.html#scala.concurrent.Future" title="scala.concurrent.Future.type">Future</a>.InternalCallbackExecutor
import scala.concurrent.duration.<span class="delimiter">{</span> Duration, Deadline, FiniteDuration, NANOSECONDS <span class="delimiter">}</span>
import scala.annotation.tailrec
import scala.util.control.NonFatal
import scala.util.<span class="delimiter">{</span> Try, Success, Failure <span class="delimiter">}</span>
import java.io.ObjectInputStream
import java.util.concurrent.locks.AbstractQueuedSynchronizer

private<span class="delimiter">[</span>concurrent<span class="delimiter">]</span> trait <a title="trait Promise[T] extends AnyRef with scala.concurrent.Promise[T] with scala.concurrent.Future[T]" id="scala.concurrent.impl;Promise">Promise</a><span class="delimiter">[</span><a title="" id="scala.concurrent.impl;Promise;T">T</a><span class="delimiter">]</span> extends scala.concurrent.<a href="../Promise.scala.html#scala.concurrent;Promise" title="scala.concurrent.Promise[T]">Promise</a><span class="delimiter">[</span>T<span class="delimiter">]</span> with scala.concurrent.<a href="../Future.scala.html#scala.concurrent;Future" title="scala.concurrent.Future[T]">Future</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
  def <a title="=&gt; Promise.this.type" id="scala.concurrent.impl;Promise.future">future</a>: this.type = this
<span class="delimiter">}</span>

<span class="comment">/* Precondition: `executor` is prepared, i.e., `executor` has been returned from invocation of `prepare` on some other `ExecutionContext`.
 */</span>
private class <a title="class CallbackRunnable[T] extends Object with Runnable with scala.concurrent.OnCompleteRunnable" id="scala.concurrent.impl;CallbackRunnable">CallbackRunnable</a><span class="delimiter">[</span><a title="" id="scala.concurrent.impl;CallbackRunnable;T">T</a><span class="delimiter">]</span><a href="#scala.concurrent.impl;CallbackRunnable" title="scala.concurrent.impl.CallbackRunnable[T]" class="delimiter">(</a>val <a title="scala.concurrent.ExecutionContext" id="scala.concurrent.impl;CallbackRunnable.executor">executor</a>: <a href="../ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a>, val <a title="scala.util.Try[T] =&gt; Any" id="scala.concurrent.impl;CallbackRunnable.onComplete">onComplete</a>: Try<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; Any<span class="delimiter">)</span> extends <a href="#scala.concurrent.impl;CallbackRunnable" title="Runnable">Runnable</a> with <a href="../Future.scala.html#scala.concurrent;OnCompleteRunnable" title="scala.concurrent.OnCompleteRunnable">OnCompleteRunnable</a> <span class="delimiter">{</span>
  <span class="comment">// must be filled in before running it</span>
  var <a title="scala.util.Try[T]" id="scala.concurrent.impl;CallbackRunnable.value_=">value</a>: <a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = null

  override def <a title="()Unit" id="scala.concurrent.impl;CallbackRunnable.run">run</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#scala.Predef.require(58bb2a7169)" title="(requirement: Boolean)Unit">require</a><span class="delimiter">(</span><a href="#scala.concurrent.impl;CallbackRunnable.value_=" title="=&gt; scala.util.Try[T]">value</a> <span title="(x$1: AnyRef)Boolean">ne</span> null<span class="delimiter">)</span> <span class="comment">// must set value to non-null before running!</span>
    try <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: scala.util.Try[T])Any">onComplete</a><span title="Unit" class="delimiter">(</span><a href="#scala.concurrent.impl;CallbackRunnable.value_=" title="=&gt; scala.util.Try[T]">value</a><span class="delimiter">)</span> catch <span class="delimiter">{</span> case <a href="../../util/control/NonFatal.scala.html#scala.util.control.NonFatal.unapply" title="(t: Throwable)Option[Throwable]">NonFatal</a><span class="delimiter">(</span><a title="Throwable" id="scala.concurrent.impl;CallbackRunnable.run.e">e</a><span class="delimiter">)</span> =&gt; <a href="#scala.concurrent.impl;CallbackRunnable.executor" title="=&gt; scala.concurrent.ExecutionContext">executor</a> <a href="../ExecutionContext.scala.html#scala.concurrent;ExecutionContext.reportFailure" title="(cause: Throwable)Unit">reportFailure</a> <a href="#scala.concurrent.impl;CallbackRunnable.run.e" title="Throwable">e</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(v: scala.util.Try[T])Unit" id="scala.concurrent.impl;CallbackRunnable.executeWithValue">executeWithValue</a><span class="delimiter">(</span><a title="scala.util.Try[T]" id="scala.concurrent.impl;CallbackRunnable.executeWithValue.v">v</a>: <a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#scala.Predef.require(58bb2a7169)" title="(requirement: Boolean)Unit">require</a><span class="delimiter">(</span><a href="#scala.concurrent.impl;CallbackRunnable.value_=" title="=&gt; scala.util.Try[T]">value</a> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span> <span class="comment">// can't complete it twice</span>
    <a href="#scala.concurrent.impl;CallbackRunnable.value_=" title="(x$1: scala.util.Try[T])Unit">value</a> = <a href="#scala.concurrent.impl;CallbackRunnable.executeWithValue.v" title="scala.util.Try[T]">v</a>
    <span class="comment">// Note that we cannot prepare the ExecutionContext at this point, since we might</span>
    <span class="comment">// already be running on a different thread!</span>
    try <a href="#scala.concurrent.impl;CallbackRunnable.executor" title="=&gt; scala.concurrent.ExecutionContext">executor</a>.<a href="../ExecutionContext.scala.html#scala.concurrent;ExecutionContext.execute" title="(runnable: Runnable)Unit">execute</a><span class="delimiter">(</span>this<span class="delimiter">)</span> catch <span class="delimiter">{</span> case <a href="../../util/control/NonFatal.scala.html#scala.util.control.NonFatal.unapply" title="(t: Throwable)Option[Throwable]">NonFatal</a><span class="delimiter">(</span><a title="Throwable" id="scala.concurrent.impl;CallbackRunnable.executeWithValue.t">t</a><span class="delimiter">)</span> =&gt; <a href="#scala.concurrent.impl;CallbackRunnable.executor" title="=&gt; scala.concurrent.ExecutionContext">executor</a> <a href="../ExecutionContext.scala.html#scala.concurrent;ExecutionContext.reportFailure" title="(cause: Throwable)Unit">reportFailure</a> <a href="#scala.concurrent.impl;CallbackRunnable.executeWithValue.t" title="Throwable">t</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

private<span class="delimiter">[</span>concurrent<span class="delimiter">]</span> object <a title="scala.concurrent.impl.Promise.type" id="scala.concurrent.impl.Promise">Promise</a> <a href="#scala.concurrent.impl.Promise" title="scala.concurrent.impl.Promise.type" class="delimiter">{</a>

  private def <a title="[T](source: scala.util.Try[T])scala.util.Try[T]" id="scala.concurrent.impl.Promise.resolveTry">resolveTry</a><span class="delimiter">[</span><a title="" id="scala.concurrent.impl.Promise.resolveTry;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.util.Try[T]" id="scala.concurrent.impl.Promise.resolveTry.source">source</a>: <a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#scala.concurrent.impl.Promise.resolveTry.source" title="scala.util.Try[T]">source</a> match <span class="delimiter">{</span>
    case Failure<span class="delimiter">(</span><a title="Throwable" id="scala.concurrent.impl.Promise.resolveTry.t">t</a><span class="delimiter">)</span> =&gt; <a href="#scala.concurrent.impl.Promise.resolver" title="(throwable: Throwable)scala.util.Try[Nothing]">resolver</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise.resolveTry.t" title="Throwable">t</a><span class="delimiter">)</span>
    case _          =&gt; <a href="#scala.concurrent.impl.Promise.resolveTry.source" title="scala.util.Try[T]">source</a>
  <span class="delimiter">}</span>

  private def <a title="[T](throwable: Throwable)scala.util.Try[T]" id="scala.concurrent.impl.Promise.resolver">resolver</a><span class="delimiter">[</span><a title="" id="scala.concurrent.impl.Promise.resolver;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Throwable" id="scala.concurrent.impl.Promise.resolver.throwable">throwable</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span>: <a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#scala.concurrent.impl.Promise.resolver.throwable" title="Throwable">throwable</a> match <span class="delimiter">{</span>
    case <span title="scala.runtime.NonLocalReturnControl[_]">t</span>: scala.runtime.<a href="../../runtime/NonLocalReturnControl.scala.html#scala.runtime;NonLocalReturnControl" title="scala.runtime.NonLocalReturnControl[_]">NonLocalReturnControl</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="../../util/Try.scala.html#scala.util;Success" title="(value: T)scala.util.Success[T]">Success</a><span class="delimiter">(</span><span title="scala.runtime.NonLocalReturnControl[_]">t</span>.<a href="../../runtime/NonLocalReturnControl.scala.html#scala.runtime;NonLocalReturnControl.value" title="=&gt; _">value</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#scala.concurrent.impl.Promise.resolver;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">)</span>
    case <span title="scala.util.control.ControlThrowable">t</span>: scala.util.control.<a href="../../util/control/ControlThrowable.scala.html#scala.util.control;ControlThrowable" title="scala.util.control.ControlThrowable">ControlThrowable</a>    =&gt; <a href="../../util/Try.scala.html#scala.util;Failure" title="(exception: Throwable)scala.util.Failure[Nothing]">Failure</a><span class="delimiter">(</span>new <a href="../package.scala.html#scala.concurrent.package;ExecutionException" title="java.util.concurrent.ExecutionException">ExecutionException</a><span class="delimiter">(</span><span title="String(&quot;Boxed ControlThrowable&quot;)" class="string">&quot;Boxed ControlThrowable&quot;</span>, <span title="scala.util.control.ControlThrowable">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
    case <span title="InterruptedException">t</span>: <span title="InterruptedException">InterruptedException</span>                   =&gt; <a href="../../util/Try.scala.html#scala.util;Failure" title="(exception: Throwable)scala.util.Failure[Nothing]">Failure</a><span class="delimiter">(</span>new <a href="../package.scala.html#scala.concurrent.package;ExecutionException" title="java.util.concurrent.ExecutionException">ExecutionException</a><span class="delimiter">(</span><span title="String(&quot;Boxed InterruptedException&quot;)" class="string">&quot;Boxed InterruptedException&quot;</span>, <span title="InterruptedException">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
    case <a title="Error" id="scala.concurrent.impl.Promise.resolver.e">e</a>: <span title="Error">Error</span>                                  =&gt; <a href="../../util/Try.scala.html#scala.util;Failure" title="(exception: Throwable)scala.util.Failure[Nothing]">Failure</a><span class="delimiter">(</span>new <a href="../package.scala.html#scala.concurrent.package;ExecutionException" title="java.util.concurrent.ExecutionException">ExecutionException</a><span class="delimiter">(</span><span title="String(&quot;Boxed Error&quot;)" class="string">&quot;Boxed Error&quot;</span>, <a href="#scala.concurrent.impl.Promise.resolver.e" title="Error">e</a><span class="delimiter">)</span><span class="delimiter">)</span>
    case <span title="Throwable">t</span>                                         =&gt; <a href="../../util/Try.scala.html#scala.util;Failure" title="(exception: Throwable)scala.util.Failure[Nothing]">Failure</a><span class="delimiter">(</span><span title="Throwable">t</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

   <span class="comment">/**
    * Latch used to implement waiting on a DefaultPromise's result.
    *
    * Inspired by: http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/locks/AbstractQueuedSynchronizer.java
    * Written by Doug Lea with assistance from members of JCP JSR-166
    * Expert Group and released to the public domain, as explained at
    * http://creativecommons.org/publicdomain/zero/1.0/
    */</span>
    private final class <a title="class CompletionLatch[T] extends java.util.concurrent.locks.AbstractQueuedSynchronizer with scala.util.Try[T] =&gt; Unit" id="scala.concurrent.impl.Promise;CompletionLatch">CompletionLatch</a><span class="delimiter">[</span><a title="" id="scala.concurrent.impl.Promise;CompletionLatch;T">T</a><span class="delimiter">]</span> extends <a href="#scala.concurrent.impl.Promise;CompletionLatch" title="java.util.concurrent.locks.AbstractQueuedSynchronizer">AbstractQueuedSynchronizer</a> with <span class="delimiter">(</span>Try<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>
      override protected def <a title="(ignored: Int)Int" id="scala.concurrent.impl.Promise;CompletionLatch.tryAcquireShared">tryAcquireShared</a><span class="delimiter">(</span><a title="Int" id="scala.concurrent.impl.Promise;CompletionLatch.tryAcquireShared.ignored">ignored</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> = if <span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;CompletionLatch" title="()Int">getState</a> <a href="../../Int.scala.html#scala;Int.!=(5f58a84eb3)" title="(x: Int)Boolean">!=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="Int(1)" class="int">1</span> else -<span title="Int(-1)" class="int">1</span>
      override protected def <a title="(ignore: Int)Boolean" id="scala.concurrent.impl.Promise;CompletionLatch.tryReleaseShared">tryReleaseShared</a><span class="delimiter">(</span><a title="Int" id="scala.concurrent.impl.Promise;CompletionLatch.tryReleaseShared.ignore">ignore</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
        <a href="#scala.concurrent.impl.Promise;CompletionLatch" title="(x$1: Int)Unit">setState</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        true
      <span class="delimiter">}</span>
      override def <a title="(ignored: scala.util.Try[T])Unit" id="scala.concurrent.impl.Promise;CompletionLatch.apply">apply</a><span class="delimiter">(</span><a title="scala.util.Try[T]" id="scala.concurrent.impl.Promise;CompletionLatch.apply.ignored">ignored</a>: <a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <a href="#scala.concurrent.impl.Promise;CompletionLatch" title="(x$1: Int)Boolean">releaseShared</a><span title="Unit" class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>


  <span class="comment">/** Default promise implementation.
   *
   *  A DefaultPromise has three possible states. It can be:
   *
   *  1. Incomplete, with an associated list of callbacks waiting on completion.
   *  2. Complete, with a result.
   *  3. Linked to another DefaultPromise.
   *
   *  If a DefaultPromise is linked to another DefaultPromise, it will
   *  delegate all its operations to that other promise. This means that two
   *  DefaultPromises that are linked will appear, to external callers, to have
   *  exactly the same state and behaviour. For instance, both will appear as
   *  incomplete, or as complete with the same result value.
   *
   *  A DefaultPromise stores its state entirely in the AnyRef cell exposed by
   *  AbstractPromise. The type of object stored in the cell fully describes the
   *  current state of the promise.
   *
   *  1. List[CallbackRunnable] - The promise is incomplete and has zero or more callbacks
   *     to call when it is eventually completed.
   *  2. Try[T] - The promise is complete and now contains its value.
   *  3. DefaultPromise[T] - The promise is linked to another promise.
   *
   * The ability to link DefaultPromises is needed to prevent memory leaks when
   * using Future.flatMap. The previous implementation of Future.flatMap used
   * onComplete handlers to propagate the ultimate value of a flatMap operation
   * to its promise. Recursive calls to flatMap built a chain of onComplete
   * handlers and promises. Unfortunately none of the handlers or promises in
   * the chain could be collected until the handlers had been called and
   * detached, which only happened when the final flatMap future was completed.
   * (In some situations, such as infinite streams, this would never actually
   * happen.) Because of the fact that the promise implementation internally
   * created references between promises, and these references were invisible to
   * user code, it was easy for user code to accidentally build large chains of
   * promises and thereby leak memory.
   *
   * The problem of leaks is solved by automatically breaking these chains of
   * promises, so that promises don't refer to each other in a long chain. This
   * allows each promise to be individually collected. The idea is to &quot;flatten&quot;
   * the chain of promises, so that instead of each promise pointing to its
   * neighbour, they instead point directly the promise at the root of the
   * chain. This means that only the root promise is referenced, and all the
   * other promises are available for garbage collection as soon as they're no
   * longer referenced by user code.
   *
   * To make the chains flattenable, the concept of linking promises together
   * needed to become an explicit feature of the DefaultPromise implementation,
   * so that the implementation to navigate and rewire links as needed. The idea
   * of linking promises is based on the [[Twitter promise implementation
   * https://github.com/twitter/util/blob/master/util-core/src/main/scala/com/twitter/util/Promise.scala]].
   *
   * In practice, flattening the chain cannot always be done perfectly. When a
   * promise is added to the end of the chain, it scans the chain and links
   * directly to the root promise. This prevents the chain from growing forwards
   * But the root promise for a chain can change, causing the chain to grow
   * backwards, and leaving all previously-linked promise pointing at a promise
   * which is no longer the root promise.
   *
   * To mitigate the problem of the root promise changing, whenever a promise's
   * methods are called, and it needs a reference to its root promise it calls
   * the `compressedRoot()` method. This method re-scans the promise chain to
   * get the root promise, and also compresses its links so that it links
   * directly to whatever the current root promise is. This ensures that the
   * chain is flattened whenever `compressedRoot()` is called. And since
   * `compressedRoot()` is called at every possible opportunity (when getting a
   * promise's value, when adding an onComplete handler, etc), this will happen
   * frequently. Unfortunately, even this eager relinking doesn't absolutely
   * guarantee that the chain will be flattened and that leaks cannot occur.
   * However eager relinking does greatly reduce the chance that leaks will
   * occur.
   *
   * Future.flatMap links DefaultPromises together by calling the `linkRootOf`
   * method. This is the only externally visible interface to linked
   * DefaultPromises, and `linkedRootOf` is currently only designed to be called
   * by Future.flatMap.
   */</span>
  class <a title="class DefaultPromise[T] extends scala.concurrent.impl.AbstractPromise with scala.concurrent.impl.Promise[T]" id="scala.concurrent.impl.Promise;DefaultPromise">DefaultPromise</a><span class="delimiter">[</span><a title="" id="scala.concurrent.impl.Promise;DefaultPromise;T">T</a><span class="delimiter">]</span> extends <a href="AbstractPromise.java.html#scala.concurrent.impl;AbstractPromise" title="scala.concurrent.impl.AbstractPromise">AbstractPromise</a> with <a href="#scala.concurrent.impl;Promise" title="scala.concurrent.impl.Promise[T]">Promise</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> self =&gt;
    <a href="AbstractPromise.java.html#scala.concurrent.impl;AbstractPromise.updateState" title="(oldState: Any, newState: Any)Boolean">updateState</a><span class="delimiter">(</span>null, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <span class="comment">// The promise is incomplete and has no callbacks</span>

    <span class="comment">/** Get the root promise for this promise, compressing the link chain to that
     *  promise if necessary.
     *
     *  For promises that are not linked, the result of calling
     *  `compressedRoot()` will the promise itself. However for linked promises,
     *  this method will traverse each link until it locates the root promise at
     *  the base of the link chain.
     *
     *  As a side effect of calling this method, the link from this promise back
     *  to the root promise will be updated (&quot;compressed&quot;) to point directly to
     *  the root promise. This allows intermediate promises in the link chain to
     *  be garbage collected. Also, subsequent calls to this method should be
     *  faster as the link chain will be shorter.
     */</span>
    @tailrec
    private def <a title="()scala.concurrent.impl.Promise.DefaultPromise[T]" id="scala.concurrent.impl.Promise;DefaultPromise.compressedRoot">compressedRoot</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[T]">DefaultPromise</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="AbstractPromise.java.html#scala.concurrent.impl;AbstractPromise.getState" title="()Object">getState</a> match <span class="delimiter">{</span>
        case <a title="scala.concurrent.impl.Promise.DefaultPromise[_]" id="scala.concurrent.impl.Promise;DefaultPromise.compressedRoot.linked">linked</a>: <a href="#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[_]">DefaultPromise</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt;
          val <a title="scala.concurrent.impl.Promise.DefaultPromise[T]" id="scala.concurrent.impl.Promise;DefaultPromise.compressedRoot.target">target</a> = <a href="#scala.concurrent.impl.Promise;DefaultPromise.compressedRoot.linked" title="scala.concurrent.impl.Promise.DefaultPromise[_]">linked</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.concurrent.impl.Promise.DefaultPromise[T]" class="delimiter">[</span><a href="#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[T]">DefaultPromise</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>.<a href="#scala.concurrent.impl.Promise;DefaultPromise.root" title="=&gt; scala.concurrent.impl.Promise.DefaultPromise[T]">root</a>
          if <span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.compressedRoot.linked" title="scala.concurrent.impl.Promise.DefaultPromise[_]">linked</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.concurrent.impl.Promise;DefaultPromise.compressedRoot.target" title="scala.concurrent.impl.Promise.DefaultPromise[T]">target</a><span class="delimiter">)</span> <a href="#scala.concurrent.impl.Promise;DefaultPromise.compressedRoot.target" title="scala.concurrent.impl.Promise.DefaultPromise[T]">target</a> else if <span class="delimiter">(</span><a href="AbstractPromise.java.html#scala.concurrent.impl;AbstractPromise.updateState" title="(oldState: Any, newState: Any)Boolean">updateState</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.compressedRoot.linked" title="scala.concurrent.impl.Promise.DefaultPromise[_]">linked</a>, <a href="#scala.concurrent.impl.Promise;DefaultPromise.compressedRoot.target" title="scala.concurrent.impl.Promise.DefaultPromise[T]">target</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.concurrent.impl.Promise;DefaultPromise.compressedRoot.target" title="scala.concurrent.impl.Promise.DefaultPromise[T]">target</a> else <a href="#scala.concurrent.impl.Promise;DefaultPromise.compressedRoot" title="()scala.concurrent.impl.Promise.DefaultPromise[T]">compressedRoot</a><span class="delimiter">(</span><span class="delimiter">)</span>
        case _ =&gt; this
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Get the promise at the root of the chain of linked promises. Used by `compressedRoot()`.
     *  The `compressedRoot()` method should be called instead of this method, as it is important
     *  to compress the link chain whenever possible.
     */</span>
    @tailrec
    private def <a title="=&gt; scala.concurrent.impl.Promise.DefaultPromise[T]" id="scala.concurrent.impl.Promise;DefaultPromise.root">root</a>: <a href="#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[T]">DefaultPromise</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="AbstractPromise.java.html#scala.concurrent.impl;AbstractPromise.getState" title="()Object">getState</a> match <span class="delimiter">{</span>
        case <a title="scala.concurrent.impl.Promise.DefaultPromise[_]" id="scala.concurrent.impl.Promise;DefaultPromise.root.linked">linked</a>: <a href="#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[_]">DefaultPromise</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="#scala.concurrent.impl.Promise;DefaultPromise.root.linked" title="scala.concurrent.impl.Promise.DefaultPromise[_]">linked</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.concurrent.impl.Promise.DefaultPromise[T]" class="delimiter">[</span><a href="#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[T]">DefaultPromise</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>.<a href="#scala.concurrent.impl.Promise;DefaultPromise.root" title="=&gt; scala.concurrent.impl.Promise.DefaultPromise[T]">root</a>
        case _ =&gt; this
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Try waiting for this promise to be completed.
     */</span>
    protected final def <a title="(atMost: scala.concurrent.duration.Duration)Boolean" id="scala.concurrent.impl.Promise;DefaultPromise.tryAwait">tryAwait</a><span class="delimiter">(</span><a title="scala.concurrent.duration.Duration" id="scala.concurrent.impl.Promise;DefaultPromise.tryAwait.atMost">atMost</a>: <a href="../duration/Duration.scala.html#scala.concurrent.duration;Duration" title="scala.concurrent.duration.Duration">Duration</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.concurrent.impl.Promise;DefaultPromise.isCompleted" title="=&gt; Boolean">isCompleted</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      import <a href="../duration/Duration.scala.html#scala.concurrent.duration.Duration" title="scala.concurrent.duration.Duration.type">Duration</a>.Undefined
      import scala.concurrent.<a href="../Future.scala.html#scala.concurrent.Future" title="scala.concurrent.Future.type">Future</a>.InternalCallbackExecutor
      <a href="#scala.concurrent.impl.Promise;DefaultPromise.tryAwait.atMost" title="scala.concurrent.duration.Duration">atMost</a> match <span class="delimiter">{</span>
        case <a title="scala.concurrent.duration.Duration" id="scala.concurrent.impl.Promise;DefaultPromise.tryAwait.e">e</a> if <a href="#scala.concurrent.impl.Promise;DefaultPromise.tryAwait.e" title="scala.concurrent.duration.Duration">e</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="../duration/Duration.scala.html#scala.concurrent.duration.Duration.Undefined" title="=&gt; scala.concurrent.duration.Duration.Infinite">Undefined</a> =&gt; throw new <a href="../../package.scala.html#scala.package;IllegalArgumentException" title="IllegalArgumentException">IllegalArgumentException</a><span class="delimiter">(</span><span title="String(&quot;cannot wait for Undefined period&quot;)" class="string">&quot;cannot wait for Undefined period&quot;</span><span class="delimiter">)</span>
        case <a href="../duration/Duration.scala.html#scala.concurrent.duration.Duration" title="scala.concurrent.duration.Duration.type">Duration</a>.<a href="../duration/Duration.scala.html#scala.concurrent.duration.Duration.Inf" title="=&gt; scala.concurrent.duration.Duration.Infinite">Inf</a>        =&gt;
          val <span title="scala.concurrent.impl.Promise.CompletionLatch[T]">l</span> = new <a href="#scala.concurrent.impl.Promise;CompletionLatch" title="scala.concurrent.impl.Promise.CompletionLatch[T]">CompletionLatch</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#scala.concurrent.impl.Promise;DefaultPromise.onComplete" title="(func: scala.util.Try[T] =&gt; Unit)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a><span class="delimiter">(</span><span title="scala.concurrent.impl.Promise.CompletionLatch[T]">l</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="../Future.scala.html#scala.concurrent.Future.InternalCallbackExecutor" title="concurrent.Future.InternalCallbackExecutor.type">InternalCallbackExecutor</a><span class="delimiter">)</span>
          <span title="scala.concurrent.impl.Promise.CompletionLatch[T]">l</span>.<span title="(x$1: Int)Unit">acquireSharedInterruptibly</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        case <a href="../duration/Duration.scala.html#scala.concurrent.duration.Duration" title="scala.concurrent.duration.Duration.type">Duration</a>.<a href="../duration/Duration.scala.html#scala.concurrent.duration.Duration.MinusInf" title="=&gt; scala.concurrent.duration.Duration.Infinite">MinusInf</a>   =&gt; <span class="comment">// Drop out</span>
        case <a title="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.impl.Promise;DefaultPromise.tryAwait.f">f</a>: <a href="../duration/Duration.scala.html#scala.concurrent.duration;FiniteDuration" title="scala.concurrent.duration.FiniteDuration">FiniteDuration</a>   =&gt;
          if <span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.tryAwait.f" title="scala.concurrent.duration.FiniteDuration">f</a> <a href="../../math/Ordered.scala.html#scala.math;Ordered.>" title="(that: scala.concurrent.duration.Duration)Boolean">&gt;</a> <a href="../duration/Duration.scala.html#scala.concurrent.duration.Duration" title="scala.concurrent.duration.Duration.type">Duration</a>.<a href="../duration/Duration.scala.html#scala.concurrent.duration.Duration.Zero" title="=&gt; scala.concurrent.duration.FiniteDuration">Zero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            val <span title="scala.concurrent.impl.Promise.CompletionLatch[T]">l</span> = new <a href="#scala.concurrent.impl.Promise;CompletionLatch" title="scala.concurrent.impl.Promise.CompletionLatch[T]">CompletionLatch</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
            <a href="#scala.concurrent.impl.Promise;DefaultPromise.onComplete" title="(func: scala.util.Try[T] =&gt; Unit)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a><span class="delimiter">(</span><span title="scala.concurrent.impl.Promise.CompletionLatch[T]">l</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="../Future.scala.html#scala.concurrent.Future.InternalCallbackExecutor" title="concurrent.Future.InternalCallbackExecutor.type">InternalCallbackExecutor</a><span class="delimiter">)</span>
            <span title="scala.concurrent.impl.Promise.CompletionLatch[T]">l</span>.<span title="(x$1: Int, x$2: Long)Boolean">tryAcquireSharedNanos</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span>, <a href="#scala.concurrent.impl.Promise;DefaultPromise.tryAwait.f" title="scala.concurrent.duration.FiniteDuration">f</a>.<a href="../duration/Duration.scala.html#scala.concurrent.duration;FiniteDuration.toNanos" title="=&gt; Long">toNanos</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#scala.concurrent.impl.Promise;DefaultPromise.isCompleted" title="=&gt; Boolean">isCompleted</a>
    <span class="delimiter">}</span> else true <span class="comment">// Already completed</span>

    @throws<span class="delimiter">(</span>classOf<span class="delimiter">[</span>TimeoutException<span class="delimiter">]</span><span class="delimiter">)</span>
    @throws<span class="delimiter">(</span>classOf<span class="delimiter">[</span>InterruptedException<span class="delimiter">]</span><span class="delimiter">)</span>
    def <a title="(atMost: scala.concurrent.duration.Duration)(implicit permit: scala.concurrent.CanAwait)DefaultPromise.this.type" id="scala.concurrent.impl.Promise;DefaultPromise.ready">ready</a><span class="delimiter">(</span><a title="scala.concurrent.duration.Duration" id="scala.concurrent.impl.Promise;DefaultPromise.ready.atMost">atMost</a>: <a href="../duration/Duration.scala.html#scala.concurrent.duration;Duration" title="scala.concurrent.duration.Duration">Duration</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.CanAwait" id="scala.concurrent.impl.Promise;DefaultPromise.ready.permit">permit</a>: <a href="../package.scala.html#scala.concurrent;CanAwait" title="scala.concurrent.CanAwait">CanAwait</a><span class="delimiter">)</span>: this.type =
      if <span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.tryAwait" title="(atMost: scala.concurrent.duration.Duration)Boolean">tryAwait</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.ready.atMost" title="scala.concurrent.duration.Duration">atMost</a><span class="delimiter">)</span><span class="delimiter">)</span> this
      else throw new <a href="../package.scala.html#scala.concurrent.package;TimeoutException" title="java.util.concurrent.TimeoutException">TimeoutException</a><span class="delimiter">(</span><span title="String(&quot;Futures timed out after [&quot;)" class="string">&quot;Futures timed out after [&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.concurrent.impl.Promise;DefaultPromise.ready.atMost" title="scala.concurrent.duration.Duration">atMost</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>

    @throws<span class="delimiter">(</span>classOf<span class="delimiter">[</span>Exception<span class="delimiter">]</span><span class="delimiter">)</span>
    def <a title="(atMost: scala.concurrent.duration.Duration)(implicit permit: scala.concurrent.CanAwait)T" id="scala.concurrent.impl.Promise;DefaultPromise.result">result</a><span class="delimiter">(</span><a title="scala.concurrent.duration.Duration" id="scala.concurrent.impl.Promise;DefaultPromise.result.atMost">atMost</a>: <a href="../duration/Duration.scala.html#scala.concurrent.duration;Duration" title="scala.concurrent.duration.Duration">Duration</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.CanAwait" id="scala.concurrent.impl.Promise;DefaultPromise.result.permit">permit</a>: <a href="../package.scala.html#scala.concurrent;CanAwait" title="scala.concurrent.CanAwait">CanAwait</a><span class="delimiter">)</span>: <a href="#scala.concurrent.impl.Promise;DefaultPromise;T" title="T">T</a> =
      <a href="#scala.concurrent.impl.Promise;DefaultPromise.ready" title="(atMost: scala.concurrent.duration.Duration)(implicit permit: scala.concurrent.CanAwait)DefaultPromise.this.type">ready</a><a href="#scala.concurrent.impl.Promise;DefaultPromise.result.permit" title="scala.concurrent.CanAwait" class="delimiter">(</a><a href="#scala.concurrent.impl.Promise;DefaultPromise.result.atMost" title="scala.concurrent.duration.Duration">atMost</a><span class="delimiter">)</span>.<a href="#scala.concurrent.impl.Promise;DefaultPromise.value" title="=&gt; Option[scala.util.Try[T]]">value</a>.<a href="../../Option.scala.html#scala;Option.get" title="=&gt; scala.util.Try[T]">get</a>.<a href="../../util/Try.scala.html#scala.util;Try.get" title="=&gt; T">get</a> <span class="comment">// ready throws TimeoutException if timeout so value.get is safe here</span>

    def <a title="=&gt; Option[scala.util.Try[T]]" id="scala.concurrent.impl.Promise;DefaultPromise.value">value</a>: <a href="../../Option.scala.html#scala;Option" title="Option[scala.util.Try[T]]">Option</a><span class="delimiter">[</span>Try<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scala.concurrent.impl.Promise;DefaultPromise.value0" title="=&gt; Option[scala.util.Try[T]]">value0</a>

    @tailrec
    private def <a title="=&gt; Option[scala.util.Try[T]]" id="scala.concurrent.impl.Promise;DefaultPromise.value0">value0</a>: <a href="../../Option.scala.html#scala;Option" title="Option[scala.util.Try[T]]">Option</a><span class="delimiter">[</span>Try<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="AbstractPromise.java.html#scala.concurrent.impl;AbstractPromise.getState" title="()Object">getState</a> match <span class="delimiter">{</span>
      case <a title="scala.util.Try[_]" id="scala.concurrent.impl.Promise;DefaultPromise.value0.c">c</a>: <a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[_]">Try</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="../../Option.scala.html#scala;Some" title="(x: scala.util.Try[T])Some[scala.util.Try[T]]">Some</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.value0.c" title="scala.util.Try[_]">c</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.util.Try[T]" class="delimiter">[</span><a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
      case _: <a href="#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[_]">DefaultPromise</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="#scala.concurrent.impl.Promise;DefaultPromise.compressedRoot" title="()scala.concurrent.impl.Promise.DefaultPromise[T]">compressedRoot</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#scala.concurrent.impl.Promise;DefaultPromise.value0" title="=&gt; Option[scala.util.Try[T]]">value0</a>
      case _ =&gt; <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
    <span class="delimiter">}</span>

    override def <a title="=&gt; Boolean" id="scala.concurrent.impl.Promise;DefaultPromise.isCompleted">isCompleted</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.concurrent.impl.Promise;DefaultPromise.isCompleted0" title="=&gt; Boolean">isCompleted0</a>

    @tailrec
    private def <a title="=&gt; Boolean" id="scala.concurrent.impl.Promise;DefaultPromise.isCompleted0">isCompleted0</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="AbstractPromise.java.html#scala.concurrent.impl;AbstractPromise.getState" title="()Object">getState</a> match <span class="delimiter">{</span>
      case _: <a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[_]">Try</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; true
      case _: <a href="#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[_]">DefaultPromise</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="#scala.concurrent.impl.Promise;DefaultPromise.compressedRoot" title="()scala.concurrent.impl.Promise.DefaultPromise[T]">compressedRoot</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#scala.concurrent.impl.Promise;DefaultPromise.isCompleted0" title="=&gt; Boolean">isCompleted0</a>
      case _ =&gt; false
    <span class="delimiter">}</span>

    def <a title="(value: scala.util.Try[T])Boolean" id="scala.concurrent.impl.Promise;DefaultPromise.tryComplete">tryComplete</a><span class="delimiter">(</span><a title="scala.util.Try[T]" id="scala.concurrent.impl.Promise;DefaultPromise.tryComplete.value">value</a>: <a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      val <a title="scala.util.Try[T]" id="scala.concurrent.impl.Promise;DefaultPromise.tryComplete.resolved">resolved</a> = <a href="#scala.concurrent.impl.Promise.resolveTry" title="(source: scala.util.Try[T])scala.util.Try[T]">resolveTry</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.tryComplete.value" title="scala.util.Try[T]">value</a><span class="delimiter">)</span>
      <a href="#scala.concurrent.impl.Promise;DefaultPromise.tryCompleteAndGetListeners" title="(v: scala.util.Try[T])List[scala.concurrent.impl.CallbackRunnable[T]]">tryCompleteAndGetListeners</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.tryComplete.resolved" title="scala.util.Try[T]">resolved</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case null             =&gt; false
        case <span title="List[scala.concurrent.impl.CallbackRunnable[T]]">rs</span> if <span title="List[scala.concurrent.impl.CallbackRunnable[T]]">rs</span>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> =&gt; true
        case <span title="List[scala.concurrent.impl.CallbackRunnable[T]]">rs</span>               =&gt; <span title="List[scala.concurrent.impl.CallbackRunnable[T]]">rs</span>.<a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: scala.concurrent.impl.CallbackRunnable[T] =&gt; Unit)Unit">foreach</a><span class="delimiter">(</span><a title="scala.concurrent.impl.CallbackRunnable[T]" id="scala.concurrent.impl.Promise;DefaultPromise.tryComplete.$anonfun.r">r</a> =&gt; <a href="#scala.concurrent.impl.Promise;DefaultPromise.tryComplete.$anonfun.r" title="scala.concurrent.impl.CallbackRunnable[T]">r</a>.<a href="#scala.concurrent.impl;CallbackRunnable.executeWithValue" title="(v: scala.util.Try[T])Unit">executeWithValue</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.tryComplete.resolved" title="scala.util.Try[T]">resolved</a><span class="delimiter">)</span><span class="delimiter">)</span>; true
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Called by `tryComplete` to store the resolved value and get the list of
     *  listeners, or `null` if it is already completed.
     */</span>
    @tailrec
    private def <a title="(v: scala.util.Try[T])List[scala.concurrent.impl.CallbackRunnable[T]]" id="scala.concurrent.impl.Promise;DefaultPromise.tryCompleteAndGetListeners">tryCompleteAndGetListeners</a><span class="delimiter">(</span><a title="scala.util.Try[T]" id="scala.concurrent.impl.Promise;DefaultPromise.tryCompleteAndGetListeners.v">v</a>: <a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[scala.concurrent.impl.CallbackRunnable[T]]">List</a><span class="delimiter">[</span>CallbackRunnable<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="AbstractPromise.java.html#scala.concurrent.impl;AbstractPromise.getState" title="()Object">getState</a> match <span class="delimiter">{</span>
        case <a title="List[_]" id="scala.concurrent.impl.Promise;DefaultPromise.tryCompleteAndGetListeners.raw">raw</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[_]">List</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt;
          val <a title="List[scala.concurrent.impl.CallbackRunnable[T]]" id="scala.concurrent.impl.Promise;DefaultPromise.tryCompleteAndGetListeners.cur">cur</a> = <a href="#scala.concurrent.impl.Promise;DefaultPromise.tryCompleteAndGetListeners.raw" title="List[_]">raw</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="List[scala.concurrent.impl.CallbackRunnable[T]]" class="delimiter">[</span><a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[scala.concurrent.impl.CallbackRunnable[T]]">List</a><span class="delimiter">[</span>CallbackRunnable<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
          if <span class="delimiter">(</span><a href="AbstractPromise.java.html#scala.concurrent.impl;AbstractPromise.updateState" title="(oldState: Any, newState: Any)Boolean">updateState</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.tryCompleteAndGetListeners.cur" title="List[scala.concurrent.impl.CallbackRunnable[T]]">cur</a>, <a href="#scala.concurrent.impl.Promise;DefaultPromise.tryCompleteAndGetListeners.v" title="scala.util.Try[T]">v</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.concurrent.impl.Promise;DefaultPromise.tryCompleteAndGetListeners.cur" title="List[scala.concurrent.impl.CallbackRunnable[T]]">cur</a> else <a href="#scala.concurrent.impl.Promise;DefaultPromise.tryCompleteAndGetListeners" title="(v: scala.util.Try[T])List[scala.concurrent.impl.CallbackRunnable[T]]">tryCompleteAndGetListeners</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.tryCompleteAndGetListeners.v" title="scala.util.Try[T]">v</a><span class="delimiter">)</span>
        case _: <a href="#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[_]">DefaultPromise</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt;
          <a href="#scala.concurrent.impl.Promise;DefaultPromise.compressedRoot" title="()scala.concurrent.impl.Promise.DefaultPromise[T]">compressedRoot</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#scala.concurrent.impl.Promise;DefaultPromise.tryCompleteAndGetListeners" title="(v: scala.util.Try[T])List[scala.concurrent.impl.CallbackRunnable[T]]">tryCompleteAndGetListeners</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.tryCompleteAndGetListeners.v" title="scala.util.Try[T]">v</a><span class="delimiter">)</span>
        case _ =&gt; null
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    def <a title="[U](func: scala.util.Try[T] =&gt; U)(implicit executor: scala.concurrent.ExecutionContext)Unit" id="scala.concurrent.impl.Promise;DefaultPromise.onComplete">onComplete</a><span class="delimiter">[</span><a title="" id="scala.concurrent.impl.Promise;DefaultPromise.onComplete;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.util.Try[T] =&gt; U" id="scala.concurrent.impl.Promise;DefaultPromise.onComplete.func">func</a>: Try<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; U<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent.impl.Promise;DefaultPromise.onComplete.executor">executor</a>: <a href="../ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <span class="delimiter">{</span>
      val <a title="scala.concurrent.ExecutionContext" id="scala.concurrent.impl.Promise;DefaultPromise.onComplete.preparedEC">preparedEC</a> = <a href="#scala.concurrent.impl.Promise;DefaultPromise.onComplete.executor" title="scala.concurrent.ExecutionContext">executor</a>.<a href="../ExecutionContext.scala.html#scala.concurrent;ExecutionContext.prepare" title="()scala.concurrent.ExecutionContext">prepare</a><span class="delimiter">(</span><span class="delimiter">)</span>
      val <a title="scala.concurrent.impl.CallbackRunnable[T]" id="scala.concurrent.impl.Promise;DefaultPromise.onComplete.runnable">runnable</a> = new <a href="#scala.concurrent.impl;CallbackRunnable" title="scala.concurrent.impl.CallbackRunnable[T]">CallbackRunnable</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.onComplete.preparedEC" title="scala.concurrent.ExecutionContext">preparedEC</a>, <a href="#scala.concurrent.impl.Promise;DefaultPromise.onComplete.func" title="scala.util.Try[T] =&gt; U">func</a><span class="delimiter">)</span>
      <a href="#scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback" title="(runnable: scala.concurrent.impl.CallbackRunnable[T])Unit">dispatchOrAddCallback</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.onComplete.runnable" title="scala.concurrent.impl.CallbackRunnable[T]">runnable</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Tries to add the callback, if already completed, it dispatches the callback to be executed.
     *  Used by `onComplete()` to add callbacks to a promise and by `link()` to transfer callbacks
     *  to the root promise when linking two promises togehter.
     */</span>
    @tailrec
    private def <a title="(runnable: scala.concurrent.impl.CallbackRunnable[T])Unit" id="scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback">dispatchOrAddCallback</a><span class="delimiter">(</span><a title="scala.concurrent.impl.CallbackRunnable[T]" id="scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback.runnable">runnable</a>: <a href="#scala.concurrent.impl;CallbackRunnable" title="scala.concurrent.impl.CallbackRunnable[T]">CallbackRunnable</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <span class="delimiter">{</span>
      <a href="AbstractPromise.java.html#scala.concurrent.impl;AbstractPromise.getState" title="()Object">getState</a> match <span class="delimiter">{</span>
        case <a title="scala.util.Try[_]" id="scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback.r">r</a>: <a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[_]">Try</a><span class="delimiter">[</span>_<span class="delimiter">]</span>          =&gt; <a href="#scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback.runnable" title="scala.concurrent.impl.CallbackRunnable[T]">runnable</a>.<a href="#scala.concurrent.impl;CallbackRunnable.executeWithValue" title="(v: scala.util.Try[T])Unit">executeWithValue</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback.r" title="scala.util.Try[_]">r</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.util.Try[T]" class="delimiter">[</span><a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
        case _: <a href="#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[_]">DefaultPromise</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="#scala.concurrent.impl.Promise;DefaultPromise.compressedRoot" title="()scala.concurrent.impl.Promise.DefaultPromise[T]">compressedRoot</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback" title="(runnable: scala.concurrent.impl.CallbackRunnable[T])Unit">dispatchOrAddCallback</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback.runnable" title="scala.concurrent.impl.CallbackRunnable[T]">runnable</a><span class="delimiter">)</span>
        case <a title="List[_]" id="scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback.listeners">listeners</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[_]">List</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; if <span class="delimiter">(</span><a href="AbstractPromise.java.html#scala.concurrent.impl;AbstractPromise.updateState" title="(oldState: Any, newState: Any)Boolean">updateState</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback.listeners" title="List[_]">listeners</a>, <a href="#scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback.runnable" title="scala.concurrent.impl.CallbackRunnable[T]">runnable</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Any)List[Any]">::</a> <a href="#scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback.listeners" title="List[_]">listeners</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span> else <a href="#scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback" title="(runnable: scala.concurrent.impl.CallbackRunnable[T])Unit">dispatchOrAddCallback</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback.runnable" title="scala.concurrent.impl.CallbackRunnable[T]">runnable</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Link this promise to the root of another promise using `link()`. Should only be
     *  be called by Future.flatMap.
     */</span>
    protected<span class="delimiter">[</span>concurrent<span class="delimiter">]</span> final def <a title="(target: scala.concurrent.impl.Promise.DefaultPromise[T])Unit" id="scala.concurrent.impl.Promise;DefaultPromise.linkRootOf">linkRootOf</a><span class="delimiter">(</span><a title="scala.concurrent.impl.Promise.DefaultPromise[T]" id="scala.concurrent.impl.Promise;DefaultPromise.linkRootOf.target">target</a>: <a href="#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[T]">DefaultPromise</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <a href="#scala.concurrent.impl.Promise;DefaultPromise.link" title="(target: scala.concurrent.impl.Promise.DefaultPromise[T])Unit">link</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.linkRootOf.target" title="scala.concurrent.impl.Promise.DefaultPromise[T]">target</a>.<a href="#scala.concurrent.impl.Promise;DefaultPromise.compressedRoot" title="()scala.concurrent.impl.Promise.DefaultPromise[T]">compressedRoot</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">/** Link this promise to another promise so that both promises share the same
     *  externally-visible state. Depending on the current state of this promise, this
     *  may involve different things. For example, any onComplete listeners will need
     *  to be transferred.
     *
     *  If this promise is already completed, then the same effect as linking -
     *  sharing the same completed value - is achieved by simply sending this
     *  promise's result to the target promise.
     */</span>
    @tailrec
    private def <a title="(target: scala.concurrent.impl.Promise.DefaultPromise[T])Unit" id="scala.concurrent.impl.Promise;DefaultPromise.link">link</a><span class="delimiter">(</span><a title="scala.concurrent.impl.Promise.DefaultPromise[T]" id="scala.concurrent.impl.Promise;DefaultPromise.link.target">target</a>: <a href="#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[T]">DefaultPromise</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = if <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.concurrent.impl.Promise;DefaultPromise.link.target" title="scala.concurrent.impl.Promise.DefaultPromise[T]">target</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="AbstractPromise.java.html#scala.concurrent.impl;AbstractPromise.getState" title="()Object">getState</a> match <span class="delimiter">{</span>
        case <a title="scala.util.Try[_]" id="scala.concurrent.impl.Promise;DefaultPromise.link.r">r</a>: <a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[_]">Try</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt;
          if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.concurrent.impl.Promise;DefaultPromise.link.target" title="scala.concurrent.impl.Promise.DefaultPromise[T]">target</a>.<a href="#scala.concurrent.impl.Promise;DefaultPromise.tryComplete" title="(value: scala.util.Try[T])Boolean">tryComplete</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.link.r" title="scala.util.Try[_]">r</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.util.Try[T]" class="delimiter">[</span><a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="comment">// Currently linking is done from Future.flatMap, which should ensure only</span>
            <span class="comment">// one promise can be completed. Therefore this situation is unexpected.</span>
            throw new <span title="IllegalStateException">IllegalStateException</span><span class="delimiter">(</span><span title="String(&quot;Cannot link completed promises together&quot;)" class="string">&quot;Cannot link completed promises together&quot;</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        case _: <a href="#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[_]">DefaultPromise</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt;
          <a href="#scala.concurrent.impl.Promise;DefaultPromise.compressedRoot" title="()scala.concurrent.impl.Promise.DefaultPromise[T]">compressedRoot</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#scala.concurrent.impl.Promise;DefaultPromise.link" title="(target: scala.concurrent.impl.Promise.DefaultPromise[T])Unit">link</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.link.target" title="scala.concurrent.impl.Promise.DefaultPromise[T]">target</a><span class="delimiter">)</span>
        case <a title="List[_]" id="scala.concurrent.impl.Promise;DefaultPromise.link.listeners">listeners</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[_]">List</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; if <span class="delimiter">(</span><a href="AbstractPromise.java.html#scala.concurrent.impl;AbstractPromise.updateState" title="(oldState: Any, newState: Any)Boolean">updateState</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.link.listeners" title="List[_]">listeners</a>, <a href="#scala.concurrent.impl.Promise;DefaultPromise.link.target" title="scala.concurrent.impl.Promise.DefaultPromise[T]">target</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.concurrent.impl.Promise;DefaultPromise.link.listeners" title="List[_]">listeners</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.concurrent.impl.Promise;DefaultPromise.link.listeners" title="List[_]">listeners</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="List[scala.concurrent.impl.CallbackRunnable[T]]" class="delimiter">[</span><a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[scala.concurrent.impl.CallbackRunnable[T]]">List</a><span class="delimiter">[</span>CallbackRunnable<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>.<a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: scala.concurrent.impl.CallbackRunnable[T] =&gt; Unit)Unit">foreach</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.link.target" title="scala.concurrent.impl.Promise.DefaultPromise[T]">target</a>.<a href="#scala.concurrent.impl.Promise;DefaultPromise.dispatchOrAddCallback" title="(runnable: scala.concurrent.impl.CallbackRunnable[T])Unit">dispatchOrAddCallback</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.link.$anonfun.x$2" title="scala.concurrent.impl.CallbackRunnable[T]">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span> else <a href="#scala.concurrent.impl.Promise;DefaultPromise.link" title="(target: scala.concurrent.impl.Promise.DefaultPromise[T])Unit">link</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;DefaultPromise.link.target" title="scala.concurrent.impl.Promise.DefaultPromise[T]">target</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An already completed Future is given its result at creation.
   *
   *  Useful in Future-composition when a value to contribute is already available.
   */</span>
  final class <a title="class KeptPromise[T] extends AnyRef with scala.concurrent.impl.Promise[T]" id="scala.concurrent.impl.Promise;KeptPromise">KeptPromise</a><span class="delimiter">[</span><a title="" id="scala.concurrent.impl.Promise;KeptPromise;T">T</a><span class="delimiter">]</span><a href="#scala.concurrent.impl.Promise;KeptPromise" title="scala.concurrent.impl.Promise.KeptPromise[T]" class="delimiter">(</a><a title="scala.util.Try[T]" id="scala.concurrent.impl.Promise;KeptPromise.suppliedValue">suppliedValue</a>: <a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.concurrent.impl;Promise" title="scala.concurrent.impl.Promise[T]">Promise</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>

    val <a title="Some[scala.util.Try[T]]" id="scala.concurrent.impl.Promise;KeptPromise.value">value</a> = <a href="../../Option.scala.html#scala;Some" title="(x: scala.util.Try[T])Some[scala.util.Try[T]]">Some</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise.resolveTry" title="(source: scala.util.Try[T])scala.util.Try[T]">resolveTry</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;KeptPromise.suppliedValue" title="scala.util.Try[T]">suppliedValue</a><span class="delimiter">)</span><span class="delimiter">)</span>

    override def <a title="=&gt; Boolean" id="scala.concurrent.impl.Promise;KeptPromise.isCompleted">isCompleted</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = true

    def <a title="(value: scala.util.Try[T])Boolean" id="scala.concurrent.impl.Promise;KeptPromise.tryComplete">tryComplete</a><span class="delimiter">(</span><a title="scala.util.Try[T]" id="scala.concurrent.impl.Promise;KeptPromise.tryComplete.value">value</a>: <a href="../../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false

    def <a title="[U](func: scala.util.Try[T] =&gt; U)(implicit executor: scala.concurrent.ExecutionContext)Unit" id="scala.concurrent.impl.Promise;KeptPromise.onComplete">onComplete</a><span class="delimiter">[</span><a title="" id="scala.concurrent.impl.Promise;KeptPromise.onComplete;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.util.Try[T] =&gt; U" id="scala.concurrent.impl.Promise;KeptPromise.onComplete.func">func</a>: Try<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; U<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent.impl.Promise;KeptPromise.onComplete.executor">executor</a>: <a href="../ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <span class="delimiter">{</span>
      val <a title="scala.util.Try[T]" id="scala.concurrent.impl.Promise;KeptPromise.onComplete.completedAs">completedAs</a> = <a href="#scala.concurrent.impl.Promise;KeptPromise.value" title="=&gt; Some[scala.util.Try[T]]">value</a>.<a href="../../Option.scala.html#scala;Some.get" title="=&gt; scala.util.Try[T]">get</a>
      val <a title="scala.concurrent.ExecutionContext" id="scala.concurrent.impl.Promise;KeptPromise.onComplete.preparedEC">preparedEC</a> = <a href="#scala.concurrent.impl.Promise;KeptPromise.onComplete.executor" title="scala.concurrent.ExecutionContext">executor</a>.<a href="../ExecutionContext.scala.html#scala.concurrent;ExecutionContext.prepare" title="()scala.concurrent.ExecutionContext">prepare</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">(</span>new <a href="#scala.concurrent.impl;CallbackRunnable" title="scala.concurrent.impl.CallbackRunnable[T]">CallbackRunnable</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;KeptPromise.onComplete.preparedEC" title="scala.concurrent.ExecutionContext">preparedEC</a>, <a href="#scala.concurrent.impl.Promise;KeptPromise.onComplete.func" title="scala.util.Try[T] =&gt; U">func</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#scala.concurrent.impl;CallbackRunnable.executeWithValue" title="(v: scala.util.Try[T])Unit">executeWithValue</a><span class="delimiter">(</span><a href="#scala.concurrent.impl.Promise;KeptPromise.onComplete.completedAs" title="scala.util.Try[T]">completedAs</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    def <a title="(atMost: scala.concurrent.duration.Duration)(implicit permit: scala.concurrent.CanAwait)KeptPromise.this.type" id="scala.concurrent.impl.Promise;KeptPromise.ready">ready</a><span class="delimiter">(</span><a title="scala.concurrent.duration.Duration" id="scala.concurrent.impl.Promise;KeptPromise.ready.atMost">atMost</a>: <a href="../duration/Duration.scala.html#scala.concurrent.duration;Duration" title="scala.concurrent.duration.Duration">Duration</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.CanAwait" id="scala.concurrent.impl.Promise;KeptPromise.ready.permit">permit</a>: <a href="../package.scala.html#scala.concurrent;CanAwait" title="scala.concurrent.CanAwait">CanAwait</a><span class="delimiter">)</span>: this.type = this

    def <a title="(atMost: scala.concurrent.duration.Duration)(implicit permit: scala.concurrent.CanAwait)T" id="scala.concurrent.impl.Promise;KeptPromise.result">result</a><span class="delimiter">(</span><a title="scala.concurrent.duration.Duration" id="scala.concurrent.impl.Promise;KeptPromise.result.atMost">atMost</a>: <a href="../duration/Duration.scala.html#scala.concurrent.duration;Duration" title="scala.concurrent.duration.Duration">Duration</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.CanAwait" id="scala.concurrent.impl.Promise;KeptPromise.result.permit">permit</a>: <a href="../package.scala.html#scala.concurrent;CanAwait" title="scala.concurrent.CanAwait">CanAwait</a><span class="delimiter">)</span>: <a href="#scala.concurrent.impl.Promise;KeptPromise;T" title="T">T</a> = <a href="#scala.concurrent.impl.Promise;KeptPromise.value" title="=&gt; Some[scala.util.Try[T]]">value</a>.<a href="../../Option.scala.html#scala;Some.get" title="=&gt; scala.util.Try[T]">get</a>.<a href="../../util/Try.scala.html#scala.util;Try.get" title="=&gt; T">get</a>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
