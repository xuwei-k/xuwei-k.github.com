<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/concurrent/Future.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2003-2013, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

package scala.concurrent

import scala.<a href="../language.scala.html#scala.language" title="language.type">language</a>.higherKinds

import java.util.concurrent.<span class="delimiter">{</span> ConcurrentLinkedQueue, TimeUnit, Callable <span class="delimiter">}</span>
import java.util.concurrent.<span title="java.util.concurrent.TimeUnit.type">TimeUnit</span>.<span class="delimiter">{</span> NANOSECONDS =&gt; NANOS, MILLISECONDS â‡’ MILLIS <span class="delimiter">}</span>
import java.lang.<span class="delimiter">{</span> Iterable =&gt; JIterable <span class="delimiter">}</span>
import java.util.<span class="delimiter">{</span> LinkedList =&gt; JLinkedList <span class="delimiter">}</span>
import java.util.concurrent.atomic.<span class="delimiter">{</span> AtomicReferenceFieldUpdater, AtomicInteger, AtomicLong, AtomicBoolean <span class="delimiter">}</span>

import scala.util.control.NonFatal
import scala.Option
import scala.util.<span class="delimiter">{</span>Try, Success, Failure<span class="delimiter">}</span>

import scala.annotation.tailrec
import scala.collection.mutable.Builder
import scala.collection.generic.CanBuildFrom
import scala.reflect.ClassTag



<span class="comment">/** The trait that represents futures.
 *
 *  Asynchronous computations that yield futures are created with the `Future` call:
 *
 *  {{{
 *  val s = &quot;Hello&quot;
 *  val f: Future[String] = Future {
 *    s + &quot; future!&quot;
 *  }
 *  f onSuccess {
 *    case msg =&gt; println(msg)
 *  }
 *  }}}
 *
 *  @author  Philipp Haller, Heather Miller, Aleksandar Prokopec, Viktor Klang
 *
 *  @define multipleCallbacks
 *  Multiple callbacks may be registered; there is no guarantee that they will be
 *  executed in a particular order.
 *
 *  @define caughtThrowables
 *  The future may contain a throwable object and this means that the future failed.
 *  Futures obtained through combinators have the same exception as the future they were obtained from.
 *  The following throwable objects are not contained in the future:
 *  - `Error` - errors are not contained within futures
 *  - `InterruptedException` - not contained within futures
 *  - all `scala.util.control.ControlThrowable` except `NonLocalReturnControl` - not contained within futures
 *
 *  Instead, the future is completed with a ExecutionException with one of the exceptions above
 *  as the cause.
 *  If a future is failed with a `scala.runtime.NonLocalReturnControl`,
 *  it is completed with a value from that throwable instead.
 *
 *  @define nonDeterministic
 *  Note: using this method yields nondeterministic dataflow programs.
 *
 *  @define forComprehensionExamples
 *  Example:
 *
 *  {{{
 *  val f = Future { 5 }
 *  val g = Future { 3 }
 *  val h = for {
 *    x: Int &lt;- f // returns Future(5)
 *    y: Int &lt;- g // returns Future(3)
 *  } yield x + y
 *  }}}
 *
 *  is translated to:
 *
 *  {{{
 *  f flatMap { (x: Int) =&gt; g map { (y: Int) =&gt; x + y } }
 *  }}}
 *
 * @define callbackInContext
 * The provided callback always runs in the provided implicit
 *`ExecutionContext`, though there is no guarantee that the
 * `execute()` method on the `ExecutionContext` will be called once
 * per callback or that `execute()` will be called in the current
 * thread. That is, the implementation may run multiple callbacks
 * in a batch within a single `execute()` and it may run
 * `execute()` either immediately or asynchronously.
 */</span>
trait <a title="trait Future[+T] extends AnyRef with scala.concurrent.Awaitable[T]" id="scala.concurrent;Future">Future</a><span class="delimiter">[</span>+<a title="" id="scala.concurrent;Future;T">T</a><span class="delimiter">]</span> extends <a href="Awaitable.scala.html#scala.concurrent;Awaitable" title="scala.concurrent.Awaitable[T]">Awaitable</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>

  <span class="comment">// The executor within the lexical scope</span>
  <span class="comment">// of the Future trait. Note that this will</span>
  <span class="comment">// (modulo bugs) _never_ execute a callback</span>
  <span class="comment">// other than those below in this same file.</span>
  <span class="comment">//</span>
  <span class="comment">// See the documentation on `InternalCallbackExecutor` for more details.</span>
  private def <a title="=&gt; scala.concurrent.Future.InternalCallbackExecutor.type" id="scala.concurrent;Future.internalExecutor">internalExecutor</a> = <a href="#scala.concurrent.Future" title="scala.concurrent.Future.type">Future</a>.<a href="#scala.concurrent.Future.InternalCallbackExecutor" title="scala.concurrent.Future.InternalCallbackExecutor.type">InternalCallbackExecutor</a>

  <span class="comment">/* Callbacks */</span>

  <span class="comment">/** When this future is completed successfully (i.e., with a value),
   *  apply the provided partial function to the value if the partial function
   *  is defined at that value.
   *
   *  If the future has already been completed with a value,
   *  this will either be applied immediately or be scheduled asynchronously.
   *
   *  $multipleCallbacks
   *  $callbackInContext
   */</span>
  def <a title="[U](pf: PartialFunction[T,U])(implicit executor: scala.concurrent.ExecutionContext)Unit" id="scala.concurrent;Future.onSuccess">onSuccess</a><span class="delimiter">[</span><a title="" id="scala.concurrent;Future.onSuccess;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[T,U]" id="scala.concurrent;Future.onSuccess.pf">pf</a>: <a href="../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[T,U]">PartialFunction</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent;Future.onSuccess.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[T] =&gt; Any)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent;Future.onSuccess.$anonfun.x0$1" title="Any" class="delimiter">{</a>
    case Success<span class="delimiter">(</span><a title="T" id="scala.concurrent;Future.onSuccess.$anonfun.v">v</a><span class="delimiter">)</span> =&gt;
      <a href="#scala.concurrent;Future.onSuccess.pf" title="PartialFunction[T,U]">pf</a>.<a href="../PartialFunction.scala.html#scala;PartialFunction.applyOrElse" title="[A1 &lt;: T, B1 &gt;: U](x: A1, default: A1 =&gt; B1)B1">applyOrElse</a><span title="(x: T, default: T =&gt; Any)Any" class="delimiter">[</span><a href="#scala.concurrent;Future;T" title="T">T</a>, <span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.concurrent;Future.onSuccess.$anonfun.v" title="T">v</a>, <a href="../Predef.scala.html#scala.Predef" title="type">Predef</a>.<a href="../Predef.scala.html#scala.Predef.conforms" title="[A]=&gt; &lt;:&lt;[A,A]">conforms</a><span title="&lt;:&lt;[T,T]" class="delimiter">[</span><a href="#scala.concurrent;Future;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">)</span> <span class="comment">// Exploiting the cached function to avoid MatchError</span>
    case _ =&gt;
  <span class="delimiter">}</span>

  <span class="comment">/** When this future is completed with a failure (i.e., with a throwable),
   *  apply the provided callback to the throwable.
   *
   *  $caughtThrowables
   *
   *  If the future has already been completed with a failure,
   *  this will either be applied immediately or be scheduled asynchronously.
   *
   *  Will not be called in case that the future is completed with a value.
   *
   *  $multipleCallbacks
   *  $callbackInContext
   */</span>
  def <a title="[U](pf: PartialFunction[Throwable,U])(implicit executor: scala.concurrent.ExecutionContext)Unit" id="scala.concurrent;Future.onFailure">onFailure</a><span class="delimiter">[</span><a title="" id="scala.concurrent;Future.onFailure;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span>@deprecatedName<span class="delimiter">(</span><span class="symbol">'callback</span><span class="delimiter">)</span> <a title="PartialFunction[Throwable,U]" id="scala.concurrent;Future.onFailure.pf">pf</a>: <a href="../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[Throwable,U]">PartialFunction</a><span class="delimiter">[</span>Throwable, U<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent;Future.onFailure.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[T] =&gt; Any)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent;Future.onFailure.$anonfun.x0$2" title="Any" class="delimiter">{</a>
    case Failure<span class="delimiter">(</span><a title="Throwable" id="scala.concurrent;Future.onFailure.$anonfun.t">t</a><span class="delimiter">)</span> =&gt;
      <a href="#scala.concurrent;Future.onFailure.pf" title="PartialFunction[Throwable,U]">pf</a>.<a href="../PartialFunction.scala.html#scala;PartialFunction.applyOrElse" title="[A1 &lt;: Throwable, B1 &gt;: U](x: A1, default: A1 =&gt; B1)B1">applyOrElse</a><span title="(x: Throwable, default: Throwable =&gt; Any)Any" class="delimiter">[</span><span title="Throwable">Throwable</span>, <span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.concurrent;Future.onFailure.$anonfun.t" title="Throwable">t</a>, <a href="../Predef.scala.html#scala.Predef" title="type">Predef</a>.<a href="../Predef.scala.html#scala.Predef.conforms" title="[A]=&gt; &lt;:&lt;[A,A]">conforms</a><span title="&lt;:&lt;[Throwable,Throwable]" class="delimiter">[</span><span title="Throwable">Throwable</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="comment">// Exploiting the cached function to avoid MatchError</span>
    case _ =&gt;
  <span class="delimiter">}</span>

  <span class="comment">/** When this future is completed, either through an exception, or a value,
   *  apply the provided function.
   *
   *  If the future has already been completed,
   *  this will either be applied immediately or be scheduled asynchronously.
   *
   *  $multipleCallbacks
   *  $callbackInContext
   */</span>
  def <a title="[U](f: scala.util.Try[T] =&gt; U)(implicit executor: scala.concurrent.ExecutionContext)Unit" id="scala.concurrent;Future.onComplete">onComplete</a><span class="delimiter">[</span><a title="" id="scala.concurrent;Future.onComplete;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span>@deprecatedName<span class="delimiter">(</span><span class="symbol">'func</span><span class="delimiter">)</span> <a title="scala.util.Try[T] =&gt; U" id="scala.concurrent;Future.onComplete.f">f</a>: Try<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; U<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent;Future.onComplete.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="../Unit.scala.html#scala;Unit" title="Unit">Unit</a>


  <span class="comment">/* Miscellaneous */</span>

  <span class="comment">/** Returns whether the future has already been completed with
   *  a value or an exception.
   *
   *  $nonDeterministic
   *
   *  @return    `true` if the future is already completed, `false` otherwise
   */</span>
  def <a title="=&gt; Boolean" id="scala.concurrent;Future.isCompleted">isCompleted</a>: <a href="../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

  <span class="comment">/** The value of this `Future`.
   *
   *  If the future is not completed the returned value will be `None`.
   *  If the future is completed the value will be `Some(Success(t))`
   *  if it contains a valid result, or `Some(Failure(error))` if it contains
   *  an exception.
   */</span>
  def <a title="=&gt; Option[scala.util.Try[T]]" id="scala.concurrent;Future.value">value</a>: <a href="../Option.scala.html#scala;Option" title="Option[scala.util.Try[T]]">Option</a><span class="delimiter">[</span>Try<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>


  <span class="comment">/* Projections */</span>

  <span class="comment">/** Returns a failed projection of this future.
   *
   *  The failed projection is a future holding a value of type `Throwable`.
   *
   *  It is completed with a value which is the throwable of the original future
   *  in case the original future is failed.
   *
   *  It is failed with a `NoSuchElementException` if the original future is completed successfully.
   *
   *  Blocking on this future returns a value if the original future is completed with an exception
   *  and throws a corresponding exception if the original future fails.
   */</span>
  def <a title="=&gt; scala.concurrent.Future[Throwable]" id="scala.concurrent;Future.failed">failed</a>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[Throwable]">Future</a><span class="delimiter">[</span>Throwable<span class="delimiter">]</span> = <span class="delimiter">{</span>
    implicit val <a title="scala.concurrent.Future.InternalCallbackExecutor.type" id="scala.concurrent;Future.failed.ec">ec</a> = <a href="#scala.concurrent;Future.internalExecutor" title="=&gt; scala.concurrent.Future.InternalCallbackExecutor.type">internalExecutor</a>
    val <a title="scala.concurrent.Promise[Throwable]" id="scala.concurrent;Future.failed.p">p</a> = <a href="Promise.scala.html#scala.concurrent.Promise.apply" title="[T]()scala.concurrent.Promise[T]">Promise</a><span title="()scala.concurrent.Promise[Throwable]" class="delimiter">[</span><span title="Throwable">Throwable</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[T] =&gt; scala.concurrent.Promise[Throwable])(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent;Future.failed.$anonfun.x0$3" title="p.type" class="delimiter">{</a>
      case Failure<span class="delimiter">(</span><a title="Throwable" id="scala.concurrent;Future.failed.$anonfun.t">t</a><span class="delimiter">)</span> =&gt; <a href="#scala.concurrent;Future.failed.p" title="scala.concurrent.Promise[Throwable]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.success" title="(value: Throwable)p.type">success</a> <a href="#scala.concurrent;Future.failed.$anonfun.t" title="Throwable">t</a>
      case Success<span class="delimiter">(</span><a title="T" id="scala.concurrent;Future.failed.$anonfun.v">v</a><span class="delimiter">)</span> =&gt; <a href="#scala.concurrent;Future.failed.p" title="scala.concurrent.Promise[Throwable]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.failure" title="(cause: Throwable)p.type">failure</a> <span class="delimiter">(</span>new <a href="../package.scala.html#scala.package;NoSuchElementException" title="java.util.NoSuchElementException">NoSuchElementException</a><span class="delimiter">(</span><span title="String(&quot;Future.failed not completed with a throwable.&quot;)" class="string">&quot;Future.failed not completed with a throwable.&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#scala.concurrent;Future.failed.p" title="scala.concurrent.Promise[Throwable]">p</a>.<a href="Promise.scala.html#scala.concurrent;Promise.future" title="=&gt; scala.concurrent.Future[Throwable]">future</a>
  <span class="delimiter">}</span>


  <span class="comment">/* Monadic operations */</span>

  <span class="comment">/** Asynchronously processes the value in the future once the value becomes available.
   *
   *  Will not be called if the future fails.
   */</span>
  def <a title="[U](f: T =&gt; U)(implicit executor: scala.concurrent.ExecutionContext)Unit" id="scala.concurrent;Future.foreach">foreach</a><span class="delimiter">[</span><a title="" id="scala.concurrent;Future.foreach;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; U" id="scala.concurrent;Future.foreach.f">f</a>: T =&gt; U<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent;Future.foreach.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[T] =&gt; Unit)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent;Future.foreach.executor" title="scala.concurrent.ExecutionContext" class="delimiter">{</a> <a href="#scala.concurrent;Future.foreach.$anonfun.x$1" title="scala.util.Try[T]">_</a> <a href="../util/Try.scala.html#scala.util;Try.foreach" title="(f: T =&gt; U)Unit">foreach</a> <a href="#scala.concurrent;Future.foreach.f" title="T =&gt; U">f</a> <span class="delimiter">}</span>

  <span class="comment">/** Creates a new future by applying the 's' function to the successful result of
   *  this future, or the 'f' function to the failed result. If there is any non-fatal
   *  exception thrown when 's' or 'f' is applied, that exception will be propagated
   *  to the resulting future.
   *
   *  @param  s  function that transforms a successful result of the receiver into a
   *             successful result of the returned future
   *  @param  f  function that transforms a failure of the receiver into a failure of
   *             the returned future
   *  @return    a future that will be completed with the transformed value
   */</span>
  def <a title="[S](s: T =&gt; S, f: Throwable =&gt; Throwable)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[S]" id="scala.concurrent;Future.transform">transform</a><span class="delimiter">[</span><a title="" id="scala.concurrent;Future.transform;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; S" id="scala.concurrent;Future.transform.s">s</a>: T =&gt; S, <a title="Throwable =&gt; Throwable" id="scala.concurrent;Future.transform.f">f</a>: Throwable =&gt; Throwable<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent;Future.transform.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[S]">Future</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scala.concurrent.Promise[S]" id="scala.concurrent;Future.transform.p">p</a> = <a href="Promise.scala.html#scala.concurrent.Promise.apply" title="[T]()scala.concurrent.Promise[T]">Promise</a><span title="()scala.concurrent.Promise[S]" class="delimiter">[</span><a href="#scala.concurrent;Future.transform;S" title="S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="comment">// transform on Try has the wrong shape for us here</span>
    <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[T] =&gt; scala.concurrent.Promise[S])(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent;Future.transform.$anonfun.x0$4" title="p.type" class="delimiter">{</a>
      case Success<span class="delimiter">(</span><a title="T" id="scala.concurrent;Future.transform.$anonfun.r">r</a><span class="delimiter">)</span> =&gt; <a href="#scala.concurrent;Future.transform.p" title="scala.concurrent.Promise[S]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.complete" title="(result: scala.util.Try[S])p.type">complete</a> <a href="../util/Try.scala.html#scala.util.Try.apply" title="(r: =&gt; S)scala.util.Try[S]">Try</a><span class="delimiter">(</span><a href="../Function1.scala.html#scala;Function1.apply" title="(v1: T)S">s</a><span class="delimiter">(</span><a href="#scala.concurrent;Future.transform.$anonfun.r" title="T">r</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case Failure<span class="delimiter">(</span><a title="Throwable" id="scala.concurrent;Future.transform.$anonfun.t">t</a><span class="delimiter">)</span> =&gt; <a href="#scala.concurrent;Future.transform.p" title="scala.concurrent.Promise[S]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.complete" title="(result: scala.util.Try[S])p.type">complete</a> <a href="../util/Try.scala.html#scala.util.Try.apply" title="(r: =&gt; Nothing)scala.util.Try[Nothing]">Try</a><span class="delimiter">(</span>throw <a href="../Function1.scala.html#scala;Function1.apply" title="(v1: Throwable)Throwable">f</a><span class="delimiter">(</span><a href="#scala.concurrent;Future.transform.$anonfun.t" title="Throwable">t</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// will throw fatal errors!</span>
    <span class="delimiter">}</span>
    <a href="#scala.concurrent;Future.transform.p" title="scala.concurrent.Promise[S]">p</a>.<a href="Promise.scala.html#scala.concurrent;Promise.future" title="=&gt; scala.concurrent.Future[S]">future</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Creates a new future by applying a function to the successful result of
   *  this future. If this future is completed with an exception then the new
   *  future will also contain this exception.
   *
   *  $forComprehensionExamples
   */</span>
  def <a title="[S](f: T =&gt; S)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[S]" id="scala.concurrent;Future.map">map</a><span class="delimiter">[</span><a title="" id="scala.concurrent;Future.map;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; S" id="scala.concurrent;Future.map.f">f</a>: T =&gt; S<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent;Future.map.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[S]">Future</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = <span class="delimiter">{</span> <span class="comment">// transform(f, identity)</span>
    val <a title="scala.concurrent.Promise[S]" id="scala.concurrent;Future.map.p">p</a> = <a href="Promise.scala.html#scala.concurrent.Promise.apply" title="[T]()scala.concurrent.Promise[T]">Promise</a><span title="()scala.concurrent.Promise[S]" class="delimiter">[</span><a href="#scala.concurrent;Future.map;S" title="S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[T] =&gt; scala.concurrent.Promise[S])(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent;Future.map.executor" title="scala.concurrent.ExecutionContext" class="delimiter">{</a> <a title="scala.util.Try[T]" id="scala.concurrent;Future.map.$anonfun.v">v</a> =&gt; <a href="#scala.concurrent;Future.map.p" title="scala.concurrent.Promise[S]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.complete" title="(result: scala.util.Try[S])p.type">complete</a> <span class="delimiter">(</span><a href="#scala.concurrent;Future.map.$anonfun.v" title="scala.util.Try[T]">v</a> <a href="../util/Try.scala.html#scala.util;Try.map" title="(f: T =&gt; S)scala.util.Try[S]">map</a> <a href="#scala.concurrent;Future.map.f" title="T =&gt; S">f</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#scala.concurrent;Future.map.p" title="scala.concurrent.Promise[S]">p</a>.<a href="Promise.scala.html#scala.concurrent;Promise.future" title="=&gt; scala.concurrent.Future[S]">future</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Creates a new future by applying a function to the successful result of
   *  this future, and returns the result of the function as the new future.
   *  If this future is completed with an exception then the new future will
   *  also contain this exception.
   *
   *  $forComprehensionExamples
   */</span>
  def <a title="[S](f: T =&gt; scala.concurrent.Future[S])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[S]" id="scala.concurrent;Future.flatMap">flatMap</a><span class="delimiter">[</span><a title="" id="scala.concurrent;Future.flatMap;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; scala.concurrent.Future[S]" id="scala.concurrent;Future.flatMap.f">f</a>: T =&gt; Future<span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent;Future.flatMap.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[S]">Future</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = <span class="delimiter">{</span>
    import impl.<a href="impl/Promise.scala.html#scala.concurrent.impl.Promise" title="scala.concurrent.impl.Promise.type">Promise</a>.DefaultPromise
    val <a title="scala.concurrent.impl.Promise.DefaultPromise[S]" id="scala.concurrent;Future.flatMap.p">p</a> = new <a href="impl/Promise.scala.html#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[S]">DefaultPromise</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[T] =&gt; Any)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent;Future.flatMap.$anonfun.x0$5" title="Any" class="delimiter">{</a>
      case <a title="scala.util.Failure[_]" id="scala.concurrent;Future.flatMap.$anonfun.f">f</a>: <a href="../util/Try.scala.html#scala.util;Failure" title="scala.util.Failure[_]">Failure</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="#scala.concurrent;Future.flatMap.p" title="scala.concurrent.impl.Promise.DefaultPromise[S]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.complete" title="(result: scala.util.Try[S])p.type">complete</a> <a href="#scala.concurrent;Future.flatMap.$anonfun.f" title="scala.util.Failure[_]">f</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.util.Failure[S]" class="delimiter">[</span><a href="../util/Try.scala.html#scala.util;Failure" title="scala.util.Failure[S]">Failure</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span>
      case Success<span class="delimiter">(</span><a title="T" id="scala.concurrent;Future.flatMap.$anonfun.v">v</a><span class="delimiter">)</span> =&gt; try <a href="../Function1.scala.html#scala;Function1.apply" title="(v1: T)scala.concurrent.Future[S]">f</a><span class="delimiter">(</span><a href="#scala.concurrent;Future.flatMap.$anonfun.v" title="T">v</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        <span class="comment">// If possible, link DefaultPromises to avoid space leaks</span>
        case <a title="scala.concurrent.impl.Promise.DefaultPromise[_]" id="scala.concurrent;Future.flatMap.$anonfun.dp">dp</a>: <a href="impl/Promise.scala.html#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[_]">DefaultPromise</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="#scala.concurrent;Future.flatMap.$anonfun.dp" title="scala.concurrent.impl.Promise.DefaultPromise[_]">dp</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.concurrent.impl.Promise.DefaultPromise[S]" class="delimiter">[</span><a href="impl/Promise.scala.html#scala.concurrent.impl.Promise;DefaultPromise" title="scala.concurrent.impl.Promise.DefaultPromise[S]">DefaultPromise</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">]</span>.<a href="impl/Promise.scala.html#scala.concurrent.impl.Promise;DefaultPromise.linkRootOf" title="(target: scala.concurrent.impl.Promise.DefaultPromise[S])Unit">linkRootOf</a><span class="delimiter">(</span><a href="#scala.concurrent;Future.flatMap.p" title="scala.concurrent.impl.Promise.DefaultPromise[S]">p</a><span class="delimiter">)</span>
        case <a title="scala.concurrent.Future[S]" id="scala.concurrent;Future.flatMap.$anonfun.fut">fut</a> =&gt; <a href="#scala.concurrent;Future.flatMap.$anonfun.fut" title="scala.concurrent.Future[S]">fut</a>.<a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[S] =&gt; scala.concurrent.impl.Promise.DefaultPromise[S])(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a><span class="delimiter">(</span><a href="#scala.concurrent;Future.flatMap.p" title="scala.concurrent.impl.Promise.DefaultPromise[S]">p</a>.<a href="Promise.scala.html#scala.concurrent;Promise.complete" title="(result: scala.util.Try[S])p.type">complete</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.concurrent;Future.internalExecutor" title="=&gt; scala.concurrent.Future.InternalCallbackExecutor.type">internalExecutor</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> catch <span class="delimiter">{</span> case <a href="../util/control/NonFatal.scala.html#scala.util.control.NonFatal.unapply" title="(t: Throwable)Option[Throwable]">NonFatal</a><span class="delimiter">(</span><a title="Throwable" id="scala.concurrent;Future.flatMap.$anonfun.t">t</a><span class="delimiter">)</span> =&gt; <a href="#scala.concurrent;Future.flatMap.p" title="scala.concurrent.impl.Promise.DefaultPromise[S]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.failure" title="(cause: Throwable)p.type">failure</a> <a href="#scala.concurrent;Future.flatMap.$anonfun.t" title="Throwable">t</a> <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#scala.concurrent;Future.flatMap.p" title="scala.concurrent.impl.Promise.DefaultPromise[S]">p</a>.<a href="impl/Promise.scala.html#scala.concurrent.impl;Promise.future" title="=&gt; p.type">future</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Creates a new future by filtering the value of the current future with a predicate.
   *
   *  If the current future contains a value which satisfies the predicate, the new future will also hold that value.
   *  Otherwise, the resulting future will fail with a `NoSuchElementException`.
   *
   *  If the current future fails, then the resulting future also fails.
   *
   *  Example:
   *  {{{
   *  val f = Future { 5 }
   *  val g = f filter { _ % 2 == 1 }
   *  val h = f filter { _ % 2 == 0 }
   *  Await.result(g, Duration.Zero) // evaluates to 5
   *  Await.result(h, Duration.Zero) // throw a NoSuchElementException
   *  }}}
   */</span>
  def <a title="(p: T =&gt; Boolean)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[T]" id="scala.concurrent;Future.filter">filter</a><span class="delimiter">(</span>@deprecatedName<span class="delimiter">(</span><span class="symbol">'pred</span><span class="delimiter">)</span> <a title="T =&gt; Boolean" id="scala.concurrent;Future.filter.p">p</a>: T =&gt; Boolean<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent;Future.filter.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[T]">Future</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#scala.concurrent;Future.map" title="(f: T =&gt; T)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[T]">map</a> <a href="#scala.concurrent;Future.filter.executor" title="scala.concurrent.ExecutionContext" class="delimiter">{</a>
      <a title="T" id="scala.concurrent;Future.filter.$anonfun.r">r</a> =&gt; if <span class="delimiter">(</span><a href="../Function1.scala.html#scala;Function1.apply" title="(v1: T)Boolean">p</a><span class="delimiter">(</span><a href="#scala.concurrent;Future.filter.$anonfun.r" title="T">r</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.concurrent;Future.filter.$anonfun.r" title="T">r</a> else throw new <a href="../package.scala.html#scala.package;NoSuchElementException" title="java.util.NoSuchElementException">NoSuchElementException</a><span class="delimiter">(</span><span title="String(&quot;Future.filter predicate is not satisfied&quot;)" class="string">&quot;Future.filter predicate is not satisfied&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Used by for-comprehensions.
   */</span>
  final def <a title="(p: T =&gt; Boolean)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[T]" id="scala.concurrent;Future.withFilter">withFilter</a><span class="delimiter">(</span><a title="T =&gt; Boolean" id="scala.concurrent;Future.withFilter.p">p</a>: T =&gt; Boolean<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent;Future.withFilter.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[T]">Future</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#scala.concurrent;Future.filter" title="(p: T =&gt; Boolean)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[T]">filter</a><span class="delimiter">(</span><a href="#scala.concurrent;Future.withFilter.p" title="T =&gt; Boolean">p</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.concurrent;Future.withFilter.executor" title="scala.concurrent.ExecutionContext">executor</a><span class="delimiter">)</span>

  <span class="comment">/** Creates a new future by mapping the value of the current future, if the given partial function is defined at that value.
   *
   *  If the current future contains a value for which the partial function is defined, the new future will also hold that value.
   *  Otherwise, the resulting future will fail with a `NoSuchElementException`.
   *
   *  If the current future fails, then the resulting future also fails.
   *
   *  Example:
   *  {{{
   *  val f = Future { -5 }
   *  val g = f collect {
   *    case x if x &lt; 0 =&gt; -x
   *  }
   *  val h = f collect {
   *    case x if x &gt; 0 =&gt; x * 2
   *  }
   *  Await.result(g, Duration.Zero) // evaluates to 5
   *  Await.result(h, Duration.Zero) // throw a NoSuchElementException
   *  }}}
   */</span>
  def <a title="[S](pf: PartialFunction[T,S])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[S]" id="scala.concurrent;Future.collect">collect</a><span class="delimiter">[</span><a title="" id="scala.concurrent;Future.collect;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[T,S]" id="scala.concurrent;Future.collect.pf">pf</a>: <a href="../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[T,S]">PartialFunction</a><span class="delimiter">[</span>T, S<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent;Future.collect.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[S]">Future</a><span class="delimiter">[</span>S<span class="delimiter">]</span> =
    <a href="#scala.concurrent;Future.map" title="(f: T =&gt; S)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[S]">map</a> <a href="#scala.concurrent;Future.collect.executor" title="scala.concurrent.ExecutionContext" class="delimiter">{</a>
      <a title="T" id="scala.concurrent;Future.collect.$anonfun.r">r</a> =&gt; <a href="#scala.concurrent;Future.collect.pf" title="PartialFunction[T,S]">pf</a>.<a href="../PartialFunction.scala.html#scala;PartialFunction.applyOrElse" title="(x: T, default: T =&gt; S)S">applyOrElse</a><span class="delimiter">(</span><a href="#scala.concurrent;Future.collect.$anonfun.r" title="T">r</a>, <span class="delimiter">(</span>t: <a href="#scala.concurrent;Future;T" title="T">T</a><span class="delimiter">)</span> =&gt; throw new <a href="../package.scala.html#scala.package;NoSuchElementException" title="java.util.NoSuchElementException">NoSuchElementException</a><span class="delimiter">(</span><span title="String(&quot;Future.collect partial function is not defined at: &quot;)" class="string">&quot;Future.collect partial function is not defined at: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.concurrent;Future.collect.$anonfun.$anonfun.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Creates a new future that will handle any matching throwable that this
   *  future might contain. If there is no match, or if this future contains
   *  a valid result then the new future will contain the same.
   *
   *  Example:
   *
   *  {{{
   *  Future (6 / 0) recover { case e: ArithmeticException =&gt; 0 } // result: 0
   *  Future (6 / 0) recover { case e: NotFoundException   =&gt; 0 } // result: exception
   *  Future (6 / 2) recover { case e: ArithmeticException =&gt; 0 } // result: 3
   *  }}}
   */</span>
  def <a title="[U &gt;: T](pf: PartialFunction[Throwable,U])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[U]" id="scala.concurrent;Future.recover">recover</a><span class="delimiter">[</span><a title=" &gt;: T" id="scala.concurrent;Future.recover;U">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[Throwable,U]" id="scala.concurrent;Future.recover.pf">pf</a>: <a href="../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[Throwable,U]">PartialFunction</a><span class="delimiter">[</span>Throwable, U<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent;Future.recover.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[U]">Future</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scala.concurrent.Promise[U]" id="scala.concurrent;Future.recover.p">p</a> = <a href="Promise.scala.html#scala.concurrent.Promise.apply" title="[T]()scala.concurrent.Promise[T]">Promise</a><span title="()scala.concurrent.Promise[U]" class="delimiter">[</span><a href="#scala.concurrent;Future.recover;U" title="U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[T] =&gt; scala.concurrent.Promise[U])(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent;Future.recover.executor" title="scala.concurrent.ExecutionContext" class="delimiter">{</a> <a title="scala.util.Try[T]" id="scala.concurrent;Future.recover.$anonfun.v">v</a> =&gt; <a href="#scala.concurrent;Future.recover.p" title="scala.concurrent.Promise[U]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.complete" title="(result: scala.util.Try[U])p.type">complete</a> <span class="delimiter">(</span><a href="#scala.concurrent;Future.recover.$anonfun.v" title="scala.util.Try[T]">v</a> <a href="../util/Try.scala.html#scala.util;Try.recover" title="(f: PartialFunction[Throwable,U])scala.util.Try[U]">recover</a> <a href="#scala.concurrent;Future.recover.pf" title="PartialFunction[Throwable,U]">pf</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#scala.concurrent;Future.recover.p" title="scala.concurrent.Promise[U]">p</a>.<a href="Promise.scala.html#scala.concurrent;Promise.future" title="=&gt; scala.concurrent.Future[U]">future</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Creates a new future that will handle any matching throwable that this
   *  future might contain by assigning it a value of another future.
   *
   *  If there is no match, or if this future contains
   *  a valid result then the new future will contain the same result.
   *
   *  Example:
   *
   *  {{{
   *  val f = Future { Int.MaxValue }
   *  Future (6 / 0) recoverWith { case e: ArithmeticException =&gt; f } // result: Int.MaxValue
   *  }}}
   */</span>
  def <a title="[U &gt;: T](pf: PartialFunction[Throwable,scala.concurrent.Future[U]])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[U]" id="scala.concurrent;Future.recoverWith">recoverWith</a><span class="delimiter">[</span><a title=" &gt;: T" id="scala.concurrent;Future.recoverWith;U">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[Throwable,scala.concurrent.Future[U]]" id="scala.concurrent;Future.recoverWith.pf">pf</a>: <a href="../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[Throwable,scala.concurrent.Future[U]]">PartialFunction</a><span class="delimiter">[</span>Throwable, Future<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent;Future.recoverWith.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[U]">Future</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scala.concurrent.Promise[U]" id="scala.concurrent;Future.recoverWith.p">p</a> = <a href="Promise.scala.html#scala.concurrent.Promise.apply" title="[T]()scala.concurrent.Promise[T]">Promise</a><span title="()scala.concurrent.Promise[U]" class="delimiter">[</span><a href="#scala.concurrent;Future.recoverWith;U" title="U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[T] =&gt; Any)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent;Future.recoverWith.$anonfun.x0$6" title="Any" class="delimiter">{</a>
      case Failure<span class="delimiter">(</span><span title="Throwable">t</span><span class="delimiter">)</span> =&gt; try <a href="#scala.concurrent;Future.recoverWith.pf" title="PartialFunction[Throwable,scala.concurrent.Future[U]]">pf</a>.<a href="../PartialFunction.scala.html#scala;PartialFunction.applyOrElse" title="(x: Throwable, default: Throwable =&gt; scala.concurrent.Future[U])scala.concurrent.Future[U]">applyOrElse</a><span class="delimiter">(</span><span title="Throwable">t</span>, <span class="delimiter">(</span>_: <span title="Throwable">Throwable</span><span class="delimiter">)</span> =&gt; this<span class="delimiter">)</span>.<a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[U] =&gt; scala.concurrent.Promise[U])(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a><span class="delimiter">(</span><a href="#scala.concurrent;Future.recoverWith.p" title="scala.concurrent.Promise[U]">p</a>.<a href="Promise.scala.html#scala.concurrent;Promise.complete" title="(result: scala.util.Try[U])p.type">complete</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.concurrent;Future.internalExecutor" title="=&gt; scala.concurrent.Future.InternalCallbackExecutor.type">internalExecutor</a><span class="delimiter">)</span> catch <span class="delimiter">{</span> case <a href="../util/control/NonFatal.scala.html#scala.util.control.NonFatal.unapply" title="(t: Throwable)Option[Throwable]">NonFatal</a><span class="delimiter">(</span><span title="Throwable">t</span><span class="delimiter">)</span> =&gt; <a href="#scala.concurrent;Future.recoverWith.p" title="scala.concurrent.Promise[U]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.failure" title="(cause: Throwable)p.type">failure</a> <span title="Throwable">t</span> <span class="delimiter">}</span>
      case <a title="scala.util.Try[T]" id="scala.concurrent;Future.recoverWith.$anonfun.other">other</a> =&gt; <a href="#scala.concurrent;Future.recoverWith.p" title="scala.concurrent.Promise[U]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.complete" title="(result: scala.util.Try[U])p.type">complete</a> <a href="#scala.concurrent;Future.recoverWith.$anonfun.other" title="scala.util.Try[T]">other</a>
    <span class="delimiter">}</span>
    <a href="#scala.concurrent;Future.recoverWith.p" title="scala.concurrent.Promise[U]">p</a>.<a href="Promise.scala.html#scala.concurrent;Promise.future" title="=&gt; scala.concurrent.Future[U]">future</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Zips the values of `this` and `that` future, and creates
   *  a new future holding the tuple of their results.
   *
   *  If `this` future fails, the resulting future is failed
   *  with the throwable stored in `this`.
   *  Otherwise, if `that` future fails, the resulting future is failed
   *  with the throwable stored in `that`.
   */</span>
  def <a title="[U](that: scala.concurrent.Future[U])scala.concurrent.Future[(T, U)]" id="scala.concurrent;Future.zip">zip</a><span class="delimiter">[</span><a title="" id="scala.concurrent;Future.zip;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.concurrent.Future[U]" id="scala.concurrent;Future.zip.that">that</a>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[U]">Future</a><span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[(T, U)]">Future</a><span class="delimiter">[</span><span class="delimiter">(</span>T, U<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    implicit val <a title="scala.concurrent.Future.InternalCallbackExecutor.type" id="scala.concurrent;Future.zip.ec">ec</a> = <a href="#scala.concurrent;Future.internalExecutor" title="=&gt; scala.concurrent.Future.InternalCallbackExecutor.type">internalExecutor</a>
    val <a title="scala.concurrent.Promise[(T, U)]" id="scala.concurrent;Future.zip.p">p</a> = <a href="Promise.scala.html#scala.concurrent.Promise.apply" title="[T]()scala.concurrent.Promise[T]">Promise</a><span title="()scala.concurrent.Promise[(T, U)]" class="delimiter">[</span><a href="../Tuple2.scala.html#scala;Tuple2" title="(T, U)" class="delimiter">(</a>T, U<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[T] =&gt; Any)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent;Future.zip.$anonfun.x0$7" title="Any" class="delimiter">{</a>
      case <a title="scala.util.Failure[_]" id="scala.concurrent;Future.zip.$anonfun.f">f</a>: <a href="../util/Try.scala.html#scala.util;Failure" title="scala.util.Failure[_]">Failure</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <a href="#scala.concurrent;Future.zip.p" title="scala.concurrent.Promise[(T, U)]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.complete" title="(result: scala.util.Try[(T, U)])p.type">complete</a> <a href="#scala.concurrent;Future.zip.$anonfun.f" title="scala.util.Failure[_]">f</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.util.Failure[(T, U)]" class="delimiter">[</span><a href="../util/Try.scala.html#scala.util;Failure" title="scala.util.Failure[(T, U)]">Failure</a><span class="delimiter">[</span><span class="delimiter">(</span>T, U<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span>
      case Success<span class="delimiter">(</span><a title="T" id="scala.concurrent;Future.zip.$anonfun.s">s</a><span class="delimiter">)</span> =&gt; <a href="#scala.concurrent;Future.zip.that" title="scala.concurrent.Future[U]">that</a> <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[U] =&gt; scala.concurrent.Promise[(T, U)])(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <span class="delimiter">{</span> <a title="scala.util.Try[U]" id="scala.concurrent;Future.zip.$anonfun.$anonfun.c">c</a> =&gt; <a href="#scala.concurrent;Future.zip.p" title="scala.concurrent.Promise[(T, U)]">p</a>.<a href="Promise.scala.html#scala.concurrent;Promise.complete" title="(result: scala.util.Try[(T, U)])p.type">complete</a><span class="delimiter">(</span><a href="#scala.concurrent;Future.zip.$anonfun.$anonfun.c" title="scala.util.Try[U]">c</a> <a href="../util/Try.scala.html#scala.util;Try.map" title="(f: U =&gt; (T, U))scala.util.Try[(T, U)]">map</a> <span class="delimiter">{</span> <a title="U" id="scala.concurrent;Future.zip.$anonfun.$anonfun.$anonfun.s2">s2</a> =&gt; <a href="../Tuple2.scala.html#scala;Tuple2" title="(_1: T, _2: U)(T, U)" class="delimiter">(</a><a href="#scala.concurrent;Future.zip.$anonfun.s" title="T">s</a>, <a href="#scala.concurrent;Future.zip.$anonfun.$anonfun.$anonfun.s2" title="U">s2</a><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#scala.concurrent;Future.zip.p" title="scala.concurrent.Promise[(T, U)]">p</a>.<a href="Promise.scala.html#scala.concurrent;Promise.future" title="=&gt; scala.concurrent.Future[(T, U)]">future</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Creates a new future which holds the result of this future if it was completed successfully, or, if not,
   *  the result of the `that` future if `that` is completed successfully.
   *  If both futures are failed, the resulting future holds the throwable object of the first future.
   *
   *  Using this method will not cause concurrent programs to become nondeterministic.
   *
   *  Example:
   *  {{{
   *  val f = Future { sys.error(&quot;failed&quot;) }
   *  val g = Future { 5 }
   *  val h = f fallbackTo g
   *  Await.result(h, Duration.Zero) // evaluates to 5
   *  }}}
   */</span>
  def <a title="[U &gt;: T](that: scala.concurrent.Future[U])scala.concurrent.Future[U]" id="scala.concurrent;Future.fallbackTo">fallbackTo</a><span class="delimiter">[</span><a title=" &gt;: T" id="scala.concurrent;Future.fallbackTo;U">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.concurrent.Future[U]" id="scala.concurrent;Future.fallbackTo.that">that</a>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[U]">Future</a><span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[U]">Future</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <span class="delimiter">{</span>
    implicit val <a title="scala.concurrent.Future.InternalCallbackExecutor.type" id="scala.concurrent;Future.fallbackTo.ec">ec</a> = <a href="#scala.concurrent;Future.internalExecutor" title="=&gt; scala.concurrent.Future.InternalCallbackExecutor.type">internalExecutor</a>
    val <a title="scala.concurrent.Promise[U]" id="scala.concurrent;Future.fallbackTo.p">p</a> = <a href="Promise.scala.html#scala.concurrent.Promise.apply" title="[T]()scala.concurrent.Promise[T]">Promise</a><span title="()scala.concurrent.Promise[U]" class="delimiter">[</span><a href="#scala.concurrent;Future.fallbackTo;U" title="U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[T] =&gt; Any)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent;Future.fallbackTo.$anonfun.x0$8" title="Any" class="delimiter">{</a>
      case <a title="scala.util.Success[T]" id="scala.concurrent;Future.fallbackTo.$anonfun.s">s</a> @ Success<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scala.concurrent;Future.fallbackTo.p" title="scala.concurrent.Promise[U]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.complete" title="(result: scala.util.Try[U])p.type">complete</a> <a href="#scala.concurrent;Future.fallbackTo.$anonfun.s" title="scala.util.Success[T]">s</a>
      case <a title="scala.util.Failure[T]" id="scala.concurrent;Future.fallbackTo.$anonfun.f">f</a> @ Failure<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scala.concurrent;Future.fallbackTo.that" title="scala.concurrent.Future[U]">that</a> <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[U] =&gt; scala.concurrent.Promise[U])(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent;Future.fallbackTo.$anonfun.$anonfun.x0$9" title="p.type" class="delimiter">{</a>
        case <a title="scala.util.Success[U]" id="scala.concurrent;Future.fallbackTo.$anonfun.$anonfun.s2">s2</a> @ Success<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scala.concurrent;Future.fallbackTo.p" title="scala.concurrent.Promise[U]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.complete" title="(result: scala.util.Try[U])p.type">complete</a> <a href="#scala.concurrent;Future.fallbackTo.$anonfun.$anonfun.s2" title="scala.util.Success[U]">s2</a>
        case _ =&gt; <a href="#scala.concurrent;Future.fallbackTo.p" title="scala.concurrent.Promise[U]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.complete" title="(result: scala.util.Try[U])p.type">complete</a> <a href="#scala.concurrent;Future.fallbackTo.$anonfun.f" title="scala.util.Failure[T]">f</a> <span class="comment">// Use the first failure as the failure</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#scala.concurrent;Future.fallbackTo.p" title="scala.concurrent.Promise[U]">p</a>.<a href="Promise.scala.html#scala.concurrent;Promise.future" title="=&gt; scala.concurrent.Future[U]">future</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Creates a new `Future[S]` which is completed with this `Future`'s result if
   *  that conforms to `S`'s erased type or a `ClassCastException` otherwise.
   */</span>
  def <a title="[S](implicit tag: scala.reflect.ClassTag[S])scala.concurrent.Future[S]" id="scala.concurrent;Future.mapTo">mapTo</a><span class="delimiter">[</span><a title="" id="scala.concurrent;Future.mapTo;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="scala.reflect.ClassTag[S]" id="scala.concurrent;Future.mapTo.tag">tag</a>: <a href="../reflect/ClassTag.scala.html#scala.reflect;ClassTag" title="scala.reflect.ClassTag[S]">ClassTag</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[S]">Future</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = <span class="delimiter">{</span>
    implicit val <a title="scala.concurrent.Future.InternalCallbackExecutor.type" id="scala.concurrent;Future.mapTo.ec">ec</a> = <a href="#scala.concurrent;Future.internalExecutor" title="=&gt; scala.concurrent.Future.InternalCallbackExecutor.type">internalExecutor</a>
    val <a title="Class[_]" id="scala.concurrent;Future.mapTo.boxedClass">boxedClass</a> = <span class="delimiter">{</span>
      val <a title="Class[_]" id="scala.concurrent;Future.mapTo.boxedClass.c">c</a> = <a href="#scala.concurrent;Future.mapTo.tag" title="scala.reflect.ClassTag[S]">tag</a>.<a href="../reflect/ClassTag.scala.html#scala.reflect;ClassTag.runtimeClass" title="=&gt; Class[_]">runtimeClass</a>
      if <span class="delimiter">(</span><a href="#scala.concurrent;Future.mapTo.boxedClass.c" title="Class[_]">c</a>.<span title="()Boolean">isPrimitive</span><span class="delimiter">)</span> <a href="#scala.concurrent.Future" title="scala.concurrent.Future.type">Future</a>.<a href="../collection/MapLike.scala.html#scala.collection;MapLike.apply" title="(key: Class[_])Class[_]">toBoxed</a><span class="delimiter">(</span><a href="#scala.concurrent;Future.mapTo.boxedClass.c" title="Class[_]">c</a><span class="delimiter">)</span> else <a href="#scala.concurrent;Future.mapTo.boxedClass.c" title="Class[_]">c</a>
    <span class="delimiter">}</span>
    <a href="../Predef.scala.html#scala.Predef.require(58bb2a7169)" title="(requirement: Boolean)Unit">require</a><span class="delimiter">(</span><a href="#scala.concurrent;Future.mapTo.boxedClass" title="Class[_]">boxedClass</a> <span title="(x$1: AnyRef)Boolean">ne</span> null<span class="delimiter">)</span>
    <a href="#scala.concurrent;Future.map" title="(f: T =&gt; S)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[S]">map</a><a href="#scala.concurrent;Future.mapTo.ec" title="scala.concurrent.Future.InternalCallbackExecutor.type" class="delimiter">(</a><a title="T" id="scala.concurrent;Future.mapTo.$anonfun.s">s</a> =&gt; <a href="#scala.concurrent;Future.mapTo.boxedClass" title="Class[_]">boxedClass</a>.<span title="(x$1: Any)_$2">cast</span><span class="delimiter">(</span><a href="#scala.concurrent;Future.mapTo.$anonfun.s" title="T">s</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="S" class="delimiter">[</span><a href="#scala.concurrent;Future.mapTo;S" title="S">S</a><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Applies the side-effecting function to the result of this future, and returns
   *  a new future with the result of this future.
   *
   *  This method allows one to enforce that the callbacks are executed in a
   *  specified order.
   *
   *  Note that if one of the chained `andThen` callbacks throws
   *  an exception, that exception is not propagated to the subsequent `andThen`
   *  callbacks. Instead, the subsequent `andThen` callbacks are given the original
   *  value of this future.
   *
   *  The following example prints out `5`:
   *
   *  {{{
   *  val f = Future { 5 }
   *  f andThen {
   *    case r =&gt; sys.error(&quot;runtime exception&quot;)
   *  } andThen {
   *    case Failure(t) =&gt; println(t)
   *    case Success(v) =&gt; println(v)
   *  }
   *  }}}
   */</span>
  def <a title="[U](pf: PartialFunction[scala.util.Try[T],U])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[T]" id="scala.concurrent;Future.andThen">andThen</a><span class="delimiter">[</span><a title="" id="scala.concurrent;Future.andThen;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[scala.util.Try[T],U]" id="scala.concurrent;Future.andThen.pf">pf</a>: <a href="../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[scala.util.Try[T],U]">PartialFunction</a><span class="delimiter">[</span>Try<span class="delimiter">[</span>T<span class="delimiter">]</span>, U<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent;Future.andThen.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[T]">Future</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scala.concurrent.Promise[T]" id="scala.concurrent;Future.andThen.p">p</a> = <a href="Promise.scala.html#scala.concurrent.Promise.apply" title="[T]()scala.concurrent.Promise[T]">Promise</a><span title="()scala.concurrent.Promise[T]" class="delimiter">[</span><a href="#scala.concurrent;Future;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[T] =&gt; Any)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent;Future.andThen.$anonfun.x0$10" title="Any" class="delimiter">{</a>
      case <a title="scala.util.Try[T]" id="scala.concurrent;Future.andThen.$anonfun.r">r</a> =&gt; try <a href="#scala.concurrent;Future.andThen.pf" title="PartialFunction[scala.util.Try[T],U]">pf</a>.<a href="../PartialFunction.scala.html#scala;PartialFunction.applyOrElse" title="[A1 &lt;: scala.util.Try[T], B1 &gt;: U](x: A1, default: A1 =&gt; B1)B1">applyOrElse</a><span title="(x: scala.util.Try[T], default: scala.util.Try[T] =&gt; Any)Any" class="delimiter">[</span><a href="../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.concurrent;Future.andThen.$anonfun.r" title="scala.util.Try[T]">r</a>, <a href="../Predef.scala.html#scala.Predef" title="type">Predef</a>.<a href="../Predef.scala.html#scala.Predef.conforms" title="[A]=&gt; &lt;:&lt;[A,A]">conforms</a><span title="&lt;:&lt;[scala.util.Try[T],scala.util.Try[T]]" class="delimiter">[</span><a href="../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> finally <a href="#scala.concurrent;Future.andThen.p" title="scala.concurrent.Promise[T]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.complete" title="(result: scala.util.Try[T])p.type">complete</a> <a href="#scala.concurrent;Future.andThen.$anonfun.r" title="scala.util.Try[T]">r</a>
    <span class="delimiter">}</span>
    <a href="#scala.concurrent;Future.andThen.p" title="scala.concurrent.Promise[T]">p</a>.<a href="Promise.scala.html#scala.concurrent;Promise.future" title="=&gt; scala.concurrent.Future[T]">future</a>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>



<span class="comment">/** Future companion object.
 *
 *  @define nonDeterministic
 *  Note: using this method yields nondeterministic dataflow programs.
 */</span>
object <a title="scala.concurrent.Future.type" id="scala.concurrent.Future">Future</a> <a href="#scala.concurrent.Future" title="scala.concurrent.Future.type" class="delimiter">{</a>

  private<span class="delimiter">[</span>concurrent<span class="delimiter">]</span> val <a title="scala.collection.immutable.Map[Class[_],Class[_]]" id="scala.concurrent.Future.toBoxed">toBoxed</a> = <a href="../collection/generic/GenMapFactory.scala.html#scala.collection.generic;GenMapFactory.apply" title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</a><span title="(elems: (Class[_], Class[_])*)scala.collection.immutable.Map[Class[_],Class[_]]" class="delimiter">[</span><span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span>, <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>
    classOf<a href="../Predef.scala.html#scala.Predef.ArrowAssoc(fefc64a42a)" title="(self: Class[Boolean])ArrowAssoc[Class[Boolean]]" class="delimiter">[</a>Boolean<span class="delimiter">]</span> <a href="../Predef.scala.html#scala.Predef;ArrowAssoc.->" title="(y: Class[Boolean])(Class[Boolean], Class[Boolean])">-&gt;</a> classOf<span title="Class[Boolean](classOf[java.lang.Boolean])" class="delimiter">[</span>java.lang.Boolean<span class="delimiter">]</span>,
    classOf<a href="../Predef.scala.html#scala.Predef.ArrowAssoc(fefc64a42a)" title="(self: Class[Byte])ArrowAssoc[Class[Byte]]" class="delimiter">[</a>Byte<span class="delimiter">]</span>    <a href="../Predef.scala.html#scala.Predef;ArrowAssoc.->" title="(y: Class[Byte])(Class[Byte], Class[Byte])">-&gt;</a> classOf<span title="Class[Byte](classOf[java.lang.Byte])" class="delimiter">[</span>java.lang.Byte<span class="delimiter">]</span>,
    classOf<a href="../Predef.scala.html#scala.Predef.ArrowAssoc(fefc64a42a)" title="(self: Class[Char])ArrowAssoc[Class[Char]]" class="delimiter">[</a>Char<span class="delimiter">]</span>    <a href="../Predef.scala.html#scala.Predef;ArrowAssoc.->" title="(y: Class[Character])(Class[Char], Class[Character])">-&gt;</a> classOf<span title="Class[Character](classOf[java.lang.Character])" class="delimiter">[</span>java.lang.Character<span class="delimiter">]</span>,
    classOf<a href="../Predef.scala.html#scala.Predef.ArrowAssoc(fefc64a42a)" title="(self: Class[Short])ArrowAssoc[Class[Short]]" class="delimiter">[</a>Short<span class="delimiter">]</span>   <a href="../Predef.scala.html#scala.Predef;ArrowAssoc.->" title="(y: Class[Short])(Class[Short], Class[Short])">-&gt;</a> classOf<span title="Class[Short](classOf[java.lang.Short])" class="delimiter">[</span>java.lang.Short<span class="delimiter">]</span>,
    classOf<a href="../Predef.scala.html#scala.Predef.ArrowAssoc(fefc64a42a)" title="(self: Class[Int])ArrowAssoc[Class[Int]]" class="delimiter">[</a>Int<span class="delimiter">]</span>     <a href="../Predef.scala.html#scala.Predef;ArrowAssoc.->" title="(y: Class[Integer])(Class[Int], Class[Integer])">-&gt;</a> classOf<span title="Class[Integer](classOf[java.lang.Integer])" class="delimiter">[</span>java.lang.Integer<span class="delimiter">]</span>,
    classOf<a href="../Predef.scala.html#scala.Predef.ArrowAssoc(fefc64a42a)" title="(self: Class[Long])ArrowAssoc[Class[Long]]" class="delimiter">[</a>Long<span class="delimiter">]</span>    <a href="../Predef.scala.html#scala.Predef;ArrowAssoc.->" title="(y: Class[Long])(Class[Long], Class[Long])">-&gt;</a> classOf<span title="Class[Long](classOf[java.lang.Long])" class="delimiter">[</span>java.lang.Long<span class="delimiter">]</span>,
    classOf<a href="../Predef.scala.html#scala.Predef.ArrowAssoc(fefc64a42a)" title="(self: Class[Float])ArrowAssoc[Class[Float]]" class="delimiter">[</a>Float<span class="delimiter">]</span>   <a href="../Predef.scala.html#scala.Predef;ArrowAssoc.->" title="(y: Class[Float])(Class[Float], Class[Float])">-&gt;</a> classOf<span title="Class[Float](classOf[java.lang.Float])" class="delimiter">[</span>java.lang.Float<span class="delimiter">]</span>,
    classOf<a href="../Predef.scala.html#scala.Predef.ArrowAssoc(fefc64a42a)" title="(self: Class[Double])ArrowAssoc[Class[Double]]" class="delimiter">[</a>Double<span class="delimiter">]</span>  <a href="../Predef.scala.html#scala.Predef;ArrowAssoc.->" title="(y: Class[Double])(Class[Double], Class[Double])">-&gt;</a> classOf<span title="Class[Double](classOf[java.lang.Double])" class="delimiter">[</span>java.lang.Double<span class="delimiter">]</span>,
    classOf<a href="../Predef.scala.html#scala.Predef.ArrowAssoc(fefc64a42a)" title="(self: Class[Unit])ArrowAssoc[Class[Unit]]" class="delimiter">[</a>Unit<span class="delimiter">]</span>    <a href="../Predef.scala.html#scala.Predef;ArrowAssoc.->" title="(y: Class[scala.runtime.BoxedUnit])(Class[Unit], Class[scala.runtime.BoxedUnit])">-&gt;</a> classOf<span title="Class[scala.runtime.BoxedUnit](classOf[scala.runtime.BoxedUnit])" class="delimiter">[</span>scala.runtime.BoxedUnit<span class="delimiter">]</span>
  <span class="delimiter">)</span>

  <span class="comment">/** Creates an already completed Future with the specified exception.
   *
   *  @tparam T       the type of the value in the future
   *  @return         the newly created `Future` object
   */</span>
  def <a title="[T](exception: Throwable)scala.concurrent.Future[T]" id="scala.concurrent.Future.failed">failed</a><span class="delimiter">[</span><a title="" id="scala.concurrent.Future.failed;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Throwable" id="scala.concurrent.Future.failed.exception">exception</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[T]">Future</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Promise.scala.html#scala.concurrent.Promise" title="scala.concurrent.Promise.type">Promise</a>.<a href="Promise.scala.html#scala.concurrent.Promise.failed" title="(exception: Throwable)scala.concurrent.Promise[Nothing]">failed</a><span class="delimiter">(</span><a href="#scala.concurrent.Future.failed.exception" title="Throwable">exception</a><span class="delimiter">)</span>.<a href="Promise.scala.html#scala.concurrent;Promise.future" title="=&gt; scala.concurrent.Future[Nothing]">future</a>

  <span class="comment">/** Creates an already completed Future with the specified result.
   *
   *  @tparam T       the type of the value in the future
   *  @return         the newly created `Future` object
   */</span>
  def <a title="[T](result: T)scala.concurrent.Future[T]" id="scala.concurrent.Future.successful">successful</a><span class="delimiter">[</span><a title="" id="scala.concurrent.Future.successful;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="scala.concurrent.Future.successful.result">result</a>: <a href="#scala.concurrent.Future.successful;T" title="T">T</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[T]">Future</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Promise.scala.html#scala.concurrent.Promise" title="scala.concurrent.Promise.type">Promise</a>.<a href="Promise.scala.html#scala.concurrent.Promise.successful" title="(result: T)scala.concurrent.Promise[T]">successful</a><span class="delimiter">(</span><a href="#scala.concurrent.Future.successful.result" title="T">result</a><span class="delimiter">)</span>.<a href="Promise.scala.html#scala.concurrent;Promise.future" title="=&gt; scala.concurrent.Future[T]">future</a>

  <span class="comment">/** Creates an already completed Future with the specified result or exception.
   *
   *  @tparam T       the type of the value in the promise
   *  @return         the newly created `Future` object
   */</span>
  def <a title="[T](result: scala.util.Try[T])scala.concurrent.Future[T]" id="scala.concurrent.Future.fromTry">fromTry</a><span class="delimiter">[</span><a title="" id="scala.concurrent.Future.fromTry;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.util.Try[T]" id="scala.concurrent.Future.fromTry.result">result</a>: <a href="../util/Try.scala.html#scala.util;Try" title="scala.util.Try[T]">Try</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[T]">Future</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="Promise.scala.html#scala.concurrent.Promise" title="scala.concurrent.Promise.type">Promise</a>.<a href="Promise.scala.html#scala.concurrent.Promise.fromTry" title="(result: scala.util.Try[T])scala.concurrent.Promise[T]">fromTry</a><span class="delimiter">(</span><a href="#scala.concurrent.Future.fromTry.result" title="scala.util.Try[T]">result</a><span class="delimiter">)</span>.<a href="Promise.scala.html#scala.concurrent;Promise.future" title="=&gt; scala.concurrent.Future[T]">future</a>

  <span class="comment">/** Starts an asynchronous computation and returns a `Future` object with the result of that computation.
  *
  *  The result becomes available once the asynchronous computation is completed.
  *
  *  @tparam T       the type of the result
  *  @param body     the asychronous computation
  *  @param executor  the execution context on which the future is run
  *  @return         the `Future` holding the result of the computation
  */</span>
  def <a title="[T](body: =&gt; T)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[T]" id="scala.concurrent.Future.apply">apply</a><span class="delimiter">[</span><a title="" id="scala.concurrent.Future.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; T" id="scala.concurrent.Future.apply.body">body</a>: =&gt;T<span class="delimiter">)</span><span class="delimiter">(</span>implicit @deprecatedName<span class="delimiter">(</span><span class="symbol">'execctx</span><span class="delimiter">)</span> <a title="scala.concurrent.ExecutionContext" id="scala.concurrent.Future.apply.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[T]">Future</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = impl.<a href="impl/Future.scala.html#scala.concurrent.impl.Future.apply" title="(body: =&gt; T)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[T]">Future</a><a href="#scala.concurrent.Future.apply.executor" title="scala.concurrent.ExecutionContext" class="delimiter">(</a><a href="#scala.concurrent.Future.apply.body" title="=&gt; T">body</a><span class="delimiter">)</span>

  <span class="comment">/** Simple version of `Future.traverse`. Transforms a `TraversableOnce[Future[A]]` into a `Future[TraversableOnce[A]]`.
   *  Useful for reducing many `Future`s into a single `Future`.
   */</span>
  def <a title="[A, M[X] &lt;: TraversableOnce[X]](in: M[scala.concurrent.Future[A]])(implicit cbf: scala.collection.generic.CanBuildFrom[M[scala.concurrent.Future[A]],A,M[A]], implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[M[A]]" id="scala.concurrent.Future.sequence">sequence</a><span class="delimiter">[</span><a title="" id="scala.concurrent.Future.sequence;A">A</a>, <a title="[X] &lt;: TraversableOnce[X]" id="scala.concurrent.Future.sequence;M">M</a><span class="delimiter">[</span><a title="" id="scala.concurrent.Future.sequence;M;X">X</a><span class="delimiter">]</span> &lt;: TraversableOnce<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="M[scala.concurrent.Future[A]]" id="scala.concurrent.Future.sequence.in">in</a>: <a href="#scala.concurrent.Future.sequence;M" title="M[scala.concurrent.Future[A]]">M</a><span class="delimiter">[</span>Future<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[M[scala.concurrent.Future[A]],A,M[A]]" id="scala.concurrent.Future.sequence.cbf">cbf</a>: <a href="../collection/generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[M[scala.concurrent.Future[A]],A,M[A]]">CanBuildFrom</a><span class="delimiter">[</span>M<span class="delimiter">[</span>Future<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>, A, M<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="scala.concurrent.ExecutionContext" id="scala.concurrent.Future.sequence.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[M[A]]">Future</a><span class="delimiter">[</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#scala.concurrent.Future.sequence.in" title="M[scala.concurrent.Future[A]]">in</a>.<a href="../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.foldLeft" title="(z: scala.concurrent.Future[scala.collection.mutable.Builder[A,M[A]]])(op: (scala.concurrent.Future[scala.collection.mutable.Builder[A,M[A]]], scala.concurrent.Future[A]) =&gt; scala.concurrent.Future[scala.collection.mutable.Builder[A,M[A]]])scala.concurrent.Future[scala.collection.mutable.Builder[A,M[A]]]">foldLeft</a><span class="delimiter">(</span><a href="#scala.concurrent.Future.successful" title="(result: scala.collection.mutable.Builder[A,M[A]])scala.concurrent.Future[scala.collection.mutable.Builder[A,M[A]]]">successful</a><span class="delimiter">(</span><a href="../collection/generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom.apply(e597f0c40a)" title="(from: M[scala.concurrent.Future[A]])scala.collection.mutable.Builder[A,M[A]]">cbf</a><span class="delimiter">(</span><a href="#scala.concurrent.Future.sequence.in" title="M[scala.concurrent.Future[A]]">in</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="delimiter">(</span><a title="scala.concurrent.Future[scala.collection.mutable.Builder[A,M[A]]]" id="scala.concurrent.Future.sequence.$anonfun.fr">fr</a>, <a title="scala.concurrent.Future[A]" id="scala.concurrent.Future.sequence.$anonfun.fa">fa</a><span class="delimiter">)</span> =&gt; for <span class="delimiter">(</span><a title="scala.collection.mutable.Builder[A,M[A]]" id="scala.concurrent.Future.sequence.$anonfun.$anonfun.r">r</a> &lt;- <a href="#scala.concurrent;Future.flatMap" title="(f: scala.collection.mutable.Builder[A,M[A]] =&gt; scala.concurrent.Future[scala.collection.mutable.Builder[A,M[A]]])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[scala.collection.mutable.Builder[A,M[A]]]">fr</a>; <a title="A" id="scala.concurrent.Future.sequence.$anonfun.$anonfun.$anonfun.a">a</a> &lt;- <a href="#scala.concurrent;Future.map" title="(f: A =&gt; scala.collection.mutable.Builder[A,M[A]])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[scala.collection.mutable.Builder[A,M[A]]]">fa</a><span class="delimiter">)</span> yield <span class="delimiter">(</span><a href="#scala.concurrent.Future.sequence.$anonfun.$anonfun.r" title="scala.collection.mutable.Builder[A,M[A]]">r</a> <a href="../collection/mutable/Builder.scala.html#scala.collection.mutable;Builder.+=(f886548160)" title="(elem: A)r.type">+=</a> <a href="#scala.concurrent.Future.sequence.$anonfun.$anonfun.$anonfun.a" title="A">a</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <a href="#scala.concurrent;Future.map" title="(f: scala.collection.mutable.Builder[A,M[A]] =&gt; M[A])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[M[A]]">map</a> <span class="delimiter">(</span><a href="#scala.concurrent.Future.sequence.$anonfun.x$3" title="scala.collection.mutable.Builder[A,M[A]]">_</a>.<a href="../collection/mutable/Builder.scala.html#scala.collection.mutable;Builder.result" title="()M[A]">result</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Returns a new `Future` to the result of the first future in the list that is completed.
   */</span>
  def <a title="[T](futures: TraversableOnce[scala.concurrent.Future[T]])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[T]" id="scala.concurrent.Future.firstCompletedOf">firstCompletedOf</a><span class="delimiter">[</span><a title="" id="scala.concurrent.Future.firstCompletedOf;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="TraversableOnce[scala.concurrent.Future[T]]" id="scala.concurrent.Future.firstCompletedOf.futures">futures</a>: <a href="../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce" title="TraversableOnce[scala.concurrent.Future[T]]">TraversableOnce</a><span class="delimiter">[</span>Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent.Future.firstCompletedOf.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[T]">Future</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scala.concurrent.Promise[T]" id="scala.concurrent.Future.firstCompletedOf.p">p</a> = <a href="Promise.scala.html#scala.concurrent.Promise.apply" title="[T]()scala.concurrent.Promise[T]">Promise</a><span title="()scala.concurrent.Promise[T]" class="delimiter">[</span><a href="#scala.concurrent.Future.firstCompletedOf;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    val completeFirst: Try<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; Unit = <a href="#scala.concurrent.Future.firstCompletedOf.p" title="scala.concurrent.Promise[T]">p</a> <a href="Promise.scala.html#scala.concurrent;Promise.tryComplete" title="scala.util.Try[T] =&gt; Unit" id="scala.concurrent.Future.firstCompletedOf.completeFirst">tryComplete</a> <a href="#scala.concurrent.Future.firstCompletedOf.completeFirst.$anonfun.x$4" title="scala.util.Try[T]">_</a>
    <a href="#scala.concurrent.Future.firstCompletedOf.futures" title="TraversableOnce[scala.concurrent.Future[T]]">futures</a> <a href="../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.foreach" title="(f: scala.concurrent.Future[T] =&gt; Unit)Unit">foreach</a> <span class="delimiter">{</span> <a href="#scala.concurrent.Future.firstCompletedOf.$anonfun.x$5" title="scala.concurrent.Future[T]">_</a> <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[T] =&gt; Unit)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent.Future.firstCompletedOf.completeFirst" title="scala.util.Try[T] =&gt; Unit">completeFirst</a> <span class="delimiter">}</span>
    <a href="#scala.concurrent.Future.firstCompletedOf.p" title="scala.concurrent.Promise[T]">p</a>.<a href="Promise.scala.html#scala.concurrent;Promise.future" title="=&gt; scala.concurrent.Future[T]">future</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Returns a `Future` that will hold the optional result of the first `Future` with a result that matches the predicate.
   */</span>
  def <a title="[T](futures: TraversableOnce[scala.concurrent.Future[T]])(p: T =&gt; Boolean)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[Option[T]]" id="scala.concurrent.Future.find">find</a><span class="delimiter">[</span><a title="" id="scala.concurrent.Future.find;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span>@deprecatedName<span class="delimiter">(</span><span class="symbol">'futurestravonce</span><span class="delimiter">)</span> <a title="TraversableOnce[scala.concurrent.Future[T]]" id="scala.concurrent.Future.find.futures">futures</a>: <a href="../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce" title="TraversableOnce[scala.concurrent.Future[T]]">TraversableOnce</a><span class="delimiter">[</span>Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>@deprecatedName<span class="delimiter">(</span><span class="symbol">'predicate</span><span class="delimiter">)</span> <a title="T =&gt; Boolean" id="scala.concurrent.Future.find.p">p</a>: T =&gt; Boolean<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent.Future.find.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[Option[T]]">Future</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scala.collection.mutable.Buffer[scala.concurrent.Future[T]]" id="scala.concurrent.Future.find.futuresBuffer">futuresBuffer</a> = <a href="#scala.concurrent.Future.find.futures" title="TraversableOnce[scala.concurrent.Future[T]]">futures</a>.<a href="../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toBuffer" title="scala.collection.mutable.Buffer[scala.concurrent.Future[T]]">toBuffer</a>
    if <span class="delimiter">(</span><a href="#scala.concurrent.Future.find.futuresBuffer" title="scala.collection.mutable.Buffer[scala.concurrent.Future[T]]">futuresBuffer</a>.<a href="../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.concurrent.Future.successful" title="[T](result: T)scala.concurrent.Future[T]">successful</a><span title="(result: Option[T])scala.concurrent.Future[Option[T]]" class="delimiter">[</span><a href="../Option.scala.html#scala;Option" title="Option[T]">Option</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="../Option.scala.html#scala.None" title="None.type">None</a><span class="delimiter">)</span>
    else <span class="delimiter">{</span>
      val <a title="scala.concurrent.Promise[Option[T]]" id="scala.concurrent.Future.find.result">result</a> = <a href="Promise.scala.html#scala.concurrent.Promise.apply" title="[T]()scala.concurrent.Promise[T]">Promise</a><span title="()scala.concurrent.Promise[Option[T]]" class="delimiter">[</span><a href="../Option.scala.html#scala;Option" title="Option[T]">Option</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
      val <a title="java.util.concurrent.atomic.AtomicInteger" id="scala.concurrent.Future.find.ref">ref</a> = new <span title="java.util.concurrent.atomic.AtomicInteger">AtomicInteger</span><span class="delimiter">(</span><a href="#scala.concurrent.Future.find.futuresBuffer" title="scala.collection.mutable.Buffer[scala.concurrent.Future[T]]">futuresBuffer</a>.<a href="../collection/SeqLike.scala.html#scala.collection;SeqLike.size" title="=&gt; Int">size</a><span class="delimiter">)</span>
      val <a title="scala.util.Try[T] =&gt; Unit" id="scala.concurrent.Future.find.search">search</a>: Try<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; Unit = <a title="scala.util.Try[T]" id="scala.concurrent.Future.find.search.$anonfun.v">v</a> =&gt; try <span class="delimiter">{</span>
        <a href="#scala.concurrent.Future.find.search.$anonfun.v" title="scala.util.Try[T]">v</a> match <span class="delimiter">{</span>
          case Success<span class="delimiter">(</span><a title="T" id="scala.concurrent.Future.find.search.$anonfun.r">r</a><span class="delimiter">)</span> if <a href="../Function1.scala.html#scala;Function1.apply" title="(v1: T)Boolean">p</a><span class="delimiter">(</span><a href="#scala.concurrent.Future.find.search.$anonfun.r" title="T">r</a><span class="delimiter">)</span> =&gt; <a href="#scala.concurrent.Future.find.result" title="scala.concurrent.Promise[Option[T]]">result</a> <a href="Promise.scala.html#scala.concurrent;Promise.tryComplete" title="(result: scala.util.Try[Option[T]])Boolean">tryComplete</a> <a href="../util/Try.scala.html#scala.util;Success" title="(value: Some[T])scala.util.Success[Some[T]]">Success</a><span class="delimiter">(</span><a href="../Option.scala.html#scala;Some" title="(x: T)Some[T]">Some</a><span class="delimiter">(</span><a href="#scala.concurrent.Future.find.search.$anonfun.r" title="T">r</a><span class="delimiter">)</span><span class="delimiter">)</span>
          case _ =&gt;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> finally <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#scala.concurrent.Future.find.ref" title="java.util.concurrent.atomic.AtomicInteger">ref</a>.<span title="()Int">decrementAndGet</span> <a href="../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#scala.concurrent.Future.find.result" title="scala.concurrent.Promise[Option[T]]">result</a> <a href="Promise.scala.html#scala.concurrent;Promise.tryComplete" title="(result: scala.util.Try[Option[T]])Boolean">tryComplete</a> <a href="../util/Try.scala.html#scala.util;Success" title="(value: None.type)scala.util.Success[None.type]">Success</a><span class="delimiter">(</span><a href="../Option.scala.html#scala.None" title="None.type">None</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#scala.concurrent.Future.find.futuresBuffer" title="scala.collection.mutable.Buffer[scala.concurrent.Future[T]]">futuresBuffer</a>.<a href="../collection/IterableLike.scala.html#scala.collection;IterableLike.foreach" title="(f: scala.concurrent.Future[T] =&gt; Unit)Unit">foreach</a><span class="delimiter">(</span><a href="#scala.concurrent.Future.find.$anonfun.x$6" title="scala.concurrent.Future[T]">_</a> <a href="#scala.concurrent;Future.onComplete" title="(f: scala.util.Try[T] =&gt; Unit)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <a href="#scala.concurrent.Future.find.search" title="scala.util.Try[T] =&gt; Unit">search</a><span class="delimiter">)</span>

      <a href="#scala.concurrent.Future.find.result" title="scala.concurrent.Promise[Option[T]]">result</a>.<a href="Promise.scala.html#scala.concurrent;Promise.future" title="=&gt; scala.concurrent.Future[Option[T]]">future</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A non-blocking fold over the specified futures, with the start value of the given zero.
   *  The fold is performed on the thread where the last future is completed,
   *  the result will be the first failure of any of the futures, or any failure in the actual fold,
   *  or the result of the fold.
   *
   *  Example:
   *  {{{
   *    val result = Await.result(Future.fold(futures)(0)(_ + _), 5 seconds)
   *  }}}
   */</span>
  def <a title="[T, R](futures: TraversableOnce[scala.concurrent.Future[T]])(zero: R)(op: (R, T) =&gt; R)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[R]" id="scala.concurrent.Future.fold">fold</a><span class="delimiter">[</span><a title="" id="scala.concurrent.Future.fold;T">T</a>, <a title="" id="scala.concurrent.Future.fold;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="TraversableOnce[scala.concurrent.Future[T]]" id="scala.concurrent.Future.fold.futures">futures</a>: <a href="../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce" title="TraversableOnce[scala.concurrent.Future[T]]">TraversableOnce</a><span class="delimiter">[</span>Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="R" id="scala.concurrent.Future.fold.zero">zero</a>: <a href="#scala.concurrent.Future.fold;R" title="R">R</a><span class="delimiter">)</span><span class="delimiter">(</span>@deprecatedName<span class="delimiter">(</span><span class="symbol">'foldFun</span><span class="delimiter">)</span> <a title="(R, T) =&gt; R" id="scala.concurrent.Future.fold.op">op</a>: <span class="delimiter">(</span>R, T<span class="delimiter">)</span> =&gt; R<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent.Future.fold.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[R]">Future</a><span class="delimiter">[</span>R<span class="delimiter">]</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#scala.concurrent.Future.fold.futures" title="TraversableOnce[scala.concurrent.Future[T]]">futures</a>.<a href="../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.concurrent.Future.successful" title="(result: R)scala.concurrent.Future[R]">successful</a><span class="delimiter">(</span><a href="#scala.concurrent.Future.fold.zero" title="R">zero</a><span class="delimiter">)</span>
    else <a href="#scala.concurrent.Future.sequence" title="(in: TraversableOnce[scala.concurrent.Future[T]])(implicit cbf: scala.collection.generic.CanBuildFrom[TraversableOnce[scala.concurrent.Future[T]],T,TraversableOnce[T]], implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[TraversableOnce[T]]">sequence</a><a href="../collection/TraversableOnce.scala.html#scala.collection.TraversableOnce.OnceCanBuildFrom" title="scala.collection.TraversableOnce.OnceCanBuildFrom[T]" class="delimiter">(</a><a href="#scala.concurrent.Future.fold.futures" title="TraversableOnce[scala.concurrent.Future[T]]">futures</a><span class="delimiter">)</span>.<a href="#scala.concurrent;Future.map" title="(f: TraversableOnce[T] =&gt; R)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[R]">map</a><a href="#scala.concurrent.Future.fold.executor" title="scala.concurrent.ExecutionContext" class="delimiter">(</a><a href="#scala.concurrent.Future.fold.$anonfun.x$7" title="TraversableOnce[T]">_</a>.<a href="../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.foldLeft" title="(z: R)(op: (R, T) =&gt; R)R">foldLeft</a><span class="delimiter">(</span><a href="#scala.concurrent.Future.fold.zero" title="R">zero</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.concurrent.Future.fold.op" title="(R, T) =&gt; R">op</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Initiates a fold over the supplied futures where the fold-zero is the result value of the `Future` that's completed first.
   *
   *  Example:
   *  {{{
   *    val result = Await.result(Future.reduce(futures)(_ + _), 5 seconds)
   *  }}}
   */</span>
  def <a title="[T, R &gt;: T](futures: TraversableOnce[scala.concurrent.Future[T]])(op: (R, T) =&gt; R)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[R]" id="scala.concurrent.Future.reduce">reduce</a><span class="delimiter">[</span><a title="" id="scala.concurrent.Future.reduce;T">T</a>, <a title=" &gt;: T" id="scala.concurrent.Future.reduce;R">R</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="TraversableOnce[scala.concurrent.Future[T]]" id="scala.concurrent.Future.reduce.futures">futures</a>: <a href="../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce" title="TraversableOnce[scala.concurrent.Future[T]]">TraversableOnce</a><span class="delimiter">[</span>Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(R, T) =&gt; R" id="scala.concurrent.Future.reduce.op">op</a>: <span class="delimiter">(</span>R, T<span class="delimiter">)</span> =&gt; R<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="scala.concurrent.Future.reduce.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[R]">Future</a><span class="delimiter">[</span>R<span class="delimiter">]</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#scala.concurrent.Future.reduce.futures" title="TraversableOnce[scala.concurrent.Future[T]]">futures</a>.<a href="../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.concurrent.Future.failed" title="(exception: Throwable)scala.concurrent.Future[Nothing]">failed</a><span class="delimiter">(</span>new <a href="../package.scala.html#scala.package;NoSuchElementException" title="java.util.NoSuchElementException">NoSuchElementException</a><span class="delimiter">(</span><span title="String(&quot;reduce attempted on empty collection&quot;)" class="string">&quot;reduce attempted on empty collection&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    else <a href="#scala.concurrent.Future.sequence" title="(in: TraversableOnce[scala.concurrent.Future[T]])(implicit cbf: scala.collection.generic.CanBuildFrom[TraversableOnce[scala.concurrent.Future[T]],T,TraversableOnce[T]], implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[TraversableOnce[T]]">sequence</a><a href="../collection/TraversableOnce.scala.html#scala.collection.TraversableOnce.OnceCanBuildFrom" title="scala.collection.TraversableOnce.OnceCanBuildFrom[T]" class="delimiter">(</a><a href="#scala.concurrent.Future.reduce.futures" title="TraversableOnce[scala.concurrent.Future[T]]">futures</a><span class="delimiter">)</span>.<a href="#scala.concurrent;Future.map" title="(f: TraversableOnce[T] =&gt; R)(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[R]">map</a><a href="#scala.concurrent.Future.reduce.executor" title="scala.concurrent.ExecutionContext" class="delimiter">(</a><a href="#scala.concurrent.Future.reduce.$anonfun.x$8" title="TraversableOnce[T]">_</a> <a href="../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.reduceLeft" title="(op: (R, T) =&gt; R)R">reduceLeft</a> <a href="#scala.concurrent.Future.reduce.op" title="(R, T) =&gt; R">op</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Transforms a `TraversableOnce[A]` into a `Future[TraversableOnce[B]]` using the provided function `A =&gt; Future[B]`.
   *  This is useful for performing a parallel map. For example, to apply a function to all items of a list
   *  in parallel:
   *
   *  {{{
   *    val myFutureList = Future.traverse(myList)(x =&gt; Future(myFunc(x)))
   *  }}}
   */</span>
  def <a title="[A, B, M[X] &lt;: TraversableOnce[X]](in: M[A])(fn: A =&gt; scala.concurrent.Future[B])(implicit cbf: scala.collection.generic.CanBuildFrom[M[A],B,M[B]], implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[M[B]]" id="scala.concurrent.Future.traverse">traverse</a><span class="delimiter">[</span><a title="" id="scala.concurrent.Future.traverse;A">A</a>, <a title="" id="scala.concurrent.Future.traverse;B">B</a>, <a title="[X] &lt;: TraversableOnce[X]" id="scala.concurrent.Future.traverse;M">M</a><span class="delimiter">[</span><a title="" id="scala.concurrent.Future.traverse;M;X">X</a><span class="delimiter">]</span> &lt;: TraversableOnce<span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="M[A]" id="scala.concurrent.Future.traverse.in">in</a>: <a href="#scala.concurrent.Future.traverse;M" title="M[A]">M</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scala.concurrent.Future[B]" id="scala.concurrent.Future.traverse.fn">fn</a>: A =&gt; Future<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.collection.generic.CanBuildFrom[M[A],B,M[B]]" id="scala.concurrent.Future.traverse.cbf">cbf</a>: <a href="../collection/generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom" title="scala.collection.generic.CanBuildFrom[M[A],B,M[B]]">CanBuildFrom</a><span class="delimiter">[</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span>, B, M<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="scala.concurrent.ExecutionContext" id="scala.concurrent.Future.traverse.executor">executor</a>: <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a><span class="delimiter">)</span>: <a href="#scala.concurrent;Future" title="scala.concurrent.Future[M[B]]">Future</a><span class="delimiter">[</span>M<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#scala.concurrent.Future.traverse.in" title="M[A]">in</a>.<a href="../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.foldLeft" title="(z: scala.concurrent.Future[scala.collection.mutable.Builder[B,M[B]]])(op: (scala.concurrent.Future[scala.collection.mutable.Builder[B,M[B]]], A) =&gt; scala.concurrent.Future[scala.collection.mutable.Builder[B,M[B]]])scala.concurrent.Future[scala.collection.mutable.Builder[B,M[B]]]">foldLeft</a><span class="delimiter">(</span><a href="#scala.concurrent.Future.successful" title="(result: scala.collection.mutable.Builder[B,M[B]])scala.concurrent.Future[scala.collection.mutable.Builder[B,M[B]]]">successful</a><span class="delimiter">(</span><a href="../collection/generic/CanBuildFrom.scala.html#scala.collection.generic;CanBuildFrom.apply(e597f0c40a)" title="(from: M[A])scala.collection.mutable.Builder[B,M[B]]">cbf</a><span class="delimiter">(</span><a href="#scala.concurrent.Future.traverse.in" title="M[A]">in</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="scala.concurrent.Future[scala.collection.mutable.Builder[B,M[B]]]" id="scala.concurrent.Future.traverse.$anonfun.fr">fr</a>, <a title="A" id="scala.concurrent.Future.traverse.$anonfun.a">a</a><span class="delimiter">)</span> =&gt;
      val <a title="scala.concurrent.Future[B]" id="scala.concurrent.Future.traverse.$anonfun.fb">fb</a> = <a href="../Function1.scala.html#scala;Function1.apply" title="(v1: A)scala.concurrent.Future[B]">fn</a><span class="delimiter">(</span><a href="#scala.concurrent.Future.traverse.$anonfun.a" title="A">a</a><span class="delimiter">)</span>
      for <span class="delimiter">(</span><a title="scala.collection.mutable.Builder[B,M[B]]" id="scala.concurrent.Future.traverse.$anonfun.$anonfun.r">r</a> &lt;- <a href="#scala.concurrent;Future.flatMap" title="(f: scala.collection.mutable.Builder[B,M[B]] =&gt; scala.concurrent.Future[scala.collection.mutable.Builder[B,M[B]]])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[scala.collection.mutable.Builder[B,M[B]]]">fr</a>; <a title="B" id="scala.concurrent.Future.traverse.$anonfun.$anonfun.$anonfun.b">b</a> &lt;- <a href="#scala.concurrent;Future.map" title="(f: B =&gt; scala.collection.mutable.Builder[B,M[B]])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[scala.collection.mutable.Builder[B,M[B]]]">fb</a><span class="delimiter">)</span> yield <span class="delimiter">(</span><a href="#scala.concurrent.Future.traverse.$anonfun.$anonfun.r" title="scala.collection.mutable.Builder[B,M[B]]">r</a> <a href="../collection/mutable/Builder.scala.html#scala.collection.mutable;Builder.+=(f886548160)" title="(elem: B)r.type">+=</a> <a href="#scala.concurrent.Future.traverse.$anonfun.$anonfun.$anonfun.b" title="B">b</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>.<a href="#scala.concurrent;Future.map" title="(f: scala.collection.mutable.Builder[B,M[B]] =&gt; M[B])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[M[B]]">map</a><a href="#scala.concurrent.Future.traverse.executor" title="scala.concurrent.ExecutionContext" class="delimiter">(</a><a href="#scala.concurrent.Future.traverse.$anonfun.x$9" title="scala.collection.mutable.Builder[B,M[B]]">_</a>.<a href="../collection/mutable/Builder.scala.html#scala.collection.mutable;Builder.result" title="()M[B]">result</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">// This is used to run callbacks which are internal</span>
  <span class="comment">// to scala.concurrent; our own callbacks are only</span>
  <span class="comment">// ever used to eventually run another callback,</span>
  <span class="comment">// and that other callback will have its own</span>
  <span class="comment">// executor because all callbacks come with</span>
  <span class="comment">// an executor. Our own callbacks never block</span>
  <span class="comment">// and have no &quot;expected&quot; exceptions.</span>
  <span class="comment">// As a result, this executor can do nothing;</span>
  <span class="comment">// some other executor will always come after</span>
  <span class="comment">// it (and sometimes one will be before it),</span>
  <span class="comment">// and those will be performing the &quot;real&quot;</span>
  <span class="comment">// dispatch to code outside scala.concurrent.</span>
  <span class="comment">// Because this exists, ExecutionContext.defaultExecutionContext</span>
  <span class="comment">// isn't instantiated by Future internals, so</span>
  <span class="comment">// if some code for some reason wants to avoid</span>
  <span class="comment">// ever starting up the default context, it can do so</span>
  <span class="comment">// by just not ever using it itself. scala.concurrent</span>
  <span class="comment">// doesn't need to create defaultExecutionContext as</span>
  <span class="comment">// a side effect.</span>
  private<span class="delimiter">[</span>concurrent<span class="delimiter">]</span> object <a title="scala.concurrent.Future.InternalCallbackExecutor.type" id="scala.concurrent.Future.InternalCallbackExecutor">InternalCallbackExecutor</a> extends <a href="ExecutionContext.scala.html#scala.concurrent;ExecutionContext" title="scala.concurrent.ExecutionContext">ExecutionContext</a> with <a href="BatchingExecutor.scala.html#scala.concurrent;BatchingExecutor" title="scala.concurrent.BatchingExecutor">BatchingExecutor</a> <span class="delimiter">{</span>
    override protected def <a title="(r: Runnable)Unit" id="scala.concurrent.Future.InternalCallbackExecutor.unbatchedExecute">unbatchedExecute</a><span class="delimiter">(</span><a title="Runnable" id="scala.concurrent.Future.InternalCallbackExecutor.unbatchedExecute.r">r</a>: <span title="Runnable">Runnable</span><span class="delimiter">)</span>: <a href="../Unit.scala.html#scala;Unit" title="Unit">Unit</a> =
      <a href="#scala.concurrent.Future.InternalCallbackExecutor.unbatchedExecute.r" title="Runnable">r</a>.<span title="()Unit">run</span><span class="delimiter">(</span><span class="delimiter">)</span>
    override def <a title="(t: Throwable)Unit" id="scala.concurrent.Future.InternalCallbackExecutor.reportFailure">reportFailure</a><span class="delimiter">(</span><a title="Throwable" id="scala.concurrent.Future.InternalCallbackExecutor.reportFailure.t">t</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span>: <a href="../Unit.scala.html#scala;Unit" title="Unit">Unit</a> =
      throw new <span title="IllegalStateException">IllegalStateException</span><span class="delimiter">(</span><span title="String(&quot;problem in scala.concurrent internal callback&quot;)" class="string">&quot;problem in scala.concurrent internal callback&quot;</span>, <a href="#scala.concurrent.Future.InternalCallbackExecutor.reportFailure.t" title="Throwable">t</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/** A marker indicating that a `java.lang.Runnable` provided to `scala.concurrent.ExecutionContext`
 * wraps a callback provided to `Future.onComplete`.
 * All callbacks provided to a `Future` end up going through `onComplete`, so this allows an
 * `ExecutionContext` to special-case callbacks that were executed by `Future` if desired.
 */</span>
trait <a title="trait OnCompleteRunnable extends AnyRef" id="scala.concurrent;OnCompleteRunnable">OnCompleteRunnable</a> <span class="delimiter">{</span>
  self: Runnable =&gt;
<span class="delimiter">}</span>


        </pre>
    </body>
</html>
