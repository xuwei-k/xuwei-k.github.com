<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/util/matching/Regex.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2007-2013, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

<span class="comment">/**
 * This package is concerned with regular expression (regex) matching against strings,
 * with the main goal of pulling out information from those matches, or replacing
 * them with something else.
 *
 * There are four classes and three objects, with most of them being members of
 * Regex companion object. [[scala.util.matching.Regex]] is the class users instantiate
 * to do regular expression matching.
 *
 * The remaining classes and objects in the package are used in the following way:
 *
 * * The companion object to [[scala.util.matching.Regex]] just contains the other members.
 * * [[scala.util.matching.Regex.Match]] makes more information about a match available.
 * * [[scala.util.matching.Regex.MatchIterator]] is used to iterate over multiple matches.
 * * [[scala.util.matching.Regex.MatchData]] is just a base trait for the above classes.
 * * [[scala.util.matching.Regex.Groups]] extracts group from a [[scala.util.matching.Regex.Match]]
 *   without recomputing the match.
 * * [[scala.util.matching.Regex.Match]] converts a [[scala.util.matching.Regex.Match]]
 *   into a [[java.lang.String]].
 *
 */</span>
package scala.util.matching

import scala.collection.AbstractIterator
import java.util.regex.<span class="delimiter">{</span> Pattern, Matcher <span class="delimiter">}</span>

<span class="comment">/** A regular expression is used to determine whether a string matches a pattern
 *  and, if it does, to extract or transform the parts that match.
 *
 *  This class delegates to the [[java.util.regex]] package of the Java Platform.
 *  See the documentation for [[java.util.regex.Pattern]] for details about
 *  the regular expression syntax for pattern strings.
 *
 *  An instance of `Regex` represents a compiled regular expression pattern.
 *  Since compilation is expensive, frequently used `Regex`es should be constructed
 *  once, outside of loops and perhaps in a companion object.
 *
 *  The canonical way to create a `Regex` is by using the method `r`, provided
 *  implicitly for strings:
 *
 *  {{{
 *  val date = &quot;&quot;&quot;(\d\d\d\d)-(\d\d)-(\d\d)&quot;&quot;&quot;.r
 *  }}}
 *
 *  Since escapes are not processed in multi-line string literals, using triple quotes
 *  avoids having to escape the backslash character, so that `&quot;\\d&quot;` can be written `&quot;&quot;&quot;\d&quot;&quot;&quot;`.
 *
 *  To extract the capturing groups when a `Regex` is matched, use it as
 *  an extractor in a pattern match:
 *
 *  {{{
 *  &quot;2004-01-20&quot; match {
 *    case date(year, month, day) =&gt; s&quot;$year was a good year for PLs.&quot;
 *  }
 *  }}}
 *
 *  To check only whether the `Regex` matches, ignoring any groups,
 *  use a sequence wildcard:
 *
 *  {{{
 *  &quot;2004-01-20&quot; match {
 *    case date(_*) =&gt; &quot;It's a date!&quot;
 *  }
 *  }}}
 *
 *  That works because a `Regex` extractor produces a sequence of strings.
 *  Extracting only the year from a date could also be expressed with
 *  a sequence wildcard:
 *
 *  {{{
 *  &quot;2004-01-20&quot; match {
 *    case date(year, _*) =&gt; s&quot;$year was a good year for PLs.&quot;
 *  }
 *  }}}
 *
 *  In a pattern match, `Regex` normally matches the entire input.
 *  However, an unanchored `Regex` finds the pattern anywhere
 *  in the input.
 *
 *  {{{
 *  val embeddedDate = date.unanchored
 *  &quot;Date: 2004-01-20 17:25:18 GMT (10 years, 28 weeks, 5 days, 17 hours and 51 minutes ago)&quot; match {
 *    case embeddedDate(&quot;2004&quot;, &quot;01&quot;, &quot;20&quot;) =&gt; &quot;A Scala is born.&quot;
 *  }
 *  }}}
 *
 *  To find or replace matches of the pattern, use the various find and replace methods.
 *  There is a flavor of each method that produces matched strings and
 *  another that produces `Match` objects.
 *
 *  For example, pattern matching with an unanchored `Regex`, as in the previous example,
 *  is the same as using `findFirstMatchIn`, except that the findFirst methods return an `Option`,
 *  or `None` for no match:
 *
 *  {{{
 *  val dates = &quot;Important dates in history: 2004-01-20, 1958-09-05, 2010-10-06, 2011-07-15&quot;
 *  val firstDate = date findFirstIn dates getOrElse &quot;No date found.&quot;
 *  val firstYear = for (m &lt;- date findFirstMatchIn dates) yield m group 1
 *  }}}
 *
 *  To find all matches:
 *
 *  {{{
 *  val allYears = for (m &lt;- date findAllMatchIn dates) yield m group 1
 *  }}}
 *
 *  But `findAllIn` returns a special iterator of strings that can be queried for the `MatchData`
 *  of the last match:
 *
 *  {{{
 *  val mi = date findAllIn dates
 *  val oldies = mi filter (_ =&gt; (mi group 1).toInt &lt; 1960) map (s =&gt; s&quot;$s: An oldie but goodie.&quot;)
 *  }}}
 *
 *  Note that `findAllIn` finds matches that don't overlap. (See [[findAllIn]] for more examples.)
 *
 *  {{{
 *  val num = &quot;&quot;&quot;(\d+)&quot;&quot;&quot;.r
 *  val all = (num findAllIn &quot;123&quot;).toList  // List(&quot;123&quot;), not List(&quot;123&quot;, &quot;23&quot;, &quot;3&quot;)
 *  }}}
 *
 *  Text replacement can be performed unconditionally or as a function of the current match:
 *
 *  {{{
 *  val redacted    = date replaceAllIn (dates, &quot;XXXX-XX-XX&quot;)
 *  val yearsOnly   = date replaceAllIn (dates, m =&gt; m group 1)
 *  val months      = (0 to 11) map { i =&gt; val c = Calendar.getInstance; c.set(2014, i, 1); f&quot;$c%tb&quot; }
 *  val reformatted = date replaceAllIn (dates, _ match { case date(y,m,d) =&gt; f&quot;${months(m.toInt - 1)} $d, $y&quot; })
 *  }}}
 *
 *  Pattern matching the `Match` against the `Regex` that created it does not reapply the `Regex`.
 *  In the expression for `reformatted`, each `date` match is computed once. But it is possible to apply a
 *  `Regex` to a `Match` resulting from a different pattern:
 *
 *  {{{
 *  val docSpree = &quot;&quot;&quot;2011(?:-\d{2}){2}&quot;&quot;&quot;.r
 *  val docView  = date replaceAllIn (dates, _ match {
 *    case docSpree() =&gt; &quot;Historic doc spree!&quot;
 *    case _          =&gt; &quot;Something else happened&quot;
 *  })
 *  }}}
 *
 *  @see [[java.util.regex.Pattern]]
 *
 *  @author  Thibaud Hottelier
 *  @author  Philipp Haller
 *  @author  Martin Odersky
 *  @version 1.1, 29/01/2008
 *
 *  @param pattern    The compiled pattern
 *  @param groupNames A mapping from names to indices in capture groups
 *
 *  @define replacementString
 *  In the replacement String, a dollar sign (`$`) followed by a number will be
 *  interpreted as a reference to a group in the matched pattern, with numbers
 *  1 through 9 corresponding to the first nine groups, and 0 standing for the
 *  whole match. Any other character is an error. The backslash (`\`) character
 *  will be interpreted as an escape character and can be used to escape the
 *  dollar sign. Use `Regex.quoteReplacement` to escape these characters.
 */</span>
@SerialVersionUID<span class="delimiter">(</span>-<span class="long">2094783597747625537L</span><span class="delimiter">)</span>
class <a title="class Regex extends AnyRef with Serializable" id="scala.util.matching;Regex">Regex</a> private<span class="delimiter">[</span>matching<span class="delimiter">]</span><span class="delimiter">(</span>val <a title="java.util.regex.Pattern" id="scala.util.matching;Regex.pattern">pattern</a>: <span title="java.util.regex.Pattern">Pattern</span>, <a title="String*" id="scala.util.matching;Regex.groupNames">groupNames</a>: <span title="String*">String</span>*<span class="delimiter">)</span> extends <a href="../../Serializable.scala.html#scala;Serializable" title="Serializable">Serializable</a> <span class="delimiter">{</span>
  outer =&gt;

  import <a href="#scala.util.matching.Regex.readResolve" title="scala.util.matching.Regex.type">Regex</a>._

  <span class="comment">/** Compile a regular expression, supplied as a string, into a pattern that
   *  can be matched against inputs.
   *
   *  If group names are supplied, they can be used this way:
   *
   *  {{{
   *  val namedDate  = new Regex(&quot;&quot;&quot;(\d\d\d\d)-(\d\d)-(\d\d)&quot;&quot;&quot;, &quot;year&quot;, &quot;month&quot;, &quot;day&quot;)
   *  val namedYears = for (m &lt;- namedDate findAllMatchIn dates) yield m group &quot;year&quot;
   *  }}}
   *
   *  This constructor does not support options as flags, which must be
   *  supplied as inline flags in the pattern string: `(?idmsux-idmsux)`.
   *
   *  @param regex      The regular expression to compile.
   *  @param groupNames Names of capturing groups.
   */</span>
  def this<span class="delimiter">(</span><a title="String" id="scala.util.matching;Regex.<init>(2294e50488).regex">regex</a>: <span title="String">String</span>, <a title="String*" id="scala.util.matching;Regex.<init>(2294e50488).groupNames">groupNames</a>: <span title="String*">String</span>*<span class="delimiter">)</span> = this<span class="delimiter">(</span><span title="java.util.regex.Pattern.type">Pattern</span>.<span title="(x$1: String)java.util.regex.Pattern">compile</span><span class="delimiter">(</span><a href="#scala.util.matching;Regex.<init>(2294e50488).regex" title="String">regex</a><span class="delimiter">)</span>, <a href="#scala.util.matching;Regex.<init>(2294e50488).groupNames" title="String*">groupNames</a>: _*<span class="delimiter">)</span>

  <span class="comment">/** Tries to match a [[java.lang.CharSequence]].
   *
   *  If the match succeeds, the result is a list of the matching
   *  groups (or a `null` element if a group did not match any input).
   *  If the pattern specifies no groups, then the result will be an empty list
   *  on a successful match.
   *
   *  This method attempts to match the entire input by default; to find the next
   *  matching subsequence, use an unanchored `Regex`.
   *
   *  For example:
   *
   *  {{{
   *  val p1 = &quot;ab*c&quot;.r
   *  val p1Matches = &quot;abbbc&quot; match {
   *    case p1() =&gt; true               // no groups
   *    case _    =&gt; false
   *  }
   *  val p2 = &quot;a(b*)c&quot;.r
   *  val p2Matches = &quot;abbbc&quot; match {
   *    case p2(_*) =&gt; true             // any groups
   *    case _      =&gt; false
   *  }
   *  val numberOfB = &quot;abbbc&quot; match {
   *    case p2(b) =&gt; Some(b.length)    // one group
   *    case _     =&gt; None
   *  }
   *  val p3 = &quot;b*&quot;.r.unanchored
   *  val p3Matches = &quot;abbbc&quot; match {
   *    case p3() =&gt; true               // find the b's
   *    case _    =&gt; false
   *  }
   *  val p4 = &quot;a(b*)(c+)&quot;.r
   *  val p4Matches = &quot;abbbcc&quot; match {
   *    case p4(_*) =&gt; true             // multiple groups
   *    case _      =&gt; false
   *  }
   *  val allGroups = &quot;abbbcc&quot; match {
   *    case p4(all @ _*) =&gt; all mkString &quot;/&quot; // &quot;bbb/cc&quot;
   *    case _            =&gt; &quot;&quot;
   *  }
   *  val cGroup = &quot;abbbcc&quot; match {
   *    case p4(_, c) =&gt; c
   *    case _        =&gt; &quot;&quot;
   *  }
   *  }}}
   *
   *  @param  s     The string to match
   *  @return       The matches
   */</span>
  def <a title="(s: CharSequence)Option[List[String]]" id="scala.util.matching;Regex.unapplySeq(e8ea5a0e04)">unapplySeq</a><span class="delimiter">(</span><a title="CharSequence" id="scala.util.matching;Regex.unapplySeq(e8ea5a0e04).s">s</a>: <span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[List[String]]">Option</a><span class="delimiter">[</span>List<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scala.util.matching;Regex.unapplySeq(e8ea5a0e04).s" title="CharSequence">s</a> match <span class="delimiter">{</span>
    case null =&gt; <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
    case _    =&gt;
      val m = <a href="#scala.util.matching;Regex.pattern" title="=&gt; java.util.regex.Pattern">pattern</a> <a title="java.util.regex.Matcher" id="scala.util.matching;Regex.unapplySeq(e8ea5a0e04).m">matcher</a> <a href="#scala.util.matching;Regex.unapplySeq(e8ea5a0e04).s" title="CharSequence">s</a>
      if <span class="delimiter">(</span><a href="#scala.util.matching;Regex.runMatcher" title="(m: java.util.regex.Matcher)Boolean">runMatcher</a><span class="delimiter">(</span><a href="#scala.util.matching;Regex.unapplySeq(e8ea5a0e04).m" title="java.util.regex.Matcher">m</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Some" title="(x: List[String])Some[List[String]]">Some</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="../../Predef.scala.html#scala;LowPriorityImplicits.intWrapper" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">1</a> <a href="../../runtime/RichInt.scala.html#scala.runtime;RichInt.to(edbf447743)" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#scala.util.matching;Regex.unapplySeq(e8ea5a0e04).m" title="java.util.regex.Matcher">m</a>.<span title="()Int">groupCount</span><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[Int]">toList</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Int =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Int],String,List[String]])List[String]">map</a> <a href="#scala.util.matching;Regex.unapplySeq(e8ea5a0e04).m" title="java.util.regex.Matcher">m</a>.<a href="#scala.util.matching;Regex.unapplySeq(e8ea5a0e04).$anonfun.x$1" title="(x$1: Int)String">group</a><span class="delimiter">)</span>
      else <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Tries to match the String representation of a [[scala.Char]].
   *
   *  If the match succeeds, the result is the first matching
   *  group if any groups are defined, or an empty Sequence otherwise.
   *
   *  For example:
   *
   *  {{{
   *  val cat = &quot;cat&quot;
   *  // the case must consume the group to match
   *  val r = &quot;&quot;&quot;(\p{Lower})&quot;&quot;&quot;.r
   *  cat(0) match { case r(x) =&gt; true }
   *  cat(0) match { case r(_) =&gt; true }
   *  cat(0) match { case r(_*) =&gt; true }
   *  cat(0) match { case r() =&gt; true }     // no match
   *
   *  // there is no group to extract
   *  val r = &quot;&quot;&quot;\p{Lower}&quot;&quot;&quot;.r
   *  cat(0) match { case r(x) =&gt; true }    // no match
   *  cat(0) match { case r(_) =&gt; true }    // no match
   *  cat(0) match { case r(_*) =&gt; true }   // matches
   *  cat(0) match { case r() =&gt; true }     // matches
   *
   *  // even if there are multiple groups, only one is returned
   *  val r = &quot;&quot;&quot;((.))&quot;&quot;&quot;.r
   *  cat(0) match { case r(_) =&gt; true }    // matches
   *  cat(0) match { case r(_,_) =&gt; true }  // no match
   *  }}}
   *
   *  @param  c     The Char to match
   *  @return       The match
   */</span>
  def <a title="(c: Char)Option[List[Char]]" id="scala.util.matching;Regex.unapplySeq(02df4c052b)">unapplySeq</a><span class="delimiter">(</span><a title="Char" id="scala.util.matching;Regex.unapplySeq(02df4c052b).c">c</a>: <a href="../../Char.scala.html#scala;Char" title="Char">Char</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[List[Char]]">Option</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    val m = <a href="#scala.util.matching;Regex.pattern" title="=&gt; java.util.regex.Pattern">pattern</a> <a title="java.util.regex.Matcher" id="scala.util.matching;Regex.unapplySeq(02df4c052b).m">matcher</a> <a href="#scala.util.matching;Regex.unapplySeq(02df4c052b).c" title="Char">c</a>.<span title="()String">toString</span>
    if <span class="delimiter">(</span><a href="#scala.util.matching;Regex.runMatcher" title="(m: java.util.regex.Matcher)Boolean">runMatcher</a><span class="delimiter">(</span><a href="#scala.util.matching;Regex.unapplySeq(02df4c052b).m" title="java.util.regex.Matcher">m</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.util.matching;Regex.unapplySeq(02df4c052b).m" title="java.util.regex.Matcher">m</a>.<span title="()Int">groupCount</span> <a href="../../Int.scala.html#scala;Int.>(5f58a84eb3)" title="(x: Int)Boolean">&gt;</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Some" title="(x: List[Char])Some[List[Char]]">Some</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.util.matching;Regex.unapplySeq(02df4c052b).m" title="java.util.regex.Matcher">m</a> <a href="../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">group</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[Char]">toList</a><span class="delimiter">)</span> else <a href="../../Option.scala.html#scala;Some" title="(x: scala.collection.immutable.Nil.type)Some[scala.collection.immutable.Nil.type]">Some</a><span class="delimiter">(</span><a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Tries to match on a [[scala.util.matching.Regex.Match]].
   *
   *  A previously failed match results in None.
   *
   *  If a successful match was made against the current pattern, then that result is used.
   *
   *  Otherwise, this Regex is applied to the previously matched input,
   *  and the result of that match is used.
   */</span>
  def <a title="(m: scala.util.matching.Regex.Match)Option[List[String]]" id="scala.util.matching;Regex.unapplySeq(19c03d2bd6)">unapplySeq</a><span class="delimiter">(</span><a title="scala.util.matching.Regex.Match" id="scala.util.matching;Regex.unapplySeq(19c03d2bd6).m">m</a>: <a href="#scala.util.matching.Regex;Match" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[List[String]]">Option</a><span class="delimiter">[</span>List<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#scala.util.matching;Regex.unapplySeq(19c03d2bd6).m" title="scala.util.matching.Regex.Match">m</a> <span title="(x$1: Any)Boolean">==</span> null <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.util.matching;Regex.unapplySeq(19c03d2bd6).m" title="scala.util.matching.Regex.Match">m</a>.<a href="#scala.util.matching.Regex;MatchData.matched" title="=&gt; String">matched</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span> <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
    else if <span class="delimiter">(</span><a href="#scala.util.matching;Regex.unapplySeq(19c03d2bd6).m" title="scala.util.matching.Regex.Match">m</a>.<a href="#scala.util.matching.Regex;Match.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()java.util.regex.Pattern">pattern</span> <span title="(x$1: Any)Boolean">==</span> this.<a href="#scala.util.matching;Regex.pattern" title="=&gt; java.util.regex.Pattern">pattern</a><span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Some" title="(x: List[String])Some[List[String]]">Some</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="../../Predef.scala.html#scala;LowPriorityImplicits.intWrapper" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">1</a> <a href="../../runtime/RichInt.scala.html#scala.runtime;RichInt.to(edbf447743)" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#scala.util.matching;Regex.unapplySeq(19c03d2bd6).m" title="scala.util.matching.Regex.Match">m</a>.<a href="#scala.util.matching.Regex;Match.groupCount" title="=&gt; Int">groupCount</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[Int]">toList</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Int =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Int],String,List[String]])List[String]">map</a> <a href="#scala.util.matching;Regex.unapplySeq(19c03d2bd6).m" title="scala.util.matching.Regex.Match">m</a>.<a href="#scala.util.matching.Regex;MatchData.group(d43c183463)" title="(i: Int)String">group</a><span class="delimiter">)</span>
    else <a href="#scala.util.matching;Regex.unapplySeq(e8ea5a0e04)" title="(s: CharSequence)Option[List[String]]">unapplySeq</a><span class="delimiter">(</span><a href="#scala.util.matching;Regex.unapplySeq(19c03d2bd6).m" title="scala.util.matching.Regex.Match">m</a>.<a href="#scala.util.matching.Regex;MatchData.matched" title="=&gt; String">matched</a><span class="delimiter">)</span>

  <span class="comment">/** Tries to match target.
   *  @param target The string to match
   *  @return       The matches
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Extracting a match result from anything but a CharSequence or Match is deprecated&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
  def <a title="(target: Any)Option[List[String]]" id="scala.util.matching;Regex.unapplySeq(7c35a79c58)">unapplySeq</a><span class="delimiter">(</span><a title="Any" id="scala.util.matching;Regex.unapplySeq(7c35a79c58).target">target</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[List[String]]">Option</a><span class="delimiter">[</span>List<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scala.util.matching;Regex.unapplySeq(7c35a79c58).target" title="Any">target</a> match <span class="delimiter">{</span>
    case <a title="CharSequence" id="scala.util.matching;Regex.unapplySeq(7c35a79c58).s">s</a>: <span title="CharSequence">CharSequence</span> =&gt;
      val m = <a href="#scala.util.matching;Regex.pattern" title="=&gt; java.util.regex.Pattern">pattern</a> <span title="java.util.regex.Matcher">matcher</span> <a href="#scala.util.matching;Regex.unapplySeq(7c35a79c58).s" title="CharSequence">s</a>
      if <span class="delimiter">(</span><a href="#scala.util.matching;Regex.runMatcher" title="(m: java.util.regex.Matcher)Boolean">runMatcher</a><span class="delimiter">(</span><span title="java.util.regex.Matcher">m</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Some" title="(x: List[String])Some[List[String]]">Some</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="../../Predef.scala.html#scala;LowPriorityImplicits.intWrapper" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">1</a> <a href="../../runtime/RichInt.scala.html#scala.runtime;RichInt.to(edbf447743)" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <span title="java.util.regex.Matcher">m</span>.<span title="()Int">groupCount</span><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[Int]">toList</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Int =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Int],String,List[String]])List[String]">map</a> <span title="java.util.regex.Matcher">m</span>.<a href="#scala.util.matching;Regex.unapplySeq(7c35a79c58).$anonfun.x$1" title="(x$1: Int)String">group</a><span class="delimiter">)</span>
      else <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
    case <span title="scala.util.matching.Regex.Match">m</span>: <a href="#scala.util.matching.Regex;Match" title="scala.util.matching.Regex.Match">Match</a> =&gt; <a href="#scala.util.matching;Regex.unapplySeq(e8ea5a0e04)" title="(s: CharSequence)Option[List[String]]">unapplySeq</a><span class="delimiter">(</span><span title="scala.util.matching.Regex.Match">m</span>.<a href="#scala.util.matching.Regex;MatchData.matched" title="=&gt; String">matched</a><span class="delimiter">)</span>
    case _ =&gt; <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
  <span class="delimiter">}</span>

  <span class="comment">//  @see UnanchoredRegex</span>
  protected def <a title="(m: java.util.regex.Matcher)Boolean" id="scala.util.matching;Regex.runMatcher">runMatcher</a><span class="delimiter">(</span><a title="java.util.regex.Matcher" id="scala.util.matching;Regex.runMatcher.m">m</a>: <span title="java.util.regex.Matcher">Matcher</span><span class="delimiter">)</span> = <a href="#scala.util.matching;Regex.runMatcher.m" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">matches</span><span class="delimiter">(</span><span class="delimiter">)</span>

  <span class="comment">/** Return all non-overlapping matches of this `Regex` in the given character 
   *  sequence as a [[scala.util.matching.Regex.MatchIterator]],
   *  which is a special [[scala.collection.Iterator]] that returns the
   *  matched strings but can also be queried for more data about the last match,
   *  such as capturing groups and start position.
   * 
   *  A `MatchIterator` can also be converted into an iterator
   *  that returns objects of type [[scala.util.matching.Regex.Match]],
   *  such as is normally returned by `findAllMatchIn`.
   * 
   *  Where potential matches overlap, the first possible match is returned,
   *  followed by the next match that follows the input consumed by the
   *  first match:
   *
   *  {{{
   *  val hat  = &quot;hat[^a]+&quot;.r
   *  val hathaway = &quot;hathatthattthatttt&quot;
   *  val hats = (hat findAllIn hathaway).toList                     // List(hath, hattth)
   *  val pos  = (hat findAllMatchIn hathaway map (_.start)).toList  // List(0, 7)
   *  }}}
   *
   *  To return overlapping matches, it is possible to formulate a regular expression
   *  with lookahead (`?=`) that does not consume the overlapping region.
   *
   *  {{{
   *  val madhatter = &quot;(h)(?=(at[^a]+))&quot;.r
   *  val madhats   = (madhatter findAllMatchIn hathaway map {
   *    case madhatter(x,y) =&gt; s&quot;$x$y&quot;
   *  }).toList                                       // List(hath, hatth, hattth, hatttt)
   *  }}}
   *
   *  Attempting to retrieve match information before performing the first match
   *  or after exhausting the iterator results in [[java.lang.IllegalStateException]].
   *  See [[scala.util.matching.Regex.MatchIterator]] for details.
   *
   *  @param source The text to match against.
   *  @return       A [[scala.util.matching.Regex.MatchIterator]] of matched substrings.
   *  @example      {{{for (words &lt;- &quot;&quot;&quot;\w+&quot;&quot;&quot;.r findAllIn &quot;A simple example.&quot;) yield words}}}
   */</span>
  def <a title="(source: CharSequence)scala.util.matching.Regex.MatchIterator" id="scala.util.matching;Regex.findAllIn">findAllIn</a><span class="delimiter">(</span><a title="CharSequence" id="scala.util.matching;Regex.findAllIn.source">source</a>: <span title="CharSequence">CharSequence</span><span class="delimiter">)</span> = new <a href="#scala.util.matching.Regex.readResolve" title="scala.util.matching.Regex.type">Regex</a>.<a href="#scala.util.matching.Regex;MatchIterator" title="scala.util.matching.Regex.MatchIterator">MatchIterator</a><span class="delimiter">(</span><a href="#scala.util.matching;Regex.findAllIn.source" title="CharSequence">source</a>, this, <a href="#scala.util.matching;Regex.groupNames" title="String*">groupNames</a><span class="delimiter">)</span>

  <span class="comment">/** Return all non-overlapping matches of this regexp in given character sequence as a
   *  [[scala.collection.Iterator]] of [[scala.util.matching.Regex.Match]].
   *
   *  @param source The text to match against.
   *  @return       A [[scala.collection.Iterator]] of [[scala.util.matching.Regex.Match]] for all matches.
   *  @example      {{{for (words &lt;- &quot;&quot;&quot;\w+&quot;&quot;&quot;.r findAllMatchIn &quot;A simple example.&quot;) yield words.start}}}
   */</span>
  def <a title="(source: CharSequence)Iterator[scala.util.matching.Regex.Match]" id="scala.util.matching;Regex.findAllMatchIn">findAllMatchIn</a><span class="delimiter">(</span><a title="CharSequence" id="scala.util.matching;Regex.findAllMatchIn.source">source</a>: <span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../collection/Iterator.scala.html#scala.collection;Iterator" title="Iterator[scala.util.matching.Regex.Match]">Iterator</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="scala.util.matching.Regex.MatchIterator" id="scala.util.matching;Regex.findAllMatchIn.matchIterator">matchIterator</a> = <a href="#scala.util.matching;Regex.findAllIn" title="(source: CharSequence)scala.util.matching.Regex.MatchIterator">findAllIn</a><span class="delimiter">(</span><a href="#scala.util.matching;Regex.findAllMatchIn.source" title="CharSequence">source</a><span class="delimiter">)</span>
    new <a title="&lt;$anon: Iterator[scala.util.matching.Regex.Match]&gt; extends AnyRef with Iterator[scala.util.matching.Regex.Match]" id="scala.util.matching;Regex.findAllMatchIn;$anon">Iterator</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="=&gt; Boolean" id="scala.util.matching;Regex.findAllMatchIn;$anon.hasNext">hasNext</a> = <a href="#scala.util.matching;Regex.findAllMatchIn.matchIterator" title="scala.util.matching.Regex.MatchIterator">matchIterator</a>.<a href="#scala.util.matching.Regex;MatchIterator.hasNext" title="=&gt; Boolean">hasNext</a>
      def <a title="()scala.util.matching.Regex.Match" id="scala.util.matching;Regex.findAllMatchIn;$anon.next">next</a>: <a href="#scala.util.matching.Regex;Match" title="scala.util.matching.Regex.Match">Match</a> = <span class="delimiter">{</span>
        <a href="#scala.util.matching;Regex.findAllMatchIn.matchIterator" title="scala.util.matching.Regex.MatchIterator">matchIterator</a>.<a href="#scala.util.matching.Regex;MatchIterator.next" title="()String">next</a><span class="delimiter">(</span><span class="delimiter">)</span>
        new <a href="#scala.util.matching.Regex;Match" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">(</span><a href="#scala.util.matching;Regex.findAllMatchIn.matchIterator" title="scala.util.matching.Regex.MatchIterator">matchIterator</a>.<a href="#scala.util.matching.Regex;MatchIterator.source" title="=&gt; CharSequence">source</a>, <a href="#scala.util.matching;Regex.findAllMatchIn.matchIterator" title="scala.util.matching.Regex.MatchIterator">matchIterator</a>.<a href="#scala.util.matching.Regex;MatchIterator.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>, <a href="#scala.util.matching;Regex.findAllMatchIn.matchIterator" title="scala.util.matching.Regex.MatchIterator">matchIterator</a>.<a href="#scala.util.matching.Regex;MatchIterator.groupNames" title="=&gt; Seq[String]">groupNames</a><span class="delimiter">)</span>.<a href="#scala.util.matching.Regex;Match.force" title="=&gt; scala.util.matching.Regex.Match">force</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Return an optional first matching string of this `Regex` in the given character sequence,
   *  or None if there is no match.
   *
   *  @param source The text to match against.
   *  @return       An [[scala.Option]] of the first matching string in the text.
   *  @example      {{{&quot;&quot;&quot;\w+&quot;&quot;&quot;.r findFirstIn &quot;A simple example.&quot; foreach println // prints &quot;A&quot;}}}
   */</span>
  def <a title="(source: CharSequence)Option[String]" id="scala.util.matching;Regex.findFirstIn">findFirstIn</a><span class="delimiter">(</span><a title="CharSequence" id="scala.util.matching;Regex.findFirstIn.source">source</a>: <span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[String]">Option</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="java.util.regex.Matcher" id="scala.util.matching;Regex.findFirstIn.m">m</a> = <a href="#scala.util.matching;Regex.pattern" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#scala.util.matching;Regex.findFirstIn.source" title="CharSequence">source</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#scala.util.matching;Regex.findFirstIn.m" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">find</span><span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Some" title="(x: String)Some[String]">Some</a><span class="delimiter">(</span><a href="#scala.util.matching;Regex.findFirstIn.m" title="java.util.regex.Matcher">m</a>.<span title="()String">group</span><span class="delimiter">)</span> else <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Return an optional first match of this `Regex` in the given character sequence,
   *  or None if it does not exist.
   *
   *  If the match is successful, the [[scala.util.matching.Regex.Match]] can be queried for
   *  more data.
   *
   *  @param source The text to match against.
   *  @return       A [[scala.Option]] of [[scala.util.matching.Regex.Match]] of the first matching string in the text.
   *  @example      {{{(&quot;&quot;&quot;[a-z]&quot;&quot;&quot;.r findFirstMatchIn &quot;A simple example.&quot;) map (_.start) // returns Some(2), the index of the first match in the text}}}
   */</span>
  def <a title="(source: CharSequence)Option[scala.util.matching.Regex.Match]" id="scala.util.matching;Regex.findFirstMatchIn">findFirstMatchIn</a><span class="delimiter">(</span><a title="CharSequence" id="scala.util.matching;Regex.findFirstMatchIn.source">source</a>: <span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[scala.util.matching.Regex.Match]">Option</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="java.util.regex.Matcher" id="scala.util.matching;Regex.findFirstMatchIn.m">m</a> = <a href="#scala.util.matching;Regex.pattern" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#scala.util.matching;Regex.findFirstMatchIn.source" title="CharSequence">source</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#scala.util.matching;Regex.findFirstMatchIn.m" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">find</span><span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Some" title="(x: scala.util.matching.Regex.Match)Some[scala.util.matching.Regex.Match]">Some</a><span class="delimiter">(</span>new <a href="#scala.util.matching.Regex;Match" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">(</span><a href="#scala.util.matching;Regex.findFirstMatchIn.source" title="CharSequence">source</a>, <a href="#scala.util.matching;Regex.findFirstMatchIn.m" title="java.util.regex.Matcher">m</a>, <a href="#scala.util.matching;Regex.groupNames" title="String*">groupNames</a><span class="delimiter">)</span><span class="delimiter">)</span> else <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Return an optional match of this `Regex` at the beginning of the
   *  given character sequence, or None if it matches no prefix
   *  of the character sequence.
   *
   *  Unlike `findFirstIn`, this method will only return a match at
   *  the beginning of the input.
   *
   *  @param source The text to match against.
   *  @return       A [[scala.Option]] of the matched prefix.
   *  @example      {{{&quot;&quot;&quot;\p{Lower}&quot;&quot;&quot;.r findPrefixOf &quot;A simple example.&quot; // returns None, since the text does not begin with a lowercase letter}}}
   */</span>
  def <a title="(source: CharSequence)Option[String]" id="scala.util.matching;Regex.findPrefixOf">findPrefixOf</a><span class="delimiter">(</span><a title="CharSequence" id="scala.util.matching;Regex.findPrefixOf.source">source</a>: <span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[String]">Option</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="java.util.regex.Matcher" id="scala.util.matching;Regex.findPrefixOf.m">m</a> = <a href="#scala.util.matching;Regex.pattern" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#scala.util.matching;Regex.findPrefixOf.source" title="CharSequence">source</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#scala.util.matching;Regex.findPrefixOf.m" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">lookingAt</span><span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Some" title="(x: String)Some[String]">Some</a><span class="delimiter">(</span><a href="#scala.util.matching;Regex.findPrefixOf.m" title="java.util.regex.Matcher">m</a>.<span title="()String">group</span><span class="delimiter">)</span> else <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Return an optional match of this `Regex` at the beginning of the
   *  given character sequence, or None if it matches no prefix
   *  of the character sequence.
   *
   *  Unlike `findFirstMatchIn`, this method will only return a match at
   *  the beginning of the input.
   *
   *  @param source The text to match against.
   *  @return       A [[scala.Option]] of the [[scala.util.matching.Regex.Match]] of the matched string.
   *  @example      {{{&quot;&quot;&quot;\w+&quot;&quot;&quot;.r findPrefixMatchOf &quot;A simple example.&quot; map (_.after) // returns Some(&quot; simple example.&quot;)}}}
   */</span>
  def <a title="(source: CharSequence)Option[scala.util.matching.Regex.Match]" id="scala.util.matching;Regex.findPrefixMatchOf">findPrefixMatchOf</a><span class="delimiter">(</span><a title="CharSequence" id="scala.util.matching;Regex.findPrefixMatchOf.source">source</a>: <span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[scala.util.matching.Regex.Match]">Option</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="java.util.regex.Matcher" id="scala.util.matching;Regex.findPrefixMatchOf.m">m</a> = <a href="#scala.util.matching;Regex.pattern" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#scala.util.matching;Regex.findPrefixMatchOf.source" title="CharSequence">source</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#scala.util.matching;Regex.findPrefixMatchOf.m" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">lookingAt</span><span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Some" title="(x: scala.util.matching.Regex.Match)Some[scala.util.matching.Regex.Match]">Some</a><span class="delimiter">(</span>new <a href="#scala.util.matching.Regex;Match" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">(</span><a href="#scala.util.matching;Regex.findPrefixMatchOf.source" title="CharSequence">source</a>, <a href="#scala.util.matching;Regex.findPrefixMatchOf.m" title="java.util.regex.Matcher">m</a>, <a href="#scala.util.matching;Regex.groupNames" title="String*">groupNames</a><span class="delimiter">)</span><span class="delimiter">)</span> else <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Replaces all matches by a string.
   *
   *  $replacementString
   *
   *  @param target      The string to match
   *  @param replacement The string that will replace each match
   *  @return            The resulting string
   *  @example           {{{&quot;&quot;&quot;\d+&quot;&quot;&quot;.r replaceAllIn (&quot;July 15&quot;, &quot;&lt;NUMBER&gt;&quot;) // returns &quot;July &lt;NUMBER&gt;&quot;}}}
   */</span>
  def <a title="(target: CharSequence, replacement: String)String" id="scala.util.matching;Regex.replaceAllIn(59b682a986)">replaceAllIn</a><span class="delimiter">(</span><a title="CharSequence" id="scala.util.matching;Regex.replaceAllIn(59b682a986).target">target</a>: <span title="CharSequence">CharSequence</span>, <a title="String" id="scala.util.matching;Regex.replaceAllIn(59b682a986).replacement">replacement</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    val <a title="java.util.regex.Matcher" id="scala.util.matching;Regex.replaceAllIn(59b682a986).m">m</a> = <a href="#scala.util.matching;Regex.pattern" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#scala.util.matching;Regex.replaceAllIn(59b682a986).target" title="CharSequence">target</a><span class="delimiter">)</span>
    <a href="#scala.util.matching;Regex.replaceAllIn(59b682a986).m" title="java.util.regex.Matcher">m</a>.<span title="(x$1: String)String">replaceAll</span><span class="delimiter">(</span><a href="#scala.util.matching;Regex.replaceAllIn(59b682a986).replacement" title="String">replacement</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Replaces all matches using a replacer function. The replacer function takes a
   * [[scala.util.matching.Regex.Match]] so that extra information can be obtained
   * from the match. For example:
   *
   * {{{
   * import scala.util.matching.Regex
   * val datePattern = new Regex(&quot;&quot;&quot;(\d\d\d\d)-(\d\d)-(\d\d)&quot;&quot;&quot;, &quot;year&quot;, &quot;month&quot;, &quot;day&quot;)
   * val text = &quot;From 2011-07-15 to 2011-07-17&quot;
   * val repl = datePattern replaceAllIn (text, m =&gt; s&quot;${m group &quot;month&quot;}/${m group &quot;day&quot;}&quot;)
   * }}}
   *
   * $replacementString
   *
   * @param target      The string to match.
   * @param replacer    The function which maps a match to another string.
   * @return            The target string after replacements.
   */</span>
  def <a title="(target: CharSequence, replacer: scala.util.matching.Regex.Match =&gt; String)String" id="scala.util.matching;Regex.replaceAllIn(1271356b35)">replaceAllIn</a><span class="delimiter">(</span><a title="CharSequence" id="scala.util.matching;Regex.replaceAllIn(1271356b35).target">target</a>: <span title="CharSequence">CharSequence</span>, <a title="scala.util.matching.Regex.Match =&gt; String" id="scala.util.matching;Regex.replaceAllIn(1271356b35).replacer">replacer</a>: Match =&gt; String<span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    val <a title="&lt;refinement of scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement&gt; extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement" id="scala.util.matching;Regex.replaceAllIn(1271356b35).it">it</a> = new <a href="#scala.util.matching.Regex.readResolve" title="scala.util.matching.Regex.type">Regex</a>.<a href="#scala.util.matching.Regex;MatchIterator" title="scala.util.matching.Regex.MatchIterator">MatchIterator</a><span class="delimiter">(</span><a href="#scala.util.matching;Regex.replaceAllIn(1271356b35).target" title="CharSequence">target</a>, this, <a href="#scala.util.matching;Regex.groupNames" title="String*">groupNames</a><span class="delimiter">)</span>.<a href="#scala.util.matching.Regex;MatchIterator.replacementData" title="=&gt; scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">replacementData</a>
    <a href="#scala.util.matching;Regex.replaceAllIn(1271356b35).it" title="&lt;refinement of scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement&gt; extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a> <a href="../../collection/Iterator.scala.html#scala.collection;Iterator.foreach" title="(f: scala.util.matching.Regex.Match =&gt; java.util.regex.Matcher)Unit">foreach</a> <span class="delimiter">(</span><a title="scala.util.matching.Regex.Match" id="scala.util.matching;Regex.replaceAllIn(1271356b35).$anonfun.md">md</a> =&gt; <a href="#scala.util.matching;Regex.replaceAllIn(1271356b35).it" title="&lt;refinement of scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement&gt; extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a> <a href="#scala.util.matching.Regex;Replacement.replace" title="(rs: String)java.util.regex.Matcher">replace</a> <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: scala.util.matching.Regex.Match)String">replacer</a><span class="delimiter">(</span><a href="#scala.util.matching;Regex.replaceAllIn(1271356b35).$anonfun.md" title="scala.util.matching.Regex.Match">md</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#scala.util.matching;Regex.replaceAllIn(1271356b35).it" title="&lt;refinement of scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement&gt; extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a>.<a href="#scala.util.matching.Regex;Replacement.replaced" title="=&gt; String">replaced</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Replaces some of the matches using a replacer function that returns an [[scala.Option]].
   * The replacer function takes a [[scala.util.matching.Regex.Match]] so that extra
   * information can be btained from the match. For example:
   *
   * {{{
   * import scala.util.matching.Regex._
   *
   * val vars = Map(&quot;x&quot; -&gt; &quot;a var&quot;, &quot;y&quot; -&gt; &quot;&quot;&quot;some $ and \ signs&quot;&quot;&quot;)
   * val text = &quot;A text with variables %x, %y and %z.&quot;
   * val varPattern = &quot;&quot;&quot;%(\w+)&quot;&quot;&quot;.r
   * val mapper = (m: Match) =&gt; vars get (m group 1) map (quoteReplacement(_))
   * val repl = varPattern replaceSomeIn (text, mapper)
   * }}}
   *
   * $replacementString
   *
   * @param target      The string to match.
   * @param replacer    The function which optionally maps a match to another string.
   * @return            The target string after replacements.
   */</span>
  def <a title="(target: CharSequence, replacer: scala.util.matching.Regex.Match =&gt; Option[String])String" id="scala.util.matching;Regex.replaceSomeIn">replaceSomeIn</a><span class="delimiter">(</span><a title="CharSequence" id="scala.util.matching;Regex.replaceSomeIn.target">target</a>: <span title="CharSequence">CharSequence</span>, <a title="scala.util.matching.Regex.Match =&gt; Option[String]" id="scala.util.matching;Regex.replaceSomeIn.replacer">replacer</a>: Match =&gt; Option<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    val <a title="&lt;refinement of scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement&gt; extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement" id="scala.util.matching;Regex.replaceSomeIn.it">it</a> = new <a href="#scala.util.matching.Regex.readResolve" title="scala.util.matching.Regex.type">Regex</a>.<a href="#scala.util.matching.Regex;MatchIterator" title="scala.util.matching.Regex.MatchIterator">MatchIterator</a><span class="delimiter">(</span><a href="#scala.util.matching;Regex.replaceSomeIn.target" title="CharSequence">target</a>, this, <a href="#scala.util.matching;Regex.groupNames" title="String*">groupNames</a><span class="delimiter">)</span>.<a href="#scala.util.matching.Regex;MatchIterator.replacementData" title="=&gt; scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">replacementData</a>
    for <span class="delimiter">(</span><a title="scala.util.matching.Regex.Match" id="scala.util.matching;Regex.replaceSomeIn.$anonfun.matchdata">matchdata</a> &lt;- <a href="../../collection/Iterator.scala.html#scala.collection;Iterator.foreach" title="(f: scala.util.matching.Regex.Match =&gt; Unit)Unit">it</a> ; <a title="String" id="scala.util.matching;Regex.replaceSomeIn.$anonfun.$anonfun.replacement">replacement</a> &lt;- <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: scala.util.matching.Regex.Match)Option[String]">replacer</a><a href="../../Option.scala.html#scala;Option.foreach" title="(f: String =&gt; java.util.regex.Matcher)Unit" class="delimiter">(</a><a href="#scala.util.matching;Regex.replaceSomeIn.$anonfun.matchdata" title="scala.util.matching.Regex.Match">matchdata</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#scala.util.matching;Regex.replaceSomeIn.it" title="&lt;refinement of scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement&gt; extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a> <a href="#scala.util.matching.Regex;Replacement.replace" title="(rs: String)java.util.regex.Matcher">replace</a> <a href="#scala.util.matching;Regex.replaceSomeIn.$anonfun.$anonfun.replacement" title="String">replacement</a>

    <a href="#scala.util.matching;Regex.replaceSomeIn.it" title="&lt;refinement of scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement&gt; extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement">it</a>.<a href="#scala.util.matching.Regex;Replacement.replaced" title="=&gt; String">replaced</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Replaces the first match by a string.
   *
   *  $replacementString
   *
   *  @param target      The string to match
   *  @param replacement The string that will replace the match
   *  @return            The resulting string
   */</span>
  def <a title="(target: CharSequence, replacement: String)String" id="scala.util.matching;Regex.replaceFirstIn">replaceFirstIn</a><span class="delimiter">(</span><a title="CharSequence" id="scala.util.matching;Regex.replaceFirstIn.target">target</a>: <span title="CharSequence">CharSequence</span>, <a title="String" id="scala.util.matching;Regex.replaceFirstIn.replacement">replacement</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    val <a title="java.util.regex.Matcher" id="scala.util.matching;Regex.replaceFirstIn.m">m</a> = <a href="#scala.util.matching;Regex.pattern" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#scala.util.matching;Regex.replaceFirstIn.target" title="CharSequence">target</a><span class="delimiter">)</span>
    <a href="#scala.util.matching;Regex.replaceFirstIn.m" title="java.util.regex.Matcher">m</a>.<span title="(x$1: String)String">replaceFirst</span><span class="delimiter">(</span><a href="#scala.util.matching;Regex.replaceFirstIn.replacement" title="String">replacement</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Splits the provided character sequence around matches of this regexp.
   *
   *  @param toSplit The character sequence to split
   *  @return        The array of strings computed by splitting the
   *                 input around matches of this regexp
   */</span>
  def <a title="(toSplit: CharSequence)Array[String]" id="scala.util.matching;Regex.split">split</a><span class="delimiter">(</span><a title="CharSequence" id="scala.util.matching;Regex.split.toSplit">toSplit</a>: <span title="CharSequence">CharSequence</span><span class="delimiter">)</span>: <a href="../../Array.scala.html#scala;Array" title="Array[String]">Array</a><span class="delimiter">[</span>String<span class="delimiter">]</span> =
    <a href="#scala.util.matching;Regex.pattern" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)Array[String]">split</span><span class="delimiter">(</span><a href="#scala.util.matching;Regex.split.toSplit" title="CharSequence">toSplit</a><span class="delimiter">)</span>

  <span class="comment">/** Create a new Regex with the same pattern, but no requirement that
   *  the entire String matches in extractor patterns.
   *
   *  Normally, matching on `date` behaves as though the pattern were
   *  enclosed in anchors, `&quot;^pattern$&quot;`.
   *
   *  The unanchored `Regex` behaves as though those anchors were removed.
   *
   *  Note that this method does not actually strip any matchers from the pattern.
   *
   *  Calling `anchored` returns the original `Regex`.
   *
   *  {{{
   *  val date = &quot;&quot;&quot;(\d\d\d\d)-(\d\d)-(\d\d)&quot;&quot;&quot;.r.unanchored
   *
   *  val date(year, month, day) = &quot;Date 2011-07-15&quot;                       // OK
   *
   *  val copyright: String = &quot;Date of this document: 2011-07-15&quot; match {
   *    case date(year, month, day) =&gt; s&quot;Copyright $year&quot;                  // OK
   *    case _                      =&gt; &quot;No copyright&quot;
   *  }
   *  }}}
   *
   *  @return        The new unanchored regex
   */</span>
  def <a title="=&gt; scala.util.matching.UnanchoredRegex" id="scala.util.matching;Regex.unanchored">unanchored</a>: <a href="#scala.util.matching;UnanchoredRegex" title="scala.util.matching.UnanchoredRegex">UnanchoredRegex</a> = new <a href="#scala.util.matching;Regex" title="&lt;$anon: scala.util.matching.Regex with scala.util.matching.UnanchoredRegex&gt; extends scala.util.matching.Regex with scala.util.matching.UnanchoredRegex" id="scala.util.matching;Regex.unanchored;$anon">Regex</a><span class="delimiter">(</span><a href="#scala.util.matching;Regex.pattern" title="=&gt; java.util.regex.Pattern">pattern</a>, <a href="#scala.util.matching;Regex.groupNames" title="String*">groupNames</a>: _*<span class="delimiter">)</span> with <a href="#scala.util.matching;UnanchoredRegex" title="scala.util.matching.UnanchoredRegex">UnanchoredRegex</a> <span class="delimiter">{</span> override def <a title="=&gt; scala.util.matching.Regex" id="scala.util.matching;Regex.unanchored;$anon.anchored">anchored</a> = <a href="#scala.util.matching;Regex" title="scala.util.matching.Regex">outer</a> <span class="delimiter">}</span>
  def <a title="=&gt; scala.util.matching.Regex" id="scala.util.matching;Regex.anchored">anchored</a>: <a href="#scala.util.matching;Regex" title="scala.util.matching.Regex">Regex</a>             = this

  def <a title="=&gt; String" id="scala.util.matching;Regex.regex">regex</a>: <span title="String">String</span> = <a href="#scala.util.matching;Regex.pattern" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="()String">pattern</span>

  <span class="comment">/** The string defining the regular expression */</span>
  override def <a title="()String" id="scala.util.matching;Regex.toString">toString</a> = <a href="#scala.util.matching;Regex.regex" title="=&gt; String">regex</a>
<span class="delimiter">}</span>

<span class="comment">/** A [[Regex]] that finds the first match when used in a pattern match.
 *
 *  @see [[Regex#unanchored]]
 */</span>
trait <a title="trait UnanchoredRegex extends scala.util.matching.Regex" id="scala.util.matching;UnanchoredRegex">UnanchoredRegex</a> extends <a href="#scala.util.matching;Regex" title="scala.util.matching.Regex">Regex</a> <span class="delimiter">{</span>
  override protected def <a title="(m: java.util.regex.Matcher)Boolean" id="scala.util.matching;UnanchoredRegex.runMatcher">runMatcher</a><span class="delimiter">(</span><a title="java.util.regex.Matcher" id="scala.util.matching;UnanchoredRegex.runMatcher.m">m</a>: <span title="java.util.regex.Matcher">Matcher</span><span class="delimiter">)</span> = <a href="#scala.util.matching;UnanchoredRegex.runMatcher.m" title="java.util.regex.Matcher">m</a>.<span title="()Boolean">find</span><span class="delimiter">(</span><span class="delimiter">)</span>
  override def <a title="=&gt; scala.util.matching.UnanchoredRegex" id="scala.util.matching;UnanchoredRegex.unanchored">unanchored</a> = this
<span class="delimiter">}</span>

<span class="comment">/** This object defines inner classes that describe
 *  regex matches and helper objects.
 */</span>
object <a title="scala.util.matching.Regex.type" id="scala.util.matching.Regex.readResolve">Regex</a> <a href="#scala.util.matching.Regex.readResolve" title="scala.util.matching.Regex.type" class="delimiter">{</a>

  <span class="comment">/** This class provides methods to access
   *  the details of a match.
   */</span>
  trait <a title="trait MatchData extends AnyRef" id="scala.util.matching.Regex;MatchData">MatchData</a> <a href="../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a>

    <span class="comment">/** The source from which the match originated */</span>
    val <a title="=&gt; CharSequence" id="scala.util.matching.Regex;MatchData.source">source</a>: <span title="CharSequence">CharSequence</span>

    <span class="comment">/** The names of the groups, or an empty sequence if none defined */</span>
    val <a title="=&gt; Seq[String]" id="scala.util.matching.Regex;MatchData.groupNames">groupNames</a>: <a href="../../collection/Seq.scala.html#scala.collection;Seq" title="Seq[String]">Seq</a><span class="delimiter">[</span>String<span class="delimiter">]</span>

    <span class="comment">/** The number of capturing groups in the pattern.
     *  (For a given successful match, some of those groups may not have matched any input.)
     */</span>
    def <a title="=&gt; Int" id="scala.util.matching.Regex;MatchData.groupCount">groupCount</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>

    <span class="comment">/** The index of the first matched character, or -1 if nothing was matched */</span>
    def <a title="=&gt; Int" id="scala.util.matching.Regex;MatchData.start(f94e342797)">start</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>

    <span class="comment">/** The index of the first matched character in group `i`,
     *  or -1 if nothing was matched for that group.
     */</span>
    def <a title="(i: Int)Int" id="scala.util.matching.Regex;MatchData.start(e643ed6cce)">start</a><span class="delimiter">(</span><a title="Int" id="scala.util.matching.Regex;MatchData.start(e643ed6cce).i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>

    <span class="comment">/** The index following the last matched character, or -1 if nothing was matched. */</span>
    def <a title="=&gt; Int" id="scala.util.matching.Regex;MatchData.end(f94e342797)">end</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>

    <span class="comment">/** The index following the last matched character in group `i`,
     *  or -1 if nothing was matched for that group.
     */</span>
    def <a title="(i: Int)Int" id="scala.util.matching.Regex;MatchData.end(e643ed6cce)">end</a><span class="delimiter">(</span><a title="Int" id="scala.util.matching.Regex;MatchData.end(e643ed6cce).i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>

    <span class="comment">/** The matched string, or `null` if nothing was matched. */</span>
    def <a title="=&gt; String" id="scala.util.matching.Regex;MatchData.matched">matched</a>: <span title="String">String</span> =
      if <span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.start(f94e342797)" title="=&gt; Int">start</a> <a href="../../Int.scala.html#scala;Int.>=(5f58a84eb3)" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#scala.util.matching.Regex;MatchData.source" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.start(f94e342797)" title="=&gt; Int">start</a>, <a href="#scala.util.matching.Regex;MatchData.end(f94e342797)" title="=&gt; Int">end</a><span class="delimiter">)</span>.<span title="()String">toString</span>
      else null

    <span class="comment">/** The matched string in group `i`,
     *  or `null` if nothing was matched.
     */</span>
    def <a title="(i: Int)String" id="scala.util.matching.Regex;MatchData.group(d43c183463)">group</a><span class="delimiter">(</span><a title="Int" id="scala.util.matching.Regex;MatchData.group(d43c183463).i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <span title="String">String</span> =
      if <span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.start(e643ed6cce)" title="(i: Int)Int">start</a><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.group(d43c183463).i" title="Int">i</a><span class="delimiter">)</span> <a href="../../Int.scala.html#scala;Int.>=(5f58a84eb3)" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#scala.util.matching.Regex;MatchData.source" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.start(e643ed6cce)" title="(i: Int)Int">start</a><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.group(d43c183463).i" title="Int">i</a><span class="delimiter">)</span>, <a href="#scala.util.matching.Regex;MatchData.end(e643ed6cce)" title="(i: Int)Int">end</a><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.group(d43c183463).i" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="()String">toString</span>
      else null

    <span class="comment">/** All capturing groups, i.e., not including group(0). */</span>
    def <a title="=&gt; List[String]" id="scala.util.matching.Regex;MatchData.subgroups">subgroups</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[String]">List</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">(</span><a href="../../Predef.scala.html#scala;LowPriorityImplicits.intWrapper" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">1</a> <a href="../../runtime/RichInt.scala.html#scala.runtime;RichInt.to(edbf447743)" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#scala.util.matching.Regex;MatchData.groupCount" title="=&gt; Int">groupCount</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[Int]">toList</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Int =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Int],String,List[String]])List[String]">map</a> <a href="#scala.util.matching.Regex;MatchData.group(d43c183463)" title="(i: Int)String">group</a>

    <span class="comment">/** The char sequence before first character of match,
     *  or `null` if nothing was matched.
     */</span>
    def <a title="=&gt; CharSequence" id="scala.util.matching.Regex;MatchData.before(3ac95d05e6)">before</a>: <span title="CharSequence">CharSequence</span> =
      if <span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.start(f94e342797)" title="=&gt; Int">start</a> <a href="../../Int.scala.html#scala;Int.>=(5f58a84eb3)" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#scala.util.matching.Regex;MatchData.source" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#scala.util.matching.Regex;MatchData.start(f94e342797)" title="=&gt; Int">start</a><span class="delimiter">)</span>
      else null

    <span class="comment">/** The char sequence before first character of match in group `i`,
     *  or `null` if nothing was matched for that group.
     */</span>
    def <a title="(i: Int)CharSequence" id="scala.util.matching.Regex;MatchData.before(ef8b26333d)">before</a><span class="delimiter">(</span><a title="Int" id="scala.util.matching.Regex;MatchData.before(ef8b26333d).i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <span title="CharSequence">CharSequence</span> =
      if <span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.start(e643ed6cce)" title="(i: Int)Int">start</a><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.before(ef8b26333d).i" title="Int">i</a><span class="delimiter">)</span> <a href="../../Int.scala.html#scala;Int.>=(5f58a84eb3)" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#scala.util.matching.Regex;MatchData.source" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#scala.util.matching.Regex;MatchData.start(e643ed6cce)" title="(i: Int)Int">start</a><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.before(ef8b26333d).i" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
      else null

    <span class="comment">/** Returns char sequence after last character of match,
     *  or `null` if nothing was matched.
     */</span>
    def <a title="=&gt; CharSequence" id="scala.util.matching.Regex;MatchData.after(3ac95d05e6)">after</a>: <span title="CharSequence">CharSequence</span> =
      if <span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.end(f94e342797)" title="=&gt; Int">end</a> <a href="../../Int.scala.html#scala;Int.>=(5f58a84eb3)" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#scala.util.matching.Regex;MatchData.source" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.end(f94e342797)" title="=&gt; Int">end</a>, <a href="#scala.util.matching.Regex;MatchData.source" title="=&gt; CharSequence">source</a>.<span title="()Int">length</span><span class="delimiter">)</span>
      else null

    <span class="comment">/** The char sequence after last character of match in group `i`,
     *  or `null` if nothing was matched for that group.
     */</span>
    def <a title="(i: Int)CharSequence" id="scala.util.matching.Regex;MatchData.after(ef8b26333d)">after</a><span class="delimiter">(</span><a title="Int" id="scala.util.matching.Regex;MatchData.after(ef8b26333d).i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <span title="CharSequence">CharSequence</span> =
      if <span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.end(e643ed6cce)" title="(i: Int)Int">end</a><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.after(ef8b26333d).i" title="Int">i</a><span class="delimiter">)</span> <a href="../../Int.scala.html#scala;Int.>=(5f58a84eb3)" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#scala.util.matching.Regex;MatchData.source" title="=&gt; CharSequence">source</a>.<span title="(x$1: Int, x$2: Int)CharSequence">subSequence</span><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.end(e643ed6cce)" title="(i: Int)Int">end</a><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.after(ef8b26333d).i" title="Int">i</a><span class="delimiter">)</span>, <a href="#scala.util.matching.Regex;MatchData.source" title="=&gt; CharSequence">source</a>.<span title="()Int">length</span><span class="delimiter">)</span>
      else null

    private lazy val nameToIndex: <a href="../../collection/immutable/Map.scala.html#scala.collection.immutable;Map" title="Map[String,Int]">Map</a><span class="delimiter">[</span>String, Int<span class="delimiter">]</span> = <a href="../../collection/generic/GenMapFactory.scala.html#scala.collection.generic;GenMapFactory.apply" title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</a><span title="(elems: (String, Int)*)scala.collection.immutable.Map[String,Int]" class="delimiter">[</span><span title="String">String</span>, <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span> <a href="../../collection/immutable/MapLike.scala.html#scala.collection.immutable;MapLike.++(cdd7f1b9f2)" title="Map[String,Int]" id="scala.util.matching.Regex;MatchData.nameToIndex">++</a> <span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: String)List[String]">::</a> <a href="#scala.util.matching.Regex;MatchData.groupNames" title="=&gt; Seq[String]">groupNames</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[String]">toList</a><span class="delimiter">)</span>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.zipWithIndex" title="(implicit bf: scala.collection.generic.CanBuildFrom[List[String],(String, Int),List[(String, Int)]])List[(String, Int)]">zipWithIndex</a>

    <span class="comment">/** Returns the group with given name.
     *
     *  @param id The group name
     *  @return   The requested group
     *  @throws   NoSuchElementException if the requested group name is not defined
     */</span>
    def <a title="(id: String)String" id="scala.util.matching.Regex;MatchData.group(45cb3974a8)">group</a><span class="delimiter">(</span><a title="String" id="scala.util.matching.Regex;MatchData.group(45cb3974a8).id">id</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <a href="#scala.util.matching.Regex;MatchData.nameToIndex" title="=&gt; Map[String,Int]">nameToIndex</a>.<a href="../../collection/MapLike.scala.html#scala.collection;MapLike.get" title="(key: String)Option[Int]">get</a><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.group(45cb3974a8).id" title="String">id</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case <a href="../../Option.scala.html#scala.None" title="None.type">None</a> =&gt; throw new <a href="../../package.scala.html#scala.package;NoSuchElementException" title="java.util.NoSuchElementException">NoSuchElementException</a><span class="delimiter">(</span><span title="String(&quot;group name &quot;)" class="string">&quot;group name &quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.util.matching.Regex;MatchData.group(45cb3974a8).id" title="String">id</a><span title="(x$1: Any)String">+</span><span title="String(&quot; not defined&quot;)" class="string">&quot; not defined&quot;</span><span class="delimiter">)</span>
      case Some<span class="delimiter">(</span><a title="Int" id="scala.util.matching.Regex;MatchData.group(45cb3974a8).index">index</a><span class="delimiter">)</span> =&gt; <a href="#scala.util.matching.Regex;MatchData.group(d43c183463)" title="(i: Int)String">group</a><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchData.group(45cb3974a8).index" title="Int">index</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** The matched string; equivalent to `matched.toString`. */</span>
    override def <a title="()String" id="scala.util.matching.Regex;MatchData.toString">toString</a> = <a href="#scala.util.matching.Regex;MatchData.matched" title="=&gt; String">matched</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Provides information about a successful match. */</span>
  class <a title="class Match extends AnyRef with scala.util.matching.Regex.MatchData" id="scala.util.matching.Regex;Match">Match</a><a href="#scala.util.matching.Regex;Match" title="scala.util.matching.Regex.Match" class="delimiter">(</a>val <a title="CharSequence" id="scala.util.matching.Regex;Match.source">source</a>: <span title="CharSequence">CharSequence</span>,
              private<span class="delimiter">[</span>matching<span class="delimiter">]</span> val <a title="java.util.regex.Matcher" id="scala.util.matching.Regex;Match.matcher">matcher</a>: <span title="java.util.regex.Matcher">Matcher</span>,
              val <a title="Seq[String]" id="scala.util.matching.Regex;Match.groupNames">groupNames</a>: <a href="../../collection/Seq.scala.html#scala.collection;Seq" title="Seq[String]">Seq</a><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.util.matching.Regex;MatchData" title="scala.util.matching.Regex.MatchData">MatchData</a> <span class="delimiter">{</span>

    <span class="comment">/** The index of the first matched character. */</span>
    val <a title="Int" id="scala.util.matching.Regex;Match.start(f94e342797)">start</a> = <a href="#scala.util.matching.Regex;Match.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Int">start</span>

    <span class="comment">/** The index following the last matched character. */</span>
    val <a title="Int" id="scala.util.matching.Regex;Match.end(f94e342797)">end</a> = <a href="#scala.util.matching.Regex;Match.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Int">end</span>

    <span class="comment">/** The number of subgroups. */</span>
    def <a title="=&gt; Int" id="scala.util.matching.Regex;Match.groupCount">groupCount</a> = <a href="#scala.util.matching.Regex;Match.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Int">groupCount</span>

    private lazy val <a title="Array[Int]" id="scala.util.matching.Regex;Match.starts">starts</a>: <a href="../../Array.scala.html#scala;Array" title="Array[Int]">Array</a><span class="delimiter">[</span>Int<span class="delimiter">]</span> =
      <span class="delimiter">(</span><span class="delimiter">(</span><a href="../../Predef.scala.html#scala;LowPriorityImplicits.intWrapper" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">0</a> <a href="../../runtime/RichInt.scala.html#scala.runtime;RichInt.to(edbf447743)" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#scala.util.matching.Regex;Match.groupCount" title="=&gt; Int">groupCount</a><span class="delimiter">)</span> <a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.map" title="(f: Int =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],Int,scala.collection.immutable.IndexedSeq[Int]])scala.collection.immutable.IndexedSeq[Int]">map</a> <a href="#scala.util.matching.Regex;Match.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<a href="#scala.util.matching.Regex;Match.starts.$anonfun.x$1" title="(x$1: Int)Int">start</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toArray" title="(implicit evidence$1: scala.reflect.ClassTag[Int])Array[Int]">toArray</a>
    private lazy val <a title="Array[Int]" id="scala.util.matching.Regex;Match.ends">ends</a>: <a href="../../Array.scala.html#scala;Array" title="Array[Int]">Array</a><span class="delimiter">[</span>Int<span class="delimiter">]</span> =
      <span class="delimiter">(</span><span class="delimiter">(</span><a href="../../Predef.scala.html#scala;LowPriorityImplicits.intWrapper" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">0</a> <a href="../../runtime/RichInt.scala.html#scala.runtime;RichInt.to(edbf447743)" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#scala.util.matching.Regex;Match.groupCount" title="=&gt; Int">groupCount</a><span class="delimiter">)</span> <a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.map" title="(f: Int =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],Int,scala.collection.immutable.IndexedSeq[Int]])scala.collection.immutable.IndexedSeq[Int]">map</a> <a href="#scala.util.matching.Regex;Match.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<a href="#scala.util.matching.Regex;Match.ends.$anonfun.x$1" title="(x$1: Int)Int">end</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toArray" title="(implicit evidence$1: scala.reflect.ClassTag[Int])Array[Int]">toArray</a>

    <span class="comment">/** The index of the first matched character in group `i`. */</span>
    def <a title="(i: Int)Int" id="scala.util.matching.Regex;Match.start(e643ed6cce)">start</a><span class="delimiter">(</span><a title="Int" id="scala.util.matching.Regex;Match.start(e643ed6cce).i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span> = <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)Int">starts</a><span class="delimiter">(</span><a href="#scala.util.matching.Regex;Match.start(e643ed6cce).i" title="Int">i</a><span class="delimiter">)</span>

    <span class="comment">/** The index following the last matched character in group `i`. */</span>
    def <a title="(i: Int)Int" id="scala.util.matching.Regex;Match.end(e643ed6cce)">end</a><span class="delimiter">(</span><a title="Int" id="scala.util.matching.Regex;Match.end(e643ed6cce).i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span> = <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)Int">ends</a><span class="delimiter">(</span><a href="#scala.util.matching.Regex;Match.end(e643ed6cce).i" title="Int">i</a><span class="delimiter">)</span>

    <span class="comment">/** The match itself with matcher-dependent lazy vals forced,
     *  so that match is valid even once matcher is advanced.
     */</span>
    def <a title="=&gt; Match.this.type" id="scala.util.matching.Regex;Match.force">force</a>: this.type = <span class="delimiter">{</span> <a href="#scala.util.matching.Regex;Match.starts" title="=&gt; Array[Int]">starts</a>; <a href="#scala.util.matching.Regex;Match.ends" title="=&gt; Array[Int]">ends</a>; this <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An extractor object for Matches, yielding the matched string.
   *
   *  This can be used to help writing replacer functions when you
   *  are not interested in match data. For example:
   *
   *  {{{
   *  import scala.util.matching.Regex.Match
   *  &quot;&quot;&quot;\w+&quot;&quot;&quot;.r replaceAllIn (&quot;A simple example.&quot;, _ match { case Match(s) =&gt; s.toUpperCase })
   *  }}}
   *
   */</span>
  object <a title="scala.util.matching.Regex.Match.type" id="scala.util.matching.Regex.Match">Match</a> <a href="#scala.util.matching.Regex.Match" title="scala.util.matching.Regex.Match.type" class="delimiter">{</a>
    def <a title="(m: scala.util.matching.Regex.Match)Some[String]" id="scala.util.matching.Regex.Match.unapply">unapply</a><span class="delimiter">(</span><a title="scala.util.matching.Regex.Match" id="scala.util.matching.Regex.Match.unapply.m">m</a>: <a href="#scala.util.matching.Regex;Match" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Some" title="Some[String]">Some</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="../../Option.scala.html#scala;Some" title="(x: String)Some[String]">Some</a><span class="delimiter">(</span><a href="#scala.util.matching.Regex.Match.unapply.m" title="scala.util.matching.Regex.Match">m</a>.<a href="#scala.util.matching.Regex;MatchData.matched" title="=&gt; String">matched</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An extractor object that yields the groups in the match. Using this extractor
   *  rather than the original `Regex` ensures that the match is not recomputed.
   *
   *  {{{
   *  import scala.util.matching.Regex.Groups
   *
   *  val date = &quot;&quot;&quot;(\d\d\d\d)-(\d\d)-(\d\d)&quot;&quot;&quot;.r
   *  val text = &quot;The doc spree happened on 2011-07-15.&quot;
   *  val day = date replaceAllIn(text, _ match { case Groups(_, month, day) =&gt; s&quot;$month/$day&quot; })
   *  }}}
   */</span>
  object <a title="scala.util.matching.Regex.Groups.type" id="scala.util.matching.Regex.Groups">Groups</a> <a href="#scala.util.matching.Regex.Groups" title="scala.util.matching.Regex.Groups.type" class="delimiter">{</a>
    def <a title="(m: scala.util.matching.Regex.Match)Option[Seq[String]]" id="scala.util.matching.Regex.Groups.unapplySeq">unapplySeq</a><span class="delimiter">(</span><a title="scala.util.matching.Regex.Match" id="scala.util.matching.Regex.Groups.unapplySeq.m">m</a>: <a href="#scala.util.matching.Regex;Match" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Seq[String]]">Option</a><span class="delimiter">[</span>Seq<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> = if <span class="delimiter">(</span><a href="#scala.util.matching.Regex.Groups.unapplySeq.m" title="scala.util.matching.Regex.Match">m</a>.<a href="#scala.util.matching.Regex;Match.groupCount" title="=&gt; Int">groupCount</a> <a href="../../Int.scala.html#scala;Int.>(5f58a84eb3)" title="(x: Int)Boolean">&gt;</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Some" title="(x: Seq[String])Some[Seq[String]]">Some</a><span class="delimiter">(</span><a href="../../Predef.scala.html#scala;LowPriorityImplicits.intWrapper" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">1</a> <a href="../../runtime/RichInt.scala.html#scala.runtime;RichInt.to(edbf447743)" title="(end: Int)scala.collection.immutable.Range.Inclusive">to</a> <a href="#scala.util.matching.Regex.Groups.unapplySeq.m" title="scala.util.matching.Regex.Match">m</a>.<a href="#scala.util.matching.Regex;Match.groupCount" title="=&gt; Int">groupCount</a> <a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.map" title="(f: Int =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],String,Seq[String]])Seq[String]">map</a> <a href="#scala.util.matching.Regex.Groups.unapplySeq.m" title="scala.util.matching.Regex.Match">m</a>.<a href="#scala.util.matching.Regex;MatchData.group(d43c183463)" title="(i: Int)String">group</a><span class="delimiter">)</span> else <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A class to step through a sequence of regex matches.
   *
   *  All methods inherited from [[scala.util.matching.Regex.MatchData]] will throw
   *  a [[java.lang.IllegalStateException]] until the matcher is initialized. The
   *  matcher can be initialized by calling `hasNext` or `next()` or causing these
   *  methods to be called, such as by invoking `toString` or iterating through
   *  the iterator's elements.
   *
   *  @see [[java.util.regex.Matcher]]
   */</span>
  class <a title="class MatchIterator extends scala.collection.AbstractIterator[String] with Iterator[String] with scala.util.matching.Regex.MatchData" id="scala.util.matching.Regex;MatchIterator">MatchIterator</a><a href="#scala.util.matching.Regex;MatchIterator" title="scala.util.matching.Regex.MatchIterator" class="delimiter">(</a>val <a title="CharSequence" id="scala.util.matching.Regex;MatchIterator.source">source</a>: <span title="CharSequence">CharSequence</span>, val <a title="scala.util.matching.Regex" id="scala.util.matching.Regex;MatchIterator.regex">regex</a>: <a href="#scala.util.matching;Regex" title="scala.util.matching.Regex">Regex</a>, val <a title="Seq[String]" id="scala.util.matching.Regex;MatchIterator.groupNames">groupNames</a>: <a href="../../collection/Seq.scala.html#scala.collection;Seq" title="Seq[String]">Seq</a><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>
  extends <a href="../../collection/Iterator.scala.html#scala.collection;AbstractIterator" title="scala.collection.AbstractIterator[String]">AbstractIterator</a><span class="delimiter">[</span>String<span class="delimiter">]</span> with <a href="../../collection/Iterator.scala.html#scala.collection;Iterator" title="Iterator[String]">Iterator</a><span class="delimiter">[</span>String<span class="delimiter">]</span> with <a href="#scala.util.matching.Regex;MatchData" title="scala.util.matching.Regex.MatchData">MatchData</a> <span class="delimiter">{</span> self =&gt;

    protected<span class="delimiter">[</span>Regex<span class="delimiter">]</span> val <a title="java.util.regex.Matcher" id="scala.util.matching.Regex;MatchIterator.matcher">matcher</a> = <a href="#scala.util.matching.Regex;MatchIterator.regex" title="=&gt; scala.util.matching.Regex">regex</a>.<a href="#scala.util.matching;Regex.pattern" title="=&gt; java.util.regex.Pattern">pattern</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchIterator.source" title="=&gt; CharSequence">source</a><span class="delimiter">)</span>
    private var <a title="Boolean" id="scala.util.matching.Regex;MatchIterator.nextSeen_=">nextSeen</a> = false

    <span class="comment">/** Is there another match? */</span>
    def <a title="=&gt; Boolean" id="scala.util.matching.Regex;MatchIterator.hasNext">hasNext</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.util.matching.Regex;MatchIterator.nextSeen_=" title="=&gt; Boolean">nextSeen</a><span class="delimiter">)</span> <a href="#scala.util.matching.Regex;MatchIterator.nextSeen_=" title="(x$1: Boolean)Unit">nextSeen</a> = <a href="#scala.util.matching.Regex;MatchIterator.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Boolean">find</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#scala.util.matching.Regex;MatchIterator.nextSeen_=" title="=&gt; Boolean">nextSeen</a>
    <span class="delimiter">}</span>

    <span class="comment">/** The next matched substring of `source`. */</span>
    def <a title="()String" id="scala.util.matching.Regex;MatchIterator.next">next</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.util.matching.Regex;MatchIterator.hasNext" title="=&gt; Boolean">hasNext</a><span class="delimiter">)</span> throw new <a href="../../package.scala.html#scala.package;NoSuchElementException" title="java.util.NoSuchElementException">NoSuchElementException</a>
      <a href="#scala.util.matching.Regex;MatchIterator.nextSeen_=" title="(x$1: Boolean)Unit">nextSeen</a> = false
      <a href="#scala.util.matching.Regex;MatchIterator.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()String">group</span>
    <span class="delimiter">}</span>

    override def <a title="()String" id="scala.util.matching.Regex;MatchIterator.toString">toString</a> = super<span class="delimiter">[</span>AbstractIterator<span class="delimiter">]</span>.<a href="../../collection/Iterator.scala.html#scala.collection;Iterator.toString" title="()String">toString</a>

    <span class="comment">/** The index of the first matched character. */</span>
    def <a title="=&gt; Int" id="scala.util.matching.Regex;MatchIterator.start(f94e342797)">start</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> = <a href="#scala.util.matching.Regex;MatchIterator.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Int">start</span>

    <span class="comment">/** The index of the first matched character in group `i`. */</span>
    def <a title="(i: Int)Int" id="scala.util.matching.Regex;MatchIterator.start(e643ed6cce)">start</a><span class="delimiter">(</span><a title="Int" id="scala.util.matching.Regex;MatchIterator.start(e643ed6cce).i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> = <a href="#scala.util.matching.Regex;MatchIterator.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="(x$1: Int)Int">start</span><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchIterator.start(e643ed6cce).i" title="Int">i</a><span class="delimiter">)</span>

    <span class="comment">/** The index of the last matched character. */</span>
    def <a title="=&gt; Int" id="scala.util.matching.Regex;MatchIterator.end(f94e342797)">end</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> = <a href="#scala.util.matching.Regex;MatchIterator.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Int">end</span>

    <span class="comment">/** The index following the last matched character in group `i`. */</span>
    def <a title="(i: Int)Int" id="scala.util.matching.Regex;MatchIterator.end(e643ed6cce)">end</a><span class="delimiter">(</span><a title="Int" id="scala.util.matching.Regex;MatchIterator.end(e643ed6cce).i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> = <a href="#scala.util.matching.Regex;MatchIterator.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="(x$1: Int)Int">end</span><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchIterator.end(e643ed6cce).i" title="Int">i</a><span class="delimiter">)</span>

    <span class="comment">/** The number of subgroups. */</span>
    def <a title="=&gt; Int" id="scala.util.matching.Regex;MatchIterator.groupCount">groupCount</a> = <a href="#scala.util.matching.Regex;MatchIterator.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="()Int">groupCount</span>

    <span class="comment">/** Convert to an iterator that yields MatchData elements instead of Strings. */</span>
    def <a title="=&gt; Iterator[scala.util.matching.Regex.Match]" id="scala.util.matching.Regex;MatchIterator.matchData">matchData</a>: <a href="../../collection/Iterator.scala.html#scala.collection;Iterator" title="Iterator[scala.util.matching.Regex.Match]">Iterator</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> = new <a title="&lt;$anon: scala.collection.AbstractIterator[scala.util.matching.Regex.Match]&gt; extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match]" id="scala.util.matching.Regex;MatchIterator.matchData;$anon">AbstractIterator</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="=&gt; Boolean" id="scala.util.matching.Regex;MatchIterator.matchData;$anon.hasNext">hasNext</a> = <a href="#scala.util.matching.Regex;MatchIterator" title="MatchIterator.this.type">self</a>.<a href="#scala.util.matching.Regex;MatchIterator.hasNext" title="=&gt; Boolean">hasNext</a>
      def <a title="()scala.util.matching.Regex.Match" id="scala.util.matching.Regex;MatchIterator.matchData;$anon.next">next</a> = <span class="delimiter">{</span> <a href="#scala.util.matching.Regex;MatchIterator" title="MatchIterator.this.type">self</a>.<a href="#scala.util.matching.Regex;MatchIterator.next" title="()String">next</a><span class="delimiter">(</span><span class="delimiter">)</span>; new <a href="#scala.util.matching.Regex;Match" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchIterator.source" title="=&gt; CharSequence">source</a>, <a href="#scala.util.matching.Regex;MatchIterator.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>, <a href="#scala.util.matching.Regex;MatchIterator.groupNames" title="=&gt; Seq[String]">groupNames</a><span class="delimiter">)</span>.<a href="#scala.util.matching.Regex;Match.force" title="=&gt; scala.util.matching.Regex.Match">force</a> <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Convert to an iterator that yields MatchData elements instead of Strings and has replacement support. */</span>
    private<span class="delimiter">[</span>matching<span class="delimiter">]</span> def <a title="=&gt; scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement" id="scala.util.matching.Regex;MatchIterator.replacementData">replacementData</a> = new <a title="&lt;$anon: scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement&gt; extends scala.collection.AbstractIterator[scala.util.matching.Regex.Match] with scala.util.matching.Regex.Replacement" id="scala.util.matching.Regex;MatchIterator.replacementData;$anon">AbstractIterator</a><span class="delimiter">[</span>Match<span class="delimiter">]</span> with <a href="#scala.util.matching.Regex;Replacement" title="scala.util.matching.Regex.Replacement">Replacement</a> <span class="delimiter">{</span>
      def <a title="=&gt; java.util.regex.Matcher" id="scala.util.matching.Regex;MatchIterator.replacementData;$anon.matcher">matcher</a> = <a href="#scala.util.matching.Regex;MatchIterator" title="MatchIterator.this.type">self</a>.<a href="#scala.util.matching.Regex;MatchIterator.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>
      def <a title="=&gt; Boolean" id="scala.util.matching.Regex;MatchIterator.replacementData;$anon.hasNext">hasNext</a> = <a href="#scala.util.matching.Regex;MatchIterator" title="MatchIterator.this.type">self</a>.<a href="#scala.util.matching.Regex;MatchIterator.hasNext" title="=&gt; Boolean">hasNext</a>
      def <a title="()scala.util.matching.Regex.Match" id="scala.util.matching.Regex;MatchIterator.replacementData;$anon.next">next</a> = <span class="delimiter">{</span> <a href="#scala.util.matching.Regex;MatchIterator" title="MatchIterator.this.type">self</a>.<a href="#scala.util.matching.Regex;MatchIterator.next" title="()String">next</a><span class="delimiter">(</span><span class="delimiter">)</span>; new <a href="#scala.util.matching.Regex;Match" title="scala.util.matching.Regex.Match">Match</a><span class="delimiter">(</span><a href="#scala.util.matching.Regex;MatchIterator.source" title="=&gt; CharSequence">source</a>, <a href="#scala.util.matching.Regex;MatchIterator.replacementData;$anon.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>, <a href="#scala.util.matching.Regex;MatchIterator.groupNames" title="=&gt; Seq[String]">groupNames</a><span class="delimiter">)</span>.<a href="#scala.util.matching.Regex;Match.force" title="=&gt; scala.util.matching.Regex.Match">force</a> <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A trait able to build a string with replacements assuming it has a matcher.
   * Meant to be mixed in with iterators.
   */</span>
  private<span class="delimiter">[</span>matching<span class="delimiter">]</span> trait <a title="trait Replacement extends AnyRef" id="scala.util.matching.Regex;Replacement">Replacement</a> <a href="../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a>
    protected def <a title="=&gt; java.util.regex.Matcher" id="scala.util.matching.Regex;Replacement.matcher">matcher</a>: <span title="java.util.regex.Matcher">Matcher</span>

    private val <a title="StringBuffer" id="scala.util.matching.Regex;Replacement.sb">sb</a> = new java.lang.<span title="StringBuffer">StringBuffer</span>

    def <a title="=&gt; String" id="scala.util.matching.Regex;Replacement.replaced">replaced</a> = <span class="delimiter">{</span>
      val <a title="StringBuffer" id="scala.util.matching.Regex;Replacement.replaced.newsb">newsb</a> = new java.lang.<span title="StringBuffer">StringBuffer</span><span class="delimiter">(</span><a href="#scala.util.matching.Regex;Replacement.sb" title="=&gt; StringBuffer">sb</a><span class="delimiter">)</span>
      <a href="#scala.util.matching.Regex;Replacement.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="(x$1: StringBuffer)StringBuffer">appendTail</span><span class="delimiter">(</span><a href="#scala.util.matching.Regex;Replacement.replaced.newsb" title="StringBuffer">newsb</a><span class="delimiter">)</span>
      <a href="#scala.util.matching.Regex;Replacement.replaced.newsb" title="StringBuffer">newsb</a>.<span title="()String">toString</span>
    <span class="delimiter">}</span>

    def <a title="(rs: String)java.util.regex.Matcher" id="scala.util.matching.Regex;Replacement.replace">replace</a><span class="delimiter">(</span><a title="String" id="scala.util.matching.Regex;Replacement.replace.rs">rs</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#scala.util.matching.Regex;Replacement.matcher" title="=&gt; java.util.regex.Matcher">matcher</a>.<span title="(x$1: StringBuffer, x$2: String)java.util.regex.Matcher">appendReplacement</span><span class="delimiter">(</span><a href="#scala.util.matching.Regex;Replacement.sb" title="=&gt; StringBuffer">sb</a>, <a href="#scala.util.matching.Regex;Replacement.replace.rs" title="String">rs</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Quotes strings to be used literally in regex patterns.
   *
   *  All regex metacharacters in the input match themselves literally in the output.
   *
   *  @example {{{List(&quot;US$&quot;, &quot;CAN$&quot;).map(Regex.quote).mkString(&quot;|&quot;).r}}}
   */</span>
  def <a title="(text: String)String" id="scala.util.matching.Regex.quote">quote</a><span class="delimiter">(</span><a title="String" id="scala.util.matching.Regex.quote.text">text</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span title="java.util.regex.Pattern.type">Pattern</span> <span title="(x$1: String)String">quote</span> <a href="#scala.util.matching.Regex.quote.text" title="String">text</a>

  <span class="comment">/** Quotes replacement strings to be used in replacement methods.
   *
   *  Replacement methods give special meaning to backslashes (`\`) and
   *  dollar signs (`$`) in replacement strings, so they are not treated
   *  as literals. This method escapes these characters so the resulting
   *  string can be used as a literal replacement representing the input
   *  string.
   *
   *  @param text The string one wishes to use as literal replacement.
   *  @return A string that can be used to replace matches with `text`.
   *  @example {{{&quot;CURRENCY&quot;.r.replaceAllIn(input, Regex quoteReplacement &quot;US$&quot;)}}}
   */</span>
  def <a title="(text: String)String" id="scala.util.matching.Regex.quoteReplacement">quoteReplacement</a><span class="delimiter">(</span><a title="String" id="scala.util.matching.Regex.quoteReplacement.text">text</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span title="java.util.regex.Matcher.type">Matcher</span> <span title="(x$1: String)String">quoteReplacement</span> <a href="#scala.util.matching.Regex.quoteReplacement.text" title="String">text</a>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
