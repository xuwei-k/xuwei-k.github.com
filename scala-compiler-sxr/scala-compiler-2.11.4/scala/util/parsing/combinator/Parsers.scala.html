<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/util/parsing/combinator/Parsers.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2006-2013, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

package scala
package util.parsing.combinator

import scala.util.parsing.input._
import scala.collection.mutable.ListBuffer
import scala.annotation.tailrec
import scala.annotation.migration
import scala.<a href="../../../language.scala.html#scala.language" title="language.type">language</a>.implicitConversions
import scala.util.DynamicVariable

<span class="comment">// TODO: better error handling (labelling like parsec's &lt;?&gt;)</span>

<span class="comment">/** `Parsers` is a component that ''provides'' generic parser combinators.
 *
 *  There are two abstract members that must be defined in order to
 *  produce parsers: the type `Elem` and
 *  [[scala.util.parsing.combinator.Parsers.Parser]]. There are helper
 *  methods that produce concrete `Parser` implementations -- see ''primitive
 *  parser'' below.
 *
 *  A `Parsers` may define multiple `Parser` instances, which are combined
 *  to produced the desired parser.
 *
 *  The type of the elements these parsers should parse must be defined
 *  by declaring `Elem`
 *  (each parser is polymorphic in the type of result it produces).
 *
 *  There are two aspects to the result of a parser:
 *  1. success or failure
 *  1. the result.
 *
 *  A [[scala.util.parsing.combinator.Parsers.Parser]] produces both kinds of information,
 *  by returning a [[scala.util.parsing.combinator.Parsers.ParseResult]] when its `apply`
 *  method is called on an input.
 *
 *  The term ''parser combinator'' refers to the fact that these parsers
 *  are constructed from primitive parsers and composition operators, such
 *  as sequencing, alternation, optionality, repetition, lifting, and so on. For example,
 *  given `p1` and `p2` of type [[scala.util.parsing.combinator.Parsers.Parser]]:
 *
 *  {{{
 *  p1 ~ p2 // sequencing: must match p1 followed by p2
 *  p1 | p2 // alternation: must match either p1 or p2, with preference given to p1
 *  p1.?    // optionality: may match p1 or not
 *  p1.*    // repetition: matches any number of repetitions of p1
 *  }}}
 *
 *  These combinators are provided as methods on [[scala.util.parsing.combinator.Parsers.Parser]],
 *  or as methods taking one or more `Parsers` and returning a `Parser` provided in
 *  this class.
 *
 *  A ''primitive parser'' is a parser that accepts or rejects a single
 *  piece of input, based on a certain criterion, such as whether the
 *  input...
 *  - is equal to some given object (see method `accept`),
 *  - satisfies a certain predicate (see method `acceptIf`),
 *  - is in the domain of a given partial function (see method `acceptMatch`)
 *  - or other conditions, by using one of the other methods available, or subclassing `Parser`
 *
 *  Even more primitive parsers always produce the same result, irrespective of the input. See
 *  methods `success`, `err` and `failure` as examples.
 *
 *  @see [[scala.util.parsing.combinator.RegexParsers]] and other known subclasses for practical examples.
 *
 *  @author Martin Odersky
 *  @author Iulian Dragos
 *  @author Adriaan Moors
 */</span>
trait <a title="trait Parsers extends AnyRef" id="scala.util.parsing.combinator;Parsers">Parsers</a> <a href="../../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a>
  <span class="comment">/** the type of input elements the provided parsers consume (When consuming
   *  invidual characters, a parser is typically called a ''scanner'', which
   *  produces ''tokens'' that are consumed by what is normally called a ''parser''.
   *  Nonetheless, the same principles apply, regardless of the input type.) */</span>
  type <a title="" id="scala.util.parsing.combinator;Parsers;Elem">Elem</a>

  <span class="comment">/** The parser input is an abstract reader of input elements, i.e. the type
   *  of input the parsers in this component expect. */</span>
  type <a title="scala.util.parsing.input.Reader[Parsers.this.Elem]" id="scala.util.parsing.combinator;Parsers;Input">Input</a> = <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="scala.util.parsing.input.Reader[Parsers.this.Elem]">Reader</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span>

  <span class="comment">/** A base class for parser results. A result is either successful or not
   *  (failure may be fatal, i.e., an Error, or not, i.e., a Failure). On
   *  success, provides a result of type `T` which consists of some result
   *  (and the rest of the input). */</span>
  sealed abstract class <a title="class ParseResult[+T] extends AnyRef" id="scala.util.parsing.combinator;Parsers;ParseResult">ParseResult</a><span class="delimiter">[</span>+<a title="" id="scala.util.parsing.combinator;Parsers;ParseResult;T">T</a><span class="delimiter">]</span> <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[T]" class="delimiter">{</a>
    <span class="comment">/** Functional composition of ParseResults.
     *
     * @param f the function to be lifted over this result
     * @return `f` applied to the result of this `ParseResult`, packaged up as a new `ParseResult`
     */</span>
    def <a title="[U](f: T =&gt; U)Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;ParseResult.map">map</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;ParseResult.map;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; U" id="scala.util.parsing.combinator;Parsers;ParseResult.map.f">f</a>: T =&gt; U<span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span>

    <span class="comment">/** Partial functional composition of ParseResults.
     *
     * @param f the partial function to be lifted over this result
     * @param error a function that takes the same argument as `f` and
     *        produces an error message to explain why `f` wasn't applicable
     *        (it is called when this is the case)
     * @return if `f` f is defined at the result in this `ParseResult`, `f`
     *         applied to the result of this `ParseResult`, packaged up as
     *         a new `ParseResult`. If `f` is not defined, `Failure`.
     */</span>
    def <a title="[U](f: PartialFunction[T,U], error: T =&gt; String)Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;ParseResult.mapPartial">mapPartial</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;ParseResult.mapPartial;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[T,U]" id="scala.util.parsing.combinator;Parsers;ParseResult.mapPartial.f">f</a>: <a href="../../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[T,U]">PartialFunction</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span>, <a title="T =&gt; String" id="scala.util.parsing.combinator;Parsers;ParseResult.mapPartial.error">error</a>: T =&gt; String<span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span>

    def <a title="[U](f: T =&gt; (Parsers.this.Input =&gt; Parsers.this.ParseResult[U]))Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;ParseResult.flatMapWithNext">flatMapWithNext</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;ParseResult.flatMapWithNext;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; (Parsers.this.Input =&gt; Parsers.this.ParseResult[U])" id="scala.util.parsing.combinator;Parsers;ParseResult.flatMapWithNext.f">f</a>: T =&gt; Input =&gt; ParseResult<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span>

    def <a title="(p: T =&gt; Boolean, error: T =&gt; String, position: Parsers.this.Input)Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers;ParseResult.filterWithError">filterWithError</a><span class="delimiter">(</span><a title="T =&gt; Boolean" id="scala.util.parsing.combinator;Parsers;ParseResult.filterWithError.p">p</a>: T =&gt; Boolean, <a title="T =&gt; String" id="scala.util.parsing.combinator;Parsers;ParseResult.filterWithError.error">error</a>: T =&gt; String, <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;ParseResult.filterWithError.position">position</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

    def <a title="[U &gt;: T](a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;ParseResult.append">append</a><span class="delimiter">[</span><a title=" &gt;: T" id="scala.util.parsing.combinator;Parsers;ParseResult.append;U">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;ParseResult.append.a">a</a>: =&gt; ParseResult<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span>

    def <a title="=&gt; Boolean" id="scala.util.parsing.combinator;Parsers;ParseResult.isEmpty">isEmpty</a> = <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.util.parsing.combinator;Parsers;ParseResult.successful" title="=&gt; Boolean">successful</a>

    <span class="comment">/** Returns the embedded result. */</span>
    def <a title="=&gt; T" id="scala.util.parsing.combinator;Parsers;ParseResult.get">get</a>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult;T" title="T">T</a>

    def <a title="[B &gt;: T](default: =&gt; B)B" id="scala.util.parsing.combinator;Parsers;ParseResult.getOrElse">getOrElse</a><span class="delimiter">[</span><a title=" &gt;: T" id="scala.util.parsing.combinator;Parsers;ParseResult.getOrElse;B">B</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; B" id="scala.util.parsing.combinator;Parsers;ParseResult.getOrElse.default">default</a>: =&gt; B<span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult.getOrElse;B" title="B">B</a> =
        if <span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;ParseResult.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers;ParseResult.getOrElse.default" title="=&gt; B">default</a> else this.<a href="#scala.util.parsing.combinator;Parsers;ParseResult.get" title="=&gt; T">get</a>

    val <a title="=&gt; Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;ParseResult.next">next</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a>

    val <a title="=&gt; Boolean" id="scala.util.parsing.combinator;Parsers;ParseResult.successful">successful</a>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The success case of `ParseResult`: contains the result and the remaining input.
   *
   *  @param result The parser's output
   *  @param next   The parser's remaining input
   */</span>
  case class <a href="#scala.util.parsing.combinator;Parsers;Success.productElement.x$1" title="class Success[+T] extends Parsers.this.ParseResult[T] with Product with Serializable" id="scala.util.parsing.combinator;Parsers.Success.readResolve">Success</a><span class="delimiter">[</span>+<a title="" id="scala.util.parsing.combinator;Parsers;Success;T">T</a><span class="delimiter">]</span><a href="../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="T" id="scala.util.parsing.combinator;Parsers;Success.result">result</a>: <a href="#scala.util.parsing.combinator;Parsers;Success;T" title="T">T</a>, override val <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Success.next">next</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> extends <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="[U](f: T =&gt; U)Parsers.this.Success[U]" id="scala.util.parsing.combinator;Parsers;Success.map">map</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Success.map;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; U" id="scala.util.parsing.combinator;Parsers;Success.map.f">f</a>: T =&gt; U<span class="delimiter">)</span> = <a href="#scala.util.parsing.combinator;Parsers.Success.readResolve" title="(result: U, next: Parsers.this.Input)Parsers.this.Success[U]">Success</a><span class="delimiter">(</span><a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: T)U">f</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Success.result" title="=&gt; T">result</a><span class="delimiter">)</span>, <a href="#scala.util.parsing.combinator;Parsers;Success.next" title="=&gt; Parsers.this.Input">next</a><span class="delimiter">)</span>
    def <a title="[U](f: PartialFunction[T,U], error: T =&gt; String)Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;Success.mapPartial">mapPartial</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Success.mapPartial;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[T,U]" id="scala.util.parsing.combinator;Parsers;Success.mapPartial.f">f</a>: <a href="../../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[T,U]">PartialFunction</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span>, <a title="T =&gt; String" id="scala.util.parsing.combinator;Parsers;Success.mapPartial.error">error</a>: T =&gt; String<span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span>
       = if<span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Success.mapPartial.f" title="PartialFunction[T,U]">f</a>.<a href="../../../PartialFunction.scala.html#scala;PartialFunction.isDefinedAt" title="(x: T)Boolean">isDefinedAt</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Success.result" title="=&gt; T">result</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers.Success.readResolve" title="(result: U, next: Parsers.this.Input)Parsers.this.Success[U]">Success</a><span class="delimiter">(</span><a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: T)U">f</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Success.result" title="=&gt; T">result</a><span class="delimiter">)</span>, <a href="#scala.util.parsing.combinator;Parsers;Success.next" title="=&gt; Parsers.this.Input">next</a><span class="delimiter">)</span>
         else <a href="#scala.util.parsing.combinator;Parsers.Failure.readResolve" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: T)String">error</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Success.result" title="=&gt; T">result</a><span class="delimiter">)</span>, <a href="#scala.util.parsing.combinator;Parsers;Success.next" title="=&gt; Parsers.this.Input">next</a><span class="delimiter">)</span>

    def <a title="[U](f: T =&gt; (Parsers.this.Input =&gt; Parsers.this.ParseResult[U]))Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;Success.flatMapWithNext">flatMapWithNext</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Success.flatMapWithNext;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; (Parsers.this.Input =&gt; Parsers.this.ParseResult[U])" id="scala.util.parsing.combinator;Parsers;Success.flatMapWithNext.f">f</a>: T =&gt; Input =&gt; ParseResult<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span>
      = <a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: T)Parsers.this.Input =&gt; Parsers.this.ParseResult[U]">f</a><a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: Parsers.this.Input)Parsers.this.ParseResult[U]" class="delimiter">(</a><a href="#scala.util.parsing.combinator;Parsers;Success.result" title="=&gt; T">result</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Success.next" title="=&gt; Parsers.this.Input">next</a><span class="delimiter">)</span>

    def <a title="(p: T =&gt; Boolean, error: T =&gt; String, position: Parsers.this.Input)Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers;Success.filterWithError">filterWithError</a><span class="delimiter">(</span><a title="T =&gt; Boolean" id="scala.util.parsing.combinator;Parsers;Success.filterWithError.p">p</a>: T =&gt; Boolean, <a title="T =&gt; String" id="scala.util.parsing.combinator;Parsers;Success.filterWithError.error">error</a>: T =&gt; String, <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Success.filterWithError.position">position</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: T)Boolean">p</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Success.result" title="=&gt; T">result</a><span class="delimiter">)</span><span class="delimiter">)</span> this
      else <a href="#scala.util.parsing.combinator;Parsers.Failure.readResolve" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: T)String">error</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Success.result" title="=&gt; T">result</a><span class="delimiter">)</span>, <a href="#scala.util.parsing.combinator;Parsers;Success.filterWithError.position" title="Parsers.this.Input">position</a><span class="delimiter">)</span>

    def <a title="[U &gt;: T](a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;Success.append">append</a><span class="delimiter">[</span><a title=" &gt;: T" id="scala.util.parsing.combinator;Parsers;Success.append;U">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;Success.append.a">a</a>: =&gt; ParseResult<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = this

    def <a title="=&gt; T" id="scala.util.parsing.combinator;Parsers;Success.get">get</a>: <a href="#scala.util.parsing.combinator;Parsers;Success;T" title="T">T</a> = <a href="#scala.util.parsing.combinator;Parsers;Success.result" title="=&gt; T">result</a>

    <span class="comment">/** The toString method of a Success. */</span>
    override def <a title="()String" id="scala.util.parsing.combinator;Parsers;Success.toString">toString</a> = <span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.util.parsing.combinator;Parsers;Success.next" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a><span title="(x$1: Any)String">+</span><span title="String(&quot;] parsed: &quot;)" class="string">&quot;] parsed: &quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.util.parsing.combinator;Parsers;Success.result" title="=&gt; T">result</a>

    val <a title="Boolean" id="scala.util.parsing.combinator;Parsers;Success.successful">successful</a> = true
  <span class="delimiter">}</span>

  private lazy val <a title="scala.util.DynamicVariable[Option[Parsers.this.NoSuccess]]" id="scala.util.parsing.combinator;Parsers.lastNoSuccessVar">lastNoSuccessVar</a> = new <a href="../../DynamicVariable.scala.html#scala.util;DynamicVariable" title="scala.util.DynamicVariable[Option[Parsers.this.NoSuccess]]">DynamicVariable</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>NoSuccess<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="../../../Option.scala.html#scala.None" title="None.type">None</a><span class="delimiter">)</span>

  <span class="comment">/** A common super-class for unsuccessful parse results. */</span>
  sealed abstract class <a title="class NoSuccess extends Parsers.this.ParseResult[Nothing]" id="scala.util.parsing.combinator;Parsers;NoSuccess">NoSuccess</a><a href="#scala.util.parsing.combinator;Parsers;NoSuccess" title="Parsers.this.NoSuccess" class="delimiter">(</a>val <a title="String" id="scala.util.parsing.combinator;Parsers;NoSuccess.msg">msg</a>: <span title="String">String</span>, override val <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;NoSuccess.next">next</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> extends <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[Nothing]">ParseResult</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="comment">// when we don't care about the difference between Failure and Error</span>
    val <a title="Boolean" id="scala.util.parsing.combinator;Parsers;NoSuccess.successful">successful</a> = false

    if <span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.lastNoSuccessVar" title="=&gt; scala.util.DynamicVariable[Option[Parsers.this.NoSuccess]]">lastNoSuccessVar</a>.<a href="../../DynamicVariable.scala.html#scala.util;DynamicVariable.value" title="=&gt; Option[Parsers.this.NoSuccess]">value</a> <a href="../../../Option.scala.html#scala;Option.forall" title="(p: Parsers.this.NoSuccess =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a title="Parsers.this.NoSuccess" id="scala.util.parsing.combinator;Parsers;NoSuccess.<local NoSuccess>.$anonfun.v">v</a> =&gt; <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;NoSuccess.next" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a> <a href="../input/Position.scala.html#scala.util.parsing.input;Position.<" title="(that: scala.util.parsing.input.Position)Boolean">&lt;</a> <a href="#scala.util.parsing.combinator;Parsers;NoSuccess.<local NoSuccess>.$anonfun.v" title="Parsers.this.NoSuccess">v</a>.<a href="#scala.util.parsing.combinator;Parsers;NoSuccess.next" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#scala.util.parsing.combinator;Parsers.lastNoSuccessVar" title="=&gt; scala.util.DynamicVariable[Option[Parsers.this.NoSuccess]]">lastNoSuccessVar</a>.<a href="../../DynamicVariable.scala.html#scala.util;DynamicVariable.value_=" title="(newval: Option[Parsers.this.NoSuccess])Unit">value</a> = <a href="../../../Option.scala.html#scala;Some" title="(x: Parsers.this.NoSuccess)Some[Parsers.this.NoSuccess]">Some</a><span class="delimiter">(</span>this<span class="delimiter">)</span>

    def <a title="[U](f: Nothing =&gt; U)Parsers.this.NoSuccess" id="scala.util.parsing.combinator;Parsers;NoSuccess.map">map</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;NoSuccess.map;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Nothing =&gt; U" id="scala.util.parsing.combinator;Parsers;NoSuccess.map.f">f</a>: Nothing =&gt; U<span class="delimiter">)</span> = this
    def <a title="[U](f: PartialFunction[Nothing,U], error: Nothing =&gt; String)Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;NoSuccess.mapPartial">mapPartial</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;NoSuccess.mapPartial;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[Nothing,U]" id="scala.util.parsing.combinator;Parsers;NoSuccess.mapPartial.f">f</a>: <a href="../../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[Nothing,U]">PartialFunction</a><span class="delimiter">[</span>Nothing, U<span class="delimiter">]</span>, <a title="Nothing =&gt; String" id="scala.util.parsing.combinator;Parsers;NoSuccess.mapPartial.error">error</a>: Nothing =&gt; String<span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = this

    def <a title="[U](f: Nothing =&gt; (Parsers.this.Input =&gt; Parsers.this.ParseResult[U]))Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;NoSuccess.flatMapWithNext">flatMapWithNext</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;NoSuccess.flatMapWithNext;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Nothing =&gt; (Parsers.this.Input =&gt; Parsers.this.ParseResult[U])" id="scala.util.parsing.combinator;Parsers;NoSuccess.flatMapWithNext.f">f</a>: Nothing =&gt; Input =&gt; ParseResult<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span>
      = this

    def <a title="(p: Nothing =&gt; Boolean, error: Nothing =&gt; String, position: Parsers.this.Input)Parsers.this.ParseResult[Nothing]" id="scala.util.parsing.combinator;Parsers;NoSuccess.filterWithError">filterWithError</a><span class="delimiter">(</span><a title="Nothing =&gt; Boolean" id="scala.util.parsing.combinator;Parsers;NoSuccess.filterWithError.p">p</a>: Nothing =&gt; Boolean, <a title="Nothing =&gt; String" id="scala.util.parsing.combinator;Parsers;NoSuccess.filterWithError.error">error</a>: Nothing =&gt; String, <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;NoSuccess.filterWithError.position">position</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[Nothing]">ParseResult</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> = this

    def <a title="=&gt; Nothing" id="scala.util.parsing.combinator;Parsers;NoSuccess.get">get</a>: <span title="Nothing">Nothing</span> = scala.sys.<a href="../../../sys/package.scala.html#scala.sys.package.error" title="(message: String)Nothing">error</a><span class="delimiter">(</span><span title="String(&quot;No result when parsing failed&quot;)" class="string">&quot;No result when parsing failed&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/** An extractor so `NoSuccess(msg, next)` can be used in matches. */</span>
  object <a title="Parsers.this.NoSuccess.type" id="scala.util.parsing.combinator;Parsers.NoSuccess">NoSuccess</a> <a href="#scala.util.parsing.combinator;Parsers.NoSuccess" title="Parsers.this.NoSuccess.type" class="delimiter">{</a>
    def <a title="[T](x: Parsers.this.ParseResult[T])Option[(String, Parsers.this.Input)]" id="scala.util.parsing.combinator;Parsers.NoSuccess.unapply">unapply</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.NoSuccess.unapply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers.NoSuccess.unapply.x">x</a>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#scala.util.parsing.combinator;Parsers.NoSuccess.unapply.x" title="Parsers.this.ParseResult[T]">x</a> match <span class="delimiter">{</span>
      case Failure<span class="delimiter">(</span><span title="String">msg</span>, <span title="Parsers.this.Input">next</span><span class="delimiter">)</span>   =&gt; <a href="../../../Option.scala.html#scala;Some" title="(x: (String, Parsers.this.Input))Some[(String, Parsers.this.Input)]">Some</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#scala;Tuple2" title="(_1: String, _2: Parsers.this.Input)(String, Parsers.this.Input)" class="delimiter">(</a><span title="String">msg</span>, <span title="Parsers.this.Input">next</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case Error<span class="delimiter">(</span><span title="String">msg</span>, <span title="Parsers.this.Input">next</span><span class="delimiter">)</span>     =&gt; <a href="../../../Option.scala.html#scala;Some" title="(x: (String, Parsers.this.Input))Some[(String, Parsers.this.Input)]">Some</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#scala;Tuple2" title="(_1: String, _2: Parsers.this.Input)(String, Parsers.this.Input)" class="delimiter">(</a><span title="String">msg</span>, <span title="Parsers.this.Input">next</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case _                    =&gt; <a href="../../../Option.scala.html#scala.None" title="None.type">None</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The failure case of `ParseResult`: contains an error-message and the remaining input.
   *  Parsing will back-track when a failure occurs.
   *
   *  @param msg    An error message string describing the failure.
   *  @param next   The parser's unconsumed input at the point where the failure occurred.
   */</span>
  case class <a title="class Failure extends Parsers.this.NoSuccess with Product with Serializable" id="scala.util.parsing.combinator;Parsers.Failure.readResolve">Failure</a><a href="../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a>override val <a title="String" id="scala.util.parsing.combinator;Parsers;Failure.msg">msg</a>: <span title="String">String</span>, override val <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Failure.next">next</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> extends <a href="#scala.util.parsing.combinator;Parsers;NoSuccess" title="Parsers.this.NoSuccess">NoSuccess</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Failure.msg" title="String">msg</a>, <a href="#scala.util.parsing.combinator;Parsers;Failure.next" title="Parsers.this.Input">next</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">/** The toString method of a Failure yields an error message. */</span>
    override def <a title="()String" id="scala.util.parsing.combinator;Parsers;Failure.toString">toString</a> = <span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.util.parsing.combinator;Parsers;Failure.next" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a><span title="(x$1: Any)String">+</span><span title="String(&quot;] failure: &quot;)" class="string">&quot;] failure: &quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.util.parsing.combinator;Parsers;Failure.msg" title="=&gt; String">msg</a><span title="(x$1: Any)String">+</span><span title="String(&quot;\n\n&quot;)" class="string">&quot;\n\n&quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.util.parsing.combinator;Parsers;Failure.next" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a>.<a href="../input/Position.scala.html#scala.util.parsing.input;Position.longString" title="=&gt; String">longString</a>

    def <a title="[U](a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;Failure.append">append</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Failure.append;U">U</a> &gt;: Nothing<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;Failure.append.a">a</a>: =&gt; ParseResult<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <span class="delimiter">{</span> val <a title="Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;Failure.append.alt">alt</a> = <a href="#scala.util.parsing.combinator;Parsers;Failure.append.a" title="=&gt; Parsers.this.ParseResult[U]">a</a>; <a href="#scala.util.parsing.combinator;Parsers;Failure.append.alt" title="Parsers.this.ParseResult[U]">alt</a> match <span class="delimiter">{</span>
      case Success<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;Parsers;Failure.append.alt" title="Parsers.this.ParseResult[U]">alt</a>
      case <a title="Parsers.this.NoSuccess" id="scala.util.parsing.combinator;Parsers;Failure.append.ns">ns</a>: <a href="#scala.util.parsing.combinator;Parsers;NoSuccess" title="Parsers.this.NoSuccess">NoSuccess</a> =&gt; if <span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Failure.append.alt" title="Parsers.this.ParseResult[U]">alt</a>.<a href="#scala.util.parsing.combinator;Parsers;ParseResult.next" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a> <a href="../input/Position.scala.html#scala.util.parsing.input;Position.<" title="(that: scala.util.parsing.input.Position)Boolean">&lt;</a> <a href="#scala.util.parsing.combinator;Parsers;Failure.next" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span> this else <a href="#scala.util.parsing.combinator;Parsers;Failure.append.alt" title="Parsers.this.ParseResult[U]">alt</a>
    <span class="delimiter">}</span><span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The fatal failure case of ParseResult: contains an error-message and
   *  the remaining input.
   *  No back-tracking is done when a parser returns an `Error`.
   *
   *  @param msg    An error message string describing the error.
   *  @param next   The parser's unconsumed input at the point where the error occurred.
   */</span>
  case class <a title="class Error extends Parsers.this.NoSuccess with Product with Serializable" id="scala.util.parsing.combinator;Parsers.Error.readResolve">Error</a><a href="../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a>override val <a title="String" id="scala.util.parsing.combinator;Parsers;Error.msg">msg</a>: <span title="String">String</span>, override val <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Error.next">next</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> extends <a href="#scala.util.parsing.combinator;Parsers;NoSuccess" title="Parsers.this.NoSuccess">NoSuccess</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Error.msg" title="String">msg</a>, <a href="#scala.util.parsing.combinator;Parsers;Error.next" title="Parsers.this.Input">next</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">/** The toString method of an Error yields an error message. */</span>
    override def <a title="()String" id="scala.util.parsing.combinator;Parsers;Error.toString">toString</a> = <span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.util.parsing.combinator;Parsers;Error.next" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a><span title="(x$1: Any)String">+</span><span title="String(&quot;] error: &quot;)" class="string">&quot;] error: &quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.util.parsing.combinator;Parsers;Error.msg" title="=&gt; String">msg</a><span title="(x$1: Any)String">+</span><span title="String(&quot;\n\n&quot;)" class="string">&quot;\n\n&quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.util.parsing.combinator;Parsers;Error.next" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a>.<a href="../input/Position.scala.html#scala.util.parsing.input;Position.longString" title="=&gt; String">longString</a>
    def <a title="[U](a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;Error.append">append</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Error.append;U">U</a> &gt;: Nothing<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;Error.append.a">a</a>: =&gt; ParseResult<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[U]">ParseResult</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = this
  <span class="delimiter">}</span>

  def <a title="[T](f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.Parser">Parser</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.Parser;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Parsers.this.Input =&gt; Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers.Parser.f">f</a>: Input =&gt; ParseResult<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
    = new <a title="&lt;$anon: Parsers.this.Input =&gt; Parsers.this.ParseResult[T]&gt; extends Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.Parser;$anon">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">{</span> def <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers.Parser;$anon.apply">apply</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.Parser;$anon.apply.in">in</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> = <a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: Parsers.this.Input)Parsers.this.ParseResult[T]">f</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.Parser;$anon.apply.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  def <a title="[T](f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T] with Parsers.this.OnceParser[T]" id="scala.util.parsing.combinator;Parsers.OnceParser">OnceParser</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.OnceParser;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Parsers.this.Input =&gt; Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers.OnceParser.f">f</a>: Input =&gt; ParseResult<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;<refinement>" title="&lt;refinement of Parsers.this.Input =&gt; Parsers.this.ParseResult[T] with Parsers.this.Input =&gt; Parsers.this.ParseResult[T]&gt; extends Parsers.this.Parser[T] with Parsers.this.OnceParser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> with OnceParser<span class="delimiter">[</span>T<span class="delimiter">]</span>
    = new <a title="&lt;$anon: Parsers.this.Input =&gt; Parsers.this.ParseResult[T] with Parsers.this.Input =&gt; Parsers.this.ParseResult[T]&gt; extends Parsers.this.Parser[T] with Parsers.this.OnceParser[T]" id="scala.util.parsing.combinator;Parsers.OnceParser;$anon">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> with <a href="#scala.util.parsing.combinator;Parsers;OnceParser" title="Parsers.this.OnceParser[T]">OnceParser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> def <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers.OnceParser;$anon.apply">apply</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.OnceParser;$anon.apply.in">in</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> = <a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: Parsers.this.Input)Parsers.this.ParseResult[T]">f</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.OnceParser;$anon.apply.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/** The root class of parsers.
   *  Parsers are functions from the Input type to ParseResult.
   */</span>
  abstract class <a title="class Parser[+T] extends AnyRef with Parsers.this.Input =&gt; Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers;Parser">Parser</a><span class="delimiter">[</span>+<a title="" id="scala.util.parsing.combinator;Parsers;Parser;T">T</a><span class="delimiter">]</span> extends <span class="delimiter">(</span>Input =&gt; ParseResult<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    private var <a title="String" id="scala.util.parsing.combinator;Parsers;Parser.name_=">name</a>: <span title="String">String</span> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    def <a title="(n: String)Parser.this.type" id="scala.util.parsing.combinator;Parsers;Parser.named">named</a><span class="delimiter">(</span><a title="String" id="scala.util.parsing.combinator;Parsers;Parser.named.n">n</a>: <span title="String">String</span><span class="delimiter">)</span>: this.type = <span class="delimiter">{</span><a href="#scala.util.parsing.combinator;Parsers;Parser.name_=" title="(x$1: String)Unit">name</a>=<a href="#scala.util.parsing.combinator;Parsers;Parser.named.n" title="String">n</a>; this<span class="delimiter">}</span>
    override def <a title="()String" id="scala.util.parsing.combinator;Parsers;Parser.toString">toString</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span title="String(&quot;Parser (&quot;)" class="string">&quot;Parser (&quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.util.parsing.combinator;Parsers;Parser.name_=" title="=&gt; String">name</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>

    <span class="comment">/** An unspecified method that defines the behaviour of this parser. */</span>
    def <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers;Parser.apply">apply</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Parser.apply.in">in</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[T]">ParseResult</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

    def <a title="[U](f: T =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.flatMap">flatMap</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Parser.flatMap;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.flatMap.f">f</a>: T =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span>
      = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Parser.flatMap.$anonfun.in">in</a> =&gt; this<span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.flatMap.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers;ParseResult.flatMapWithNext" title="(f: T =&gt; (Parsers.this.Input =&gt; Parsers.this.ParseResult[U]))Parsers.this.ParseResult[U]">flatMapWithNext</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.flatMap.f" title="T =&gt; Parsers.this.Parser[U]">f</a><span class="delimiter">)</span><span class="delimiter">}</span>

    def <a title="[U](f: T =&gt; U)Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.map">map</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Parser.map;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; U" id="scala.util.parsing.combinator;Parsers;Parser.map.f">f</a>: T =&gt; U<span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> <span class="comment">//= flatMap{x =&gt; success(f(x))}</span>
      = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Parser.map.$anonfun.in">in</a> =&gt; this<span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.map.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers;ParseResult.map" title="(f: T =&gt; U)Parsers.this.ParseResult[U]">map</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.map.f" title="T =&gt; U">f</a><span class="delimiter">)</span><span class="delimiter">}</span>

    def <a title="(p: T =&gt; Boolean)Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers;Parser.filter">filter</a><span class="delimiter">(</span><a title="T =&gt; Boolean" id="scala.util.parsing.combinator;Parsers;Parser.filter.p">p</a>: T =&gt; Boolean<span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
      = <a href="#scala.util.parsing.combinator;Parsers;Parser.withFilter" title="(p: T =&gt; Boolean)Parsers.this.Parser[T]">withFilter</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.filter.p" title="T =&gt; Boolean">p</a><span class="delimiter">)</span>

    def <a title="(p: T =&gt; Boolean)Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers;Parser.withFilter">withFilter</a><span class="delimiter">(</span><a title="T =&gt; Boolean" id="scala.util.parsing.combinator;Parsers;Parser.withFilter.p">p</a>: T =&gt; Boolean<span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
      = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Parser.withFilter.$anonfun.in">in</a> =&gt; this<span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.withFilter.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers;ParseResult.filterWithError" title="(p: T =&gt; Boolean, error: T =&gt; String, position: Parsers.this.Input)Parsers.this.ParseResult[T]">filterWithError</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.withFilter.p" title="T =&gt; Boolean">p</a>, <span title="String(&quot;Input doesn\'t match filter: &quot;)" class="string">&quot;Input doesn't match filter: &quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.util.parsing.combinator;Parsers;Parser.withFilter.$anonfun.$anonfun.x$1" title="T">_</a>, <a href="#scala.util.parsing.combinator;Parsers;Parser.withFilter.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span><span class="delimiter">}</span>

    <span class="comment">// no filter yet, dealing with zero is tricky!</span>

    @migration<span class="delimiter">(</span><span class="string">&quot;The call-by-name argument is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.&quot;</span>, <span class="string">&quot;2.9.0&quot;</span><span class="delimiter">)</span>
    def <a title="[U &gt;: T](p0: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.append">append</a><span class="delimiter">[</span><a title=" &gt;: T" id="scala.util.parsing.combinator;Parsers;Parser.append;U">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.append.p0">p0</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <span class="delimiter">{</span> lazy val <a title="Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.append.p">p</a> = <a href="#scala.util.parsing.combinator;Parsers;Parser.append.p0" title="=&gt; Parsers.this.Parser[U]">p0</a> <span class="comment">// lazy argument</span>
      <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Parser.append.$anonfun.in">in</a> =&gt; this<span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.append.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers;ParseResult.append" title="(a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]">append</a> <a href="#scala.util.parsing.combinator;Parsers;Parser.apply" title="(in: Parsers.this.Input)Parsers.this.ParseResult[U]">p</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.append.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span><span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">// the operator formerly known as +++, ++, &amp;, but now, behold the venerable ~</span>
    <span class="comment">// it's short, light (looks like whitespace), has few overloaded meaning (thanks to the recent change from ~ to unary_~)</span>
    <span class="comment">// and we love it! (or do we like `,` better?)</span>

    <span class="comment">/** A parser combinator for sequential composition.
     *
     * `p ~ q` succeeds if `p` succeeds and `q` succeeds on the input left over by `p`.
     *
     * @param q a parser that will be executed after `p` (this parser)
     *          succeeds -- evaluated at most once, and only when necessary.
     * @return a `Parser` that -- on success -- returns a `~` (like a `Pair`,
     *         but easier to pattern match on) that contains the result of `p` and
     *         that of `q`. The resulting parser fails if either `p` or `q` fails.
     */</span>
    @migration<span class="delimiter">(</span><span class="string">&quot;The call-by-name argument is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.&quot;</span>, <span class="string">&quot;2.9.0&quot;</span><span class="delimiter">)</span>
    def <a title="[U](q: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[T,U]]" id="scala.util.parsing.combinator;Parsers;Parser.~">~</a> <span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Parser.~;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.~.q">q</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[Parsers.this.~[T,U]]">Parser</a><span class="delimiter">[</span>~<span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span> lazy val <a title="Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.~.p">p</a> = <a href="#scala.util.parsing.combinator;Parsers;Parser.~.q" title="=&gt; Parsers.this.Parser[U]">q</a> <span class="comment">// lazy argument</span>
      <span class="delimiter">(</span>for<span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers;Parser.~.$anonfun.a">a</a> &lt;- this; <a title="U" id="scala.util.parsing.combinator;Parsers;Parser.~.$anonfun.$anonfun.b">b</a> &lt;- <a href="#scala.util.parsing.combinator;Parsers;Parser.map" title="(f: U =&gt; Parsers.this.~[T,U])Parsers.this.Parser[Parsers.this.~[T,U]]">p</a><span class="delimiter">)</span> yield new <a href="#scala.util.parsing.combinator;Parsers.~.readResolve" title="Parsers.this.~[T,U]">~</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.~.$anonfun.a" title="T">a</a>,<a href="#scala.util.parsing.combinator;Parsers;Parser.~.$anonfun.$anonfun.b" title="U">b</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#scala.util.parsing.combinator;Parsers;Parser.named" title="(n: String)Parsers.this.Parser[Parsers.this.~[T,U]]">named</a><span class="delimiter">(</span><span title="String(&quot;~&quot;)" class="string">&quot;~&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** A parser combinator for sequential composition which keeps only the right result.
     *
     * `p ~&gt; q` succeeds if `p` succeeds and `q` succeeds on the input left over by `p`.
     *
     * @param q a parser that will be executed after `p` (this parser)
     *        succeeds -- evaluated at most once, and only when necessary.
     * @return a `Parser` that -- on success -- returns the result of `q`.
     */</span>
    @migration<span class="delimiter">(</span><span class="string">&quot;The call-by-name argument is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.&quot;</span>, <span class="string">&quot;2.9.0&quot;</span><span class="delimiter">)</span>
    def <a title="[U](q: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.~>">~&gt;</a> <span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Parser.~>;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.~>.q">q</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <span class="delimiter">{</span> lazy val <a title="Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.~>.p">p</a> = <a href="#scala.util.parsing.combinator;Parsers;Parser.~>.q" title="=&gt; Parsers.this.Parser[U]">q</a> <span class="comment">// lazy argument</span>
      <span class="delimiter">(</span>for<span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers;Parser.~>.$anonfun.a">a</a> &lt;- this; <a title="U" id="scala.util.parsing.combinator;Parsers;Parser.~>.$anonfun.$anonfun.b">b</a> &lt;- <a href="#scala.util.parsing.combinator;Parsers;Parser.map" title="(f: U =&gt; U)Parsers.this.Parser[U]">p</a><span class="delimiter">)</span> yield <a href="#scala.util.parsing.combinator;Parsers;Parser.~>.$anonfun.$anonfun.b" title="U">b</a><span class="delimiter">)</span>.<a href="#scala.util.parsing.combinator;Parsers;Parser.named" title="(n: String)Parsers.this.Parser[U]">named</a><span class="delimiter">(</span><span title="String(&quot;~&gt;&quot;)" class="string">&quot;~&gt;&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** A parser combinator for sequential composition which keeps only the left result.
     *
     *  `p &lt;~ q` succeeds if `p` succeeds and `q` succeeds on the input
     *           left over by `p`.
     *
     * @note &lt;~ has lower operator precedence than ~ or ~&gt;.
     *
     * @param q a parser that will be executed after `p` (this parser) succeeds -- evaluated at most once, and only when necessary
     * @return a `Parser` that -- on success -- returns the result of `p`.
     */</span>
    @migration<span class="delimiter">(</span><span class="string">&quot;The call-by-name argument is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.&quot;</span>, <span class="string">&quot;2.9.0&quot;</span><span class="delimiter">)</span>
    def <a title="[U](q: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers;Parser.<~">&lt;~</a> <span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Parser.<~;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.<~.q">q</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span> lazy val <a title="Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.<~.p">p</a> = <a href="#scala.util.parsing.combinator;Parsers;Parser.<~.q" title="=&gt; Parsers.this.Parser[U]">q</a> <span class="comment">// lazy argument</span>
      <span class="delimiter">(</span>for<span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers;Parser.<~.$anonfun.a">a</a> &lt;- this; <a title="U" id="scala.util.parsing.combinator;Parsers;Parser.<~.$anonfun.$anonfun.b">b</a> &lt;- <a href="#scala.util.parsing.combinator;Parsers;Parser.map" title="(f: U =&gt; T)Parsers.this.Parser[T]">p</a><span class="delimiter">)</span> yield <a href="#scala.util.parsing.combinator;Parsers;Parser.<~.$anonfun.a" title="T">a</a><span class="delimiter">)</span>.<a href="#scala.util.parsing.combinator;Parsers;Parser.named" title="(n: String)Parsers.this.Parser[T]">named</a><span class="delimiter">(</span><span title="String(&quot;&lt;~&quot;)" class="string">&quot;&lt;~&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

     <span class="comment">/* not really useful: V cannot be inferred because Parser is covariant in first type parameter (V is always trivially Nothing)
    def ~~ [U, V](q: =&gt; Parser[U])(implicit combine: (T, U) =&gt; V): Parser[V] = new Parser[V] {
      def apply(in: Input) = seq(Parser.this, q)((x, y) =&gt; combine(x,y))(in)
    }  */</span>

    <span class="comment">/** A parser combinator for non-back-tracking sequential composition.
     *
     *  `p ~! q` succeeds if `p` succeeds and `q` succeeds on the input left over by `p`.
     *   In case of failure, no back-tracking is performed (in an earlier parser produced by the `|` combinator).
     *
     * @param p a parser that will be executed after `p` (this parser) succeeds
     * @return a `Parser` that -- on success -- returns a `~` (like a Pair, but easier to pattern match on)
     *         that contains the result of `p` and that of `q`.
     *         The resulting parser fails if either `p` or `q` fails, this failure is fatal.
     */</span>
    def <a title="[U](p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[T,U]]" id="scala.util.parsing.combinator;Parsers;Parser.~!">~!</a> <span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Parser.~!;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.~!.p">p</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[Parsers.this.~[T,U]]">Parser</a><span class="delimiter">[</span>~<span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">]</span>
      = <a href="#scala.util.parsing.combinator;Parsers.OnceParser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]] with Parsers.this.OnceParser[Parsers.this.~[T,U]]">OnceParser</a><span class="delimiter">{</span> <span class="delimiter">(</span>for<span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers;Parser.~!.$anonfun.a">a</a> &lt;- this; <a title="U" id="scala.util.parsing.combinator;Parsers;Parser.~!.$anonfun.$anonfun.b">b</a> &lt;- <a href="#scala.util.parsing.combinator;Parsers.commit" title="(p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">commit</a><a href="#scala.util.parsing.combinator;Parsers;Parser.map" title="(f: U =&gt; Parsers.this.~[T,U])Parsers.this.Parser[Parsers.this.~[T,U]]" class="delimiter">(</a><a href="#scala.util.parsing.combinator;Parsers;Parser.~!.p" title="=&gt; Parsers.this.Parser[U]">p</a><span class="delimiter">)</span><span class="delimiter">)</span> yield new <a href="#scala.util.parsing.combinator;Parsers.~.readResolve" title="Parsers.this.~[T,U]">~</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.~!.$anonfun.a" title="T">a</a>,<a href="#scala.util.parsing.combinator;Parsers;Parser.~!.$anonfun.$anonfun.b" title="U">b</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#scala.util.parsing.combinator;Parsers;Parser.named" title="(n: String)Parsers.this.Parser[Parsers.this.~[T,U]]">named</a><span class="delimiter">(</span><span title="String(&quot;~!&quot;)" class="string">&quot;~!&quot;</span><span class="delimiter">)</span> <span class="delimiter">}</span>

    <span class="comment">/** A parser combinator for alternative composition.
     *
     *  `p | q` succeeds if `p` succeeds or `q` succeeds.
     *   Note that `q` is only tried if `p`s failure is non-fatal (i.e., back-tracking is allowed).
     *
     * @param q a parser that will be executed if `p` (this parser) fails (and allows back-tracking)
     * @return a `Parser` that returns the result of the first parser to succeed (out of `p` and `q`)
     *         The resulting parser succeeds if (and only if)
     *         - `p` succeeds, ''or''
     *         - if `p` fails allowing back-tracking and `q` succeeds.
     */</span>
    def <a title="[U &gt;: T](q: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.|">|</a> <span class="delimiter">[</span><a title=" &gt;: T" id="scala.util.parsing.combinator;Parsers;Parser.|;U">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.|.q">q</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers;Parser.append" title="(p0: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">append</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.|.q" title="=&gt; Parsers.this.Parser[U]">q</a><span class="delimiter">)</span>.<a href="#scala.util.parsing.combinator;Parsers;Parser.named" title="(n: String)Parsers.this.Parser[U]">named</a><span class="delimiter">(</span><span title="String(&quot;|&quot;)" class="string">&quot;|&quot;</span><span class="delimiter">)</span>

    <span class="comment">// TODO</span>
    <span class="comment">/** A parser combinator for alternative with longest match composition.
     *
     *  `p ||| q` succeeds if `p` succeeds or `q` succeeds.
     *  If `p` and `q` both succeed, the parser that consumed the most characters accepts.
     *
     * @param q0 a parser that accepts if p consumes less characters. -- evaluated at most once, and only when necessary
     * @return a `Parser` that returns the result of the parser consuming the most characters (out of `p` and `q`).
     */</span>
    @migration<span class="delimiter">(</span><span class="string">&quot;The call-by-name argument is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.&quot;</span>, <span class="string">&quot;2.9.0&quot;</span><span class="delimiter">)</span>
    def <a title="[U &gt;: T](q0: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.|||">|||</a> <span class="delimiter">[</span><a title=" &gt;: T" id="scala.util.parsing.combinator;Parsers;Parser.|||;U">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.|||.q0">q0</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = new <a title="&lt;$anon: Parsers.this.Input =&gt; Parsers.this.ParseResult[U]&gt; extends Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.|||;$anon">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> <span class="delimiter">{</span>
      lazy val <a title="Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.|||;$anon.q">q</a> = <a href="#scala.util.parsing.combinator;Parsers;Parser.|||.q0" title="=&gt; Parsers.this.Parser[U]">q0</a> <span class="comment">// lazy argument</span>
      def <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;Parser.|||;$anon.apply">apply</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Parser.|||;$anon.apply.in">in</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        val <a title="Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers;Parser.|||;$anon.apply.res1">res1</a> = <a href="#scala.util.parsing.combinator;Parsers;Parser.apply" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">Parser</a>.this<span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.|||;$anon.apply.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
        val <a title="Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;Parser.|||;$anon.apply.res2">res2</a> = <a href="#scala.util.parsing.combinator;Parsers;Parser.apply" title="(in: Parsers.this.Input)Parsers.this.ParseResult[U]">q</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.|||;$anon.apply.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span>

        <a href="../../../Tuple2.scala.html#scala;Tuple2" title="(_1: Parsers.this.ParseResult[T], _2: Parsers.this.ParseResult[U])(Parsers.this.ParseResult[T], Parsers.this.ParseResult[U])" class="delimiter">(</a><a href="#scala.util.parsing.combinator;Parsers;Parser.|||;$anon.apply.res1" title="Parsers.this.ParseResult[T]">res1</a>, <a href="#scala.util.parsing.combinator;Parsers;Parser.|||;$anon.apply.res2" title="Parsers.this.ParseResult[U]">res2</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case <span class="delimiter">(</span><span title="Parsers.this.Success[T]">s1</span> @ Success<span class="delimiter">(</span>_, <span title="Parsers.this.Input">next1</span><span class="delimiter">)</span>, <span title="Parsers.this.Success[U]">s2</span> @ Success<span class="delimiter">(</span>_, <span title="Parsers.this.Input">next2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; if <span class="delimiter">(</span><span title="Parsers.this.Input">next2</span>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a> <a href="../input/Position.scala.html#scala.util.parsing.input;Position.<" title="(that: scala.util.parsing.input.Position)Boolean">&lt;</a> <span title="Parsers.this.Input">next1</span>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span> <span title="Parsers.this.Success[T]">s1</span> else <span title="Parsers.this.Success[U]">s2</span>
          case <span class="delimiter">(</span><span title="Parsers.this.Success[T]">s1</span> @ Success<span class="delimiter">(</span>_, _<span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <span title="Parsers.this.Success[T]">s1</span>
          case <span class="delimiter">(</span>_, <span title="Parsers.this.Success[U]">s2</span> @ Success<span class="delimiter">(</span>_, _<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="Parsers.this.Success[U]">s2</span>
          case <span class="delimiter">(</span><a title="Parsers.this.Error" id="scala.util.parsing.combinator;Parsers;Parser.|||;$anon.apply.e1">e1</a> @ Error<span class="delimiter">(</span>_, _<span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;Parsers;Parser.|||;$anon.apply.e1" title="Parsers.this.Error">e1</a>
          case <span class="delimiter">(</span><a title="Parsers.this.Failure" id="scala.util.parsing.combinator;Parsers;Parser.|||;$anon.apply.f1">f1</a> @ Failure<span class="delimiter">(</span>_, <span title="Parsers.this.Input">next1</span><span class="delimiter">)</span>, <a title="Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;Parser.|||;$anon.apply.ns2">ns2</a> @ <a href="#scala.util.parsing.combinator;Parsers.NoSuccess.unapply" title="(x: Parsers.this.ParseResult[U])Option[(String, Parsers.this.Input)]">NoSuccess</a><span class="delimiter">(</span>_, <span title="Parsers.this.Input">next2</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; if <span class="delimiter">(</span><span title="Parsers.this.Input">next2</span>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a> <a href="../input/Position.scala.html#scala.util.parsing.input;Position.<" title="(that: scala.util.parsing.input.Position)Boolean">&lt;</a> <span title="Parsers.this.Input">next1</span>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers;Parser.|||;$anon.apply.f1" title="Parsers.this.Failure">f1</a> else <a href="#scala.util.parsing.combinator;Parsers;Parser.|||;$anon.apply.ns2" title="Parsers.this.ParseResult[U]">ns2</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      override def <a title="()String" id="scala.util.parsing.combinator;Parsers;Parser.|||;$anon.toString">toString</a> = <span title="String(&quot;|||&quot;)" class="string">&quot;|||&quot;</span>
    <span class="delimiter">}</span>

    <span class="comment">/** A parser combinator for function application.
     *
     *  `p ^^ f` succeeds if `p` succeeds; it returns `f` applied to the result of `p`.
     *
     * @param f a function that will be applied to this parser's result (see `map` in `ParseResult`).
     * @return a parser that has the same behaviour as the current parser, but whose result is
     *         transformed by `f`.
     */</span>
    def <a title="[U](f: T =&gt; U)Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.^^">^^</a> <span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Parser.^^;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; U" id="scala.util.parsing.combinator;Parsers;Parser.^^.f">f</a>: T =&gt; U<span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers;Parser.map" title="(f: T =&gt; U)Parsers.this.Parser[U]">map</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.^^.f" title="T =&gt; U">f</a><span class="delimiter">)</span>.<a href="#scala.util.parsing.combinator;Parsers;Parser.named" title="(n: String)Parsers.this.Parser[U]">named</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.toString" title="()String">toString</a><span title="(x$1: Any)String">+</span><span title="String(&quot;^^&quot;)" class="string">&quot;^^&quot;</span><span class="delimiter">)</span>

    <span class="comment">/** A parser combinator that changes a successful result into the specified value.
     *
     *  `p ^^^ v` succeeds if `p` succeeds; discards its result, and returns `v` instead.
     *
     * @param v The new result for the parser, evaluated at most once (if `p` succeeds), not evaluated at all if `p` fails.
     * @return a parser that has the same behaviour as the current parser, but whose successful result is `v`
     */</span>
    @migration<span class="delimiter">(</span><span class="string">&quot;The call-by-name argument is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.&quot;</span>, <span class="string">&quot;2.9.0&quot;</span><span class="delimiter">)</span>
    def <a title="[U](v: =&gt; U)Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.^^^">^^^</a> <span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Parser.^^^;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; U" id="scala.util.parsing.combinator;Parsers;Parser.^^^.v">v</a>: =&gt; U<span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> =  new <a title="&lt;$anon: Parsers.this.Input =&gt; Parsers.this.ParseResult[U]&gt; extends Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.^^^;$anon">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> <span class="delimiter">{</span>
      lazy val <a title="U" id="scala.util.parsing.combinator;Parsers;Parser.^^^;$anon.v0">v0</a> = <a href="#scala.util.parsing.combinator;Parsers;Parser.^^^.v" title="=&gt; U">v</a> <span class="comment">// lazy argument</span>
      def <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[U]" id="scala.util.parsing.combinator;Parsers;Parser.^^^;$anon.apply">apply</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Parser.^^^;$anon.apply.in">in</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> = <a href="#scala.util.parsing.combinator;Parsers;Parser.apply" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">Parser</a>.this<span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.^^^;$anon.apply.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers;ParseResult.map" title="(f: T =&gt; U)Parsers.this.ParseResult[U]">map</a> <span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers;Parser.^^^;$anon.apply.$anonfun.x">x</a> =&gt; <a href="#scala.util.parsing.combinator;Parsers;Parser.^^^;$anon.v0" title="=&gt; U">v0</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>.<a href="#scala.util.parsing.combinator;Parsers;Parser.named" title="(n: String)Parsers.this.Parser[U]{lazy val v0: U}">named</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.toString" title="()String">toString</a><span title="(x$1: Any)String">+</span><span title="String(&quot;^^^&quot;)" class="string">&quot;^^^&quot;</span><span class="delimiter">)</span>

    <span class="comment">/** A parser combinator for partial function application.
     *
     *  `p ^? (f, error)` succeeds if `p` succeeds AND `f` is defined at the result of `p`;
     *  in that case, it returns `f` applied to the result of `p`. If `f` is not applicable,
     *  error(the result of `p`) should explain why.
     *
     * @param f a partial function that will be applied to this parser's result
     *          (see `mapPartial` in `ParseResult`).
     * @param error a function that takes the same argument as `f` and produces an error message
     *        to explain why `f` wasn't applicable
     * @return a parser that succeeds if the current parser succeeds &lt;i&gt;and&lt;/i&gt; `f` is applicable
     *         to the result. If so, the result will be transformed by `f`.
     */</span>
    def <a title="[U](f: PartialFunction[T,U], error: T =&gt; String)Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.^?(f902a51452)">^?</a> <span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Parser.^?(f902a51452);U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[T,U]" id="scala.util.parsing.combinator;Parsers;Parser.^?(f902a51452).f">f</a>: <a href="../../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[T,U]">PartialFunction</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span>, <a title="T =&gt; String" id="scala.util.parsing.combinator;Parsers;Parser.^?(f902a51452).error">error</a>: T =&gt; String<span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Parser.^?(f902a51452).$anonfun.in">in</a> =&gt;
      this<span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.^?(f902a51452).$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span>.<a href="#scala.util.parsing.combinator;Parsers;ParseResult.mapPartial" title="(f: PartialFunction[T,U], error: T =&gt; String)Parsers.this.ParseResult[U]">mapPartial</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.^?(f902a51452).f" title="PartialFunction[T,U]">f</a>, <a href="#scala.util.parsing.combinator;Parsers;Parser.^?(f902a51452).error" title="T =&gt; String">error</a><span class="delimiter">)</span><span class="delimiter">}</span>.<a href="#scala.util.parsing.combinator;Parsers;Parser.named" title="(n: String)Parsers.this.Parser[U]">named</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.toString" title="()String">toString</a><span title="(x$1: Any)String">+</span><span title="String(&quot;^?&quot;)" class="string">&quot;^?&quot;</span><span class="delimiter">)</span>

    <span class="comment">/** A parser combinator for partial function application.
     *
     *  `p ^? f` succeeds if `p` succeeds AND `f` is defined at the result of `p`;
     *  in that case, it returns `f` applied to the result of `p`.
     *
     * @param f a partial function that will be applied to this parser's result
     *          (see `mapPartial` in `ParseResult`).
     * @return a parser that succeeds if the current parser succeeds &lt;i&gt;and&lt;/i&gt; `f` is applicable
     *         to the result. If so, the result will be transformed by `f`.
     */</span>
    def <a title="[U](f: PartialFunction[T,U])Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.^?(00c7e0162e)">^?</a> <span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Parser.^?(00c7e0162e);U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[T,U]" id="scala.util.parsing.combinator;Parsers;Parser.^?(00c7e0162e).f">f</a>: <a href="../../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[T,U]">PartialFunction</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers;Parser.^?(f902a51452)" title="(f: PartialFunction[T,U], error: T =&gt; String)Parsers.this.Parser[U]">^?</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.^?(00c7e0162e).f" title="PartialFunction[T,U]">f</a>, <a title="T" id="scala.util.parsing.combinator;Parsers;Parser.^?(00c7e0162e).$anonfun.r">r</a> =&gt; <span title="String(&quot;Constructor function not defined at &quot;)" class="string">&quot;Constructor function not defined at &quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.util.parsing.combinator;Parsers;Parser.^?(00c7e0162e).$anonfun.r" title="T">r</a><span class="delimiter">)</span>

    <span class="comment">/** A parser combinator that parameterizes a subsequent parser with the
     *  result of this one.
     *
     *  Use this combinator when a parser depends on the result of a previous
     *  parser. `p` should be a function that takes the result from the first
     *  parser and returns the second parser.
     *
     *  `p into fq` (with `fq` typically `{x =&gt; q}`) first applies `p`, and
     *  then, if `p` successfully returned result `r`, applies `fq(r)` to the
     *  rest of the input.
     *
     *  ''From: G. Hutton. Higher-order functions for parsing. J. Funct. Program., 2(3):323--343, 1992.''
     *
     *  @example {{{
     *  def perlRE = &quot;m&quot; ~&gt; (&quot;.&quot;.r into (separator =&gt; &quot;&quot;&quot;[^%s]*&quot;&quot;&quot;.format(separator).r &lt;~ separator))
     *  }}}
     *
     *  @param fq a function that, given the result from this parser, returns
     *         the second parser to be applied
     *  @return a parser that succeeds if this parser succeeds (with result `x`)
     *          and if then `fq(x)` succeeds
     */</span>
    def <a title="[U](fq: T =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.into">into</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Parser.into;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.into.fq">fq</a>: T =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers;Parser.flatMap" title="(f: T =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">flatMap</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.into.fq" title="T =&gt; Parsers.this.Parser[U]">fq</a><span class="delimiter">)</span>

    <span class="comment">// shortcuts for combinators:</span>

    <span class="comment">/** Returns `into(fq)`. */</span>
    def <a title="[U](fq: T =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.>>">&gt;&gt;</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;Parser.>>;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.>>.fq">fq</a>: T =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>=<a href="#scala.util.parsing.combinator;Parsers;Parser.into" title="(fq: T =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">into</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.>>.fq" title="T =&gt; Parsers.this.Parser[U]">fq</a><span class="delimiter">)</span>

    <span class="comment">/** Returns a parser that repeatedly parses what this parser parses.
     *
     *  @return rep(this)
     */</span>
    def <a title="=&gt; Parsers.this.Parser[List[T]]" id="scala.util.parsing.combinator;Parsers;Parser.*(a254972157)">*</a> = <a href="#scala.util.parsing.combinator;Parsers.rep" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep</a><span class="delimiter">(</span>this<span class="delimiter">)</span>

    <span class="comment">/** Returns a parser that repeatedly parses what this parser parses,
     *  interleaved with the `sep` parser. The `sep` parser specifies how
     *  the results parsed by this parser should be combined.
     *
     *  @return chainl1(this, sep)
     */</span>
    def <a title="[U &gt;: T](sep: =&gt; Parsers.this.Parser[(U, U) =&gt; U])Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;Parser.*(031114d5bd)">*</a><span class="delimiter">[</span><a title=" &gt;: T" id="scala.util.parsing.combinator;Parsers;Parser.*(031114d5bd);U">U</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[(U, U) =&gt; U]" id="scala.util.parsing.combinator;Parsers;Parser.*(031114d5bd).sep">sep</a>: =&gt; Parser<span class="delimiter">[</span><span class="delimiter">(</span>U, U<span class="delimiter">)</span> =&gt; U<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#scala.util.parsing.combinator;Parsers.chainl1(199401a8c7)" title="(p: =&gt; Parsers.this.Parser[U], q: =&gt; Parsers.this.Parser[(U, U) =&gt; U])Parsers.this.Parser[U]">chainl1</a><span class="delimiter">(</span>this, <a href="#scala.util.parsing.combinator;Parsers;Parser.*(031114d5bd).sep" title="=&gt; Parsers.this.Parser[(U, U) =&gt; U]">sep</a><span class="delimiter">)</span>

    <span class="comment">// TODO: improve precedence? a ~ b*(&quot;,&quot;) = a ~ (b*(&quot;,&quot;))  should be true</span>

    <span class="comment">/** Returns a parser that repeatedly (at least once) parses what this parser parses.
     *
     *  @return rep1(this)
     */</span>
    def <a title="=&gt; Parsers.this.Parser[List[T]]" id="scala.util.parsing.combinator;Parsers;Parser.+">+</a> = <a href="#scala.util.parsing.combinator;Parsers.rep1(7368d9e567)" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep1</a><span class="delimiter">(</span>this<span class="delimiter">)</span>

    <span class="comment">/** Returns a parser that optionally parses what this parser parses.
     *
     *  @return opt(this)
     */</span>
    def <a title="=&gt; Parsers.this.Parser[Option[T]]" id="scala.util.parsing.combinator;Parsers;Parser.?">?</a> = <a href="#scala.util.parsing.combinator;Parsers.opt" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[Option[T]]">opt</a><span class="delimiter">(</span>this<span class="delimiter">)</span>

    <span class="comment">/** Changes the failure message produced by a parser.
     *
     *  This doesn't change the behavior of a parser on neither
     *  success nor error, just on failure. The semantics are
     *  slightly different than those obtained by doing `| failure(msg)`,
     *  in that the message produced by this method will always
     *  replace the message produced, which is not guaranteed
     *  by that idiom.
     *
     *  For example, parser `p` below will always produce the
     *  designated failure message, while `q` will not produce
     *  it if `sign` is parsed but `number` is not.
     *
     *  {{{
     *  def p = sign.? ~ number withFailureMessage  &quot;Number expected!&quot;
     *  def q = sign.? ~ number | failure(&quot;Number expected!&quot;)
     *  }}}
     *
     *  @param msg The message that will replace the default failure message.
     *  @return    A parser with the same properties and different failure message.
     */</span>
    def <a title="(msg: String)Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers;Parser.withFailureMessage">withFailureMessage</a><span class="delimiter">(</span><a title="String" id="scala.util.parsing.combinator;Parsers;Parser.withFailureMessage.msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Parser.withFailureMessage.$anonfun.in">in</a> =&gt;
      this<span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.withFailureMessage.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case Failure<span class="delimiter">(</span>_, <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Parser.withFailureMessage.$anonfun.next">next</a><span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;Parsers.Failure.readResolve" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.withFailureMessage.msg" title="String">msg</a>, <a href="#scala.util.parsing.combinator;Parsers;Parser.withFailureMessage.$anonfun.next" title="Parsers.this.Input">next</a><span class="delimiter">)</span>
        case <a title="Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers;Parser.withFailureMessage.$anonfun.other">other</a>            =&gt; <a href="#scala.util.parsing.combinator;Parsers;Parser.withFailureMessage.$anonfun.other" title="Parsers.this.ParseResult[T]">other</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Changes the error message produced by a parser.
     *
     *  This doesn't change the behavior of a parser on neither
     *  success nor failure, just on error. The semantics are
     *  slightly different than those obtained by doing `| error(msg)`,
     *  in that the message produced by this method will always
     *  replace the message produced, which is not guaranteed
     *  by that idiom.
     *
     *  For example, parser `p` below will always produce the
     *  designated error message, while `q` will not produce
     *  it if `sign` is parsed but `number` is not.
     *
     *  {{{
     *  def p = sign.? ~ number withErrorMessage  &quot;Number expected!&quot;
     *  def q = sign.? ~ number | error(&quot;Number expected!&quot;)
     *  }}}
     *
     *  @param msg The message that will replace the default error message.
     *  @return    A parser with the same properties and different error message.
     */</span>
    def <a title="(msg: String)Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers;Parser.withErrorMessage">withErrorMessage</a><span class="delimiter">(</span><a title="String" id="scala.util.parsing.combinator;Parsers;Parser.withErrorMessage.msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Parser.withErrorMessage.$anonfun.in">in</a> =&gt;
      this<span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.withErrorMessage.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case Error<span class="delimiter">(</span>_, <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers;Parser.withErrorMessage.$anonfun.next">next</a><span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;Parsers.Error.readResolve" title="(msg: String, next: Parsers.this.Input)Parsers.this.Error">Error</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;Parser.withErrorMessage.msg" title="String">msg</a>, <a href="#scala.util.parsing.combinator;Parsers;Parser.withErrorMessage.$anonfun.next" title="Parsers.this.Input">next</a><span class="delimiter">)</span>
        case <a title="Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers;Parser.withErrorMessage.$anonfun.other">other</a>          =&gt; <a href="#scala.util.parsing.combinator;Parsers;Parser.withErrorMessage.$anonfun.other" title="Parsers.this.ParseResult[T]">other</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Wrap a parser so that its failures become errors (the `|` combinator
   *  will give up as soon as it encounters an error, on failure it simply
   *  tries the next alternative).
   */</span>
  def <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.commit">commit</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.commit;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.commit.p">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.commit.$anonfun.in">in</a> =&gt;
    <a href="#scala.util.parsing.combinator;Parsers;Parser.apply" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.commit.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> match<span class="delimiter">{</span>
      case <a title="Parsers.this.Success[T]" id="scala.util.parsing.combinator;Parsers.commit.$anonfun.s">s</a> @ Success<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;Parsers.commit.$anonfun.s" title="Parsers.this.Success[T]">s</a>
      case <a title="Parsers.this.Error" id="scala.util.parsing.combinator;Parsers.commit.$anonfun.e">e</a> @ Error<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;Parsers.commit.$anonfun.e" title="Parsers.this.Error">e</a>
      case <a title="Parsers.this.Failure" id="scala.util.parsing.combinator;Parsers.commit.$anonfun.f">f</a> @ Failure<span class="delimiter">(</span><a title="String" id="scala.util.parsing.combinator;Parsers.commit.$anonfun.msg">msg</a>, <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.commit.$anonfun.next">next</a><span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;Parsers.Error.readResolve" title="(msg: String, next: Parsers.this.Input)Parsers.this.Error">Error</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.commit.$anonfun.msg" title="String">msg</a>, <a href="#scala.util.parsing.combinator;Parsers.commit.$anonfun.next" title="Parsers.this.Input">next</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A parser matching input elements that satisfy a given predicate.
   *
   *  `elem(kind, p)` succeeds if the input starts with an element `e` for which `p(e)` is true.
   *
   *  @param  kind   The element kind, used for error messages
   *  @param  p      A predicate that determines which elements match.
   *  @return
   */</span>
  def <a title="(kind: String, p: Parsers.this.Elem =&gt; Boolean)Parsers.this.Parser[Parsers.this.Elem]" id="scala.util.parsing.combinator;Parsers.elem(ffef23e4c5)">elem</a><span class="delimiter">(</span><a title="String" id="scala.util.parsing.combinator;Parsers.elem(ffef23e4c5).kind">kind</a>: <span title="String">String</span>, <a title="Parsers.this.Elem =&gt; Boolean" id="scala.util.parsing.combinator;Parsers.elem(ffef23e4c5).p">p</a>: Elem =&gt; Boolean<span class="delimiter">)</span> = <a href="#scala.util.parsing.combinator;Parsers.acceptIf" title="(p: Parsers.this.Elem =&gt; Boolean)(err: Parsers.this.Elem =&gt; String)Parsers.this.Parser[Parsers.this.Elem]">acceptIf</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.elem(ffef23e4c5).p" title="Parsers.this.Elem =&gt; Boolean">p</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Parsers.this.Elem" id="scala.util.parsing.combinator;Parsers.elem(ffef23e4c5).$anonfun.inEl">inEl</a> =&gt; <a href="#scala.util.parsing.combinator;Parsers.elem(ffef23e4c5).kind" title="String">kind</a><span title="(x$1: Any)String">+</span><span title="String(&quot; expected&quot;)" class="string">&quot; expected&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** A parser that matches only the given element `e`.
   *
   *  `elem(e)` succeeds if the input starts with an element `e`.
   *
   *  @param e the `Elem` that must be the next piece of input for the returned parser to succeed
   *  @return a `Parser` that succeeds if `e` is the next available input (and returns it).
   */</span>
  def <a title="(e: Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]" id="scala.util.parsing.combinator;Parsers.elem(c166237af5)">elem</a><span class="delimiter">(</span><a title="Parsers.this.Elem" id="scala.util.parsing.combinator;Parsers.elem(c166237af5).e">e</a>: <a href="#scala.util.parsing.combinator;Parsers;Elem" title="Parsers.this.Elem">Elem</a><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[Parsers.this.Elem]">Parser</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers.accept(c166237af5)" title="implicit scala.util.parsing.combinator.Parsers.accept : (e: Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]">accept</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.elem(c166237af5).e" title="Parsers.this.Elem">e</a><span class="delimiter">)</span>

  <span class="comment">/** A parser that matches only the given element `e`.
   *
   *  The method is implicit so that elements can automatically be lifted to their parsers.
   *  For example, when parsing `Token`s, `Identifier(&quot;new&quot;)` (which is a `Token`) can be used directly,
   *  instead of first creating a `Parser` using `accept(Identifier(&quot;new&quot;))`.
   *
   *  @param e the `Elem` that must be the next piece of input for the returned parser to succeed
   *  @return a `tParser` that succeeds if `e` is the next available input.
   */</span>

  implicit def <a title="implicit scala.util.parsing.combinator.Parsers.accept : (e: Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]" id="scala.util.parsing.combinator;Parsers.accept(c166237af5)">accept</a><span class="delimiter">(</span><a title="Parsers.this.Elem" id="scala.util.parsing.combinator;Parsers.accept(c166237af5).e">e</a>: <a href="#scala.util.parsing.combinator;Parsers;Elem" title="Parsers.this.Elem">Elem</a><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[Parsers.this.Elem]">Parser</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers.acceptIf" title="(p: Parsers.this.Elem =&gt; Boolean)(err: Parsers.this.Elem =&gt; String)Parsers.this.Parser[Parsers.this.Elem]">acceptIf</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.accept(c166237af5).$anonfun.x$2" title="Parsers.this.Elem">_</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.util.parsing.combinator;Parsers.accept(c166237af5).e" title="Parsers.this.Elem">e</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="String(&quot;`&quot;)" class="string">&quot;`&quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.util.parsing.combinator;Parsers.accept(c166237af5).e" title="Parsers.this.Elem">e</a><span title="(x$1: Any)String">+</span><span title="String(&quot;\' expected but &quot;)" class="string">&quot;' expected but &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.util.parsing.combinator;Parsers.accept(c166237af5).$anonfun.x$3" title="Parsers.this.Elem">_</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; found&quot;)" class="string">&quot; found&quot;</span><span class="delimiter">)</span>

  <span class="comment">/** A parser that matches only the given list of element `es`.
   *
   *  `accept(es)` succeeds if the input subsequently provides the elements in the list `es`.
   *
   *  @param  es the list of expected elements
   *  @return a Parser that recognizes a specified list of elements
   */</span>
  def <a title="[ES](es: ES)(implicit evidence$1: ES =&gt; List[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]" id="scala.util.parsing.combinator;Parsers.accept(39b1fbf9b6)">accept</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.accept(39b1fbf9b6);ES">ES</a> &lt;% List<span class="delimiter">[</span>Elem<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="ES" id="scala.util.parsing.combinator;Parsers.accept(39b1fbf9b6).es">es</a>: <a href="#scala.util.parsing.combinator;Parsers.accept(39b1fbf9b6);ES" title="ES">ES</a><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[List[Parsers.this.Elem]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Elem<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers.acceptSeq" title="(es: ES)(implicit evidence$2: ES =&gt; Iterable[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]">acceptSeq</a><a href="#scala.util.parsing.combinator;Parsers.accept(39b1fbf9b6).evidence$1" title="ES =&gt; List[Parsers.this.Elem]" class="delimiter">(</a><a href="#scala.util.parsing.combinator;Parsers.accept(39b1fbf9b6).es" title="ES">es</a><span class="delimiter">)</span>

  <span class="comment">/** The parser that matches an element in the domain of the partial function `f`.
   *
   *  If `f` is defined on the first element in the input, `f` is applied
   *  to it to produce this parser's result.
   *
   *  Example: The parser `accept(&quot;name&quot;, {case Identifier(n) =&gt; Name(n)})`
   *          accepts an `Identifier(n)` and returns a `Name(n)`
   *
   *  @param expected a description of the kind of element this parser expects (for error messages)
   *  @param f a partial function that determines when this parser is successful and what its output is
   *  @return A parser that succeeds if `f` is applicable to the first element of the input,
   *          applying `f` to it to produce the result.
   */</span>
  def <a title="[U](expected: String, f: PartialFunction[Parsers.this.Elem,U])Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers.accept(35ac5e03c3)">accept</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.accept(35ac5e03c3);U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="scala.util.parsing.combinator;Parsers.accept(35ac5e03c3).expected">expected</a>: <span title="String">String</span>, <a title="PartialFunction[Parsers.this.Elem,U]" id="scala.util.parsing.combinator;Parsers.accept(35ac5e03c3).f">f</a>: <a href="../../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[Parsers.this.Elem,U]">PartialFunction</a><span class="delimiter">[</span>Elem, U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers.acceptMatch" title="(expected: String, f: PartialFunction[Parsers.this.Elem,U])Parsers.this.Parser[U]">acceptMatch</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.accept(35ac5e03c3).expected" title="String">expected</a>, <a href="#scala.util.parsing.combinator;Parsers.accept(35ac5e03c3).f" title="PartialFunction[Parsers.this.Elem,U]">f</a><span class="delimiter">)</span>

  <span class="comment">/** A parser matching input elements that satisfy a given predicate.
   *
   *  `acceptIf(p)(el =&gt; &quot;Unexpected &quot;+el)` succeeds if the input starts with an element `e` for which `p(e)` is true.
   *
   *  @param  err    A function from the received element into an error message.
   *  @param  p      A predicate that determines which elements match.
   *  @return        A parser for elements satisfying p(e).
   */</span>
  def <a title="(p: Parsers.this.Elem =&gt; Boolean)(err: Parsers.this.Elem =&gt; String)Parsers.this.Parser[Parsers.this.Elem]" id="scala.util.parsing.combinator;Parsers.acceptIf">acceptIf</a><span class="delimiter">(</span><a title="Parsers.this.Elem =&gt; Boolean" id="scala.util.parsing.combinator;Parsers.acceptIf.p">p</a>: Elem =&gt; Boolean<span class="delimiter">)</span><span class="delimiter">(</span><a title="Parsers.this.Elem =&gt; String" id="scala.util.parsing.combinator;Parsers.acceptIf.err">err</a>: Elem =&gt; String<span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[Parsers.this.Elem]">Parser</a><span class="delimiter">[</span>Elem<span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[Parsers.this.Elem])Parsers.this.Parser[Parsers.this.Elem]">Parser</a> <span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.acceptIf.$anonfun.in">in</a> =&gt;
    if <span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.acceptIf.$anonfun.in" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.atEnd" title="=&gt; Boolean">atEnd</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers.Failure.readResolve" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><span title="String(&quot;end of input&quot;)" class="string">&quot;end of input&quot;</span>, <a href="#scala.util.parsing.combinator;Parsers.acceptIf.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
    else if <span class="delimiter">(</span><a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: Parsers.this.Elem)Boolean">p</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.acceptIf.$anonfun.in" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.first" title="=&gt; Parsers.this.Elem">first</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers.Success.readResolve" title="(result: Parsers.this.Elem, next: Parsers.this.Input)Parsers.this.Success[Parsers.this.Elem]">Success</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.acceptIf.$anonfun.in" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.first" title="=&gt; Parsers.this.Elem">first</a>, <a href="#scala.util.parsing.combinator;Parsers.acceptIf.$anonfun.in" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.rest" title="=&gt; scala.util.parsing.input.Reader[Parsers.this.Elem]">rest</a><span class="delimiter">)</span>
    else <a href="#scala.util.parsing.combinator;Parsers.Failure.readResolve" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: Parsers.this.Elem)String">err</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.acceptIf.$anonfun.in" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.first" title="=&gt; Parsers.this.Elem">first</a><span class="delimiter">)</span>, <a href="#scala.util.parsing.combinator;Parsers.acceptIf.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The parser that matches an element in the domain of the partial function `f`.
   *
   *  If `f` is defined on the first element in the input, `f` is applied
   *  to it to produce this parser's result.
   *
   *  Example: The parser `acceptMatch(&quot;name&quot;, {case Identifier(n) =&gt; Name(n)})`
   *          accepts an `Identifier(n)` and returns a `Name(n)`
   *
   *  @param expected a description of the kind of element this parser expects (for error messages)
   *  @param f a partial function that determines when this parser is successful and what its output is
   *  @return A parser that succeeds if `f` is applicable to the first element of the input,
   *          applying `f` to it to produce the result.
   */</span>
  def <a title="[U](expected: String, f: PartialFunction[Parsers.this.Elem,U])Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers.acceptMatch">acceptMatch</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.acceptMatch;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="scala.util.parsing.combinator;Parsers.acceptMatch.expected">expected</a>: <span title="String">String</span>, <a title="PartialFunction[Parsers.this.Elem,U]" id="scala.util.parsing.combinator;Parsers.acceptMatch.f">f</a>: <a href="../../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[Parsers.this.Elem,U]">PartialFunction</a><span class="delimiter">[</span>Elem, U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.acceptMatch.$anonfun.in">in</a> =&gt;
    if <span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.acceptMatch.$anonfun.in" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.atEnd" title="=&gt; Boolean">atEnd</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers.Failure.readResolve" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><span title="String(&quot;end of input&quot;)" class="string">&quot;end of input&quot;</span>, <a href="#scala.util.parsing.combinator;Parsers.acceptMatch.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
    else if <span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.acceptMatch.f" title="PartialFunction[Parsers.this.Elem,U]">f</a>.<a href="../../../PartialFunction.scala.html#scala;PartialFunction.isDefinedAt" title="(x: Parsers.this.Elem)Boolean">isDefinedAt</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.acceptMatch.$anonfun.in" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.first" title="=&gt; Parsers.this.Elem">first</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers.Success.readResolve" title="(result: U, next: Parsers.this.Input)Parsers.this.Success[U]">Success</a><span class="delimiter">(</span><a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: Parsers.this.Elem)U">f</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.acceptMatch.$anonfun.in" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.first" title="=&gt; Parsers.this.Elem">first</a><span class="delimiter">)</span>, <a href="#scala.util.parsing.combinator;Parsers.acceptMatch.$anonfun.in" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.rest" title="=&gt; scala.util.parsing.input.Reader[Parsers.this.Elem]">rest</a><span class="delimiter">)</span>
    else <a href="#scala.util.parsing.combinator;Parsers.Failure.readResolve" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.acceptMatch.expected" title="String">expected</a><span title="(x$1: Any)String">+</span><span title="String(&quot; expected&quot;)" class="string">&quot; expected&quot;</span>, <a href="#scala.util.parsing.combinator;Parsers.acceptMatch.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A parser that matches only the given [[scala.collection.Iterable]] collection of elements `es`.
   *
   *  `acceptSeq(es)` succeeds if the input subsequently provides the elements in the iterable `es`.
   *
   *  @param  es the list of expected elements
   *  @return a Parser that recognizes a specified list of elements
   */</span>
  def <a title="[ES](es: ES)(implicit evidence$2: ES =&gt; Iterable[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]" id="scala.util.parsing.combinator;Parsers.acceptSeq">acceptSeq</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.acceptSeq;ES">ES</a> &lt;% Iterable<span class="delimiter">[</span>Elem<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="ES" id="scala.util.parsing.combinator;Parsers.acceptSeq.es">es</a>: <a href="#scala.util.parsing.combinator;Parsers.acceptSeq;ES" title="ES">ES</a><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[List[Parsers.this.Elem]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Elem<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: ES)Iterable[Parsers.this.Elem]">es</a>.<a href="../../../collection/IterableLike.scala.html#scala.collection;IterableLike.foldRight" title="[B](z: B)(op: (Parsers.this.Elem, B) =&gt; B)B">foldRight</a><span title="(z: Parsers.this.Parser[List[Parsers.this.Elem]])(op: (Parsers.this.Elem, Parsers.this.Parser[List[Parsers.this.Elem]]) =&gt; Parsers.this.Parser[List[Parsers.this.Elem]])Parsers.this.Parser[List[Parsers.this.Elem]]" class="delimiter">[</span><a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[List[Parsers.this.Elem]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Elem<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.success" title="(v: scala.collection.immutable.Nil.type)Parsers.this.Parser[scala.collection.immutable.Nil.type]">success</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">{</span><span class="delimiter">(</span><a title="Parsers.this.Elem" id="scala.util.parsing.combinator;Parsers.acceptSeq.$anonfun.x">x</a>, <a title="Parsers.this.Parser[List[Parsers.this.Elem]]" id="scala.util.parsing.combinator;Parsers.acceptSeq.$anonfun.pxs">pxs</a><span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;Parsers.accept(c166237af5)" title="implicit scala.util.parsing.combinator.Parsers.accept : (e: Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]">accept</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.acceptSeq.$anonfun.x" title="Parsers.this.Elem">x</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers;Parser.~" title="(q: =&gt; Parsers.this.Parser[List[Parsers.this.Elem]])Parsers.this.Parser[Parsers.this.~[Parsers.this.Elem,List[Parsers.this.Elem]]]">~</a> <a href="#scala.util.parsing.combinator;Parsers.acceptSeq.$anonfun.pxs" title="Parsers.this.Parser[List[Parsers.this.Elem]]">pxs</a> <a href="#scala.util.parsing.combinator;Parsers;Parser.^^" title="(f: Parsers.this.~[Parsers.this.Elem,List[Parsers.this.Elem]] =&gt; List[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]">^^</a> <a href="#scala.util.parsing.combinator;Parsers.mkList" title="Parsers.this.~[Parsers.this.Elem,List[Parsers.this.Elem]] =&gt; List[Parsers.this.Elem]">mkList</a><span class="delimiter">}</span>

  <span class="comment">/** A parser that always fails.
   *
   * @param msg The error message describing the failure.
   * @return A parser that always fails with the specified error message.
   */</span>
  def <a title="(msg: String)Parsers.this.Parser[Nothing]" id="scala.util.parsing.combinator;Parsers.failure">failure</a><span class="delimiter">(</span><a title="String" id="scala.util.parsing.combinator;Parsers.failure.msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[Nothing])Parsers.this.Parser[Nothing]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.failure.$anonfun.in">in</a> =&gt; <a href="#scala.util.parsing.combinator;Parsers.Failure.readResolve" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.failure.msg" title="String">msg</a>, <a href="#scala.util.parsing.combinator;Parsers.failure.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/** A parser that results in an error.
   *
   * @param msg The error message describing the failure.
   * @return A parser that always fails with the specified error message.
   */</span>
  def <a title="(msg: String)Parsers.this.Parser[Nothing]" id="scala.util.parsing.combinator;Parsers.err">err</a><span class="delimiter">(</span><a title="String" id="scala.util.parsing.combinator;Parsers.err.msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[Nothing])Parsers.this.Parser[Nothing]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.err.$anonfun.in">in</a> =&gt; <a href="#scala.util.parsing.combinator;Parsers.Error.readResolve" title="(msg: String, next: Parsers.this.Input)Parsers.this.Error">Error</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.err.msg" title="String">msg</a>, <a href="#scala.util.parsing.combinator;Parsers.err.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/** A parser that always succeeds.
   *
   * @param v The result for the parser
   * @return A parser that always succeeds, with the given result `v`
   */</span>
  def <a title="[T](v: T)Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.success">success</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.success;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers.success.v">v</a>: <a href="#scala.util.parsing.combinator;Parsers.success;T" title="T">T</a><span class="delimiter">)</span> = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.success.$anonfun.in">in</a> =&gt; <a href="#scala.util.parsing.combinator;Parsers.Success.readResolve" title="(result: T, next: Parsers.this.Input)Parsers.this.Success[T]">Success</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.success.v" title="T">v</a>, <a href="#scala.util.parsing.combinator;Parsers.success.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/** A helper method that turns a `Parser` into one that will
   *  print debugging information to stdout before and after
   *  being applied.
   */</span>
  def <a title="[T](p: =&gt; Parsers.this.Parser[T])(name: String)Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.log">log</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.log;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.log.p">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="String" id="scala.util.parsing.combinator;Parsers.log.name">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a><span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.log.$anonfun.in">in</a> =&gt;
    <a href="../../../Predef.scala.html#scala.Predef.println(b0c81b2e65)" title="(x: Any)Unit">println</a><span class="delimiter">(</span><span title="String(&quot;trying &quot;)" class="string">&quot;trying &quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.util.parsing.combinator;Parsers.log.name" title="String">name</a> <span title="(x$1: Any)String">+</span><span title="String(&quot; at &quot;)" class="string">&quot; at &quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.util.parsing.combinator;Parsers.log.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
    val <a title="Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers.log.$anonfun.r">r</a> = <a href="#scala.util.parsing.combinator;Parsers;Parser.apply" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.log.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
    <a href="../../../Predef.scala.html#scala.Predef.println(b0c81b2e65)" title="(x: Any)Unit">println</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.log.name" title="String">name</a> <span title="(x$1: Any)String">+</span><span title="String(&quot; --&gt; &quot;)" class="string">&quot; --&gt; &quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.util.parsing.combinator;Parsers.log.$anonfun.r" title="Parsers.this.ParseResult[T]">r</a><span class="delimiter">)</span>
    <a href="#scala.util.parsing.combinator;Parsers.log.$anonfun.r" title="Parsers.this.ParseResult[T]">r</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A parser generator for repetitions.
   *
   *  `rep(p)` repeatedly uses `p` to parse the input until `p` fails
   *  (the result is a List of the consecutive results of `p`).
   *
   * @param p a `Parser` that is to be applied successively to the input
   * @return A parser that returns a list of results produced by repeatedly applying `p` to the input.
   */</span>
  def <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]" id="scala.util.parsing.combinator;Parsers.rep">rep</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.rep;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.rep.p">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[List[T]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers.rep1(7368d9e567)" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep1</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.rep.p" title="=&gt; Parsers.this.Parser[T]">p</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers;Parser.|" title="(q: =&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[List[T]]">|</a> <a href="#scala.util.parsing.combinator;Parsers.success" title="(v: List[Nothing])Parsers.this.Parser[List[Nothing]]">success</a><span class="delimiter">(</span>List<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A parser generator for interleaved repetitions.
   *
   *  `repsep(p, q)` repeatedly uses `p` interleaved with `q` to parse the input, until `p` fails.
   *  (The result is a `List` of the results of `p`.)
   *
   *  Example: `repsep(term, &quot;,&quot;)` parses a comma-separated list of term's, yielding a list of these terms.
   *
   * @param p a `Parser` that is to be applied successively to the input
   * @param q a `Parser` that parses the elements that separate the elements parsed by `p`
   * @return A parser that returns a list of results produced by repeatedly applying `p` (interleaved with `q`) to the input.
   *         The results of `p` are collected in a list. The results of `q` are discarded.
   */</span>
  def <a title="[T](p: =&gt; Parsers.this.Parser[T], q: =&gt; Parsers.this.Parser[Any])Parsers.this.Parser[List[T]]" id="scala.util.parsing.combinator;Parsers.repsep">repsep</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.repsep;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.repsep.p">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; Parsers.this.Parser[Any]" id="scala.util.parsing.combinator;Parsers.repsep.q">q</a>: =&gt; Parser<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[List[T]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#scala.util.parsing.combinator;Parsers.rep1sep" title="(p: =&gt; Parsers.this.Parser[T], q: =&gt; Parsers.this.Parser[Any])Parsers.this.Parser[List[T]]">rep1sep</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.repsep.p" title="=&gt; Parsers.this.Parser[T]">p</a>, <a href="#scala.util.parsing.combinator;Parsers.repsep.q" title="=&gt; Parsers.this.Parser[Any]">q</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers;Parser.|" title="(q: =&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[List[T]]">|</a> <a href="#scala.util.parsing.combinator;Parsers.success" title="(v: List[Nothing])Parsers.this.Parser[List[Nothing]]">success</a><span class="delimiter">(</span>List<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A parser generator for non-empty repetitions.
   *
   *  `rep1(p)` repeatedly uses `p` to parse the input until `p` fails -- `p` must succeed at least
   *             once (the result is a `List` of the consecutive results of `p`)
   *
   * @param p a `Parser` that is to be applied successively to the input
   * @return A parser that returns a list of results produced by repeatedly applying `p` to the input
   *        (and that only succeeds if `p` matches at least once).
   */</span>
  def <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]" id="scala.util.parsing.combinator;Parsers.rep1(7368d9e567)">rep1</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.rep1(7368d9e567);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.rep1(7368d9e567).p">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[List[T]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7)" title="(first: =&gt; Parsers.this.Parser[T], p0: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep1</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.rep1(7368d9e567).p" title="=&gt; Parsers.this.Parser[T]">p</a>, <a href="#scala.util.parsing.combinator;Parsers.rep1(7368d9e567).p" title="=&gt; Parsers.this.Parser[T]">p</a><span class="delimiter">)</span>

  <span class="comment">/** A parser generator for non-empty repetitions.
   *
   *  `rep1(f, p)` first uses `f` (which must succeed) and then repeatedly
   *     uses `p` to parse the input until `p` fails
   *     (the result is a `List` of the consecutive results of `f` and `p`)
   *
   * @param first a `Parser` that parses the first piece of input
   * @param p0 a `Parser` that is to be applied successively to the rest of the input (if any) -- evaluated at most once, and only when necessary
   * @return A parser that returns a list of results produced by first applying `f` and then
   *         repeatedly `p` to the input (it only succeeds if `f` matches).
   */</span>
  @migration<span class="delimiter">(</span><span class="string">&quot;The `p0` call-by-name arguments is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.&quot;</span>, <span class="string">&quot;2.9.0&quot;</span><span class="delimiter">)</span>
  def <a title="[T](first: =&gt; Parsers.this.Parser[T], p0: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7)">rep1</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).first">first</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).p0">p0</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[List[T]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[List[T]])Parsers.this.Parser[List[T]]">Parser</a> <span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.in">in</a> =&gt;
    lazy val <a title="Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.p">p</a> = <a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).p0" title="=&gt; Parsers.this.Parser[T]">p0</a> <span class="comment">// lazy argument</span>
    val <a title="scala.collection.mutable.ListBuffer[T]" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.elems">elems</a> = new <a href="../../../collection/mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer" title="scala.collection.mutable.ListBuffer[T]">ListBuffer</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

    def <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[List[T]]" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue">continue</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.in">in</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[List[T]]">ParseResult</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      val <a title="Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.p0">p0</a> = <a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.p" title="=&gt; Parsers.this.Parser[T]">p</a>    <span class="comment">// avoid repeatedly re-evaluating by-name parser</span>
      @tailrec def <a title="(in0: Parsers.this.Input)Parsers.this.ParseResult[List[T]]" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.applyp">applyp</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.applyp.in0">in0</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[List[T]]">ParseResult</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers;Parser.apply" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p0</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.applyp.in0" title="Parsers.this.Input">in0</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case Success<span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.applyp.x">x</a>, <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.applyp.rest">rest</a><span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.elems" title="scala.collection.mutable.ListBuffer[T]">elems</a> <a href="../../../collection/mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.+=(f93df146a4)" title="(x: T)elems.type">+=</a> <a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.applyp.x" title="T">x</a> ; <a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.applyp" title="(in0: Parsers.this.Input)Parsers.this.ParseResult[List[T]]">applyp</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.applyp.rest" title="Parsers.this.Input">rest</a><span class="delimiter">)</span>
        case <a title="Parsers.this.Error" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.applyp.e">e</a> @ Error<span class="delimiter">(</span>_, _<span class="delimiter">)</span>  =&gt; <a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.applyp.e" title="Parsers.this.Error">e</a>  <span class="comment">// still have to propagate error</span>
        case _                =&gt; <a href="#scala.util.parsing.combinator;Parsers.Success.readResolve" title="(result: List[T], next: Parsers.this.Input)Parsers.this.Success[List[T]]">Success</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.elems" title="scala.collection.mutable.ListBuffer[T]">elems</a>.<a href="../../../collection/mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.toList" title="=&gt; List[T]">toList</a>, <a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.applyp.in0" title="Parsers.this.Input">in0</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.applyp" title="(in0: Parsers.this.Input)Parsers.this.ParseResult[List[T]]">applyp</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#scala.util.parsing.combinator;Parsers;Parser.apply" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">first</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case Success<span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.x">x</a>, <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.rest">rest</a><span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.elems" title="scala.collection.mutable.ListBuffer[T]">elems</a> <a href="../../../collection/mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.+=(f93df146a4)" title="(x: T)elems.type">+=</a> <a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.x" title="T">x</a> ; <a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.continue" title="(in: Parsers.this.Input)Parsers.this.ParseResult[List[T]]">continue</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.rest" title="Parsers.this.Input">rest</a><span class="delimiter">)</span>
      case <a title="Parsers.this.NoSuccess" id="scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.ns">ns</a>: <a href="#scala.util.parsing.combinator;Parsers;NoSuccess" title="Parsers.this.NoSuccess">NoSuccess</a>    =&gt; <a href="#scala.util.parsing.combinator;Parsers.rep1(e88fd05af7).$anonfun.ns" title="Parsers.this.NoSuccess">ns</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A parser generator for a specified number of repetitions.
   *
   *  `repN(n, p)` uses `p` exactly `n` time to parse the input
   *  (the result is a `List` of the `n` consecutive results of `p`).
   *
   * @param p   a `Parser` that is to be applied successively to the input
   * @param num the exact number of times `p` must succeed
   * @return    A parser that returns a list of results produced by repeatedly applying `p` to the input
   *        (and that only succeeds if `p` matches exactly `n` times).
   */</span>
  def <a title="[T](num: Int, p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]" id="scala.util.parsing.combinator;Parsers.repN">repN</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.repN;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="scala.util.parsing.combinator;Parsers.repN.num">num</a>: <a href="../../../Int.scala.html#scala;Int" title="Int">Int</a>, <a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.repN.p">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[List[T]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.repN.num" title="Int">num</a> <a href="../../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers.success" title="(v: scala.collection.immutable.Nil.type)Parsers.this.Parser[scala.collection.immutable.Nil.type]">success</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> else <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[List[T]])Parsers.this.Parser[List[T]]">Parser</a> <span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.repN.$anonfun.in">in</a> =&gt;
      val <a title="scala.collection.mutable.ListBuffer[T]" id="scala.util.parsing.combinator;Parsers.repN.$anonfun.elems">elems</a> = new <a href="../../../collection/mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer" title="scala.collection.mutable.ListBuffer[T]">ListBuffer</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
      val <a title="Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.repN.$anonfun.p0">p0</a> = <a href="#scala.util.parsing.combinator;Parsers.repN.p" title="=&gt; Parsers.this.Parser[T]">p</a>    <span class="comment">// avoid repeatedly re-evaluating by-name parser</span>

      @tailrec def <a title="(in0: Parsers.this.Input)Parsers.this.ParseResult[List[T]]" id="scala.util.parsing.combinator;Parsers.repN.$anonfun.applyp">applyp</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.repN.$anonfun.applyp.in0">in0</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;ParseResult" title="Parsers.this.ParseResult[List[T]]">ParseResult</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
        if <span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.repN.$anonfun.elems" title="scala.collection.mutable.ListBuffer[T]">elems</a>.<a href="../../../collection/mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.length" title="=&gt; Int">length</a> <a href="../../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <a href="#scala.util.parsing.combinator;Parsers.repN.num" title="Int">num</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers.Success.readResolve" title="(result: List[T], next: Parsers.this.Input)Parsers.this.Success[List[T]]">Success</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.repN.$anonfun.elems" title="scala.collection.mutable.ListBuffer[T]">elems</a>.<a href="../../../collection/mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.toList" title="=&gt; List[T]">toList</a>, <a href="#scala.util.parsing.combinator;Parsers.repN.$anonfun.applyp.in0" title="Parsers.this.Input">in0</a><span class="delimiter">)</span>
        else <a href="#scala.util.parsing.combinator;Parsers;Parser.apply" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p0</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.repN.$anonfun.applyp.in0" title="Parsers.this.Input">in0</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case Success<span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers.repN.$anonfun.applyp.x">x</a>, <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.repN.$anonfun.applyp.rest">rest</a><span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;Parsers.repN.$anonfun.elems" title="scala.collection.mutable.ListBuffer[T]">elems</a> <a href="../../../collection/mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.+=(f93df146a4)" title="(x: T)elems.type">+=</a> <a href="#scala.util.parsing.combinator;Parsers.repN.$anonfun.applyp.x" title="T">x</a> ; <a href="#scala.util.parsing.combinator;Parsers.repN.$anonfun.applyp" title="(in0: Parsers.this.Input)Parsers.this.ParseResult[List[T]]">applyp</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.repN.$anonfun.applyp.rest" title="Parsers.this.Input">rest</a><span class="delimiter">)</span>
          case <a title="Parsers.this.NoSuccess" id="scala.util.parsing.combinator;Parsers.repN.$anonfun.applyp.ns">ns</a>: <a href="#scala.util.parsing.combinator;Parsers;NoSuccess" title="Parsers.this.NoSuccess">NoSuccess</a>    =&gt; <a href="#scala.util.parsing.combinator;Parsers.repN.$anonfun.applyp.ns" title="Parsers.this.NoSuccess">ns</a>
        <span class="delimiter">}</span>

      <a href="#scala.util.parsing.combinator;Parsers.repN.$anonfun.applyp" title="(in0: Parsers.this.Input)Parsers.this.ParseResult[List[T]]">applyp</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.repN.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/** A parser generator for non-empty repetitions.
   *
   *  `rep1sep(p, q)` repeatedly applies `p` interleaved with `q` to parse the
   *  input, until `p` fails. The parser `p` must succeed at least once.
   *
   * @param p a `Parser` that is to be applied successively to the input
   * @param q a `Parser` that parses the elements that separate the elements parsed by `p`
   *          (interleaved with `q`)
   * @return A parser that returns a list of results produced by repeatedly applying `p` to the input
   *         (and that only succeeds if `p` matches at least once).
   *         The results of `p` are collected in a list. The results of `q` are discarded.
   */</span>
  def <a title="[T](p: =&gt; Parsers.this.Parser[T], q: =&gt; Parsers.this.Parser[Any])Parsers.this.Parser[List[T]]" id="scala.util.parsing.combinator;Parsers.rep1sep">rep1sep</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.rep1sep;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.rep1sep.p">p</a> : =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; Parsers.this.Parser[Any]" id="scala.util.parsing.combinator;Parsers.rep1sep.q">q</a> : =&gt; Parser<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[List[T]]">Parser</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#scala.util.parsing.combinator;Parsers.rep1sep.p" title="=&gt; Parsers.this.Parser[T]">p</a> <a href="#scala.util.parsing.combinator;Parsers;Parser.~" title="(q: =&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[Parsers.this.~[T,List[T]]]">~</a> <a href="#scala.util.parsing.combinator;Parsers.rep" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.rep1sep.q" title="=&gt; Parsers.this.Parser[Any]">q</a> <a href="#scala.util.parsing.combinator;Parsers;Parser.~>" title="(q: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]">~&gt;</a> <a href="#scala.util.parsing.combinator;Parsers.rep1sep.p" title="=&gt; Parsers.this.Parser[T]">p</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers;Parser.^^" title="(f: Parsers.this.~[T,List[T]] =&gt; List[T])Parsers.this.Parser[List[T]]">^^</a> <a href="#scala.util.parsing.combinator;Parsers.rep1sep.$anonfun.x0$1" title="List[T]" class="delimiter">{</a>case <a title="T" id="scala.util.parsing.combinator;Parsers.rep1sep.$anonfun.x">x</a>~<a title="List[T]" id="scala.util.parsing.combinator;Parsers.rep1sep.$anonfun.y">y</a> =&gt; <a href="#scala.util.parsing.combinator;Parsers.rep1sep.$anonfun.x" title="T">x</a><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: T)List[T]">::</a><a href="#scala.util.parsing.combinator;Parsers.rep1sep.$anonfun.y" title="List[T]">y</a><span class="delimiter">}</span>

  <span class="comment">/** A parser generator that, roughly, generalises the rep1sep generator so
   *  that `q`, which parses the separator, produces a left-associative
   *  function that combines the elements it separates.
   *
   *  ''From: J. Fokker. Functional parsers. In J. Jeuring and E. Meijer, editors, Advanced Functional Programming,
   *  volume 925 of Lecture Notes in Computer Science, pages 1--23. Springer, 1995.''
   *
   * @param p a parser that parses the elements
   * @param q a parser that parses the token(s) separating the elements, yielding a left-associative function that
   *          combines two elements into one
   */</span>
  def <a title="[T](p: =&gt; Parsers.this.Parser[T], q: =&gt; Parsers.this.Parser[(T, T) =&gt; T])Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.chainl1(199401a8c7)">chainl1</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.chainl1(199401a8c7);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.chainl1(199401a8c7).p">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; Parsers.this.Parser[(T, T) =&gt; T]" id="scala.util.parsing.combinator;Parsers.chainl1(199401a8c7).q">q</a>: =&gt; Parser<span class="delimiter">[</span><span class="delimiter">(</span>T, T<span class="delimiter">)</span> =&gt; T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
    = <a href="#scala.util.parsing.combinator;Parsers.chainl1(b00165f38a)" title="(first: =&gt; Parsers.this.Parser[T], p: =&gt; Parsers.this.Parser[T], q: =&gt; Parsers.this.Parser[(T, T) =&gt; T])Parsers.this.Parser[T]">chainl1</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.chainl1(199401a8c7).p" title="=&gt; Parsers.this.Parser[T]">p</a>, <a href="#scala.util.parsing.combinator;Parsers.chainl1(199401a8c7).p" title="=&gt; Parsers.this.Parser[T]">p</a>, <a href="#scala.util.parsing.combinator;Parsers.chainl1(199401a8c7).q" title="=&gt; Parsers.this.Parser[(T, T) =&gt; T]">q</a><span class="delimiter">)</span>

  <span class="comment">/** A parser generator that, roughly, generalises the `rep1sep` generator
   *  so that `q`, which parses the separator, produces a left-associative
   *  function that combines the elements it separates.
   *
   * @param first a parser that parses the first element
   * @param p a parser that parses the subsequent elements
   * @param q a parser that parses the token(s) separating the elements,
   *          yielding a left-associative function that combines two elements
   *          into one
   */</span>
  def <a title="[T, U](first: =&gt; Parsers.this.Parser[T], p: =&gt; Parsers.this.Parser[U], q: =&gt; Parsers.this.Parser[(T, U) =&gt; T])Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.chainl1(b00165f38a)">chainl1</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.chainl1(b00165f38a);T">T</a>, <a title="" id="scala.util.parsing.combinator;Parsers.chainl1(b00165f38a);U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).first">first</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).p">p</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span>, <a title="=&gt; Parsers.this.Parser[(T, U) =&gt; T]" id="scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).q">q</a>: =&gt; Parser<span class="delimiter">[</span><span class="delimiter">(</span>T, U<span class="delimiter">)</span> =&gt; T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
    = <a href="#scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).first" title="=&gt; Parsers.this.Parser[T]">first</a> <a href="#scala.util.parsing.combinator;Parsers;Parser.~" title="(q: =&gt; Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; T,U]]])Parsers.this.Parser[Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; T,U]]]]">~</a> <a href="#scala.util.parsing.combinator;Parsers.rep" title="(p: =&gt; Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; T,U]])Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; T,U]]]">rep</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).q" title="=&gt; Parsers.this.Parser[(T, U) =&gt; T]">q</a> <a href="#scala.util.parsing.combinator;Parsers;Parser.~" title="(q: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; T,U]]">~</a> <a href="#scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).p" title="=&gt; Parsers.this.Parser[U]">p</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers;Parser.^^" title="(f: Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; T,U]]] =&gt; T)Parsers.this.Parser[T]">^^</a> <a href="#scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).$anonfun.x0$2" title="T" class="delimiter">{</a>
        case <a title="T" id="scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).$anonfun.x">x</a> ~ <a title="List[Parsers.this.~[(T, U) =&gt; T,U]]" id="scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).$anonfun.xs">xs</a> =&gt; <a href="#scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).$anonfun.xs" title="List[Parsers.this.~[(T, U) =&gt; T,U]]">xs</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.foldLeft" title="(z: T)(f: (T, Parsers.this.~[(T, U) =&gt; T,U]) =&gt; T)T">foldLeft</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).$anonfun.x" title="T">x</a>: <a href="#scala.util.parsing.combinator;Parsers.chainl1(b00165f38a);T" title="T">T</a><span class="delimiter">)</span><a href="../../../Tuple2.scala.html#scala;Tuple2" title="T" class="delimiter">{</a>case <span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).$anonfun.$anonfun.a">a</a>, <a title="(T, U) =&gt; T" id="scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).$anonfun.$anonfun.f">f</a> ~ <a title="U" id="scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).$anonfun.$anonfun.b">b</a><span class="delimiter">)</span> =&gt; <a href="../../../Function2.scala.html#scala;Function2.apply" title="(v1: T, v2: U)T">f</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).$anonfun.$anonfun.a" title="T">a</a>, <a href="#scala.util.parsing.combinator;Parsers.chainl1(b00165f38a).$anonfun.$anonfun.b" title="U">b</a><span class="delimiter">)</span><span class="delimiter">}</span> <span class="comment">// x's type annotation is needed to deal with changed type inference due to SI-5189</span>
      <span class="delimiter">}</span>

  <span class="comment">/** A parser generator that generalises the `rep1sep` generator so that `q`,
   *  which parses the separator, produces a right-associative function that
   *  combines the elements it separates. Additionally, the right-most (last)
   *  element and the left-most combining function have to be supplied.
   *
   * rep1sep(p: Parser[T], q) corresponds to chainr1(p, q ^^ cons, cons, Nil) (where val cons = (x: T, y: List[T]) =&gt; x :: y)
   *
   * @param p a parser that parses the elements
   * @param q a parser that parses the token(s) separating the elements, yielding a right-associative function that
   *          combines two elements into one
   * @param combine the &quot;last&quot; (left-most) combination function to be applied
   * @param first   the &quot;first&quot; (right-most) element to be combined
   */</span>
  def <a title="[T, U](p: =&gt; Parsers.this.Parser[T], q: =&gt; Parsers.this.Parser[(T, U) =&gt; U], combine: (T, U) =&gt; U, first: U)Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers.chainr1">chainr1</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.chainr1;T">T</a>, <a title="" id="scala.util.parsing.combinator;Parsers.chainr1;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.chainr1.p">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="=&gt; Parsers.this.Parser[(T, U) =&gt; U]" id="scala.util.parsing.combinator;Parsers.chainr1.q">q</a>: =&gt; Parser<span class="delimiter">[</span><span class="delimiter">(</span>T, U<span class="delimiter">)</span> =&gt; U<span class="delimiter">]</span>, <a title="(T, U) =&gt; U" id="scala.util.parsing.combinator;Parsers.chainr1.combine">combine</a>: <span class="delimiter">(</span>T, U<span class="delimiter">)</span> =&gt; U, <a title="U" id="scala.util.parsing.combinator;Parsers.chainr1.first">first</a>: <a href="#scala.util.parsing.combinator;Parsers.chainr1;U" title="U">U</a><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[U]">Parser</a><span class="delimiter">[</span>U<span class="delimiter">]</span>
    = <a href="#scala.util.parsing.combinator;Parsers.chainr1.p" title="=&gt; Parsers.this.Parser[T]">p</a> <a href="#scala.util.parsing.combinator;Parsers;Parser.~" title="(q: =&gt; Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; U,T]]])Parsers.this.Parser[Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; U,T]]]]">~</a> <a href="#scala.util.parsing.combinator;Parsers.rep" title="(p: =&gt; Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; U,T]])Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; U,T]]]">rep</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.chainr1.q" title="=&gt; Parsers.this.Parser[(T, U) =&gt; U]">q</a> <a href="#scala.util.parsing.combinator;Parsers;Parser.~" title="(q: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; U,T]]">~</a> <a href="#scala.util.parsing.combinator;Parsers.chainr1.p" title="=&gt; Parsers.this.Parser[T]">p</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers;Parser.^^" title="(f: Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; U,T]]] =&gt; U)Parsers.this.Parser[U]">^^</a> <a href="#scala.util.parsing.combinator;Parsers.chainr1.$anonfun.x0$4" title="U" class="delimiter">{</a>
        case <a title="T" id="scala.util.parsing.combinator;Parsers.chainr1.$anonfun.x">x</a> ~ <a title="List[Parsers.this.~[(T, U) =&gt; U,T]]" id="scala.util.parsing.combinator;Parsers.chainr1.$anonfun.xs">xs</a> =&gt; <span class="delimiter">(</span>new <a href="#scala.util.parsing.combinator;Parsers.~.readResolve" title="Parsers.this.~[(T, U) =&gt; U,T]">~</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.chainr1.combine" title="(T, U) =&gt; U">combine</a>, <a href="#scala.util.parsing.combinator;Parsers.chainr1.$anonfun.x" title="T">x</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Parsers.this.~[(T, U) =&gt; U,T])List[Parsers.this.~[(T, U) =&gt; U,T]]">::</a> <a href="#scala.util.parsing.combinator;Parsers.chainr1.$anonfun.xs" title="List[Parsers.this.~[(T, U) =&gt; U,T]]">xs</a><span class="delimiter">)</span>.<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.foldRight" title="(z: U)(op: (Parsers.this.~[(T, U) =&gt; U,T], U) =&gt; U)U">foldRight</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.chainr1.first" title="U">first</a><span class="delimiter">)</span><a href="../../../Tuple2.scala.html#scala;Tuple2" title="U" class="delimiter">{</a>case <span class="delimiter">(</span><a title="(T, U) =&gt; U" id="scala.util.parsing.combinator;Parsers.chainr1.$anonfun.$anonfun.f">f</a> ~ <a title="T" id="scala.util.parsing.combinator;Parsers.chainr1.$anonfun.$anonfun.a">a</a>, <a title="U" id="scala.util.parsing.combinator;Parsers.chainr1.$anonfun.$anonfun.b">b</a><span class="delimiter">)</span> =&gt; <a href="../../../Function2.scala.html#scala;Function2.apply" title="(v1: T, v2: U)U">f</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.chainr1.$anonfun.$anonfun.a" title="T">a</a>, <a href="#scala.util.parsing.combinator;Parsers.chainr1.$anonfun.$anonfun.b" title="U">b</a><span class="delimiter">)</span><span class="delimiter">}</span>
      <span class="delimiter">}</span>

  <span class="comment">/** A parser generator for optional sub-phrases.
   *
   *  `opt(p)` is a parser that returns `Some(x)` if `p` returns `x` and `None` if `p` fails.
   *
   * @param p A `Parser` that is tried on the input
   * @return a `Parser` that always succeeds: either with the result provided by `p` or
   *         with the empty result
   */</span>
  def <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[Option[T]]" id="scala.util.parsing.combinator;Parsers.opt">opt</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.opt;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.opt.p">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[Option[T]]">Parser</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#scala.util.parsing.combinator;Parsers.opt.p" title="=&gt; Parsers.this.Parser[T]">p</a> <a href="#scala.util.parsing.combinator;Parsers;Parser.^^" title="(f: T =&gt; Some[T])Parsers.this.Parser[Some[T]]">^^</a> <span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers.opt.$anonfun.x">x</a> =&gt; <a href="../../../Option.scala.html#scala;Some" title="(x: T)Some[T]">Some</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.opt.$anonfun.x" title="T">x</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers;Parser.|" title="(q: =&gt; Parsers.this.Parser[Option[T]])Parsers.this.Parser[Option[T]]">|</a> <a href="#scala.util.parsing.combinator;Parsers.success" title="(v: None.type)Parsers.this.Parser[None.type]">success</a><span class="delimiter">(</span><a href="../../../Option.scala.html#scala.None" title="None.type">None</a><span class="delimiter">)</span>

  <span class="comment">/** Wrap a parser so that its failures and errors become success and
   *  vice versa -- it never consumes any input.
   */</span>
  def <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[Unit]" id="scala.util.parsing.combinator;Parsers.not">not</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.not;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.not.p">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[Unit]">Parser</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[Unit])Parsers.this.Parser[Unit]">Parser</a> <span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.not.$anonfun.in">in</a> =&gt;
    <a href="#scala.util.parsing.combinator;Parsers;Parser.apply" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.not.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case Success<span class="delimiter">(</span>_, _<span class="delimiter">)</span>  =&gt; <a href="#scala.util.parsing.combinator;Parsers.Failure.readResolve" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><span title="String(&quot;Expected failure&quot;)" class="string">&quot;Expected failure&quot;</span>, <a href="#scala.util.parsing.combinator;Parsers.not.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
      case _              =&gt; <a href="#scala.util.parsing.combinator;Parsers.Success.readResolve" title="(result: Unit, next: Parsers.this.Input)Parsers.this.Success[Unit]">Success</a><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#scala.util.parsing.combinator;Parsers.not.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A parser generator for guard expressions. The resulting parser will
   *  fail or succeed just like the one given as parameter but it will not
   *  consume any input.
   *
   * @param p a `Parser` that is to be applied to the input
   * @return A parser that returns success if and only if `p` succeeds but
   *         never consumes any input
   */</span>
  def <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.guard">guard</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.guard;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.guard.p">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a> <span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.guard.$anonfun.in">in</a> =&gt;
    <a href="#scala.util.parsing.combinator;Parsers;Parser.apply" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.guard.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> match<span class="delimiter">{</span>
      case <a title="Parsers.this.Success[T]" id="scala.util.parsing.combinator;Parsers.guard.$anonfun.s">s</a>@ Success<span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers.guard.$anonfun.s1">s1</a>,_<span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;Parsers.Success.readResolve" title="(result: T, next: Parsers.this.Input)Parsers.this.Success[T]">Success</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.guard.$anonfun.s1" title="T">s1</a>, <a href="#scala.util.parsing.combinator;Parsers.guard.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span>
      case <a title="Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers.guard.$anonfun.e">e</a> =&gt; <a href="#scala.util.parsing.combinator;Parsers.guard.$anonfun.e" title="Parsers.this.ParseResult[T]">e</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** `positioned` decorates a parser's result with the start position of the
   *  input it consumed.
   *
   * @param p a `Parser` whose result conforms to `Positional`.
   * @return A parser that has the same behaviour as `p`, but which marks its
   *         result with the start position of the input it consumed,
   *         if it didn't already have a position.
   */</span>
  def <a title="[T &lt;: scala.util.parsing.input.Positional](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.positioned">positioned</a><span class="delimiter">[</span><a title=" &lt;: scala.util.parsing.input.Positional" id="scala.util.parsing.combinator;Parsers.positioned;T">T</a> &lt;: Positional<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.positioned.p">p</a>: =&gt; Parser<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#scala.util.parsing.combinator;Parsers.Parser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a> <span class="delimiter">{</span> <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.positioned.$anonfun.in">in</a> =&gt;
    <a href="#scala.util.parsing.combinator;Parsers;Parser.apply" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.positioned.$anonfun.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case Success<span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers.positioned.$anonfun.t">t</a>, <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.positioned.$anonfun.in1">in1</a><span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;Parsers.Success.readResolve" title="(result: T, next: Parsers.this.Input)Parsers.this.Success[T]">Success</a><span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.positioned.$anonfun.t" title="T">t</a>.<a href="../input/Positional.scala.html#scala.util.parsing.input;Positional.pos" title="=&gt; scala.util.parsing.input.Position">pos</a> <span title="(x$1: Any)Boolean">==</span> <a href="../input/NoPosition.scala.html#scala.util.parsing.input.NoPosition" title="scala.util.parsing.input.NoPosition.type">NoPosition</a><span class="delimiter">)</span> <a href="#scala.util.parsing.combinator;Parsers.positioned.$anonfun.t" title="T">t</a> <a href="../input/Positional.scala.html#scala.util.parsing.input;Positional.setPos" title="(newpos: scala.util.parsing.input.Position)t.type">setPos</a> <a href="#scala.util.parsing.combinator;Parsers.positioned.$anonfun.in" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a> else <a href="#scala.util.parsing.combinator;Parsers.positioned.$anonfun.t" title="T">t</a>, <a href="#scala.util.parsing.combinator;Parsers.positioned.$anonfun.in1" title="Parsers.this.Input">in1</a><span class="delimiter">)</span>
      case <a title="Parsers.this.NoSuccess" id="scala.util.parsing.combinator;Parsers.positioned.$anonfun.ns">ns</a>: <a href="#scala.util.parsing.combinator;Parsers;NoSuccess" title="Parsers.this.NoSuccess">NoSuccess</a> =&gt; <a href="#scala.util.parsing.combinator;Parsers.positioned.$anonfun.ns" title="Parsers.this.NoSuccess">ns</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A parser generator delimiting whole phrases (i.e. programs).
   *
   *  `phrase(p)` succeeds if `p` succeeds and no input is left over after `p`.
   *
   *  @param p the parser that must consume all input for the resulting parser
   *           to succeed.
   *  @return  a parser that has the same result as `p`, but that only succeeds
   *           if `p` consumed all the input.
   */</span>
  def <a title="[T](p: Parsers.this.Parser[T])Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.phrase">phrase</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.phrase;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.phrase.p">p</a>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> = new <a title="&lt;$anon: Parsers.this.Input =&gt; Parsers.this.ParseResult[T]&gt; extends Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers.phrase;$anon">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers.phrase;$anon.apply">apply</a><span class="delimiter">(</span><a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.phrase;$anon.apply.in">in</a>: <a href="../input/Reader.scala.html#scala.util.parsing.input;Reader" title="Parsers.this.Input">Input</a><span class="delimiter">)</span> = <a href="#scala.util.parsing.combinator;Parsers.lastNoSuccessVar" title="=&gt; scala.util.DynamicVariable[Option[Parsers.this.NoSuccess]]">lastNoSuccessVar</a>.<a href="../../DynamicVariable.scala.html#scala.util;DynamicVariable.withValue" title="(newval: Option[Parsers.this.NoSuccess])(thunk: =&gt; Parsers.this.ParseResult[T])Parsers.this.ParseResult[T]">withValue</a><span class="delimiter">(</span><a href="../../../Option.scala.html#scala.None" title="None.type">None</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#scala.util.parsing.combinator;Parsers;Parser.apply" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.phrase;$anon.apply.in" title="Parsers.this.Input">in</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case <a title="Parsers.this.Success[T]" id="scala.util.parsing.combinator;Parsers.phrase;$anon.apply.s">s</a> @ Success<span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers.phrase;$anon.apply.out">out</a>, <a title="Parsers.this.Input" id="scala.util.parsing.combinator;Parsers.phrase;$anon.apply.in1">in1</a><span class="delimiter">)</span> =&gt;
        if <span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.phrase;$anon.apply.in1" title="Parsers.this.Input">in1</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.atEnd" title="=&gt; Boolean">atEnd</a><span class="delimiter">)</span>
          <a href="#scala.util.parsing.combinator;Parsers.phrase;$anon.apply.s" title="Parsers.this.Success[T]">s</a>
        else
            <a href="#scala.util.parsing.combinator;Parsers.lastNoSuccessVar" title="=&gt; scala.util.DynamicVariable[Option[Parsers.this.NoSuccess]]">lastNoSuccessVar</a>.<a href="../../DynamicVariable.scala.html#scala.util;DynamicVariable.value" title="=&gt; Option[Parsers.this.NoSuccess]">value</a> <a href="../../../Option.scala.html#scala;Option.filterNot" title="(p: Parsers.this.NoSuccess =&gt; Boolean)Option[Parsers.this.NoSuccess]">filterNot</a> <span class="delimiter">{</span> <a href="#scala.util.parsing.combinator;Parsers.phrase;$anon.apply.$anonfun.x$6" title="Parsers.this.NoSuccess">_</a>.<a href="#scala.util.parsing.combinator;Parsers;NoSuccess.next" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a> <a href="../input/Position.scala.html#scala.util.parsing.input;Position.<" title="(that: scala.util.parsing.input.Position)Boolean">&lt;</a> <a href="#scala.util.parsing.combinator;Parsers.phrase;$anon.apply.in1" title="Parsers.this.Input">in1</a>.<a href="../input/Reader.scala.html#scala.util.parsing.input;Reader.pos" title="=&gt; scala.util.parsing.input.Position">pos</a> <span class="delimiter">}</span> <a href="../../../Option.scala.html#scala;Option.getOrElse" title="(default: =&gt; Parsers.this.NoSuccess)Parsers.this.NoSuccess">getOrElse</a> <a href="#scala.util.parsing.combinator;Parsers.Failure.readResolve" title="(msg: String, next: Parsers.this.Input)Parsers.this.Failure">Failure</a><span class="delimiter">(</span><span title="String(&quot;end of input expected&quot;)" class="string">&quot;end of input expected&quot;</span>, <a href="#scala.util.parsing.combinator;Parsers.phrase;$anon.apply.in1" title="Parsers.this.Input">in1</a><span class="delimiter">)</span>
        case <a title="Parsers.this.ParseResult[T]" id="scala.util.parsing.combinator;Parsers.phrase;$anon.apply.ns">ns</a> =&gt; <a href="#scala.util.parsing.combinator;Parsers.lastNoSuccessVar" title="=&gt; scala.util.DynamicVariable[Option[Parsers.this.NoSuccess]]">lastNoSuccessVar</a>.<a href="../../DynamicVariable.scala.html#scala.util;DynamicVariable.value" title="=&gt; Option[Parsers.this.NoSuccess]">value</a>.<a href="../../../Option.scala.html#scala;Option.getOrElse" title="(default: =&gt; Parsers.this.ParseResult[T])Parsers.this.ParseResult[T]">getOrElse</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.phrase;$anon.apply.ns" title="Parsers.this.ParseResult[T]">ns</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Given a concatenation with a repetition (list), move the concatenated element into the list */</span>
  def <a title="[T]=&gt; Parsers.this.~[T,List[T]] =&gt; List[T]" id="scala.util.parsing.combinator;Parsers.mkList">mkList</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers.mkList;T">T</a><span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers.mkList.$anonfun.x$7" title="Parsers.this.~[T,List[T]]">_</a>: <a href="#scala.util.parsing.combinator;Parsers.~.readResolve" title="Parsers.this.~[T,List[T]]">~</a><span class="delimiter">[</span>T, List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> match <span class="delimiter">{</span> case <a title="T" id="scala.util.parsing.combinator;Parsers.mkList.$anonfun.x">x</a> ~ <a title="List[T]" id="scala.util.parsing.combinator;Parsers.mkList.$anonfun.xs">xs</a> =&gt; <a href="#scala.util.parsing.combinator;Parsers.mkList.$anonfun.x" title="T">x</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: T)List[T]">::</a> <a href="#scala.util.parsing.combinator;Parsers.mkList.$anonfun.xs" title="List[T]">xs</a> <span class="delimiter">}</span>

  <span class="comment">/** A wrapper over sequence of matches.
   *
   *  Given `p1: Parser[A]` and `p2: Parser[B]`, a parser composed with
   *  `p1 ~ p2` will have type `Parser[~[A, B]]`. The successful result
   *  of the parser can be extracted from this case class.
   *
   *  It also enables pattern matching, so something like this is possible:
   *
   *  {{{
   *  def concat(p1: Parser[String], p2: Parser[String]): Parser[String] =
   *    p1 ~ p2 ^^ { case a ~ b =&gt; a + b }
   *  }}}
   */</span>
  case class <a href="#scala.util.parsing.combinator;Parsers;~.productElement.x$1" title="class ~[+a, +b] extends AnyRef with Product with Serializable" id="scala.util.parsing.combinator;Parsers.~.readResolve">~</a><span class="delimiter">[</span>+<a title="" id="scala.util.parsing.combinator;Parsers;~;a">a</a>, +<a title="" id="scala.util.parsing.combinator;Parsers;~;b">b</a><span class="delimiter">]</span><a href="../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="a" id="scala.util.parsing.combinator;Parsers;~._1">_1</a>: <a href="#scala.util.parsing.combinator;Parsers;~;a" title="a">a</a>, <a title="b" id="scala.util.parsing.combinator;Parsers;~._2">_2</a>: <a href="#scala.util.parsing.combinator;Parsers;~;b" title="b">b</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    override def <a title="()String" id="scala.util.parsing.combinator;Parsers;~.toString">toString</a> = <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.util.parsing.combinator;Parsers;~._1" title="=&gt; a">_1</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;~&quot;)" class="string">&quot;~&quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.util.parsing.combinator;Parsers;~._2" title="=&gt; b">_2</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A parser whose `~` combinator disallows back-tracking.
   */</span>
  trait <a title="trait OnceParser[+T] extends Parsers.this.Parser[T]" id="scala.util.parsing.combinator;Parsers;OnceParser">OnceParser</a><span class="delimiter">[</span>+<a title="" id="scala.util.parsing.combinator;Parsers;OnceParser;T">T</a><span class="delimiter">]</span> extends <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[T]">Parser</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
    override def <a title="[U](p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[T,U]]" id="scala.util.parsing.combinator;Parsers;OnceParser.~">~</a> <span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;Parsers;OnceParser.~;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; Parsers.this.Parser[U]" id="scala.util.parsing.combinator;Parsers;OnceParser.~.p">p</a>: =&gt; Parser<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.util.parsing.combinator;Parsers;Parser" title="Parsers.this.Parser[Parsers.this.~[T,U]]">Parser</a><span class="delimiter">[</span>~<span class="delimiter">[</span>T, U<span class="delimiter">]</span><span class="delimiter">]</span>
      = <a href="#scala.util.parsing.combinator;Parsers.OnceParser" title="(f: Parsers.this.Input =&gt; Parsers.this.ParseResult[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]] with Parsers.this.OnceParser[Parsers.this.~[T,U]]">OnceParser</a><span class="delimiter">{</span> <span class="delimiter">(</span>for<span class="delimiter">(</span><a title="T" id="scala.util.parsing.combinator;Parsers;OnceParser.~.$anonfun.a">a</a> &lt;- this; <a title="U" id="scala.util.parsing.combinator;Parsers;OnceParser.~.$anonfun.$anonfun.b">b</a> &lt;- <a href="#scala.util.parsing.combinator;Parsers.commit" title="(p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">commit</a><a href="#scala.util.parsing.combinator;Parsers;Parser.map" title="(f: U =&gt; Parsers.this.~[T,U])Parsers.this.Parser[Parsers.this.~[T,U]]" class="delimiter">(</a><a href="#scala.util.parsing.combinator;Parsers;OnceParser.~.p" title="=&gt; Parsers.this.Parser[U]">p</a><span class="delimiter">)</span><span class="delimiter">)</span> yield new <a href="#scala.util.parsing.combinator;Parsers.~.readResolve" title="Parsers.this.~[T,U]">~</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;Parsers;OnceParser.~.$anonfun.a" title="T">a</a>,<a href="#scala.util.parsing.combinator;Parsers;OnceParser.~.$anonfun.$anonfun.b" title="U">b</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#scala.util.parsing.combinator;Parsers;Parser.named" title="(n: String)Parsers.this.Parser[Parsers.this.~[T,U]]">named</a><span class="delimiter">(</span><span title="String(&quot;~&quot;)" class="string">&quot;~&quot;</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
