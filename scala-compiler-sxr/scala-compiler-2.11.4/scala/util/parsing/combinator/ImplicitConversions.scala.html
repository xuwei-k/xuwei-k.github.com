<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/util/parsing/combinator/ImplicitConversions.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2006-2013, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |                                         **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>


package scala
package util.parsing.combinator

import scala.<a href="../../../language.scala.html#scala.language" title="language.type">language</a>.implicitConversions

<span class="comment">/** This object contains implicit conversions that come in handy when using the `^^` combinator.
 *
 *  Refer to [[scala.util.parsing.combinator.Parsers]] to construct an AST from the concrete syntax.
 *
 * The reason for this is that the sequential composition combinator (`~`) combines its constituents
 * into a ~. When several `~`s are combined, this results in nested `~`s (to the left).
 * The `flatten*` coercions makes it easy to apply an `n`-argument function to a nested `~` of
 * depth `n-1`
 *
 * The `headOptionTailToFunList` converts a function that takes a `List[A]` to a function that
 * accepts a `~[A, Option[List[A]]]` (this happens when parsing something of the following
 * shape: `p ~ opt(&quot;.&quot; ~ repsep(p, &quot;.&quot;))` -- where `p` is a parser that yields an `A`).
 *
 * @author Martin Odersky
 * @author Iulian Dragos
 * @author Adriaan Moors
 */</span>
trait <a title="trait ImplicitConversions extends AnyRef" id="scala.util.parsing.combinator;ImplicitConversions">ImplicitConversions</a> <a href="../../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a> self: Parsers =&gt;
  implicit def <a title="[A, B, C](f: (A, B) =&gt; C)ImplicitConversions.this.~[A,B] =&gt; C" id="scala.util.parsing.combinator;ImplicitConversions.flatten2">flatten2</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten2;A">A</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten2;B">B</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten2;C">C</a><span class="delimiter">]</span>         <span class="delimiter">(</span><a title="(A, B) =&gt; C" id="scala.util.parsing.combinator;ImplicitConversions.flatten2.f">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span> =
    <span class="delimiter">(</span>p: <a href="Parsers.scala.html#scala.util.parsing.combinator;Parsers;~" title="ImplicitConversions.this.~[A,B]">~</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;ImplicitConversions.flatten2.$anonfun.p" title="ImplicitConversions.this.~[A,B]">p</a> match <span class="delimiter">{</span>case <a title="A" id="scala.util.parsing.combinator;ImplicitConversions.flatten2.$anonfun.a">a</a> ~ <a title="B" id="scala.util.parsing.combinator;ImplicitConversions.flatten2.$anonfun.b">b</a> =&gt; <a href="../../../Function2.scala.html#scala;Function2.apply" title="(v1: A, v2: B)C">f</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;ImplicitConversions.flatten2.$anonfun.a" title="A">a</a>, <a href="#scala.util.parsing.combinator;ImplicitConversions.flatten2.$anonfun.b" title="B">b</a><span class="delimiter">)</span><span class="delimiter">}</span>
  implicit def <a title="[A, B, C, D](f: (A, B, C) =&gt; D)ImplicitConversions.this.~[ImplicitConversions.this.~[A,B],C] =&gt; D" id="scala.util.parsing.combinator;ImplicitConversions.flatten3">flatten3</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten3;A">A</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten3;B">B</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten3;C">C</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten3;D">D</a><span class="delimiter">]</span>      <span class="delimiter">(</span><a title="(A, B, C) =&gt; D" id="scala.util.parsing.combinator;ImplicitConversions.flatten3.f">f</a>: <span class="delimiter">(</span>A, B, C<span class="delimiter">)</span> =&gt; D<span class="delimiter">)</span> =
    <span class="delimiter">(</span>p: <a href="Parsers.scala.html#scala.util.parsing.combinator;Parsers;~" title="ImplicitConversions.this.~[ImplicitConversions.this.~[A,B],C]">~</a><span class="delimiter">[</span>~<span class="delimiter">[</span>A, B<span class="delimiter">]</span>, C<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;ImplicitConversions.flatten3.$anonfun.p" title="ImplicitConversions.this.~[ImplicitConversions.this.~[A,B],C]">p</a> match <span class="delimiter">{</span>case <a title="A" id="scala.util.parsing.combinator;ImplicitConversions.flatten3.$anonfun.a">a</a> ~ <a title="B" id="scala.util.parsing.combinator;ImplicitConversions.flatten3.$anonfun.b">b</a> ~ <a title="C" id="scala.util.parsing.combinator;ImplicitConversions.flatten3.$anonfun.c">c</a> =&gt; <a href="../../../Function3.scala.html#scala;Function3.apply" title="(v1: A, v2: B, v3: C)D">f</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;ImplicitConversions.flatten3.$anonfun.a" title="A">a</a>, <a href="#scala.util.parsing.combinator;ImplicitConversions.flatten3.$anonfun.b" title="B">b</a>, <a href="#scala.util.parsing.combinator;ImplicitConversions.flatten3.$anonfun.c" title="C">c</a><span class="delimiter">)</span><span class="delimiter">}</span>
  implicit def <a title="[A, B, C, D, E](f: (A, B, C, D) =&gt; E)ImplicitConversions.this.~[ImplicitConversions.this.~[ImplicitConversions.this.~[A,B],C],D] =&gt; E" id="scala.util.parsing.combinator;ImplicitConversions.flatten4">flatten4</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten4;A">A</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten4;B">B</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten4;C">C</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten4;D">D</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten4;E">E</a><span class="delimiter">]</span>   <span class="delimiter">(</span><a title="(A, B, C, D) =&gt; E" id="scala.util.parsing.combinator;ImplicitConversions.flatten4.f">f</a>: <span class="delimiter">(</span>A, B, C, D<span class="delimiter">)</span> =&gt; E<span class="delimiter">)</span> =
    <span class="delimiter">(</span>p: <a href="Parsers.scala.html#scala.util.parsing.combinator;Parsers;~" title="ImplicitConversions.this.~[ImplicitConversions.this.~[ImplicitConversions.this.~[A,B],C],D]">~</a><span class="delimiter">[</span>~<span class="delimiter">[</span>~<span class="delimiter">[</span>A, B<span class="delimiter">]</span>, C<span class="delimiter">]</span>, D<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;ImplicitConversions.flatten4.$anonfun.p" title="ImplicitConversions.this.~[ImplicitConversions.this.~[ImplicitConversions.this.~[A,B],C],D]">p</a> match <span class="delimiter">{</span>case <a title="A" id="scala.util.parsing.combinator;ImplicitConversions.flatten4.$anonfun.a">a</a> ~ <a title="B" id="scala.util.parsing.combinator;ImplicitConversions.flatten4.$anonfun.b">b</a> ~ <a title="C" id="scala.util.parsing.combinator;ImplicitConversions.flatten4.$anonfun.c">c</a> ~ <a title="D" id="scala.util.parsing.combinator;ImplicitConversions.flatten4.$anonfun.d">d</a> =&gt; <a href="../../../Function4.scala.html#scala;Function4.apply" title="(v1: A, v2: B, v3: C, v4: D)E">f</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;ImplicitConversions.flatten4.$anonfun.a" title="A">a</a>, <a href="#scala.util.parsing.combinator;ImplicitConversions.flatten4.$anonfun.b" title="B">b</a>, <a href="#scala.util.parsing.combinator;ImplicitConversions.flatten4.$anonfun.c" title="C">c</a>, <a href="#scala.util.parsing.combinator;ImplicitConversions.flatten4.$anonfun.d" title="D">d</a><span class="delimiter">)</span><span class="delimiter">}</span>
  implicit def <a title="[A, B, C, D, E, F](f: (A, B, C, D, E) =&gt; F)ImplicitConversions.this.~[ImplicitConversions.this.~[ImplicitConversions.this.~[ImplicitConversions.this.~[A,B],C],D],E] =&gt; F" id="scala.util.parsing.combinator;ImplicitConversions.flatten5">flatten5</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten5;A">A</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten5;B">B</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten5;C">C</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten5;D">D</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten5;E">E</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.flatten5;F">F</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(A, B, C, D, E) =&gt; F" id="scala.util.parsing.combinator;ImplicitConversions.flatten5.f">f</a>: <span class="delimiter">(</span>A, B, C, D, E<span class="delimiter">)</span> =&gt; F<span class="delimiter">)</span> =
    <span class="delimiter">(</span>p: <a href="Parsers.scala.html#scala.util.parsing.combinator;Parsers;~" title="ImplicitConversions.this.~[ImplicitConversions.this.~[ImplicitConversions.this.~[ImplicitConversions.this.~[A,B],C],D],E]">~</a><span class="delimiter">[</span>~<span class="delimiter">[</span>~<span class="delimiter">[</span>~<span class="delimiter">[</span>A, B<span class="delimiter">]</span>, C<span class="delimiter">]</span>, D<span class="delimiter">]</span>, E<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;ImplicitConversions.flatten5.$anonfun.p" title="ImplicitConversions.this.~[ImplicitConversions.this.~[ImplicitConversions.this.~[ImplicitConversions.this.~[A,B],C],D],E]">p</a> match <span class="delimiter">{</span>case <a title="A" id="scala.util.parsing.combinator;ImplicitConversions.flatten5.$anonfun.a">a</a> ~ <a title="B" id="scala.util.parsing.combinator;ImplicitConversions.flatten5.$anonfun.b">b</a> ~ <a title="C" id="scala.util.parsing.combinator;ImplicitConversions.flatten5.$anonfun.c">c</a> ~ <a title="D" id="scala.util.parsing.combinator;ImplicitConversions.flatten5.$anonfun.d">d</a> ~ <a title="E" id="scala.util.parsing.combinator;ImplicitConversions.flatten5.$anonfun.e">e</a>=&gt; <a href="../../../Function5.scala.html#scala;Function5.apply" title="(v1: A, v2: B, v3: C, v4: D, v5: E)F">f</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;ImplicitConversions.flatten5.$anonfun.a" title="A">a</a>, <a href="#scala.util.parsing.combinator;ImplicitConversions.flatten5.$anonfun.b" title="B">b</a>, <a href="#scala.util.parsing.combinator;ImplicitConversions.flatten5.$anonfun.c" title="C">c</a>, <a href="#scala.util.parsing.combinator;ImplicitConversions.flatten5.$anonfun.d" title="D">d</a>, <a href="#scala.util.parsing.combinator;ImplicitConversions.flatten5.$anonfun.e" title="E">e</a><span class="delimiter">)</span><span class="delimiter">}</span>
  implicit def <a title="[A, T](f: List[A] =&gt; T)ImplicitConversions.this.~[A,Option[List[A]]] =&gt; T" id="scala.util.parsing.combinator;ImplicitConversions.headOptionTailToFunList">headOptionTailToFunList</a><span class="delimiter">[</span><a title="" id="scala.util.parsing.combinator;ImplicitConversions.headOptionTailToFunList;A">A</a>, <a title="" id="scala.util.parsing.combinator;ImplicitConversions.headOptionTailToFunList;T">T</a><span class="delimiter">]</span> <span class="delimiter">(</span><a title="List[A] =&gt; T" id="scala.util.parsing.combinator;ImplicitConversions.headOptionTailToFunList.f">f</a>: List<span class="delimiter">[</span>A<span class="delimiter">]</span> =&gt; T<span class="delimiter">)</span>=
    <span class="delimiter">(</span>p: <a href="Parsers.scala.html#scala.util.parsing.combinator;Parsers;~" title="ImplicitConversions.this.~[A,Option[List[A]]]">~</a><span class="delimiter">[</span>A, Option<span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: List[A])T">f</a><span class="delimiter">(</span><a href="#scala.util.parsing.combinator;ImplicitConversions.headOptionTailToFunList.$anonfun.p" title="ImplicitConversions.this.~[A,Option[List[A]]]">p</a>.<a href="Parsers.scala.html#scala.util.parsing.combinator;Parsers;~._1" title="=&gt; A">_1</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: A)List[A]">::</a> <span class="delimiter">(</span><a href="#scala.util.parsing.combinator;ImplicitConversions.headOptionTailToFunList.$anonfun.p" title="ImplicitConversions.this.~[A,Option[List[A]]]">p</a>.<a href="Parsers.scala.html#scala.util.parsing.combinator;Parsers;~._2" title="=&gt; Option[List[A]]">_2</a> match <span class="delimiter">{</span> case Some<span class="delimiter">(</span><a title="List[A]" id="scala.util.parsing.combinator;ImplicitConversions.headOptionTailToFunList.$anonfun.xs">xs</a><span class="delimiter">)</span> =&gt; <a href="#scala.util.parsing.combinator;ImplicitConversions.headOptionTailToFunList.$anonfun.xs" title="List[A]">xs</a> case <a href="../../../Option.scala.html#scala.None" title="None.type">None</a> =&gt; <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
