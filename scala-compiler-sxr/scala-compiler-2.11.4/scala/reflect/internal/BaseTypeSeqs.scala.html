<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/reflect/internal/BaseTypeSeqs.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* NSC -- new Scala compiler
 * Copyright 2005-2013 LAMP/EPFL
 * @author  Martin Odersky
 */</span>
package scala
package reflect
package internal

<span class="comment">// todo implement in terms of BitSet</span>
import scala.collection.<span class="delimiter">{</span> mutable, immutable <span class="delimiter">}</span>
import scala.math.max
import util.Statistics

<span class="comment">/** A base type sequence (BaseTypeSeq) is an ordered sequence spanning all the base types
 *  of a type. It characterized by the following two laws:
 *
 *  (1) Each element of `tp.baseTypeSeq`  is a basetype of `tp`
 *  (2) For each basetype `bt1` of `tp` there is an element `bt` in `tp.baseTypeSeq` such that
 *
 *      bt.typeSymbol = bt1.typeSymbol
 *      bt &lt;: bt1
 *
 *  (3) The type symbols of different elements are different.
 *
 *  Elements in the sequence are ordered by Symbol.isLess.
 *  @note base type sequences were called closures up to 2.7.1. The name has been changed
 *  to avoid confusion with function closures.
 */</span>
trait <a title="trait BaseTypeSeqs extends AnyRef" id="scala.reflect.internal;BaseTypeSeqs">BaseTypeSeqs</a> <a href="../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a>
  this: SymbolTable =&gt;
  import <a href="Definitions.scala.html#scala.reflect.internal;Definitions.definitions" title="BaseTypeSeqs.this.definitions.type">definitions</a>._
  import <a href="#scala.reflect.internal.BaseTypeSeqsStats" title="scala.reflect.internal.BaseTypeSeqsStats.type">BaseTypeSeqsStats</a>._

  protected def <a title="(parents: List[BaseTypeSeqs.this.Type], elems: Array[BaseTypeSeqs.this.Type])BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs.newBaseTypeSeq">newBaseTypeSeq</a><span class="delimiter">(</span><a title="List[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs.newBaseTypeSeq.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[BaseTypeSeqs.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Array[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs.newBaseTypeSeq.elems">elems</a>: <a href="../../Array.scala.html#scala;Array" title="Array[BaseTypeSeqs.this.Type]">Array</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
    new <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="BaseTypeSeqs.this.BaseTypeSeq">BaseTypeSeq</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.newBaseTypeSeq.parents" title="List[BaseTypeSeqs.this.Type]">parents</a>, <a href="#scala.reflect.internal;BaseTypeSeqs.newBaseTypeSeq.elems" title="Array[BaseTypeSeqs.this.Type]">elems</a><span class="delimiter">)</span>

  <span class="comment">/** Note: constructor is protected to force everyone to use the factory method newBaseTypeSeq instead.
   *  This is necessary because when run from reflection every base type sequence needs to have a
   *  SynchronizedBaseTypeSeq as mixin.
   */</span>
  class <a title="class BaseTypeSeq extends AnyRef" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq">BaseTypeSeq</a> protected<span class="delimiter">[</span>reflect<span class="delimiter">]</span> <span class="delimiter">(</span>private<span class="delimiter">[</span>BaseTypeSeqs<span class="delimiter">]</span> val <a title="List[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[BaseTypeSeqs.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, private<span class="delimiter">[</span>BaseTypeSeqs<span class="delimiter">]</span> val <a title="Array[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.elems">elems</a>: <a href="../../Array.scala.html#scala;Array" title="Array[BaseTypeSeqs.this.Type]">Array</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  self =&gt;
    if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.incCounter(456ea4fa07)" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="#scala.reflect.internal.BaseTypeSeqsStats.baseTypeSeqCount" title="=&gt; scala.reflect.internal.util.Statistics.Counter">baseTypeSeqCount</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.incCounter(e3d5d10146)" title="(c: scala.reflect.internal.util.Statistics.Counter, delta: Int)Unit">incCounter</a><span class="delimiter">(</span><a href="#scala.reflect.internal.BaseTypeSeqsStats.baseTypeSeqLenTotal" title="=&gt; scala.reflect.internal.util.Statistics.Counter">baseTypeSeqLenTotal</a>, <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.elems" title="=&gt; Array[BaseTypeSeqs.this.Type]">elems</a>.<a href="../../Array.scala.html#scala;Array.length" title="=&gt; Int">length</a><span class="delimiter">)</span>

    <span class="comment">/** The number of types in the sequence */</span>
    def <a title="=&gt; Int" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.length">length</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> = <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.elems" title="=&gt; Array[BaseTypeSeqs.this.Type]">elems</a>.<a href="../../Array.scala.html#scala;Array.length" title="=&gt; Int">length</a>

    <span class="comment">// #3676 shows why we can't store NoType in elems to mark cycles</span>
    <span class="comment">// (while NoType is in there to indicate a cycle in this BTS, during the execution of</span>
    <span class="comment">//  the mergePrefixAndArgs below, the elems get copied without the pending map,</span>
    <span class="comment">//  so that NoType's are seen instead of the original type --&gt; spurious compile error)</span>
    private val <a title="scala.collection.mutable.BitSet" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.pending">pending</a> = new mutable.<a href="../../collection/mutable/BitSet.scala.html#scala.collection.mutable;BitSet" title="scala.collection.mutable.BitSet">BitSet</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.length" title="=&gt; Int">length</a><span class="delimiter">)</span>

    <span class="comment">/** The type at i'th position in this sequence; lazy types are returned evaluated. */</span>
    def <a title="(i: Int)BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply">apply</a><span class="delimiter">(</span><a title="Int" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="BaseTypeSeqs.this.Type">Type</a> =
      if<span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.pending" title="=&gt; scala.collection.mutable.BitSet">pending</a> <a href="../../collection/BitSetLike.scala.html#scala.collection;BitSetLike.contains" title="(elem: Int)Boolean">contains</a> <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.i" title="Int">i</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.pending" title="=&gt; scala.collection.mutable.BitSet">pending</a>.<a href="../../collection/mutable/BitSet.scala.html#scala.collection.mutable;BitSet.clear" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
        throw <a href="#scala.reflect.internal;BaseTypeSeqs.CyclicInheritance" title="=&gt; Throwable">CyclicInheritance</a>
      <span class="delimiter">}</span> else
        <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)BaseTypeSeqs.this.Type">elems</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.i" title="Int">i</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case <a title="BaseTypeSeqs.this.RefinedType" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.rtp">rtp</a> @ RefinedType<span class="delimiter">(</span><a title="List[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.variants">variants</a>, <a title="BaseTypeSeqs.this.Scope" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.decls">decls</a><span class="delimiter">)</span> =&gt;
            <span class="comment">// can't assert decls.isEmpty; see t0764</span>
            <span class="comment">//if (!decls.isEmpty) abort(&quot;computing closure of &quot;+this+&quot;:&quot;+this.isInstanceOf[RefinedType]+&quot;/&quot;+closureCache(j))</span>
            <span class="comment">//Console.println(&quot;compute closure of &quot;+this+&quot; =&gt; glb(&quot;+variants+&quot;)&quot;)</span>
            <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.pending" title="=&gt; scala.collection.mutable.BitSet">pending</a> <a href="../../collection/mutable/BitSet.scala.html#scala.collection.mutable;BitSet.+=(0d9da624a1)" title="(elem: Int)BaseTypeSeq.this.pending.type">+=</a> <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.i" title="Int">i</a>
            try <span class="delimiter">{</span>
              <a href="Types.scala.html#scala.reflect.internal;Types.mergePrefixAndArgs" title="(tps: List[BaseTypeSeqs.this.Type], variance: scala.reflect.internal.Variance, depth: scala.reflect.internal.Depth)BaseTypeSeqs.this.Type">mergePrefixAndArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.variants" title="List[BaseTypeSeqs.this.Type]">variants</a>, <a href="Variance.scala.html#scala.reflect.internal.Variance" title="scala.reflect.internal.Variance.type">Variance</a>.<a href="Variance.scala.html#scala.reflect.internal.Variance.Contravariant" title="=&gt; scala.reflect.internal.Variance">Contravariant</a>, <a href="Types.scala.html#scala.reflect.internal;Types.lubDepth" title="(ts: List[BaseTypeSeqs.this.Type])scala.reflect.internal.Depth">lubDepth</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.variants" title="List[BaseTypeSeqs.this.Type]">variants</a><span class="delimiter">)</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
                case <a href="Types.scala.html#scala.reflect.internal;Types.NoType" title="BaseTypeSeqs.this.NoType.type">NoType</a> =&gt; <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeError" title="(msg: String)Nothing">typeError</a><span class="delimiter">(</span><span title="String(&quot;no common type instance of base types &quot;)" class="string">&quot;no common type instance of base types &quot;</span><span title="(x$1: Any)String">+</span><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.variants" title="List[BaseTypeSeqs.this.Type]">variants</a> <a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a> <span title="String(&quot;, and &quot;)" class="string">&quot;, and &quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span><span title="String(&quot; exists.&quot;)" class="string">&quot; exists.&quot;</span><span class="delimiter">)</span>
                case <a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.tp0">tp0</a>    =&gt;
                  <a href="../../collection/mutable/SetLike.scala.html#scala.collection.mutable;SetLike.update" title="(elem: Int, included: Boolean)Unit">pending</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.i" title="Int">i</a><span class="delimiter">)</span> = false
                  <a href="../../Array.scala.html#scala;Array.update" title="(i: Int, x: BaseTypeSeqs.this.Type)Unit">elems</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.i" title="Int">i</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.tp0" title="BaseTypeSeqs.this.Type">tp0</a>
                  <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.tp0" title="BaseTypeSeqs.this.Type">tp0</a>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            catch <span class="delimiter">{</span>
              case <a href="#scala.reflect.internal;BaseTypeSeqs.CyclicInheritance" title="=&gt; Throwable">CyclicInheritance</a> =&gt;
                <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeError" title="(msg: String)Nothing">typeError</a><span class="delimiter">(</span>
                  <span title="String(&quot;computing the common type instance of base types &quot;)" class="string">&quot;computing the common type instance of base types &quot;</span><span title="(x$1: Any)String">+</span><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.variants" title="List[BaseTypeSeqs.this.Type]">variants</a> <a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a> <span title="String(&quot;, and &quot;)" class="string">&quot;, and &quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span><span title="String(&quot; leads to a cycle.&quot;)" class="string">&quot; leads to a cycle.&quot;</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          case <a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.tp">tp</a> =&gt;
            <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply.tp" title="BaseTypeSeqs.this.Type">tp</a>
        <span class="delimiter">}</span>

    def <a title="(i: Int)BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.rawElem">rawElem</a><span class="delimiter">(</span><a title="Int" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.rawElem.i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span> = <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)BaseTypeSeqs.this.Type">elems</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.rawElem.i" title="Int">i</a><span class="delimiter">)</span>

    <span class="comment">/** The type symbol of the type at i'th position in this sequence;
     *  no evaluation needed.
     */</span>
    def <a title="(i: Int)BaseTypeSeqs.this.Symbol" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeSymbol">typeSymbol</a><span class="delimiter">(</span><a title="Int" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeSymbol.i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="BaseTypeSeqs.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)BaseTypeSeqs.this.Type">elems</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeSymbol.i" title="Int">i</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case RefinedType<span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeSymbol.v">v</a> :: <a title="List[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeSymbol.vs">vs</a>, _<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeSymbol.v" title="BaseTypeSeqs.this.Type">v</a>.<a href="Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; BaseTypeSeqs.this.Symbol">typeSymbol</a>
        case <a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeSymbol.tp">tp</a> =&gt; <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeSymbol.tp" title="BaseTypeSeqs.this.Type">tp</a>.<a href="Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; BaseTypeSeqs.this.Symbol">typeSymbol</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Return all evaluated types in this sequence as a list */</span>
    def <a title="=&gt; List[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.toList">toList</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[BaseTypeSeqs.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="../../Predef.scala.html#scala.Predef.refArrayOps" title="(xs: Array[BaseTypeSeqs.this.Type])scala.collection.mutable.ArrayOps[BaseTypeSeqs.this.Type]">elems</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[BaseTypeSeqs.this.Type]">toList</a>

    def <a title="(head: BaseTypeSeqs.this.Type, offset: Int)BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.copy">copy</a><span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.copy.head">head</a>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="BaseTypeSeqs.this.Type">Type</a>, <a title="Int" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.copy.offset">offset</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="BaseTypeSeqs.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      val <a title="Array[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.copy.arr">arr</a> = new <a href="../../Array.scala.html#scala;Array" title="Array[BaseTypeSeqs.this.Type]">Array</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.elems" title="=&gt; Array[BaseTypeSeqs.this.Type]">elems</a>.<a href="../../Array.scala.html#scala;Array.length" title="=&gt; Int">length</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+</a> <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.copy.offset" title="Int">offset</a><span class="delimiter">)</span>
      scala.compat.<a href="../../compat/Platform.scala.html#scala.compat.Platform" title="scala.compat.Platform.type">Platform</a>.<a href="../../compat/Platform.scala.html#scala.compat.Platform.arraycopy" title="(src: AnyRef, srcPos: Int, dest: AnyRef, destPos: Int, length: Int)Unit">arraycopy</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.elems" title="=&gt; Array[BaseTypeSeqs.this.Type]">elems</a>, <span title="Int(0)" class="int">0</span>, <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.copy.arr" title="Array[BaseTypeSeqs.this.Type]">arr</a>, <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.copy.offset" title="Int">offset</a>, <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.elems" title="=&gt; Array[BaseTypeSeqs.this.Type]">elems</a>.<a href="../../Array.scala.html#scala;Array.length" title="=&gt; Int">length</a><span class="delimiter">)</span>
      <a href="../../Array.scala.html#scala;Array.update" title="(i: Int, x: BaseTypeSeqs.this.Type)Unit">arr</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> = <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.copy.head" title="BaseTypeSeqs.this.Type">head</a>
      <a href="#scala.reflect.internal;BaseTypeSeqs.newBaseTypeSeq" title="(parents: List[BaseTypeSeqs.this.Type], elems: Array[BaseTypeSeqs.this.Type])BaseTypeSeqs.this.BaseTypeSeq">newBaseTypeSeq</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.parents" title="=&gt; List[BaseTypeSeqs.this.Type]">parents</a>, <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.copy.arr" title="Array[BaseTypeSeqs.this.Type]">arr</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Compute new base type sequence with `tp` prepended to this sequence */</span>
    def <a title="(tp: BaseTypeSeqs.this.Type)BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.prepend">prepend</a><span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.prepend.tp">tp</a>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="BaseTypeSeqs.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="BaseTypeSeqs.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.copy" title="(head: BaseTypeSeqs.this.Type, offset: Int)BaseTypeSeqs.this.BaseTypeSeq">copy</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.prepend.tp" title="BaseTypeSeqs.this.Type">tp</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

    <span class="comment">/** Compute new base type sequence with `tp` replacing the head of this sequence */</span>
    def <a title="(tp: BaseTypeSeqs.this.Type)BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.updateHead">updateHead</a><span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.updateHead.tp">tp</a>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="BaseTypeSeqs.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="BaseTypeSeqs.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.copy" title="(head: BaseTypeSeqs.this.Type, offset: Int)BaseTypeSeqs.this.BaseTypeSeq">copy</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.updateHead.tp" title="BaseTypeSeqs.this.Type">tp</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>

    <span class="comment">/** Compute new base type sequence where every element is mapped
     *  with function `f`. Lazy types are mapped but not evaluated */</span>
    def <a title="(f: BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type)BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map">map</a><span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map.f">f</a>: Type =&gt; Type<span class="delimiter">)</span>: <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="BaseTypeSeqs.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
	  <span class="comment">// inlined `elems map f` for performance</span>
      val <a title="Int" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map.len">len</a> = <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.length" title="=&gt; Int">length</a>
      val <a title="Array[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map.arr">arr</a> = new <a href="../../Array.scala.html#scala;Array" title="Array[BaseTypeSeqs.this.Type]">Array</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map.len" title="Int">len</a><span class="delimiter">)</span>
      var <a title="Int" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map.i">i</a> = <span title="Int(0)" class="int">0</span>
      while <span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map.i" title="Int">i</a> <a href="../../Int.scala.html#scala;Int.<(5f58a84eb3)" title="(x: Int)Boolean">&lt;</a> <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map.len" title="Int">len</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map.while$1" title="()Unit" class="delimiter">{</a>
        <a href="../../Array.scala.html#scala;Array.update" title="(i: Int, x: BaseTypeSeqs.this.Type)Unit">arr</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map.i" title="Int">i</a><span class="delimiter">)</span> = <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: BaseTypeSeqs.this.Type)BaseTypeSeqs.this.Type">f</a><span class="delimiter">(</span><a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)BaseTypeSeqs.this.Type">elems</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map.i" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map.i" title="Int">i</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal;BaseTypeSeqs.newBaseTypeSeq" title="(parents: List[BaseTypeSeqs.this.Type], elems: Array[BaseTypeSeqs.this.Type])BaseTypeSeqs.this.BaseTypeSeq">newBaseTypeSeq</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.parents" title="=&gt; List[BaseTypeSeqs.this.Type]">parents</a>, <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map.arr" title="Array[BaseTypeSeqs.this.Type]">arr</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    def <a title="(f: BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type)BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.lateMap">lateMap</a><span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.lateMap.f">f</a>: Type =&gt; Type<span class="delimiter">)</span>: <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="BaseTypeSeqs.this.BaseTypeSeq">BaseTypeSeq</a> = new <a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq" title="BaseTypeSeqs.this.MappedBaseTypeSeq">MappedBaseTypeSeq</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.lateMap.f" title="BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type">f</a><span class="delimiter">)</span>

    def <a title="(p: BaseTypeSeqs.this.Type =&gt; Boolean)Boolean" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.exists">exists</a><span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type =&gt; Boolean" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.exists.p">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="../../Predef.scala.html#scala.Predef.refArrayOps" title="(xs: Array[BaseTypeSeqs.this.Type])scala.collection.mutable.ArrayOps[BaseTypeSeqs.this.Type]">elems</a> <a href="../../collection/IndexedSeqOptimized.scala.html#scala.collection;IndexedSeqOptimized.exists" title="(p: BaseTypeSeqs.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.exists.p" title="BaseTypeSeqs.this.Type =&gt; Boolean">p</a>

    lazy val <a title="scala.reflect.internal.Depth" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.maxDepth">maxDepth</a> = <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.maxDepthOfElems" title="=&gt; scala.reflect.internal.Depth">maxDepthOfElems</a>

    protected def <a title="=&gt; scala.reflect.internal.Depth" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.maxDepthOfElems">maxDepthOfElems</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <span class="delimiter">{</span>
      var <a title="scala.reflect.internal.Depth" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.maxDepthOfElems.d">d</a> = <a href="Depth.scala.html#scala.reflect.internal.Depth" title="scala.reflect.internal.Depth.type">Depth</a>.<a href="Depth.scala.html#scala.reflect.internal.Depth.Zero" title="=&gt; scala.reflect.internal.Depth">Zero</a>
      <a href="../../Predef.scala.html#scala;LowPriorityImplicits.intWrapper" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">1</a> <a href="../../runtime/RichInt.scala.html#scala.runtime;RichInt.until(7457d0ec05)" title="(end: Int)scala.collection.immutable.Range">until</a> <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.length" title="=&gt; Int">length</a> <a href="../../collection/immutable/Range.scala.html#scala.collection.immutable;Range.foreach" title="(f: Int =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a title="Int" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.maxDepthOfElems.$anonfun.i">i</a> =&gt; <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.maxDepthOfElems.d" title="scala.reflect.internal.Depth">d</a> = <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.maxDepthOfElems.d" title="scala.reflect.internal.Depth">d</a> <a href="Depth.scala.html#scala.reflect.internal;Depth.max" title="(that: scala.reflect.internal.Depth)scala.reflect.internal.Depth">max</a> <a href="Types.scala.html#scala.reflect.internal;Types.typeDepth(6d5725dfee)" title="(tp: BaseTypeSeqs.this.Type)scala.reflect.internal.Depth">typeDepth</a><span class="delimiter">(</span><a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)BaseTypeSeqs.this.Type">elems</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.maxDepthOfElems.$anonfun.i" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.maxDepthOfElems.d" title="scala.reflect.internal.Depth">d</a>
    <span class="delimiter">}</span>

    override def <a title="()String" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.toString">toString</a> = <a href="../../Predef.scala.html#scala.Predef.refArrayOps" title="(xs: Array[BaseTypeSeqs.this.Type])scala.collection.mutable.ArrayOps[BaseTypeSeqs.this.Type]">elems</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;BTS(&quot;)" class="string">&quot;BTS(&quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>

    private def <a title="(msg: String)Nothing" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeError">typeError</a><span class="delimiter">(</span><a title="String" id="scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeError.msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Nothing">Nothing</span> =
      throw new <a href="Types.scala.html#scala.reflect.internal;Types;TypeError" title="BaseTypeSeqs.this.TypeError">TypeError</a><span class="delimiter">(</span>
        <span title="String(&quot;the type intersection &quot;)" class="string">&quot;the type intersection &quot;</span><span title="(x$1: Any)String">+</span><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.parents" title="=&gt; List[BaseTypeSeqs.this.Type]">parents</a> <a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a> <span title="String(&quot; with &quot;)" class="string">&quot; with &quot;</span><span class="delimiter">)</span><span title="(x$1: Any)String">+</span><span title="String(&quot; is malformed&quot;)" class="string">&quot; is malformed&quot;</span><span title="(x$1: Any)String">+</span>
        <span title="String(&quot;\n --- because ---\n&quot;)" class="string">&quot;\n --- because ---\n&quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeError.msg" title="String">msg</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A merker object for a base type sequence that's no yet computed.
   *  used to catch inheritance cycles
   */</span>
  val <a title="BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs.undetBaseTypeSeq">undetBaseTypeSeq</a>: <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="BaseTypeSeqs.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#scala.reflect.internal;BaseTypeSeqs.newBaseTypeSeq" title="(parents: List[BaseTypeSeqs.this.Type], elems: Array[BaseTypeSeqs.this.Type])BaseTypeSeqs.this.BaseTypeSeq">newBaseTypeSeq</a><span class="delimiter">(</span>List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>, <a href="../../Array.scala.html#scala.Array.apply(f425c59989)" title="(xs: BaseTypeSeqs.this.Type*)(implicit evidence$2: scala.reflect.ClassTag[BaseTypeSeqs.this.Type])Array[BaseTypeSeqs.this.Type]">Array</a><a href="Types.scala.html#scala.reflect.internal;Types.TypeTagg" title="=&gt; scala.reflect.ClassTag[BaseTypeSeqs.this.Type]" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Create a base type sequence consisting of a single type */</span>
  def <a title="(tp: BaseTypeSeqs.this.Type)BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs.baseTypeSingletonSeq">baseTypeSingletonSeq</a><span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs.baseTypeSingletonSeq.tp">tp</a>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="BaseTypeSeqs.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="BaseTypeSeqs.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#scala.reflect.internal;BaseTypeSeqs.newBaseTypeSeq" title="(parents: List[BaseTypeSeqs.this.Type], elems: Array[BaseTypeSeqs.this.Type])BaseTypeSeqs.this.BaseTypeSeq">newBaseTypeSeq</a><span class="delimiter">(</span>List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>, <a href="../../Array.scala.html#scala.Array.apply(f425c59989)" title="(xs: BaseTypeSeqs.this.Type*)(implicit evidence$2: scala.reflect.ClassTag[BaseTypeSeqs.this.Type])Array[BaseTypeSeqs.this.Type]">Array</a><a href="Types.scala.html#scala.reflect.internal;Types.TypeTagg" title="=&gt; scala.reflect.ClassTag[BaseTypeSeqs.this.Type]" class="delimiter">(</a><a href="#scala.reflect.internal;BaseTypeSeqs.baseTypeSingletonSeq.tp" title="BaseTypeSeqs.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Create the base type sequence of a compound type wuth given tp.parents */</span>
  def <a title="(tp: BaseTypeSeqs.this.Type)BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq">compoundBaseTypeSeq</a><span class="delimiter">(</span><span title="BaseTypeSeqs.this.Type">tp</span>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="BaseTypeSeqs.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="BaseTypeSeqs.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
    val <a title="BaseTypeSeqs.this.Symbol" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.tsym">tsym</a> = <span title="BaseTypeSeqs.this.Type">tp</span>.<a href="Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; BaseTypeSeqs.this.Symbol">typeSymbol</a>
    val <a title="List[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.parents">parents</a> = <span title="BaseTypeSeqs.this.Type">tp</span>.<a href="Types.scala.html#scala.reflect.internal;Types;Type.parents" title="=&gt; List[BaseTypeSeqs.this.Type]">parents</a>
<span class="comment">//    Console.println(&quot;computing baseTypeSeq of &quot; + tsym.tpe + &quot; &quot; + parents)//DEBUG</span>
    val <a title="scala.collection.mutable.ListBuffer[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.buf">buf</a> = new mutable.<a href="../../collection/mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer" title="scala.collection.mutable.ListBuffer[BaseTypeSeqs.this.Type]">ListBuffer</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>
    <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.buf" title="scala.collection.mutable.ListBuffer[BaseTypeSeqs.this.Type]">buf</a> <a href="../../collection/mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.+=(f93df146a4)" title="(x: BaseTypeSeqs.this.Type)buf.type">+=</a> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.tsym" title="BaseTypeSeqs.this.Symbol">tsym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe_*" title="=&gt; BaseTypeSeqs.this.Type">tpe_*</a>
    var <a title="Int" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.btsSize">btsSize</a> = <span title="Int(1)" class="int">1</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.parents" title="List[BaseTypeSeqs.this.Type]">parents</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="Int" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nparents">nparents</a> = <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.parents" title="List[BaseTypeSeqs.this.Type]">parents</a>.<a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.length" title="=&gt; Int">length</a>
      val <a title="Array[BaseTypeSeqs.this.BaseTypeSeq]" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.pbtss">pbtss</a> = new <a href="../../Array.scala.html#scala;Array" title="Array[BaseTypeSeqs.this.BaseTypeSeq]">Array</a><span class="delimiter">[</span>BaseTypeSeq<span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nparents" title="Int">nparents</a><span class="delimiter">)</span>
      val <a title="Array[Int]" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.index">index</a> = new <a href="../../Array.scala.html#scala;Array" title="Array[Int]">Array</a><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nparents" title="Int">nparents</a><span class="delimiter">)</span>
      var <a title="Int" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i">i</a> = <span title="Int(0)" class="int">0</span>
      for <span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.$anonfun.p">p</a> &lt;- <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: BaseTypeSeqs.this.Type =&gt; Unit)Unit">parents</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.$anonfun.parentBts">parentBts</a> = <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.$anonfun.p" title="BaseTypeSeqs.this.Type">p</a>.<a href="Types.scala.html#scala.reflect.internal;Types;Type.dealias" title="=&gt; BaseTypeSeqs.this.Type">dealias</a>.<a href="Types.scala.html#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; BaseTypeSeqs.this.BaseTypeSeq">baseTypeSeq</a> <span class="comment">// dealias need for SI-8046.</span>
        <a href="../../Array.scala.html#scala;Array.update" title="(i: Int, x: BaseTypeSeqs.this.BaseTypeSeq)Unit">pbtss</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i" title="Int">i</a><span class="delimiter">)</span> =
          if <span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.$anonfun.parentBts" title="BaseTypeSeqs.this.BaseTypeSeq">parentBts</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;BaseTypeSeqs.undetBaseTypeSeq" title="=&gt; BaseTypeSeqs.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyClass" title="=&gt; BaseTypeSeqs.this.ClassSymbol">AnyClass</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; BaseTypeSeqs.this.Type">info</a>.<a href="Types.scala.html#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; BaseTypeSeqs.this.BaseTypeSeq">baseTypeSeq</a>
          else <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.$anonfun.parentBts" title="BaseTypeSeqs.this.BaseTypeSeq">parentBts</a>
        <a href="../../Array.scala.html#scala;Array.update" title="(i: Int, x: Int)Unit">index</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i" title="Int">i</a><span class="delimiter">)</span> = <span title="Int(0)" class="int">0</span>
        <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i" title="Int">i</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span>
      def <a title="(i: Int)BaseTypeSeqs.this.Symbol" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextTypeSymbol">nextTypeSymbol</a><span class="delimiter">(</span><a title="Int" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextTypeSymbol.i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="BaseTypeSeqs.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
        val <a title="Int" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextTypeSymbol.j">j</a> = <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)Int">index</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextTypeSymbol.i" title="Int">i</a><span class="delimiter">)</span>
        val <a title="BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextTypeSymbol.pbts">pbts</a> = <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)BaseTypeSeqs.this.BaseTypeSeq">pbtss</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextTypeSymbol.i" title="Int">i</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextTypeSymbol.j" title="Int">j</a> <a href="../../Int.scala.html#scala;Int.<(5f58a84eb3)" title="(x: Int)Boolean">&lt;</a> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextTypeSymbol.pbts" title="BaseTypeSeqs.this.BaseTypeSeq">pbts</a>.<a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.length" title="=&gt; Int">length</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextTypeSymbol.pbts" title="BaseTypeSeqs.this.BaseTypeSeq">pbts</a>.<a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeSymbol" title="(i: Int)BaseTypeSeqs.this.Symbol">typeSymbol</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextTypeSymbol.j" title="Int">j</a><span class="delimiter">)</span> else <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyClass" title="=&gt; BaseTypeSeqs.this.ClassSymbol">AnyClass</a>
      <span class="delimiter">}</span>
      def <a title="(i: Int)BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextRawElem">nextRawElem</a><span class="delimiter">(</span><a title="Int" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextRawElem.i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="BaseTypeSeqs.this.Type">Type</a> = <span class="delimiter">{</span>
        val <a title="Int" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextRawElem.j">j</a> = <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)Int">index</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextRawElem.i" title="Int">i</a><span class="delimiter">)</span>
        val <a title="BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextRawElem.pbts">pbts</a> = <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)BaseTypeSeqs.this.BaseTypeSeq">pbtss</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextRawElem.i" title="Int">i</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextRawElem.j" title="Int">j</a> <a href="../../Int.scala.html#scala;Int.<(5f58a84eb3)" title="(x: Int)Boolean">&lt;</a> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextRawElem.pbts" title="BaseTypeSeqs.this.BaseTypeSeq">pbts</a>.<a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.length" title="=&gt; Int">length</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextRawElem.pbts" title="BaseTypeSeqs.this.BaseTypeSeq">pbts</a>.<a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.rawElem" title="(i: Int)BaseTypeSeqs.this.Type">rawElem</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextRawElem.j" title="Int">j</a><span class="delimiter">)</span> else <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyTpe" title="=&gt; BaseTypeSeqs.this.Type">AnyTpe</a>
      <span class="delimiter">}</span>
      var <a title="BaseTypeSeqs.this.Symbol" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.minSym">minSym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="BaseTypeSeqs.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; BaseTypeSeqs.this.NoSymbol">NoSymbol</a>
      while <span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.minSym" title="BaseTypeSeqs.this.Symbol">minSym</a> <span title="(x$1: Any)Boolean">!=</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyClass" title="=&gt; BaseTypeSeqs.this.ClassSymbol">AnyClass</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.while$4" title="()Unit" class="delimiter">{</a>
        <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.minSym" title="BaseTypeSeqs.this.Symbol">minSym</a> = <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextTypeSymbol" title="(i: Int)BaseTypeSeqs.this.Symbol">nextTypeSymbol</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i" title="Int">i</a> = <span title="Int(1)" class="int">1</span>
        while <span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i" title="Int">i</a> <a href="../../Int.scala.html#scala;Int.<(5f58a84eb3)" title="(x: Int)Boolean">&lt;</a> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nparents" title="Int">nparents</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.while$2" title="()Unit" class="delimiter">{</a>
          val <a title="BaseTypeSeqs.this.Symbol" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextSym">nextSym</a> = <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextTypeSymbol" title="(i: Int)BaseTypeSeqs.this.Symbol">nextTypeSymbol</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i" title="Int">i</a><span class="delimiter">)</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextSym" title="BaseTypeSeqs.this.Symbol">nextSym</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isLess" title="(that: BaseTypeSeqs.this.Symbol)Boolean">isLess</a> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.minSym" title="BaseTypeSeqs.this.Symbol">minSym</a><span class="delimiter">)</span>
            <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.minSym" title="BaseTypeSeqs.this.Symbol">minSym</a> = <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextSym" title="BaseTypeSeqs.this.Symbol">nextSym</a>
          <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i" title="Int">i</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
        <span class="delimiter">}</span>
        var <a title="List[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.minTypes">minTypes</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[BaseTypeSeqs.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
        def <a title="(tp: BaseTypeSeqs.this.Type)Boolean" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.alreadyInMinTypes">alreadyInMinTypes</a><span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.alreadyInMinTypes.tp">tp</a>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="BaseTypeSeqs.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
          @annotation.tailrec def <a title="(tps: List[BaseTypeSeqs.this.Type])Boolean" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.alreadyInMinTypes.loop">loop</a><span class="delimiter">(</span><a title="List[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.alreadyInMinTypes.loop.tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[BaseTypeSeqs.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.alreadyInMinTypes.loop.tps" title="List[BaseTypeSeqs.this.Type]">tps</a> match <span class="delimiter">{</span>
            case <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>     =&gt; false
            case <a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.alreadyInMinTypes.loop.x">x</a> :: <a title="List[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.alreadyInMinTypes.loop.xs">xs</a> =&gt; <span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.alreadyInMinTypes.tp" title="BaseTypeSeqs.this.Type">tp</a> <a href="Types.scala.html#scala.reflect.internal;Types;Type.=:=" title="(that: BaseTypeSeqs.this.Type)Boolean">=:=</a> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.alreadyInMinTypes.loop.x" title="BaseTypeSeqs.this.Type">x</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.alreadyInMinTypes.loop" title="(tps: List[BaseTypeSeqs.this.Type])Boolean">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.alreadyInMinTypes.loop.xs" title="List[BaseTypeSeqs.this.Type]">xs</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.alreadyInMinTypes.loop" title="(tps: List[BaseTypeSeqs.this.Type])Boolean">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.minTypes" title="List[BaseTypeSeqs.this.Type]">minTypes</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i" title="Int">i</a> = <span title="Int(0)" class="int">0</span>
        while <span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i" title="Int">i</a> <a href="../../Int.scala.html#scala;Int.<(5f58a84eb3)" title="(x: Int)Boolean">&lt;</a> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nparents" title="Int">nparents</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.while$3" title="()Unit" class="delimiter">{</a>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextTypeSymbol" title="(i: Int)BaseTypeSeqs.this.Symbol">nextTypeSymbol</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i" title="Int">i</a><span class="delimiter">)</span> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.minSym" title="BaseTypeSeqs.this.Symbol">minSym</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.nextRawElem" title="(i: Int)BaseTypeSeqs.this.Type">nextRawElem</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i" title="Int">i</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
              case RefinedType<span class="delimiter">(</span><a title="List[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.variants">variants</a>, <a title="BaseTypeSeqs.this.Scope" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.decls">decls</a><span class="delimiter">)</span> =&gt;
                for <span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.$anonfun.tp">tp</a> &lt;- <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: BaseTypeSeqs.this.Type =&gt; Unit)Unit">variants</a><span class="delimiter">)</span>
                  if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.alreadyInMinTypes" title="(tp: BaseTypeSeqs.this.Type)Boolean">alreadyInMinTypes</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.$anonfun.tp" title="BaseTypeSeqs.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.minTypes" title="List[BaseTypeSeqs.this.Type]">minTypes</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: BaseTypeSeqs.this.Type)List[BaseTypeSeqs.this.Type]">::=</a> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.$anonfun.tp" title="BaseTypeSeqs.this.Type">tp</a>
              case <span title="BaseTypeSeqs.this.Type">tp</span> =&gt;
                if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.alreadyInMinTypes" title="(tp: BaseTypeSeqs.this.Type)Boolean">alreadyInMinTypes</a><span class="delimiter">(</span><span title="BaseTypeSeqs.this.Type">tp</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.minTypes" title="List[BaseTypeSeqs.this.Type]">minTypes</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: BaseTypeSeqs.this.Type)List[BaseTypeSeqs.this.Type]">::=</a> <span title="BaseTypeSeqs.this.Type">tp</span>
            <span class="delimiter">}</span>
            <a href="../../Array.scala.html#scala;Array.update" title="(i: Int, x: Int)Unit">index</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i" title="Int">i</a><span class="delimiter">)</span> = <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)Int">index</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i" title="Int">i</a><span class="delimiter">)</span> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+</a> <span title="Int(1)" class="int">1</span>
          <span class="delimiter">}</span>
          <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.i" title="Int">i</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
        <span class="delimiter">}</span>
        <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.buf" title="scala.collection.mutable.ListBuffer[BaseTypeSeqs.this.Type]">buf</a> <a href="../../collection/mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.+=(f93df146a4)" title="(x: BaseTypeSeqs.this.Type)buf.type">+=</a> <a href="Types.scala.html#scala.reflect.internal;Types.intersectionType(8490c4bc7b)" title="(tps: List[BaseTypeSeqs.this.Type])BaseTypeSeqs.this.Type">intersectionType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.minTypes" title="List[BaseTypeSeqs.this.Type]">minTypes</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.btsSize" title="Int">btsSize</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    val <a title="Array[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.elems">elems</a> = new <a href="../../Array.scala.html#scala;Array" title="Array[BaseTypeSeqs.this.Type]">Array</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.btsSize" title="Int">btsSize</a><span class="delimiter">)</span>
    <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.buf" title="scala.collection.mutable.ListBuffer[BaseTypeSeqs.this.Type]">buf</a>.<a href="../../collection/generic/TraversableForwarder.scala.html#scala.collection.generic;TraversableForwarder.copyToArray(e81484900d)" title="(xs: Array[BaseTypeSeqs.this.Type], start: Int)Unit">copyToArray</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.elems" title="Array[BaseTypeSeqs.this.Type]">elems</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
<span class="comment">//    Console.println(&quot;computed baseTypeSeq of &quot; + tsym.tpe + &quot; &quot; + parents + &quot;: &quot;+elems.toString)//DEBUG</span>
    <a href="#scala.reflect.internal;BaseTypeSeqs.newBaseTypeSeq" title="(parents: List[BaseTypeSeqs.this.Type], elems: Array[BaseTypeSeqs.this.Type])BaseTypeSeqs.this.BaseTypeSeq">newBaseTypeSeq</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.parents" title="List[BaseTypeSeqs.this.Type]">parents</a>, <a href="#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq.elems" title="Array[BaseTypeSeqs.this.Type]">elems</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  class <a title="class MappedBaseTypeSeq extends BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq">MappedBaseTypeSeq</a><a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq" title="BaseTypeSeqs.this.MappedBaseTypeSeq" class="delimiter">(</a><a title="BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.orig">orig</a>: <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="BaseTypeSeqs.this.BaseTypeSeq">BaseTypeSeq</a>, <a title="BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.f">f</a>: Type =&gt; Type<span class="delimiter">)</span> extends <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="BaseTypeSeqs.this.BaseTypeSeq">BaseTypeSeq</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.orig" title="BaseTypeSeqs.this.BaseTypeSeq">orig</a>.<a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.parents" title="=&gt; List[BaseTypeSeqs.this.Type]">parents</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[BaseTypeSeqs.this.Type],BaseTypeSeqs.this.Type,List[BaseTypeSeqs.this.Type]])List[BaseTypeSeqs.this.Type]">map</a> <a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.f" title="BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type">f</a>, <a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.orig" title="BaseTypeSeqs.this.BaseTypeSeq">orig</a>.<a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.elems" title="=&gt; Array[BaseTypeSeqs.this.Type]">elems</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    override def <a title="(i: Int)BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.apply">apply</a><span class="delimiter">(</span><a title="Int" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.apply.i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span> = <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: BaseTypeSeqs.this.Type)BaseTypeSeqs.this.Type">f</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.orig" title="BaseTypeSeqs.this.BaseTypeSeq">orig</a>.<a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply" title="(i: Int)BaseTypeSeqs.this.Type">apply</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.apply.i" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
    override def <a title="(i: Int)BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.rawElem">rawElem</a><span class="delimiter">(</span><a title="Int" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.rawElem.i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span> = <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: BaseTypeSeqs.this.Type)BaseTypeSeqs.this.Type">f</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.orig" title="BaseTypeSeqs.this.BaseTypeSeq">orig</a>.<a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.rawElem" title="(i: Int)BaseTypeSeqs.this.Type">rawElem</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.rawElem.i" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
    override def <a title="(i: Int)BaseTypeSeqs.this.Symbol" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.typeSymbol">typeSymbol</a><span class="delimiter">(</span><a title="Int" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.typeSymbol.i">i</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.orig" title="BaseTypeSeqs.this.BaseTypeSeq">orig</a>.<a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeSymbol" title="(i: Int)BaseTypeSeqs.this.Symbol">typeSymbol</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.typeSymbol.i" title="Int">i</a><span class="delimiter">)</span>
    override def <a title="=&gt; List[BaseTypeSeqs.this.Type]" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.toList">toList</a> = <a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.orig" title="BaseTypeSeqs.this.BaseTypeSeq">orig</a>.<a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.toList" title="=&gt; List[BaseTypeSeqs.this.Type]">toList</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[BaseTypeSeqs.this.Type],BaseTypeSeqs.this.Type,List[BaseTypeSeqs.this.Type]])List[BaseTypeSeqs.this.Type]">map</a> <a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.f" title="BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type">f</a>
    override def <a title="(head: BaseTypeSeqs.this.Type, offset: Int)BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.copy">copy</a><span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.copy.head">head</a>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="BaseTypeSeqs.this.Type">Type</a>, <a title="Int" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.copy.offset">offset</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.orig" title="BaseTypeSeqs.this.BaseTypeSeq">orig</a> <a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map" title="(f: BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type)BaseTypeSeqs.this.BaseTypeSeq">map</a> <a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.f" title="BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type">f</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.copy" title="(head: BaseTypeSeqs.this.Type, offset: Int)BaseTypeSeqs.this.BaseTypeSeq">copy</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.copy.head" title="BaseTypeSeqs.this.Type">head</a>, <a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.copy.offset" title="Int">offset</a><span class="delimiter">)</span>
    override def <a title="(g: BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type)BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.map">map</a><span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.map.g">g</a>: Type =&gt; Type<span class="delimiter">)</span> = <a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.lateMap" title="(g: BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type)BaseTypeSeqs.this.BaseTypeSeq">lateMap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.map.g" title="BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type">g</a><span class="delimiter">)</span>
    override def <a title="(g: BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type)BaseTypeSeqs.this.BaseTypeSeq" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.lateMap">lateMap</a><span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.lateMap.g">g</a>: Type =&gt; Type<span class="delimiter">)</span> = <a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.orig" title="BaseTypeSeqs.this.BaseTypeSeq">orig</a>.<a href="#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.lateMap" title="(f: BaseTypeSeqs.this.Type =&gt; BaseTypeSeqs.this.Type)BaseTypeSeqs.this.BaseTypeSeq">lateMap</a><span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.lateMap.$anonfun.x">x</a> =&gt; <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: BaseTypeSeqs.this.Type)BaseTypeSeqs.this.Type">g</a><span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: BaseTypeSeqs.this.Type)BaseTypeSeqs.this.Type">f</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.lateMap.$anonfun.x" title="BaseTypeSeqs.this.Type">x</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    override def <a title="(p: BaseTypeSeqs.this.Type =&gt; Boolean)Boolean" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.exists">exists</a><span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type =&gt; Boolean" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.exists.p">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> = <a href="../../Predef.scala.html#scala.Predef.refArrayOps" title="(xs: Array[BaseTypeSeqs.this.Type])scala.collection.mutable.ArrayOps[BaseTypeSeqs.this.Type]">elems</a> <a href="../../collection/IndexedSeqOptimized.scala.html#scala.collection;IndexedSeqOptimized.exists" title="(p: BaseTypeSeqs.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.exists.$anonfun.x">x</a> =&gt; <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: BaseTypeSeqs.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: BaseTypeSeqs.this.Type)BaseTypeSeqs.this.Type">f</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.exists.$anonfun.x" title="BaseTypeSeqs.this.Type">x</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    override protected def <a title="=&gt; scala.reflect.internal.Depth" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.maxDepthOfElems">maxDepthOfElems</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <a href="../../Predef.scala.html#scala.Predef.refArrayOps" title="(xs: Array[BaseTypeSeqs.this.Type])scala.collection.mutable.ArrayOps[BaseTypeSeqs.this.Type]">elems</a>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.map" title="(f: BaseTypeSeqs.this.Type =&gt; scala.reflect.internal.Depth)(implicit bf: scala.collection.generic.CanBuildFrom[Array[BaseTypeSeqs.this.Type],scala.reflect.internal.Depth,Array[scala.reflect.internal.Depth]])Array[scala.reflect.internal.Depth]">map</a><a href="../../Predef.scala.html#scala.Predef.genericArrayOps" title="(xs: Array[scala.reflect.internal.Depth])scala.collection.mutable.ArrayOps[scala.reflect.internal.Depth]" class="delimiter">(</a><a title="BaseTypeSeqs.this.Type" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.maxDepthOfElems.$anonfun.x">x</a> =&gt; <a href="Types.scala.html#scala.reflect.internal;Types.typeDepth(6d5725dfee)" title="(tp: BaseTypeSeqs.this.Type)scala.reflect.internal.Depth">typeDepth</a><span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: BaseTypeSeqs.this.Type)BaseTypeSeqs.this.Type">f</a><span class="delimiter">(</span><a href="#scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.maxDepthOfElems.$anonfun.x" title="BaseTypeSeqs.this.Type">x</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.max" title="(implicit cmp: Ordering[scala.reflect.internal.Depth])scala.reflect.internal.Depth">max</a>
    override def <a title="()String" id="scala.reflect.internal;BaseTypeSeqs;MappedBaseTypeSeq.toString">toString</a> = <a href="../../Predef.scala.html#scala.Predef.refArrayOps" title="(xs: Array[BaseTypeSeqs.this.Type])scala.collection.mutable.ArrayOps[BaseTypeSeqs.this.Type]">elems</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;MBTS(&quot;)" class="string">&quot;MBTS(&quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  val <a title="Throwable" id="scala.reflect.internal;BaseTypeSeqs.CyclicInheritance">CyclicInheritance</a> = new <a href="../../package.scala.html#scala.package;Throwable" title="Throwable">Throwable</a>
<span class="delimiter">}</span>

object <a title="scala.reflect.internal.BaseTypeSeqsStats.type" id="scala.reflect.internal.BaseTypeSeqsStats">BaseTypeSeqsStats</a> <a href="#scala.reflect.internal.BaseTypeSeqsStats" title="scala.reflect.internal.BaseTypeSeqsStats.type" class="delimiter">{</a>
  val <a title="scala.reflect.internal.util.Statistics.Counter" id="scala.reflect.internal.BaseTypeSeqsStats.baseTypeSeqCount">baseTypeSeqCount</a> = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newCounter" title="(prefix: String, phases: String*)scala.reflect.internal.util.Statistics.Counter">newCounter</a><span class="delimiter">(</span><span title="String(&quot;#base type seqs&quot;)" class="string">&quot;#base type seqs&quot;</span><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.Counter" id="scala.reflect.internal.BaseTypeSeqsStats.baseTypeSeqLenTotal">baseTypeSeqLenTotal</a> = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newRelCounter" title="(prefix: String, ctr: scala.reflect.internal.util.Statistics.Counter)scala.reflect.internal.util.Statistics.Counter">newRelCounter</a><span class="delimiter">(</span><span title="String(&quot;avg base type seq length&quot;)" class="string">&quot;avg base type seq length&quot;</span>, <a href="#scala.reflect.internal.BaseTypeSeqsStats.baseTypeSeqCount" title="=&gt; scala.reflect.internal.util.Statistics.Counter">baseTypeSeqCount</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
