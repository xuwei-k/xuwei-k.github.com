<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/reflect/internal/tpe/TypeMaps.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scala
package reflect
package internal
package tpe

import scala.collection.<span class="delimiter">{</span> mutable, immutable <span class="delimiter">}</span>
import <a href="../Flags.scala.html#scala.reflect.internal.Flags" title="scala.reflect.internal.Flags.type">Flags</a>._
import scala.annotation.tailrec
import <a href="../Variance.scala.html#scala.reflect.internal.Variance" title="scala.reflect.internal.Variance.type">Variance</a>._

private<span class="delimiter">[</span>internal<span class="delimiter">]</span> trait <a title="trait TypeMaps extends AnyRef" id="scala.reflect.internal.tpe;TypeMaps">TypeMaps</a> <a href="../../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a>
  self: SymbolTable =&gt;
  import <a href="../Definitions.scala.html#scala.reflect.internal;Definitions.definitions" title="TypeMaps.this.definitions.type">definitions</a>._

  <span class="comment">/** Normalize any type aliases within this type (@see Type#normalize).
    *  Note that this depends very much on the call to &quot;normalize&quot;, not &quot;dealias&quot;,
    *  so it is no longer carries the too-stealthy name &quot;deAlias&quot;.
    */</span>
  object <a title="TypeMaps.this.normalizeAliases.type" id="scala.reflect.internal.tpe;TypeMaps.normalizeAliases">normalizeAliases</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.normalizeAliases.apply">apply</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp</span> match <span class="delimiter">{</span>
      case TypeRef<span class="delimiter">(</span>_, <span title="TypeMaps.this.Symbol">sym</span>, _<span class="delimiter">)</span> if <span title="TypeMaps.this.Symbol">sym</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAliasType" title="=&gt; Boolean">isAliasType</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span title="TypeMaps.this.Type">tp</span>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a> =&gt; <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.logResult" title="(msg: =&gt; String)(result: TypeMaps.this.Type)TypeMaps.this.Type">logResult</a><span class="delimiter">(</span><a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;Normalized type alias function &quot;)">Normalized type alias function $</span><span title="TypeMaps.this.Type">tp</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp</span>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.normalize" title="=&gt; TypeMaps.this.Type">normalize</a><span class="delimiter">)</span>
      case TypeRef<span class="delimiter">(</span>_, <span title="TypeMaps.this.Symbol">sym</span>, _<span class="delimiter">)</span> if <span title="TypeMaps.this.Symbol">sym</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAliasType" title="=&gt; Boolean">isAliasType</a>                      =&gt; <span title="TypeMaps.this.Type">tp</span>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.normalize" title="=&gt; TypeMaps.this.Type">normalize</a>
      case <span title="TypeMaps.this.Type">tp</span>                                                         =&gt; <span title="TypeMaps.this.Type">tp</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Remove any occurrence of type &lt;singleton&gt; from this type and its parents */</span>
  object <a title="TypeMaps.this.dropSingletonType.type" id="scala.reflect.internal.tpe;TypeMaps.dropSingletonType">dropSingletonType</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.dropSingletonType.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.dropSingletonType.apply.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps.dropSingletonType.apply.tp" title="TypeMaps.this.Type">tp</a> match <span class="delimiter">{</span>
        case TypeRef<span class="delimiter">(</span>_, <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.SingletonClass" title="=&gt; TypeMaps.this.ClassSymbol">SingletonClass</a>, _<span class="delimiter">)</span> =&gt;
          <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyTpe" title="=&gt; TypeMaps.this.Type">AnyTpe</a>
        case <span title="TypeMaps.this.RefinedType">tp1</span> @ RefinedType<span class="delimiter">(</span><a title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps.dropSingletonType.apply.parents">parents</a>, <a title="TypeMaps.this.Scope" id="scala.reflect.internal.tpe;TypeMaps.dropSingletonType.apply.decls">decls</a><span class="delimiter">)</span> =&gt;
          <a href="#scala.reflect.internal.tpe;TypeMaps.dropSingletonType.apply.parents" title="List[TypeMaps.this.Type]">parents</a> <a href="../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filter" title="(p: TypeMaps.this.Type =&gt; Boolean)List[TypeMaps.this.Type]">filter</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.dropSingletonType.apply.$anonfun.x$1" title="TypeMaps.this.Type">_</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; TypeMaps.this.Symbol">typeSymbol</a> <span title="(x$1: Any)Boolean">!=</span> <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.SingletonClass" title="=&gt; TypeMaps.this.ClassSymbol">SingletonClass</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
            case <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>                       =&gt; <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyTpe" title="=&gt; TypeMaps.this.Type">AnyTpe</a>
            case <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.dropSingletonType.apply.p">p</a> :: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> if <a href="#scala.reflect.internal.tpe;TypeMaps.dropSingletonType.apply.decls" title="TypeMaps.this.Scope">decls</a>.<a href="../Scopes.scala.html#scala.reflect.internal;Scopes;Scope.isEmpty" title="=&gt; Boolean">isEmpty</a> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.dropSingletonType.apply.p" title="TypeMaps.this.Type">p</a><span class="delimiter">)</span>
            case <a title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps.dropSingletonType.apply.ps">ps</a>                        =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="../Types.scala.html#scala.reflect.internal;Types.copyRefinedType" title="(original: TypeMaps.this.RefinedType, parents: List[TypeMaps.this.Type], decls: TypeMaps.this.Scope)TypeMaps.this.Type">copyRefinedType</a><span class="delimiter">(</span><span title="TypeMaps.this.RefinedType">tp1</span>, <a href="#scala.reflect.internal.tpe;TypeMaps.dropSingletonType.apply.ps" title="List[TypeMaps.this.Type]">ps</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.dropSingletonType.apply.decls" title="TypeMaps.this.Scope">decls</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        case <span title="TypeMaps.this.Type">tp1</span> =&gt;
          <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp1</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Type with all top-level occurrences of abstract types replaced by their bounds */</span>
  object <a title="TypeMaps.this.abstractTypesToBounds.type" id="scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds">abstractTypesToBounds</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <a href="#scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply.tp" title="TypeMaps.this.Type">tp</a> match <span class="delimiter">{</span>
      case TypeRef<span class="delimiter">(</span>_, <span title="TypeMaps.this.Symbol">sym</span>, _<span class="delimiter">)</span> if <span title="TypeMaps.this.Symbol">sym</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAliasType" title="=&gt; Boolean">isAliasType</a>    =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">apply</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply.tp" title="TypeMaps.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.dealias" title="=&gt; TypeMaps.this.Type">dealias</a><span class="delimiter">)</span>
      case TypeRef<span class="delimiter">(</span>_, <span title="TypeMaps.this.Symbol">sym</span>, _<span class="delimiter">)</span> if <span title="TypeMaps.this.Symbol">sym</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAbstractType" title="=&gt; Boolean">isAbstractType</a> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">apply</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply.tp" title="TypeMaps.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.bounds" title="=&gt; TypeMaps.this.TypeBounds">bounds</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; TypeMaps.this.Type">hi</a><span class="delimiter">)</span>
      case <a title="TypeMaps.this.RefinedType" id="scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply.rtp">rtp</a> @ RefinedType<span class="delimiter">(</span><a title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply.parents">parents</a>, <a title="TypeMaps.this.Scope" id="scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply.decls">decls</a><span class="delimiter">)</span>        =&gt; <a href="../Types.scala.html#scala.reflect.internal;Types.copyRefinedType" title="(original: TypeMaps.this.RefinedType, parents: List[TypeMaps.this.Type], decls: TypeMaps.this.Scope)TypeMaps.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply.rtp" title="TypeMaps.this.RefinedType">rtp</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply.parents" title="List[TypeMaps.this.Type]">parents</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="(f: TypeMaps.this.Type =&gt; TypeMaps.this.Type)List[TypeMaps.this.Type]">mapConserve</a> this, <a href="#scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply.decls" title="TypeMaps.this.Scope">decls</a><span class="delimiter">)</span>
      case AnnotatedType<span class="delimiter">(</span>_, _<span class="delimiter">)</span>                      =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
      case _                                        =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps.abstractTypesToBounds.apply.tp" title="TypeMaps.this.Type">tp</a>             <span class="comment">// no recursion - top level only</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">// Set to true for A* =&gt; Seq[A]</span>
  <span class="comment">//   (And it will only rewrite A* in method result types.)</span>
  <span class="comment">//   This is the pre-existing behavior.</span>
  <span class="comment">// Or false for Seq[A] =&gt; Seq[A]</span>
  <span class="comment">//   (It will rewrite A* everywhere but method parameters.)</span>
  <span class="comment">//   This is the specified behavior.</span>
  protected def <a title="=&gt; Boolean" id="scala.reflect.internal.tpe;TypeMaps.etaExpandKeepsStar">etaExpandKeepsStar</a> = false

  <span class="comment">/** Turn any T* types into Seq[T] except when
    *  in method parameter position.
    */</span>
  object <a title="TypeMaps.this.dropIllegalStarTypes.type" id="scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes">dropIllegalStarTypes</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <a href="#scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.tp" title="TypeMaps.this.Type">tp</a> match <span class="delimiter">{</span>
      case MethodType<span class="delimiter">(</span><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.params">params</a>, <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.restpe">restpe</a><span class="delimiter">)</span> =&gt;
        <span class="comment">// Not mapping over params</span>
        val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.restpe1">restpe1</a> = <a href="#scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">apply</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.restpe" title="TypeMaps.this.Type">restpe</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.restpe" title="TypeMaps.this.Type">restpe</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.restpe1" title="TypeMaps.this.Type">restpe1</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types;MethodType" title="(params: List[TypeMaps.this.Symbol], resultType: TypeMaps.this.Type)TypeMaps.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.params" title="List[TypeMaps.this.Symbol]">params</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.restpe1" title="TypeMaps.this.Type">restpe1</a><span class="delimiter">)</span>
      case TypeRef<span class="delimiter">(</span>_, <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.RepeatedParamClass" title="=&gt; TypeMaps.this.ClassSymbol">RepeatedParamClass</a>, <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.arg">arg</a> :: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> =&gt;
        <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.seqType" title="(arg: TypeMaps.this.Type)TypeMaps.this.Type">seqType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.arg" title="TypeMaps.this.Type">arg</a><span class="delimiter">)</span>
      case _ =&gt;
        if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.etaExpandKeepsStar" title="=&gt; Boolean">etaExpandKeepsStar</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.tp" title="TypeMaps.this.Type">tp</a> else <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.dropIllegalStarTypes.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  trait <a title="trait AnnotationFilter extends TypeMaps.this.TypeMap" id="scala.reflect.internal.tpe;TypeMaps;AnnotationFilter">AnnotationFilter</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    def <a title="(annot: TypeMaps.this.AnnotationInfo)Boolean" id="scala.reflect.internal.tpe;TypeMaps;AnnotationFilter.keepAnnotation">keepAnnotation</a><span class="delimiter">(</span><a title="TypeMaps.this.AnnotationInfo" id="scala.reflect.internal.tpe;TypeMaps;AnnotationFilter.keepAnnotation.annot">annot</a>: <a href="../AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;AnnotationInfo" title="TypeMaps.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    override def <a title="(annot: TypeMaps.this.AnnotationInfo)TypeMaps.this.AnnotationInfo" id="scala.reflect.internal.tpe;TypeMaps;AnnotationFilter.mapOver(f5ea0a0ec1)">mapOver</a><span class="delimiter">(</span><a title="TypeMaps.this.AnnotationInfo" id="scala.reflect.internal.tpe;TypeMaps;AnnotationFilter.mapOver(f5ea0a0ec1).annot">annot</a>: <a href="../AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;AnnotationInfo" title="TypeMaps.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AnnotationFilter.keepAnnotation" title="(annot: TypeMaps.this.AnnotationInfo)Boolean">keepAnnotation</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AnnotationFilter.mapOver(f5ea0a0ec1).annot" title="TypeMaps.this.AnnotationInfo">annot</a><span class="delimiter">)</span><span class="delimiter">)</span> super.<a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1)" title="(annot: TypeMaps.this.AnnotationInfo)TypeMaps.this.AnnotationInfo">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AnnotationFilter.mapOver(f5ea0a0ec1).annot" title="TypeMaps.this.AnnotationInfo">annot</a><span class="delimiter">)</span>
      else <a href="../AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos.UnmappableAnnotation" title="TypeMaps.this.UnmappableAnnotation.type">UnmappableAnnotation</a>
  <span class="delimiter">}</span>

  trait <a title="trait KeepOnlyTypeConstraints extends TypeMaps.this.TypeMap with TypeMaps.this.AnnotationFilter" id="scala.reflect.internal.tpe;TypeMaps;KeepOnlyTypeConstraints">KeepOnlyTypeConstraints</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;AnnotationFilter" title="TypeMaps.this.AnnotationFilter">AnnotationFilter</a> <span class="delimiter">{</span>
    <span class="comment">// filter keeps only type constraint annotations</span>
    def <a title="(annot: TypeMaps.this.AnnotationInfo)Boolean" id="scala.reflect.internal.tpe;TypeMaps;KeepOnlyTypeConstraints.keepAnnotation">keepAnnotation</a><span class="delimiter">(</span><a title="TypeMaps.this.AnnotationInfo" id="scala.reflect.internal.tpe;TypeMaps;KeepOnlyTypeConstraints.keepAnnotation.annot">annot</a>: <a href="../AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;AnnotationInfo" title="TypeMaps.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;KeepOnlyTypeConstraints.keepAnnotation.annot" title="TypeMaps.this.AnnotationInfo">annot</a> <a href="../AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;AnnotationInfo.matches" title="(clazz: TypeMaps.this.Symbol)Boolean">matches</a> <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.TypeConstraintClass" title="=&gt; TypeMaps.this.ClassSymbol">TypeConstraintClass</a>
  <span class="delimiter">}</span>

  <span class="comment">// todo. move these into scala.reflect.api</span>

  <span class="comment">/** A prototype for mapping a function over all possible types
    */</span>
  abstract class <a title="class TypeMap extends AnyRef with TypeMaps.this.Type =&gt; TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap">TypeMap</a><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap" class="delimiter">(</a><a title="Boolean" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.trackVariance">trackVariance</a>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a><span class="delimiter">)</span> extends <span class="delimiter">(</span>Type =&gt; Type<span class="delimiter">)</span> <span class="delimiter">{</span>
    def this<span class="delimiter">(</span><span class="delimiter">)</span> = this<span class="delimiter">(</span>trackVariance = false<span class="delimiter">)</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.apply.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>

    private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="scala.reflect.internal.Variance" id="scala.reflect.internal.tpe;TypeMaps;TypeMap._variance">_variance</a>: <a href="../Variance.scala.html#scala.reflect.internal;Variance" title="scala.reflect.internal.Variance">Variance</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.trackVariance" title="Boolean">trackVariance</a><span class="delimiter">)</span> <a href="../Variance.scala.html#scala.reflect.internal.Variance.Covariant" title="=&gt; scala.reflect.internal.Variance">Covariant</a> else <a href="../Variance.scala.html#scala.reflect.internal.Variance.Invariant" title="=&gt; scala.reflect.internal.Variance">Invariant</a>

    def <a title="(x: scala.reflect.internal.Variance)Unit" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.variance_=">variance_=</a><span class="delimiter">(</span><a title="scala.reflect.internal.Variance" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.variance_=.x">x</a>: <a href="../Variance.scala.html#scala.reflect.internal;Variance" title="scala.reflect.internal.Variance">Variance</a><span class="delimiter">)</span> = <span class="delimiter">{</span> <a href="../../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.trackVariance" title="Boolean">trackVariance</a>, this<span class="delimiter">)</span> ; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap._variance" title="scala.reflect.internal.Variance">_variance</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.variance_=.x" title="scala.reflect.internal.Variance">x</a> <span class="delimiter">}</span>
    def <a title="=&gt; scala.reflect.internal.Variance" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.variance">variance</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap._variance" title="scala.reflect.internal.Variance">_variance</a>

    <span class="comment">/** Map this function over given type */</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)">mapOver</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a> match <span class="delimiter">{</span>
      case <a title="TypeMaps.this.TypeRef" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tr">tr</a> @ TypeRef<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span>, <span title="TypeMaps.this.Symbol">sym</span>, <span title="List[TypeMaps.this.Type]">args</span><span class="delimiter">)</span> =&gt;
        val <span title="TypeMaps.this.Type">pre1</span> = this<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span><span class="delimiter">)</span>
        val <span title="List[TypeMaps.this.Type]">args1</span> = <span class="delimiter">(</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.trackVariance" title="Boolean">trackVariance</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span title="List[TypeMaps.this.Type]">args</span>.<a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.variance" title="=&gt; scala.reflect.internal.Variance">variance</a>.<a href="../Variance.scala.html#scala.reflect.internal;Variance.isInvariant" title="=&gt; Boolean">isInvariant</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span title="TypeMaps.this.Symbol">sym</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeParams" title="=&gt; List[TypeMaps.this.Symbol]">typeParams</a>.<a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span>
            <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverArgs" title="(args: List[TypeMaps.this.Type], tparams: List[TypeMaps.this.Symbol])List[TypeMaps.this.Type]">mapOverArgs</a><span class="delimiter">(</span><span title="List[TypeMaps.this.Type]">args</span>, <span title="TypeMaps.this.Symbol">sym</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeParams" title="=&gt; List[TypeMaps.this.Symbol]">typeParams</a><span class="delimiter">)</span>
          else
            <span title="List[TypeMaps.this.Type]">args</span> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="(f: TypeMaps.this.Type =&gt; TypeMaps.this.Type)List[TypeMaps.this.Type]">mapConserve</a> this
          <span class="delimiter">)</span>
        if <span class="delimiter">(</span><span class="delimiter">(</span><span title="TypeMaps.this.Type">pre1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Type">pre</span><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><span title="List[TypeMaps.this.Type]">args1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="List[TypeMaps.this.Type]">args</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types.copyTypeRef" title="(tp: TypeMaps.this.Type, pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol, args: List[TypeMaps.this.Type])TypeMaps.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>, <span title="TypeMaps.this.Type">pre1</span>, <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tr" title="TypeMaps.this.TypeRef">tr</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeRef.coevolveSym" title="(pre1: TypeMaps.this.Type)TypeMaps.this.Symbol">coevolveSym</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">pre1</span><span class="delimiter">)</span>, <span title="List[TypeMaps.this.Type]">args1</span><span class="delimiter">)</span>
      case ThisType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
      case SingleType<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span>, <span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span> =&gt;
        if <span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a> <span class="comment">// short path</span>
        else <span class="delimiter">{</span>
          val <span title="TypeMaps.this.Type">pre1</span> = this<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span><span class="delimiter">)</span>
          if <span class="delimiter">(</span><span title="TypeMaps.this.Type">pre1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Type">pre</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
          else <a href="../Types.scala.html#scala.reflect.internal;Types.singleType" title="(pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol)TypeMaps.this.Type">singleType</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">pre1</span>, <span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      case MethodType<span class="delimiter">(</span><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).params">params</a>, <span title="TypeMaps.this.Type">result</span><span class="delimiter">)</span> =&gt;
        val <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).params1">params1</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.flipped" title="(body: =&gt; List[TypeMaps.this.Symbol])List[TypeMaps.this.Symbol]">flipped</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(c59a65d52b)" title="(origSyms: List[TypeMaps.this.Symbol])List[TypeMaps.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).params" title="List[TypeMaps.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span>
        val <span title="TypeMaps.this.Type">result1</span> = this<span class="delimiter">(</span><span title="TypeMaps.this.Type">result</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).params1" title="List[TypeMaps.this.Symbol]">params1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).params" title="List[TypeMaps.this.Symbol]">params</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><span title="TypeMaps.this.Type">result1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Type">result</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types.copyMethodType" title="(tp: TypeMaps.this.Type, params: List[TypeMaps.this.Symbol], restpe: TypeMaps.this.Type)TypeMaps.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).params1" title="List[TypeMaps.this.Symbol]">params1</a>, <span title="TypeMaps.this.Type">result1</span>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.substSym" title="(from: List[TypeMaps.this.Symbol], to: List[TypeMaps.this.Symbol])TypeMaps.this.Type">substSym</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).params" title="List[TypeMaps.this.Symbol]">params</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).params1" title="List[TypeMaps.this.Symbol]">params1</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case PolyType<span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">tparams</span>, <span title="TypeMaps.this.Type">result</span><span class="delimiter">)</span> =&gt;
        val <span title="List[TypeMaps.this.Symbol]">tparams1</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.flipped" title="(body: =&gt; List[TypeMaps.this.Symbol])List[TypeMaps.this.Symbol]">flipped</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(c59a65d52b)" title="(origSyms: List[TypeMaps.this.Symbol])List[TypeMaps.this.Symbol]">mapOver</a><span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">tparams</span><span class="delimiter">)</span><span class="delimiter">)</span>
        val <span title="TypeMaps.this.Type">result1</span> = this<span class="delimiter">(</span><span title="TypeMaps.this.Type">result</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">tparams1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="List[TypeMaps.this.Symbol]">tparams</span><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><span title="TypeMaps.this.Type">result1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Type">result</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types;PolyType" title="(typeParams: List[TypeMaps.this.Symbol], resultType: TypeMaps.this.Type)TypeMaps.this.PolyType">PolyType</a><span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">tparams1</span>, <span title="TypeMaps.this.Type">result1</span>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.substSym" title="(from: List[TypeMaps.this.Symbol], to: List[TypeMaps.this.Symbol])TypeMaps.this.Type">substSym</a><span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">tparams</span>, <span title="List[TypeMaps.this.Symbol]">tparams1</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case NullaryMethodType<span class="delimiter">(</span><span title="TypeMaps.this.Type">result</span><span class="delimiter">)</span> =&gt;
        val <span title="TypeMaps.this.Type">result1</span> = this<span class="delimiter">(</span><span title="TypeMaps.this.Type">result</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><span title="TypeMaps.this.Type">result1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Type">result</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types;NullaryMethodType" title="(resultType: TypeMaps.this.Type)TypeMaps.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">result1</span><span class="delimiter">)</span>
      case ConstantType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
      case SuperType<span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).thistp">thistp</a>, <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).supertp">supertp</a><span class="delimiter">)</span> =&gt;
        val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).thistp1">thistp1</a> = this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).thistp" title="TypeMaps.this.Type">thistp</a><span class="delimiter">)</span>
        val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).supertp1">supertp1</a> = this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).supertp" title="TypeMaps.this.Type">supertp</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).thistp1" title="TypeMaps.this.Type">thistp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).thistp" title="TypeMaps.this.Type">thistp</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).supertp1" title="TypeMaps.this.Type">supertp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).supertp" title="TypeMaps.this.Type">supertp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types.SuperType.apply(6f0c418900)" title="(thistp: TypeMaps.this.Type, supertp: TypeMaps.this.Type)TypeMaps.this.Type">SuperType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).thistp1" title="TypeMaps.this.Type">thistp1</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).supertp1" title="TypeMaps.this.Type">supertp1</a><span class="delimiter">)</span>
      case TypeBounds<span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).lo">lo</a>, <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).hi">hi</a><span class="delimiter">)</span> =&gt;
        val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).lo1">lo1</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.flipped" title="(body: =&gt; TypeMaps.this.Type)TypeMaps.this.Type">flipped</a><span class="delimiter">(</span>this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).lo" title="TypeMaps.this.Type">lo</a><span class="delimiter">)</span><span class="delimiter">)</span>
        val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).hi1">hi1</a> = this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).hi" title="TypeMaps.this.Type">hi</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).lo1" title="TypeMaps.this.Type">lo1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).lo" title="TypeMaps.this.Type">lo</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).hi1" title="TypeMaps.this.Type">hi1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).hi" title="TypeMaps.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3)" title="(lo: TypeMaps.this.Type, hi: TypeMaps.this.Type)TypeMaps.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).lo1" title="TypeMaps.this.Type">lo1</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).hi1" title="TypeMaps.this.Type">hi1</a><span class="delimiter">)</span>
      case BoundedWildcardType<span class="delimiter">(</span><a title="TypeMaps.this.TypeBounds" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).bounds">bounds</a><span class="delimiter">)</span> =&gt;
        val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).bounds1">bounds1</a> = this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).bounds" title="TypeMaps.this.TypeBounds">bounds</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).bounds1" title="TypeMaps.this.Type">bounds1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).bounds" title="TypeMaps.this.TypeBounds">bounds</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types;BoundedWildcardType" title="(bounds: TypeMaps.this.TypeBounds)TypeMaps.this.BoundedWildcardType">BoundedWildcardType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).bounds1" title="TypeMaps.this.Type">bounds1</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="TypeMaps.this.TypeBounds" class="delimiter">[</span><a href="../Types.scala.html#scala.reflect.internal;Types;TypeBounds" title="TypeMaps.this.TypeBounds">TypeBounds</a><span class="delimiter">]</span><span class="delimiter">)</span>
      case <a title="TypeMaps.this.RefinedType" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).rtp">rtp</a> @ RefinedType<span class="delimiter">(</span><a title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).parents">parents</a>, <a title="TypeMaps.this.Scope" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).decls">decls</a><span class="delimiter">)</span> =&gt;
        val parents1 = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).parents" title="List[TypeMaps.this.Type]">parents</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).parents1">mapConserve</a> this
        val <a title="TypeMaps.this.Scope" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).decls1">decls1</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ba27114502)" title="(scope: TypeMaps.this.Scope)TypeMaps.this.Scope">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).decls" title="TypeMaps.this.Scope">decls</a><span class="delimiter">)</span>
        <a href="../Types.scala.html#scala.reflect.internal;Types.copyRefinedType" title="(original: TypeMaps.this.RefinedType, parents: List[TypeMaps.this.Type], decls: TypeMaps.this.Scope)TypeMaps.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).rtp" title="TypeMaps.this.RefinedType">rtp</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).parents1" title="List[TypeMaps.this.Type]">parents1</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).decls1" title="TypeMaps.this.Scope">decls1</a><span class="delimiter">)</span>
      case ExistentialType<span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">tparams</span>, <span title="TypeMaps.this.Type">result</span><span class="delimiter">)</span> =&gt;
        val <span title="List[TypeMaps.this.Symbol]">tparams1</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(c59a65d52b)" title="(origSyms: List[TypeMaps.this.Symbol])List[TypeMaps.this.Symbol]">mapOver</a><span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">tparams</span><span class="delimiter">)</span>
        val <span title="TypeMaps.this.Type">result1</span> = this<span class="delimiter">(</span><span title="TypeMaps.this.Type">result</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">tparams1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="List[TypeMaps.this.Symbol]">tparams</span><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><span title="TypeMaps.this.Type">result1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Type">result</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types.newExistentialType" title="(quantified: List[TypeMaps.this.Symbol], underlying: TypeMaps.this.Type)TypeMaps.this.Type">newExistentialType</a><span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">tparams1</span>, <span title="TypeMaps.this.Type">result1</span>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.substSym" title="(from: List[TypeMaps.this.Symbol], to: List[TypeMaps.this.Symbol])TypeMaps.this.Type">substSym</a><span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">tparams</span>, <span title="List[TypeMaps.this.Symbol]">tparams1</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case OverloadedType<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span>, <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).alts">alts</a><span class="delimiter">)</span> =&gt;
        val <span title="TypeMaps.this.Type">pre1</span> = if <span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="../Types.scala.html#scala.reflect.internal;Types;ClassInfoType" title="TypeMaps.this.ClassInfoType">ClassInfoType</a><span class="delimiter">]</span><span class="delimiter">)</span> <span title="TypeMaps.this.Type">pre</span> else this<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><span title="TypeMaps.this.Type">pre1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Type">pre</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types;OverloadedType" title="(pre: TypeMaps.this.Type, alternatives: List[TypeMaps.this.Symbol])TypeMaps.this.OverloadedType">OverloadedType</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">pre1</span>, <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).alts" title="List[TypeMaps.this.Symbol]">alts</a><span class="delimiter">)</span>
      case AntiPolyType<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span>, <span title="List[TypeMaps.this.Type]">args</span><span class="delimiter">)</span> =&gt;
        val <span title="TypeMaps.this.Type">pre1</span> = this<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span><span class="delimiter">)</span>
        val args1 = <span title="List[TypeMaps.this.Type]">args</span> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="List[TypeMaps.this.Type]">mapConserve</a> this
        if <span class="delimiter">(</span><span class="delimiter">(</span><span title="TypeMaps.this.Type">pre1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Type">pre</span><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><span title="List[TypeMaps.this.Type]">args1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="List[TypeMaps.this.Type]">args</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types;AntiPolyType" title="(pre: TypeMaps.this.Type, targs: List[TypeMaps.this.Type])TypeMaps.this.AntiPolyType">AntiPolyType</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">pre1</span>, <span title="List[TypeMaps.this.Type]">args1</span><span class="delimiter">)</span>
      case <a title="TypeMaps.this.TypeVar" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tv">tv</a>@TypeVar<span class="delimiter">(</span>_, <a title="TypeMaps.this.TypeConstraint" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).constr">constr</a><span class="delimiter">)</span> =&gt;
        if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).constr" title="TypeMaps.this.TypeConstraint">constr</a>.<a href="TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.instValid" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).constr" title="TypeMaps.this.TypeConstraint">constr</a>.<a href="TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst" title="=&gt; TypeMaps.this.Type">inst</a><span class="delimiter">)</span>
        else <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tv" title="TypeMaps.this.TypeVar">tv</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.applyArgs" title="(newArgs: List[TypeMaps.this.Type])TypeMaps.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverArgs" title="(args: List[TypeMaps.this.Type], tparams: List[TypeMaps.this.Symbol])List[TypeMaps.this.Type]">mapOverArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tv" title="TypeMaps.this.TypeVar">tv</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.typeArgs" title="=&gt; List[TypeMaps.this.Type]">typeArgs</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tv" title="TypeMaps.this.TypeVar">tv</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.params" title="=&gt; List[TypeMaps.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span>  <span class="comment">//@M !args.isEmpty implies !typeParams.isEmpty</span>
      case AnnotatedType<span class="delimiter">(</span><a title="List[TypeMaps.this.AnnotationInfo]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).annots">annots</a>, <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).atp">atp</a><span class="delimiter">)</span> =&gt;
        val <a title="List[TypeMaps.this.AnnotationInfo]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).annots1">annots1</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotations" title="(annots: List[TypeMaps.this.AnnotationInfo])List[TypeMaps.this.AnnotationInfo]">mapOverAnnotations</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).annots" title="List[TypeMaps.this.AnnotationInfo]">annots</a><span class="delimiter">)</span>
        val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).atp1">atp1</a> = this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).atp" title="TypeMaps.this.Type">atp</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).annots1" title="List[TypeMaps.this.AnnotationInfo]">annots1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).annots" title="List[TypeMaps.this.AnnotationInfo]">annots</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).atp1" title="TypeMaps.this.Type">atp1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).atp" title="TypeMaps.this.Type">atp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
        else if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).annots1" title="List[TypeMaps.this.AnnotationInfo]">annots1</a>.<a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).atp1" title="TypeMaps.this.Type">atp1</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types;AnnotatedType" title="(annotations: List[TypeMaps.this.AnnotationInfo], underlying: TypeMaps.this.Type)TypeMaps.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).annots1" title="List[TypeMaps.this.AnnotationInfo]">annots1</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).atp1" title="TypeMaps.this.Type">atp1</a><span class="delimiter">)</span>
      <span class="comment">/*
            case ErrorType =&gt; tp
            case WildcardType =&gt; tp
            case NoType =&gt; tp
            case NoPrefix =&gt; tp
            case ErasedSingleType(sym) =&gt; tp
      */</span>
      case _ =&gt;
        <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
      <span class="comment">// throw new Error(&quot;mapOver inapplicable for &quot; + tp);</span>
    <span class="delimiter">}</span>

    def <a title="[T](v: scala.reflect.internal.Variance)(body: =&gt; T)T" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.withVariance">withVariance</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.withVariance;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.internal.Variance" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.withVariance.v">v</a>: <a href="../Variance.scala.html#scala.reflect.internal;Variance" title="scala.reflect.internal.Variance">Variance</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; T" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.withVariance.body">body</a>: =&gt; T<span class="delimiter">)</span>: <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.withVariance;T" title="T">T</a> = <span class="delimiter">{</span>
      val <a title="scala.reflect.internal.Variance" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.withVariance.saved">saved</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.variance" title="=&gt; scala.reflect.internal.Variance">variance</a>
      <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.variance_=" title="(x: scala.reflect.internal.Variance)Unit">variance</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.withVariance.v" title="scala.reflect.internal.Variance">v</a>
      try <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.withVariance.body" title="=&gt; T">body</a> finally <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.variance_=" title="(x: scala.reflect.internal.Variance)Unit">variance</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.withVariance.saved" title="scala.reflect.internal.Variance">saved</a>
    <span class="delimiter">}</span>
    @inline final def <a title="[T](body: =&gt; T)T" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.flipped">flipped</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.flipped;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; T" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.flipped.body">body</a>: =&gt; T<span class="delimiter">)</span>: <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.flipped;T" title="T">T</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.trackVariance" title="Boolean">trackVariance</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.variance_=" title="(x: scala.reflect.internal.Variance)Unit">variance</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.variance" title="=&gt; scala.reflect.internal.Variance">variance</a>.<a href="../Variance.scala.html#scala.reflect.internal;Variance.flip" title="=&gt; scala.reflect.internal.Variance">flip</a>
      try <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.flipped.body" title="=&gt; T">body</a>
      finally if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.trackVariance" title="Boolean">trackVariance</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.variance_=" title="(x: scala.reflect.internal.Variance)Unit">variance</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.variance" title="=&gt; scala.reflect.internal.Variance">variance</a>.<a href="../Variance.scala.html#scala.reflect.internal;Variance.flip" title="=&gt; scala.reflect.internal.Variance">flip</a>
    <span class="delimiter">}</span>
    protected def <a title="(args: List[TypeMaps.this.Type], tparams: List[TypeMaps.this.Symbol])List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverArgs">mapOverArgs</a><span class="delimiter">(</span><a title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverArgs.args">args</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverArgs.tparams">tparams</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.trackVariance" title="Boolean">trackVariance</a><span class="delimiter">)</span>
        <a href="../util/Collections.scala.html#scala.reflect.internal.util;Collections.map2Conserve" title="(xs: List[TypeMaps.this.Type], ys: List[TypeMaps.this.Symbol])(f: (TypeMaps.this.Type, TypeMaps.this.Symbol) =&gt; TypeMaps.this.Type)List[TypeMaps.this.Type]">map2Conserve</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverArgs.args" title="List[TypeMaps.this.Type]">args</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverArgs.tparams" title="List[TypeMaps.this.Symbol]">tparams</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverArgs.$anonfun.arg">arg</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverArgs.$anonfun.tparam">tparam</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.withVariance" title="(v: scala.reflect.internal.Variance)(body: =&gt; TypeMaps.this.Type)TypeMaps.this.Type">withVariance</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.variance" title="=&gt; scala.reflect.internal.Variance">variance</a> <a href="../Variance.scala.html#scala.reflect.internal;Variance.*" title="(other: scala.reflect.internal.Variance)scala.reflect.internal.Variance">*</a> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverArgs.$anonfun.tparam" title="TypeMaps.this.Symbol">tparam</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.variance" title="=&gt; scala.reflect.internal.Variance">variance</a><span class="delimiter">)</span><span class="delimiter">(</span>this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverArgs.$anonfun.arg" title="TypeMaps.this.Type">arg</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      else
        <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverArgs.args" title="List[TypeMaps.this.Type]">args</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="(f: TypeMaps.this.Type =&gt; TypeMaps.this.Type)List[TypeMaps.this.Type]">mapConserve</a> this
      <span class="delimiter">)</span>
    <span class="comment">/** Applies this map to the symbol's info, setting variance = Invariant
      *  if necessary when the symbol is an alias.
      */</span>
    private def <a title="(sym: TypeMaps.this.Symbol)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.applyToSymbolInfo">applyToSymbolInfo</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.applyToSymbolInfo.sym">sym</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.trackVariance" title="Boolean">trackVariance</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.variance" title="=&gt; scala.reflect.internal.Variance">variance</a>.<a href="../Variance.scala.html#scala.reflect.internal;Variance.isInvariant" title="=&gt; Boolean">isInvariant</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.applyToSymbolInfo.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAliasType" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.withVariance" title="(v: scala.reflect.internal.Variance)(body: =&gt; TypeMaps.this.Type)TypeMaps.this.Type">withVariance</a><span class="delimiter">(</span><a href="../Variance.scala.html#scala.reflect.internal.Variance.Invariant" title="=&gt; scala.reflect.internal.Variance">Invariant</a><span class="delimiter">)</span><span class="delimiter">(</span>this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.applyToSymbolInfo.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; TypeMaps.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span>
      else
        this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.applyToSymbolInfo.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; TypeMaps.this.Type">info</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Called by mapOver to determine whether the original symbols can
      *  be returned, or whether they must be cloned.
      */</span>
    protected def <a title="(origSyms: List[TypeMaps.this.Symbol])Boolean" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.noChangeToSymbols">noChangeToSymbols</a><span class="delimiter">(</span><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.noChangeToSymbols.origSyms">origSyms</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      @tailrec def <a title="(syms: List[TypeMaps.this.Symbol])Boolean" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.noChangeToSymbols.loop">loop</a><span class="delimiter">(</span><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.noChangeToSymbols.loop.syms">syms</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.noChangeToSymbols.loop.syms" title="List[TypeMaps.this.Symbol]">syms</a> match <span class="delimiter">{</span>
        case <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>     =&gt; true
        case <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.noChangeToSymbols.loop.x">x</a> :: <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.noChangeToSymbols.loop.xs">xs</a> =&gt; <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.noChangeToSymbols.loop.x" title="TypeMaps.this.Symbol">x</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; TypeMaps.this.Type">info</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.applyToSymbolInfo" title="(sym: TypeMaps.this.Symbol)TypeMaps.this.Type">applyToSymbolInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.noChangeToSymbols.loop.x" title="TypeMaps.this.Symbol">x</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.noChangeToSymbols.loop" title="(syms: List[TypeMaps.this.Symbol])Boolean">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.noChangeToSymbols.loop.xs" title="List[TypeMaps.this.Symbol]">xs</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.noChangeToSymbols.loop" title="(syms: List[TypeMaps.this.Symbol])Boolean">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.noChangeToSymbols.origSyms" title="List[TypeMaps.this.Symbol]">origSyms</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Map this function over given scope */</span>
    def <a title="(scope: TypeMaps.this.Scope)TypeMaps.this.Scope" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ba27114502)">mapOver</a><span class="delimiter">(</span><a title="TypeMaps.this.Scope" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ba27114502).scope">scope</a>: <a href="../Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="TypeMaps.this.Scope">Scope</a><span class="delimiter">)</span>: <a href="../Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="TypeMaps.this.Scope">Scope</a> = <span class="delimiter">{</span>
      val <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ba27114502).elems">elems</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ba27114502).scope" title="TypeMaps.this.Scope">scope</a>.<a href="../Scopes.scala.html#scala.reflect.internal;Scopes;Scope.toList" title="=&gt; List[TypeMaps.this.Symbol]">toList</a>
      val <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ba27114502).elems1">elems1</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(c59a65d52b)" title="(origSyms: List[TypeMaps.this.Symbol])List[TypeMaps.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ba27114502).elems" title="List[TypeMaps.this.Symbol]">elems</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ba27114502).elems1" title="List[TypeMaps.this.Symbol]">elems1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ba27114502).elems" title="List[TypeMaps.this.Symbol]">elems</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ba27114502).scope" title="TypeMaps.this.Scope">scope</a>
      else <a href="../Scopes.scala.html#scala.reflect.internal;Scopes.newScopeWith" title="(elems: TypeMaps.this.Symbol*)TypeMaps.this.Scope">newScopeWith</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ba27114502).elems1" title="List[TypeMaps.this.Symbol]">elems1</a>: _*<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Map this function over given list of symbols */</span>
    def <a title="(origSyms: List[TypeMaps.this.Symbol])List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(c59a65d52b)">mapOver</a><span class="delimiter">(</span><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(c59a65d52b).origSyms">origSyms</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="comment">// fast path in case nothing changes due to map</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.noChangeToSymbols" title="(origSyms: List[TypeMaps.this.Symbol])Boolean">noChangeToSymbols</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(c59a65d52b).origSyms" title="List[TypeMaps.this.Symbol]">origSyms</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(c59a65d52b).origSyms" title="List[TypeMaps.this.Symbol]">origSyms</a>
      <span class="comment">// map is not the identity --&gt; do cloning properly</span>
      else <a href="../Symbols.scala.html#scala.reflect.internal;Symbols.cloneSymbolsAndModify" title="(syms: List[TypeMaps.this.Symbol], infoFn: TypeMaps.this.Type =&gt; TypeMaps.this.Type)List[TypeMaps.this.Symbol]">cloneSymbolsAndModify</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(c59a65d52b).origSyms" title="List[TypeMaps.this.Symbol]">origSyms</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a>.this<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    def <a title="(annot: TypeMaps.this.AnnotationInfo)TypeMaps.this.AnnotationInfo" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1)">mapOver</a><span class="delimiter">(</span><a title="TypeMaps.this.AnnotationInfo" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).annot">annot</a>: <a href="../AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;AnnotationInfo" title="TypeMaps.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">)</span>: <a href="../AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;AnnotationInfo" title="TypeMaps.this.AnnotationInfo">AnnotationInfo</a> = <span class="delimiter">{</span>
      val <a href="../AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos.AnnotationInfo.unapply" title="(info: TypeMaps.this.AnnotationInfo)Option[(TypeMaps.this.Type, List[TypeMaps.this.Tree], List[(TypeMaps.this.Name, TypeMaps.this.ClassfileAnnotArg)])]">AnnotationInfo</a><a href="../../../Tuple3.scala.html#scala;Tuple3" title="(TypeMaps.this.Type, List[TypeMaps.this.Tree], List[(TypeMaps.this.Name, TypeMaps.this.ClassfileAnnotArg)])" class="delimiter">(</a><a href="../../../Tuple3.scala.html#scala;Tuple3._1" title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).atp">atp</a>, <a href="../../../Tuple3.scala.html#scala;Tuple3._2" title="List[TypeMaps.this.Tree]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).args">args</a>, <a href="../../../Tuple3.scala.html#scala;Tuple3._3" title="List[(TypeMaps.this.Name, TypeMaps.this.ClassfileAnnotArg)]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).assocs">assocs</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).annot" title="TypeMaps.this.AnnotationInfo">annot</a>
      val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).atp1">atp1</a>  = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).atp" title="TypeMaps.this.Type">atp</a><span class="delimiter">)</span>
      val <a title="List[TypeMaps.this.Tree]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).args1">args1</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotArgs" title="(args: List[TypeMaps.this.Tree])List[TypeMaps.this.Tree]">mapOverAnnotArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).args" title="List[TypeMaps.this.Tree]">args</a><span class="delimiter">)</span>
      <span class="comment">// there is no need to rewrite assocs, as they are constants</span>

      if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).args" title="List[TypeMaps.this.Tree]">args</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).args1" title="List[TypeMaps.this.Tree]">args1</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).atp" title="TypeMaps.this.Type">atp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).atp1" title="TypeMaps.this.Type">atp1</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).annot" title="TypeMaps.this.AnnotationInfo">annot</a>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).args1" title="List[TypeMaps.this.Tree]">args1</a>.<a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).args" title="List[TypeMaps.this.Tree]">args</a>.<a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <a href="../AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos.UnmappableAnnotation" title="TypeMaps.this.UnmappableAnnotation.type">UnmappableAnnotation</a>  <span class="comment">// some annotation arg was unmappable</span>
      else <a href="../AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos.AnnotationInfo.apply" title="(atp: TypeMaps.this.Type, args: List[TypeMaps.this.Tree], assocs: List[(TypeMaps.this.Name, TypeMaps.this.ClassfileAnnotArg)])TypeMaps.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).atp1" title="TypeMaps.this.Type">atp1</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).args1" title="List[TypeMaps.this.Tree]">args1</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).assocs" title="List[(TypeMaps.this.Name, TypeMaps.this.ClassfileAnnotArg)]">assocs</a><span class="delimiter">)</span> <a href="../AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;AnnotationInfo.setPos" title="(pos: scala.reflect.internal.util.Position)TypeMaps.this.AnnotationInfo">setPos</a> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1).annot" title="TypeMaps.this.AnnotationInfo">annot</a>.<a href="../AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;AnnotationInfo.pos" title="=&gt; TypeMaps.this.Position">pos</a>
    <span class="delimiter">}</span>

    def <a title="(annots: List[TypeMaps.this.AnnotationInfo])List[TypeMaps.this.AnnotationInfo]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotations">mapOverAnnotations</a><span class="delimiter">(</span><a title="List[TypeMaps.this.AnnotationInfo]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotations.annots">annots</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span> = <span class="delimiter">{</span>
      val annots1 = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotations.annots" title="List[TypeMaps.this.AnnotationInfo]">annots</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="List[TypeMaps.this.AnnotationInfo]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotations.annots1">mapConserve</a> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(f5ea0a0ec1)" title="(annot: TypeMaps.this.AnnotationInfo)TypeMaps.this.AnnotationInfo">mapOver</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotations.annots1" title="List[TypeMaps.this.AnnotationInfo]">annots1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotations.annots" title="List[TypeMaps.this.AnnotationInfo]">annots</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotations.annots" title="List[TypeMaps.this.AnnotationInfo]">annots</a>
      else <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotations.annots1" title="List[TypeMaps.this.AnnotationInfo]">annots1</a> <a href="../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filterNot" title="(p: TypeMaps.this.AnnotationInfo =&gt; Boolean)List[TypeMaps.this.AnnotationInfo]">filterNot</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotations.$anonfun.x$3" title="TypeMaps.this.AnnotationInfo">_</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="../AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos.UnmappableAnnotation" title="TypeMaps.this.UnmappableAnnotation.type">UnmappableAnnotation</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Map over a set of annotation arguments.  If any
      *  of the arguments cannot be mapped, then return Nil.  */</span>
    def <a title="(args: List[TypeMaps.this.Tree])List[TypeMaps.this.Tree]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotArgs">mapOverAnnotArgs</a><span class="delimiter">(</span><a title="List[TypeMaps.this.Tree]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotArgs.args">args</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> = <span class="delimiter">{</span>
      val args1 = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotArgs.args" title="List[TypeMaps.this.Tree]">args</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="List[TypeMaps.this.Tree]" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotArgs.args1">mapConserve</a> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ac17634929)" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree">mapOver</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotArgs.args1" title="List[TypeMaps.this.Tree]">args1</a> <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: TypeMaps.this.Tree)Boolean">contains</a> <a href="../Types.scala.html#scala.reflect.internal;Types.UnmappableTree" title="TypeMaps.this.UnmappableTree.type">UnmappableTree</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
      else <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOverAnnotArgs.args1" title="List[TypeMaps.this.Tree]">args1</a>
    <span class="delimiter">}</span>

    def <a title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ac17634929)">mapOver</a><span class="delimiter">(</span><a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ac17634929).tree">tree</a>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a> =
      <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(6a76c588ac)" title="(tree: TypeMaps.this.Tree, giveup: () =&gt; Nothing)TypeMaps.this.Tree">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ac17634929).tree" title="TypeMaps.this.Tree">tree</a>, <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; return <a href="../Types.scala.html#scala.reflect.internal;Types.UnmappableTree" title="TypeMaps.this.UnmappableTree.type">UnmappableTree</a><span class="delimiter">)</span>

    <span class="comment">/** Map a tree that is part of an annotation argument.
      *  If the tree cannot be mapped, then invoke giveup().
      *  The default is to transform the tree with
      *  TypeMapTransformer.
      */</span>
    def <a title="(tree: TypeMaps.this.Tree, giveup: () =&gt; Nothing)TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(6a76c588ac)">mapOver</a><span class="delimiter">(</span><a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(6a76c588ac).tree">tree</a>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a>, <a title="() =&gt; Nothing" id="scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(6a76c588ac).giveup">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a> =
      <span class="delimiter">(</span>new <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer" title="TypeMap.this.TypeMapTransformer">TypeMapTransformer</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(6a76c588ac).tree" title="TypeMaps.this.Tree">tree</a><span class="delimiter">)</span>

    <span class="comment">/** This transformer leaves the tree alone except to remap
      *  its types. */</span>
    class <a title="class TypeMapTransformer extends TypeMaps.this.Transformer" id="scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer">TypeMapTransformer</a> extends <a href="../../api/Trees.scala.html#scala.reflect.api;Trees;Transformer" title="TypeMaps.this.Transformer">Transformer</a> <span class="delimiter">{</span>
      override def <a title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform">transform</a><span class="delimiter">(</span><a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform.tree">tree</a>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        val <a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform.tree1">tree1</a> = super.<a href="../../api/Trees.scala.html#scala.reflect.api;Trees;Transformer.transform" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform.tree" title="TypeMaps.this.Tree">tree</a><span class="delimiter">)</span>
        val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform.tpe1">tpe1</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.apply" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">TypeMap</a>.this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform.tree1" title="TypeMaps.this.Tree">tree1</a>.<a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; TypeMaps.this.Type">tpe</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform.tree" title="TypeMaps.this.Tree">tree</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform.tree1" title="TypeMaps.this.Tree">tree1</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform.tree" title="TypeMaps.this.Tree">tree</a>.<a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; TypeMaps.this.Type">tpe</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform.tpe1" title="TypeMaps.this.Type">tpe1</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform.tree" title="TypeMaps.this.Tree">tree</a>
        else
          <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform.tree1" title="TypeMaps.this.Tree">tree1</a>.<a href="../Trees.scala.html#scala.reflect.internal;Trees;TreeContextApiImpl.shallowDuplicate" title="=&gt; TypeMaps.this.Tree">shallowDuplicate</a>.<a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.setType" title="(tp: TypeMaps.this.Type)TypeMaps.this.Tree">setType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform.tpe1" title="TypeMaps.this.Type">tpe1</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  abstract class <a title="class TypeTraverser extends TypeMaps.this.TypeMap" id="scala.reflect.internal.tpe;TypeMaps;TypeTraverser">TypeTraverser</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)Unit" id="scala.reflect.internal.tpe;TypeMaps;TypeTraverser.traverse">traverse</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeTraverser.traverse.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeTraverser.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeTraverser.apply.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span class="delimiter">{</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeTraverser.traverse" title="(tp: TypeMaps.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeTraverser.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeTraverser.apply.tp" title="TypeMaps.this.Type">tp</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  abstract class <a title="class TypeTraverserWithResult[T] extends TypeMaps.this.TypeTraverser" id="scala.reflect.internal.tpe;TypeMaps;TypeTraverserWithResult">TypeTraverserWithResult</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal.tpe;TypeMaps;TypeTraverserWithResult;T">T</a><span class="delimiter">]</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeTraverser" title="TypeMaps.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    def <a title="=&gt; T" id="scala.reflect.internal.tpe;TypeMaps;TypeTraverserWithResult.result">result</a>: <a href="#scala.reflect.internal.tpe;TypeMaps;TypeTraverserWithResult;T" title="T">T</a>
    def <a title="()Unit" id="scala.reflect.internal.tpe;TypeMaps;TypeTraverserWithResult.clear">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>
  <span class="delimiter">}</span>

  abstract class <a title="class TypeCollector[T] extends TypeMaps.this.TypeTraverser" id="scala.reflect.internal.tpe;TypeMaps;TypeCollector">TypeCollector</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal.tpe;TypeMaps;TypeCollector;T">T</a><span class="delimiter">]</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector" title="TypeMaps.this.TypeCollector[T]" class="delimiter">(</a><a title="T" id="scala.reflect.internal.tpe;TypeMaps;TypeCollector.initial">initial</a>: <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector;T" title="T">T</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeTraverser" title="TypeMaps.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    var <a title="T" id="scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=">result</a>: <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector;T" title="T">T</a> = _
    def <a title="(tp: TypeMaps.this.Type)T" id="scala.reflect.internal.tpe;TypeMaps;TypeCollector.collect">collect</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;TypeCollector.collect.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=" title="(x$1: T)Unit">result</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.initial" title="T">initial</a>
      <a href="#scala.reflect.internal.tpe;TypeMaps;TypeTraverser.traverse" title="(tp: TypeMaps.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.collect.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=" title="=&gt; T">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The raw to existential map converts a ''raw type'' to an existential type.
    *  It is necessary because we might have read a raw type of a
    *  parameterized Java class from a class file. At the time we read the type
    *  the corresponding class file might still not be read, so we do not
    *  know what the type parameters of the type are. Therefore
    *  the conversion of raw types to existential types might not have taken place
    *  in ClassFileparser.sigToType (where it is usually done).
    */</span>
  def <a title="=&gt; TypeMaps.this.TypeMap" id="scala.reflect.internal.tpe;TypeMaps.rawToExistential">rawToExistential</a> = new <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="&lt;$anon: TypeMaps.this.Type =&gt; TypeMaps.this.Type&gt; extends TypeMaps.this.TypeMap" id="scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon">TypeMap</a> <span class="delimiter">{</span>
    private var <a title="scala.collection.immutable.Set[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.expanded_=">expanded</a> = immutable.<a href="../../../collection/generic/GenericCompanion.scala.html#scala.collection.generic;GenericCompanion.apply" title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</a><span title="(elems: TypeMaps.this.Symbol*)scala.collection.immutable.Set[TypeMaps.this.Symbol]" class="delimiter">[</span><a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.tp" title="TypeMaps.this.Type">tp</a> match <span class="delimiter">{</span>
      case TypeRef<span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.pre">pre</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.sym">sym</a>, <a href="../../../collection/generic/SeqFactory.scala.html#scala.collection.generic;SeqFactory.unapplySeq" title="(x: List[TypeMaps.this.Type])Some[List[TypeMaps.this.Type]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> if <a href="../Types.scala.html#scala.reflect.internal;Types.isRawIfWithoutArgs" title="(sym: TypeMaps.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.sym" title="TypeMaps.this.Symbol">sym</a><span class="delimiter">)</span> =&gt;
        if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.expanded_=" title="=&gt; scala.collection.immutable.Set[TypeMaps.this.Symbol]">expanded</a> <a href="../../../collection/SetLike.scala.html#scala.collection;SetLike.contains" title="(elem: TypeMaps.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.sym" title="TypeMaps.this.Symbol">sym</a><span class="delimiter">)</span> <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyRefTpe" title="=&gt; TypeMaps.this.Type">AnyRefTpe</a>
        else try <span class="delimiter">{</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.expanded_=" title="(x$1: scala.collection.immutable.Set[TypeMaps.this.Symbol])Unit">expanded</a> <a href="../../../collection/SetLike.scala.html#scala.collection;SetLike.+(daf7108c0f)" title="(elem: TypeMaps.this.Symbol)scala.collection.immutable.Set[TypeMaps.this.Symbol]">+=</a> <a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.sym" title="TypeMaps.this.Symbol">sym</a>
          val <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.eparams">eparams</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(c59a65d52b)" title="(origSyms: List[TypeMaps.this.Symbol])List[TypeMaps.this.Symbol]">mapOver</a><span class="delimiter">(</span><a href="../Types.scala.html#scala.reflect.internal;Types.typeParamsToExistentials(b9dabede8a)" title="(clazz: TypeMaps.this.Symbol)List[TypeMaps.this.Symbol]">typeParamsToExistentials</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.sym" title="TypeMaps.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="../Types.scala.html#scala.reflect.internal;Types.existentialAbstraction" title="(tparams: List[TypeMaps.this.Symbol], tpe0: TypeMaps.this.Type)TypeMaps.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.eparams" title="List[TypeMaps.this.Symbol]">eparams</a>, <a href="../Types.scala.html#scala.reflect.internal;Types.typeRef" title="(pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol, args: List[TypeMaps.this.Type])TypeMaps.this.Type">typeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">apply</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.pre" title="TypeMaps.this.Type">pre</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.sym" title="TypeMaps.this.Symbol">sym</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.eparams" title="List[TypeMaps.this.Symbol]">eparams</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: TypeMaps.this.Symbol =&gt; TypeMaps.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[TypeMaps.this.Symbol],TypeMaps.this.Type,List[TypeMaps.this.Type]])List[TypeMaps.this.Type]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.$anonfun.x$4" title="TypeMaps.this.Symbol">_</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; TypeMaps.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span> finally <span class="delimiter">{</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.expanded_=" title="(x$1: scala.collection.immutable.Set[TypeMaps.this.Symbol])Unit">expanded</a> <a href="../../../collection/SetLike.scala.html#scala.collection;SetLike.-(daf7108c0f)" title="(elem: TypeMaps.this.Symbol)scala.collection.immutable.Set[TypeMaps.this.Symbol]">-=</a> <a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.sym" title="TypeMaps.this.Symbol">sym</a>
        <span class="delimiter">}</span>
      case _ =&gt;
        <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.rawToExistential;$anon.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="comment">/***
    *@M: I think this is more desirable, but Martin prefers to leave raw-types as-is as much as possible
    object rawToExistentialInJava extends TypeMap {
      def apply(tp: Type): Type = tp match {
        // any symbol that occurs in a java sig, not just java symbols
        // see http://lampsvn.epfl.ch/trac/scala/ticket/2454#comment:14
        case TypeRef(pre, sym, List()) if !sym.typeParams.isEmpty =&gt;
          val eparams = typeParamsToExistentials(sym, sym.typeParams)
          existentialAbstraction(eparams, TypeRef(pre, sym, eparams map (_.tpe)))
        case _ =&gt;
          mapOver(tp)
      }
    }
    */</span>

  <span class="comment">/** Used by existentialAbstraction.
    */</span>
  class <a title="class ExistentialExtrapolation extends TypeMaps.this.TypeMap" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation">ExistentialExtrapolation</a><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation" title="TypeMaps.this.ExistentialExtrapolation" class="delimiter">(</a><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.tparams">tparams</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a><span class="delimiter">(</span>trackVariance = true<span class="delimiter">)</span> <span class="delimiter">{</span>
    private val <a title="scala.collection.mutable.HashMap[TypeMaps.this.Symbol,Int]" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.occurCount">occurCount</a> = mutable.<a href="../../../collection/generic/GenMapFactory.scala.html#scala.collection.generic;GenMapFactory.apply" title="[A, B](elems: (A, B)*)scala.collection.mutable.HashMap[A,B]">HashMap</a><span title="(elems: (TypeMaps.this.Symbol, Int)*)scala.collection.mutable.HashMap[TypeMaps.this.Symbol,Int]" class="delimiter">[</span><a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a>, <a href="../../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    private def <a title="(tp: TypeMaps.this.Type)Unit" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.countOccs">countOccs</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.countOccs.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.countOccs.tp" title="TypeMaps.this.Type">tp</a> <a href="../Types.scala.html#scala.reflect.internal;Types;Type.foreach" title="(f: TypeMaps.this.Type =&gt; Unit)Unit">foreach</a> <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.countOccs.$anonfun.x0$1" title="Unit" class="delimiter">{</a>
        case TypeRef<span class="delimiter">(</span>_, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.countOccs.$anonfun.sym">sym</a>, _<span class="delimiter">)</span> =&gt;
          if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.tparams" title="List[TypeMaps.this.Symbol]">tparams</a> <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: TypeMaps.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.countOccs.$anonfun.sym" title="TypeMaps.this.Symbol">sym</a><span class="delimiter">)</span>
            <a href="../../../collection/mutable/HashMap.scala.html#scala.collection.mutable;HashMap.update" title="(key: TypeMaps.this.Symbol, value: Int)Unit">occurCount</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.countOccs.$anonfun.sym" title="TypeMaps.this.Symbol">sym</a><span class="delimiter">)</span> <a href="../../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
        case _ =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    def <a title="(tpe: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.extrapolate">extrapolate</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.extrapolate.tpe">tpe</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.tparams" title="List[TypeMaps.this.Symbol]">tparams</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: TypeMaps.this.Symbol =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.extrapolate.$anonfun.t">t</a> =&gt; <a href="../../../collection/mutable/HashMap.scala.html#scala.collection.mutable;HashMap.update" title="(key: TypeMaps.this.Symbol, value: Int)Unit">occurCount</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.extrapolate.$anonfun.t" title="TypeMaps.this.Symbol">t</a><span class="delimiter">)</span> = <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.countOccs" title="(tp: TypeMaps.this.Type)Unit">countOccs</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.extrapolate.tpe" title="TypeMaps.this.Type">tpe</a><span class="delimiter">)</span>
      for <span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.extrapolate.$anonfun.tparam">tparam</a> &lt;- <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: TypeMaps.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.countOccs" title="(tp: TypeMaps.this.Type)Unit">countOccs</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.extrapolate.$anonfun.tparam" title="TypeMaps.this.Symbol">tparam</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; TypeMaps.this.Type">info</a><span class="delimiter">)</span>

      <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">apply</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.extrapolate.tpe" title="TypeMaps.this.Type">tpe</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** If these conditions all hold:
      *   1) we are in covariant (or contravariant) position
      *   2) this type occurs exactly once in the existential scope
      *   3) the widened upper (or lower) bound of this type contains no references to tparams
      *  Then we replace this lone occurrence of the type with the widened upper (or lower) bound.
      *  All other types pass through unchanged.
      */</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span class="delimiter">{</span>
      val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.tp1">tp1</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.variance" title="=&gt; scala.reflect.internal.Variance">variance</a>.<a href="../Variance.scala.html#scala.reflect.internal;Variance.isInvariant" title="=&gt; Boolean">isInvariant</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.tp1" title="TypeMaps.this.Type">tp1</a>
      else <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.tp1" title="TypeMaps.this.Type">tp1</a> match <span class="delimiter">{</span>
        case TypeRef<span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.pre">pre</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.sym">sym</a>, <a title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.args">args</a><span class="delimiter">)</span> if <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.tparams" title="List[TypeMaps.this.Symbol]">tparams</a> <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: TypeMaps.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.sym" title="TypeMaps.this.Symbol">sym</a> =&gt;
          val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.repl">repl</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.variance" title="=&gt; scala.reflect.internal.Variance">variance</a>.<a href="../Variance.scala.html#scala.reflect.internal;Variance.isPositive" title="=&gt; Boolean">isPositive</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps.dropSingletonType.apply" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">dropSingletonType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.tp1" title="TypeMaps.this.Type">tp1</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.bounds" title="=&gt; TypeMaps.this.TypeBounds">bounds</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; TypeMaps.this.Type">hi</a><span class="delimiter">)</span> else <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.tp1" title="TypeMaps.this.Type">tp1</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.bounds" title="=&gt; TypeMaps.this.TypeBounds">bounds</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeBounds.lo" title="=&gt; TypeMaps.this.Type">lo</a>
          val <a title="Int" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.count">count</a> = <a href="../../../collection/mutable/HashMap.scala.html#scala.collection.mutable;HashMap.apply" title="(key: TypeMaps.this.Symbol)Int">occurCount</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.sym" title="TypeMaps.this.Symbol">sym</a><span class="delimiter">)</span>
          val containsTypeParam = <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.tparams" title="List[TypeMaps.this.Symbol]">tparams</a> <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="Boolean" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.containsTypeParam">exists</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.repl" title="TypeMaps.this.Type">repl</a> <a href="../Types.scala.html#scala.reflect.internal;Types;Type.contains" title="(sym: TypeMaps.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.containsTypeParam.$anonfun.x$5" title="TypeMaps.this.Symbol">_</a><span class="delimiter">)</span>
          def <a title="=&gt; String" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.msg">msg</a> = <span class="delimiter">{</span>
            val <a title="String" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.msg.word">word</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.variance" title="=&gt; scala.reflect.internal.Variance">variance</a>.<a href="../Variance.scala.html#scala.reflect.internal;Variance.isPositive" title="=&gt; Boolean">isPositive</a><span class="delimiter">)</span> <span title="String(&quot;upper&quot;)" class="string">&quot;upper&quot;</span> else <span title="String(&quot;lower&quot;)" class="string">&quot;lower&quot;</span>
            <a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;Widened lone occurrence of &quot;)">Widened lone occurrence of $</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.tp1" title="TypeMaps.this.Type">tp1</a><span title="String(&quot; inside existential to &quot;)"> inside existential to $</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.msg.word" title="String">word</a><span title="String(&quot; bound&quot;)" class="string"> bound&quot;</span>
          <span class="delimiter">}</span>
          if <span class="delimiter">(</span><a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.repl" title="TypeMaps.this.Type">repl</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; TypeMaps.this.Symbol">typeSymbol</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isBottomClass" title="=&gt; Boolean">isBottomClass</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.count" title="Int">count</a> <a href="../../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.containsTypeParam" title="Boolean">containsTypeParam</a><span class="delimiter">)</span>
            <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglogResult" title="(msg: =&gt; String)(result: TypeMaps.this.Type)TypeMaps.this.Type">debuglogResult</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.msg" title="=&gt; String">msg</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.repl" title="TypeMaps.this.Type">repl</a><span class="delimiter">)</span>
          else
            <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.tp1" title="TypeMaps.this.Type">tp1</a>
        case _ =&gt;
          <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.apply.tp1" title="TypeMaps.this.Type">tp1</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    override def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92)">mapOver</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a> match <span class="delimiter">{</span>
      case SingleType<span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).pre">pre</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).sym">sym</a><span class="delimiter">)</span> =&gt;
        if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a> <span class="comment">// short path</span>
        else <span class="delimiter">{</span>
          val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).pre1">pre1</a> = this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).pre" title="TypeMaps.this.Type">pre</a><span class="delimiter">)</span>
          if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).pre1" title="TypeMaps.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).pre" title="TypeMaps.this.Type">pre</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).pre1" title="TypeMaps.this.Type">pre1</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.isStable" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a>
          else <a href="../Types.scala.html#scala.reflect.internal;Types.singleType" title="(pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol)TypeMaps.this.Type">singleType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).pre1" title="TypeMaps.this.Type">pre1</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).sym" title="TypeMaps.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      case _ =&gt; super.<a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ad9e013c92).tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// Do not discard the types of existential ident's. The</span>
    <span class="comment">// symbol of the Ident itself cannot be listed in the</span>
    <span class="comment">// existential's parameters, so the resulting existential</span>
    <span class="comment">// type would be ill-formed.</span>
    override def <a title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ac17634929)">mapOver</a><span class="delimiter">(</span><a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ac17634929).tree">tree</a>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ac17634929).tree" title="TypeMaps.this.Tree">tree</a> match <span class="delimiter">{</span>
      case Ident<span class="delimiter">(</span>_<span class="delimiter">)</span> if <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ac17634929).tree" title="TypeMaps.this.Tree">tree</a>.<a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; TypeMaps.this.Type">tpe</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.isStable" title="=&gt; Boolean">isStable</a> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ac17634929).tree" title="TypeMaps.this.Tree">tree</a>
      case _                             =&gt; super.<a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ac17634929)" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.mapOver(ac17634929).tree" title="TypeMaps.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Might the given symbol be important when calculating the prefix
    *  of a type? When tp.asSeenFrom(pre, clazz) is called on `tp`,
    *  the result will be `tp` unchanged if `pre` is trivial and `clazz`
    *  is a symbol such that isPossiblePrefix(clazz) == false.
    */</span>
  def <a title="(clazz: TypeMaps.this.Symbol)Boolean" id="scala.reflect.internal.tpe;TypeMaps.isPossiblePrefix">isPossiblePrefix</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps.isPossiblePrefix.clazz">clazz</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps.isPossiblePrefix.clazz" title="TypeMaps.this.Symbol">clazz</a>.<a href="../../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isClass" title="=&gt; Boolean">isClass</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps.isPossiblePrefix.clazz" title="TypeMaps.this.Symbol">clazz</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a>

  protected<span class="delimiter">[</span>internal<span class="delimiter">]</span> def <a title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)Boolean" id="scala.reflect.internal.tpe;TypeMaps.skipPrefixOf">skipPrefixOf</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.skipPrefixOf.pre">pre</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps.skipPrefixOf.clazz">clazz</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
    <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.skipPrefixOf.pre" title="TypeMaps.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeMaps.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.skipPrefixOf.pre" title="TypeMaps.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoPrefix" title="TypeMaps.this.NoPrefix.type">NoPrefix</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps.isPossiblePrefix" title="(clazz: TypeMaps.this.Symbol)Boolean">isPossiblePrefix</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.skipPrefixOf.clazz" title="TypeMaps.this.Symbol">clazz</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>

  def <a title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)TypeMaps.this.AsSeenFromMap" id="scala.reflect.internal.tpe;TypeMaps.newAsSeenFromMap">newAsSeenFromMap</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.newAsSeenFromMap.pre">pre</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps.newAsSeenFromMap.clazz">clazz</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap" title="TypeMaps.this.AsSeenFromMap">AsSeenFromMap</a> =
    new <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap" title="TypeMaps.this.AsSeenFromMap">AsSeenFromMap</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.newAsSeenFromMap.pre" title="TypeMaps.this.Type">pre</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.newAsSeenFromMap.clazz" title="TypeMaps.this.Symbol">clazz</a><span class="delimiter">)</span>

  <span class="comment">/** A map to compute the asSeenFrom method.
    */</span>
  class <a title="class AsSeenFromMap extends TypeMaps.this.TypeMap with TypeMaps.this.KeepOnlyTypeConstraints" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap">AsSeenFromMap</a><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap" title="TypeMaps.this.AsSeenFromMap" class="delimiter">(</a><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromPrefix">seenFromPrefix</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromClass">seenFromClass</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> with <a href="#scala.reflect.internal.tpe;TypeMaps;KeepOnlyTypeConstraints" title="TypeMaps.this.KeepOnlyTypeConstraints">KeepOnlyTypeConstraints</a> <span class="delimiter">{</span>
    <span class="comment">// Some example source constructs relevant in asSeenFrom:</span>
    <span class="comment">//</span>
    <span class="comment">// object CaptureThis {</span>
    <span class="comment">//   trait X[A] { def f: this.type = this }</span>
    <span class="comment">//   class Y[A] { def f: this.type = this }</span>
    <span class="comment">//   // Created new existential to represent This(CaptureThis.X) seen from CaptureThis.X[B]: type _1.type &lt;: CaptureThis.X[B] with Singleton</span>
    <span class="comment">//   def f1[B] = new X[B] { }</span>
    <span class="comment">//   // TODO - why is the behavior different when it's a class?</span>
    <span class="comment">//   def f2[B] = new Y[B] { }</span>
    <span class="comment">// }</span>
    <span class="comment">// class CaptureVal[T] {</span>
    <span class="comment">//   val f: java.util.List[_ &lt;: T] = null</span>
    <span class="comment">//   // Captured existential skolem for type _$1 seen from CaptureVal.this.f.type: type _$1</span>
    <span class="comment">//   def g = f get 0</span>
    <span class="comment">// }</span>
    <span class="comment">// class ClassParam[T] {</span>
    <span class="comment">//   // AsSeenFromMap(Inner.this.type, class Inner)/classParameterAsSeen(T)#loop(ClassParam.this.type, class ClassParam)</span>
    <span class="comment">//   class Inner(lhs: T) { def f = lhs }</span>
    <span class="comment">// }</span>
    def <a title="=&gt; List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.capturedParams">capturedParams</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>  = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap._capturedParams_=" title="=&gt; List[TypeMaps.this.Symbol]">_capturedParams</a>
    def <a title="=&gt; List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.capturedSkolems">capturedSkolems</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap._capturedSkolems_=" title="=&gt; List[TypeMaps.this.Symbol]">_capturedSkolems</a>

    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.apply">apply</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span title="TypeMaps.this.Type">tp</span> match <span class="delimiter">{</span>
      case <span title="TypeMaps.this.ThisType">tp</span> @ ThisType<span class="delimiter">(</span>_<span class="delimiter">)</span>                                            =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen" title="(tp: TypeMaps.this.ThisType)TypeMaps.this.Type">thisTypeAsSeen</a><span class="delimiter">(</span><span title="TypeMaps.this.ThisType">tp</span><span class="delimiter">)</span>
      case <span title="TypeMaps.this.SingleType">tp</span> @ SingleType<span class="delimiter">(</span>_, <span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span>                                     =&gt; if <span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <span title="TypeMaps.this.SingleType">tp</span> else <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen" title="(tp: TypeMaps.this.SingleType)TypeMaps.this.Type">singleTypeAsSeen</a><span class="delimiter">(</span><span title="TypeMaps.this.SingleType">tp</span><span class="delimiter">)</span>
      case <span title="TypeMaps.this.TypeRef">tp</span> @ TypeRef<span class="delimiter">(</span>_, <span title="TypeMaps.this.Symbol">sym</span>, _<span class="delimiter">)</span> if <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isTypeParamOfEnclosingClass" title="(sym: TypeMaps.this.Symbol)Boolean">isTypeParamOfEnclosingClass</a><span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen" title="(classParam: TypeMaps.this.Type)TypeMaps.this.Type">classParameterAsSeen</a><span class="delimiter">(</span><span title="TypeMaps.this.TypeRef">tp</span><span class="delimiter">)</span>
      case _                                                           =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    private var <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap._capturedSkolems_=">_capturedSkolems</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
    private var <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap._capturedParams_=">_capturedParams</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>  = <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
    private val <a title="Boolean" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isStablePrefix">isStablePrefix</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromPrefix" title="TypeMaps.this.Type">seenFromPrefix</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.isStable" title="=&gt; Boolean">isStable</a>

    <span class="comment">// isBaseClassOfEnclosingClassOrInfoIsNotYetComplete would be a more accurate</span>
    <span class="comment">// but less succinct name.</span>
    private def <a title="(base: TypeMaps.this.Symbol)Boolean" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isBaseClassOfEnclosingClass">isBaseClassOfEnclosingClass</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isBaseClassOfEnclosingClass.base">base</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      def <a title="(encl: TypeMaps.this.Symbol)Boolean" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isBaseClassOfEnclosingClass.loop">loop</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isBaseClassOfEnclosingClass.loop.encl">encl</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">(</span>
        <a href="#scala.reflect.internal.tpe;TypeMaps.isPossiblePrefix" title="(clazz: TypeMaps.this.Symbol)Boolean">isPossiblePrefix</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isBaseClassOfEnclosingClass.loop.encl" title="TypeMaps.this.Symbol">encl</a><span class="delimiter">)</span>
          <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isBaseClassOfEnclosingClass.loop.encl" title="TypeMaps.this.Symbol">encl</a> <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isSubClass" title="(that: TypeMaps.this.Symbol)Boolean">isSubClass</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isBaseClassOfEnclosingClass.base" title="TypeMaps.this.Symbol">base</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isBaseClassOfEnclosingClass.loop" title="(encl: TypeMaps.this.Symbol)Boolean">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isBaseClassOfEnclosingClass.loop.encl" title="TypeMaps.this.Symbol">encl</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.enclClass" title="=&gt; TypeMaps.this.Symbol">enclClass</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>
      <span class="comment">// The hasCompleteInfo guard is necessary to avoid cycles during the typing</span>
      <span class="comment">// of certain classes, notably ones defined inside package objects.</span>
      <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isBaseClassOfEnclosingClass.base" title="TypeMaps.this.Symbol">base</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.hasCompleteInfo" title="=&gt; Boolean">hasCompleteInfo</a> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isBaseClassOfEnclosingClass.loop" title="(encl: TypeMaps.this.Symbol)Boolean">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromClass" title="TypeMaps.this.Symbol">seenFromClass</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Is the symbol a class type parameter from one of the enclosing
      *  classes, or a base class of one of them?
      */</span>
    private def <a title="(sym: TypeMaps.this.Symbol)Boolean" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isTypeParamOfEnclosingClass">isTypeParamOfEnclosingClass</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isTypeParamOfEnclosingClass.sym">sym</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">(</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isTypeParamOfEnclosingClass.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isTypeParameter" title="=&gt; Boolean">isTypeParameter</a>
        <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isTypeParamOfEnclosingClass.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a>.<a href="../../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isClass" title="=&gt; Boolean">isClass</a>
        <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isBaseClassOfEnclosingClass" title="(base: TypeMaps.this.Symbol)Boolean">isBaseClassOfEnclosingClass</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isTypeParamOfEnclosingClass.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a><span class="delimiter">)</span>
      <span class="delimiter">)</span>

    <span class="comment">/** Creates an existential representing a type parameter which appears
      *  in the prefix of a ThisType.
      */</span>
    protected def <a title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis">captureThis</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis.pre">pre</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis.clazz">clazz</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.capturedParams" title="=&gt; List[TypeMaps.this.Symbol]">capturedParams</a> <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.find" title="(p: TypeMaps.this.Symbol =&gt; Boolean)Option[TypeMaps.this.Symbol]">find</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis.$anonfun.x$6" title="TypeMaps.this.Symbol">_</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis.clazz" title="TypeMaps.this.Symbol">clazz</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case Some<span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis.p">p</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis.p" title="TypeMaps.this.Symbol">p</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; TypeMaps.this.Type">tpe</a>
        case _       =&gt;
          val qvar = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis.clazz" title="TypeMaps.this.Symbol">clazz</a> <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.freshExistential" title="(suffix: String)TypeMaps.this.TypeSymbol">freshExistential</a> <a href="../StdNames.scala.html#scala.reflect.internal;StdNames.nme" title="TypeMaps.this.nme.type">nme</a>.<a href="../StdNames.scala.html#scala.reflect.internal;StdNames;CommonNames.SINGLETON_SUFFIX" title="=&gt; String">SINGLETON_SUFFIX</a> <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="TypeMaps.this.TypeSymbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis.qvar">setInfo</a> <a href="../Types.scala.html#scala.reflect.internal;Types.singletonBounds" title="(hi: TypeMaps.this.Type)TypeMaps.this.TypeBounds">singletonBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis.pre" title="TypeMaps.this.Type">pre</a><span class="delimiter">)</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap._capturedParams_=" title="(x$1: List[TypeMaps.this.Symbol])Unit">_capturedParams</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: TypeMaps.this.Symbol)List[TypeMaps.this.Symbol]">::=</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis.qvar" title="TypeMaps.this.TypeSymbol">qvar</a>
          <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;Captured This(&quot;)">Captured This($</span><span class="delimiter">{</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis.clazz" title="TypeMaps.this.Symbol">clazz</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.fullNameString" title="=&gt; String">fullNameString</a><span class="delimiter">}</span><span title="String(&quot;) seen from &quot;)">) seen from $</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromPrefix" title="TypeMaps.this.Type">seenFromPrefix</a><span title="String(&quot;: &quot;)">: $</span><span class="delimiter">{</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis.qvar" title="TypeMaps.this.TypeSymbol">qvar</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.defString" title="=&gt; String">defString</a><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis.qvar" title="TypeMaps.this.TypeSymbol">qvar</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; TypeMaps.this.Type">tpe</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    protected def <a title="(skolems: List[TypeMaps.this.Symbol])Unit" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureSkolems">captureSkolems</a><span class="delimiter">(</span><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureSkolems.skolems">skolems</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      for <span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureSkolems.$anonfun.p">p</a> &lt;- <a href="../../../collection/generic/FilterMonadic.scala.html#scala.collection.generic;FilterMonadic.foreach" title="(f: TypeMaps.this.Symbol =&gt; Unit)Unit">skolems</a>; if <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.capturedSkolems" title="=&gt; List[TypeMaps.this.Symbol]">capturedSkolems</a> <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: TypeMaps.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureSkolems.$anonfun.p" title="TypeMaps.this.Symbol">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;Captured &quot;)">Captured $</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureSkolems.$anonfun.p" title="TypeMaps.this.Symbol">p</a><span title="String(&quot; seen from &quot;)"> seen from $</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromPrefix" title="TypeMaps.this.Type">seenFromPrefix</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
        <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap._capturedSkolems_=" title="(x$1: List[TypeMaps.this.Symbol])Unit">_capturedSkolems</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: TypeMaps.this.Symbol)List[TypeMaps.this.Symbol]">::=</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureSkolems.$anonfun.p" title="TypeMaps.this.Symbol">p</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Find the type argument in an applied type which corresponds to a type parameter.
      *  The arguments are required to be related as follows, through intermediary `clazz`.
      *  An exception will be thrown if this is violated.
      *
      *  @param   lhs    its symbol is a type parameter of `clazz`
      *  @param   rhs    a type application constructed from `clazz`
      */</span>
    private def <a title="(lhs: TypeMaps.this.Type, rhs: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument">correspondingTypeArgument</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.lhs">lhs</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>, <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.rhs">rhs</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span class="delimiter">{</span>
      val TypeRef<a href="../../../Tuple2.scala.html#scala;Tuple2" title="(TypeMaps.this.Symbol, List[TypeMaps.this.Type])" class="delimiter">(</a>_, <a href="../../../Tuple2.scala.html#scala;Tuple2._1" title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.lhsSym">lhsSym</a>, <a href="../../../Tuple2.scala.html#scala;Tuple2._2" title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.lhsArgs">lhsArgs</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.lhs" title="TypeMaps.this.Type">lhs</a>
      val TypeRef<a href="../../../Tuple2.scala.html#scala;Tuple2" title="(TypeMaps.this.Symbol, List[TypeMaps.this.Type])" class="delimiter">(</a>_, <a href="../../../Tuple2.scala.html#scala;Tuple2._1" title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.rhsSym">rhsSym</a>, <a href="../../../Tuple2.scala.html#scala;Tuple2._2" title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.rhsArgs">rhsArgs</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.rhs" title="TypeMaps.this.Type">rhs</a>
      <a href="../../../Predef.scala.html#scala.Predef.require(a2f0e4a061)" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.lhsSym" title="TypeMaps.this.Symbol">lhsSym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.rhsSym" title="TypeMaps.this.Symbol">rhsSym</a>, <a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.lhsSym" title="TypeMaps.this.Symbol">lhsSym</a><span title="String(&quot; is not a type parameter of &quot;)"> is not a type parameter of $</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.rhsSym" title="TypeMaps.this.Symbol">rhsSym</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>

      <span class="comment">// Find the type parameter position; we'll use the corresponding argument.</span>
      <span class="comment">// Why are we checking by name rather than by equality? Because for</span>
      <span class="comment">// reasons which aren't yet fully clear, we can arrive here holding a type</span>
      <span class="comment">// parameter whose owner is rhsSym, and which shares the name of an actual</span>
      <span class="comment">// type parameter of rhsSym, but which is not among the type parameters of</span>
      <span class="comment">// rhsSym. One can see examples of it at SI-4365.</span>
      val argIndex = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.rhsSym" title="TypeMaps.this.Symbol">rhsSym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeParams" title="=&gt; List[TypeMaps.this.Symbol]">typeParams</a> <a href="../../../collection/GenSeqLike.scala.html#scala.collection;GenSeqLike.indexWhere(654a5f82d5)" title="Int" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.argIndex">indexWhere</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.lhsSym" title="TypeMaps.this.Symbol">lhsSym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; lhsSym.NameType">name</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.argIndex.$anonfun.x$9" title="TypeMaps.this.Symbol">_</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; x$9.NameType">name</a><span class="delimiter">)</span>
      <span class="comment">// don't be too zealous with the exceptions, see #2641</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.argIndex" title="Int">argIndex</a> <a href="../../../Int.scala.html#scala;Int.<(5f58a84eb3)" title="(x: Int)Boolean">&lt;</a> <span title="Int(0)" class="int">0</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.rhs" title="TypeMaps.this.Type">rhs</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.parents" title="=&gt; List[TypeMaps.this.Type]">parents</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: TypeMaps.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="../Types.scala.html#scala.reflect.internal;Types.typeIsErroneous" title="=&gt; TypeMaps.this.Type =&gt; Boolean">typeIsErroneous</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="../Types.scala.html#scala.reflect.internal;Types.ErrorType" title="TypeMaps.this.ErrorType.type">ErrorType</a>
      else <span class="delimiter">{</span>
        <span class="comment">// It's easy to get here when working on hardcore type machinery (not to</span>
        <span class="comment">// mention when not doing so, see above) so let's provide a standout error.</span>
        def <a title="(s: TypeMaps.this.Symbol)String" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.own_s">own_s</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.own_s.s">s</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.own_s.s" title="TypeMaps.this.Symbol">s</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.nameString" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; in &quot;)" class="string">&quot; in &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.own_s.s" title="TypeMaps.this.Symbol">s</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.nameString" title="=&gt; String">nameString</a>
        def <a title="=&gt; String" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.explain">explain</a> =
          <a href="../util/StripMarginInterpolator.scala.html#scala.reflect.internal.util;StripMarginInterpolator.sm" title="(args: Any*)String">sm</a>&quot;&quot;&quot;<span title="String(&quot;|   sought  &quot;)">|   sought  $</span><span class="delimiter">{</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.own_s" title="(s: TypeMaps.this.Symbol)String">own_s</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.lhsSym" title="TypeMaps.this.Symbol">lhsSym</a><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;\n               | classSym  &quot;)">
               | classSym  $</span><span class="delimiter">{</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.own_s" title="(s: TypeMaps.this.Symbol)String">own_s</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.rhsSym" title="TypeMaps.this.Symbol">rhsSym</a><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;\n               |  tparams  &quot;)">
               |  tparams  $</span><span class="delimiter">{</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.rhsSym" title="TypeMaps.this.Symbol">rhsSym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeParams" title="=&gt; List[TypeMaps.this.Symbol]">typeParams</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: TypeMaps.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[TypeMaps.this.Symbol],String,List[String]])List[String]">map</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.own_s" title="(s: TypeMaps.this.Symbol)String">own_s</a> <a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">}</span><span title="String(&quot;\n               |&quot;)" class="string">
               |&quot;&quot;&quot;</span>

        if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.argIndex" title="Int">argIndex</a> <a href="../../../Int.scala.html#scala;Int.<(5f58a84eb3)" title="(x: Int)Boolean">&lt;</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
          <a href="../Reporting.scala.html#scala.reflect.internal;Reporting.abort" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;Something is wrong: cannot find &quot;)">Something is wrong: cannot find $</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.lhs" title="TypeMaps.this.Type">lhs</a><span title="String(&quot; in applied type &quot;)"> in applied type $</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.rhs" title="TypeMaps.this.Type">rhs</a><span title="String(&quot;\\n&quot;)" class="string">\n&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.explain" title="=&gt; String">explain</a><span class="delimiter">)</span>
        else <span class="delimiter">{</span>
          val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.targ">targ</a>   = <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.apply" title="(n: Int)TypeMaps.this.Type">rhsArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.argIndex" title="Int">argIndex</a><span class="delimiter">)</span>
          <span class="comment">// @M! don't just replace the whole thing, might be followed by type application</span>
          val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.result">result</a> = <a href="../Types.scala.html#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: TypeMaps.this.Type, args: List[TypeMaps.this.Type])TypeMaps.this.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.targ" title="TypeMaps.this.Type">targ</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.lhsArgs" title="List[TypeMaps.this.Type]">lhsArgs</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="(f: TypeMaps.this.Type =&gt; TypeMaps.this.Type)List[TypeMaps.this.Type]">mapConserve</a> this<span class="delimiter">)</span>
          def <a title="=&gt; String" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.msg">msg</a> = <a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;Created &quot;)">Created $</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.result" title="TypeMaps.this.Type">result</a><span title="String(&quot;, though could not find &quot;)">, though could not find $</span><span class="delimiter">{</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.own_s" title="(s: TypeMaps.this.Symbol)String">own_s</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.lhsSym" title="TypeMaps.this.Symbol">lhsSym</a><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot; among tparams of &quot;)"> among tparams of $</span><span class="delimiter">{</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.own_s" title="(s: TypeMaps.this.Symbol)String">own_s</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.rhsSym" title="TypeMaps.this.Symbol">rhsSym</a><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span>
          if <span class="delimiter">(</span><a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.rhsSym" title="TypeMaps.this.Symbol">rhsSym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeParams" title="=&gt; List[TypeMaps.this.Symbol]">typeParams</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: TypeMaps.this.Symbol)Boolean">contains</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.lhsSym" title="TypeMaps.this.Symbol">lhsSym</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.devWarning" title="(msg: =&gt; String)Unit">devWarning</a><span class="delimiter">(</span><a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;Inconsistent tparam/owner views: had to fall back on names\\n&quot;)">Inconsistent tparam/owner views: had to fall back on names\n$</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.msg" title="=&gt; String">msg</a><span title="String(&quot;\\n&quot;)">\n$</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.explain" title="=&gt; String">explain</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>

          <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument.result" title="TypeMaps.this.Type">result</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">// 0) @pre: `classParam` is a class type parameter</span>
    <span class="comment">// 1) Walk the owner chain of `seenFromClass` until we find the class which owns `classParam`</span>
    <span class="comment">// 2) Take the base type of the prefix at that point with respect to the owning class</span>
    <span class="comment">// 3) Solve for the type parameters through correspondence with the type args of the base type</span>
    <span class="comment">//</span>
    <span class="comment">// Only class type parameters (and not skolems) are considered, because other type parameters</span>
    <span class="comment">// are not influenced by the prefix through which they are seen. Note that type params of</span>
    <span class="comment">// anonymous type functions, which currently can only arise from normalising type aliases, are</span>
    <span class="comment">// owned by the type alias of which they are the eta-expansion.</span>
    private def <a title="(classParam: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen">classParameterAsSeen</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.classParam">classParam</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span class="delimiter">{</span>
      val TypeRef<a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.tparam.tparam" title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.tparam" class="delimiter">(</a>_, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.tparam.tparam">tparam</a>, _<span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.classParam" title="TypeMaps.this.Type">classParam</a>

      def <a title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop">loop</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.pre">pre</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.clazz">clazz</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span class="delimiter">{</span>
        <span class="comment">// have to deconst because it may be a Class[T]</span>
        def <a title="=&gt; TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.nextBase">nextBase</a> = <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.pre" title="TypeMaps.this.Type">pre</a> <a href="../Types.scala.html#scala.reflect.internal;Types;Type.baseType" title="(clazz: TypeMaps.this.Symbol)TypeMaps.this.Type">baseType</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.clazz" title="TypeMaps.this.Symbol">clazz</a><span class="delimiter">)</span>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.deconst" title="=&gt; TypeMaps.this.Type">deconst</a>
        <span class="comment">//@M! see test pos/tcpoly_return_overriding.scala why mapOver is necessary</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.skipPrefixOf" title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)Boolean">skipPrefixOf</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.pre" title="TypeMaps.this.Type">pre</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.clazz" title="TypeMaps.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.classParam" title="TypeMaps.this.Type">classParam</a><span class="delimiter">)</span>
        else if <span class="delimiter">(</span><a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.matchesPrefixAndClass" title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)(candidate: TypeMaps.this.Symbol)Boolean">matchesPrefixAndClass</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.pre" title="TypeMaps.this.Type">pre</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.clazz" title="TypeMaps.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.tparam" title="TypeMaps.this.Symbol">tparam</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop" title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)TypeMaps.this.Type">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.nextBase" title="=&gt; TypeMaps.this.Type">nextBase</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.prefix" title="=&gt; TypeMaps.this.Type">prefix</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.clazz" title="TypeMaps.this.Symbol">clazz</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a><span class="delimiter">)</span>
        else <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.nextBase" title="=&gt; TypeMaps.this.Type">nextBase</a> match <span class="delimiter">{</span>
          case <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeMaps.this.NoType.type">NoType</a>                         =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop" title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)TypeMaps.this.Type">loop</a><span class="delimiter">(</span><a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeMaps.this.NoType.type">NoType</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.clazz" title="TypeMaps.this.Symbol">clazz</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a><span class="delimiter">)</span> <span class="comment">// backstop for SI-2797, must remove `SingletonType#isHigherKinded` and run pos/t2797.scala to get here.</span>
          case <a title="TypeMaps.this.TypeRef" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.applied">applied</a> @ TypeRef<span class="delimiter">(</span>_, _, _<span class="delimiter">)</span>     =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.correspondingTypeArgument" title="(lhs: TypeMaps.this.Type, rhs: TypeMaps.this.Type)TypeMaps.this.Type">correspondingTypeArgument</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.classParam" title="TypeMaps.this.Type">classParam</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.applied" title="TypeMaps.this.TypeRef">applied</a><span class="delimiter">)</span>
          case ExistentialType<span class="delimiter">(</span><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.eparams">eparams</a>, <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.qtpe">qtpe</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureSkolems" title="(skolems: List[TypeMaps.this.Symbol])Unit">captureSkolems</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.eparams" title="List[TypeMaps.this.Symbol]">eparams</a><span class="delimiter">)</span> ; <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop" title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)TypeMaps.this.Type">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.qtpe" title="TypeMaps.this.Type">qtpe</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.clazz" title="TypeMaps.this.Symbol">clazz</a><span class="delimiter">)</span>
          case <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop.t">t</a>                              =&gt; <a href="../Reporting.scala.html#scala.reflect.internal;Reporting.abort" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.tparam" title="TypeMaps.this.Symbol">tparam</a><span title="String(&quot; in &quot;)"> in $</span><span class="delimiter">{</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.tparam" title="TypeMaps.this.Symbol">tparam</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a><span class="delimiter">}</span><span title="String(&quot; cannot be instantiated from &quot;)"> cannot be instantiated from $</span><span class="delimiter">{</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromPrefix" title="TypeMaps.this.Type">seenFromPrefix</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.widen" title="=&gt; TypeMaps.this.Type">widen</a><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.classParameterAsSeen.loop" title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)TypeMaps.this.Type">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromPrefix" title="TypeMaps.this.Type">seenFromPrefix</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromClass" title="TypeMaps.this.Symbol">seenFromClass</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// Does the candidate symbol match the given prefix and class?</span>
    <span class="comment">// Since pre may be something like ThisType(A) where trait A { self: B =&gt; },</span>
    <span class="comment">// we have to test the typeSymbol of the widened type, not pre.typeSymbol, or</span>
    <span class="comment">// B will not be considered.</span>
    private def <a title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)(candidate: TypeMaps.this.Symbol)Boolean" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.matchesPrefixAndClass">matchesPrefixAndClass</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.matchesPrefixAndClass.pre">pre</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.matchesPrefixAndClass.clazz">clazz</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.matchesPrefixAndClass.candidate">candidate</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.matchesPrefixAndClass.clazz" title="TypeMaps.this.Symbol">clazz</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.matchesPrefixAndClass.candidate" title="TypeMaps.this.Symbol">candidate</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.matchesPrefixAndClass.pre" title="TypeMaps.this.Type">pre</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.widen" title="=&gt; TypeMaps.this.Type">widen</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; TypeMaps.this.Symbol">typeSymbol</a> <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isSubClass" title="(that: TypeMaps.this.Symbol)Boolean">isSubClass</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.matchesPrefixAndClass.clazz" title="TypeMaps.this.Symbol">clazz</a><span class="delimiter">)</span>

    <span class="comment">// Whether the annotation tree currently being mapped over has had a This(_) node rewritten.</span>
    private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="Boolean" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.wroteAnnotation">wroteAnnotation</a> = false
    private object <a title="AsSeenFromMap.this.annotationArgRewriter.type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter">annotationArgRewriter</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer" title="AsSeenFromMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>
      private def <a title="(thiz: TypeMaps.this.Symbol)Boolean" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.matchesThis">matchesThis</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.matchesThis.thiz">thiz</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.matchesPrefixAndClass" title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)(candidate: TypeMaps.this.Symbol)Boolean">matchesPrefixAndClass</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromPrefix" title="TypeMaps.this.Type">seenFromPrefix</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromClass" title="TypeMaps.this.Symbol">seenFromClass</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.matchesThis.thiz" title="TypeMaps.this.Symbol">thiz</a><span class="delimiter">)</span>

      <span class="comment">// what symbol should really be used?</span>
      private def <a title="()TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.newThis">newThis</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a> = <span class="delimiter">{</span>
        <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.wroteAnnotation" title="Boolean">wroteAnnotation</a> = true
        val <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.newThis.presym">presym</a>      = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromPrefix" title="TypeMaps.this.Type">seenFromPrefix</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.widen" title="=&gt; TypeMaps.this.Type">widen</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; TypeMaps.this.Symbol">typeSymbol</a>
        val thisSym     = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.newThis.presym" title="TypeMaps.this.Symbol">presym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.newThis.thisSym.qual$1">owner</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.newValue$default$3" title="Long" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.newThis.thisSym.x$16">newValue</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.newThis.presym" title="TypeMaps.this.Symbol">presym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; presym.NameType">name</a>.<a href="../Names.scala.html#scala.reflect.internal;Names;Name.toTermName" title="TypeMaps.this.TermName" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.newThis.thisSym.x$14">toTermName</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.newThis.presym" title="TypeMaps.this.Symbol">presym</a>.<a href="../StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.pos" title="TypeMaps.this.Position" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.newThis.thisSym.x$15">pos</a><span class="delimiter">)</span> <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="TypeMaps.this.TermSymbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.newThis.thisSym">setInfo</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromPrefix" title="TypeMaps.this.Type">seenFromPrefix</a>
        <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.gen" title="=&gt; scala.reflect.internal.TreeGen{val global: TypeMaps.this.type}">gen</a>.<a href="../TreeGen.scala.html#scala.reflect.internal;TreeGen.mkAttributedQualifier(63a1718c8b)" title="(tpe: TypeMaps.this.gen.global.Type, termSym: TypeMaps.this.gen.global.Symbol)TypeMaps.this.gen.global.Tree">mkAttributedQualifier</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromPrefix" title="TypeMaps.this.Type">seenFromPrefix</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.newThis.thisSym" title="TypeMaps.this.TermSymbol">thisSym</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="comment">/** Rewrite `This` trees in annotation argument trees */</span>
      override def <a title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.transform">transform</a><span class="delimiter">(</span><span title="TypeMaps.this.Tree">tree</span>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a> = super.<a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree">transform</a><span class="delimiter">(</span><span title="TypeMaps.this.Tree">tree</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case This<span class="delimiter">(</span>_<span class="delimiter">)</span> if <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.matchesThis" title="(thiz: TypeMaps.this.Symbol)Boolean">matchesThis</a><span class="delimiter">(</span><span title="TypeMaps.this.Tree">tree</span>.<a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; TypeMaps.this.Symbol">symbol</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.newThis" title="()TypeMaps.this.Tree">newThis</a><span class="delimiter">(</span><span class="delimiter">)</span>
        case <span title="TypeMaps.this.Tree">tree</span>                                =&gt; <span title="TypeMaps.this.Tree">tree</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">// This becomes considerably cheaper if we optimize for the common cases:</span>
    <span class="comment">// where the prefix is stable and where no This nodes are rewritten. If</span>
    <span class="comment">// either is true, then we don't need to worry about calling giveup. So if</span>
    <span class="comment">// the prefix is unstable, use a stack variable to indicate whether the tree</span>
    <span class="comment">// was touched. This takes us to one allocation per AsSeenFromMap rather</span>
    <span class="comment">// than an allocation on every call to mapOver, and no extra work when the</span>
    <span class="comment">// tree only has its types remapped.</span>
    override def <a title="(tree: TypeMaps.this.Tree, giveup: () =&gt; Nothing)TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.mapOver(6a76c588ac)">mapOver</a><span class="delimiter">(</span><a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.mapOver(6a76c588ac).tree">tree</a>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a>, <a title="() =&gt; Nothing" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.mapOver(6a76c588ac).giveup">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.isStablePrefix" title="=&gt; Boolean">isStablePrefix</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter" title="AsSeenFromMap.this.annotationArgRewriter.type">annotationArgRewriter</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.transform" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree">transform</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.mapOver(6a76c588ac).tree" title="TypeMaps.this.Tree">tree</a>
      else <span class="delimiter">{</span>
        val <a title="Boolean" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.mapOver(6a76c588ac).saved">saved</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.wroteAnnotation" title="Boolean">wroteAnnotation</a>
        <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.wroteAnnotation" title="Boolean">wroteAnnotation</a> = false
        try <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter" title="AsSeenFromMap.this.annotationArgRewriter.type">annotationArgRewriter</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.annotationArgRewriter.transform" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree">transform</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.mapOver(6a76c588ac).tree" title="TypeMaps.this.Tree">tree</a>
        finally if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.wroteAnnotation" title="Boolean">wroteAnnotation</a><span class="delimiter">)</span> <a href="../../../Function0.scala.html#scala;Function0.apply" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span> else <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.wroteAnnotation" title="Boolean">wroteAnnotation</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.mapOver(6a76c588ac).saved" title="Boolean">saved</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    private def <a title="(tp: TypeMaps.this.ThisType)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen">thisTypeAsSeen</a><span class="delimiter">(</span><a title="TypeMaps.this.ThisType" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;ThisType" title="TypeMaps.this.ThisType">ThisType</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span class="delimiter">{</span>
      def <a title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop">loop</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.pre">pre</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.clazz">clazz</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span class="delimiter">{</span>
        val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.pre1">pre1</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.pre" title="TypeMaps.this.Type">pre</a> match <span class="delimiter">{</span>
          case SuperType<span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.pre1.thistpe">thistpe</a>, _<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.pre1.thistpe" title="TypeMaps.this.Type">thistpe</a>
          case _                     =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.pre" title="TypeMaps.this.Type">pre</a>
        <span class="delimiter">}</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.skipPrefixOf" title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)Boolean">skipPrefixOf</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.pre" title="TypeMaps.this.Type">pre</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.clazz" title="TypeMaps.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.tp" title="TypeMaps.this.ThisType">tp</a><span class="delimiter">)</span> <span class="comment">// TODO - is mapOver necessary here?</span>
        else if <span class="delimiter">(</span><a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.matchesPrefixAndClass" title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)(candidate: TypeMaps.this.Symbol)Boolean">matchesPrefixAndClass</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.pre" title="TypeMaps.this.Type">pre</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.clazz" title="TypeMaps.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.tp" title="TypeMaps.this.ThisType">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;ThisType.sym" title="=&gt; TypeMaps.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop" title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)TypeMaps.this.Type">loop</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.pre" title="TypeMaps.this.Type">pre</a> <a href="../Types.scala.html#scala.reflect.internal;Types;Type.baseType" title="(clazz: TypeMaps.this.Symbol)TypeMaps.this.Type">baseType</a> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.clazz" title="TypeMaps.this.Symbol">clazz</a><span class="delimiter">)</span>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.prefix" title="=&gt; TypeMaps.this.Type">prefix</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.clazz" title="TypeMaps.this.Symbol">clazz</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a><span class="delimiter">)</span>
        else if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.pre1" title="TypeMaps.this.Type">pre1</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.isStable" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.pre1" title="TypeMaps.this.Type">pre1</a>
        else
          <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.captureThis" title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)TypeMaps.this.Type">captureThis</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.pre1" title="TypeMaps.this.Type">pre1</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop.clazz" title="TypeMaps.this.Symbol">clazz</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.thisTypeAsSeen.loop" title="(pre: TypeMaps.this.Type, clazz: TypeMaps.this.Symbol)TypeMaps.this.Type">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromPrefix" title="TypeMaps.this.Type">seenFromPrefix</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromClass" title="TypeMaps.this.Symbol">seenFromClass</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    private def <a title="(tp: TypeMaps.this.SingleType)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen">singleTypeAsSeen</a><span class="delimiter">(</span><a title="TypeMaps.this.SingleType" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;SingleType" title="TypeMaps.this.SingleType">SingleType</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span class="delimiter">{</span>
      val SingleType<a href="../../../Tuple2.scala.html#scala;Tuple2" title="(TypeMaps.this.Type, TypeMaps.this.Symbol)" class="delimiter">(</a><a href="../../../Tuple2.scala.html#scala;Tuple2._1" title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen.pre">pre</a>, <a href="../../../Tuple2.scala.html#scala;Tuple2._2" title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen.sym">sym</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen.tp" title="TypeMaps.this.SingleType">tp</a>

      val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen.pre1">pre1</a> = this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen.pre" title="TypeMaps.this.Type">pre</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen.pre1" title="TypeMaps.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen.pre" title="TypeMaps.this.Type">pre</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen.tp" title="TypeMaps.this.SingleType">tp</a>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen.pre1" title="TypeMaps.this.Type">pre1</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.isStable" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="../Types.scala.html#scala.reflect.internal;Types.singleType" title="(pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol)TypeMaps.this.Type">singleType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen.pre1" title="TypeMaps.this.Type">pre1</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen.sym" title="TypeMaps.this.Symbol">sym</a><span class="delimiter">)</span>
      else <a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen.pre1" title="TypeMaps.this.Type">pre1</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.memberType" title="(sym: TypeMaps.this.Symbol)TypeMaps.this.Type">memberType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.singleTypeAsSeen.sym" title="TypeMaps.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.resultType(9b9cdebb0f)" title="=&gt; TypeMaps.this.Type">resultType</a> <span class="comment">//todo: this should be rolled into existential abstraction</span>
    <span class="delimiter">}</span>

    override def <a title="()String" id="scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.toString">toString</a> = <a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;AsSeenFromMap(&quot;)">AsSeenFromMap($</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromPrefix" title="TypeMaps.this.Type">seenFromPrefix</a><span title="String(&quot;, &quot;)">, $</span><a href="#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.seenFromClass" title="TypeMaps.this.Symbol">seenFromClass</a><span title="String(&quot;)&quot;)" class="string">)&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A base class to compute all substitutions */</span>
  abstract class <a title="class SubstMap[T] extends TypeMaps.this.TypeMap" id="scala.reflect.internal.tpe;TypeMaps;SubstMap">SubstMap</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal.tpe;TypeMaps;SubstMap;T">T</a><span class="delimiter">]</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap" title="TypeMaps.this.SubstMap[T]" class="delimiter">(</a><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.from">from</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[T]" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.to">to</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    <span class="comment">// OPT this check was 2-3% of some profiles, demoted to -Xdev</span>
    if <span class="delimiter">(</span><a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.isDeveloper" title="=&gt; Boolean">isDeveloper</a><span class="delimiter">)</span> <a href="../../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="../Types.scala.html#scala.reflect.internal;Types.sameLength" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.from" title="List[TypeMaps.this.Symbol]">from</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.to" title="List[T]">to</a><span class="delimiter">)</span>, <span title="String(&quot;Unsound substitution from &quot;)" class="string">&quot;Unsound substitution from &quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.from" title="List[TypeMaps.this.Symbol]">from</a> <span title="(x$1: Any)String">+</span><span title="String(&quot; to &quot;)" class="string">&quot; to &quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.to" title="List[T]">to</a><span class="delimiter">)</span>

    <span class="comment">/** Are `sym` and `sym1` the same? Can be tuned by subclasses. */</span>
    protected def <a title="(sym: TypeMaps.this.Symbol, sym1: TypeMaps.this.Symbol)Boolean" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.matches">matches</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.matches.sym">sym</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.matches.sym1">sym1</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.matches.sym" title="TypeMaps.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.matches.sym1" title="TypeMaps.this.Symbol">sym1</a>

    <span class="comment">/** Map target to type, can be tuned by subclasses */</span>
    protected def <a title="(fromtp: TypeMaps.this.Type, tp: T)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.toType">toType</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.toType.fromtp">fromtp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>, <a title="T" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.toType.tp">tp</a>: <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap;T" title="T">T</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>

    protected def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.renameBoundSyms">renameBoundSyms</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.renameBoundSyms.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.renameBoundSyms.tp" title="TypeMaps.this.Type">tp</a> match <span class="delimiter">{</span>
      case MethodType<span class="delimiter">(</span><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.renameBoundSyms.ps">ps</a>, <span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span> =&gt;
        <a href="../Symbols.scala.html#scala.reflect.internal;Symbols.createFromClonedSymbols" title="(syms: List[TypeMaps.this.Symbol], tpe: TypeMaps.this.Type)(creator: (List[TypeMaps.this.Symbol], TypeMaps.this.Type) =&gt; TypeMaps.this.Type)TypeMaps.this.Type">createFromClonedSymbols</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.renameBoundSyms.ps" title="List[TypeMaps.this.Symbol]">ps</a>, <span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">ps1</span>, <span title="TypeMaps.this.Type">tp1</span><span class="delimiter">)</span> =&gt; <a href="../Types.scala.html#scala.reflect.internal;Types.copyMethodType" title="(tp: TypeMaps.this.Type, params: List[TypeMaps.this.Symbol], restpe: TypeMaps.this.Type)TypeMaps.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.renameBoundSyms.tp" title="TypeMaps.this.Type">tp</a>, <span title="List[TypeMaps.this.Symbol]">ps1</span>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.renameBoundSyms" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">renameBoundSyms</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case PolyType<span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">bs</span>, <span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span> =&gt;
        <a href="../Symbols.scala.html#scala.reflect.internal;Symbols.createFromClonedSymbols" title="(syms: List[TypeMaps.this.Symbol], tpe: TypeMaps.this.Type)(creator: (List[TypeMaps.this.Symbol], TypeMaps.this.Type) =&gt; TypeMaps.this.PolyType)TypeMaps.this.PolyType">createFromClonedSymbols</a><span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">bs</span>, <span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">ps1</span>, <span title="TypeMaps.this.Type">tp1</span><span class="delimiter">)</span> =&gt; <a href="../Types.scala.html#scala.reflect.internal;Types;PolyType" title="(typeParams: List[TypeMaps.this.Symbol], resultType: TypeMaps.this.Type)TypeMaps.this.PolyType">PolyType</a><span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">ps1</span>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.renameBoundSyms" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">renameBoundSyms</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case ExistentialType<span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">bs</span>, <span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span> =&gt;
        <a href="../Symbols.scala.html#scala.reflect.internal;Symbols.createFromClonedSymbols" title="(syms: List[TypeMaps.this.Symbol], tpe: TypeMaps.this.Type)(creator: (List[TypeMaps.this.Symbol], TypeMaps.this.Type) =&gt; TypeMaps.this.Type)TypeMaps.this.Type">createFromClonedSymbols</a><span class="delimiter">(</span><span title="List[TypeMaps.this.Symbol]">bs</span>, <span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="../Types.scala.html#scala.reflect.internal;Types.newExistentialType" title="(quantified: List[TypeMaps.this.Symbol], underlying: TypeMaps.this.Type)TypeMaps.this.Type">newExistentialType</a><span class="delimiter">)</span>
      case _ =&gt;
        <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.renameBoundSyms.tp" title="TypeMaps.this.Type">tp</a>
    <span class="delimiter">}</span>

    @tailrec private def <a title="(tp: TypeMaps.this.Type, sym: TypeMaps.this.Symbol, from: List[TypeMaps.this.Symbol], to: List[T])TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.subst">subst</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.subst.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.subst.sym">sym</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a>, <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.subst.from">from</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[T]" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.subst.to">to</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.subst.from" title="List[TypeMaps.this.Symbol]">from</a>.<a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.subst.tp" title="TypeMaps.this.Type">tp</a>
      <span class="comment">// else if (to.isEmpty) error(&quot;Unexpected substitution on '%s': from = %s but to == Nil&quot;.format(tp, from))</span>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.matches" title="(sym: TypeMaps.this.Symbol, sym1: TypeMaps.this.Symbol)Boolean">matches</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.subst.from" title="List[TypeMaps.this.Symbol]">from</a>.<a href="../../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; TypeMaps.this.Symbol">head</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.subst.sym" title="TypeMaps.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.toType" title="(fromtp: TypeMaps.this.Type, tp: T)TypeMaps.this.Type">toType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.subst.tp" title="TypeMaps.this.Type">tp</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.subst.to" title="List[T]">to</a>.<a href="../../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; T">head</a><span class="delimiter">)</span>
      else <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.subst" title="(tp: TypeMaps.this.Type, sym: TypeMaps.this.Symbol, from: List[TypeMaps.this.Symbol], to: List[T])TypeMaps.this.Type">subst</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.subst.tp" title="TypeMaps.this.Type">tp</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.subst.sym" title="TypeMaps.this.Symbol">sym</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.subst.from" title="List[TypeMaps.this.Symbol]">from</a>.<a href="../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[TypeMaps.this.Symbol]">tail</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.subst.to" title="List[T]">to</a>.<a href="../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[T]">tail</a><span class="delimiter">)</span>
      <span class="delimiter">)</span>

    def <a title="(tp0: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tp0">tp0</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.from" title="List[TypeMaps.this.Symbol]">from</a>.<a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tp0" title="TypeMaps.this.Type">tp0</a> else <span class="delimiter">{</span>
      val <a title="scala.collection.immutable.Set[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.boundSyms">boundSyms</a>             = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tp0" title="TypeMaps.this.Type">tp0</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.boundSyms" title="=&gt; scala.collection.immutable.Set[TypeMaps.this.Symbol]">boundSyms</a>
      val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tp1">tp1</a>                   = if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.boundSyms" title="scala.collection.immutable.Set[TypeMaps.this.Symbol]">boundSyms</a>.<a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.boundSyms" title="scala.collection.immutable.Set[TypeMaps.this.Symbol]">boundSyms</a> <a href="../../../collection/IterableLike.scala.html#scala.collection;IterableLike.exists" title="(p: TypeMaps.this.Symbol =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.from" title="List[TypeMaps.this.Symbol]">from</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: Any)Boolean">contains</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.renameBoundSyms" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">renameBoundSyms</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tp0" title="TypeMaps.this.Type">tp0</a><span class="delimiter">)</span> else <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tp0" title="TypeMaps.this.Type">tp0</a>
      val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tp">tp</a>                    = <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tp1" title="TypeMaps.this.Type">tp1</a><span class="delimiter">)</span>
      def <a title="(sym: TypeMaps.this.Symbol)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.substFor">substFor</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.substFor.sym">sym</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.subst" title="(tp: TypeMaps.this.Type, sym: TypeMaps.this.Symbol, from: List[TypeMaps.this.Symbol], to: List[T])TypeMaps.this.Type">subst</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tp" title="TypeMaps.this.Type">tp</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.substFor.sym" title="TypeMaps.this.Symbol">sym</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.from" title="List[TypeMaps.this.Symbol]">from</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.to" title="List[T]">to</a><span class="delimiter">)</span>

      <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tp" title="TypeMaps.this.Type">tp</a> match <span class="delimiter">{</span>
        <span class="comment">// @M</span>
        <span class="comment">// 1) arguments must also be substituted (even when the &quot;head&quot; of the</span>
        <span class="comment">// applied type has already been substituted)</span>
        <span class="comment">// example: (subst RBound[RT] from [type RT,type RBound] to</span>
        <span class="comment">// [type RT&amp;,type RBound&amp;]) = RBound&amp;[RT&amp;]</span>
        <span class="comment">// 2) avoid loops (which occur because alpha-conversion is</span>
        <span class="comment">// not performed properly imo)</span>
        <span class="comment">// e.g. if in class Iterable[a] there is a new Iterable[(a,b)],</span>
        <span class="comment">// we must replace the a in Iterable[a] by (a,b)</span>
        <span class="comment">// (must not recurse --&gt; loops)</span>
        <span class="comment">// 3) replacing m by List in m[Int] should yield List[Int], not just List</span>
        case TypeRef<span class="delimiter">(</span><a href="../Types.scala.html#scala.reflect.internal;Types.NoPrefix" title="TypeMaps.this.NoPrefix.type">NoPrefix</a>, <span title="TypeMaps.this.Symbol">sym</span>, <a title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.args">args</a><span class="delimiter">)</span> =&gt;
          val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tcon">tcon</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.substFor" title="(sym: TypeMaps.this.Symbol)TypeMaps.this.Type">substFor</a><span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span>
          if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tp" title="TypeMaps.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tcon" title="TypeMaps.this.Type">tcon</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.args" title="List[TypeMaps.this.Type]">args</a>.<a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tcon" title="TypeMaps.this.Type">tcon</a>
          else <a href="../Types.scala.html#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: TypeMaps.this.Type, args: List[TypeMaps.this.Type])TypeMaps.this.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tcon" title="TypeMaps.this.Type">tcon</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.typeConstructor" title="=&gt; TypeMaps.this.Type">typeConstructor</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.args" title="List[TypeMaps.this.Type]">args</a><span class="delimiter">)</span>
        case SingleType<span class="delimiter">(</span><a href="../Types.scala.html#scala.reflect.internal;Types.NoPrefix" title="TypeMaps.this.NoPrefix.type">NoPrefix</a>, <span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span> =&gt;
          <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.substFor" title="(sym: TypeMaps.this.Symbol)TypeMaps.this.Type">substFor</a><span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span>
        case ClassInfoType<span class="delimiter">(</span><a title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.parents">parents</a>, <a title="TypeMaps.this.Scope" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.decls">decls</a>, <span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span> =&gt;
          val parents1 = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.parents" title="List[TypeMaps.this.Type]">parents</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.parents1">mapConserve</a> this
          <span class="comment">// We don't touch decls here; they will be touched when an enclosing TreeSubstitutor</span>
          <span class="comment">// transforms the tree that defines them.</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.parents1" title="List[TypeMaps.this.Type]">parents1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.parents" title="List[TypeMaps.this.Type]">parents</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tp" title="TypeMaps.this.Type">tp</a>
          else <a href="../Types.scala.html#scala.reflect.internal;Types;ClassInfoType" title="(parents: List[TypeMaps.this.Type], decls: TypeMaps.this.Scope, typeSymbol: TypeMaps.this.Symbol)TypeMaps.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.parents1" title="List[TypeMaps.this.Type]">parents1</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.decls" title="TypeMaps.this.Scope">decls</a>, <span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span>
        case _ =&gt;
          <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply.tp" title="TypeMaps.this.Type">tp</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `substSym` method. */</span>
  class <a title="class SubstSymMap extends TypeMaps.this.SubstMap[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap">SubstSymMap</a><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap" title="TypeMaps.this.SubstSymMap" class="delimiter">(</a><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.from">from</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.to">to</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap" title="TypeMaps.this.SubstMap[TypeMaps.this.Symbol]">SubstMap</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.from" title="List[TypeMaps.this.Symbol]">from</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.to" title="List[TypeMaps.this.Symbol]">to</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def this<span class="delimiter">(</span><a title="(TypeMaps.this.Symbol, TypeMaps.this.Symbol)*" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.<init>(8f9f09916e).pairs">pairs</a>: <span title="(TypeMaps.this.Symbol, TypeMaps.this.Symbol)*" class="delimiter">(</span>Symbol, Symbol<span class="delimiter">)</span>*<span class="delimiter">)</span> = this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.<init>(8f9f09916e).pairs" title="(TypeMaps.this.Symbol, TypeMaps.this.Symbol)*">pairs</a>.<a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[(TypeMaps.this.Symbol, TypeMaps.this.Symbol)]">toList</a>.<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: ((TypeMaps.this.Symbol, TypeMaps.this.Symbol)) =&gt; TypeMaps.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[(TypeMaps.this.Symbol, TypeMaps.this.Symbol)],TypeMaps.this.Symbol,List[TypeMaps.this.Symbol]])List[TypeMaps.this.Symbol]">map</a><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.List.canBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,TypeMaps.this.Symbol,List[TypeMaps.this.Symbol]]" class="delimiter">(</a><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.<init>(8f9f09916e).$anonfun.x$11" title="(TypeMaps.this.Symbol, TypeMaps.this.Symbol)">_</a>.<a href="../../../Tuple2.scala.html#scala;Tuple2._1" title="=&gt; TypeMaps.this.Symbol">_1</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.<init>(8f9f09916e).pairs" title="(TypeMaps.this.Symbol, TypeMaps.this.Symbol)*">pairs</a>.<a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[(TypeMaps.this.Symbol, TypeMaps.this.Symbol)]">toList</a>.<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: ((TypeMaps.this.Symbol, TypeMaps.this.Symbol)) =&gt; TypeMaps.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[(TypeMaps.this.Symbol, TypeMaps.this.Symbol)],TypeMaps.this.Symbol,List[TypeMaps.this.Symbol]])List[TypeMaps.this.Symbol]">map</a><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.List.canBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,TypeMaps.this.Symbol,List[TypeMaps.this.Symbol]]" class="delimiter">(</a><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.<init>(8f9f09916e).$anonfun.x$12" title="(TypeMaps.this.Symbol, TypeMaps.this.Symbol)">_</a>.<a href="../../../Tuple2.scala.html#scala;Tuple2._2" title="=&gt; TypeMaps.this.Symbol">_2</a><span class="delimiter">)</span><span class="delimiter">)</span>

    protected def <a title="(fromtp: TypeMaps.this.Type, sym: TypeMaps.this.Symbol)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.toType">toType</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.toType.fromtp">fromtp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.toType.sym">sym</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.toType.fromtp" title="TypeMaps.this.Type">fromtp</a> match <span class="delimiter">{</span>
      case TypeRef<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span>, _, <a title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.toType.args">args</a><span class="delimiter">)</span> =&gt; <a href="../Types.scala.html#scala.reflect.internal;Types.copyTypeRef" title="(tp: TypeMaps.this.Type, pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol, args: List[TypeMaps.this.Type])TypeMaps.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.toType.fromtp" title="TypeMaps.this.Type">fromtp</a>, <span title="TypeMaps.this.Type">pre</span>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.toType.sym" title="TypeMaps.this.Symbol">sym</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.toType.args" title="List[TypeMaps.this.Type]">args</a><span class="delimiter">)</span>
      case SingleType<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span>, _<span class="delimiter">)</span> =&gt; <a href="../Types.scala.html#scala.reflect.internal;Types.singleType" title="(pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol)TypeMaps.this.Type">singleType</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.toType.sym" title="TypeMaps.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    @tailrec private def <a title="(sym: TypeMaps.this.Symbol, from: List[TypeMaps.this.Symbol], to: List[TypeMaps.this.Symbol])TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.subst">subst</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.subst.sym">sym</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a>, <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.subst.from">from</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.subst.to">to</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.subst.from" title="List[TypeMaps.this.Symbol]">from</a>.<a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.subst.sym" title="TypeMaps.this.Symbol">sym</a>
      <span class="comment">// else if (to.isEmpty) error(&quot;Unexpected substitution on '%s': from = %s but to == Nil&quot;.format(sym, from))</span>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.matches" title="(sym: TypeMaps.this.Symbol, sym1: TypeMaps.this.Symbol)Boolean">matches</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.subst.from" title="List[TypeMaps.this.Symbol]">from</a>.<a href="../../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; TypeMaps.this.Symbol">head</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.subst.sym" title="TypeMaps.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.subst.to" title="List[TypeMaps.this.Symbol]">to</a>.<a href="../../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; TypeMaps.this.Symbol">head</a>
      else <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.subst" title="(sym: TypeMaps.this.Symbol, from: List[TypeMaps.this.Symbol], to: List[TypeMaps.this.Symbol])TypeMaps.this.Symbol">subst</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.subst.sym" title="TypeMaps.this.Symbol">sym</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.subst.from" title="List[TypeMaps.this.Symbol]">from</a>.<a href="../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[TypeMaps.this.Symbol]">tail</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.subst.to" title="List[TypeMaps.this.Symbol]">to</a>.<a href="../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[TypeMaps.this.Symbol]">tail</a><span class="delimiter">)</span>
      <span class="delimiter">)</span>
    private def <a title="(sym: TypeMaps.this.Symbol)TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.substFor">substFor</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.substFor.sym">sym</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.subst" title="(sym: TypeMaps.this.Symbol, from: List[TypeMaps.this.Symbol], to: List[TypeMaps.this.Symbol])TypeMaps.this.Symbol">subst</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.substFor.sym" title="TypeMaps.this.Symbol">sym</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.from" title="List[TypeMaps.this.Symbol]">from</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.to" title="List[TypeMaps.this.Symbol]">to</a><span class="delimiter">)</span>

    override def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.apply.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.from" title="List[TypeMaps.this.Symbol]">from</a>.<a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.apply.tp" title="TypeMaps.this.Type">tp</a>
      else <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.apply.tp" title="TypeMaps.this.Type">tp</a> match <span class="delimiter">{</span>
        case TypeRef<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span>, <span title="TypeMaps.this.Symbol">sym</span>, <a title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.apply.args">args</a><span class="delimiter">)</span> if <span title="TypeMaps.this.Type">pre</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoPrefix" title="TypeMaps.this.NoPrefix.type">NoPrefix</a> =&gt;
          val <span title="TypeMaps.this.Symbol">newSym</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.substFor" title="(sym: TypeMaps.this.Symbol)TypeMaps.this.Symbol">substFor</a><span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span>
          <span class="comment">// mapOver takes care of subst'ing in args</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a> <span class="delimiter">(</span> if <span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Symbol">newSym</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.apply.tp" title="TypeMaps.this.Type">tp</a> else <a href="../Types.scala.html#scala.reflect.internal;Types.copyTypeRef" title="(tp: TypeMaps.this.Type, pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol, args: List[TypeMaps.this.Type])TypeMaps.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.apply.tp" title="TypeMaps.this.Type">tp</a>, <span title="TypeMaps.this.Type">pre</span>, <span title="TypeMaps.this.Symbol">newSym</span>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.apply.args" title="List[TypeMaps.this.Type]">args</a><span class="delimiter">)</span> <span class="delimiter">)</span>
        <span class="comment">// assert(newSym.typeParams.length == sym.typeParams.length, &quot;typars mismatch in SubstSymMap: &quot;+(sym, sym.typeParams, newSym, newSym.typeParams))</span>
        case SingleType<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span>, <span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span> if <span title="TypeMaps.this.Type">pre</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoPrefix" title="TypeMaps.this.NoPrefix.type">NoPrefix</a> =&gt;
          val <span title="TypeMaps.this.Symbol">newSym</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.substFor" title="(sym: TypeMaps.this.Symbol)TypeMaps.this.Symbol">substFor</a><span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span> if <span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Symbol">newSym</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.apply.tp" title="TypeMaps.this.Type">tp</a> else <a href="../Types.scala.html#scala.reflect.internal;Types.singleType" title="(pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol)TypeMaps.this.Type">singleType</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span>, <span title="TypeMaps.this.Symbol">newSym</span><span class="delimiter">)</span> <span class="delimiter">)</span>
        case _ =&gt;
          super.<a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply" title="(tp0: TypeMaps.this.Type)TypeMaps.this.Type">apply</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="delimiter">)</span>

    object <a title="SubstSymMap.this.mapTreeSymbols.type" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols">mapTreeSymbols</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer" title="SubstSymMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>
      val <a title="TypeMaps.this.TreeCopier" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.strictCopy">strictCopy</a> = <a href="../../api/Trees.scala.html#scala.reflect.api;Trees.newStrictTreeCopier" title="=&gt; TypeMaps.this.TreeCopier">newStrictTreeCopier</a>

      def <a title="(sym: TypeMaps.this.Symbol)Option[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.termMapsTo">termMapsTo</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.termMapsTo.sym">sym</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.from" title="List[TypeMaps.this.Symbol]">from</a> <a href="../../../collection/GenSeqLike.scala.html#scala.collection;GenSeqLike.indexOf(e13e28e917)" title="(elem: TypeMaps.this.Symbol)Int">indexOf</a> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.termMapsTo.sym" title="TypeMaps.this.Symbol">sym</a> match <span class="delimiter">{</span>
        case <span title="Int(-1)">-</span><span class="int">1</span>   =&gt; <a href="../../../Option.scala.html#scala.None" title="None.type">None</a>
        case <a title="Int" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.termMapsTo.idx">idx</a>  =&gt; <a href="../../../Option.scala.html#scala;Some" title="(x: TypeMaps.this.Symbol)Some[TypeMaps.this.Symbol]">Some</a><span class="delimiter">(</span><a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.apply" title="(n: Int)TypeMaps.this.Symbol">to</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.termMapsTo.idx" title="Int">idx</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="comment">// if tree.symbol is mapped to another symbol, passes the new symbol into the</span>
      <span class="comment">// constructor `trans` and sets the symbol and the type on the resulting tree.</span>
      def <a title="(tree: TypeMaps.this.Tree)(trans: TypeMaps.this.Symbol =&gt; TypeMaps.this.Tree)TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transformIfMapped">transformIfMapped</a><span class="delimiter">(</span><a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transformIfMapped.tree">tree</a>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="TypeMaps.this.Symbol =&gt; TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transformIfMapped.trans">trans</a>: Symbol =&gt; Tree<span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.termMapsTo" title="(sym: TypeMaps.this.Symbol)Option[TypeMaps.this.Symbol]">termMapsTo</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transformIfMapped.tree" title="TypeMaps.this.Tree">tree</a>.<a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; TypeMaps.this.Symbol">symbol</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case Some<span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transformIfMapped.toSym">toSym</a><span class="delimiter">)</span> =&gt; <a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: TypeMaps.this.Symbol)TypeMaps.this.Tree">trans</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transformIfMapped.toSym" title="TypeMaps.this.Symbol">toSym</a><span class="delimiter">)</span> <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.setSymbol" title="(sym: TypeMaps.this.Symbol)TypeMaps.this.Tree">setSymbol</a> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transformIfMapped.toSym" title="TypeMaps.this.Symbol">toSym</a> <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.setType" title="(tp: TypeMaps.this.Type)TypeMaps.this.Tree">setType</a> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transformIfMapped.tree" title="TypeMaps.this.Tree">tree</a>.<a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; TypeMaps.this.Type">tpe</a>
        case <a href="../../../Option.scala.html#scala.None" title="None.type">None</a> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transformIfMapped.tree" title="TypeMaps.this.Tree">tree</a>
      <span class="delimiter">}</span>

      <span class="comment">// changes trees which refer to one of the mapped symbols. trees are copied before attributes are modified.</span>
      override def <a title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transform">transform</a><span class="delimiter">(</span><span title="TypeMaps.this.Tree">tree</span>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="comment">// super.transform maps symbol references in the types of `tree`. it also copies trees where necessary.</span>
        super.<a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree">transform</a><span class="delimiter">(</span><span title="TypeMaps.this.Tree">tree</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case <a title="TypeMaps.this.Ident" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transform.id">id</a> @ Ident<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
            <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transformIfMapped" title="(tree: TypeMaps.this.Tree)(trans: TypeMaps.this.Symbol =&gt; TypeMaps.this.Tree)TypeMaps.this.Tree">transformIfMapped</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transform.id" title="TypeMaps.this.Ident">id</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="TypeMaps.this.Symbol">toSym</span> =&gt;
              <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.strictCopy" title="=&gt; TypeMaps.this.TreeCopier">strictCopy</a>.<a href="../../api/Trees.scala.html#scala.reflect.api;Trees;TreeCopierOps.Ident" title="(tree: TypeMaps.this.Tree, name: TypeMaps.this.Name)TypeMaps.this.Ident">Ident</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transform.id" title="TypeMaps.this.Ident">id</a>, <span title="TypeMaps.this.Symbol">toSym</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; toSym.NameType">name</a><span class="delimiter">)</span><span class="delimiter">)</span>

          case <a title="TypeMaps.this.Select" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transform.sel">sel</a> @ Select<span class="delimiter">(</span><a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transform.qual">qual</a>, <a title="TypeMaps.this.Name" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transform.name">name</a><span class="delimiter">)</span> =&gt;
            <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transformIfMapped" title="(tree: TypeMaps.this.Tree)(trans: TypeMaps.this.Symbol =&gt; TypeMaps.this.Tree)TypeMaps.this.Tree">transformIfMapped</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transform.sel" title="TypeMaps.this.Select">sel</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="TypeMaps.this.Symbol">toSym</span> =&gt;
              <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.strictCopy" title="=&gt; TypeMaps.this.TreeCopier">strictCopy</a>.<a href="../../api/Trees.scala.html#scala.reflect.api;Trees;TreeCopierOps.Select" title="(tree: TypeMaps.this.Tree, qualifier: TypeMaps.this.Tree, selector: TypeMaps.this.Name)TypeMaps.this.Select">Select</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transform.sel" title="TypeMaps.this.Select">sel</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transform.qual" title="TypeMaps.this.Tree">qual</a>, <span title="TypeMaps.this.Symbol">toSym</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; toSym.NameType">name</a><span class="delimiter">)</span><span class="delimiter">)</span>

          case <span title="TypeMaps.this.Tree">tree</span> =&gt; <span title="TypeMaps.this.Tree">tree</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    override def <a title="(tree: TypeMaps.this.Tree, giveup: () =&gt; Nothing)TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapOver(6a76c588ac)">mapOver</a><span class="delimiter">(</span><a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapOver(6a76c588ac).tree">tree</a>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a>, <a title="() =&gt; Nothing" id="scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapOver(6a76c588ac).giveup">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a> = <span class="delimiter">{</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols" title="SubstSymMap.this.mapTreeSymbols.type">mapTreeSymbols</a>.<a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapTreeSymbols.transform" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.mapOver(6a76c588ac).tree" title="TypeMaps.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `subst` method. */</span>
  class <a title="class SubstTypeMap extends TypeMaps.this.SubstMap[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap">SubstTypeMap</a><a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap" title="TypeMaps.this.SubstTypeMap" class="delimiter">(</a>val <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.from">from</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, val <a title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.to">to</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;SubstMap" title="TypeMaps.this.SubstMap[TypeMaps.this.Type]">SubstMap</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.from" title="List[TypeMaps.this.Symbol]">from</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.to" title="List[TypeMaps.this.Type]">to</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    protected def <a title="(fromtp: TypeMaps.this.Type, tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.toType">toType</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.toType.fromtp">fromtp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>, <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.toType.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.toType.tp" title="TypeMaps.this.Type">tp</a>

    override def <a title="(tree: TypeMaps.this.Tree, giveup: () =&gt; Nothing)TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac)">mapOver</a><span class="delimiter">(</span><a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac).tree">tree</a>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a>, <a title="() =&gt; Nothing" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac).giveup">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Nothing<span class="delimiter">)</span>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a> = <span class="delimiter">{</span>
      object <a title="trans.type" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac).trans">trans</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer" title="SubstTypeMap.this.TypeMapTransformer">TypeMapTransformer</a> <span class="delimiter">{</span>
        override def <a title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac);trans.transform">transform</a><span class="delimiter">(</span><a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac);trans.transform.tree">tree</a>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac);trans.transform.tree" title="TypeMaps.this.Tree">tree</a> match <span class="delimiter">{</span>
          case Ident<span class="delimiter">(</span><a title="TypeMaps.this.Name" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac);trans.transform.name">name</a><span class="delimiter">)</span> =&gt;
            <a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.from" title="=&gt; List[TypeMaps.this.Symbol]">from</a> <a href="../../../collection/GenSeqLike.scala.html#scala.collection;GenSeqLike.indexOf(e13e28e917)" title="(elem: TypeMaps.this.Symbol)Int">indexOf</a> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac);trans.transform.tree" title="TypeMaps.this.Tree">tree</a>.<a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; TypeMaps.this.Symbol">symbol</a> match <span class="delimiter">{</span>
              case <span title="Int(-1)">-</span><span class="int">1</span>   =&gt; super.<a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac);trans.transform.tree" title="TypeMaps.this.Tree">tree</a><span class="delimiter">)</span>
              case <a title="Int" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac);trans.transform.idx">idx</a>  =&gt;
                val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac);trans.transform.totpe">totpe</a> = <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.apply" title="(n: Int)TypeMaps.this.Type">to</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac);trans.transform.idx" title="Int">idx</a><span class="delimiter">)</span>
                if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac);trans.transform.totpe" title="TypeMaps.this.Type">totpe</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.isStable" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac);trans.transform.tree" title="TypeMaps.this.Tree">tree</a>.<a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.duplicate" title="=&gt; tree.type">duplicate</a> <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.setType" title="(tp: TypeMaps.this.Type)tree.type">setType</a> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac);trans.transform.totpe" title="TypeMaps.this.Type">totpe</a>
                else <a href="../../../Function0.scala.html#scala;Function0.apply" title="()Nothing">giveup</a><span class="delimiter">(</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          case _ =&gt;
            super.<a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap;TypeMapTransformer.transform" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac);trans.transform.tree" title="TypeMaps.this.Tree">tree</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac).trans" title="trans.type">trans</a>.<a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac);trans.transform" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.mapOver(6a76c588ac).tree" title="TypeMaps.this.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `substThis` method. */</span>
  class <a title="class SubstThisMap extends TypeMaps.this.TypeMap" id="scala.reflect.internal.tpe;TypeMaps;SubstThisMap">SubstThisMap</a><a href="#scala.reflect.internal.tpe;TypeMaps;SubstThisMap" title="TypeMaps.this.SubstThisMap" class="delimiter">(</a><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;SubstThisMap.from">from</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a>, <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstThisMap.to">to</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstThisMap.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstThisMap.apply.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;SubstThisMap.apply.tp" title="TypeMaps.this.Type">tp</a> match <span class="delimiter">{</span>
      case ThisType<span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;SubstThisMap.apply.sym">sym</a><span class="delimiter">)</span> if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstThisMap.apply.sym" title="TypeMaps.this.Symbol">sym</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstThisMap.from" title="TypeMaps.this.Symbol">from</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;SubstThisMap.to" title="TypeMaps.this.Type">to</a>
      case _ =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstThisMap.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  class <a title="class SubstWildcardMap extends TypeMaps.this.TypeMap" id="scala.reflect.internal.tpe;TypeMaps;SubstWildcardMap">SubstWildcardMap</a><a href="#scala.reflect.internal.tpe;TypeMaps;SubstWildcardMap" title="TypeMaps.this.SubstWildcardMap" class="delimiter">(</a><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;SubstWildcardMap.from">from</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstWildcardMap.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;SubstWildcardMap.apply.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = try <span class="delimiter">{</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;SubstWildcardMap.apply.tp" title="TypeMaps.this.Type">tp</a> match <span class="delimiter">{</span>
        case TypeRef<span class="delimiter">(</span>_, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;SubstWildcardMap.apply.sym">sym</a>, _<span class="delimiter">)</span> if <a href="#scala.reflect.internal.tpe;TypeMaps;SubstWildcardMap.from" title="List[TypeMaps.this.Symbol]">from</a> <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: TypeMaps.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal.tpe;TypeMaps;SubstWildcardMap.apply.sym" title="TypeMaps.this.Symbol">sym</a> =&gt;
          <a href="../Types.scala.html#scala.reflect.internal;Types;BoundedWildcardType" title="(bounds: TypeMaps.this.TypeBounds)TypeMaps.this.BoundedWildcardType">BoundedWildcardType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstWildcardMap.apply.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; TypeMaps.this.Type">info</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.bounds" title="=&gt; TypeMaps.this.TypeBounds">bounds</a><span class="delimiter">)</span>
        case _ =&gt;
          <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;SubstWildcardMap.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> catch <span class="delimiter">{</span>
      case <a title="TypeMaps.this.MalformedType" id="scala.reflect.internal.tpe;TypeMaps;SubstWildcardMap.apply.ex">ex</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;MalformedType" title="TypeMaps.this.MalformedType">MalformedType</a> =&gt;
        <a href="../Types.scala.html#scala.reflect.internal;Types.WildcardType" title="TypeMaps.this.WildcardType.type">WildcardType</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">// dependent method types</span>
  object <a title="TypeMaps.this.IsDependentCollector.type" id="scala.reflect.internal.tpe;TypeMaps.IsDependentCollector">IsDependentCollector</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector" title="TypeMaps.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span>false<span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)Unit" id="scala.reflect.internal.tpe;TypeMaps.IsDependentCollector.traverse">traverse</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.IsDependentCollector.traverse.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.IsDependentCollector.traverse.tp" title="TypeMaps.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.isImmediatelyDependent" title="=&gt; Boolean">isImmediatelyDependent</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=" title="(x$1: Boolean)Unit">result</a> = true
      else if <span class="delimiter">(</span><a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.IsDependentCollector.traverse.tp" title="TypeMaps.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.dealias" title="=&gt; TypeMaps.this.Type">dealias</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  object <a title="TypeMaps.this.ApproximateDependentMap.type" id="scala.reflect.internal.tpe;TypeMaps.ApproximateDependentMap">ApproximateDependentMap</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.ApproximateDependentMap.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.ApproximateDependentMap.apply.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.ApproximateDependentMap.apply.tp" title="TypeMaps.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.isImmediatelyDependent" title="=&gt; Boolean">isImmediatelyDependent</a><span class="delimiter">)</span> <a href="../Types.scala.html#scala.reflect.internal;Types.WildcardType" title="TypeMaps.this.WildcardType.type">WildcardType</a>
      else <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.ApproximateDependentMap.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Note: This map is needed even for non-dependent method types, despite what the name might imply.
    */</span>
  class <a title="class InstantiateDependentMap extends TypeMaps.this.TypeMap with TypeMaps.this.KeepOnlyTypeConstraints" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap">InstantiateDependentMap</a><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap" title="TypeMaps.this.InstantiateDependentMap" class="delimiter">(</a><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.params">params</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.actuals0">actuals0</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> with <a href="#scala.reflect.internal.tpe;TypeMaps;KeepOnlyTypeConstraints" title="TypeMaps.this.KeepOnlyTypeConstraints">KeepOnlyTypeConstraints</a> <span class="delimiter">{</span>
    private val <a title="scala.collection.immutable.IndexedSeq[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.actuals">actuals</a>      = <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.actuals0" title="List[TypeMaps.this.Type]">actuals0</a>.<a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toIndexedSeq" title="=&gt; scala.collection.immutable.IndexedSeq[TypeMaps.this.Type]">toIndexedSeq</a>
    private val <a title="Array[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentials">existentials</a> = new <a href="../../../Array.scala.html#scala;Array" title="Array[TypeMaps.this.Symbol]">Array</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.actuals" title="=&gt; scala.collection.immutable.IndexedSeq[TypeMaps.this.Type]">actuals</a>.<a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.size" title="=&gt; Int">size</a><span class="delimiter">)</span>
    def <a title="=&gt; List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialsNeeded">existentialsNeeded</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeMaps.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="../../../Predef.scala.html#scala.Predef.refArrayOps" title="(xs: Array[TypeMaps.this.Symbol])scala.collection.mutable.ArrayOps[TypeMaps.this.Symbol]">existentials</a>.<a href="../../../collection/IndexedSeqLike.scala.html#scala.collection;IndexedSeqLike.iterator" title="=&gt; Iterator[TypeMaps.this.Symbol]">iterator</a>.<a href="../../../collection/Iterator.scala.html#scala.collection;Iterator.filter" title="(p: TypeMaps.this.Symbol =&gt; Boolean)Iterator[TypeMaps.this.Symbol]">filter</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialsNeeded.$anonfun.x$13" title="TypeMaps.this.Symbol">_</a> <span title="(x$1: AnyRef)Boolean">ne</span> null<span class="delimiter">)</span>.<a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[TypeMaps.this.Symbol]">toList</a>

    private object <a title="InstantiateDependentMap.this.StableArgTp.type" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StableArgTp">StableArgTp</a> <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StableArgTp" title="InstantiateDependentMap.this.StableArgTp.type" class="delimiter">{</a>
      <span class="comment">// type of actual arg corresponding to param -- if the type is stable</span>
      def <a title="(param: TypeMaps.this.Symbol)Option[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StableArgTp.unapply">unapply</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StableArgTp.unapply.param">param</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#scala;Option" title="Option[TypeMaps.this.Type]">Option</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.params" title="List[TypeMaps.this.Symbol]">params</a> <a href="../../../collection/GenSeqLike.scala.html#scala.collection;GenSeqLike.indexOf(e13e28e917)" title="(elem: TypeMaps.this.Symbol)Int">indexOf</a> <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StableArgTp.unapply.param" title="TypeMaps.this.Symbol">param</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case <span title="Int(-1)">-</span><span class="int">1</span>  =&gt; <a href="../../../Option.scala.html#scala.None" title="None.type">None</a>
        case <a title="Int" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StableArgTp.unapply.pid">pid</a> =&gt;
          val <a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StableArgTp.unapply.tp">tp</a> = <a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.apply" title="(idx: Int)TypeMaps.this.Type">actuals</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StableArgTp.unapply.pid" title="Int">pid</a><span class="delimiter">)</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StableArgTp.unapply.tp" title="TypeMaps.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.isStable" title="=&gt; Boolean">isStable</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StableArgTp.unapply.tp" title="TypeMaps.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; TypeMaps.this.Symbol">typeSymbol</a> <span title="(x$1: Any)Boolean">!=</span> <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.NothingClass" title="TypeMaps.this.definitions.NothingClass.type">NothingClass</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../Option.scala.html#scala;Some" title="(x: TypeMaps.this.Type)Some[TypeMaps.this.Type]">Some</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StableArgTp.unapply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
          else <a href="../../../Option.scala.html#scala.None" title="None.type">None</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Return the type symbol for referencing a parameter that's instantiated to an unstable actual argument.
     *
     * To soundly abstract over an unstable value (x: T) while retaining the most type information,
     * use `x.type forSome { type x.type &lt;: T with Singleton}`
     * `typeOf[T].narrowExistentially(symbolOf[x])`.
     *
     * See also: captureThis in AsSeenFromMap.
     */</span>
    private def <a title="(pid: Int)TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialFor">existentialFor</a><span class="delimiter">(</span><a title="Int" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialFor.pid">pid</a>: <a href="../../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="../../../Array.scala.html#scala;Array.apply" title="(i: Int)TypeMaps.this.Symbol">existentials</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialFor.pid" title="Int">pid</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialFor.param">param</a> = <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.apply" title="(n: Int)TypeMaps.this.Symbol">params</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialFor.pid" title="Int">pid</a><span class="delimiter">)</span>
        <a href="../../../Array.scala.html#scala;Array.update" title="(i: Int, x: TypeMaps.this.Symbol)Unit">existentials</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialFor.pid" title="Int">pid</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialFor.param" title="TypeMaps.this.Symbol">param</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.newExistential" title="(name: TypeMaps.this.TypeName, pos: TypeMaps.this.Position, newFlags: Long)TypeMaps.this.TypeSymbol">newExistential</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialFor.param" title="TypeMaps.this.Symbol">param</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; param.NameType">name</a>.<a href="../Names.scala.html#scala.reflect.internal;Names;Name.toTypeName" title="=&gt; TypeMaps.this.TypeName">toTypeName</a> <a href="../Names.scala.html#scala.reflect.internal;Names;Name.append(b90d33c7e8)" title="(suffix: String)TypeMaps.this.Name with TypeMaps.this.TypeName">append</a> <a href="../StdNames.scala.html#scala.reflect.internal;StdNames.nme" title="TypeMaps.this.nme.type">nme</a>.<a href="../StdNames.scala.html#scala.reflect.internal;StdNames;CommonNames.SINGLETON_SUFFIX" title="=&gt; String">SINGLETON_SUFFIX</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialFor.param" title="TypeMaps.this.Symbol">param</a>.<a href="../StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.pos" title="=&gt; TypeMaps.this.Position">pos</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialFor.param" title="TypeMaps.this.Symbol">param</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.flags" title="=&gt; Long">flags</a><span class="delimiter">)</span>
            <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="(info: TypeMaps.this.Type)TypeMaps.this.TypeSymbol">setInfo</a> <a href="../Types.scala.html#scala.reflect.internal;Types.singletonBounds" title="(hi: TypeMaps.this.Type)TypeMaps.this.TypeBounds">singletonBounds</a><span class="delimiter">(</span><a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.apply" title="(idx: Int)TypeMaps.this.Type">actuals</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialFor.pid" title="Int">pid</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="../../../Array.scala.html#scala;Array.apply" title="(i: Int)TypeMaps.this.Symbol">existentials</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialFor.pid" title="Int">pid</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    private object <a title="InstantiateDependentMap.this.UnstableArgTp.type" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.UnstableArgTp">UnstableArgTp</a> <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.UnstableArgTp" title="InstantiateDependentMap.this.UnstableArgTp.type" class="delimiter">{</a>
      <span class="comment">// existential quantifier and type of corresponding actual arg with unstable type</span>
      def <a title="(param: TypeMaps.this.Symbol)Option[(TypeMaps.this.Symbol, TypeMaps.this.Type)]" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.UnstableArgTp.unapply">unapply</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.UnstableArgTp.unapply.param">param</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#scala;Option" title="Option[(TypeMaps.this.Symbol, TypeMaps.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Type<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.params" title="List[TypeMaps.this.Symbol]">params</a> <a href="../../../collection/GenSeqLike.scala.html#scala.collection;GenSeqLike.indexOf(e13e28e917)" title="(elem: TypeMaps.this.Symbol)Int">indexOf</a> <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.UnstableArgTp.unapply.param" title="TypeMaps.this.Symbol">param</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case <span title="Int(-1)">-</span><span class="int">1</span>  =&gt; <a href="../../../Option.scala.html#scala.None" title="None.type">None</a>
        case <a title="Int" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.UnstableArgTp.unapply.pid">pid</a> =&gt;
          val <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.UnstableArgTp.unapply.sym">sym</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialFor" title="(pid: Int)TypeMaps.this.Symbol">existentialFor</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.UnstableArgTp.unapply.pid" title="Int">pid</a><span class="delimiter">)</span>
          <a href="../../../Option.scala.html#scala;Some" title="(x: (TypeMaps.this.Symbol, TypeMaps.this.Type))Some[(TypeMaps.this.Symbol, TypeMaps.this.Type)]">Some</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#scala;Tuple2" title="(_1: TypeMaps.this.Symbol, _2: TypeMaps.this.Type)(TypeMaps.this.Symbol, TypeMaps.this.Type)" class="delimiter">(</a><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.UnstableArgTp.unapply.sym" title="TypeMaps.this.Symbol">sym</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.UnstableArgTp.unapply.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe_*" title="=&gt; TypeMaps.this.Type">tpe_*</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// refers to an actual value, must be kind-*</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    private object <a title="InstantiateDependentMap.this.StabilizedArgTp.type" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StabilizedArgTp">StabilizedArgTp</a> <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StabilizedArgTp" title="InstantiateDependentMap.this.StabilizedArgTp.type" class="delimiter">{</a>
      def <a title="(param: TypeMaps.this.Symbol)Option[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StabilizedArgTp.unapply">unapply</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StabilizedArgTp.unapply.param">param</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#scala;Option" title="Option[TypeMaps.this.Type]">Option</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> =
        <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StabilizedArgTp.unapply.param" title="TypeMaps.this.Symbol">param</a> match <span class="delimiter">{</span>
          case <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StableArgTp.unapply" title="(param: TypeMaps.this.Symbol)Option[TypeMaps.this.Type]">StableArgTp</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp</span><span class="delimiter">)</span>      =&gt; <a href="../../../Option.scala.html#scala;Some" title="(x: TypeMaps.this.Type)Some[TypeMaps.this.Type]">Some</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp</span><span class="delimiter">)</span>  <span class="comment">// (1)</span>
          case <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.UnstableArgTp.unapply" title="(param: TypeMaps.this.Symbol)Option[(TypeMaps.this.Symbol, TypeMaps.this.Type)]">UnstableArgTp</a><span class="delimiter">(</span>_, <span title="TypeMaps.this.Type">tp</span><span class="delimiter">)</span> =&gt; <a href="../../../Option.scala.html#scala;Some" title="(x: TypeMaps.this.Type)Some[TypeMaps.this.Type]">Some</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp</span><span class="delimiter">)</span>  <span class="comment">// (2)</span>
          case _ =&gt; <a href="../../../Option.scala.html#scala.None" title="None.type">None</a>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** instantiate `param.type` to the (sound approximation of the) type `T`
     * of the actual argument `arg` that was passed in for `param`
     *
     * (1) If `T` is stable, we can just use that.
     *
     * (2) SI-3873: it'd be unsound to instantiate `param.type` to an unstable `T`,
     * so we approximate to `X forSome {type X &lt;: T with Singleton}` -- we can't soundly say more.
     */</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.apply">apply</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <span title="TypeMaps.this.Type">tp</span> match <span class="delimiter">{</span>
      case SingleType<span class="delimiter">(</span><a href="../Types.scala.html#scala.reflect.internal;Types.NoPrefix" title="TypeMaps.this.NoPrefix.type">NoPrefix</a>, <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StabilizedArgTp.unapply" title="(param: TypeMaps.this.Symbol)Option[TypeMaps.this.Type]">StabilizedArgTp</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="TypeMaps.this.Type">tp</span>
      case _                                         =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">//AM propagate more info to annotations -- this seems a bit ad-hoc... (based on code by spoon)</span>
    override def <a title="(arg: TypeMaps.this.Tree, giveup: () =&gt; Nothing)TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99)">mapOver</a><span class="delimiter">(</span><a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99).arg">arg</a>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a>, <a title="() =&gt; Nothing" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99).giveup">giveup</a>: <span class="delimiter">(</span><span class="delimiter">)</span>=&gt;Nothing<span class="delimiter">)</span>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a> = <span class="delimiter">{</span>
      <span class="comment">// TODO: this should be simplified; in the stable case, one can</span>
      <span class="comment">// probably just use an Ident to the tree.symbol.</span>
      <span class="comment">//</span>
      <span class="comment">// @PP: That leads to failure here, where stuff no longer has type</span>
      <span class="comment">// 'String @Annot(&quot;stuff&quot;)' but 'String @Annot(x)'.</span>
      <span class="comment">//</span>
      <span class="comment">//   def m(x: String): String @Annot(x) = x</span>
      <span class="comment">//   val stuff = m(&quot;stuff&quot;)</span>
      <span class="comment">//</span>
      <span class="comment">// (TODO cont.) Why an existential in the non-stable case?</span>
      <span class="comment">//</span>
      <span class="comment">// @PP: In the following:</span>
      <span class="comment">//</span>
      <span class="comment">//   def m = { val x = &quot;three&quot; ; val y: String @Annot(x) = x; y }</span>
      <span class="comment">//</span>
      <span class="comment">// m is typed as 'String @Annot(x) forSome { val x: String }'.</span>
      <span class="comment">//</span>
      <span class="comment">// Both examples are from run/constrained-types.scala.</span>
      object <a title="treeTrans.type" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99).treeTrans">treeTrans</a> extends <a href="../../api/Trees.scala.html#scala.reflect.api;Trees;Transformer" title="TypeMaps.this.Transformer">Transformer</a> <span class="delimiter">{</span>
        override def <a title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99);treeTrans.transform">transform</a><span class="delimiter">(</span><a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99);treeTrans.transform.tree">tree</a>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a> = <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99);treeTrans.transform.tree" title="TypeMaps.this.Tree">tree</a>.<a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; TypeMaps.this.Symbol">symbol</a> match <span class="delimiter">{</span>
          case <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.StableArgTp.unapply" title="(param: TypeMaps.this.Symbol)Option[TypeMaps.this.Type]">StableArgTp</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp</span><span class="delimiter">)</span>          =&gt; <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.gen" title="=&gt; scala.reflect.internal.TreeGen{val global: TypeMaps.this.type}">gen</a>.<a href="../TreeGen.scala.html#scala.reflect.internal;TreeGen.mkAttributedQualifier(63a1718c8b)" title="(tpe: TypeMaps.this.gen.global.Type, termSym: TypeMaps.this.gen.global.Symbol)TypeMaps.this.gen.global.Tree">mkAttributedQualifier</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">tp</span>, <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99);treeTrans.transform.tree" title="TypeMaps.this.Tree">tree</a>.<a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; TypeMaps.this.Symbol">symbol</a><span class="delimiter">)</span>
          case <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.UnstableArgTp.unapply" title="(param: TypeMaps.this.Symbol)Option[(TypeMaps.this.Symbol, TypeMaps.this.Type)]">UnstableArgTp</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99);treeTrans.transform.quant">quant</a>, <span title="TypeMaps.this.Type">tp</span><span class="delimiter">)</span> =&gt; <a href="../Trees.scala.html#scala.reflect.internal;Trees.Ident(e8c336bf3b)" title="(sym: TypeMaps.this.Symbol)TypeMaps.this.Ident">Ident</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99);treeTrans.transform.quant" title="TypeMaps.this.Symbol">quant</a><span class="delimiter">)</span> <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.copyAttrs" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Ident">copyAttrs</a> <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99);treeTrans.transform.tree" title="TypeMaps.this.Tree">tree</a> <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.setType" title="(tp: TypeMaps.this.Type)TypeMaps.this.Ident">setType</a> <span title="TypeMaps.this.Type">tp</span>
          case _                        =&gt; super.<a href="../../api/Trees.scala.html#scala.reflect.api;Trees;Transformer.transform" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99);treeTrans.transform.tree" title="TypeMaps.this.Tree">tree</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99).treeTrans" title="treeTrans.type">treeTrans</a> <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99);treeTrans.transform" title="(tree: TypeMaps.this.Tree)TypeMaps.this.Tree">transform</a> <a href="#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.mapOver(2650936c99).arg" title="TypeMaps.this.Tree">arg</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to convert every occurrence of a wildcard type to a fresh
    *  type variable */</span>
  object <a title="TypeMaps.this.wildcardToTypeVarMap.type" id="scala.reflect.internal.tpe;TypeMaps.wildcardToTypeVarMap">wildcardToTypeVarMap</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.wildcardToTypeVarMap.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.wildcardToTypeVarMap.apply.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <a href="#scala.reflect.internal.tpe;TypeMaps.wildcardToTypeVarMap.apply.tp" title="TypeMaps.this.Type">tp</a> match <span class="delimiter">{</span>
      case <a href="../Types.scala.html#scala.reflect.internal;Types.WildcardType" title="TypeMaps.this.WildcardType.type">WildcardType</a> =&gt;
        <a href="../Types.scala.html#scala.reflect.internal;Types.TypeVar.apply(cf74f7f79a)" title="(origin: TypeMaps.this.Type, constr: TypeMaps.this.TypeConstraint)TypeMaps.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.wildcardToTypeVarMap.apply.tp" title="TypeMaps.this.Type">tp</a>, new <a href="TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint" title="TypeMaps.this.TypeConstraint">TypeConstraint</a><span class="delimiter">)</span>
      case BoundedWildcardType<span class="delimiter">(</span><a title="TypeMaps.this.TypeBounds" id="scala.reflect.internal.tpe;TypeMaps.wildcardToTypeVarMap.apply.bounds">bounds</a><span class="delimiter">)</span> =&gt;
        <a href="../Types.scala.html#scala.reflect.internal;Types.TypeVar.apply(cf74f7f79a)" title="(origin: TypeMaps.this.Type, constr: TypeMaps.this.TypeConstraint)TypeMaps.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.wildcardToTypeVarMap.apply.tp" title="TypeMaps.this.Type">tp</a>, new <a href="TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint" title="TypeMaps.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.wildcardToTypeVarMap.apply.bounds" title="TypeMaps.this.TypeBounds">bounds</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case _ =&gt;
        <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.wildcardToTypeVarMap.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to convert each occurrence of a type variable to its origin. */</span>
  object <a title="TypeMaps.this.typeVarToOriginMap.type" id="scala.reflect.internal.tpe;TypeMaps.typeVarToOriginMap">typeVarToOriginMap</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.typeVarToOriginMap.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.typeVarToOriginMap.apply.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <a href="#scala.reflect.internal.tpe;TypeMaps.typeVarToOriginMap.apply.tp" title="TypeMaps.this.Type">tp</a> match <span class="delimiter">{</span>
      case TypeVar<span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.typeVarToOriginMap.apply.origin">origin</a>, _<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps.typeVarToOriginMap.apply.origin" title="TypeMaps.this.Type">origin</a>
      case _ =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.typeVarToOriginMap.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `contains` method. */</span>
  class <a title="class ContainsCollector extends TypeMaps.this.TypeCollector[Boolean]" id="scala.reflect.internal.tpe;TypeMaps;ContainsCollector">ContainsCollector</a><a href="#scala.reflect.internal.tpe;TypeMaps;ContainsCollector" title="TypeMaps.this.ContainsCollector" class="delimiter">(</a><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps;ContainsCollector.sym">sym</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector" title="TypeMaps.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span>false<span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)Unit" id="scala.reflect.internal.tpe;TypeMaps;ContainsCollector.traverse">traverse</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;ContainsCollector.traverse.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal.tpe;TypeMaps;ContainsCollector.traverse.tp" title="TypeMaps.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.normalize" title="=&gt; TypeMaps.this.Type">normalize</a> match <span class="delimiter">{</span>
          case TypeRef<span class="delimiter">(</span>_, <span title="TypeMaps.this.Symbol">sym1</span>, _<span class="delimiter">)</span> if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ContainsCollector.sym" title="TypeMaps.this.Symbol">sym</a> <span title="(x$1: Any)Boolean">==</span> <span title="TypeMaps.this.Symbol">sym1</span><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=" title="(x$1: Boolean)Unit">result</a> = true
          case SingleType<span class="delimiter">(</span>_, <span title="TypeMaps.this.Symbol">sym1</span><span class="delimiter">)</span> if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ContainsCollector.sym" title="TypeMaps.this.Symbol">sym</a> <span title="(x$1: Any)Boolean">==</span> <span title="TypeMaps.this.Symbol">sym1</span><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=" title="(x$1: Boolean)Unit">result</a> = true
          case _ =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ContainsCollector.traverse.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    override def <a title="(arg: TypeMaps.this.Tree)TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;ContainsCollector.mapOver(d2e20c1515)">mapOver</a><span class="delimiter">(</span><a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;ContainsCollector.mapOver(d2e20c1515).arg">arg</a>: <a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TypeMaps.this.Tree">Tree</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      for <span class="delimiter">(</span><a title="TypeMaps.this.Tree" id="scala.reflect.internal.tpe;TypeMaps;ContainsCollector.mapOver(d2e20c1515).$anonfun.t">t</a> &lt;- <a href="../Trees.scala.html#scala.reflect.internal;Trees;TreeContextApiImpl.foreach" title="(f: TypeMaps.this.Tree =&gt; Unit)Unit">arg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal.tpe;TypeMaps;ContainsCollector.traverse" title="(tp: TypeMaps.this.Type)Unit">traverse</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ContainsCollector.mapOver(d2e20c1515).$anonfun.t" title="TypeMaps.this.Tree">t</a>.<a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; TypeMaps.this.Type">tpe</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ContainsCollector.mapOver(d2e20c1515).$anonfun.t" title="TypeMaps.this.Tree">t</a>.<a href="../Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; TypeMaps.this.Symbol">symbol</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal.tpe;TypeMaps;ContainsCollector.sym" title="TypeMaps.this.Symbol">sym</a><span class="delimiter">)</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=" title="(x$1: Boolean)Unit">result</a> = true
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;ContainsCollector.mapOver(d2e20c1515).arg" title="TypeMaps.this.Tree">arg</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `filter` method. */</span>
  class <a title="class FilterTypeCollector extends TypeMaps.this.TypeCollector[List[TypeMaps.this.Type]]" id="scala.reflect.internal.tpe;TypeMaps;FilterTypeCollector">FilterTypeCollector</a><a href="#scala.reflect.internal.tpe;TypeMaps;FilterTypeCollector" title="TypeMaps.this.FilterTypeCollector" class="delimiter">(</a><a title="TypeMaps.this.Type =&gt; Boolean" id="scala.reflect.internal.tpe;TypeMaps;FilterTypeCollector.p">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector" title="TypeMaps.this.TypeCollector[List[TypeMaps.this.Type]]">TypeCollector</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    override def <a title="(tp: TypeMaps.this.Type)List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps;FilterTypeCollector.collect">collect</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;FilterTypeCollector.collect.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span> = super.<a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.collect" title="(tp: TypeMaps.this.Type)List[TypeMaps.this.Type]">collect</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;FilterTypeCollector.collect.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>.<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.reverse" title="=&gt; List[TypeMaps.this.Type]">reverse</a>

    def <a title="(tp: TypeMaps.this.Type)Unit" id="scala.reflect.internal.tpe;TypeMaps;FilterTypeCollector.traverse">traverse</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;FilterTypeCollector.traverse.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: TypeMaps.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;FilterTypeCollector.traverse.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=" title="(x$1: List[TypeMaps.this.Type])Unit">result</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: TypeMaps.this.Type)List[TypeMaps.this.Type]">::=</a> <a href="#scala.reflect.internal.tpe;TypeMaps;FilterTypeCollector.traverse.tp" title="TypeMaps.this.Type">tp</a>
      <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;FilterTypeCollector.traverse.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `collect` method. */</span>
  class <a title="class CollectTypeCollector[T] extends TypeMaps.this.TypeCollector[List[T]]" id="scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector">CollectTypeCollector</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector;T">T</a><span class="delimiter">]</span><a href="#scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector" title="TypeMaps.this.CollectTypeCollector[T]" class="delimiter">(</a><a title="PartialFunction[TypeMaps.this.Type,T]" id="scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector.pf">pf</a>: <a href="../../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[TypeMaps.this.Type,T]">PartialFunction</a><span class="delimiter">[</span>Type, T<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector" title="TypeMaps.this.TypeCollector[List[T]]">TypeCollector</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    override def <a title="(tp: TypeMaps.this.Type)List[T]" id="scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector.collect">collect</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector.collect.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span> = super.<a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.collect" title="(tp: TypeMaps.this.Type)List[T]">collect</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector.collect.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>.<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.reverse" title="=&gt; List[T]">reverse</a>

    def <a title="(tp: TypeMaps.this.Type)Unit" id="scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector.traverse">traverse</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector.traverse.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector.pf" title="PartialFunction[TypeMaps.this.Type,T]">pf</a>.<a href="../../../PartialFunction.scala.html#scala;PartialFunction.isDefinedAt" title="(x: TypeMaps.this.Type)Boolean">isDefinedAt</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector.traverse.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=" title="(x$1: List[T])Unit">result</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: T)List[T]">::=</a> <a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: TypeMaps.this.Type)T">pf</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector.traverse.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector.traverse.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  class <a title="class ForEachTypeTraverser extends TypeMaps.this.TypeTraverser" id="scala.reflect.internal.tpe;TypeMaps;ForEachTypeTraverser">ForEachTypeTraverser</a><a href="#scala.reflect.internal.tpe;TypeMaps;ForEachTypeTraverser" title="TypeMaps.this.ForEachTypeTraverser" class="delimiter">(</a><a title="TypeMaps.this.Type =&gt; Unit" id="scala.reflect.internal.tpe;TypeMaps;ForEachTypeTraverser.f">f</a>: Type =&gt; Unit<span class="delimiter">)</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeTraverser" title="TypeMaps.this.TypeTraverser">TypeTraverser</a> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)Unit" id="scala.reflect.internal.tpe;TypeMaps;ForEachTypeTraverser.traverse">traverse</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;ForEachTypeTraverser.traverse.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: TypeMaps.this.Type)Unit">f</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ForEachTypeTraverser.traverse.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;ForEachTypeTraverser.traverse.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `filter` method. */</span>
  class <a title="class FindTypeCollector extends TypeMaps.this.TypeCollector[Option[TypeMaps.this.Type]]" id="scala.reflect.internal.tpe;TypeMaps;FindTypeCollector">FindTypeCollector</a><a href="#scala.reflect.internal.tpe;TypeMaps;FindTypeCollector" title="TypeMaps.this.FindTypeCollector" class="delimiter">(</a><a title="TypeMaps.this.Type =&gt; Boolean" id="scala.reflect.internal.tpe;TypeMaps;FindTypeCollector.p">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector" title="TypeMaps.this.TypeCollector[Option[TypeMaps.this.Type]]">TypeCollector</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="../../../Option.scala.html#scala.None" title="None.type">None</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)Unit" id="scala.reflect.internal.tpe;TypeMaps;FindTypeCollector.traverse">traverse</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps;FindTypeCollector.traverse.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=" title="=&gt; Option[TypeMaps.this.Type]">result</a>.<a href="../../../Option.scala.html#scala;Option.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: TypeMaps.this.Type)Boolean">p</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;FindTypeCollector.traverse.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=" title="(x$1: Option[TypeMaps.this.Type])Unit">result</a> = <a href="../../../Option.scala.html#scala;Some" title="(x: TypeMaps.this.Type)Some[TypeMaps.this.Type]">Some</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;FindTypeCollector.traverse.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps;FindTypeCollector.traverse.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A map to implement the `contains` method. */</span>
  object <a title="TypeMaps.this.ErroneousCollector.type" id="scala.reflect.internal.tpe;TypeMaps.ErroneousCollector">ErroneousCollector</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector" title="TypeMaps.this.TypeCollector[Boolean]">TypeCollector</a><span class="delimiter">(</span>false<span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="(tp: TypeMaps.this.Type)Unit" id="scala.reflect.internal.tpe;TypeMaps.ErroneousCollector.traverse">traverse</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.ErroneousCollector.traverse.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=" title="=&gt; Boolean">result</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal.tpe;TypeMaps;TypeCollector.result_=" title="(x$1: Boolean)Unit">result</a> = <a href="#scala.reflect.internal.tpe;TypeMaps.ErroneousCollector.traverse.tp" title="TypeMaps.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.isError" title="=&gt; Boolean">isError</a>
        <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span title="Unit" class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.ErroneousCollector.traverse.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  object <a title="TypeMaps.this.adaptToNewRunMap.type" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap">adaptToNewRunMap</a> extends <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="TypeMaps.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>

    private def <a title="(pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol)TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun">adaptToNewRun</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.pre">pre</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym">sym</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="../Phase.scala.html#scala.reflect.internal;Phase.flatClasses" title="=&gt; Boolean">flatClasses</a> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isRootSymbol" title="=&gt; Boolean">isRootSymbol</a> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.pre" title="TypeMaps.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoPrefix" title="TypeMaps.this.NoPrefix.type">NoPrefix</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.pre" title="TypeMaps.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeMaps.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModuleClass" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sourceModule1">sourceModule1</a> = <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun" title="(pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol)TypeMaps.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.pre" title="TypeMaps.this.Type">pre</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.sourceModule" title="=&gt; TypeMaps.this.Symbol">sourceModule</a><span class="delimiter">)</span>

        <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sourceModule1" title="TypeMaps.this.Symbol">sourceModule1</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.moduleClass" title="=&gt; TypeMaps.this.Symbol">moduleClass</a> <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.orElse" title="(alt: =&gt; TypeMaps.this.Symbol)TypeMaps.this.Symbol">orElse</a> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sourceModule1" title="TypeMaps.this.Symbol">sourceModule1</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.initialize" title="=&gt; sourceModule1.type">initialize</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.moduleClass" title="=&gt; TypeMaps.this.Symbol">moduleClass</a> <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.orElse" title="(alt: =&gt; TypeMaps.this.Symbol)TypeMaps.this.Symbol">orElse</a> <span class="delimiter">{</span>
          val <a title="String" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.msg">msg</a> = <span title="String(&quot;Cannot adapt module class; sym = %s, sourceModule = %s, sourceModule.moduleClass = %s =&gt; sourceModule1 = %s, sourceModule1.moduleClass = %s&quot;)" class="string">&quot;Cannot adapt module class; sym = %s, sourceModule = %s, sourceModule.moduleClass = %s =&gt; sourceModule1 = %s, sourceModule1.moduleClass = %s&quot;</span>
          <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">msg</a>.<a href="../../../collection/immutable/StringLike.scala.html#scala.collection.immutable;StringLike.format" title="(args: Any*)String">format</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.sourceModule" title="=&gt; TypeMaps.this.Symbol">sourceModule</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.sourceModule" title="=&gt; TypeMaps.this.Symbol">sourceModule</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.moduleClass" title="=&gt; TypeMaps.this.Symbol">moduleClass</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sourceModule1" title="TypeMaps.this.Symbol">sourceModule1</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sourceModule1" title="TypeMaps.this.Symbol">sourceModule1</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.moduleClass" title="=&gt; TypeMaps.this.Symbol">moduleClass</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      else <span class="delimiter">{</span>
        var rebind0 = <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.pre" title="TypeMaps.this.Type">pre</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.findMember" title="(name: TypeMaps.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)TypeMaps.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym.NameType">name</a>, <span title="Long(67108864L)">BRIDGE</span>, <span title="Long(0L)" class="int">0</span>, stableOnly = true<span class="delimiter">)</span> <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.orElse" title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.rebind0">orElse</a> <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAliasType" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span> throw <a href="../Types.scala.html#scala.reflect.internal;Types.missingAliasException" title="=&gt; TypeMaps.this.MissingAliasControl">missingAliasException</a>
          <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.devWarning" title="(msg: =&gt; String)Unit">devWarning</a><span class="delimiter">(</span><a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.pre" title="TypeMaps.this.Type">pre</a><span title="String(&quot;.&quot;)">.$</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a><span title="String(&quot; no longer exist at phase &quot;)"> no longer exist at phase $</span><a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
          throw new <a href="../Types.scala.html#scala.reflect.internal;Types;MissingTypeControl" title="TypeMaps.this.MissingTypeControl">MissingTypeControl</a> <span class="comment">// For build manager and presentation compiler purposes</span>
        <span class="delimiter">}</span>
        <span class="comment">/* The two symbols have the same fully qualified name */</span>
        def <a title="(sym1: TypeMaps.this.Symbol, sym2: TypeMaps.this.Symbol)Boolean" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.corresponds">corresponds</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.corresponds.sym1">sym1</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.corresponds.sym2">sym2</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeMaps.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> =
          <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.corresponds.sym1" title="TypeMaps.this.Symbol">sym1</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym1.NameType">name</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.corresponds.sym2" title="TypeMaps.this.Symbol">sym2</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym2.NameType">name</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.corresponds.sym1" title="TypeMaps.this.Symbol">sym1</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.corresponds" title="(sym1: TypeMaps.this.Symbol, sym2: TypeMaps.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.corresponds.sym1" title="TypeMaps.this.Symbol">sym1</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.corresponds.sym2" title="TypeMaps.this.Symbol">sym2</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.corresponds" title="(sym1: TypeMaps.this.Symbol, sym2: TypeMaps.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.rebind0" title="TypeMaps.this.Symbol">rebind0</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><span title="String(&quot;ADAPT1 pre = &quot;)" class="string">&quot;ADAPT1 pre = &quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.pre" title="TypeMaps.this.Type">pre</a><span title="(x$1: Any)String">+</span><span title="String(&quot;, sym = &quot;)" class="string">&quot;, sym = &quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.fullLocationString" title="=&gt; String">fullLocationString</a><span title="(x$1: Any)String">+</span><span title="String(&quot;, rebind = &quot;)" class="string">&quot;, rebind = &quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.rebind0" title="TypeMaps.this.Symbol">rebind0</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.fullLocationString" title="=&gt; String">fullLocationString</a><span class="delimiter">)</span>
          val <a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.bcs">bcs</a> = <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.pre" title="TypeMaps.this.Type">pre</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.baseClasses" title="=&gt; List[TypeMaps.this.Symbol]">baseClasses</a>.<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.dropWhile" title="(p: TypeMaps.this.Symbol =&gt; Boolean)List[TypeMaps.this.Symbol]">dropWhile</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.bcs.$anonfun.bc">bc</a> =&gt; <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.corresponds" title="(sym1: TypeMaps.this.Symbol, sym2: TypeMaps.this.Symbol)Boolean">corresponds</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.bcs.$anonfun.bc" title="TypeMaps.this.Symbol">bc</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.bcs" title="List[TypeMaps.this.Symbol]">bcs</a>.<a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
            <a href="../../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.pre" title="TypeMaps.this.Type">pre</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; TypeMaps.this.Symbol">typeSymbol</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isRefinementClass" title="=&gt; Boolean">isRefinementClass</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.pre" title="TypeMaps.this.Type">pre</a><span class="delimiter">)</span> <span class="comment">// if pre is a refinementclass it might be a structural type =&gt; OK to leave it in.</span>
          else
            <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.rebind0" title="TypeMaps.this.Symbol">rebind0</a> = <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.pre" title="TypeMaps.this.Type">pre</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.baseType" title="(clazz: TypeMaps.this.Symbol)TypeMaps.this.Type">baseType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.bcs" title="List[TypeMaps.this.Symbol]">bcs</a>.<a href="../../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; TypeMaps.this.Symbol">head</a><span class="delimiter">)</span>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.member" title="(name: TypeMaps.this.Name)TypeMaps.this.Symbol">member</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym.NameType">name</a><span class="delimiter">)</span>
          <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span>
            <span title="String(&quot;ADAPT2 pre = &quot;)" class="string">&quot;ADAPT2 pre = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.pre" title="TypeMaps.this.Type">pre</a> <span title="(x$1: Any)String">+</span>
              <span title="String(&quot;, bcs.head = &quot;)" class="string">&quot;, bcs.head = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.bcs" title="List[TypeMaps.this.Symbol]">bcs</a>.<a href="../../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; TypeMaps.this.Symbol">head</a> <span title="(x$1: Any)String">+</span>
              <span title="String(&quot;, sym = &quot;)" class="string">&quot;, sym = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.fullLocationString" title="=&gt; String">fullLocationString</a> <span title="(x$1: Any)String">+</span>
              <span title="String(&quot;, rebind = &quot;)" class="string">&quot;, rebind = &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.rebind0" title="TypeMaps.this.Symbol">rebind0</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.fullLocationString" title="=&gt; String">fullLocationString</a>
          <span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.rebind0" title="TypeMaps.this.Symbol">rebind0</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.suchThat" title="(cond: TypeMaps.this.Symbol =&gt; Boolean)TypeMaps.this.Symbol">suchThat</a><span class="delimiter">(</span><a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.$anonfun.sym">sym</a> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.$anonfun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isType" title="=&gt; Boolean">isType</a> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.$anonfun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isStable" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.orElse" title="(alt: =&gt; TypeMaps.this.Symbol)TypeMaps.this.Symbol">orElse</a> <span class="delimiter">{</span>
          <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span><a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="../Phase.scala.html#scala.reflect.internal;Phase.flatClasses" title="=&gt; Boolean">flatClasses</a><span title="(x$1: Any)String">+</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a><span title="(x$1: Any)String">+</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym.NameType">name</a><span title="(x$1: Any)String">+</span><span title="String(&quot; &quot;)" class="string">&quot; &quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isType" title="=&gt; Boolean">isType</a><span class="delimiter">)</span>
          throw new <a href="../Types.scala.html#scala.reflect.internal;Types;MalformedType" title="TypeMaps.this.MalformedType">MalformedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.pre" title="TypeMaps.this.Type">pre</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun.sym" title="TypeMaps.this.Symbol">sym</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.nameString" title="=&gt; String">nameString</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    def <a title="(tp: TypeMaps.this.Type)TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply">apply</a><span class="delimiter">(</span><a title="TypeMaps.this.Type" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a><span class="delimiter">)</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeMaps.this.Type">Type</a> = <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a> match <span class="delimiter">{</span>
      case ThisType<span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span> =&gt;
        try <span class="delimiter">{</span>
          val <span title="TypeMaps.this.Symbol">sym1</span> = <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun" title="(pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol)TypeMaps.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.thisType" title="=&gt; TypeMaps.this.Type">thisType</a>, <span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span>
          if <span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym1</span> <span title="(x$1: Any)Boolean">==</span> <span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a> else <a href="../Types.scala.html#scala.reflect.internal;Types.ThisType.apply(a489b0ed7a)" title="(sym: TypeMaps.this.Symbol)TypeMaps.this.Type">ThisType</a><span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym1</span><span class="delimiter">)</span>
        <span class="delimiter">}</span> catch <span class="delimiter">{</span>
          case <span title="TypeMaps.this.MissingTypeControl">ex</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;MissingTypeControl" title="TypeMaps.this.MissingTypeControl">MissingTypeControl</a> =&gt;
            <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
        <span class="delimiter">}</span>
      case SingleType<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span>, <span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span> =&gt;
        if <span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym</span>.<a href="../HasFlags.scala.html#scala.reflect.internal;HasFlags.hasPackageFlag" title="=&gt; Boolean">hasPackageFlag</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
        else <span class="delimiter">{</span>
          val <span title="TypeMaps.this.Type">pre1</span> = this<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span><span class="delimiter">)</span>
          try <span class="delimiter">{</span>
            val <span title="TypeMaps.this.Symbol">sym1</span> = <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun" title="(pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol)TypeMaps.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">pre1</span>, <span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span>
            if <span class="delimiter">(</span><span class="delimiter">(</span><span title="TypeMaps.this.Type">pre1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Type">pre</span><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
            else <a href="../Types.scala.html#scala.reflect.internal;Types.singleType" title="(pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol)TypeMaps.this.Type">singleType</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">pre1</span>, <span title="TypeMaps.this.Symbol">sym1</span><span class="delimiter">)</span>
          <span class="delimiter">}</span> catch <span class="delimiter">{</span>
            case _: <a href="../Types.scala.html#scala.reflect.internal;Types;MissingTypeControl" title="TypeMaps.this.MissingTypeControl">MissingTypeControl</a> =&gt;
              <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      case TypeRef<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span>, <span title="TypeMaps.this.Symbol">sym</span>, <a title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.args">args</a><span class="delimiter">)</span> =&gt;
        if <span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
        else <span class="delimiter">{</span>
          val <span title="TypeMaps.this.Type">pre1</span> = this<span class="delimiter">(</span><span title="TypeMaps.this.Type">pre</span><span class="delimiter">)</span>
          val args1 = <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.args" title="List[TypeMaps.this.Type]">args</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="List[TypeMaps.this.Type]" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.args1">mapConserve</a> <span class="delimiter">(</span>this<span class="delimiter">)</span>
          try <span class="delimiter">{</span>
            val <span title="TypeMaps.this.Symbol">sym1</span> = <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.adaptToNewRun" title="(pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol)TypeMaps.this.Symbol">adaptToNewRun</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">pre1</span>, <span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span>
            if <span class="delimiter">(</span><span class="delimiter">(</span><span title="TypeMaps.this.Type">pre1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Type">pre</span><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Symbol">sym</span><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.args1" title="List[TypeMaps.this.Type]">args1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.args" title="List[TypeMaps.this.Type]">args</a><span class="delimiter">)</span><span class="comment">/* &amp;&amp; sym.isExternal*/</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
            <span class="delimiter">}</span> else if <span class="delimiter">(</span><span title="TypeMaps.this.Symbol">sym1</span> <span title="(x$1: Any)Boolean">==</span> <a href="../Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; TypeMaps.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.devWarning" title="(msg: =&gt; String)Unit">devWarning</a><span class="delimiter">(</span><a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;adapt to new run failed: pre=&quot;)">adapt to new run failed: pre=$</span><span title="TypeMaps.this.Type">pre</span><span title="String(&quot; pre1=&quot;)"> pre1=$</span><span title="TypeMaps.this.Type">pre1</span><span title="String(&quot; sym=&quot;)"> sym=$</span><span title="TypeMaps.this.Symbol">sym</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
              <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
            <span class="delimiter">}</span> else <span class="delimiter">{</span>
              <a href="../Types.scala.html#scala.reflect.internal;Types.copyTypeRef" title="(tp: TypeMaps.this.Type, pre: TypeMaps.this.Type, sym: TypeMaps.this.Symbol, args: List[TypeMaps.this.Type])TypeMaps.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>, <span title="TypeMaps.this.Type">pre1</span>, <span title="TypeMaps.this.Symbol">sym1</span>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.args1" title="List[TypeMaps.this.Type]">args1</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span> catch <span class="delimiter">{</span>
            case <span title="TypeMaps.this.MissingAliasControl">ex</span>: <a href="../Types.scala.html#scala.reflect.internal;Types;MissingAliasControl" title="TypeMaps.this.MissingAliasControl">MissingAliasControl</a> =&gt;
              <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">apply</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.dealias" title="=&gt; TypeMaps.this.Type">dealias</a><span class="delimiter">)</span>
            case _: <a href="../Types.scala.html#scala.reflect.internal;Types;MissingTypeControl" title="TypeMaps.this.MissingTypeControl">MissingTypeControl</a> =&gt;
              <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      case MethodType<span class="delimiter">(</span><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.params">params</a>, <span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span> =&gt;
        val <span title="TypeMaps.this.Type">restp1</span> = this<span class="delimiter">(</span><span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><span title="TypeMaps.this.Type">restp1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types.copyMethodType" title="(tp: TypeMaps.this.Type, params: List[TypeMaps.this.Symbol], restpe: TypeMaps.this.Type)TypeMaps.this.Type">copyMethodType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.params" title="List[TypeMaps.this.Symbol]">params</a>, <span title="TypeMaps.this.Type">restp1</span><span class="delimiter">)</span>
      case NullaryMethodType<span class="delimiter">(</span><span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span> =&gt;
        val <span title="TypeMaps.this.Type">restp1</span> = this<span class="delimiter">(</span><span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><span title="TypeMaps.this.Type">restp1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types;NullaryMethodType" title="(resultType: TypeMaps.this.Type)TypeMaps.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">(</span><span title="TypeMaps.this.Type">restp1</span><span class="delimiter">)</span>
      case PolyType<span class="delimiter">(</span><a title="List[TypeMaps.this.Symbol]" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tparams">tparams</a>, <span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span> =&gt;
        val <span title="TypeMaps.this.Type">restp1</span> = this<span class="delimiter">(</span><span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><span title="TypeMaps.this.Type">restp1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="TypeMaps.this.Type">restp</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types;PolyType" title="(typeParams: List[TypeMaps.this.Symbol], resultType: TypeMaps.this.Type)TypeMaps.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tparams" title="List[TypeMaps.this.Symbol]">tparams</a>, <span title="TypeMaps.this.Type">restp1</span><span class="delimiter">)</span>

      <span class="comment">// Lukas: we need to check (together) whether we should also include parameter types</span>
      <span class="comment">// of PolyType and MethodType in adaptToNewRun</span>

      case ClassInfoType<span class="delimiter">(</span><span title="List[TypeMaps.this.Type]">parents</span>, <span title="TypeMaps.this.Scope">decls</span>, <a title="TypeMaps.this.Symbol" id="scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.clazz">clazz</a><span class="delimiter">)</span> =&gt;
        if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.clazz" title="TypeMaps.this.Symbol">clazz</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
        else <span class="delimiter">{</span>
          val parents1 = <span title="List[TypeMaps.this.Type]">parents</span> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="List[TypeMaps.this.Type]">mapConserve</a> <span class="delimiter">(</span>this<span class="delimiter">)</span>
          if <span class="delimiter">(</span><span title="List[TypeMaps.this.Type]">parents1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="List[TypeMaps.this.Type]">parents</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
          else <a href="../Types.scala.html#scala.reflect.internal;Types;ClassInfoType" title="(parents: List[TypeMaps.this.Type], decls: TypeMaps.this.Scope, typeSymbol: TypeMaps.this.Symbol)TypeMaps.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span><span title="List[TypeMaps.this.Type]">parents1</span>, <span title="TypeMaps.this.Scope">decls</span>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.clazz" title="TypeMaps.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      case RefinedType<span class="delimiter">(</span><span title="List[TypeMaps.this.Type]">parents</span>, <span title="TypeMaps.this.Scope">decls</span><span class="delimiter">)</span> =&gt;
        val parents1 = <span title="List[TypeMaps.this.Type]">parents</span> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="List[TypeMaps.this.Type]">mapConserve</a> <span class="delimiter">(</span>this<span class="delimiter">)</span>
        if <span class="delimiter">(</span><span title="List[TypeMaps.this.Type]">parents1</span> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="List[TypeMaps.this.Type]">parents</span><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
        else <a href="../Types.scala.html#scala.reflect.internal;Types.refinedType(b06f606da5)" title="(parents: List[TypeMaps.this.Type], owner: TypeMaps.this.Symbol, decls: TypeMaps.this.Scope, pos: TypeMaps.this.Position)TypeMaps.this.Type">refinedType</a><span class="delimiter">(</span><span title="List[TypeMaps.this.Type]">parents1</span>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; TypeMaps.this.Symbol">typeSymbol</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a>, <span title="TypeMaps.this.Scope">decls</span>, <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; TypeMaps.this.Symbol">typeSymbol</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; TypeMaps.this.Symbol">owner</a>.<a href="../StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.pos" title="=&gt; TypeMaps.this.Position">pos</a><span class="delimiter">)</span>
      case SuperType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
      case TypeBounds<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
      case TypeVar<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
      case AnnotatedType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
      case ExistentialType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: TypeMaps.this.Type)TypeMaps.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a><span class="delimiter">)</span>
      case _ =&gt; <a href="#scala.reflect.internal.tpe;TypeMaps.adaptToNewRunMap.apply.tp" title="TypeMaps.this.Type">tp</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
