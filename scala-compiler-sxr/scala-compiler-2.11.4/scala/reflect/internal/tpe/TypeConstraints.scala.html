<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/reflect/internal/tpe/TypeConstraints.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scala
package reflect
package internal
package tpe

import scala.collection.<span class="delimiter">{</span> generic <span class="delimiter">}</span>
import generic.Clearable

private<span class="delimiter">[</span>internal<span class="delimiter">]</span> trait <a title="trait TypeConstraints extends AnyRef" id="scala.reflect.internal.tpe;TypeConstraints">TypeConstraints</a> <a href="../../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a>
  self: SymbolTable =&gt;
  import <a href="../Definitions.scala.html#scala.reflect.internal;Definitions.definitions" title="TypeConstraints.this.definitions.type">definitions</a>._

  <span class="comment">/** A log of type variable with their original constraints. Used in order
    *  to undo constraints in the case of isSubType/isSameType failure.
    */</span>
  private lazy val <a title="TypeConstraints.this.UndoLog" id="scala.reflect.internal.tpe;TypeConstraints._undoLog">_undoLog</a> = new <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog" title="TypeConstraints.this.UndoLog">UndoLog</a>
  def <a title="=&gt; TypeConstraints.this.UndoLog" id="scala.reflect.internal.tpe;TypeConstraints.undoLog">undoLog</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints._undoLog" title="=&gt; TypeConstraints.this.UndoLog">_undoLog</a>

  import <a href="#scala.reflect.internal.tpe.TypeConstraints" title="scala.reflect.internal.tpe.TypeConstraints.type">TypeConstraints</a>.UndoPair
  class <a title="class UndoLog extends AnyRef with scala.collection.generic.Clearable" id="scala.reflect.internal.tpe;TypeConstraints;UndoLog">UndoLog</a> extends <a href="../../../collection/generic/Clearable.scala.html#scala.collection.generic;Clearable" title="scala.collection.generic.Clearable">Clearable</a> <span class="delimiter">{</span>
    type <a title="List[scala.reflect.internal.tpe.TypeConstraints.UndoPair[TypeConstraints.this.TypeVar,TypeConstraints.this.TypeConstraint]]" id="scala.reflect.internal.tpe;TypeConstraints;UndoLog;UndoPairs">UndoPairs</a> = <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[scala.reflect.internal.tpe.TypeConstraints.UndoPair[TypeConstraints.this.TypeVar,TypeConstraints.this.TypeConstraint]]">List</a><span class="delimiter">[</span>UndoPair<span class="delimiter">[</span>TypeVar, TypeConstraint<span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="comment">//OPT this method is public so we can do `manual inlining`</span>
    var <a title="UndoLog.this.UndoPairs" id="scala.reflect.internal.tpe;TypeConstraints;UndoLog.log_=">log</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="UndoLog.this.UndoPairs">UndoPairs</a> = List<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    <span class="comment">// register with the auto-clearing cache manager</span>
    <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.perRunCaches" title="TypeConstraints.this.perRunCaches.type">perRunCaches</a>.<a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.perRunCaches.recordCache" title="(cache: TypeConstraints.this.UndoLog)TypeConstraints.this.UndoLog">recordCache</a><span class="delimiter">(</span>this<span class="delimiter">)</span>

    <span class="comment">/** Undo all changes to constraints to type variables upto `limit`. */</span>
    <span class="comment">//OPT this method is public so we can do `manual inlining`</span>
    def <a title="(limit: UndoLog.this.UndoPairs)Unit" id="scala.reflect.internal.tpe;TypeConstraints;UndoLog.undoTo">undoTo</a><span class="delimiter">(</span><a title="UndoLog.this.UndoPairs" id="scala.reflect.internal.tpe;TypeConstraints;UndoLog.undoTo.limit">limit</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="UndoLog.this.UndoPairs">UndoPairs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.assertCorrectThread" title="()Unit">assertCorrectThread</a><span class="delimiter">(</span><span class="delimiter">)</span>
      while <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.log_=" title="=&gt; UndoLog.this.UndoPairs">log</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.undoTo.limit" title="UndoLog.this.UndoPairs">limit</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.log_=" title="=&gt; UndoLog.this.UndoPairs">log</a>.<a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.undoTo.while$1" title="()Unit" class="delimiter">{</a>
        val UndoPair<a href="../../../Tuple2.scala.html#scala;Tuple2" title="(TypeConstraints.this.TypeVar, TypeConstraints.this.TypeConstraint)" class="delimiter">(</a><a href="../../../Tuple2.scala.html#scala;Tuple2._1" title="TypeConstraints.this.TypeVar" id="scala.reflect.internal.tpe;TypeConstraints;UndoLog.undoTo.tv">tv</a>, <a href="../../../Tuple2.scala.html#scala;Tuple2._2" title="TypeConstraints.this.TypeConstraint" id="scala.reflect.internal.tpe;TypeConstraints;UndoLog.undoTo.constr">constr</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.log_=" title="=&gt; UndoLog.this.UndoPairs">log</a>.<a href="../../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; scala.reflect.internal.tpe.TypeConstraints.UndoPair[TypeConstraints.this.TypeVar,TypeConstraints.this.TypeConstraint]">head</a>
        <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.undoTo.tv" title="TypeConstraints.this.TypeVar">tv</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.constr_=" title="(x$1: TypeConstraints.this.TypeConstraint)Unit">constr</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.undoTo.constr" title="TypeConstraints.this.TypeConstraint">constr</a>
        <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.log_=" title="(x$1: UndoLog.this.UndoPairs)Unit">log</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.log_=" title="=&gt; UndoLog.this.UndoPairs">log</a>.<a href="../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[scala.reflect.internal.tpe.TypeConstraints.UndoPair[TypeConstraints.this.TypeVar,TypeConstraints.this.TypeConstraint]]">tail</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** No sync necessary, because record should only
      *  be called from within an undo or undoUnless block,
      *  which is already synchronized.
      */</span>
    private<span class="delimiter">[</span>reflect<span class="delimiter">]</span> def <a title="(tv: TypeConstraints.this.TypeVar)Unit" id="scala.reflect.internal.tpe;TypeConstraints;UndoLog.record">record</a><span class="delimiter">(</span><a title="TypeConstraints.this.TypeVar" id="scala.reflect.internal.tpe;TypeConstraints;UndoLog.record.tv">tv</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar" title="TypeConstraints.this.TypeVar">TypeVar</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.log_=" title="(x$1: UndoLog.this.UndoPairs)Unit">log</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: scala.reflect.internal.tpe.TypeConstraints.UndoPair[TypeConstraints.this.TypeVar,TypeConstraints.this.TypeConstraint])List[scala.reflect.internal.tpe.TypeConstraints.UndoPair[TypeConstraints.this.TypeVar,TypeConstraints.this.TypeConstraint]]">::=</a> <a href="#scala.reflect.internal.tpe.TypeConstraints.UndoPair.readResolve" title="(tv: TypeConstraints.this.TypeVar, tConstraint: TypeConstraints.this.TypeConstraint)scala.reflect.internal.tpe.TypeConstraints.UndoPair[TypeConstraints.this.TypeVar,TypeConstraints.this.TypeConstraint]">UndoPair</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.record.tv" title="TypeConstraints.this.TypeVar">tv</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.record.tv" title="TypeConstraints.this.TypeVar">tv</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; TypeConstraints.this.TypeConstraint">constr</a>.<a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.cloneInternal" title="=&gt; TypeConstraints.this.TypeConstraint">cloneInternal</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    def <a title="()Unit" id="scala.reflect.internal.tpe;TypeConstraints;UndoLog.clear">clear</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="../Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="../settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">debug</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal.tpe;TypeConstraints" title="TypeConstraints.this.type">self</a>.<a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.log" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><span title="String(&quot;Clearing &quot;)" class="string">&quot;Clearing &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.log_=" title="=&gt; UndoLog.this.UndoPairs">log</a>.<a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.size" title="=&gt; Int">size</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; entries from the undoLog.&quot;)" class="string">&quot; entries from the undoLog.&quot;</span><span class="delimiter">)</span>
      <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.log_=" title="(x$1: UndoLog.this.UndoPairs)Unit">log</a> = <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
    <span class="delimiter">}</span>

    <span class="comment">// `block` should not affect constraints on typevars</span>
    def <a title="[T](block: =&gt; T)T" id="scala.reflect.internal.tpe;TypeConstraints;UndoLog.undo">undo</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal.tpe;TypeConstraints;UndoLog.undo;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; T" id="scala.reflect.internal.tpe;TypeConstraints;UndoLog.undo.block">block</a>: =&gt; T<span class="delimiter">)</span>: <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.undo;T" title="T">T</a> = <span class="delimiter">{</span>
      val <a title="UndoLog.this.UndoPairs" id="scala.reflect.internal.tpe;TypeConstraints;UndoLog.undo.before">before</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.log_=" title="=&gt; UndoLog.this.UndoPairs">log</a>
      try <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.undo.block" title="=&gt; T">block</a>
      finally <a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.undoTo" title="(limit: UndoLog.this.UndoPairs)Unit">undoTo</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;UndoLog.undo.before" title="UndoLog.this.UndoPairs">before</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** @PP: Unable to see why these apparently constant types should need vals
    *  in every TypeConstraint, I lifted them out.
    */</span>
  private lazy val <a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints.numericLoBound">numericLoBound</a> = <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;ValueClassDefinitions.IntTpe" title="=&gt; TypeConstraints.this.Type">IntTpe</a>
  private lazy val <a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints.numericHiBound">numericHiBound</a> = <a href="../Types.scala.html#scala.reflect.internal;Types.intersectionType(b28944ca7d)" title="(tps: List[TypeConstraints.this.Type], owner: TypeConstraints.this.Symbol)TypeConstraints.this.Type">intersectionType</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.List.apply" title="(xs: TypeConstraints.this.Type*)List[TypeConstraints.this.Type]">List</a><span class="delimiter">(</span><a href="../Definitions.scala.html#scala.reflect.internal;Definitions;ValueClassDefinitions.ByteTpe" title="=&gt; TypeConstraints.this.Type">ByteTpe</a>, <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;ValueClassDefinitions.CharTpe" title="=&gt; TypeConstraints.this.Type">CharTpe</a><span class="delimiter">)</span>, <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ScalaPackageClass" title="=&gt; TypeConstraints.this.ClassSymbol">ScalaPackageClass</a><span class="delimiter">)</span>

  <span class="comment">/** A class expressing upper and lower bounds constraints of type variables,
    * as well as their instantiations.
    */</span>
  class <a title="class TypeConstraint extends AnyRef" id="scala.reflect.internal.tpe;TypeConstraints.TypeConstraint">TypeConstraint</a><a href="#scala.reflect.internal.tpe;TypeConstraints.TypeConstraint" title="TypeConstraints.this.TypeConstraint" class="delimiter">(</a><a title="List[TypeConstraints.this.Type]" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.lo0">lo0</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeConstraints.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[TypeConstraints.this.Type]" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.hi0">hi0</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeConstraints.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numlo0">numlo0</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeConstraints.this.Type">Type</a>, <a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numhi0">numhi0</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeConstraints.this.Type">Type</a>, <a title="Boolean" id="scala.reflect.internal.tpe;TypeConstraints.TypeConstraint.<init>$default$5">avoidWidening0</a>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false<span class="delimiter">)</span> <span class="delimiter">{</span>
    def this<span class="delimiter">(</span><a title="List[TypeConstraints.this.Type]" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.<init>(7eb81c824b).lo0">lo0</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeConstraints.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[TypeConstraints.this.Type]" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.<init>(7eb81c824b).hi0">hi0</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeConstraints.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = this<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.<init>(7eb81c824b).lo0" title="List[TypeConstraints.this.Type]">lo0</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.<init>(7eb81c824b).hi0" title="List[TypeConstraints.this.Type]">hi0</a>, <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeConstraints.this.NoType.type">NoType</a>, <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeConstraints.this.NoType.type">NoType</a><span class="delimiter">)</span>
    def this<span class="delimiter">(</span><a title="TypeConstraints.this.TypeBounds" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.<init>(607381de0a).bounds">bounds</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;TypeBounds" title="TypeConstraints.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span> = this<span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.List.apply" title="(xs: TypeConstraints.this.Type*)List[TypeConstraints.this.Type]">List</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.<init>(607381de0a).bounds" title="TypeConstraints.this.TypeBounds">bounds</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeBounds.lo" title="=&gt; TypeConstraints.this.Type">lo</a><span class="delimiter">)</span>, <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.List.apply" title="(xs: TypeConstraints.this.Type*)List[TypeConstraints.this.Type]">List</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.<init>(607381de0a).bounds" title="TypeConstraints.this.TypeBounds">bounds</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; TypeConstraints.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
    def this<span class="delimiter">(</span><span class="delimiter">)</span> = this<span class="delimiter">(</span>List<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>, List<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="comment">/*  Syncnote: Type constraints are assumed to be used from only one
     *  thread. They are not exposed in api.Types and are used only locally
     *  in operations that are exposed from types. Hence, no syncing of any
     *  variables should be ncessesary.
     */</span>

    <span class="comment">/** Guard these lists against AnyClass and NothingClass appearing,
      *  else loBounds.isEmpty will have different results for an empty
      *  constraint and one with Nothing as a lower bound.  [Actually
      *  guarding addLoBound/addHiBound somehow broke raw types so it
      *  only guards against being created with them.]
      */</span>
    private var lobounds = <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.lo0" title="List[TypeConstraints.this.Type]">lo0</a> <a href="../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filterNot" title="List[TypeConstraints.this.Type]" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.lobounds_=">filterNot</a> <a href="../Types.scala.html#scala.reflect.internal;Types.typeIsNothing" title="=&gt; TypeConstraints.this.Type =&gt; Boolean">typeIsNothing</a>
    private var hibounds = <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.hi0" title="List[TypeConstraints.this.Type]">hi0</a> <a href="../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filterNot" title="List[TypeConstraints.this.Type]" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.hibounds_=">filterNot</a> <a href="../Types.scala.html#scala.reflect.internal;Types.typeIsAny" title="=&gt; TypeConstraints.this.Type =&gt; Boolean">typeIsAny</a>
    private var <a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numlo_=">numlo</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numlo0" title="TypeConstraints.this.Type">numlo0</a>
    private var <a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numhi_=">numhi</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numhi0" title="TypeConstraints.this.Type">numhi0</a>
    private var <a title="Boolean" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.avoidWidening_=">avoidWidening</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints.TypeConstraint.<init>$default$5" title="Boolean">avoidWidening0</a>

    def <a title="=&gt; List[TypeConstraints.this.Type]" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.loBounds">loBounds</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeConstraints.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numlo_=" title="=&gt; TypeConstraints.this.Type">numlo</a> <span title="(x$1: Any)Boolean">==</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeConstraints.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.lobounds_=" title="=&gt; List[TypeConstraints.this.Type]">lobounds</a> else <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numlo_=" title="=&gt; TypeConstraints.this.Type">numlo</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: TypeConstraints.this.Type)List[TypeConstraints.this.Type]">::</a> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.lobounds_=" title="=&gt; List[TypeConstraints.this.Type]">lobounds</a>
    def <a title="=&gt; List[TypeConstraints.this.Type]" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.hiBounds">hiBounds</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeConstraints.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numhi_=" title="=&gt; TypeConstraints.this.Type">numhi</a> <span title="(x$1: Any)Boolean">==</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeConstraints.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.hibounds_=" title="=&gt; List[TypeConstraints.this.Type]">hibounds</a> else <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numhi_=" title="=&gt; TypeConstraints.this.Type">numhi</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: TypeConstraints.this.Type)List[TypeConstraints.this.Type]">::</a> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.hibounds_=" title="=&gt; List[TypeConstraints.this.Type]">hibounds</a>
    def <a title="=&gt; Boolean" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.avoidWiden">avoidWiden</a>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.avoidWidening_=" title="=&gt; Boolean">avoidWidening</a>

    def <a title="(tp: TypeConstraints.this.Type, isNumericBound: Boolean)Unit" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addLoBound">addLoBound</a><span class="delimiter">(</span><a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addLoBound.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeConstraints.this.Type">Type</a>, <a title="Boolean" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addLoBound$default$2">isNumericBound</a>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false<span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// For some reason which is still a bit fuzzy, we must let Nothing through as</span>
      <span class="comment">// a lower bound despite the fact that Nothing is always a lower bound.  My current</span>
      <span class="comment">// supposition is that the side-effecting type constraint accumulation mechanism</span>
      <span class="comment">// depends on these subtype tests being performed to make forward progress when</span>
      <span class="comment">// there are mutally recursive type vars.</span>
      <span class="comment">// See pos/t6367 and pos/t6499 for the competing test cases.</span>
      val <a title="Boolean" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addLoBound.mustConsider">mustConsider</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addLoBound.tp" title="TypeConstraints.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; TypeConstraints.this.Symbol">typeSymbol</a> match <span class="delimiter">{</span>
        case <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.NothingClass" title="TypeConstraints.this.definitions.NothingClass.type">NothingClass</a> =&gt; true
        case _            =&gt; <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.lobounds_=" title="=&gt; List[TypeConstraints.this.Type]">lobounds</a> <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: TypeConstraints.this.Type)Boolean">contains</a> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addLoBound.tp" title="TypeConstraints.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addLoBound.mustConsider" title="Boolean">mustConsider</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addLoBound$default$2" title="Boolean">isNumericBound</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isNumericValueType" title="(tp: TypeConstraints.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addLoBound.tp" title="TypeConstraints.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numlo_=" title="=&gt; TypeConstraints.this.Type">numlo</a> <span title="(x$1: Any)Boolean">==</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeConstraints.this.NoType.type">NoType</a> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isNumericSubType" title="(tp1: TypeConstraints.this.Type, tp2: TypeConstraints.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numlo_=" title="=&gt; TypeConstraints.this.Type">numlo</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addLoBound.tp" title="TypeConstraints.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numlo_=" title="(x$1: TypeConstraints.this.Type)Unit">numlo</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addLoBound.tp" title="TypeConstraints.this.Type">tp</a>
          else if <span class="delimiter">(</span><a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isNumericSubType" title="(tp1: TypeConstraints.this.Type, tp2: TypeConstraints.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addLoBound.tp" title="TypeConstraints.this.Type">tp</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numlo_=" title="=&gt; TypeConstraints.this.Type">numlo</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numlo_=" title="(x$1: TypeConstraints.this.Type)Unit">numlo</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints.numericLoBound" title="=&gt; TypeConstraints.this.Type">numericLoBound</a>
        <span class="delimiter">}</span>
        else <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.lobounds_=" title="(x$1: List[TypeConstraints.this.Type])Unit">lobounds</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: TypeConstraints.this.Type)List[TypeConstraints.this.Type]">::=</a> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addLoBound.tp" title="TypeConstraints.this.Type">tp</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    def <a title="(tp: TypeConstraints.this.Type)Unit" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.checkWidening">checkWidening</a><span class="delimiter">(</span><a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.checkWidening.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeConstraints.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if<span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.checkWidening.tp" title="TypeConstraints.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.isStable" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.avoidWidening_=" title="(x$1: Boolean)Unit">avoidWidening</a> = true
      else <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.checkWidening.tp" title="TypeConstraints.this.Type">tp</a> match <span class="delimiter">{</span>
        case <a href="../Types.scala.html#scala.reflect.internal;Types.HasTypeMember.unapply" title="(tp: TypeConstraints.this.Type)Option[(TypeConstraints.this.TypeName, TypeConstraints.this.Type)]">HasTypeMember</a><span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.avoidWidening_=" title="(x$1: Boolean)Unit">avoidWidening</a> = true
        case _ =&gt;
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    def <a title="(tp: TypeConstraints.this.Type, isNumericBound: Boolean)Unit" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound">addHiBound</a><span class="delimiter">(</span><a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeConstraints.this.Type">Type</a>, <a title="Boolean" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound$default$2">isNumericBound</a>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false<span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// My current test case only demonstrates the need to let Nothing through as</span>
      <span class="comment">// a lower bound, but I suspect the situation is symmetrical.</span>
      val <a title="Boolean" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound.mustConsider">mustConsider</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound.tp" title="TypeConstraints.this.Type">tp</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; TypeConstraints.this.Symbol">typeSymbol</a> match <span class="delimiter">{</span>
        case <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyClass" title="=&gt; TypeConstraints.this.ClassSymbol">AnyClass</a> =&gt; true
        case _        =&gt; <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.hibounds_=" title="=&gt; List[TypeConstraints.this.Type]">hibounds</a> <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: TypeConstraints.this.Type)Boolean">contains</a> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound.tp" title="TypeConstraints.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound.mustConsider" title="Boolean">mustConsider</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.checkWidening" title="(tp: TypeConstraints.this.Type)Unit">checkWidening</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound.tp" title="TypeConstraints.this.Type">tp</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound$default$2" title="Boolean">isNumericBound</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isNumericValueType" title="(tp: TypeConstraints.this.Type)Boolean">isNumericValueType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound.tp" title="TypeConstraints.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numhi_=" title="=&gt; TypeConstraints.this.Type">numhi</a> <span title="(x$1: Any)Boolean">==</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeConstraints.this.NoType.type">NoType</a> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isNumericSubType" title="(tp1: TypeConstraints.this.Type, tp2: TypeConstraints.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound.tp" title="TypeConstraints.this.Type">tp</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numhi_=" title="=&gt; TypeConstraints.this.Type">numhi</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numhi_=" title="(x$1: TypeConstraints.this.Type)Unit">numhi</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound.tp" title="TypeConstraints.this.Type">tp</a>
          else if <span class="delimiter">(</span><a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isNumericSubType" title="(tp1: TypeConstraints.this.Type, tp2: TypeConstraints.this.Type)Boolean">isNumericSubType</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numhi_=" title="=&gt; TypeConstraints.this.Type">numhi</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound.tp" title="TypeConstraints.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numhi_=" title="(x$1: TypeConstraints.this.Type)Unit">numhi</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints.numericHiBound" title="=&gt; TypeConstraints.this.Type">numericHiBound</a>
        <span class="delimiter">}</span>
        else <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.hibounds_=" title="(x$1: List[TypeConstraints.this.Type])Unit">hibounds</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: TypeConstraints.this.Type)List[TypeConstraints.this.Type]">::=</a> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound.tp" title="TypeConstraints.this.Type">tp</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    def <a title="=&gt; Boolean" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.instWithinBounds">instWithinBounds</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.instValid" title="=&gt; Boolean">instValid</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.isWithinBounds" title="(tp: TypeConstraints.this.Type)Boolean">isWithinBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst_=" title="=&gt; TypeConstraints.this.Type">inst</a><span class="delimiter">)</span>

    def <a title="(tp: TypeConstraints.this.Type)Boolean" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.isWithinBounds">isWithinBounds</a><span class="delimiter">(</span><a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.isWithinBounds.tp">tp</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeConstraints.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">(</span>
         <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.lobounds_=" title="=&gt; List[TypeConstraints.this.Type]">lobounds</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: TypeConstraints.this.Type =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.isWithinBounds.$anonfun.x$4" title="TypeConstraints.this.Type">_</a> <a href="../Types.scala.html#scala.reflect.internal;Types;Type.<:<" title="(that: TypeConstraints.this.Type)Boolean">&lt;:&lt;</a> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.isWithinBounds.tp" title="TypeConstraints.this.Type">tp</a><span class="delimiter">)</span>
      <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.hibounds_=" title="=&gt; List[TypeConstraints.this.Type]">hibounds</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: TypeConstraints.this.Type =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.isWithinBounds.tp" title="TypeConstraints.this.Type">tp</a> <a href="../Types.scala.html#scala.reflect.internal;Types;Type.<:<" title="(that: TypeConstraints.this.Type)Boolean">&lt;:&lt;</a> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.isWithinBounds.$anonfun.x$5" title="TypeConstraints.this.Type">_</a><span class="delimiter">)</span>
      <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numlo_=" title="=&gt; TypeConstraints.this.Type">numlo</a> <span title="(x$1: Any)Boolean">==</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeConstraints.this.NoType.type">NoType</a> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numlo_=" title="=&gt; TypeConstraints.this.Type">numlo</a> <a href="../Types.scala.html#scala.reflect.internal;Types;Type.weak_<:<" title="(that: TypeConstraints.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.isWithinBounds.tp" title="TypeConstraints.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numhi_=" title="=&gt; TypeConstraints.this.Type">numhi</a> <span title="(x$1: Any)Boolean">==</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeConstraints.this.NoType.type">NoType</a> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.isWithinBounds.tp" title="TypeConstraints.this.Type">tp</a> <a href="../Types.scala.html#scala.reflect.internal;Types;Type.weak_<:<" title="(that: TypeConstraints.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numhi_=" title="=&gt; TypeConstraints.this.Type">numhi</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>

    var <a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst_=">inst</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeConstraints.this.Type">Type</a> = <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeConstraints.this.NoType.type">NoType</a> <span class="comment">// @M reduce visibility?</span>

    def <a title="=&gt; Boolean" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.instValid">instValid</a> = <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst_=" title="=&gt; TypeConstraints.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> null<span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst_=" title="=&gt; TypeConstraints.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeConstraints.this.NoType.type">NoType</a><span class="delimiter">)</span>

    def <a title="=&gt; TypeConstraints.this.TypeConstraint" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.cloneInternal">cloneInternal</a> = <span class="delimiter">{</span>
      val <a title="TypeConstraints.this.TypeConstraint" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.cloneInternal.tc">tc</a> = new <a href="#scala.reflect.internal.tpe;TypeConstraints.TypeConstraint" title="TypeConstraints.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.lobounds_=" title="=&gt; List[TypeConstraints.this.Type]">lobounds</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.hibounds_=" title="=&gt; List[TypeConstraints.this.Type]">hibounds</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numlo_=" title="=&gt; TypeConstraints.this.Type">numlo</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.numhi_=" title="=&gt; TypeConstraints.this.Type">numhi</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.avoidWidening_=" title="=&gt; Boolean">avoidWidening</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.cloneInternal.tc" title="TypeConstraints.this.TypeConstraint">tc</a>.<a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst_=" title="(x$1: TypeConstraints.this.Type)Unit">inst</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst_=" title="=&gt; TypeConstraints.this.Type">inst</a>
      <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.cloneInternal.tc" title="TypeConstraints.this.TypeConstraint">tc</a>
    <span class="delimiter">}</span>

    override def <a title="()String" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString">toString</a> = <span class="delimiter">{</span>
      val <a title="String" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr">boundsStr</a> = <span class="delimiter">{</span>
        val <a title="String" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr.lo">lo</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.loBounds" title="=&gt; List[TypeConstraints.this.Type]">loBounds</a> <a href="../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filterNot" title="(p: TypeConstraints.this.Type =&gt; Boolean)List[TypeConstraints.this.Type]">filterNot</a> <a href="../Types.scala.html#scala.reflect.internal;Types.typeIsNothing" title="=&gt; TypeConstraints.this.Type =&gt; Boolean">typeIsNothing</a> match <span class="delimiter">{</span>
          case <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>       =&gt; <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
          case <a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr.lo.tp">tp</a> :: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> =&gt; <span title="String(&quot; &gt;: &quot;)" class="string">&quot; &gt;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr.lo.tp" title="TypeConstraints.this.Type">tp</a>
          case <a title="List[TypeConstraints.this.Type]" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr.lo.tps">tps</a>       =&gt; <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr.lo.tps" title="List[TypeConstraints.this.Type]">tps</a>.<a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot; &gt;: (&quot;)" class="string">&quot; &gt;: (&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        val <a title="String" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr.hi">hi</a> = <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.hiBounds" title="=&gt; List[TypeConstraints.this.Type]">hiBounds</a> <a href="../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filterNot" title="(p: TypeConstraints.this.Type =&gt; Boolean)List[TypeConstraints.this.Type]">filterNot</a> <a href="../Types.scala.html#scala.reflect.internal;Types.typeIsAny" title="=&gt; TypeConstraints.this.Type =&gt; Boolean">typeIsAny</a> match <span class="delimiter">{</span>
          case <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>       =&gt; <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
          case <a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr.hi.tp">tp</a> :: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> =&gt; <span title="String(&quot; &lt;: &quot;)" class="string">&quot; &lt;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr.hi.tp" title="TypeConstraints.this.Type">tp</a>
          case <a title="List[TypeConstraints.this.Type]" id="scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr.hi.tps">tps</a>       =&gt; <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr.hi.tps" title="List[TypeConstraints.this.Type]">tps</a>.<a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot; &lt;: (&quot;)" class="string">&quot; &lt;: (&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr.lo" title="String">lo</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr.hi" title="String">hi</a>
      <span class="delimiter">}</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst_=" title="=&gt; TypeConstraints.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeConstraints.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr" title="String">boundsStr</a>
      else <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.toString.boundsStr" title="String">boundsStr</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; _= &quot;)" class="string">&quot; _= &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst_=" title="=&gt; TypeConstraints.this.Type">inst</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.safeToString" title="=&gt; String">safeToString</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Solve constraint collected in types `tvars`.
    *
    *  @param tvars      All type variables to be instantiated.
    *  @param tparams    The type parameters corresponding to `tvars`
    *  @param variances  The variances of type parameters; need to reverse
    *                    solution direction for all contravariant variables.
    *  @param upper      When `true` search for max solution else min.
    */</span>
  def <a title="(tvars: List[TypeConstraints.this.TypeVar], tparams: List[TypeConstraints.this.Symbol], variances: List[scala.reflect.internal.Variance], upper: Boolean, depth: scala.reflect.internal.Depth)Boolean" id="scala.reflect.internal.tpe;TypeConstraints.solve">solve</a><span class="delimiter">(</span><a title="List[TypeConstraints.this.TypeVar]" id="scala.reflect.internal.tpe;TypeConstraints.solve.tvars">tvars</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeConstraints.this.TypeVar]">List</a><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span>, <a title="List[TypeConstraints.this.Symbol]" id="scala.reflect.internal.tpe;TypeConstraints.solve.tparams">tparams</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[TypeConstraints.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[scala.reflect.internal.Variance]" id="scala.reflect.internal.tpe;TypeConstraints.solve.variances">variances</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[scala.reflect.internal.Variance]">List</a><span class="delimiter">[</span>Variance<span class="delimiter">]</span>, <a title="Boolean" id="scala.reflect.internal.tpe;TypeConstraints.solve.upper">upper</a>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>, <a title="scala.reflect.internal.Depth" id="scala.reflect.internal.tpe;TypeConstraints.solve.depth">depth</a>: <a href="../Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>

    def <a title="(tvar: TypeConstraints.this.TypeVar, tparam: TypeConstraints.this.Symbol, variance: scala.reflect.internal.Variance)Unit" id="scala.reflect.internal.tpe;TypeConstraints.solve.solveOne">solveOne</a><span class="delimiter">(</span><a title="TypeConstraints.this.TypeVar" id="scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar">tvar</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar" title="TypeConstraints.this.TypeVar">TypeVar</a>, <a title="TypeConstraints.this.Symbol" id="scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tparam">tparam</a>: <a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="TypeConstraints.this.Symbol">Symbol</a>, <a title="scala.reflect.internal.Variance" id="scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.variance">variance</a>: <a href="../Variance.scala.html#scala.reflect.internal;Variance" title="scala.reflect.internal.Variance">Variance</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; TypeConstraints.this.TypeConstraint">constr</a>.<a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst_=" title="=&gt; TypeConstraints.this.Type">inst</a> <span title="(x$1: Any)Boolean">==</span> <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeConstraints.this.NoType.type">NoType</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="Boolean" id="scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.up">up</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.variance" title="scala.reflect.internal.Variance">variance</a>.<a href="../Variance.scala.html#scala.reflect.internal;Variance.isContravariant" title="=&gt; Boolean">isContravariant</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.upper" title="Boolean">upper</a> else <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.upper" title="Boolean">upper</a>
        <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; TypeConstraints.this.TypeConstraint">constr</a>.<a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst_=" title="(x$1: TypeConstraints.this.Type)Unit">inst</a> = null
        val <a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.bound">bound</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;Type" title="TypeConstraints.this.Type">Type</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.up" title="Boolean">up</a><span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tparam" title="TypeConstraints.this.Symbol">tparam</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; TypeConstraints.this.Type">info</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.bounds" title="=&gt; TypeConstraints.this.TypeBounds">bounds</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; TypeConstraints.this.Type">hi</a> else <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tparam" title="TypeConstraints.this.Symbol">tparam</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; TypeConstraints.this.Type">info</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.bounds" title="=&gt; TypeConstraints.this.TypeBounds">bounds</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeBounds.lo" title="=&gt; TypeConstraints.this.Type">lo</a>
        <span class="comment">//Console.println(&quot;solveOne0(tv, tp, v, b)=&quot;+(tvar, tparam, variance, bound))</span>
        var cyclic = <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.bound" title="TypeConstraints.this.Type">bound</a> <a href="../Types.scala.html#scala.reflect.internal;Types;Type.contains" title="Boolean" id="scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.cyclic">contains</a> <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tparam" title="TypeConstraints.this.Symbol">tparam</a>
        <a href="../util/Collections.scala.html#scala.reflect.internal.util;Collections.foreach3" title="(xs1: List[TypeConstraints.this.TypeVar], xs2: List[TypeConstraints.this.Symbol], xs3: List[scala.reflect.internal.Variance])(f: (TypeConstraints.this.TypeVar, TypeConstraints.this.Symbol, scala.reflect.internal.Variance) =&gt; Unit)Unit">foreach3</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tvars" title="List[TypeConstraints.this.TypeVar]">tvars</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tparams" title="List[TypeConstraints.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.variances" title="List[scala.reflect.internal.Variance]">variances</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="TypeConstraints.this.TypeVar" id="scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.$anonfun.tvar2">tvar2</a>, <span title="TypeConstraints.this.Symbol">tparam2</span>, <a title="scala.reflect.internal.Variance" id="scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.$anonfun.variance2">variance2</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          val ok = <span class="delimiter">(</span><span title="TypeConstraints.this.Symbol">tparam2</span> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tparam" title="TypeConstraints.this.Symbol">tparam</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="Boolean" id="scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.$anonfun.ok">&amp;&amp;</a> <span class="delimiter">(</span>
            <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.bound" title="TypeConstraints.this.Type">bound</a> <a href="../Types.scala.html#scala.reflect.internal;Types;Type.contains" title="(sym: TypeConstraints.this.Symbol)Boolean">contains</a> <span title="TypeConstraints.this.Symbol">tparam2</span><span class="delimiter">)</span>
              <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a>  <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.up" title="Boolean">up</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><span title="TypeConstraints.this.Symbol">tparam2</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; TypeConstraints.this.Type">info</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.bounds" title="=&gt; TypeConstraints.this.TypeBounds">bounds</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeBounds.lo" title="=&gt; TypeConstraints.this.Type">lo</a> <a href="../Types.scala.html#scala.reflect.internal;Types;Type.=:=" title="(that: TypeConstraints.this.Type)Boolean">=:=</a> <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tparam" title="TypeConstraints.this.Symbol">tparam</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpeHK" title="=&gt; TypeConstraints.this.Type">tpeHK</a><span class="delimiter">)</span>
              <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.up" title="Boolean">up</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><span title="TypeConstraints.this.Symbol">tparam2</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; TypeConstraints.this.Type">info</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.bounds" title="=&gt; TypeConstraints.this.TypeBounds">bounds</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; TypeConstraints.this.Type">hi</a> <a href="../Types.scala.html#scala.reflect.internal;Types;Type.=:=" title="(that: TypeConstraints.this.Type)Boolean">=:=</a> <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tparam" title="TypeConstraints.this.Symbol">tparam</a>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpeHK" title="=&gt; TypeConstraints.this.Type">tpeHK</a><span class="delimiter">)</span>
            <span class="delimiter">)</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.$anonfun.ok" title="Boolean">ok</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.$anonfun.tvar2" title="TypeConstraints.this.TypeVar">tvar2</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; TypeConstraints.this.TypeConstraint">constr</a>.<a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst_=" title="=&gt; TypeConstraints.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span> <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.cyclic" title="Boolean">cyclic</a> = true
            <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne" title="(tvar: TypeConstraints.this.TypeVar, tparam: TypeConstraints.this.Symbol, variance: scala.reflect.internal.Variance)Unit">solveOne</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.$anonfun.tvar2" title="TypeConstraints.this.TypeVar">tvar2</a>, <span title="TypeConstraints.this.Symbol">tparam2</span>, <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.$anonfun.variance2" title="scala.reflect.internal.Variance">variance2</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.cyclic" title="Boolean">cyclic</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.up" title="Boolean">up</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.bound" title="TypeConstraints.this.Type">bound</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; TypeConstraints.this.Symbol">typeSymbol</a> <span title="(x$1: Any)Boolean">!=</span> <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyClass" title="=&gt; TypeConstraints.this.ClassSymbol">AnyClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a><span title="String(&quot; addHiBound &quot;)"> addHiBound $</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.bound" title="TypeConstraints.this.Type">bound</a><span title="String(&quot;.instantiateTypeParams(&quot;)">.instantiateTypeParams($</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tparams" title="List[TypeConstraints.this.Symbol]">tparams</a><span title="String(&quot;, &quot;)">, $</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tvars" title="List[TypeConstraints.this.TypeVar]">tvars</a><span title="String(&quot;)&quot;)" class="string">)&quot;</span><span class="delimiter">)</span>
              <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a> <a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.addHiBound" title="(tp: TypeConstraints.this.Type, isNumericBound: Boolean)Unit">addHiBound</a> <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.bound" title="TypeConstraints.this.Type">bound</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[TypeConstraints.this.Symbol], actuals: List[TypeConstraints.this.Type])TypeConstraints.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tparams" title="List[TypeConstraints.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tvars" title="List[TypeConstraints.this.TypeVar]">tvars</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            for <span class="delimiter">(</span><span title="TypeConstraints.this.Symbol">tparam2</span> &lt;- <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: TypeConstraints.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
              <span title="TypeConstraints.this.Symbol">tparam2</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; TypeConstraints.this.Type">info</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.bounds" title="=&gt; TypeConstraints.this.TypeBounds">bounds</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeBounds.lo" title="=&gt; TypeConstraints.this.Type">lo</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.dealias" title="=&gt; TypeConstraints.this.Type">dealias</a> match <span class="delimiter">{</span>
                case TypeRef<span class="delimiter">(</span>_, <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tparam" title="TypeConstraints.this.Symbol">`tparam`</a>, _<span class="delimiter">)</span> =&gt;
                  <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a><span title="String(&quot; addHiBound &quot;)"> addHiBound $</span><span title="TypeConstraints.this.Symbol">tparam2</span><span title="String(&quot;.tpeHK.instantiateTypeParams(&quot;)">.tpeHK.instantiateTypeParams($</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tparams" title="List[TypeConstraints.this.Symbol]">tparams</a><span title="String(&quot;, &quot;)">, $</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tvars" title="List[TypeConstraints.this.TypeVar]">tvars</a><span title="String(&quot;)&quot;)" class="string">)&quot;</span><span class="delimiter">)</span>
                  <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a> <a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.addHiBound" title="(tp: TypeConstraints.this.Type, isNumericBound: Boolean)Unit">addHiBound</a> <span title="TypeConstraints.this.Symbol">tparam2</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpeHK" title="=&gt; TypeConstraints.this.Type">tpeHK</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[TypeConstraints.this.Symbol], actuals: List[TypeConstraints.this.Type])TypeConstraints.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tparams" title="List[TypeConstraints.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tvars" title="List[TypeConstraints.this.TypeVar]">tvars</a><span class="delimiter">)</span>
                case _ =&gt;
              <span class="delimiter">}</span>
          <span class="delimiter">}</span> else <span class="delimiter">{</span>
            if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.bound" title="TypeConstraints.this.Type">bound</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; TypeConstraints.this.Symbol">typeSymbol</a> <span title="(x$1: Any)Boolean">!=</span> <a href="../Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.NothingClass" title="TypeConstraints.this.definitions.NothingClass.type">NothingClass</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.bound" title="TypeConstraints.this.Type">bound</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; TypeConstraints.this.Symbol">typeSymbol</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tparam" title="TypeConstraints.this.Symbol">tparam</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a><span title="String(&quot; addLoBound &quot;)"> addLoBound $</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.bound" title="TypeConstraints.this.Type">bound</a><span title="String(&quot;.instantiateTypeParams(&quot;)">.instantiateTypeParams($</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tparams" title="List[TypeConstraints.this.Symbol]">tparams</a><span title="String(&quot;, &quot;)">, $</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tvars" title="List[TypeConstraints.this.TypeVar]">tvars</a><span title="String(&quot;)&quot;)" class="string">)&quot;</span><span class="delimiter">)</span>
              <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a> <a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.addLoBound" title="(tp: TypeConstraints.this.Type, isNumericBound: Boolean)Unit">addLoBound</a> <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.bound" title="TypeConstraints.this.Type">bound</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[TypeConstraints.this.Symbol], actuals: List[TypeConstraints.this.Type])TypeConstraints.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tparams" title="List[TypeConstraints.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tvars" title="List[TypeConstraints.this.TypeVar]">tvars</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            for <span class="delimiter">(</span><span title="TypeConstraints.this.Symbol">tparam2</span> &lt;- <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: TypeConstraints.this.Symbol =&gt; Unit)Unit">tparams</a><span class="delimiter">)</span>
              <span title="TypeConstraints.this.Symbol">tparam2</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; TypeConstraints.this.Type">info</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.bounds" title="=&gt; TypeConstraints.this.TypeBounds">bounds</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; TypeConstraints.this.Type">hi</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.dealias" title="=&gt; TypeConstraints.this.Type">dealias</a> match <span class="delimiter">{</span>
                case TypeRef<span class="delimiter">(</span>_, <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tparam" title="TypeConstraints.this.Symbol">`tparam`</a>, _<span class="delimiter">)</span> =&gt;
                  <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a><span title="String(&quot; addLoBound &quot;)"> addLoBound $</span><span title="TypeConstraints.this.Symbol">tparam2</span><span title="String(&quot;.tpeHK.instantiateTypeParams(&quot;)">.tpeHK.instantiateTypeParams($</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tparams" title="List[TypeConstraints.this.Symbol]">tparams</a><span title="String(&quot;, &quot;)">, $</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tvars" title="List[TypeConstraints.this.TypeVar]">tvars</a><span title="String(&quot;)&quot;)" class="string">)&quot;</span><span class="delimiter">)</span>
                  <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a> <a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.addLoBound" title="(tp: TypeConstraints.this.Type, isNumericBound: Boolean)Unit">addLoBound</a> <span title="TypeConstraints.this.Symbol">tparam2</span>.<a href="../Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpeHK" title="=&gt; TypeConstraints.this.Type">tpeHK</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[TypeConstraints.this.Symbol], actuals: List[TypeConstraints.this.Type])TypeConstraints.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tparams" title="List[TypeConstraints.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tvars" title="List[TypeConstraints.this.TypeVar]">tvars</a><span class="delimiter">)</span>
                case _ =&gt;
              <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; TypeConstraints.this.TypeConstraint">constr</a>.<a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst_=" title="(x$1: TypeConstraints.this.Type)Unit">inst</a> = <a href="../Types.scala.html#scala.reflect.internal;Types.NoType" title="TypeConstraints.this.NoType.type">NoType</a> <span class="comment">// necessary because hibounds/lobounds may contain tvar</span>

        <span class="comment">//println(&quot;solving &quot;+tvar+&quot; &quot;+up+&quot; &quot;+(if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds)+((if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds) map (_.widen)))</span>
        val <a title="TypeConstraints.this.Type" id="scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.newInst">newInst</a> = <span class="delimiter">(</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.up" title="Boolean">up</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.depth" title="scala.reflect.internal.Depth">depth</a>.<a href="../Depth.scala.html#scala.reflect.internal;Depth.isAnyDepth" title="=&gt; Boolean">isAnyDepth</a><span class="delimiter">)</span> <a href="GlbLubs.scala.html#scala.reflect.internal.tpe;GlbLubs.glb(d5711a700e)" title="(ts: List[TypeConstraints.this.Type])TypeConstraints.this.Type">glb</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; TypeConstraints.this.TypeConstraint">constr</a>.<a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.hiBounds" title="=&gt; List[TypeConstraints.this.Type]">hiBounds</a><span class="delimiter">)</span>
            else <a href="GlbLubs.scala.html#scala.reflect.internal.tpe;GlbLubs.glb(f19b6da1b5)" title="(ts: List[TypeConstraints.this.Type], depth: scala.reflect.internal.Depth)TypeConstraints.this.Type">glb</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; TypeConstraints.this.TypeConstraint">constr</a>.<a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.hiBounds" title="=&gt; List[TypeConstraints.this.Type]">hiBounds</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          else <span class="delimiter">{</span>
            if <span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.depth" title="scala.reflect.internal.Depth">depth</a>.<a href="../Depth.scala.html#scala.reflect.internal;Depth.isAnyDepth" title="=&gt; Boolean">isAnyDepth</a><span class="delimiter">)</span> <a href="GlbLubs.scala.html#scala.reflect.internal.tpe;GlbLubs.lub(d5711a700e)" title="(ts: List[TypeConstraints.this.Type])TypeConstraints.this.Type">lub</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; TypeConstraints.this.TypeConstraint">constr</a>.<a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.loBounds" title="=&gt; List[TypeConstraints.this.Type]">loBounds</a><span class="delimiter">)</span>
            else <a href="GlbLubs.scala.html#scala.reflect.internal.tpe;GlbLubs.lub(f19b6da1b5)" title="(ts: List[TypeConstraints.this.Type], depth: scala.reflect.internal.Depth)TypeConstraints.this.Type">lub</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; TypeConstraints.this.TypeConstraint">constr</a>.<a href="#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.loBounds" title="=&gt; List[TypeConstraints.this.Type]">loBounds</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <span class="delimiter">)</span>

        <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a><span title="String(&quot; setInst &quot;)"> setInst $</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.newInst" title="TypeConstraints.this.Type">newInst</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
        <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.tvar" title="TypeConstraints.this.TypeVar">tvar</a> <a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.setInst" title="(tp: TypeConstraints.this.Type)tvar.type">setInst</a> <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne.newInst" title="TypeConstraints.this.Type">newInst</a>
        <span class="comment">//Console.println(&quot;solving &quot;+tvar+&quot; &quot;+up+&quot; &quot;+(if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds)+((if (up) (tvar.constr.hiBounds) else tvar.constr.loBounds) map (_.widen))+&quot; = &quot;+tvar.constr.inst)//@MDEBUG</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">// println(&quot;solving &quot;+tvars+&quot;/&quot;+tparams+&quot;/&quot;+(tparams map (_.info)))</span>
    <a href="../util/Collections.scala.html#scala.reflect.internal.util;Collections.foreach3" title="(xs1: List[TypeConstraints.this.TypeVar], xs2: List[TypeConstraints.this.Symbol], xs3: List[scala.reflect.internal.Variance])(f: (TypeConstraints.this.TypeVar, TypeConstraints.this.Symbol, scala.reflect.internal.Variance) =&gt; Unit)Unit">foreach3</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tvars" title="List[TypeConstraints.this.TypeVar]">tvars</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tparams" title="List[TypeConstraints.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.variances" title="List[scala.reflect.internal.Variance]">variances</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.solveOne" title="(tvar: TypeConstraints.this.TypeVar, tparam: TypeConstraints.this.Symbol, variance: scala.reflect.internal.Variance)Unit">solveOne</a><span class="delimiter">)</span>

    def <a title="(tv: TypeConstraints.this.TypeVar)Unit" id="scala.reflect.internal.tpe;TypeConstraints.solve.logBounds">logBounds</a><span class="delimiter">(</span><a title="TypeConstraints.this.TypeVar" id="scala.reflect.internal.tpe;TypeConstraints.solve.logBounds.tv">tv</a>: <a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar" title="TypeConstraints.this.TypeVar">TypeVar</a><span class="delimiter">)</span> = <a href="../SymbolTable.scala.html#scala.reflect.internal;SymbolTable.log" title="(msg: =&gt; AnyRef)Unit">log</a> <span class="delimiter">{</span>
      val <a title="String" id="scala.reflect.internal.tpe;TypeConstraints.solve.logBounds.what">what</a> = if <span class="delimiter">(</span><a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.logBounds.tv" title="TypeConstraints.this.TypeVar">tv</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.instValid" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <span title="String(&quot;is invalid&quot;)" class="string">&quot;is invalid&quot;</span> else <a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;does not conform to bounds: &quot;)">does not conform to bounds: $</span><span class="delimiter">{</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.logBounds.tv" title="TypeConstraints.this.TypeVar">tv</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; TypeConstraints.this.TypeConstraint">constr</a><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span>
      <a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;Inferred type for &quot;)">Inferred type for $</span><span class="delimiter">{</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.logBounds.tv" title="TypeConstraints.this.TypeVar">tv</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.originString" title="=&gt; String">originString</a><span class="delimiter">}</span><span title="String(&quot; (&quot;)"> ($</span><span class="delimiter">{</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.logBounds.tv" title="TypeConstraints.this.TypeVar">tv</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.inst" title="=&gt; TypeConstraints.this.Type">inst</a><span class="delimiter">}</span><span title="String(&quot;) &quot;)">) $</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.logBounds.what" title="String">what</a><span title="String(&quot;&quot;)" class="string">&quot;</span>
    <span class="delimiter">}</span>

    <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.tvars" title="List[TypeConstraints.this.TypeVar]">tvars</a> <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: TypeConstraints.this.TypeVar =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a title="TypeConstraints.this.TypeVar" id="scala.reflect.internal.tpe;TypeConstraints.solve.$anonfun.tv">tv</a> =&gt; <a href="#scala.reflect.internal.tpe;TypeConstraints.solve.$anonfun.tv" title="TypeConstraints.this.TypeVar">tv</a>.<a href="../Types.scala.html#scala.reflect.internal;Types;TypeVar.instWithinBounds" title="=&gt; Boolean">instWithinBounds</a> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> util.<a href="../util/package.scala.html#scala.reflect.internal.util.package.andFalse" title="(body: Unit)Boolean">andFalse</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.logBounds" title="(tv: TypeConstraints.this.TypeVar)Unit">logBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal.tpe;TypeConstraints.solve.$anonfun.tv" title="TypeConstraints.this.TypeVar">tv</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

private<span class="delimiter">[</span>internal<span class="delimiter">]</span> object <a title="scala.reflect.internal.tpe.TypeConstraints.type" id="scala.reflect.internal.tpe.TypeConstraints">TypeConstraints</a> <a href="#scala.reflect.internal.tpe.TypeConstraints" title="scala.reflect.internal.tpe.TypeConstraints.type" class="delimiter">{</a>
  <span class="comment">// UndoPair is declared in companion object to not hold an outer pointer reference</span>
  final case class <a href="#scala.reflect.internal.tpe.TypeConstraints;UndoPair.productElement.x$1" title="class UndoPair[TypeVar &lt;: scala.reflect.internal.SymbolTable#TypeVar, TypeConstraint &lt;: scala.reflect.internal.tpe.TypeConstraints#TypeConstraint] extends AnyRef with Product with Serializable" id="scala.reflect.internal.tpe.TypeConstraints.UndoPair.readResolve">UndoPair</a><span class="delimiter">[</span><a title=" &lt;: scala.reflect.internal.SymbolTable#TypeVar" id="scala.reflect.internal.tpe.TypeConstraints;UndoPair;TypeVar">TypeVar</a> &lt;: SymbolTable#TypeVar,
    <a title=" &lt;: scala.reflect.internal.tpe.TypeConstraints#TypeConstraint" id="scala.reflect.internal.tpe.TypeConstraints;UndoPair;TypeConstraint">TypeConstraint</a> &lt;: TypeConstraints#TypeConstraint<span class="delimiter">]</span><a href="../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="TypeVar" id="scala.reflect.internal.tpe.TypeConstraints;UndoPair.tv">tv</a>: <a href="#scala.reflect.internal.tpe.TypeConstraints;UndoPair;TypeVar" title="TypeVar">TypeVar</a>, <a title="TypeConstraint" id="scala.reflect.internal.tpe.TypeConstraints;UndoPair.tConstraint">tConstraint</a>: <a href="#scala.reflect.internal.tpe.TypeConstraints;UndoPair;TypeConstraint" title="TypeConstraint">TypeConstraint</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
