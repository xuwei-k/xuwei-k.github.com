<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/reflect/internal/Types.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* NSC -- new Scala compiler
 * Copyright 2005-2013 LAMP/EPFL
 * @author  Martin Odersky
 */</span>

package scala
package reflect
package internal

import scala.collection.<span class="delimiter">{</span> mutable, immutable, generic <span class="delimiter">}</span>
import scala.ref.WeakReference
import mutable.ListBuffer
import <a href="Flags.scala.html#scala.reflect.internal.Flags" title="scala.reflect.internal.Flags.type">Flags</a>._
import scala.util.control.ControlThrowable
import scala.annotation.tailrec
import util.Statistics
import util.<a href="util/ThreeValues.scala.html#scala.reflect.internal.util.ThreeValues" title="scala.reflect.internal.util.ThreeValues.type">ThreeValues</a>._
import <a href="Variance.scala.html#scala.reflect.internal.Variance" title="scala.reflect.internal.Variance.type">Variance</a>._
import <a href="Depth.scala.html#scala.reflect.internal.Depth" title="scala.reflect.internal.Depth.type">Depth</a>._
import <a href="#scala.reflect.internal.TypeConstants" title="scala.reflect.internal.TypeConstants.type">TypeConstants</a>._

<span class="comment">/* A standard type pattern match:
  case ErrorType =&gt;
    // internal: error
  case WildcardType =&gt;
    // internal: unknown
  case BoundedWildcardType(bounds) =&gt;
    // internal: unknown
  case NoType =&gt;
  case NoPrefix =&gt;
  case ThisType(sym) =&gt;
    // sym.this.type
  case SuperType(thistpe, supertpe) =&gt;
    // super references
  case SingleType(pre, sym) =&gt;
    // pre.sym.type
  case ConstantType(value) =&gt;
    // Int(2)
  case TypeRef(pre, sym, args) =&gt;
    // pre.sym[targs]
    // Outer.this.C would be represented as TypeRef(ThisType(Outer), C, List())
  case RefinedType(parents, defs) =&gt;
    // parent1 with ... with parentn { defs }
  case ExistentialType(tparams, result) =&gt;
    // result forSome { tparams }
  case AnnotatedType(annots, tp) =&gt;
    // tp @annots

  // the following are non-value types; you cannot write them down in Scala source.

  case TypeBounds(lo, hi) =&gt;
    // &gt;: lo &lt;: hi
  case ClassInfoType(parents, defs, clazz) =&gt;
    // same as RefinedType except as body of class
  case MethodType(paramtypes, result) =&gt;
    // (paramtypes)result
    // For instance def m(): T is represented as MethodType(List(), T)
  case NullaryMethodType(result) =&gt; // eliminated by uncurry
    // an eval-by-name type
    // For instance def m: T is represented as NullaryMethodType(T)
  case PolyType(tparams, result) =&gt;
    // [tparams]result where result is a (Nullary)MethodType or ClassInfoType

  // The remaining types are not used after phase `typer`.
  case OverloadedType(pre, tparams, alts) =&gt;
    // all alternatives of an overloaded ident
  case AntiPolyType(pre, targs) =&gt;
    // rarely used, disappears when combined with a PolyType
  case TypeVar(inst, constr) =&gt;
    // a type variable
    // Replace occurrences of type parameters with type vars, where
    // inst is the instantiation and constr is a list of bounds.
  case ErasedValueType(clazz, underlying)
    // only used during erasure of derived value classes.
*/</span>

trait <a title="trait Types extends AnyRef with scala.reflect.api.Types with scala.reflect.internal.tpe.TypeComparers with scala.reflect.internal.tpe.TypeToStrings with scala.reflect.internal.tpe.CommonOwners with scala.reflect.internal.tpe.GlbLubs with scala.reflect.internal.tpe.TypeMaps with scala.reflect.internal.tpe.TypeConstraints with scala.reflect.internal.tpe.FindMembers with scala.reflect.internal.util.Collections" id="scala.reflect.internal;Types">Types</a>
  extends api.<a href="../api/Types.scala.html#scala.reflect.api;Types" title="scala.reflect.api.Types">Types</a>
  with tpe.<a href="tpe/TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers" title="scala.reflect.internal.tpe.TypeComparers">TypeComparers</a>
  with tpe.<a href="tpe/TypeToStrings.scala.html#scala.reflect.internal.tpe;TypeToStrings" title="scala.reflect.internal.tpe.TypeToStrings">TypeToStrings</a>
  with tpe.<a href="tpe/CommonOwners.scala.html#scala.reflect.internal.tpe;CommonOwners" title="scala.reflect.internal.tpe.CommonOwners">CommonOwners</a>
  with tpe.<a href="tpe/GlbLubs.scala.html#scala.reflect.internal.tpe;GlbLubs" title="scala.reflect.internal.tpe.GlbLubs">GlbLubs</a>
  with tpe.<a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps" title="scala.reflect.internal.tpe.TypeMaps">TypeMaps</a>
  with tpe.<a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints" title="scala.reflect.internal.tpe.TypeConstraints">TypeConstraints</a>
  with tpe.<a href="tpe/FindMembers.scala.html#scala.reflect.internal.tpe;FindMembers" title="scala.reflect.internal.tpe.FindMembers">FindMembers</a>
  with util.<a href="util/Collections.scala.html#scala.reflect.internal.util;Collections" title="scala.reflect.internal.util.Collections">Collections</a> <span class="delimiter">{</span> self: SymbolTable =&gt;

  import <a href="Definitions.scala.html#scala.reflect.internal;Definitions.definitions" title="Types.this.definitions.type">definitions</a>._
  import <a href="#scala.reflect.internal.TypesStats" title="scala.reflect.internal.TypesStats.type">TypesStats</a>._

  private var <a title="Boolean" id="scala.reflect.internal;Types.explainSwitch_=">explainSwitch</a> = false
  private final val <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="scala.reflect.internal;Types.emptySymbolSet">emptySymbolSet</a> = immutable.<a href="../../collection/immutable/Set.scala.html#scala.collection.immutable.Set" title="scala.collection.immutable.Set.type">Set</a>.<a href="../../collection/generic/ImmutableSetFactory.scala.html#scala.collection.generic;ImmutableSetFactory.empty" title="[A]=&gt; scala.collection.immutable.Set[A]">empty</a><span title="scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span>

  private final val traceTypeVars = sys.<a href="../../sys/package.scala.html#scala.sys.package.props" title="=&gt; scala.sys.SystemProperties">props</a> <a href="../../sys/SystemProperties.scala.html#scala.sys;SystemProperties.contains" title="Boolean" id="scala.reflect.internal;Types.traceTypeVars">contains</a> <span title="String(&quot;scalac.debug.tvar&quot;)" class="string">&quot;scalac.debug.tvar&quot;</span>
  private final val <a title="Boolean" id="scala.reflect.internal;Types.breakCycles">breakCycles</a> = <a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings;MutableSettings.breakCycles" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">breakCycles</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings;MutableSettings;SettingValue.value" title="=&gt; Boolean">value</a>
  <span class="comment">/** In case anyone wants to turn on type parameter bounds being used
   *  to seed type constraints.
   */</span>
  private final val propagateParameterBoundsToTypeVars = sys.<a href="../../sys/package.scala.html#scala.sys.package.props" title="=&gt; scala.sys.SystemProperties">props</a> <a href="../../sys/SystemProperties.scala.html#scala.sys;SystemProperties.contains" title="Boolean" id="scala.reflect.internal;Types.propagateParameterBoundsToTypeVars">contains</a> <span title="String(&quot;scalac.debug.prop-constraints&quot;)" class="string">&quot;scalac.debug.prop-constraints&quot;</span>
  private final val sharperSkolems = sys.<a href="../../sys/package.scala.html#scala.sys.package.props" title="=&gt; scala.sys.SystemProperties">props</a> <a href="../../sys/SystemProperties.scala.html#scala.sys;SystemProperties.contains" title="Boolean" id="scala.reflect.internal;Types.sharperSkolems">contains</a> <span title="String(&quot;scalac.experimental.sharper-skolems&quot;)" class="string">&quot;scalac.experimental.sharper-skolems&quot;</span>

  protected val <a title="Boolean" id="scala.reflect.internal;Types.enableTypeVarExperimentals">enableTypeVarExperimentals</a> = <a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings;MutableSettings.Xexperimental" title="=&gt; scala.reflect.internal.settings.MutableSettings#BooleanSetting">Xexperimental</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings;MutableSettings;SettingValue.value" title="=&gt; Boolean">value</a>

  <span class="comment">/** Caching the most recent map has a 75-90% hit rate. */</span>
  private object <a title="Types.this.substTypeMapCache.type" id="scala.reflect.internal;Types.substTypeMapCache">substTypeMapCache</a> <a href="#scala.reflect.internal;Types.substTypeMapCache" title="Types.this.substTypeMapCache.type" class="delimiter">{</a>
    private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="Types.this.SubstTypeMap" id="scala.reflect.internal;Types.substTypeMapCache.cached">cached</a>: <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap" title="Types.this.SubstTypeMap">SubstTypeMap</a> = new <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap" title="Types.this.SubstTypeMap">SubstTypeMap</a><span class="delimiter">(</span><a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>

    def <a title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.SubstTypeMap" id="scala.reflect.internal;Types.substTypeMapCache.apply">apply</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.substTypeMapCache.apply.from">from</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.substTypeMapCache.apply.to">to</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap" title="Types.this.SubstTypeMap">SubstTypeMap</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.substTypeMapCache.cached" title="Types.this.SubstTypeMap">cached</a>.<a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.from" title="=&gt; List[Types.this.Symbol]">from</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types.substTypeMapCache.apply.from" title="List[Types.this.Symbol]">from</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.substTypeMapCache.cached" title="Types.this.SubstTypeMap">cached</a>.<a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap.to" title="=&gt; List[Types.this.Type]">to</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types.substTypeMapCache.apply.to" title="List[Types.this.Type]">to</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types.substTypeMapCache.cached" title="Types.this.SubstTypeMap">cached</a> = new <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap" title="Types.this.SubstTypeMap">SubstTypeMap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.substTypeMapCache.apply.from" title="List[Types.this.Symbol]">from</a>, <a href="#scala.reflect.internal;Types.substTypeMapCache.apply.to" title="List[Types.this.Type]">to</a><span class="delimiter">)</span>

      <a href="#scala.reflect.internal;Types.substTypeMapCache.cached" title="Types.this.SubstTypeMap">cached</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The current skolemization level, needed for the algorithms
   *  in isSameType, isSubType that do constraint solving under a prefix.
   */</span>
  private var <a title="Int" id="scala.reflect.internal;Types._skolemizationLevel_=">_skolemizationLevel</a> = <span title="Int(0)" class="int">0</span>
  def <a title="=&gt; Int" id="scala.reflect.internal;Types.skolemizationLevel">skolemizationLevel</a> = <a href="#scala.reflect.internal;Types._skolemizationLevel_=" title="=&gt; Int">_skolemizationLevel</a>
  def <a title="(value: Int)Unit" id="scala.reflect.internal;Types.skolemizationLevel_=">skolemizationLevel_=</a><span class="delimiter">(</span><a title="Int" id="scala.reflect.internal;Types.skolemizationLevel_=.value">value</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types._skolemizationLevel_=" title="(x$1: Int)Unit">_skolemizationLevel</a> = <a href="#scala.reflect.internal;Types.skolemizationLevel_=.value" title="Int">value</a>

  <span class="comment">/** A map from lists to compound types that have the given list as parents.
   *  This is used to avoid duplication in the computation of base type sequences and baseClasses.
   *  It makes use of the fact that these two operations depend only on the parents,
   *  not on the refinement.
   */</span>
  private val <a title="scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]" id="scala.reflect.internal;Types._intersectionWitness">_intersectionWitness</a> = <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.perRunCaches" title="Types.this.perRunCaches.type">perRunCaches</a>.<a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.perRunCaches.newWeakMap" title="[K, V]()scala.collection.mutable.WeakHashMap[K,V]">newWeakMap</a><span title="()scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]" class="delimiter">[</span><a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a href="../../ref/WeakReference.scala.html#scala.ref;WeakReference" title="scala.ref.WeakReference[Types.this.Type]">WeakReference</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
  def <a title="=&gt; scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]" id="scala.reflect.internal;Types.intersectionWitness">intersectionWitness</a> = <a href="#scala.reflect.internal;Types._intersectionWitness" title="=&gt; scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]">_intersectionWitness</a>

  <span class="comment">/** A proxy for a type (identified by field `underlying`) that forwards most
   *  operations to it (for exceptions, see WrappingProxy, which forwards even more operations).
   *  every operation that is overridden for some kind of types should be forwarded.
   */</span>
  trait <a title="trait SimpleTypeProxy extends Types.this.Type" id="scala.reflect.internal;Types;SimpleTypeProxy">SimpleTypeProxy</a> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;SimpleTypeProxy.underlying">underlying</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">// the following operations + those in RewrappingTypeProxy are all operations</span>
    <span class="comment">// in class Type that are overridden in some subclass</span>
    <span class="comment">// Important to keep this up-to-date when new operations are added!</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;SimpleTypeProxy.isTrivial">isTrivial</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.isTrivial" title="=&gt; Boolean">isTrivial</a>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;SimpleTypeProxy.isHigherKinded">isHigherKinded</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;SimpleTypeProxy.typeConstructor">typeConstructor</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.typeConstructor" title="=&gt; Types.this.Type">typeConstructor</a>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;SimpleTypeProxy.isError">isError</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.isError" title="=&gt; Boolean">isError</a>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;SimpleTypeProxy.isErroneous">isErroneous</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.isErroneous" title="=&gt; Boolean">isErroneous</a>
    override def <a title="=&gt; Int" id="scala.reflect.internal;Types;SimpleTypeProxy.paramSectionCount">paramSectionCount</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.paramSectionCount" title="=&gt; Int">paramSectionCount</a>
    override def <a title="=&gt; List[List[Types.this.Symbol]]" id="scala.reflect.internal;Types;SimpleTypeProxy.paramss">paramss</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.paramss" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;SimpleTypeProxy.params">params</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.params" title="=&gt; List[Types.this.Symbol]">params</a>
    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;SimpleTypeProxy.paramTypes">paramTypes</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.paramTypes" title="=&gt; List[Types.this.Type]">paramTypes</a>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;SimpleTypeProxy.termSymbol">termSymbol</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.termSymbol" title="=&gt; Types.this.Symbol">termSymbol</a>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;SimpleTypeProxy.termSymbolDirect">termSymbolDirect</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.termSymbolDirect" title="=&gt; Types.this.Symbol">termSymbolDirect</a>
    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;SimpleTypeProxy.typeParams">typeParams</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>
    override def <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="scala.reflect.internal;Types;SimpleTypeProxy.boundSyms">boundSyms</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.boundSyms" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;SimpleTypeProxy.typeSymbol">typeSymbol</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;SimpleTypeProxy.typeSymbolDirect">typeSymbolDirect</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbolDirect" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;SimpleTypeProxy.widen">widen</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;SimpleTypeProxy.typeOfThis">typeOfThis</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.typeOfThis" title="=&gt; Types.this.Type">typeOfThis</a>
    override def <a title="=&gt; Types.this.TypeBounds" id="scala.reflect.internal;Types;SimpleTypeProxy.bounds">bounds</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.bounds" title="=&gt; Types.this.TypeBounds">bounds</a>
    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;SimpleTypeProxy.parents">parents</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;SimpleTypeProxy.prefix">prefix</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.prefix" title="=&gt; Types.this.Type">prefix</a>
    override def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types;SimpleTypeProxy.decls">decls</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a>
    override def <a title="(clazz: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;SimpleTypeProxy.baseType">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;SimpleTypeProxy.baseType.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.baseType" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;SimpleTypeProxy.baseType.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;SimpleTypeProxy.baseTypeSeq">baseTypeSeq</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    override def <a title="=&gt; scala.reflect.internal.Depth" id="scala.reflect.internal;Types;SimpleTypeProxy.baseTypeSeqDepth">baseTypeSeqDepth</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeqDepth" title="=&gt; scala.reflect.internal.Depth">baseTypeSeqDepth</a>
    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;SimpleTypeProxy.baseClasses">baseClasses</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.baseClasses" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A proxy for a type (identified by field `underlying`) that forwards most
   *  operations to it. Every operation that is overridden for some kind of types is
   *  forwarded here. Some operations are rewrapped again.
   */</span>
  trait <a title="trait RewrappingTypeProxy extends Types.this.Type with Types.this.SimpleTypeProxy" id="scala.reflect.internal;Types;RewrappingTypeProxy">RewrappingTypeProxy</a> extends <a href="#scala.reflect.internal;Types;SimpleTypeProxy" title="Types.this.SimpleTypeProxy">SimpleTypeProxy</a> <span class="delimiter">{</span>
    protected def <a title="(newtp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap">maybeRewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap.newtp">newtp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap.newtp" title="Types.this.Type">newtp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span> this
      <span class="comment">// BoundedWildcardTypes reach here during erroneous compilation: neg/t6258</span>
      <span class="comment">// Higher-kinded exclusion is because [x]CC[x] compares =:= to CC: pos/t3800</span>
      <span class="comment">// Otherwise, if newtp =:= underlying, don't rewrap it.</span>
      else if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap.newtp" title="Types.this.Type">newtp</a>.<a href="#scala.reflect.internal;Types;Type.isWildcard" title="=&gt; Boolean">isWildcard</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap.newtp" title="Types.this.Type">newtp</a>.<a href="#scala.reflect.internal;Types;Type.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap.newtp" title="Types.this.Type">newtp</a> <a href="#scala.reflect.internal;Types;Type.=:=" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span> this
      else <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.rewrap" title="(newtp: Types.this.Type)Types.this.Type">rewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap.newtp" title="Types.this.Type">newtp</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    protected def <a title="(newtp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.rewrap">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.rewrap.newtp">newtp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">// the following are all operations in class Type that are overridden in some subclass</span>
    <span class="comment">// Important to keep this up-to-date when new operations are added!</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.widen">widen</a> = <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.narrow">narrow</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.narrow" title="=&gt; Types.this.Type">narrow</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.deconst">deconst</a> = <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.deconst" title="=&gt; Types.this.Type">deconst</a><span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.resultType(9b9cdebb0f)">resultType</a> = <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.resultType(9b9cdebb0f)" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
    override def <a title="(actuals: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.resultType(01bbd0fc8a)">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types;RewrappingTypeProxy.resultType(01bbd0fc8a).actuals">actuals</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.resultType(01bbd0fc8a)" title="(actuals: List[Types.this.Type])Types.this.Type">resultType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RewrappingTypeProxy.resultType(01bbd0fc8a).actuals" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span><span class="delimiter">)</span>
    override def <a title="=&gt; Int" id="scala.reflect.internal;Types;RewrappingTypeProxy.paramSectionCount">paramSectionCount</a> = <span title="Int(0)" class="int">0</span>
    override def <a title="=&gt; List[List[Types.this.Symbol]]" id="scala.reflect.internal;Types;RewrappingTypeProxy.paramss">paramss</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Types.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;RewrappingTypeProxy.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;RewrappingTypeProxy.paramTypes">paramTypes</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;RewrappingTypeProxy.typeArgs">typeArgs</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a>
    override def <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.instantiateTypeParams">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;RewrappingTypeProxy.instantiateTypeParams.formals">formals</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;RewrappingTypeProxy.instantiateTypeParams.actuals">actuals</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RewrappingTypeProxy.instantiateTypeParams.formals" title="List[Types.this.Symbol]">formals</a>, <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.instantiateTypeParams.actuals" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
    override def <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.skolemizeExistential(3dd66220a2)">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;RewrappingTypeProxy.skolemizeExistential(3dd66220a2).owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="scala.reflect.internal;Types;RewrappingTypeProxy.skolemizeExistential(3dd66220a2).origin">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.skolemizeExistential(3dd66220a2)" title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type">skolemizeExistential</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RewrappingTypeProxy.skolemizeExistential(3dd66220a2).owner" title="Types.this.Symbol">owner</a>, <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.skolemizeExistential(3dd66220a2).origin" title="AnyRef">origin</a><span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.normalize">normalize</a> = <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.etaExpand">etaExpand</a> = <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.etaExpand" title="=&gt; Types.this.Type">etaExpand</a><span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.dealias">dealias</a> = <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.dealias" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>
    override def <a title="(owner: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.cloneInfo">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;RewrappingTypeProxy.cloneInfo.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.cloneInfo" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RewrappingTypeProxy.cloneInfo.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    override def <a title="(owner: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.atOwner">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;RewrappingTypeProxy.atOwner.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.atOwner" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RewrappingTypeProxy.atOwner.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;RewrappingTypeProxy.prefixString">prefixString</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.prefixString" title="=&gt; String">prefixString</a>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;RewrappingTypeProxy.isComplete">isComplete</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.isComplete" title="=&gt; Boolean">isComplete</a>
    override def <a title="(sym: Types.this.Symbol)Unit" id="scala.reflect.internal;Types;RewrappingTypeProxy.complete">complete</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;RewrappingTypeProxy.complete.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.complete" title="(sym: Types.this.Symbol)Unit">complete</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RewrappingTypeProxy.complete.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    override def <a title="(sym: Types.this.Symbol)Unit" id="scala.reflect.internal;Types;RewrappingTypeProxy.load">load</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;RewrappingTypeProxy.load.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.load" title="(sym: Types.this.Symbol)Unit">load</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RewrappingTypeProxy.load.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    override def <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.withAnnotations">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="scala.reflect.internal;Types;RewrappingTypeProxy.withAnnotations.annots">annots</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.withAnnotations" title="(annots: List[Types.this.AnnotationInfo])Types.this.Type">withAnnotations</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RewrappingTypeProxy.withAnnotations.annots" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span><span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;RewrappingTypeProxy.withoutAnnotations">withoutAnnotations</a> = <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.withoutAnnotations" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  case object <a href="#scala.reflect.internal;Types.UnmappableTree.productElement.x$1" title="Types.this.UnmappableTree.type" id="scala.reflect.internal;Types.UnmappableTree.readResolve">UnmappableTree</a> extends <a href="Trees.scala.html#scala.reflect.internal;Trees;TermTree" title="Types.this.TermTree">TermTree</a> <span class="delimiter">{</span>
    override def <a title="()String" id="scala.reflect.internal;Types.UnmappableTree.toString">toString</a> = <span title="String(&quot;&lt;unmappable&gt;&quot;)" class="string">&quot;&lt;unmappable&gt;&quot;</span>
    super.<a href="Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe_=" title="(t: Types.this.Type)Unit">tpe_=</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span>
    override def <a title="(t: Types.this.Type)Unit" id="scala.reflect.internal;Types.UnmappableTree.tpe_=">tpe_=</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.UnmappableTree.tpe_=.t">t</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.UnmappableTree.tpe_=.t" title="Types.this.Type">t</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      throw new <a href="../../package.scala.html#scala.package;UnsupportedOperationException" title="UnsupportedOperationException">UnsupportedOperationException</a><span class="delimiter">(</span><span title="String(&quot;tpe_=(&quot;)" class="string">&quot;tpe_=(&quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.reflect.internal;Types.UnmappableTree.tpe_=.t" title="Types.this.Type">t</a><span title="(x$1: Any)String">+</span><span title="String(&quot;) inapplicable for &lt;empty&gt;&quot;)" class="string">&quot;) inapplicable for &lt;empty&gt;&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  abstract class <a title="class TypeApiImpl extends Types.this.TypeApi" id="scala.reflect.internal;Types;TypeApiImpl">TypeApiImpl</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: Type =&gt;
    def <a title="(name: Types.this.Name)Types.this.Symbol" id="scala.reflect.internal;Types;TypeApiImpl.declaration">declaration</a><span class="delimiter">(</span><a title="Types.this.Name" id="scala.reflect.internal;Types;TypeApiImpl.declaration.name">name</a>: <a href="Names.scala.html#scala.reflect.internal;Names;Name" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <a href="#scala.reflect.internal;Types;Type.decl" title="(name: Types.this.Name)Types.this.Symbol">decl</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeApiImpl.declaration.name" title="Types.this.Name">name</a><span class="delimiter">)</span>
    def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types;TypeApiImpl.declarations">declarations</a> = <a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a>
    def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;TypeApiImpl.typeArguments">typeArguments</a> = <a href="#scala.reflect.internal;Types;Type.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;TypeApiImpl.erasure">erasure</a> = this match <span class="delimiter">{</span>
      case ConstantType<span class="delimiter">(</span><a title="Types.this.Constant" id="scala.reflect.internal;Types;TypeApiImpl.erasure.value">value</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a>.<a href="#scala.reflect.internal;Types;TypeApiImpl.erasure" title="=&gt; Types.this.Type">erasure</a>
      case _ =&gt;
        var <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeApiImpl.erasure.result">result</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="transform/Transforms.scala.html#scala.reflect.internal.transform;Transforms.transformedType(58e97526c5)" title="(tpe: Types.this.Type)_348.global.Type forSome { val _348: scala.reflect.internal.transform.PostErasure{val global: Types.this.type} }">transformedType</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;TypeApiImpl.erasure.result" title="Types.this.Type">result</a> = <a href="#scala.reflect.internal;Types;TypeApiImpl.erasure.result" title="Types.this.Type">result</a>.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a> match <span class="delimiter">{</span> <span class="comment">// necessary to deal with erasures of HK types, typeConstructor won't work</span>
          case PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;TypeApiImpl.erasure.undets">undets</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeApiImpl.erasure.underlying">underlying</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.existentialAbstraction" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeApiImpl.erasure.undets" title="List[Types.this.Symbol]">undets</a>, <a href="#scala.reflect.internal;Types;TypeApiImpl.erasure.underlying" title="Types.this.Type">underlying</a><span class="delimiter">)</span> <span class="comment">// we don't want undets in the result</span>
          case _ =&gt; <a href="#scala.reflect.internal;Types;TypeApiImpl.erasure.result" title="Types.this.Type">result</a>
        <span class="delimiter">}</span>
        <span class="comment">// erasure screws up all ThisTypes for modules into PackageTypeRefs</span>
        <span class="comment">// we need to unscrew them, or certain typechecks will fail mysteriously</span>
        <span class="comment">// http://groups.google.com/group/scala-internals/browse_thread/thread/6d3277ae21b6d581</span>
        <a href="#scala.reflect.internal;Types;TypeApiImpl.erasure.result" title="Types.this.Type">result</a> = <a href="#scala.reflect.internal;Types;TypeApiImpl.erasure.result" title="Types.this.Type">result</a>.<a href="#scala.reflect.internal;Types;Type.map" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.Type">map</a><span class="delimiter">(</span><span title="Types.this.Type">tpe</span> =&gt; <span title="Types.this.Type">tpe</span> match <span class="delimiter">{</span>
          case <span title="Types.this.PackageTypeRef">tpe</span>: <a href="#scala.reflect.internal;Types;PackageTypeRef" title="Types.this.PackageTypeRef">PackageTypeRef</a> =&gt; <a href="#scala.reflect.internal;Types.ThisType.apply(a489b0ed7a)" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><span title="Types.this.PackageTypeRef">tpe</span>.<a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
          case _ =&gt; <span title="Types.this.Type">tpe</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;TypeApiImpl.erasure.result" title="Types.this.Type">result</a>
    <span class="delimiter">}</span>
    def <a title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type" id="scala.reflect.internal;Types;TypeApiImpl.substituteSymbols">substituteSymbols</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;TypeApiImpl.substituteSymbols.from">from</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;TypeApiImpl.substituteSymbols.to">to</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;Type.substSym" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeApiImpl.substituteSymbols.from" title="List[Types.this.Symbol]">from</a>, <a href="#scala.reflect.internal;Types;TypeApiImpl.substituteSymbols.to" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span>
    def <a title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types;TypeApiImpl.substituteTypes">substituteTypes</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;TypeApiImpl.substituteTypes.from">from</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;TypeApiImpl.substituteTypes.to">to</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;Type.subst" title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeApiImpl.substituteTypes.from" title="List[Types.this.Symbol]">from</a>, <a href="#scala.reflect.internal;Types;TypeApiImpl.substituteTypes.to" title="List[Types.this.Type]">to</a><span class="delimiter">)</span>

    <span class="comment">// the only thingies that we want to splice are: 1) type parameters, 2) abstract type members</span>
    <span class="comment">// the thingies that we don't want to splice are: 1) concrete types (obviously), 2) existential skolems</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeApiImpl.isSpliceable">isSpliceable</a> = <span class="delimiter">{</span>
      this.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#scala.reflect.internal;Types;TypeRef" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">]</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAbstractType" title="=&gt; Boolean">isAbstractType</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;SymbolContextApiImpl.isExistential" title="=&gt; Boolean">isExistential</a>
    <span class="delimiter">}</span>

    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;TypeApiImpl.companion">companion</a> = <span class="delimiter">{</span>
      val <a title="Types.this.Symbol" id="scala.reflect.internal;Types;TypeApiImpl.companion.sym">sym</a> = <a href="#scala.reflect.internal;Types;Type.typeSymbolDirect" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeApiImpl.companion.sym" title="Types.this.Symbol">sym</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModule" title="=&gt; Boolean">isModule</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;TypeApiImpl.companion.sym" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#scala.reflect.internal;HasFlags.isPackage" title="=&gt; Boolean">isPackage</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeApiImpl.companion.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.companionSymbol" title="=&gt; Types.this.Symbol">companionSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; Types.this.Type">tpe</a>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeApiImpl.companion.sym" title="Types.this.Symbol">sym</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModuleClass" title="=&gt; Boolean">isModuleClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;TypeApiImpl.companion.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeApiImpl.companion.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.sourceModule" title="=&gt; Types.this.Symbol">sourceModule</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.companionSymbol" title="=&gt; Types.this.Symbol">companionSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; Types.this.Type">tpe</a>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeApiImpl.companion.sym" title="Types.this.Symbol">sym</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isClass" title="=&gt; Boolean">isClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;TypeApiImpl.companion.sym" title="Types.this.Symbol">sym</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModuleClass" title="=&gt; Boolean">isModuleClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;TypeApiImpl.companion.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeApiImpl.companion.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.companionSymbol" title="=&gt; Types.this.Symbol">companionSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>
      else <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
    <span class="delimiter">}</span>

    def <a title="=&gt; List[List[Types.this.Symbol]]" id="scala.reflect.internal;Types;TypeApiImpl.paramLists">paramLists</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Types.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;Type.paramss" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The base class for all types */</span>
  abstract class <a title="class Type extends Types.this.TypeApiImpl with Types.this.Annotatable[Types.this.Type]" id="scala.reflect.internal;Types;Type">Type</a> extends <a href="#scala.reflect.internal;Types;TypeApiImpl" title="Types.this.TypeApiImpl">TypeApiImpl</a> with <a href="AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;Annotatable" title="Types.this.Annotatable[Types.this.Type]">Annotatable</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="comment">/** Types for which asSeenFrom always is the identity, no matter what
     *  prefix or owner.
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;Type.isTrivial">isTrivial</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false

    <span class="comment">/** Is this type higher-kinded, i.e., is it a type constructor @M */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;Type.isHigherKinded">isHigherKinded</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;Type.takesTypeArgs">takesTypeArgs</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = this.<a href="#scala.reflect.internal;Types;Type.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a>

    <span class="comment">/** Does this type denote a stable reference (i.e. singleton type)? */</span>
    final def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;Type.isStable">isStable</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="Definitions.scala.html#scala.reflect.internal;Definitions.definitions" title="Types.this.definitions.type">definitions</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isStable" title="(tp: Types.this.Type)Boolean">isStable</a> this

    <span class="comment">/** Is this type dangerous (i.e. it might contain conflicting
     *  type information when empty, so that it can be constructed
     *  so that type unsoundness results.) A dangerous type has an underlying
     *  type of the form T_1 with T_n { decls }, where one of the
     *  T_i (i &gt; 1) is an abstract type.
     */</span>
    final def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;Type.isVolatile">isVolatile</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="Definitions.scala.html#scala.reflect.internal;Definitions.definitions" title="Types.this.definitions.type">definitions</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isVolatile" title="(tp: Types.this.Type)Boolean">isVolatile</a> this

    <span class="comment">/** Is this type a structural refinement type (it ''refines'' members that have not been inherited) */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;Type.isStructuralRefinement">isStructuralRefinement</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false

    <span class="comment">/** Does this type depend immediately on an enclosing method parameter?
      * I.e., is it a singleton type whose termSymbol refers to an argument of the symbol's owner (which is a method)?
      */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;Type.isImmediatelyDependent">isImmediatelyDependent</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false

    <span class="comment">/** Is this type a dependent method type? */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;Type.isDependentMethodType">isDependentMethodType</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false

    <span class="comment">/** True for WildcardType or BoundedWildcardType. */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;Type.isWildcard">isWildcard</a> = false

    <span class="comment">/** Is this type produced as a repair for an error? */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;Type.isError">isError</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isError" title="=&gt; Boolean">isError</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types;Type.termSymbol" title="=&gt; Types.this.Symbol">termSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isError" title="=&gt; Boolean">isError</a>

    <span class="comment">/** Is this type produced as a repair for an error? */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;Type.isErroneous">isErroneous</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps.ErroneousCollector" title="Types.this.ErroneousCollector.type">ErroneousCollector</a>.<a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeCollector.collect" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span>this<span class="delimiter">)</span>

    <span class="comment">/** Can this type only be subtyped by bottom types?
     *  This is assessed to be the case if the class is final,
     *  and all type parameters (if any) are invariant.
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;Type.isFinalType">isFinalType</a> = <a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.hasOnlyBottomSubclasses" title="=&gt; Boolean">hasOnlyBottomSubclasses</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;Type.prefix" title="=&gt; Types.this.Type">prefix</a>.<a href="#scala.reflect.internal;Types;Type.isStable" title="=&gt; Boolean">isStable</a>

    <span class="comment">/** Is this type completed (i.e. not a lazy type)? */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;Type.isComplete">isComplete</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = true

    <span class="comment">/** If this is a lazy type, assign a new type to `sym`. */</span>
    def <a title="(sym: Types.this.Symbol)Unit" id="scala.reflect.internal;Types;Type.complete">complete</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.complete.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>

    <span class="comment">/** The term symbol associated with the type
      * Note that the symbol of the normalized type is returned (@see normalize)
      */</span>
    def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;Type.termSymbol">termSymbol</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a>

    <span class="comment">/** The type symbol associated with the type
      * Note that the symbol of the normalized type is returned (@see normalize)
      * A type's typeSymbol should if possible not be inspected directly, due to
      * the likelihood that what is true for tp.typeSymbol is not true for
      * tp.sym, due to normalization.
      */</span>
    def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;Type.typeSymbol">typeSymbol</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a>

    <span class="comment">/** The term symbol ''directly'' associated with the type.
     */</span>
    def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;Type.termSymbolDirect">termSymbolDirect</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <a href="#scala.reflect.internal;Types;Type.termSymbol" title="=&gt; Types.this.Symbol">termSymbol</a>

    <span class="comment">/** The type symbol ''directly'' associated with the type.
     *  In other words, no normalization is performed: if this is an alias type,
     *  the symbol returned is that of the alias, not the underlying type.
     */</span>
    def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;Type.typeSymbolDirect">typeSymbolDirect</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>

    <span class="comment">/** The base type underlying a type proxy, identity on all other types */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.underlying">underlying</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = this

    <span class="comment">/** Widen from singleton type to its underlying non-singleton
     *  base type by applying one or more `underlying` dereferences,
     *  identity for all other types.
     *
     *  class Outer { class C ; val x: C }
     *  val o: Outer
     *  &lt;o.x.type&gt;.widen = o.C
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.widen">widen</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = this

    <span class="comment">/** Map a constant type or not-null-type to its underlying base type,
     *  identity for all other types.
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.deconst">deconst</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = this

    <span class="comment">/** The type of `this` of a class type or reference type. */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.typeOfThis">typeOfThis</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeOfThis" title="=&gt; Types.this.Type">typeOfThis</a>

    <span class="comment">/** Map to a singleton type which is a subtype of this type.
     *  The fallback implemented here gives
     *    T.narrow  = T' forSome { type T' &lt;: T with Singleton }
     *  Overridden where we know more about where types come from.
     */</span>
    <span class="comment">/*
    Note: this implementation of narrow is theoretically superior to the one
    in use below, but imposed a significant performance penalty.  It was in trunk
    from svn r24960 through r25080.
    */</span>
    <span class="comment">/*
    def narrow: Type =
      if (phase.erasedTypes) this
      else commonOwner(this) freshExistential &quot;.type&quot; setInfo singletonBounds(this) tpe
    */</span>

    <span class="comment">/** Map to a singleton type which is a subtype of this type.
     *  The fallback implemented here gives:
     *  {{{
     *    T.narrow  =  (T {}).this.type
     *  }}}
     *  Overridden where we know more about where types come from.
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.narrow">narrow</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> this
      else <span class="delimiter">{</span>
        val <a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.narrow.cowner">cowner</a> = <a href="tpe/CommonOwners.scala.html#scala.reflect.internal.tpe;CommonOwners.commonOwner(dba47c210f)" title="(t: Types.this.Type)Types.this.Symbol">commonOwner</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types.refinedType(b06f606da5)" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span>this <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#scala.reflect.internal;Types;Type.narrow.cowner" title="Types.this.Symbol">cowner</a>, <a href="Scopes.scala.html#scala.reflect.internal;Scopes.EmptyScope" title="Types.this.EmptyScope.type">EmptyScope</a>, <a href="#scala.reflect.internal;Types;Type.narrow.cowner" title="Types.this.Symbol">cowner</a>.<a href="StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.pos" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.narrow" title="=&gt; Types.this.Type">narrow</a>
      <span class="delimiter">}</span>

    <span class="comment">/** For a TypeBounds type, itself;
     *  for a reference denoting an abstract type, its bounds,
     *  for all other types, a TypeBounds type all of whose bounds are this type.
     */</span>
    def <a title="=&gt; Types.this.TypeBounds" id="scala.reflect.internal;Types;Type.bounds">bounds</a>: <a href="#scala.reflect.internal;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3)" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span>this, this<span class="delimiter">)</span>

    <span class="comment">/** For a class or intersection type, its parents.
     *  For a TypeBounds type, the parents of its hi bound.
     *  inherited by typerefs, singleton types, and refinement types,
     *  The empty list for all other types */</span>
    def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;Type.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    <span class="comment">/** For a class with nonEmpty parents, the first parent.
     *  Otherwise some specific fixed top type.
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.firstParent">firstParent</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Type">head</a> else <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ObjectTpe" title="=&gt; Types.this.Type">ObjectTpe</a>

    <span class="comment">/** For a typeref or single-type, the prefix of the normalized type (@see normalize).
     *  NoType for all other types. */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.prefix">prefix</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>

    <span class="comment">/** A chain of all typeref or singletype prefixes of this type, longest first.
     *  (Only used from safeToString.)
     */</span>
    def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;Type.prefixChain">prefixChain</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = this match <span class="delimiter">{</span>
      case TypeRef<span class="delimiter">(</span><span title="Types.this.Type">pre</span>, _, _<span class="delimiter">)</span> =&gt; <span title="Types.this.Type">pre</span> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <span title="Types.this.Type">pre</span>.<a href="#scala.reflect.internal;Types;Type.prefixChain" title="=&gt; List[Types.this.Type]">prefixChain</a>
      case SingleType<span class="delimiter">(</span><span title="Types.this.Type">pre</span>, _<span class="delimiter">)</span> =&gt; <span title="Types.this.Type">pre</span> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <span title="Types.this.Type">pre</span>.<a href="#scala.reflect.internal;Types;Type.prefixChain" title="=&gt; List[Types.this.Type]">prefixChain</a>
      case _ =&gt; List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** This type, without its type arguments @M */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.typeConstructor">typeConstructor</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = this

    <span class="comment">/** For a typeref, its arguments. The empty list for all other types */</span>
    def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;Type.typeArgs">typeArgs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    <span class="comment">/** A list of placeholder types derived from the type parameters.
     *  Used by RefinedType and TypeRef.
     */</span>
    protected def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;Type.dummyArgs">dummyArgs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;Type.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.dummyArgs.$anonfun.x$4" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeConstructor" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>

    <span class="comment">/** For a (nullary) method or poly type, its direct result type,
     *  the type itself for all other types. */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.resultType(9b9cdebb0f)">resultType</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = this

    def <a title="(actuals: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types;Type.resultType(01bbd0fc8a)">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types;Type.resultType(01bbd0fc8a).actuals">actuals</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = this

    <span class="comment">/** Only used for dependent method types. */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.resultApprox">resultApprox</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps.ApproximateDependentMap.apply" title="(tp: Types.this.Type)Types.this.Type">ApproximateDependentMap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.resultType(9b9cdebb0f)" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>

    <span class="comment">/** For a curried/nullary method or poly type its non-method result type,
     *  the type itself for all other types */</span>
    final def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.finalResultType">finalResultType</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="Definitions.scala.html#scala.reflect.internal;Definitions.definitions" title="Types.this.definitions.type">definitions</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.finalResultType" title="(tp: Types.this.Type)Types.this.Type">finalResultType</a> this

    <span class="comment">/** For a method type, the number of its value parameter sections,
     *  0 for all other types */</span>
    def <a title="=&gt; Int" id="scala.reflect.internal;Types;Type.paramSectionCount">paramSectionCount</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> = <span title="Int(0)" class="int">0</span>

    <span class="comment">/** For a method or poly type, a list of its value parameter sections,
     *  the empty list for all other types */</span>
    def <a title="=&gt; List[List[Types.this.Symbol]]" id="scala.reflect.internal;Types;Type.paramss">paramss</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Types.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    <span class="comment">/** For a method or poly type, its first value parameter section,
     *  the empty list for all other types */</span>
    def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    <span class="comment">/** For a method or poly type, the types of its first value parameter section,
     *  the empty list for all other types */</span>
    def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;Type.paramTypes">paramTypes</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    <span class="comment">/** For a (potentially wrapped) poly type, its type parameters,
     *  the empty list for all other types */</span>
    def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.typeParams">typeParams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    <span class="comment">/** For a (potentially wrapped) poly or existential type, its bound symbols,
     *  the empty list for all other types */</span>
    def <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.boundSyms">boundSyms</a>: immutable.<a href="../../collection/immutable/Set.scala.html#scala.collection.immutable;Set" title="scala.collection.immutable.Set[Types.this.Symbol]">Set</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types.emptySymbolSet" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">emptySymbolSet</a>

    <span class="comment">/** Replace formal type parameter symbols with actual type arguments.
     *
     * Amounts to substitution except for higher-kinded types. (See overridden method in TypeRef) -- @M
     */</span>
    def <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types;Type.instantiateTypeParams">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.instantiateTypeParams.formals">formals</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;Type.instantiateTypeParams.actuals">actuals</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.sameLength" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.instantiateTypeParams.formals" title="List[Types.this.Symbol]">formals</a>, <a href="#scala.reflect.internal;Types;Type.instantiateTypeParams.actuals" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span><span class="delimiter">)</span> this.<a href="#scala.reflect.internal;Types;Type.subst" title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type">subst</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.instantiateTypeParams.formals" title="List[Types.this.Symbol]">formals</a>, <a href="#scala.reflect.internal;Types;Type.instantiateTypeParams.actuals" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span> else <a href="#scala.reflect.internal;Types.ErrorType.readResolve" title="Types.this.ErrorType.type">ErrorType</a>

    <span class="comment">/** If this type is an existential, turn all existentially bound variables to type skolems.
     *  @param  owner    The owner of the created type skolems
     *  @param  origin   The tree whose type was an existential for which the skolem was created.
     */</span>
    def <a title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="scala.reflect.internal;Types;Type.skolemizeExistential(3dd66220a2)">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.skolemizeExistential(3dd66220a2).owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="scala.reflect.internal;Types;Type.skolemizeExistential(3dd66220a2).origin">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = this

    <span class="comment">/** A simple version of skolemizeExistential for situations where
     *  owner or unpack location do not matter (typically used in subtype tests)
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.skolemizeExistential(9b9cdebb0f)">skolemizeExistential</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;Type.skolemizeExistential(3dd66220a2)" title="(owner: Types.this.Symbol, origin: AnyRef)Types.this.Type">skolemizeExistential</a><span class="delimiter">(</span><a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a>, null<span class="delimiter">)</span>

    <span class="comment">/** Reduce to beta eta-long normal form.
     *  Expands type aliases and converts higher-kinded TypeRefs to PolyTypes.
     *  Functions on types are also implemented as PolyTypes.
     *
     *  Example: (in the below, `&lt;List&gt;` is the type constructor of List)
     *    TypeRef(pre, `&lt;List&gt;`, List()) is replaced by
     *    PolyType(X, TypeRef(pre, `&lt;List&gt;`, List(X)))
     *
     *  Discussion: normalize is NOT usually what you want to be calling.
     *  The (very real) danger with normalize is that it will force types
     *  which would not otherwise have been forced, leading to mysterious
     *  behavioral differences, cycles, and other elements of mysteries.
     *  Under most conditions the method you should be calling is `dealiasWiden`
     *  (see that method for more info.)
     *
     *  Here are a few of the side-effect-trail-leaving methods called
     *  by various implementations of normalize:
     *
     *   - sym.info
     *   - tpe.etaExpand
     *   - tpe.betaReduce
     *   - tpe.memberType
     *   - sym.nextOverriddenSymbol
     *   - constraint.inst
     *
     *  If you've been around the compiler a while that list must fill
     *  your heart with fear.
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.normalize">normalize</a> = this <span class="comment">// @MAT</span>

    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.etaExpand">etaExpand</a> = this

    <span class="comment">/** Expands type aliases. */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.dealias">dealias</a> = this

    <span class="comment">/** Repeatedly apply widen and dealias until they have no effect.
     *  This compensates for the fact that type aliases can hide beneath
     *  singleton types and singleton types can hide inside type aliases.
     *  !!! - and yet it is still inadequate, because aliases and singletons
     *  might lurk in the upper bounds of an abstract type. See SI-7051.
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.dealiasWiden">dealiasWiden</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a>.<a href="#scala.reflect.internal;Types;Type.dealiasWiden" title="=&gt; Types.this.Type">dealiasWiden</a>
      else if <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types;Type.dealias" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.dealias" title="=&gt; Types.this.Type">dealias</a>.<a href="#scala.reflect.internal;Types;Type.dealiasWiden" title="=&gt; Types.this.Type">dealiasWiden</a>
      else this
    <span class="delimiter">)</span>

    <span class="comment">/** All the types encountered in the course of dealiasing/widening,
     *  including each intermediate beta reduction step (whereas calling
     *  dealias applies as many as possible.)
     */</span>
    def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;Type.dealiasWidenChain">dealiasWidenChain</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = this <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <span class="delimiter">(</span>
      if <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a>.<a href="#scala.reflect.internal;Types;Type.dealiasWidenChain" title="=&gt; List[Types.this.Type]">dealiasWidenChain</a>
      else if <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types;Type.betaReduce" title="=&gt; Types.this.Type">betaReduce</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.betaReduce" title="=&gt; Types.this.Type">betaReduce</a>.<a href="#scala.reflect.internal;Types;Type.dealiasWidenChain" title="=&gt; List[Types.this.Type]">dealiasWidenChain</a>
      else <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
    <span class="delimiter">)</span>

    <span class="comment">/** Performs a single step of beta-reduction on types.
     *  Given:
     *
     *    type C[T] = B[T]
     *    type B[T] = A
     *    class A
     *
     *  The following will happen after `betaReduce` is invoked:
     *    TypeRef(pre, &lt;C&gt;, List(Int)) is replaced by
     *    TypeRef(pre, &lt;B&gt;, List(Int))
     *
     *  Unlike `dealias`, which recursively applies beta reduction, until it's stuck,
     *  `betaReduce` performs exactly one step and then returns.
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.betaReduce">betaReduce</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = this

    <span class="comment">/** For a classtype or refined type, its defined or declared members;
     *  inherited by subtypes and typerefs.
     *  The empty scope for all other types.
     */</span>
    def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types;Type.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> = <a href="Scopes.scala.html#scala.reflect.internal;Scopes.EmptyScope" title="Types.this.EmptyScope.type">EmptyScope</a>

    <span class="comment">/** The defined or declared members with name `name` in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */</span>
    def <a title="(name: Types.this.Name)Types.this.Symbol" id="scala.reflect.internal;Types;Type.decl">decl</a><span class="delimiter">(</span><a title="Types.this.Name" id="scala.reflect.internal;Types;Type.decl.name">name</a>: <a href="Names.scala.html#scala.reflect.internal;Names;Name" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <a href="#scala.reflect.internal;Types;Type.findDecl" title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol">findDecl</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.decl.name" title="Types.this.Name">name</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>

    <span class="comment">/** A list of all non-private members defined or declared in this type. */</span>
    def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.nonPrivateDecls">nonPrivateDecls</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.filterNot" title="(p: Types.this.Symbol =&gt; Boolean)Types.this.Scope">filterNot</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.nonPrivateDecls.$anonfun.x$6" title="Types.this.Symbol">_</a>.<a href="HasFlags.scala.html#scala.reflect.internal;HasFlags.isPrivate" title="=&gt; Boolean">isPrivate</a><span class="delimiter">)</span>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.toList" title="=&gt; List[Types.this.Symbol]">toList</a>

    <span class="comment">/** The non-private defined or declared members with name `name` in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */</span>
    def <a title="(name: Types.this.Name)Types.this.Symbol" id="scala.reflect.internal;Types;Type.nonPrivateDecl">nonPrivateDecl</a><span class="delimiter">(</span><a title="Types.this.Name" id="scala.reflect.internal;Types;Type.nonPrivateDecl.name">name</a>: <a href="Names.scala.html#scala.reflect.internal;Names;Name" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <a href="#scala.reflect.internal;Types;Type.findDecl" title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol">findDecl</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.nonPrivateDecl.name" title="Types.this.Name">name</a>, <span title="Int(4)">PRIVATE</span><span class="delimiter">)</span>

    <span class="comment">/** A list of all members of this type (defined or inherited)
     *  Members appear in linearization order of their owners.
     *  Members with the same owner appear in reverse order of their declarations.
     */</span>
    def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types;Type.members">members</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> = <a href="#scala.reflect.internal;Types;Type.membersBasedOnFlags" title="(excludedFlags: Long, requiredFlags: Long)Types.this.Scope">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(0L)" class="int">0</span>, <span title="Long(0L)" class="int">0</span><span class="delimiter">)</span>

    <span class="comment">/** A list of all non-private members of this type (defined or inherited) */</span>
    def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types;Type.nonPrivateMembers">nonPrivateMembers</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> = <a href="#scala.reflect.internal;Types;Type.membersBasedOnFlags" title="(excludedFlags: Long, requiredFlags: Long)Types.this.Scope">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619972L)">BridgeAndPrivateFlags</span>, <span title="Long(0L)" class="int">0</span><span class="delimiter">)</span>

    <span class="comment">/** A list of all non-private members of this type  (defined or inherited),
     *  admitting members with given flags `admit`
     */</span>
    def <a title="(admit: Long)Types.this.Scope" id="scala.reflect.internal;Types;Type.nonPrivateMembersAdmitting">nonPrivateMembersAdmitting</a><span class="delimiter">(</span><a title="Long" id="scala.reflect.internal;Types;Type.nonPrivateMembersAdmitting.admit">admit</a>: <a href="../../Long.scala.html#scala;Long" title="Long">Long</a><span class="delimiter">)</span>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> = <a href="#scala.reflect.internal;Types;Type.membersBasedOnFlags" title="(excludedFlags: Long, requiredFlags: Long)Types.this.Scope">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619972L)">BridgeAndPrivateFlags</span> <a href="../../Long.scala.html#scala;Long.&(89ec8b5973)" title="(x: Long)Long">&amp;</a> <a href="../../Long.scala.html#scala;Long.unary_~" title="=&gt; Long">~</a><a href="#scala.reflect.internal;Types;Type.nonPrivateMembersAdmitting.admit" title="Long">admit</a>, <span title="Long(0L)" class="int">0</span><span class="delimiter">)</span>

    <span class="comment">/** A list of all implicit symbols of this type  (defined or inherited) */</span>
    def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types;Type.implicitMembers">implicitMembers</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> = <a href="#scala.reflect.internal;Types;Type.membersBasedOnFlags" title="(excludedFlags: Long, requiredFlags: Long)Types.this.Scope">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619968L)">BridgeFlags</span>, <span title="Long(512L)">IMPLICIT</span><span class="delimiter">)</span>

    <span class="comment">/** A list of all deferred symbols of this type  (defined or inherited) */</span>
    def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types;Type.deferredMembers">deferredMembers</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> = <a href="#scala.reflect.internal;Types;Type.membersBasedOnFlags" title="(excludedFlags: Long, requiredFlags: Long)Types.this.Scope">membersBasedOnFlags</a><span class="delimiter">(</span><span title="Long(4398113619968L)">BridgeFlags</span>, <span title="Long(16L)">DEFERRED</span><span class="delimiter">)</span>

    <span class="comment">/** The member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist */</span>
    def <a title="(name: Types.this.Name)Types.this.Symbol" id="scala.reflect.internal;Types;Type.member">member</a><span class="delimiter">(</span><a title="Types.this.Name" id="scala.reflect.internal;Types;Type.member.name">name</a>: <a href="Names.scala.html#scala.reflect.internal;Names;Name" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> =
      <a href="#scala.reflect.internal;Types;Type.memberBasedOnName" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.member.name" title="Types.this.Name">name</a>, <span title="Long(4398113619968L)">BridgeFlags</span><span class="delimiter">)</span>

    <span class="comment">/** The non-private member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Bridges are excluded from the result
     */</span>
    def <a title="(name: Types.this.Name)Types.this.Symbol" id="scala.reflect.internal;Types;Type.nonPrivateMember">nonPrivateMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="scala.reflect.internal;Types;Type.nonPrivateMember.name">name</a>: <a href="Names.scala.html#scala.reflect.internal;Names;Name" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> =
      <a href="#scala.reflect.internal;Types;Type.memberBasedOnName" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.nonPrivateMember.name" title="Types.this.Name">name</a>, <span title="Long(4398113619972L)">BridgeAndPrivateFlags</span><span class="delimiter">)</span>

    <span class="comment">/** The non-private member with given name, admitting members with given flags `admit`.
     *  &quot;Admitting&quot; refers to the fact that members with a PRIVATE, BRIDGE, or VBRIDGE
     *  flag are usually excluded from findMember results, but supplying any of those flags
     *  to this method disables that exclusion.
     *
     *  An OverloadedSymbol if several exist, NoSymbol if none exists.
     */</span>
    def <a title="(name: Types.this.Name, admit: Long)Types.this.Symbol" id="scala.reflect.internal;Types;Type.nonPrivateMemberAdmitting">nonPrivateMemberAdmitting</a><span class="delimiter">(</span><a title="Types.this.Name" id="scala.reflect.internal;Types;Type.nonPrivateMemberAdmitting.name">name</a>: <a href="Names.scala.html#scala.reflect.internal;Names;Name" title="Types.this.Name">Name</a>, <a title="Long" id="scala.reflect.internal;Types;Type.nonPrivateMemberAdmitting.admit">admit</a>: <a href="../../Long.scala.html#scala;Long" title="Long">Long</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> =
      <a href="#scala.reflect.internal;Types;Type.memberBasedOnName" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.nonPrivateMemberAdmitting.name" title="Types.this.Name">name</a>, <span title="Long(4398113619972L)">BridgeAndPrivateFlags</span> <a href="../../Long.scala.html#scala;Long.&(89ec8b5973)" title="(x: Long)Long">&amp;</a> <a href="../../Long.scala.html#scala;Long.unary_~" title="=&gt; Long">~</a><a href="#scala.reflect.internal;Types;Type.nonPrivateMemberAdmitting.admit" title="Long">admit</a><span class="delimiter">)</span>

    <span class="comment">/** The non-local member with given name,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist */</span>
    def <a title="(name: Types.this.Name)Types.this.Symbol" id="scala.reflect.internal;Types;Type.nonLocalMember">nonLocalMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="scala.reflect.internal;Types;Type.nonLocalMember.name">name</a>: <a href="Names.scala.html#scala.reflect.internal;Names;Name" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> =
      <a href="#scala.reflect.internal;Types;Type.memberBasedOnName" title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol">memberBasedOnName</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.nonLocalMember.name" title="Types.this.Name">name</a>, BridgeFlags <span title="Long(4398114144256L)">|</span> LOCAL<span class="delimiter">)</span>

    <span class="comment">/** Members excluding and requiring the given flags.
     *  Note: unfortunately it doesn't work to exclude DEFERRED this way.
     */</span>
    def <a title="(excludedFlags: Long, requiredFlags: Long)Types.this.Scope" id="scala.reflect.internal;Types;Type.membersBasedOnFlags">membersBasedOnFlags</a><span class="delimiter">(</span><a title="Long" id="scala.reflect.internal;Types;Type.membersBasedOnFlags.excludedFlags">excludedFlags</a>: <a href="../../Long.scala.html#scala;Long" title="Long">Long</a>, <a title="Long" id="scala.reflect.internal;Types;Type.membersBasedOnFlags.requiredFlags">requiredFlags</a>: <a href="../../Long.scala.html#scala;Long" title="Long">Long</a><span class="delimiter">)</span>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> =
      <a href="#scala.reflect.internal;Types;Type.findMembers" title="(excludedFlags: Long, requiredFlags: Long)Types.this.Scope">findMembers</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.membersBasedOnFlags.excludedFlags" title="Long">excludedFlags</a>, <a href="#scala.reflect.internal;Types;Type.membersBasedOnFlags.requiredFlags" title="Long">requiredFlags</a><span class="delimiter">)</span>

    def <a title="(name: Types.this.Name, excludedFlags: Long)Types.this.Symbol" id="scala.reflect.internal;Types;Type.memberBasedOnName">memberBasedOnName</a><span class="delimiter">(</span><a title="Types.this.Name" id="scala.reflect.internal;Types;Type.memberBasedOnName.name">name</a>: <a href="Names.scala.html#scala.reflect.internal;Names;Name" title="Types.this.Name">Name</a>, <a title="Long" id="scala.reflect.internal;Types;Type.memberBasedOnName.excludedFlags">excludedFlags</a>: <a href="../../Long.scala.html#scala;Long" title="Long">Long</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> =
      <a href="#scala.reflect.internal;Types;Type.findMember" title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol">findMember</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.memberBasedOnName.name" title="Types.this.Name">name</a>, <a href="#scala.reflect.internal;Types;Type.memberBasedOnName.excludedFlags" title="Long">excludedFlags</a>, <span title="Long(0L)" class="int">0</span>, stableOnly = false<span class="delimiter">)</span>

    <span class="comment">/** The least type instance of given class which is a supertype
     *  of this type.  Example:
     *    class D[T]
     *    class C extends p.D[Int]
     *    ThisType(C).baseType(D) = p.D[Int]
     */</span>
    def <a title="(clazz: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;Type.baseType">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.baseType.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>

    <span class="comment">/** This type as seen from prefix `pre` and class `clazz`. This means:
     *  Replace all thistypes of `clazz` or one of its subclasses
     *  by `pre` and instantiate all parameters by arguments of `pre`.
     *  Proceed analogously for thistypes referring to outer classes.
     *
     *  Example:
     *    class D[T] { def m: T }
     *    class C extends p.D[Int]
     *    T.asSeenFrom(ThisType(C), D)  (where D is owner of m)
     *      = Int
     */</span>
    def <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;Type.asSeenFrom">asSeenFrom</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;Type.asSeenFrom.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.asSeenFrom.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      val <a title="scala.reflect.internal.util.Statistics.TimerSnapshot" id="scala.reflect.internal;Types;Type.asSeenFrom.start">start</a> = if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.pushTimer" title="(timers: scala.reflect.internal.util.Statistics.TimerStack, timer: =&gt; scala.reflect.internal.util.Statistics.StackableTimer)scala.reflect.internal.util.Statistics.TimerSnapshot">pushTimer</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.typeOpsStack" title="=&gt; scala.reflect.internal.util.Statistics.TimerStack">typeOpsStack</a>, <a href="#scala.reflect.internal.TypesStats.asSeenFromNanos" title="=&gt; scala.reflect.internal.util.Statistics.StackableTimer">asSeenFromNanos</a><span class="delimiter">)</span>  else null
      try <span class="delimiter">{</span>
        val trivial = <span class="delimiter">(</span>
             this.<a href="#scala.reflect.internal;Types;Type.isTrivial" title="=&gt; Boolean">isTrivial</a>
          <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;Type.asSeenFrom.pre" title="Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: Any)Boolean">!=</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ArrayClass" title="=&gt; Types.this.ClassSymbol">ArrayClass</a>
          <a href="../../Boolean.scala.html#scala;Boolean.||" title="Boolean" id="scala.reflect.internal;Types;Type.asSeenFrom.trivial">||</a> <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps.skipPrefixOf" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Boolean">skipPrefixOf</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.asSeenFrom.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;Type.asSeenFrom.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
        <span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.asSeenFrom.trivial" title="Boolean">trivial</a><span class="delimiter">)</span> this
        else <span class="delimiter">{</span>
          val <a title="Types.this.AsSeenFromMap" id="scala.reflect.internal;Types;Type.asSeenFrom.m">m</a>     = <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps.newAsSeenFromMap" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.AsSeenFromMap">newAsSeenFromMap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.asSeenFrom.pre" title="Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a>, <a href="#scala.reflect.internal;Types;Type.asSeenFrom.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
          val <a title="Types.this.Type" id="scala.reflect.internal;Types;Type.asSeenFrom.tp">tp</a>    = <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.apply" title="(tp: Types.this.Type)Types.this.Type">m</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
          val <a title="Types.this.Type" id="scala.reflect.internal;Types;Type.asSeenFrom.tp1">tp1</a>   = <a href="#scala.reflect.internal;Types.existentialAbstraction" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.asSeenFrom.m" title="Types.this.AsSeenFromMap">m</a>.<a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.capturedParams" title="=&gt; List[Types.this.Symbol]">capturedParams</a>, <a href="#scala.reflect.internal;Types;Type.asSeenFrom.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>

          if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.asSeenFrom.m" title="Types.this.AsSeenFromMap">m</a>.<a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.capturedSkolems" title="=&gt; List[Types.this.Symbol]">capturedSkolems</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.asSeenFrom.tp1" title="Types.this.Type">tp1</a>
          else <a href="Symbols.scala.html#scala.reflect.internal;Symbols.deriveType" title="(syms: List[Types.this.Symbol], symFn: Types.this.Symbol =&gt; Types.this.Symbol)(tpe: Types.this.Type)Types.this.Type">deriveType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.asSeenFrom.m" title="Types.this.AsSeenFromMap">m</a>.<a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;AsSeenFromMap.capturedSkolems" title="=&gt; List[Types.this.Symbol]">capturedSkolems</a>, <a href="#scala.reflect.internal;Types;Type.asSeenFrom.$anonfun.x$7" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.cloneSymbol(4a4a4b92d2)" title="=&gt; x$7.TypeOfClonedSymbol">cloneSymbol</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setFlag" title="(mask: Long)x$7.TypeOfClonedSymbol">setFlag</a> <span title="Long(65536L)">CAPTURED</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.asSeenFrom.tp1" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> finally if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.popTimer" title="(timers: scala.reflect.internal.util.Statistics.TimerStack, prev: scala.reflect.internal.util.Statistics.TimerSnapshot)Unit">popTimer</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.typeOpsStack" title="=&gt; scala.reflect.internal.util.Statistics.TimerStack">typeOpsStack</a>, <a href="#scala.reflect.internal;Types;Type.asSeenFrom.start" title="scala.reflect.internal.util.Statistics.TimerSnapshot">start</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** The info of `sym`, seen as a member of this type.
     *
     *  Example:
     *  {{{
     *    class D[T] { def m: T }
     *    class C extends p.D[Int]
     *    ThisType(C).memberType(m) = Int
     *  }}}
     */</span>
    def <a title="(sym: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;Type.memberInfo">memberInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.memberInfo.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="../../Predef.scala.html#scala.Predef.require(a2f0e4a061)" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.memberInfo.sym" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a>, this<span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types;Type.memberInfo.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.asSeenFrom" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;Type.memberInfo.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** The type of `sym`, seen as a member of this type. */</span>
    def <a title="(sym: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;Type.memberType">memberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.memberType.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;Type.memberType.sym" title="Types.this.Symbol">sym</a> match <span class="delimiter">{</span>
      case <a title="Types.this.MethodSymbol" id="scala.reflect.internal;Types;Type.memberType.meth">meth</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;MethodSymbol" title="Types.this.MethodSymbol">MethodSymbol</a> =&gt;
        <a href="#scala.reflect.internal;Types;Type.memberType.meth" title="Types.this.MethodSymbol">meth</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;MethodSymbol.typeAsMemberOf" title="(pre: Types.this.Type)Types.this.Type">typeAsMemberOf</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
      case _ =&gt;
        <a href="#scala.reflect.internal;Types;Type.computeMemberType" title="(sym: Types.this.Symbol)Types.this.Type">computeMemberType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.memberType.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    def <a title="(sym: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;Type.computeMemberType">computeMemberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.computeMemberType.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;Type.computeMemberType.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpeHK" title="=&gt; Types.this.Type">tpeHK</a> match <span class="delimiter">{</span> <span class="comment">//@M don't prematurely instantiate higher-kinded types, they will be instantiated by transform, typedTypeApply, etc. when really necessary</span>
      case OverloadedType<span class="delimiter">(</span>_, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.computeMemberType.alts">alts</a><span class="delimiter">)</span> =&gt;
        <a href="#scala.reflect.internal;Types.OverloadedType.readResolve" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.OverloadedType">OverloadedType</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;Type.computeMemberType.alts" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span>
      case <a title="Types.this.Type" id="scala.reflect.internal;Types;Type.computeMemberType.tp">tp</a> =&gt;
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.computeMemberType.sym" title="Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a> else <a href="#scala.reflect.internal;Types;Type.computeMemberType.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.asSeenFrom" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;Type.computeMemberType.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Substitute types `to` for occurrences of references to
     *  symbols `from` in this type.
     */</span>
    def <a title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types;Type.subst">subst</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.subst.from">from</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;Type.subst.to">to</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.subst.from" title="List[Types.this.Symbol]">from</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> this else <a href="#scala.reflect.internal;Types.substTypeMapCache.apply" title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.SubstTypeMap">substTypeMapCache</a><a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply" title="(tp0: Types.this.Type)Types.this.Type" class="delimiter">(</a><a href="#scala.reflect.internal;Types;Type.subst.from" title="List[Types.this.Symbol]">from</a>, <a href="#scala.reflect.internal;Types;Type.subst.to" title="List[Types.this.Type]">to</a><span class="delimiter">)</span><span class="delimiter">(</span>this<span class="delimiter">)</span>

    <span class="comment">/** Substitute symbols `to` for occurrences of symbols `from` in this type.
     *
     * !!! NOTE !!!: If you need to do a substThis and a substSym, the substThis has to come
     * first, as otherwise symbols will immediately get rebound in typeRef to the old
     * symbol.
     */</span>
    def <a title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type" id="scala.reflect.internal;Types;Type.substSym">substSym</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.substSym.from">from</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.substSym.to">to</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.substSym.from" title="List[Types.this.Symbol]">from</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;Type.substSym.to" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types;Type.substSym.from" title="List[Types.this.Symbol]">from</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> this
      else new <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstSymMap" title="Types.this.SubstSymMap">SubstSymMap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.substSym.from" title="List[Types.this.Symbol]">from</a>, <a href="#scala.reflect.internal;Types;Type.substSym.to" title="List[Types.this.Symbol]">to</a><span class="delimiter">)</span> <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstSymMap.apply" title="(tp: Types.this.Type)Types.this.Type">apply</a> this

    <span class="comment">/** Substitute all occurrences of `ThisType(from)` in this type by `to`.
     *
     * !!! NOTE !!!: If you need to do a substThis and a substSym, the substThis has to come
     * first, as otherwise symbols will immediately get rebound in typeRef to the old
     * symbol.
     */</span>
    def <a title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;Type.substThis(9f714a76d3)">substThis</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.substThis(9f714a76d3).from">from</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;Type.substThis(9f714a76d3).to">to</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      new <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstThisMap" title="Types.this.SubstThisMap">SubstThisMap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.substThis(9f714a76d3).from" title="Types.this.Symbol">from</a>, <a href="#scala.reflect.internal;Types;Type.substThis(9f714a76d3).to" title="Types.this.Type">to</a><span class="delimiter">)</span> <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstThisMap.apply" title="(tp: Types.this.Type)Types.this.Type">apply</a> this
    def <a title="(from: Types.this.Symbol, to: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;Type.substThis(7931700073)">substThis</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.substThis(7931700073).from">from</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.substThis(7931700073).to">to</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      <a href="#scala.reflect.internal;Types;Type.substThis(9f714a76d3)" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.substThis(7931700073).from" title="Types.this.Symbol">from</a>, <a href="#scala.reflect.internal;Types;Type.substThis(7931700073).to" title="Types.this.Symbol">to</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.thisType" title="=&gt; Types.this.Type">thisType</a><span class="delimiter">)</span>

    <span class="comment">/** Performs both substThis and substSym, in that order.
     *
     * [JZ] Reverted `SubstThisAndSymMap` from 334872, which was not the same as
     * `substThis(from, to).substSym(symsFrom, symsTo)`.
     *
     * `SubstThisAndSymMap` performs a breadth-first map over this type, which meant that
     * symbol substitution occured before `ThisType` substitution. Consequently, in substitution
     * of a `SingleType(ThisType(`from`), sym), symbols were rebound to `from` rather than `to`.
     */</span>
    def <a title="(from: Types.this.Symbol, to: Types.this.Type, symsFrom: List[Types.this.Symbol], symsTo: List[Types.this.Symbol])Types.this.Type" id="scala.reflect.internal;Types;Type.substThisAndSym">substThisAndSym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.substThisAndSym.from">from</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;Type.substThisAndSym.to">to</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.substThisAndSym.symsFrom">symsFrom</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.substThisAndSym.symsTo">symsTo</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.substThisAndSym.symsFrom" title="List[Types.this.Symbol]">symsFrom</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;Type.substThisAndSym.symsTo" title="List[Types.this.Symbol]">symsTo</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.substThis(9f714a76d3)" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.substThisAndSym.from" title="Types.this.Symbol">from</a>, <a href="#scala.reflect.internal;Types;Type.substThisAndSym.to" title="Types.this.Type">to</a><span class="delimiter">)</span>
      else <a href="#scala.reflect.internal;Types;Type.substThis(9f714a76d3)" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.substThisAndSym.from" title="Types.this.Symbol">from</a>, <a href="#scala.reflect.internal;Types;Type.substThisAndSym.to" title="Types.this.Type">to</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.substSym" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.substThisAndSym.symsFrom" title="List[Types.this.Symbol]">symsFrom</a>, <a href="#scala.reflect.internal;Types;Type.substThisAndSym.symsTo" title="List[Types.this.Symbol]">symsTo</a><span class="delimiter">)</span>

    <span class="comment">/** Returns all parts of this type which satisfy predicate `p` */</span>
    def <a title="(p: Types.this.Type =&gt; Boolean)Type.this.FilterMapForeach" id="scala.reflect.internal;Types;Type.withFilter">withFilter</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types;Type.withFilter.p">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> = new <a href="#scala.reflect.internal;Types;Type;FilterMapForeach" title="Type.this.FilterMapForeach">FilterMapForeach</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.withFilter.p" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>

    class <a title="class FilterMapForeach extends Types.this.FilterTypeCollector" id="scala.reflect.internal;Types;Type;FilterMapForeach">FilterMapForeach</a><a href="#scala.reflect.internal;Types;Type;FilterMapForeach" title="Type.this.FilterMapForeach" class="delimiter">(</a><a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types;Type;FilterMapForeach.p">p</a>: Type =&gt; Boolean<span class="delimiter">)</span> extends <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;FilterTypeCollector" title="Types.this.FilterTypeCollector">FilterTypeCollector</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type;FilterMapForeach.p" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span><span class="delimiter">{</span>
      def <a title="[U](f: Types.this.Type =&gt; U)Unit" id="scala.reflect.internal;Types;Type;FilterMapForeach.foreach">foreach</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal;Types;Type;FilterMapForeach.foreach;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; U" id="scala.reflect.internal;Types;Type;FilterMapForeach.foreach.f">f</a>: Type =&gt; U<span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;FilterTypeCollector.collect" title="(tp: Types.this.Type)List[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>.this<span class="delimiter">)</span> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: Types.this.Type =&gt; U)Unit">foreach</a> <a href="#scala.reflect.internal;Types;Type;FilterMapForeach.foreach.f" title="Types.this.Type =&gt; U">f</a>
      def <a title="[T](f: Types.this.Type =&gt; T)List[T]" id="scala.reflect.internal;Types;Type;FilterMapForeach.map">map</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal;Types;Type;FilterMapForeach.map;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; T" id="scala.reflect.internal;Types;Type;FilterMapForeach.map.f">f</a>: Type =&gt; T<span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span>  = <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;FilterTypeCollector.collect" title="(tp: Types.this.Type)List[Types.this.Type]">collect</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>.this<span class="delimiter">)</span> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Type =&gt; T)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],T,List[T]])List[T]">map</a> <a href="#scala.reflect.internal;Types;Type;FilterMapForeach.map.f" title="Types.this.Type =&gt; T">f</a>
    <span class="delimiter">}</span>

    @inline final def <a title="(alt: =&gt; Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;Type.orElse">orElse</a><span class="delimiter">(</span><a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.orElse.alt">alt</a>: =&gt; Type<span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = if <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> this else <a href="#scala.reflect.internal;Types;Type.orElse.alt" title="=&gt; Types.this.Type">alt</a>

    <span class="comment">/** Returns optionally first type (in a preorder traversal) which satisfies predicate `p`,
     *  or None if none exists.
     */</span>
    def <a title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]" id="scala.reflect.internal;Types;Type.find">find</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types;Type.find.p">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Types.this.Type]">Option</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = new <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;FindTypeCollector" title="Types.this.FindTypeCollector">FindTypeCollector</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.find.p" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>.<a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeCollector.collect" title="(tp: Types.this.Type)Option[Types.this.Type]">collect</a><span class="delimiter">(</span>this<span class="delimiter">)</span>

    <span class="comment">/** Apply `f` to each part of this type */</span>
    def <a title="(f: Types.this.Type =&gt; Unit)Unit" id="scala.reflect.internal;Types;Type.foreach">foreach</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Unit" id="scala.reflect.internal;Types;Type.foreach.f">f</a>: Type =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span> new <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;ForEachTypeTraverser" title="Types.this.ForEachTypeTraverser">ForEachTypeTraverser</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.foreach.f" title="Types.this.Type =&gt; Unit">f</a><span class="delimiter">)</span>.<a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;ForEachTypeTraverser.traverse" title="(tp: Types.this.Type)Unit">traverse</a><span class="delimiter">(</span>this<span class="delimiter">)</span> <span class="delimiter">}</span>

    <span class="comment">/** Apply `pf' to each part of this type on which the function is defined */</span>
    def <a title="[T](pf: PartialFunction[Types.this.Type,T])List[T]" id="scala.reflect.internal;Types;Type.collect">collect</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal;Types;Type.collect;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[Types.this.Type,T]" id="scala.reflect.internal;Types;Type.collect.pf">pf</a>: <a href="../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[Types.this.Type,T]">PartialFunction</a><span class="delimiter">[</span>Type, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = new <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector" title="Types.this.CollectTypeCollector[T]">CollectTypeCollector</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.collect.pf" title="PartialFunction[Types.this.Type,T]">pf</a><span class="delimiter">)</span>.<a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;CollectTypeCollector.collect" title="(tp: Types.this.Type)List[T]">collect</a><span class="delimiter">(</span>this<span class="delimiter">)</span>

    <span class="comment">/** Apply `f` to each part of this type; children get mapped before their parents */</span>
    def <a title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;Type.map">map</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.map.f">f</a>: Type =&gt; Type<span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = new <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="&lt;$anon: Types.this.Type =&gt; Types.this.Type&gt; extends Types.this.TypeMap" id="scala.reflect.internal;Types;Type.map;$anon">TypeMap</a> <span class="delimiter">{</span>
      def <a title="(x: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;Type.map;$anon.apply">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;Type.map;$anon.apply.x">x</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Types.this.Type)Types.this.Type">f</a><span class="delimiter">(</span><a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.map;$anon.apply.x" title="Types.this.Type">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <a href="#scala.reflect.internal;Types;Type.map;$anon.apply" title="(x: Types.this.Type)Types.this.Type">apply</a> this

    <span class="comment">/** Is there part of this type which satisfies predicate `p`? */</span>
    def <a title="(p: Types.this.Type =&gt; Boolean)Boolean" id="scala.reflect.internal;Types;Type.exists">exists</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types;Type.exists.p">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;Type.find" title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]">find</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.exists.p" title="Types.this.Type =&gt; Boolean">p</a><span class="delimiter">)</span>.<a href="../../Option.scala.html#scala;Option.isEmpty" title="=&gt; Boolean">isEmpty</a>

    <span class="comment">/** Does this type contain a reference to this symbol? */</span>
    def <a title="(sym: Types.this.Symbol)Boolean" id="scala.reflect.internal;Types;Type.contains">contains</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.contains.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = new <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;ContainsCollector" title="Types.this.ContainsCollector">ContainsCollector</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.contains.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeCollector.collect" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span>this<span class="delimiter">)</span>

    <span class="comment">/** Is this type a subtype of that type? */</span>
    def <a title="(that: Types.this.Type)Boolean" id="scala.reflect.internal;Types;Type.<:<">&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;Type.<:<.that">that</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.stat_<:<" title="(that: Types.this.Type)Boolean">stat_&lt;:&lt;</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.<:<.that" title="Types.this.Type">that</a><span class="delimiter">)</span>
      else <span class="delimiter">{</span>
        <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;Type.<:<.that" title="Types.this.Type">that</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a>
        <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.explainSwitch_=" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.explain" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;&lt;:&quot;)" class="string">&quot;&lt;:&quot;</span>, <a href="tpe/TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isSubType" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: scala.reflect.internal.Depth)Boolean">isSubType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.<:<.$anonfun.x$8" title="Types.this.Type">_</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a href="#scala.reflect.internal;Types;Type.<:<.$anonfun.x$9" title="Types.this.Type">_</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>, this, <a href="#scala.reflect.internal;Types;Type.<:<.that" title="Types.this.Type">that</a><span class="delimiter">)</span>
         else <a href="tpe/TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isSubType" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: scala.reflect.internal.Depth)Boolean">isSubType</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;Type.<:<.that" title="Types.this.Type">that</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Is this type a subtype of that type in a pattern context?
     *  Dummy type arguments on the right hand side are replaced with
     *  fresh existentials, except for Arrays.
     *
     *  See bug1434.scala for an example of code which would fail
     *  if only a &lt;:&lt; test were applied.
     */</span>
    def <a title="(that: Types.this.Type)Boolean" id="scala.reflect.internal;Types;Type.matchesPattern">matchesPattern</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;Type.matchesPattern.that">that</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">(</span>this <a href="#scala.reflect.internal;Types;Type.<:<" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#scala.reflect.internal;Types;Type.matchesPattern.that" title="Types.this.Type">that</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.matchesPattern.that" title="Types.this.Type">that</a> match <span class="delimiter">{</span>
      case <a href="#scala.reflect.internal;Types.ArrayTypeRef.unapply" title="(tp: Types.this.Type)Option[Types.this.Type]">ArrayTypeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;Type.matchesPattern.elem2">elem2</a><span class="delimiter">)</span> if <a href="#scala.reflect.internal;Types;Type.matchesPattern.elem2" title="Types.this.Type">elem2</a>.<a href="#scala.reflect.internal;Types;Type.typeConstructor" title="=&gt; Types.this.Type">typeConstructor</a>.<a href="#scala.reflect.internal;Types;Type.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a> =&gt;
        this match <span class="delimiter">{</span>
          case <a href="#scala.reflect.internal;Types.ArrayTypeRef.unapply" title="(tp: Types.this.Type)Option[Types.this.Type]">ArrayTypeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;Type.matchesPattern.elem1">elem1</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types;Type.matchesPattern.elem1" title="Types.this.Type">elem1</a> <a href="#scala.reflect.internal;Types;Type.matchesPattern" title="(that: Types.this.Type)Boolean">matchesPattern</a> <a href="#scala.reflect.internal;Types;Type.matchesPattern.elem2" title="Types.this.Type">elem2</a>
          case _                   =&gt; false
        <span class="delimiter">}</span>
      case TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.matchesPattern.sym">sym</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;Type.matchesPattern.args">args</a><span class="delimiter">)</span> =&gt;
        val <a title="Types.this.Type" id="scala.reflect.internal;Types;Type.matchesPattern.that1">that1</a> = <a href="#scala.reflect.internal;Types.existentialAbstraction" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.matchesPattern.args" title="List[Types.this.Type]">args</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Type =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.matchesPattern.that1.$anonfun.x$10" title="Types.this.Type">_</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types;Type.matchesPattern.that" title="Types.this.Type">that</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.matchesPattern.that" title="Types.this.Type">that</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types;Type.matchesPattern.that1" title="Types.this.Type">that1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span>this <a href="#scala.reflect.internal;Types;Type.<:<" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#scala.reflect.internal;Types;Type.matchesPattern.that1" title="Types.this.Type">that1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
          <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span>this<a href="#scala.reflect.internal;Types;Type" title="String(&quot;.matchesPattern(&quot;)">.matchesPattern($</a><a href="#scala.reflect.internal;Types;Type.matchesPattern.that" title="Types.this.Type">that</a><span title="String(&quot;) depended on discarding args and testing &lt;:&lt; &quot;)">) depended on discarding args and testing &lt;:&lt; $</span><a href="#scala.reflect.internal;Types;Type.matchesPattern.that1" title="Types.this.Type">that1</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
          true
        <span class="delimiter">}</span>
      case _ =&gt;
        false
    <span class="delimiter">}</span><span class="delimiter">)</span>

    def <a title="(that: Types.this.Type)Boolean" id="scala.reflect.internal;Types;Type.stat_<:<">stat_&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;Type.stat_<:<.that">that</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.incCounter(456ea4fa07)" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.subtypeCount" title="=&gt; scala.reflect.internal.util.Statistics.Counter">subtypeCount</a><span class="delimiter">)</span>
      val <a title="scala.reflect.internal.util.Statistics.TimerSnapshot" id="scala.reflect.internal;Types;Type.stat_<:<.start">start</a> = if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.pushTimer" title="(timers: scala.reflect.internal.util.Statistics.TimerStack, timer: =&gt; scala.reflect.internal.util.Statistics.StackableTimer)scala.reflect.internal.util.Statistics.TimerSnapshot">pushTimer</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.typeOpsStack" title="=&gt; scala.reflect.internal.util.Statistics.TimerStack">typeOpsStack</a>, <a href="#scala.reflect.internal.TypesStats.subtypeNanos" title="=&gt; scala.reflect.internal.util.Statistics.StackableTimer">subtypeNanos</a><span class="delimiter">)</span> else null
      val result =
        <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;Type.stat_<:<.that" title="Types.this.Type">that</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="Boolean" id="scala.reflect.internal;Types;Type.stat_<:<.result">||</a>
        <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.explainSwitch_=" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.explain" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;&lt;:&quot;)" class="string">&quot;&lt;:&quot;</span>, <a href="tpe/TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isSubType" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: scala.reflect.internal.Depth)Boolean">isSubType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.stat_<:<.result.$anonfun.x$11" title="Types.this.Type">_</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a href="#scala.reflect.internal;Types;Type.stat_<:<.result.$anonfun.x$12" title="Types.this.Type">_</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>, this, <a href="#scala.reflect.internal;Types;Type.stat_<:<.that" title="Types.this.Type">that</a><span class="delimiter">)</span>
         else <a href="tpe/TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isSubType" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: scala.reflect.internal.Depth)Boolean">isSubType</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;Type.stat_<:<.that" title="Types.this.Type">that</a><span class="delimiter">)</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.popTimer" title="(timers: scala.reflect.internal.util.Statistics.TimerStack, prev: scala.reflect.internal.util.Statistics.TimerSnapshot)Unit">popTimer</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.typeOpsStack" title="=&gt; scala.reflect.internal.util.Statistics.TimerStack">typeOpsStack</a>, <a href="#scala.reflect.internal;Types;Type.stat_<:<.start" title="scala.reflect.internal.util.Statistics.TimerSnapshot">start</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types;Type.stat_<:<.result" title="Boolean">result</a>
    <span class="delimiter">}</span>

    <span class="comment">/** Is this type a weak subtype of that type? True also for numeric types, i.e. Int weak_&lt;:&lt; Long.
     */</span>
    def <a title="(that: Types.this.Type)Boolean" id="scala.reflect.internal;Types;Type.weak_<:<">weak_&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;Type.weak_<:<.that">that</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.incCounter(456ea4fa07)" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.subtypeCount" title="=&gt; scala.reflect.internal.util.Statistics.Counter">subtypeCount</a><span class="delimiter">)</span>
      val <a title="scala.reflect.internal.util.Statistics.TimerSnapshot" id="scala.reflect.internal;Types;Type.weak_<:<.start">start</a> = if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.pushTimer" title="(timers: scala.reflect.internal.util.Statistics.TimerStack, timer: =&gt; scala.reflect.internal.util.Statistics.StackableTimer)scala.reflect.internal.util.Statistics.TimerSnapshot">pushTimer</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.typeOpsStack" title="=&gt; scala.reflect.internal.util.Statistics.TimerStack">typeOpsStack</a>, <a href="#scala.reflect.internal.TypesStats.subtypeNanos" title="=&gt; scala.reflect.internal.util.Statistics.StackableTimer">subtypeNanos</a><span class="delimiter">)</span> else null
      val result =
        <span class="delimiter">(</span><span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;Type.weak_<:<.that" title="Types.this.Type">that</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="Boolean" id="scala.reflect.internal;Types;Type.weak_<:<.result">||</a>
         <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.explainSwitch_=" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.explain" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;weak_&lt;:&quot;)" class="string">&quot;weak_&lt;:&quot;</span>, <a href="tpe/TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isWeakSubType" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isWeakSubType</a>, this, <a href="#scala.reflect.internal;Types;Type.weak_<:<.that" title="Types.this.Type">that</a><span class="delimiter">)</span>
          else <a href="tpe/TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isWeakSubType" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isWeakSubType</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;Type.weak_<:<.that" title="Types.this.Type">that</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.popTimer" title="(timers: scala.reflect.internal.util.Statistics.TimerStack, prev: scala.reflect.internal.util.Statistics.TimerSnapshot)Unit">popTimer</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.typeOpsStack" title="=&gt; scala.reflect.internal.util.Statistics.TimerStack">typeOpsStack</a>, <a href="#scala.reflect.internal;Types;Type.weak_<:<.start" title="scala.reflect.internal.util.Statistics.TimerSnapshot">start</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types;Type.weak_<:<.result" title="Boolean">result</a>
    <span class="delimiter">}</span>

    <span class="comment">/** Is this type equivalent to that type? */</span>
    def <a title="(that: Types.this.Type)Boolean" id="scala.reflect.internal;Types;Type.=:=">=:=</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;Type.=:=.that">that</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">(</span>
      <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;Type.=:=.that" title="Types.this.Type">that</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a>
      <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.explainSwitch_=" title="=&gt; Boolean">explainSwitch</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.explain" title="(op: String, p: (Types.this.Type, Types.this.Type) =&gt; Boolean, tp1: Types.this.Type, arg2: Types.this.Type)Boolean">explain</a><span class="delimiter">(</span><span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span>, <a href="tpe/TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isSameType" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a>, this, <a href="#scala.reflect.internal;Types;Type.=:=.that" title="Types.this.Type">that</a><span class="delimiter">)</span>
       else <a href="tpe/TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isSameType" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isSameType</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;Type.=:=.that" title="Types.this.Type">that</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>

    <span class="comment">/** Is this type close enough to that type so that members
     *  with the two type would override each other?
     *  This means:
     *    - Either both types are polytypes with the same number of
     *      type parameters and their result types match after renaming
     *      corresponding type parameters
     *    - Or both types are (nullary) method types with equivalent type parameter types
     *      and matching result types
     *    - Or both types are equivalent
     *    - Or phase.erasedTypes is false and both types are neither method nor
     *      poly types.
     */</span>
    def <a title="(that: Types.this.Type)Boolean" id="scala.reflect.internal;Types;Type.matches">matches</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;Type.matches.that">that</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;Type.matches.that" title="Types.this.Type">that</a>, <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>

    <span class="comment">/** Same as matches, except that non-method types are always assumed to match. */</span>
    def <a title="(that: Types.this.Type)Boolean" id="scala.reflect.internal;Types;Type.looselyMatches">looselyMatches</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;Type.looselyMatches.that">that</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;Type.looselyMatches.that" title="Types.this.Type">that</a>, alwaysMatchSimple = true<span class="delimiter">)</span>

    <span class="comment">/** The shortest sorted upwards closed array of types that contains
     *  this type as first element.
     *
     *  A list or array of types ts is upwards closed if
     *
     *    for all t in ts:
     *      for all typerefs p.s[args] such that t &lt;: p.s[args]
     *      there exists a typeref p'.s[args'] in ts such that
     *      t &lt;: p'.s['args] &lt;: p.s[args],
     *
     *      and
     *
     *      for all singleton types p.s such that t &lt;: p.s
     *      there exists a singleton type p'.s in ts such that
     *      t &lt;: p'.s &lt;: p.s
     *
     *  Sorting is with respect to Symbol.isLess() on type symbols.
     */</span>
    def <a title="=&gt; Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;Type.baseTypeSeq">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs.baseTypeSingletonSeq" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">baseTypeSingletonSeq</a><span class="delimiter">(</span>this<span class="delimiter">)</span>

    <span class="comment">/** The maximum depth (@see typeDepth)
     *  of each type in the BaseTypeSeq of this type except the first.
     */</span>
    def <a title="=&gt; scala.reflect.internal.Depth" id="scala.reflect.internal;Types;Type.baseTypeSeqDepth">baseTypeSeqDepth</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <a href="Depth.scala.html#scala.reflect.internal.Depth.apply" title="(depth: Int)scala.reflect.internal.Depth">Depth</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

    <span class="comment">/** The list of all baseclasses of this type (including its own typeSymbol)
     *  in linearization order, starting with the class itself and ending
     *  in class Any.
     */</span>
    def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.baseClasses">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>

    <span class="comment">/**
     *  @param sym the class symbol
     *  @return    the index of given class symbol in the BaseTypeSeq of this type,
     *             or -1 if no base type with given class symbol exists.
     */</span>
    def <a title="(sym: Types.this.Symbol)Int" id="scala.reflect.internal;Types;Type.baseTypeIndex">baseTypeIndex</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.baseTypeIndex.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> = <span class="delimiter">{</span>
      val <a title="Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;Type.baseTypeIndex.bts">bts</a> = <a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
      var <a title="Int" id="scala.reflect.internal;Types;Type.baseTypeIndex.lo">lo</a> = <span title="Int(0)" class="int">0</span>
      var hi = <a href="#scala.reflect.internal;Types;Type.baseTypeIndex.bts" title="Types.this.BaseTypeSeq">bts</a>.<a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.length" title="=&gt; Int">length</a> <a href="../../Int.scala.html#scala;Int.-(1409840560)" title="Int" id="scala.reflect.internal;Types;Type.baseTypeIndex.hi">-</a> <span title="Int(1)" class="int">1</span>
      while <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.baseTypeIndex.lo" title="Int">lo</a> <a href="../../Int.scala.html#scala;Int.<=(5f58a84eb3)" title="(x: Int)Boolean">&lt;=</a> <a href="#scala.reflect.internal;Types;Type.baseTypeIndex.hi" title="Int">hi</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.baseTypeIndex.while$1" title="()Unit" class="delimiter">{</a>
        val mid = <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.baseTypeIndex.lo" title="Int">lo</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+</a> <a href="#scala.reflect.internal;Types;Type.baseTypeIndex.hi" title="Int">hi</a><span class="delimiter">)</span> <a href="../../Int.scala.html#scala;Int./(1409840560)" title="Int" id="scala.reflect.internal;Types;Type.baseTypeIndex.mid">/</a> <span title="Int(2)" class="int">2</span>
        val <a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.baseTypeIndex.btssym">btssym</a> = <a href="#scala.reflect.internal;Types;Type.baseTypeIndex.bts" title="Types.this.BaseTypeSeq">bts</a>.<a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.typeSymbol" title="(i: Int)Types.this.Symbol">typeSymbol</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.baseTypeIndex.mid" title="Int">mid</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.baseTypeIndex.sym" title="Types.this.Symbol">sym</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types;Type.baseTypeIndex.btssym" title="Types.this.Symbol">btssym</a><span class="delimiter">)</span> return <a href="#scala.reflect.internal;Types;Type.baseTypeIndex.mid" title="Int">mid</a>
        else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.baseTypeIndex.sym" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isLess" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#scala.reflect.internal;Types;Type.baseTypeIndex.btssym" title="Types.this.Symbol">btssym</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.baseTypeIndex.hi" title="Int">hi</a> = <a href="#scala.reflect.internal;Types;Type.baseTypeIndex.mid" title="Int">mid</a> <a href="../../Int.scala.html#scala;Int.-(1409840560)" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span>
        else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.baseTypeIndex.btssym" title="Types.this.Symbol">btssym</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isLess" title="(that: Types.this.Symbol)Boolean">isLess</a> <a href="#scala.reflect.internal;Types;Type.baseTypeIndex.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.baseTypeIndex.lo" title="Int">lo</a> = <a href="#scala.reflect.internal;Types;Type.baseTypeIndex.mid" title="Int">mid</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+</a> <span title="Int(1)" class="int">1</span>
        else <a href="Reporting.scala.html#scala.reflect.internal;Reporting.abort" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><span title="String(&quot;sym is neither `sym == btssym`, `sym isLess btssym` nor `btssym isLess sym`&quot;)" class="string">&quot;sym is neither `sym == btssym`, `sym isLess btssym` nor `btssym isLess sym`&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      -<span title="Int(-1)" class="int">1</span>
    <span class="delimiter">}</span>

    <span class="comment">/** If this is a ExistentialType, PolyType or MethodType, a copy with cloned type / value parameters
     *  owned by `owner`. Identity for all other types.
     */</span>
    def <a title="(owner: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;Type.cloneInfo">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.cloneInfo.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = this

    <span class="comment">/** Make sure this type is correct as the info of given owner; clone it if not. */</span>
    def <a title="(owner: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;Type.atOwner">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.atOwner.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = this

    protected def <a title="=&gt; String" id="scala.reflect.internal;Types;Type.objectPrefix">objectPrefix</a> = <span title="String(&quot;object &quot;)" class="string">&quot;object &quot;</span>
    protected def <a title="=&gt; String" id="scala.reflect.internal;Types;Type.packagePrefix">packagePrefix</a> = <span title="String(&quot;package &quot;)" class="string">&quot;package &quot;</span>
    def <a title="(str: String)String" id="scala.reflect.internal;Types;Type.trimPrefix">trimPrefix</a><span class="delimiter">(</span><a title="String" id="scala.reflect.internal;Types;Type.trimPrefix.str">str</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">str</a> <a href="../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">stripPrefix</a> <a href="#scala.reflect.internal;Types;Type.objectPrefix" title="=&gt; String">objectPrefix</a> <a href="../../collection/immutable/StringLike.scala.html#scala.collection.immutable;StringLike.stripPrefix" title="(prefix: String)String">stripPrefix</a> <a href="#scala.reflect.internal;Types;Type.packagePrefix" title="=&gt; String">packagePrefix</a>

    <span class="comment">/** The string representation of this type used as a prefix */</span>
    def <a title="=&gt; String" id="scala.reflect.internal;Types;Type.prefixString">prefixString</a> = <a href="#scala.reflect.internal;Types;Type.trimPrefix" title="(str: String)String">trimPrefix</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.toString" title="()String">toString</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span>

   <span class="comment">/** Convert toString avoiding infinite recursions by cutting off
     *  after `maxTostringRecursions` recursion levels. Uses `safeToString`
     *  to produce a string on each level.
     */</span>
    override final def <a title="()String" id="scala.reflect.internal;Types;Type.toString">toString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span class="comment">// see comments to internal#Symbol.typeSignature for an explanation why this initializes</span>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.isCompilerUniverse" title="=&gt; Boolean">isCompilerUniverse</a><span class="delimiter">)</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.fullyInitializeType" title="(tp: Types.this.Type)Types.this.Type">fullyInitializeType</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
      <a href="tpe/TypeToStrings.scala.html#scala.reflect.internal.tpe;TypeToStrings.typeToString" title="(tpe: Types.this.Type)String">typeToString</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Method to be implemented in subclasses.
     *  Converts this type to a string in calling toString for its parts.
     */</span>
    def <a title="=&gt; String" id="scala.reflect.internal;Types;Type.safeToString">safeToString</a>: <span title="String">String</span> = super.<span title="()String">toString</span>

    <span class="comment">/** The string representation of this type, with singletypes explained. */</span>
    def <a title="=&gt; String" id="scala.reflect.internal;Types;Type.toLongString">toLongString</a> = <span class="delimiter">{</span>
      val <a title="String" id="scala.reflect.internal;Types;Type.toLongString.str">str</a> = <a href="#scala.reflect.internal;Types;Type.toString" title="()String">toString</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.toLongString.str" title="String">str</a> <span title="(x$1: Any)Boolean">==</span> <span title="String(&quot;type&quot;)" class="string">&quot;type&quot;</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a>.<a href="#scala.reflect.internal;Types;Type.toString" title="()String">toString</a>
      else if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.toLongString.str" title="String">str</a> <span title="(x$1: String)Boolean">endsWith</span> <span title="String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModuleClass" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a> match <span class="delimiter">{</span>
          case RefinedType<span class="delimiter">(</span>_, _<span class="delimiter">)</span>                      =&gt; <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a>
          case _                                      =&gt;
            if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a>.<a href="#scala.reflect.internal;Types;Type.toString" title="()String">toString</a>.<span title="()String">trim</span> <span title="(x$1: Any)Boolean">==</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.toLongString.str" title="String">str</a>
            else <a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span><a href="#scala.reflect.internal;Types;Type.toLongString.str" title="String">str</a><span title="String(&quot; (with underlying type &quot;)"> (with underlying type $</span><a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a><span title="String(&quot;)&quot;)" class="string">)&quot;</span>
        <span class="delimiter">}</span>
      else <a href="#scala.reflect.internal;Types;Type.toLongString.str" title="String">str</a>
    <span class="delimiter">}</span>

    <span class="comment">/** The string representation of this type when the direct object in a sentence.
     *  Normally this is no different from the regular representation, but modules
     *  read better as &quot;object Foo&quot; here and &quot;Foo.type&quot; the rest of the time.
     */</span>
    def <a title="=&gt; String" id="scala.reflect.internal;Types;Type.directObjectString">directObjectString</a> = <a href="#scala.reflect.internal;Types;Type.safeToString" title="=&gt; String">safeToString</a>

    <span class="comment">/** A test whether a type contains any unification type variables.
     *  Overridden with custom logic except where trivially true.
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;Type.isGround">isGround</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = this match <span class="delimiter">{</span>
      case ThisType<span class="delimiter">(</span>_<span class="delimiter">)</span> | <a href="#scala.reflect.internal;Types.NoPrefix.readResolve" title="Types.this.NoPrefix.type">NoPrefix</a> | <a href="#scala.reflect.internal;Types.WildcardType.readResolve" title="Types.this.WildcardType.type">WildcardType</a> | <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a> | <a href="#scala.reflect.internal;Types.ErrorType.readResolve" title="Types.this.ErrorType.type">ErrorType</a> | ConstantType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
        true
      case _ =&gt;
        <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps.typeVarToOriginMap.apply" title="(tp: Types.this.Type)Types.this.Type">typeVarToOriginMap</a><span class="delimiter">(</span>this<span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> this
    <span class="delimiter">}</span>

    <span class="comment">/** If this is a symbol loader type, load and assign a new type to `sym`. */</span>
    def <a title="(sym: Types.this.Symbol)Unit" id="scala.reflect.internal;Types;Type.load">load</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.load.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>

    private def <a title="(name: Types.this.Name, excludedFlags: Int)Types.this.Symbol" id="scala.reflect.internal;Types;Type.findDecl">findDecl</a><span class="delimiter">(</span><a title="Types.this.Name" id="scala.reflect.internal;Types;Type.findDecl.name">name</a>: <a href="Names.scala.html#scala.reflect.internal;Names;Name" title="Types.this.Name">Name</a>, <a title="Int" id="scala.reflect.internal;Types;Type.findDecl.excludedFlags">excludedFlags</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      var <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.findDecl.alts">alts</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
      var <a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.findDecl.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a>
      var <a title="Types.this.ScopeEntry" id="scala.reflect.internal;Types;Type.findDecl.e">e</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;ScopeEntry" title="Types.this.ScopeEntry">ScopeEntry</a> = <a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.lookupEntry" title="(name: Types.this.Name)Types.this.ScopeEntry">lookupEntry</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.findDecl.name" title="Types.this.Name">name</a><span class="delimiter">)</span>
      while <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.findDecl.e" title="Types.this.ScopeEntry">e</a> <span title="(x$1: AnyRef)Boolean">ne</span> null<span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.findDecl.while$2" title="()Unit" class="delimiter">{</a>
        if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;Type.findDecl.e" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;ScopeEntry.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.hasFlag(f19781a561)" title="(mask: Long)Boolean">hasFlag</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.findDecl.excludedFlags" title="Int">excludedFlags</a>.<a href="../../Int.scala.html#scala;Int.toLong" title="=&gt; Long">toLong</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.findDecl.sym" title="Types.this.Symbol">sym</a> <span title="(x$1: Any)Boolean">==</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.findDecl.sym" title="Types.this.Symbol">sym</a> = <a href="#scala.reflect.internal;Types;Type.findDecl.e" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;ScopeEntry.sym" title="=&gt; Types.this.Symbol">sym</a>
          else <span class="delimiter">{</span>
            if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.findDecl.alts" title="List[Types.this.Symbol]">alts</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.findDecl.alts" title="List[Types.this.Symbol]">alts</a> = <a href="#scala.reflect.internal;Types;Type.findDecl.sym" title="Types.this.Symbol">sym</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
            <a href="#scala.reflect.internal;Types;Type.findDecl.alts" title="List[Types.this.Symbol]">alts</a> = <a href="#scala.reflect.internal;Types;Type.findDecl.e" title="Types.this.ScopeEntry">e</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;ScopeEntry.sym" title="=&gt; Types.this.Symbol">sym</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#scala.reflect.internal;Types;Type.findDecl.alts" title="List[Types.this.Symbol]">alts</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#scala.reflect.internal;Types;Type.findDecl.e" title="Types.this.ScopeEntry">e</a> = <a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.lookupNextEntry" title="(entry: Types.this.ScopeEntry)Types.this.ScopeEntry">lookupNextEntry</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.findDecl.e" title="Types.this.ScopeEntry">e</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.findDecl.alts" title="List[Types.this.Symbol]">alts</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.findDecl.sym" title="Types.this.Symbol">sym</a>
      else <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.baseClasses" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Symbol">head</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.newOverloaded" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.TermSymbol">newOverloaded</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;Type.findDecl.alts" title="List[Types.this.Symbol]">alts</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Find all members meeting the flag requirements.
     *
     * If you require a DEFERRED member, you will get it if it exists -- even if there's an overriding concrete member.
     * If you exclude DEFERRED members, or don't specify any requirements,
     *    you won't get deferred members (whether they have an overriding concrete member or not)
     *
     * Thus, findMember requiring DEFERRED flags yields deferred members,
     * while `findMember(excludedFlags = 0, requiredFlags = 0).filter(_.isDeferred)` may not (if there's a corresponding concrete member)
     *
     * Requirements take precedence over exclusions, so requiring and excluding DEFERRED will yield a DEFERRED member (if there is one).
     *
     */</span>
    def <a title="(excludedFlags: Long, requiredFlags: Long)Types.this.Scope" id="scala.reflect.internal;Types;Type.findMembers">findMembers</a><span class="delimiter">(</span><a title="Long" id="scala.reflect.internal;Types;Type.findMembers.excludedFlags">excludedFlags</a>: <a href="../../Long.scala.html#scala;Long" title="Long">Long</a>, <a title="Long" id="scala.reflect.internal;Types;Type.findMembers.requiredFlags">requiredFlags</a>: <a href="../../Long.scala.html#scala;Long" title="Long">Long</a><span class="delimiter">)</span>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> = <span class="delimiter">{</span>
      def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types;Type.findMembers.findMembersInternal">findMembersInternal</a> = new <a href="tpe/FindMembers.scala.html#scala.reflect.internal.tpe;FindMembers;FindMembers" title="Types.this.FindMembers">FindMembers</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;Type.findMembers.excludedFlags" title="Long">excludedFlags</a>, <a href="#scala.reflect.internal;Types;Type.findMembers.requiredFlags" title="Long">requiredFlags</a><span class="delimiter">)</span>.<a href="tpe/FindMembers.scala.html#scala.reflect.internal.tpe;FindMembers;FindMemberBase.apply" title="()Types.this.Scope">apply</a><span class="delimiter">(</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span>this.<a href="#scala.reflect.internal;Types;Type.isGround" title="=&gt; Boolean">isGround</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.findMembers.findMembersInternal" title="=&gt; Types.this.Scope">findMembersInternal</a>
      else <a href="#scala.reflect.internal;Types.suspendingTypeVars" title="(tvs: List[Types.this.TypeVar])(op: =&gt; Types.this.Scope)Types.this.Scope">suspendingTypeVars</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeVarsInType" title="(tp: Types.this.Type)List[Types.this.TypeVar]">typeVarsInType</a><span class="delimiter">(</span>this<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.findMembers.findMembersInternal" title="=&gt; Types.this.Scope">findMembersInternal</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     *  Find member(s) in this type. If several members matching criteria are found, they are
     *  returned in an OverloadedSymbol
     *
     *  @param name           The member's name
     *  @param excludedFlags  Returned members do not have these flags
     *  @param requiredFlags  Returned members do have these flags
     *  @param stableOnly     If set, return only members that are types or stable values
     */</span>
    def <a title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol" id="scala.reflect.internal;Types;Type.findMember">findMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="scala.reflect.internal;Types;Type.findMember.name">name</a>: <a href="Names.scala.html#scala.reflect.internal;Names;Name" title="Types.this.Name">Name</a>, <a title="Long" id="scala.reflect.internal;Types;Type.findMember.excludedFlags">excludedFlags</a>: <a href="../../Long.scala.html#scala;Long" title="Long">Long</a>, <a title="Long" id="scala.reflect.internal;Types;Type.findMember.requiredFlags">requiredFlags</a>: <a href="../../Long.scala.html#scala;Long" title="Long">Long</a>, <a title="Boolean" id="scala.reflect.internal;Types;Type.findMember.stableOnly">stableOnly</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;Type.findMember.findMemberInternal">findMemberInternal</a> = new <a href="tpe/FindMembers.scala.html#scala.reflect.internal.tpe;FindMembers;FindMember" title="Types.this.FindMember">FindMember</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;Type.findMember.name" title="Types.this.Name">name</a>, <a href="#scala.reflect.internal;Types;Type.findMember.excludedFlags" title="Long">excludedFlags</a>, <a href="#scala.reflect.internal;Types;Type.findMember.requiredFlags" title="Long">requiredFlags</a>, <a href="#scala.reflect.internal;Types;Type.findMember.stableOnly" title="Boolean">stableOnly</a><span class="delimiter">)</span>.<a href="tpe/FindMembers.scala.html#scala.reflect.internal.tpe;FindMembers;FindMemberBase.apply" title="()Types.this.Symbol">apply</a><span class="delimiter">(</span><span class="delimiter">)</span>

      if <span class="delimiter">(</span>this.<a href="#scala.reflect.internal;Types;Type.isGround" title="=&gt; Boolean">isGround</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.findMember.findMemberInternal" title="=&gt; Types.this.Symbol">findMemberInternal</a>
      else <a href="#scala.reflect.internal;Types.suspendingTypeVars" title="(tvs: List[Types.this.TypeVar])(op: =&gt; Types.this.Symbol)Types.this.Symbol">suspendingTypeVars</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeVarsInType" title="(tp: Types.this.Type)List[Types.this.TypeVar]">typeVarsInType</a><span class="delimiter">(</span>this<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.findMember.findMemberInternal" title="=&gt; Types.this.Symbol">findMemberInternal</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** The (existential or otherwise) skolems and existentially quantified variables which are free in this type */</span>
    def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams">skolemsExceptMethodTypeParams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      var <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.boundSyms">boundSyms</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
      var <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.skolems">skolems</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>
      for <span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.$anonfun.t">t</a> &lt;- this<span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.$anonfun.t" title="Types.this.Type">t</a> match <span class="delimiter">{</span>
          case ExistentialType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.$anonfun.quantified">quantified</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.$anonfun.qtpe">qtpe</a><span class="delimiter">)</span> =&gt;
            <a href="#scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.boundSyms" title="List[Types.this.Symbol]">boundSyms</a> = <a href="#scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.boundSyms" title="List[Types.this.Symbol]">boundSyms</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.:::" title="(prefix: List[Types.this.Symbol])List[Types.this.Symbol]">:::</a> <a href="#scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.$anonfun.quantified" title="List[Types.this.Symbol]">quantified</a>
          case TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.$anonfun.sym">sym</a>, _<span class="delimiter">)</span> =&gt;
            if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.$anonfun.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isExistentialSkolem" title="=&gt; Boolean">isExistentialSkolem</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.$anonfun.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isGADTSkolem" title="=&gt; Boolean">isGADTSkolem</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="comment">// treat GADT skolems like existential skolems</span>
                <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.boundSyms" title="List[Types.this.Symbol]">boundSyms</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: Types.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.$anonfun.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.skolems" title="List[Types.this.Symbol]">skolems</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: Types.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.$anonfun.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.skolems" title="List[Types.this.Symbol]">skolems</a> = <a href="#scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.$anonfun.sym" title="Types.this.Symbol">sym</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.skolems" title="List[Types.this.Symbol]">skolems</a>
          case _ =&gt;
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal;Types;Type.skolemsExceptMethodTypeParams.skolems" title="List[Types.this.Symbol]">skolems</a>
    <span class="delimiter">}</span>

    <span class="comment">// Implementation of Annotatable for all types but AnnotatedType, which</span>
    <span class="comment">// overrides these.</span>
    def <a title="=&gt; List[Types.this.AnnotationInfo]" id="scala.reflect.internal;Types;Type.annotations">annotations</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span> = <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;Type.withoutAnnotations">withoutAnnotations</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = this
    def <a title="(p: Types.this.AnnotationInfo =&gt; Boolean)Types.this.Type" id="scala.reflect.internal;Types;Type.filterAnnotations">filterAnnotations</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo =&gt; Boolean" id="scala.reflect.internal;Types;Type.filterAnnotations.p">p</a>: AnnotationInfo =&gt; Boolean<span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = this
    def <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="scala.reflect.internal;Types;Type.setAnnotations">setAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="scala.reflect.internal;Types;Type.setAnnotations.annots">annots</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>  = <a href="#scala.reflect.internal;Types.annotatedType" title="(annots: List[Types.this.AnnotationInfo], underlying: Types.this.Type)Types.this.Type">annotatedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.setAnnotations.annots" title="List[Types.this.AnnotationInfo]">annots</a>, this<span class="delimiter">)</span>
    def <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="scala.reflect.internal;Types;Type.withAnnotations">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="scala.reflect.internal;Types;Type.withAnnotations.annots">annots</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.annotatedType" title="(annots: List[Types.this.AnnotationInfo], underlying: Types.this.Type)Types.this.Type">annotatedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.withAnnotations.annots" title="List[Types.this.AnnotationInfo]">annots</a>, this<span class="delimiter">)</span>

    <span class="comment">/** The kind of this type; used for debugging */</span>
    def <a title="=&gt; String" id="scala.reflect.internal;Types;Type.kind">kind</a>: <span title="String">String</span> = <span title="String(&quot;unknown type of class &quot;)" class="string">&quot;unknown type of class &quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.reflect.internal;Types;Type" title="()Class[_]">getClass</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

<span class="comment">// Subclasses ------------------------------------------------------------</span>

  <span class="comment">/**
   *  A type that can be passed to unique(..) and be stored in the uniques map.
   */</span>
  abstract class <a title="class UniqueType extends Types.this.Type with Product" id="scala.reflect.internal;Types;UniqueType">UniqueType</a> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> with <a href="../../Product.scala.html#scala;Product" title="Product">Product</a> <span class="delimiter">{</span>
    final override val <a title="Int" id="scala.reflect.internal;Types;UniqueType.hashCode">hashCode</a> = <a href="#scala.reflect.internal;Types;UniqueType.computeHashCode" title="=&gt; Int">computeHashCode</a>
    protected def <a title="=&gt; Int" id="scala.reflect.internal;Types;UniqueType.computeHashCode">computeHashCode</a> = scala.runtime.<a href="../../runtime/ScalaRunTime.scala.html#scala.runtime.ScalaRunTime" title="scala.runtime.ScalaRunTime.type">ScalaRunTime</a>.<a href="../../runtime/ScalaRunTime.scala.html#scala.runtime.ScalaRunTime._hashCode" title="(x: Product)Int">_hashCode</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
  <span class="delimiter">}</span>

 <span class="comment">/** A base class for types that defer some operations
   *  to their immediate supertype.
   */</span>
  abstract class <a title="class SubType extends Types.this.UniqueType" id="scala.reflect.internal;Types;SubType">SubType</a> extends <a href="#scala.reflect.internal;Types;UniqueType" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;SubType.supertype">supertype</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>
    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;SubType.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;SubType.supertype" title="=&gt; Types.this.Type">supertype</a>.<a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a>
    override def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types;SubType.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> = <a href="#scala.reflect.internal;Types;SubType.supertype" title="=&gt; Types.this.Type">supertype</a>.<a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a>
    override def <a title="(clazz: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;SubType.baseType">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;SubType.baseType.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;SubType.supertype" title="=&gt; Types.this.Type">supertype</a>.<a href="#scala.reflect.internal;Types;Type.baseType" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;SubType.baseType.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;SubType.baseTypeSeq">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#scala.reflect.internal;Types;SubType.supertype" title="=&gt; Types.this.Type">supertype</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    override def <a title="=&gt; scala.reflect.internal.Depth" id="scala.reflect.internal;Types;SubType.baseTypeSeqDepth">baseTypeSeqDepth</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <a href="#scala.reflect.internal;Types;SubType.supertype" title="=&gt; Types.this.Type">supertype</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeqDepth" title="=&gt; scala.reflect.internal.Depth">baseTypeSeqDepth</a>
    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;SubType.baseClasses">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;SubType.supertype" title="=&gt; Types.this.Type">supertype</a>.<a href="#scala.reflect.internal;Types;Type.baseClasses" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A base class for types that represent a single value
   *  (single-types and this-types).
   */</span>
  abstract class <a title="class SingletonType extends Types.this.SubType with Types.this.SimpleTypeProxy with Types.this.SingletonTypeApi" id="scala.reflect.internal;Types;SingletonType">SingletonType</a> extends <a href="#scala.reflect.internal;Types;SubType" title="Types.this.SubType">SubType</a> with <a href="#scala.reflect.internal;Types;SimpleTypeProxy" title="Types.this.SimpleTypeProxy">SimpleTypeProxy</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;SingletonTypeApi" title="Types.this.SingletonTypeApi">SingletonTypeApi</a> <span class="delimiter">{</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;SingletonType.supertype">supertype</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;SingletonType.isTrivial">isTrivial</a> = false
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;SingletonType.widen">widen</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a>
    override def <a title="=&gt; Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;SingletonType.baseTypeSeq">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.incCounter(456ea4fa07)" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.singletonBaseTypeSeqCount" title="=&gt; scala.reflect.internal.util.Statistics.SubCounter">singletonBaseTypeSeqCount</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.prepend" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">prepend</a> this
    <span class="delimiter">}</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;SingletonType.isHigherKinded">isHigherKinded</a> = false <span class="comment">// singleton type classifies objects, thus must be kind *</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;SingletonType.safeToString">safeToString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span class="comment">// Avoiding printing Predef.type and scala.package.type as &quot;type&quot;,</span>
      <span class="comment">// since in all other cases we omit those prefixes.</span>
      val <a title="Types.this.Symbol" id="scala.reflect.internal;Types;SingletonType.safeToString.pre">pre</a> = <a href="#scala.reflect.internal;Types;Type.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.skipPackageObject" title="=&gt; Types.this.Symbol">skipPackageObject</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;SingletonType.safeToString.pre" title="Types.this.Symbol">pre</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isOmittablePrefix" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;SingletonType.safeToString.pre" title="Types.this.Symbol">pre</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.fullName(3bf7c90be7)" title="=&gt; String">fullName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.type&quot;)" class="string">&quot;.type&quot;</span>
      else <a href="#scala.reflect.internal;Types;Type.prefixString" title="=&gt; String">prefixString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;type&quot;)" class="string">&quot;type&quot;</span>
    <span class="delimiter">}</span>
<span class="comment">/*
    override def typeOfThis: Type = typeSymbol.typeOfThis
    override def bounds: TypeBounds = TypeBounds(this, this)
    override def prefix: Type = NoType
    override def typeArgs: List[Type] = List()
    override def typeParams: List[Symbol] = List()
*/</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An object representing an erroneous type */</span>
  case object <a href="#scala.reflect.internal;Types.ErrorType.productElement.x$1" title="Types.this.ErrorType.type" id="scala.reflect.internal;Types.ErrorType.readResolve">ErrorType</a> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    <span class="comment">// todo see whether we can do without</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types.ErrorType.isError">isError</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = true
    override def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types.ErrorType.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> = new <a href="Scopes.scala.html#scala.reflect.internal;Scopes;ErrorScope" title="Types.this.ErrorScope">ErrorScope</a><span class="delimiter">(</span><a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
    override def <a title="(name: Types.this.Name, excludedFlags: Long, requiredFlags: Long, stableOnly: Boolean)Types.this.Symbol" id="scala.reflect.internal;Types.ErrorType.findMember">findMember</a><span class="delimiter">(</span><a title="Types.this.Name" id="scala.reflect.internal;Types.ErrorType.findMember.name">name</a>: <a href="Names.scala.html#scala.reflect.internal;Names;Name" title="Types.this.Name">Name</a>, <a title="Long" id="scala.reflect.internal;Types.ErrorType.findMember.excludedFlags">excludedFlags</a>: <a href="../../Long.scala.html#scala;Long" title="Long">Long</a>, <a title="Long" id="scala.reflect.internal;Types.ErrorType.findMember.requiredFlags">requiredFlags</a>: <a href="../../Long.scala.html#scala;Long" title="Long">Long</a>, <a title="Boolean" id="scala.reflect.internal;Types.ErrorType.findMember.stableOnly">stableOnly</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
      var sym = <a href="#scala.reflect.internal;Types.ErrorType.decls" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.lookup" title="Types.this.Symbol" id="scala.reflect.internal;Types.ErrorType.findMember.sym">lookup</a> <a href="#scala.reflect.internal;Types.ErrorType.findMember.name" title="Types.this.Name">name</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.ErrorType.findMember.sym" title="Types.this.Symbol">sym</a> <span title="(x$1: Any)Boolean">==</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types.ErrorType.findMember.sym" title="Types.this.Symbol">sym</a> = <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.newErrorSymbol" title="(name: Types.this.Name)Types.this.Symbol">newErrorSymbol</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.ErrorType.findMember.name" title="Types.this.Name">name</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types.ErrorType.decls" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.enter" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#scala.reflect.internal;Types.ErrorType.findMember.sym" title="Types.this.Symbol">sym</a>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal;Types.ErrorType.findMember.sym" title="Types.this.Symbol">sym</a>
    <span class="delimiter">}</span>
    override def <a title="(clazz: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types.ErrorType.baseType">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.ErrorType.baseType.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = this
    override def <a title="=&gt; String" id="scala.reflect.internal;Types.ErrorType.safeToString">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;&lt;error&gt;&quot;)" class="string">&quot;&lt;error&gt;&quot;</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types.ErrorType.narrow">narrow</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = this
    override def <a title="=&gt; String" id="scala.reflect.internal;Types.ErrorType.kind">kind</a> = <span title="String(&quot;ErrorType&quot;)" class="string">&quot;ErrorType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An object representing an unknown type, used during type inference.
   *  If you see WildcardType outside of inference it is almost certainly a bug.
   */</span>
  case object <a href="#scala.reflect.internal;Types.WildcardType.productElement.x$1" title="Types.this.WildcardType.type" id="scala.reflect.internal;Types.WildcardType.readResolve">WildcardType</a> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types.WildcardType.isWildcard">isWildcard</a> = true
    override def <a title="=&gt; String" id="scala.reflect.internal;Types.WildcardType.safeToString">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types.WildcardType.kind">kind</a> = <span title="String(&quot;WildcardType&quot;)" class="string">&quot;WildcardType&quot;</span>
  <span class="delimiter">}</span>
  <span class="comment">/** BoundedWildcardTypes, used only during type inference, are created in
   *  two places that I can find:
   *
   *    1. If the expected type of an expression is an existential type,
   *       its hidden symbols are replaced with bounded wildcards.
   *    2. When an implicit conversion is being sought based in part on
   *       the name of a method in the converted type, a HasMethodMatching
   *       type is created: a MethodType with parameters typed as
   *       BoundedWildcardTypes.
   */</span>
  case class <a title="class BoundedWildcardType extends Types.this.Type with Types.this.BoundedWildcardTypeApi with Product with Serializable" id="scala.reflect.internal;Types;BoundedWildcardType">BoundedWildcardType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a>override val <a title="Types.this.TypeBounds" id="scala.reflect.internal;Types;BoundedWildcardType.bounds">bounds</a>: <a href="#scala.reflect.internal;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;BoundedWildcardTypeApi" title="Types.this.BoundedWildcardTypeApi">BoundedWildcardTypeApi</a> <span class="delimiter">{</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;BoundedWildcardType.isWildcard">isWildcard</a> = true
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;BoundedWildcardType.safeToString">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;BoundedWildcardType.bounds" title="=&gt; Types.this.TypeBounds">bounds</a>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;BoundedWildcardType.kind">kind</a> = <span title="String(&quot;BoundedWildcardType&quot;)" class="string">&quot;BoundedWildcardType&quot;</span>
  <span class="delimiter">}</span>

  object <a title="Types.this.BoundedWildcardType.type" id="scala.reflect.internal;Types.BoundedWildcardType.readResolve">BoundedWildcardType</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;BoundedWildcardTypeExtractor" title="Types.this.BoundedWildcardTypeExtractor">BoundedWildcardTypeExtractor</a>

  <span class="comment">/** An object representing a non-existing type */</span>
  case object <a href="#scala.reflect.internal;Types.NoType.productElement.x$1" title="Types.this.NoType.type" id="scala.reflect.internal;Types.NoType.readResolve">NoType</a> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types.NoType.isTrivial">isTrivial</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = true
    override def <a title="=&gt; String" id="scala.reflect.internal;Types.NoType.safeToString">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;&lt;notype&gt;&quot;)" class="string">&quot;&lt;notype&gt;&quot;</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types.NoType.kind">kind</a> = <span title="String(&quot;NoType&quot;)" class="string">&quot;NoType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An object representing a non-existing prefix */</span>
  case object <a href="#scala.reflect.internal;Types.NoPrefix.productElement.x$1" title="Types.this.NoPrefix.type" id="scala.reflect.internal;Types.NoPrefix.readResolve">NoPrefix</a> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types.NoPrefix.isTrivial">isTrivial</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = true
    override def <a title="=&gt; String" id="scala.reflect.internal;Types.NoPrefix.prefixString">prefixString</a> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types.NoPrefix.safeToString">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;&lt;noprefix&gt;&quot;)" class="string">&quot;&lt;noprefix&gt;&quot;</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types.NoPrefix.kind">kind</a> = <span title="String(&quot;NoPrefixType&quot;)" class="string">&quot;NoPrefixType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class for this-types of the form &lt;sym&gt;.this.type
   */</span>
  abstract case class <a href="#scala.reflect.internal;Types;ThisType.productElement.x$1" title="class ThisType extends Types.this.SingletonType with Types.this.ThisTypeApi with Product with Serializable" id="scala.reflect.internal;Types;ThisType">ThisType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ThisType.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;SingletonType" title="Types.this.SingletonType">SingletonType</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;ThisTypeApi" title="Types.this.ThisTypeApi">ThisTypeApi</a> <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isClass" title="=&gt; Boolean">isClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;SymbolContextApiImpl.isFreeType" title="=&gt; Boolean">isFreeType</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// SI-6640 allow StubSymbols to reveal what's missing from the classpath before we trip the assertion.</span>
      <a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.failIfStub" title="()Unit">failIfStub</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="Reporting.scala.html#scala.reflect.internal;Reporting.abort" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;ThisType(&quot;)">ThisType($</span><a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a><span title="String(&quot;) for sym which is not a class&quot;)" class="string">) for sym which is not a class&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;ThisType.isTrivial">isTrivial</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;ThisType.typeSymbol">typeSymbol</a> = <a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;ThisType.underlying">underlying</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeOfThis" title="=&gt; Types.this.Type">typeOfThis</a>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;ThisType.isHigherKinded">isHigherKinded</a> = <a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isRefinementClass" title="=&gt; Boolean">isRefinementClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;ThisType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ThisType.prefixString">prefixString</a> =
      if <span class="delimiter">(</span><a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">debug</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.nameString" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.this.&quot;)" class="string">&quot;.this.&quot;</span>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAnonOrRefinementClass" title="=&gt; Boolean">isAnonOrRefinementClass</a><span class="delimiter">)</span> <span title="String(&quot;this.&quot;)" class="string">&quot;this.&quot;</span>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isOmittablePrefix" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModuleClass" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.fullNameString" title="=&gt; String">fullNameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      else <a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.nameString" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.this.&quot;)" class="string">&quot;.this.&quot;</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ThisType.safeToString">safeToString</a>: <span title="String">String</span> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isEffectiveRoot" title="=&gt; Boolean">isEffectiveRoot</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;ThisType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; ThisType.this.sym.NameType">name</a>
      else super.<a href="#scala.reflect.internal;Types;SingletonType.safeToString" title="=&gt; String">safeToString</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;ThisType.narrow">narrow</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = this
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ThisType.kind">kind</a> = <span title="String(&quot;ThisType&quot;)" class="string">&quot;ThisType&quot;</span>
  <span class="delimiter">}</span>

  final class <a title="class UniqueThisType extends Types.this.ThisType" id="scala.reflect.internal;Types;UniqueThisType">UniqueThisType</a><a href="#scala.reflect.internal;Types;UniqueThisType" title="Types.this.UniqueThisType" class="delimiter">(</a><a title="Types.this.Symbol" id="scala.reflect.internal;Types;UniqueThisType.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;ThisType" title="Types.this.ThisType">ThisType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;UniqueThisType.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">}</span>

  object <a title="Types.this.ThisType.type" id="scala.reflect.internal;Types.ThisType.readResolve">ThisType</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;ThisTypeExtractor" title="Types.this.ThisTypeExtractor">ThisTypeExtractor</a> <span class="delimiter">{</span>
    def <a title="(sym: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types.ThisType.apply(a489b0ed7a)">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.ThisType.apply(a489b0ed7a).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.unique" title="(tp: Types.this.UniqueThisType)Types.this.UniqueThisType">unique</a><span class="delimiter">(</span>new <a href="#scala.reflect.internal;Types;UniqueThisType" title="Types.this.UniqueThisType">UniqueThisType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.ThisType.apply(a489b0ed7a).sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.ThisType.apply(a489b0ed7a).sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isImplClass" title="=&gt; Boolean">isImplClass</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.ThisType.apply(a489b0ed7a).sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeOfThis" title="=&gt; Types.this.Type">typeOfThis</a>
      else <a href="#scala.reflect.internal;Types.ThisType.apply(a489b0ed7a).sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe_*" title="=&gt; Types.this.Type">tpe_*</a>
    <span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class for singleton types of the form `&lt;prefix&gt;.&lt;sym.name&gt;.type`.
   *  Cannot be created directly; one should always use `singleType` for creation.
   */</span>
  abstract case class <a href="#scala.reflect.internal;Types;SingleType.productElement.x$1" title="class SingleType extends Types.this.SingletonType with Types.this.SingleTypeApi with Product with Serializable" id="scala.reflect.internal;Types;SingleType">SingleType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;SingleType.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;SingleType.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;SingletonType" title="Types.this.SingletonType">SingletonType</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;SingleTypeApi" title="Types.this.SingleTypeApi">SingleTypeApi</a> <span class="delimiter">{</span>
    private var <a title="scala.reflect.internal.util.ThreeValues.ThreeValue" id="scala.reflect.internal;Types;SingleType.trivial_=">trivial</a>: <a href="../../Byte.scala.html#scala;Byte" title="scala.reflect.internal.util.ThreeValues.ThreeValue">ThreeValue</a> = <span title="Byte(0)">UNKNOWN</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;SingleType.isTrivial">isTrivial</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;SingleType.trivial_=" title="=&gt; scala.reflect.internal.util.ThreeValues.ThreeValue">trivial</a> <a href="../../Byte.scala.html#scala;Byte.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(0)">UNKNOWN</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;SingleType.trivial_=" title="(x$1: scala.reflect.internal.util.ThreeValues.ThreeValue)Unit">trivial</a> = <a href="util/ThreeValues.scala.html#scala.reflect.internal.util.ThreeValues.fromBoolean" title="(b: Boolean)scala.reflect.internal.util.ThreeValues.ThreeValue">fromBoolean</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;SingleType.pre" title="=&gt; Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.isTrivial" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span>
      <a href="util/ThreeValues.scala.html#scala.reflect.internal.util.ThreeValues.toBoolean" title="(x: scala.reflect.internal.util.ThreeValues.ThreeValue)Boolean">toBoolean</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;SingleType.trivial_=" title="=&gt; scala.reflect.internal.util.ThreeValues.ThreeValue">trivial</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;SingleType.isGround">isGround</a> = <a href="#scala.reflect.internal;Types;SingleType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types;SingleType.pre" title="=&gt; Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.isGround" title="=&gt; Boolean">isGround</a>

    private<span class="delimiter">[</span>reflect<span class="delimiter">]</span> var <a title="Types.this.Type" id="scala.reflect.internal;Types;SingleType.underlyingCache_=">underlyingCache</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
    private<span class="delimiter">[</span>reflect<span class="delimiter">]</span> var <a title="Int" id="scala.reflect.internal;Types;SingleType.underlyingPeriod_=">underlyingPeriod</a> = <span title="Int(0)">NoPeriod</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;SingleType.underlying">underlying</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      val <a title="Types.this.Type" id="scala.reflect.internal;Types;SingleType.underlying.cache">cache</a> = <a href="#scala.reflect.internal;Types;SingleType.underlyingCache_=" title="=&gt; Types.this.Type">underlyingCache</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;SingleType.underlyingPeriod_=" title="=&gt; Int">underlyingPeriod</a> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;SingleType.underlying.cache" title="Types.this.Type">cache</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;SingleType.underlying.cache" title="Types.this.Type">cache</a>
      else <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types.defineUnderlyingOfSingleType" title="(tpe: Types.this.SingleType)Unit">defineUnderlyingOfSingleType</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;SingleType.underlyingCache_=" title="=&gt; Types.this.Type">underlyingCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">// more precise conceptually, but causes cyclic errors:    (paramss exists (_ contains sym))</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;SingleType.isImmediatelyDependent">isImmediatelyDependent</a> = <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;SingleType.sym" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;SingleType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isMethod" title="=&gt; Boolean">isMethod</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;SingleType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isValueParameter" title="=&gt; Boolean">isValueParameter</a><span class="delimiter">)</span>
<span class="comment">/*
    override def narrow: Type = {
      if (phase.erasedTypes) this
      else {
        val thissym = refinedType(List(this), sym.owner, EmptyScope).typeSymbol
        if (sym.owner != NoSymbol) {
          //Console.println(&quot;narrowing module &quot; + sym + thissym.owner);
          thissym.typeOfThis = this
        }
        thissym.thisType
      }
    }
*/</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;SingleType.narrow">narrow</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = this

    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;SingleType.termSymbol">termSymbol</a> = <a href="#scala.reflect.internal;Types;SingleType.sym" title="=&gt; Types.this.Symbol">sym</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;SingleType.prefix">prefix</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;SingleType.pre" title="=&gt; Types.this.Type">pre</a>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;SingleType.prefixString">prefixString</a> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;SingleType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.skipPackageObject" title="=&gt; Types.this.Symbol">skipPackageObject</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isOmittablePrefix" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;SingleType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageObjectOrClass" title="=&gt; Boolean">isPackageObjectOrClass</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;SingleType.pre" title="=&gt; Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.prefixString" title="=&gt; String">prefixString</a>
      else <a href="#scala.reflect.internal;Types;SingleType.pre" title="=&gt; Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.prefixString" title="=&gt; String">prefixString</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;SingleType.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.nameString" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
    <span class="delimiter">)</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;SingleType.kind">kind</a> = <span title="String(&quot;SingleType&quot;)" class="string">&quot;SingleType&quot;</span>
  <span class="delimiter">}</span>

  final class <a title="class UniqueSingleType extends Types.this.SingleType" id="scala.reflect.internal;Types;UniqueSingleType">UniqueSingleType</a><a href="#scala.reflect.internal;Types;UniqueSingleType" title="Types.this.UniqueSingleType" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;UniqueSingleType.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;UniqueSingleType.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;SingleType" title="Types.this.SingleType">SingleType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;UniqueSingleType.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;UniqueSingleType.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

  object <a title="Types.this.SingleType.type" id="scala.reflect.internal;Types.SingleType.readResolve">SingleType</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;SingleTypeExtractor" title="Types.this.SingleTypeExtractor">SingleTypeExtractor</a> <span class="delimiter">{</span>
    def <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types.SingleType.apply(383b209a7d)">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.SingleType.apply(383b209a7d).pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.SingleType.apply(383b209a7d).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#scala.reflect.internal;Types.unique" title="(tp: Types.this.UniqueSingleType)Types.this.UniqueSingleType">unique</a><span class="delimiter">(</span>new <a href="#scala.reflect.internal;Types;UniqueSingleType" title="Types.this.UniqueSingleType">UniqueSingleType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.SingleType.apply(383b209a7d).pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.SingleType.apply(383b209a7d).sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  protected def <a title="(tpe: Types.this.SingleType)Unit" id="scala.reflect.internal;Types.defineUnderlyingOfSingleType">defineUnderlyingOfSingleType</a><span class="delimiter">(</span><a title="Types.this.SingleType" id="scala.reflect.internal;Types.defineUnderlyingOfSingleType.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;SingleType" title="Types.this.SingleType">SingleType</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="Int" id="scala.reflect.internal;Types.defineUnderlyingOfSingleType.period">period</a> = <a href="#scala.reflect.internal;Types.defineUnderlyingOfSingleType.tpe" title="Types.this.SingleType">tpe</a>.<a href="#scala.reflect.internal;Types;SingleType.underlyingPeriod_=" title="=&gt; Int">underlyingPeriod</a>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineUnderlyingOfSingleType.period" title="Int">period</a> <a href="../../Int.scala.html#scala;Int.!=(5f58a84eb3)" title="(x: Int)Boolean">!=</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#scala.reflect.internal;Types.defineUnderlyingOfSingleType.tpe" title="Types.this.SingleType">tpe</a>.<a href="#scala.reflect.internal;Types;SingleType.underlyingPeriod_=" title="(x$1: Int)Unit">underlyingPeriod</a> = <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.isValid" title="(period: Types.this.Period)Boolean">isValid</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineUnderlyingOfSingleType.period" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// [Eugene to Paul] needs review</span>
        <a href="#scala.reflect.internal;Types.defineUnderlyingOfSingleType.tpe" title="Types.this.SingleType">tpe</a>.<a href="#scala.reflect.internal;Types;SingleType.underlyingCache_=" title="(x$1: Types.this.Type)Unit">underlyingCache</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineUnderlyingOfSingleType.tpe" title="Types.this.SingleType">tpe</a>.<a href="#scala.reflect.internal;Types;SingleType.sym" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: Any)Boolean">==</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.ThisType.apply(a489b0ed7a)" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="../api/Mirrors.scala.html#scala.reflect.api;Mirrors.rootMirror" title="=&gt; Types.this.Mirror">rootMirror</a>.<a href="Mirrors.scala.html#scala.reflect.internal;Mirrors;RootsBase.RootClass" title="=&gt; Types.this.ClassSymbol">RootClass</a><span class="delimiter">)</span> else <a href="#scala.reflect.internal;Types.defineUnderlyingOfSingleType.tpe" title="Types.this.SingleType">tpe</a>.<a href="#scala.reflect.internal;Types;SingleType.pre" title="=&gt; Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.memberType" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineUnderlyingOfSingleType.tpe" title="Types.this.SingleType">tpe</a>.<a href="#scala.reflect.internal;Types;SingleType.sym" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.resultType(9b9cdebb0f)" title="=&gt; Types.this.Type">resultType</a>
        <a href="../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineUnderlyingOfSingleType.tpe" title="Types.this.SingleType">tpe</a>.<a href="#scala.reflect.internal;Types;SingleType.underlyingCache_=" title="=&gt; Types.this.Type">underlyingCache</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types.defineUnderlyingOfSingleType.tpe" title="Types.this.SingleType">tpe</a>, <a href="#scala.reflect.internal;Types.defineUnderlyingOfSingleType.tpe" title="Types.this.SingleType">tpe</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  abstract case class <a href="#scala.reflect.internal;Types;SuperType.productElement.x$1" title="class SuperType extends Types.this.SingletonType with Types.this.SuperTypeApi with Product with Serializable" id="scala.reflect.internal;Types;SuperType">SuperType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;SuperType.thistpe">thistpe</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;SuperType.supertpe">supertpe</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;SingletonType" title="Types.this.SingletonType">SingletonType</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;SuperTypeApi" title="Types.this.SuperTypeApi">SuperTypeApi</a> <span class="delimiter">{</span>
    private var <a title="scala.reflect.internal.util.ThreeValues.ThreeValue" id="scala.reflect.internal;Types;SuperType.trivial_=">trivial</a>: <a href="../../Byte.scala.html#scala;Byte" title="scala.reflect.internal.util.ThreeValues.ThreeValue">ThreeValue</a> = <span title="Byte(0)">UNKNOWN</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;SuperType.isTrivial">isTrivial</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;SuperType.trivial_=" title="=&gt; scala.reflect.internal.util.ThreeValues.ThreeValue">trivial</a> <a href="../../Byte.scala.html#scala;Byte.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(0)">UNKNOWN</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;SuperType.trivial_=" title="(x$1: scala.reflect.internal.util.ThreeValues.ThreeValue)Unit">trivial</a> = <a href="util/ThreeValues.scala.html#scala.reflect.internal.util.ThreeValues.fromBoolean" title="(b: Boolean)scala.reflect.internal.util.ThreeValues.ThreeValue">fromBoolean</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;SuperType.thistpe" title="=&gt; Types.this.Type">thistpe</a>.<a href="#scala.reflect.internal;Types;Type.isTrivial" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;SuperType.supertpe" title="=&gt; Types.this.Type">supertpe</a>.<a href="#scala.reflect.internal;Types;Type.isTrivial" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span>
      <a href="util/ThreeValues.scala.html#scala.reflect.internal.util.ThreeValues.toBoolean" title="(x: scala.reflect.internal.util.ThreeValues.ThreeValue)Boolean">toBoolean</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;SuperType.trivial_=" title="=&gt; scala.reflect.internal.util.ThreeValues.ThreeValue">trivial</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;SuperType.typeSymbol">typeSymbol</a> = <a href="#scala.reflect.internal;Types;SuperType.thistpe" title="=&gt; Types.this.Type">thistpe</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;SuperType.underlying">underlying</a> = <a href="#scala.reflect.internal;Types;SuperType.supertpe" title="=&gt; Types.this.Type">supertpe</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;SuperType.prefix">prefix</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;SuperType.supertpe" title="=&gt; Types.this.Type">supertpe</a>.<a href="#scala.reflect.internal;Types;Type.prefix" title="=&gt; Types.this.Type">prefix</a>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;SuperType.prefixString">prefixString</a> = <a href="#scala.reflect.internal;Types;SuperType.thistpe" title="=&gt; Types.this.Type">thistpe</a>.<a href="#scala.reflect.internal;Types;Type.prefixString" title="=&gt; String">prefixString</a>.<span title="(x$1: String, x$2: String)String">replaceAll</span><span class="delimiter">(</span><span title="String(&quot;\\bthis\\.$&quot;)" class="string">&quot;&quot;&quot;\bthis\.$&quot;&quot;&quot;</span>, <span title="String(&quot;super.&quot;)" class="string">&quot;super.&quot;</span><span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;SuperType.narrow">narrow</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;SuperType.thistpe" title="=&gt; Types.this.Type">thistpe</a>.<a href="#scala.reflect.internal;Types;Type.narrow" title="=&gt; Types.this.Type">narrow</a>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;SuperType.kind">kind</a> = <span title="String(&quot;SuperType&quot;)" class="string">&quot;SuperType&quot;</span>
  <span class="delimiter">}</span>

  final class <a title="class UniqueSuperType extends Types.this.SuperType" id="scala.reflect.internal;Types;UniqueSuperType">UniqueSuperType</a><a href="#scala.reflect.internal;Types;UniqueSuperType" title="Types.this.UniqueSuperType" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;UniqueSuperType.thistp">thistp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;UniqueSuperType.supertp">supertp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;SuperType" title="Types.this.SuperType">SuperType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;UniqueSuperType.thistp" title="Types.this.Type">thistp</a>, <a href="#scala.reflect.internal;Types;UniqueSuperType.supertp" title="Types.this.Type">supertp</a><span class="delimiter">)</span>

  object <a title="Types.this.SuperType.type" id="scala.reflect.internal;Types.SuperType.readResolve">SuperType</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;SuperTypeExtractor" title="Types.this.SuperTypeExtractor">SuperTypeExtractor</a> <span class="delimiter">{</span>
    def <a title="(thistp: Types.this.Type, supertp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.SuperType.apply(6f0c418900)">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.SuperType.apply(6f0c418900).thistp">thistp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.SuperType.apply(6f0c418900).supertp">supertp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.SuperType.apply(6f0c418900).supertp" title="Types.this.Type">supertp</a>
      else <a href="#scala.reflect.internal;Types.unique" title="(tp: Types.this.UniqueSuperType)Types.this.UniqueSuperType">unique</a><span class="delimiter">(</span>new <a href="#scala.reflect.internal;Types;UniqueSuperType" title="Types.this.UniqueSuperType">UniqueSuperType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.SuperType.apply(6f0c418900).thistp" title="Types.this.Type">thistp</a>, <a href="#scala.reflect.internal;Types.SuperType.apply(6f0c418900).supertp" title="Types.this.Type">supertp</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class for the bounds of abstract types and type parameters
   */</span>
  abstract case class <a href="#scala.reflect.internal;Types;TypeBounds.productElement.x$1" title="class TypeBounds extends Types.this.SubType with Types.this.TypeBoundsApi with Product with Serializable" id="scala.reflect.internal;Types;TypeBounds">TypeBounds</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeBounds.lo">lo</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeBounds.hi">hi</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;SubType" title="Types.this.SubType">SubType</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;TypeBoundsApi" title="Types.this.TypeBoundsApi">TypeBoundsApi</a> <span class="delimiter">{</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;TypeBounds.supertype">supertype</a> = <a href="#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; Types.this.Type">hi</a>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeBounds.isTrivial">isTrivial</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types;TypeBounds.lo" title="=&gt; Types.this.Type">lo</a>.<a href="#scala.reflect.internal;Types;Type.isTrivial" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; Types.this.Type">hi</a>.<a href="#scala.reflect.internal;Types;Type.isTrivial" title="=&gt; Boolean">isTrivial</a>
    override def <a title="=&gt; Types.this.TypeBounds" id="scala.reflect.internal;Types;TypeBounds.bounds">bounds</a>: <a href="#scala.reflect.internal;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a> = this
    def <a title="(that: Types.this.Type)Boolean" id="scala.reflect.internal;Types;TypeBounds.containsType">containsType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeBounds.containsType.that">that</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;TypeBounds.containsType.that" title="Types.this.Type">that</a> match <span class="delimiter">{</span>
      case TypeBounds<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types;TypeBounds.containsType.that" title="Types.this.Type">that</a> <a href="#scala.reflect.internal;Types;Type.<:<" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> this
      case _                =&gt; <a href="#scala.reflect.internal;Types;TypeBounds.lo" title="=&gt; Types.this.Type">lo</a> <a href="#scala.reflect.internal;Types;Type.<:<" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#scala.reflect.internal;Types;TypeBounds.containsType.that" title="Types.this.Type">that</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;TypeBounds.containsType.that" title="Types.this.Type">that</a> <a href="#scala.reflect.internal;Types;Type.<:<" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; Types.this.Type">hi</a>
    <span class="delimiter">}</span>
    private def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeBounds.emptyLowerBound">emptyLowerBound</a> = <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Types.this.Type)Boolean">typeIsNothing</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeBounds.lo" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types;TypeBounds.lo" title="=&gt; Types.this.Type">lo</a>.<a href="#scala.reflect.internal;Types;Type.isWildcard" title="=&gt; Boolean">isWildcard</a>
    private def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeBounds.emptyUpperBound">emptyUpperBound</a> = <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Types.this.Type)Boolean">typeIsAny</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; Types.this.Type">hi</a>.<a href="#scala.reflect.internal;Types;Type.isWildcard" title="=&gt; Boolean">isWildcard</a>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeBounds.isEmptyBounds">isEmptyBounds</a> = <a href="#scala.reflect.internal;Types;TypeBounds.emptyLowerBound" title="=&gt; Boolean">emptyLowerBound</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;TypeBounds.emptyUpperBound" title="=&gt; Boolean">emptyUpperBound</a>

    override def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeBounds.safeToString">safeToString</a> = <a href="#scala.reflect.internal;Types;TypeBounds.scalaNotation" title="(typeString: Types.this.Type =&gt; String)String">scalaNotation</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeBounds.safeToString.$anonfun.x$17" title="Types.this.Type">_</a>.<a href="#scala.reflect.internal;Types;Type.toString" title="()String">toString</a><span class="delimiter">)</span>

    <span class="comment">/** Bounds notation used in Scala syntax.
      * For example +This &lt;: scala.collection.generic.Sorted[K,This].
      */</span>
    private<span class="delimiter">[</span>internal<span class="delimiter">]</span> def <a title="(typeString: Types.this.Type =&gt; String)String" id="scala.reflect.internal;Types;TypeBounds.scalaNotation">scalaNotation</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; String" id="scala.reflect.internal;Types;TypeBounds.scalaNotation.typeString">typeString</a>: Type =&gt; String<span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeBounds.emptyLowerBound" title="=&gt; Boolean">emptyLowerBound</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> else <span title="String(&quot; &gt;: &quot;)" class="string">&quot; &gt;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Types.this.Type)String">typeString</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeBounds.lo" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span>
      <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeBounds.emptyUpperBound" title="=&gt; Boolean">emptyUpperBound</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> else <span title="String(&quot; &lt;: &quot;)" class="string">&quot; &lt;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Types.this.Type)String">typeString</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="comment">/** Bounds notation used in http://adriaanm.github.com/files/higher.pdf.
      * For example *(scala.collection.generic.Sorted[K,This]).
      */</span>
    private<span class="delimiter">[</span>internal<span class="delimiter">]</span> def <a title="(typeString: Types.this.Type =&gt; String)String" id="scala.reflect.internal;Types;TypeBounds.starNotation">starNotation</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; String" id="scala.reflect.internal;Types;TypeBounds.starNotation.typeString">typeString</a>: Type =&gt; String<span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeBounds.emptyLowerBound" title="=&gt; Boolean">emptyLowerBound</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;TypeBounds.emptyUpperBound" title="=&gt; Boolean">emptyUpperBound</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeBounds.emptyLowerBound" title="=&gt; Boolean">emptyLowerBound</a><span class="delimiter">)</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Types.this.Type)String">typeString</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
      else <a href="../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;(%s, %s)&quot;</a> <a href="../../collection/immutable/StringLike.scala.html#scala.collection.immutable;StringLike.format" title="(args: Any*)String">format</a> <span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Types.this.Type)String">typeString</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeBounds.lo" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Types.this.Type)String">typeString</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeBounds.kind">kind</a> = <span title="String(&quot;TypeBoundsType&quot;)" class="string">&quot;TypeBoundsType&quot;</span>
  <span class="delimiter">}</span>

  final class <a title="class UniqueTypeBounds extends Types.this.TypeBounds" id="scala.reflect.internal;Types;UniqueTypeBounds">UniqueTypeBounds</a><a href="#scala.reflect.internal;Types;UniqueTypeBounds" title="Types.this.UniqueTypeBounds" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;UniqueTypeBounds.lo">lo</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;UniqueTypeBounds.hi">hi</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;UniqueTypeBounds.lo" title="Types.this.Type">lo</a>, <a href="#scala.reflect.internal;Types;UniqueTypeBounds.hi" title="Types.this.Type">hi</a><span class="delimiter">)</span>

  object <a title="Types.this.TypeBounds.type" id="scala.reflect.internal;Types.TypeBounds.readResolve">TypeBounds</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;TypeBoundsExtractor" title="Types.this.TypeBoundsExtractor">TypeBoundsExtractor</a> <span class="delimiter">{</span>
    def <a title="=&gt; Types.this.TypeBounds" id="scala.reflect.internal;Types.TypeBounds.empty">empty</a>: <a href="#scala.reflect.internal;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a>           = <a href="#scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3)" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.NothingTpe" title="=&gt; Types.this.Type">NothingTpe</a>, <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyTpe" title="=&gt; Types.this.Type">AnyTpe</a><span class="delimiter">)</span>
    def <a title="(hi: Types.this.Type)Types.this.TypeBounds" id="scala.reflect.internal;Types.TypeBounds.upper">upper</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.TypeBounds.upper.hi">hi</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3)" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.NothingTpe" title="=&gt; Types.this.Type">NothingTpe</a>, <a href="#scala.reflect.internal;Types.TypeBounds.upper.hi" title="Types.this.Type">hi</a><span class="delimiter">)</span>
    def <a title="(lo: Types.this.Type)Types.this.TypeBounds" id="scala.reflect.internal;Types.TypeBounds.lower">lower</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.TypeBounds.lower.lo">lo</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3)" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">apply</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeBounds.lower.lo" title="Types.this.Type">lo</a>, <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyTpe" title="=&gt; Types.this.Type">AnyTpe</a><span class="delimiter">)</span>
    def <a title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds" id="scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3)">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3).lo">lo</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3).hi">hi</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a> = <span class="delimiter">{</span>
      <a href="#scala.reflect.internal;Types.unique" title="(tp: Types.this.UniqueTypeBounds)Types.this.UniqueTypeBounds">unique</a><span class="delimiter">(</span>new <a href="#scala.reflect.internal;Types;UniqueTypeBounds" title="Types.this.UniqueTypeBounds">UniqueTypeBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3).lo" title="Types.this.Type">lo</a>, <a href="#scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3).hi" title="Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.TypeBounds" class="delimiter">[</span><a href="#scala.reflect.internal;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  object <a title="Types.this.CompoundType.type" id="scala.reflect.internal;Types.CompoundType">CompoundType</a> <a href="#scala.reflect.internal;Types.CompoundType" title="Types.this.CompoundType.type" class="delimiter">{</a>
    def <a title="(tp: Types.this.Type)Option[(List[Types.this.Type], Types.this.Scope, Types.this.Symbol)]" id="scala.reflect.internal;Types.CompoundType.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.CompoundType.unapply.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(List[Types.this.Type], Types.this.Scope, Types.this.Symbol)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span>, Scope, Symbol<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types.CompoundType.unapply.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
      case ClassInfoType<span class="delimiter">(</span><span title="List[Types.this.Type]">parents</span>, <span title="Types.this.Scope">decls</span>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.CompoundType.unapply.clazz">clazz</a><span class="delimiter">)</span> =&gt; <a href="../../Option.scala.html#scala;Some" title="(x: (List[Types.this.Type], Types.this.Scope, Types.this.Symbol))Some[(List[Types.this.Type], Types.this.Scope, Types.this.Symbol)]">Some</a><span class="delimiter">(</span><a href="../../Tuple3.scala.html#scala;Tuple3" title="(_1: List[Types.this.Type], _2: Types.this.Scope, _3: Types.this.Symbol)(List[Types.this.Type], Types.this.Scope, Types.this.Symbol)" class="delimiter">(</a><span title="List[Types.this.Type]">parents</span>, <span title="Types.this.Scope">decls</span>, <a href="#scala.reflect.internal;Types.CompoundType.unapply.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case RefinedType<span class="delimiter">(</span><span title="List[Types.this.Type]">parents</span>, <span title="Types.this.Scope">decls</span><span class="delimiter">)</span>          =&gt; <a href="../../Option.scala.html#scala;Some" title="(x: (List[Types.this.Type], Types.this.Scope, Types.this.Symbol))Some[(List[Types.this.Type], Types.this.Scope, Types.this.Symbol)]">Some</a><span class="delimiter">(</span><a href="../../Tuple3.scala.html#scala;Tuple3" title="(_1: List[Types.this.Type], _2: Types.this.Scope, _3: Types.this.Symbol)(List[Types.this.Type], Types.this.Scope, Types.this.Symbol)" class="delimiter">(</a><span title="List[Types.this.Type]">parents</span>, <span title="Types.this.Scope">decls</span>, <a href="#scala.reflect.internal;Types.CompoundType.unapply.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case _                                    =&gt; <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A common base class for intersection types and class types
   */</span>
  abstract class <a title="class CompoundType extends Types.this.Type with Types.this.CompoundTypeApi" id="scala.reflect.internal;Types;CompoundType">CompoundType</a> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;CompoundTypeApi" title="Types.this.CompoundTypeApi">CompoundTypeApi</a> <span class="delimiter">{</span>

    private<span class="delimiter">[</span>reflect<span class="delimiter">]</span> var <a title="Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;CompoundType.baseTypeSeqCache_=">baseTypeSeqCache</a>: <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = _
    private<span class="delimiter">[</span>reflect<span class="delimiter">]</span> var <a title="Int" id="scala.reflect.internal;Types;CompoundType.baseTypeSeqPeriod_=">baseTypeSeqPeriod</a> = <span title="Int(0)">NoPeriod</span>
    private<span class="delimiter">[</span>reflect<span class="delimiter">]</span> var <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;CompoundType.baseClassesCache_=">baseClassesCache</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = _
    private<span class="delimiter">[</span>reflect<span class="delimiter">]</span> var <a title="Int" id="scala.reflect.internal;Types;CompoundType.baseClassesPeriod_=">baseClassesPeriod</a> = <span title="Int(0)">NoPeriod</span>

    override def <a title="=&gt; Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;CompoundType.baseTypeSeq">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      val <a title="Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;CompoundType.baseTypeSeq.cached">cached</a> = <a href="#scala.reflect.internal;Types;CompoundType.baseTypeSeqCache_=" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;CompoundType.baseTypeSeqPeriod_=" title="=&gt; Int">baseTypeSeqPeriod</a> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;CompoundType.baseTypeSeq.cached" title="Types.this.BaseTypeSeq">cached</a> <span title="(x$1: Any)Boolean">!=</span> null <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;CompoundType.baseTypeSeq.cached" title="Types.this.BaseTypeSeq">cached</a> <span title="(x$1: Any)Boolean">!=</span> <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs.undetBaseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;CompoundType.baseTypeSeq.cached" title="Types.this.BaseTypeSeq">cached</a>
      else <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType" title="(tpe: Types.this.CompoundType)Unit">defineBaseTypeSeqOfCompoundType</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;CompoundType.baseTypeSeqCache_=" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs.undetBaseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
          throw new <a href="#scala.reflect.internal;Types.RecoverableCyclicReference.readResolve" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>

        <a href="#scala.reflect.internal;Types;CompoundType.baseTypeSeqCache_=" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    override def <a title="=&gt; scala.reflect.internal.Depth" id="scala.reflect.internal;Types;CompoundType.baseTypeSeqDepth">baseTypeSeqDepth</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <a href="#scala.reflect.internal;Types;CompoundType.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.maxDepth" title="=&gt; scala.reflect.internal.Depth">maxDepth</a>

    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;CompoundType.baseClasses">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
      val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;CompoundType.baseClasses.cached">cached</a> = <a href="#scala.reflect.internal;Types;CompoundType.baseClassesCache_=" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;CompoundType.baseClassesPeriod_=" title="=&gt; Int">baseClassesPeriod</a> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;CompoundType.baseClasses.cached" title="List[Types.this.Symbol]">cached</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;CompoundType.baseClasses.cached" title="List[Types.this.Symbol]">cached</a>
      else <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(ef25718acb)" title="(tpe: Types.this.CompoundType)Unit">defineBaseClassesOfCompoundType</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;CompoundType.baseClassesCache_=" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span>
          throw new <a href="#scala.reflect.internal;Types.RecoverableCyclicReference.readResolve" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>

        <a href="#scala.reflect.internal;Types;CompoundType.baseClassesCache_=" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** The slightly less idiomatic use of Options is due to
     *  performance considerations. A version using for comprehensions
     *  might be too slow (this is deemed a hotspot of the type checker).
     *
     *  See with Martin before changing this method.
     */</span>
    def <a title="[A](op1: =&gt; A)(op2: Types.this.Type =&gt; A)A" id="scala.reflect.internal;Types;CompoundType.memo">memo</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal;Types;CompoundType.memo;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="scala.reflect.internal;Types;CompoundType.memo.op1">op1</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; A" id="scala.reflect.internal;Types;CompoundType.memo.op2">op2</a>: Type =&gt; A<span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;CompoundType.memo;A" title="A">A</a> = <span class="delimiter">{</span>
      def <a title="()A" id="scala.reflect.internal;Types;CompoundType.memo.updateCache">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;CompoundType.memo;A" title="A">A</a> = <span class="delimiter">{</span>
        <a href="../../collection/convert/Wrappers.scala.html#scala.collection.convert;Wrappers;JMapWrapperLike.update" title="(k: List[Types.this.Type], v: scala.ref.WeakReference[Types.this.Type])Unit">intersectionWitness</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> = new <a href="../../ref/WeakReference.scala.html#scala.ref;WeakReference" title="scala.ref.WeakReference[Types.this.CompoundType]">WeakReference</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;CompoundType.memo.op1" title="=&gt; A">op1</a>
      <span class="delimiter">}</span>

      <a href="#scala.reflect.internal;Types.intersectionWitness" title="=&gt; scala.collection.mutable.WeakHashMap[List[Types.this.Type],scala.ref.WeakReference[Types.this.Type]]">intersectionWitness</a> <a href="../../collection/convert/Wrappers.scala.html#scala.collection.convert;Wrappers;JMapWrapperLike.get" title="(k: List[Types.this.Type])Option[scala.ref.WeakReference[Types.this.Type]]">get</a> <a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a> match <span class="delimiter">{</span>
        case Some<span class="delimiter">(</span><a title="scala.ref.WeakReference[Types.this.Type]" id="scala.reflect.internal;Types;CompoundType.memo.ref">ref</a><span class="delimiter">)</span> =&gt;
          <a href="#scala.reflect.internal;Types;CompoundType.memo.ref" title="scala.ref.WeakReference[Types.this.Type]">ref</a>.<a href="../../ref/ReferenceWrapper.scala.html#scala.ref;ReferenceWrapper.get" title="=&gt; Option[Types.this.Type]">get</a> match <span class="delimiter">{</span>
            case Some<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;CompoundType.memo.w">w</a><span class="delimiter">)</span> =&gt; if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;CompoundType.memo.w" title="Types.this.Type">w</a> <span title="(x$1: AnyRef)Boolean">eq</span> this<span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;CompoundType.memo.op1" title="=&gt; A">op1</a> else <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Types.this.Type)A">op2</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;CompoundType.memo.w" title="Types.this.Type">w</a><span class="delimiter">)</span>
            case <a href="../../Option.scala.html#scala.None" title="None.type">None</a> =&gt; <a href="#scala.reflect.internal;Types;CompoundType.memo.updateCache" title="()A">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        case <a href="../../Option.scala.html#scala.None" title="None.type">None</a> =&gt; <a href="#scala.reflect.internal;Types;CompoundType.memo.updateCache" title="()A">updateCache</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    override def <a title="(sym: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;CompoundType.baseType">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;CompoundType.baseType.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      val <a title="Int" id="scala.reflect.internal;Types;CompoundType.baseType.index">index</a> = <a href="#scala.reflect.internal;Types;Type.baseTypeIndex" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;CompoundType.baseType.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;CompoundType.baseType.index" title="Int">index</a> <a href="../../Int.scala.html#scala;Int.>=(5f58a84eb3)" title="(x: Int)Boolean">&gt;=</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply" title="(i: Int)Types.this.Type">baseTypeSeq</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;CompoundType.baseType.index" title="Int">index</a><span class="delimiter">)</span> else <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
    <span class="delimiter">}</span>

    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;CompoundType.narrow">narrow</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.thisType" title="=&gt; Types.this.Type">thisType</a>

    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;CompoundType.isStructuralRefinement">isStructuralRefinement</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> =
      <a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAnonOrRefinementClass" title="=&gt; Boolean">isAnonOrRefinementClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a> <a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.exists" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.symbolIsPossibleInRefinement" title="=&gt; Types.this.Symbol =&gt; Boolean">symbolIsPossibleInRefinement</a><span class="delimiter">)</span>

    protected def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;CompoundType.shouldForceScope">shouldForceScope</a> = <a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">debug</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.isEmpty" title="=&gt; Boolean">isEmpty</a>
    protected def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types;CompoundType.initDecls">initDecls</a>        = <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.fullyInitializeScope" title="(scope: Types.this.Scope)Types.this.Scope">fullyInitializeScope</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span>
    protected def <a title="=&gt; String" id="scala.reflect.internal;Types;CompoundType.scopeString">scopeString</a>      = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;CompoundType.shouldForceScope" title="=&gt; Boolean">shouldForceScope</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;CompoundType.initDecls" title="=&gt; Types.this.Scope">initDecls</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;{&quot;)" class="string">&quot;{&quot;</span>, <span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="String(&quot;}&quot;)" class="string">&quot;}&quot;</span><span class="delimiter">)</span> else <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;CompoundType.safeToString">safeToString</a>      = <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.parentsString" title="(parents: List[Types.this.Type])String">parentsString</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;CompoundType.scopeString" title="=&gt; String">scopeString</a>
  <span class="delimiter">}</span>

  protected def <a title="(tpe: Types.this.Type)List[Types.this.Symbol]" id="scala.reflect.internal;Types.computeBaseClasses">computeBaseClasses</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.computeBaseClasses.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.computeBaseClasses.parents">parents</a> = <a href="#scala.reflect.internal;Types.computeBaseClasses.tpe" title="Types.this.Type">tpe</a>.<a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a> <span class="comment">// adriaan says tpe.parents does work sometimes, so call it only once</span>
    val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.computeBaseClasses.baseTail">baseTail</a> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.computeBaseClasses.parents" title="List[Types.this.Type]">parents</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.computeBaseClasses.parents" title="List[Types.this.Type]">parents</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Type">head</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#scala.reflect.internal;Types;PackageTypeRef" title="Types.this.PackageTypeRef">PackageTypeRef</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
      else <span class="delimiter">{</span>
        <span class="comment">//Console.println(&quot;computing base classes of &quot; + typeSymbol + &quot; at phase &quot; + phase);//DEBUG</span>
        <span class="comment">// optimized, since this seems to be performance critical</span>
        val <a title="Types.this.Type" id="scala.reflect.internal;Types.computeBaseClasses.baseTail.superclazz">superclazz</a> = <a href="#scala.reflect.internal;Types.computeBaseClasses.parents" title="List[Types.this.Type]">parents</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Type">head</a> <span class="comment">// parents.isEmpty was already excluded</span>
        var <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.computeBaseClasses.baseTail.mixins">mixins</a>     = <a href="#scala.reflect.internal;Types.computeBaseClasses.parents" title="List[Types.this.Type]">parents</a>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[Types.this.Type]">tail</a>
        val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.computeBaseClasses.baseTail.sbcs">sbcs</a>       = <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.superclazz" title="Types.this.Type">superclazz</a>.<a href="#scala.reflect.internal;Types;Type.baseClasses" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
        var <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.computeBaseClasses.baseTail.bcs">bcs</a>        = <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.sbcs" title="List[Types.this.Symbol]">sbcs</a>
        def <a title="(clazz: Types.this.Symbol)Boolean" id="scala.reflect.internal;Types.computeBaseClasses.baseTail.isNew">isNew</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.computeBaseClasses.baseTail.isNew.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">(</span>
          <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.superclazz" title="Types.this.Type">superclazz</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeIndex" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.isNew.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> <a href="../../Int.scala.html#scala;Int.<(5f58a84eb3)" title="(x: Int)Boolean">&lt;</a> <span title="Int(0)" class="int">0</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
          <span class="delimiter">{</span> var <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.computeBaseClasses.baseTail.isNew.p">p</a> = <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.bcs" title="List[Types.this.Symbol]">bcs</a>
            while <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.isNew.p" title="List[Types.this.Symbol]">p</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.sbcs" title="List[Types.this.Symbol]">sbcs</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.isNew.p" title="List[Types.this.Symbol]">p</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Symbol">head</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.isNew.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.isNew.p" title="List[Types.this.Symbol]">p</a> = <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.isNew.p" title="List[Types.this.Symbol]">p</a>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[Types.this.Symbol]">tail</a>
            <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.isNew.p" title="List[Types.this.Symbol]">p</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.sbcs" title="List[Types.this.Symbol]">sbcs</a>
          <span class="delimiter">}</span>
        <span class="delimiter">)</span>
        while <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.mixins" title="List[Types.this.Type]">mixins</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.while$4" title="()Unit" class="delimiter">{</a>
          def <a title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]" id="scala.reflect.internal;Types.computeBaseClasses.baseTail.addMixinBaseClasses">addMixinBaseClasses</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.computeBaseClasses.baseTail.addMixinBaseClasses.mbcs">mbcs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
            if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.addMixinBaseClasses.mbcs" title="List[Types.this.Symbol]">mbcs</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.bcs" title="List[Types.this.Symbol]">bcs</a>
            else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.isNew" title="(clazz: Types.this.Symbol)Boolean">isNew</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.addMixinBaseClasses.mbcs" title="List[Types.this.Symbol]">mbcs</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Symbol">head</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.addMixinBaseClasses.mbcs" title="List[Types.this.Symbol]">mbcs</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Symbol">head</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.addMixinBaseClasses" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.addMixinBaseClasses.mbcs" title="List[Types.this.Symbol]">mbcs</a>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[Types.this.Symbol]">tail</a><span class="delimiter">)</span>
            else <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.addMixinBaseClasses" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.addMixinBaseClasses.mbcs" title="List[Types.this.Symbol]">mbcs</a>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[Types.this.Symbol]">tail</a><span class="delimiter">)</span>
          <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.bcs" title="List[Types.this.Symbol]">bcs</a> = <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.addMixinBaseClasses" title="(mbcs: List[Types.this.Symbol])List[Types.this.Symbol]">addMixinBaseClasses</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.mixins" title="List[Types.this.Type]">mixins</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Type">head</a>.<a href="#scala.reflect.internal;Types;Type.baseClasses" title="=&gt; List[Types.this.Symbol]">baseClasses</a><span class="delimiter">)</span>
          <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.mixins" title="List[Types.this.Type]">mixins</a> = <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.mixins" title="List[Types.this.Type]">mixins</a>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[Types.this.Type]">tail</a>
        <span class="delimiter">}</span>
        <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail.bcs" title="List[Types.this.Symbol]">bcs</a>
      <span class="delimiter">}</span>
    <span class="delimiter">)</span>
    <a href="#scala.reflect.internal;Types.computeBaseClasses.tpe" title="Types.this.Type">tpe</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#scala.reflect.internal;Types.computeBaseClasses.baseTail" title="List[Types.this.Symbol]">baseTail</a>
  <span class="delimiter">}</span>

  protected def <a title="(tpe: Types.this.CompoundType)Unit" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType">defineBaseTypeSeqOfCompoundType</a><span class="delimiter">(</span><a title="Types.this.CompoundType" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;CompoundType" title="Types.this.CompoundType">CompoundType</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="Int" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.period">period</a> = <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;CompoundType.baseTypeSeqPeriod_=" title="=&gt; Int">baseTypeSeqPeriod</a>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.period" title="Int">period</a> <a href="../../Int.scala.html#scala;Int.!=(5f58a84eb3)" title="(x: Int)Boolean">!=</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;CompoundType.baseTypeSeqPeriod_=" title="(x$1: Int)Unit">baseTypeSeqPeriod</a> = <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.isValidForBaseClasses" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.period" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types.typeContainsTypeVar" title="=&gt; Types.this.Type =&gt; Boolean">typeContainsTypeVar</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="comment">// rename type vars to fresh type params, take base type sequence of</span>
          <span class="comment">// resulting type, and rename back all the entries in that sequence</span>
          var <a title="scala.collection.immutable.Set[Types.this.TypeVar]" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tvs">tvs</a> = <a href="../../collection/generic/GenericCompanion.scala.html#scala.collection.generic;GenericCompanion.apply" title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</a><span title="(elems: Types.this.TypeVar*)scala.collection.immutable.Set[Types.this.TypeVar]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
          for <span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.$anonfun.p">p</a> &lt;- <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: Types.this.Type =&gt; Unit)Unit">parents</a><span class="delimiter">)</span>
            for <span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.$anonfun.$anonfun.t">t</a> &lt;- <a href="#scala.reflect.internal;Types;Type.foreach" title="(f: Types.this.Type =&gt; Unit)Unit">p</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.$anonfun.$anonfun.t" title="Types.this.Type">t</a> match <span class="delimiter">{</span>
              case <a title="Types.this.TypeVar" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.$anonfun.$anonfun.tv">tv</a>: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a> =&gt; <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tvs" title="scala.collection.immutable.Set[Types.this.TypeVar]">tvs</a> <a href="../../collection/SetLike.scala.html#scala.collection;SetLike.+(daf7108c0f)" title="(elem: Types.this.TypeVar)scala.collection.immutable.Set[Types.this.TypeVar]">+=</a> <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.$anonfun.$anonfun.tv" title="Types.this.TypeVar">tv</a>
              case _ =&gt;
            <span class="delimiter">}</span>
          val <a title="Map[Types.this.Type,Types.this.Symbol]" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.varToParamMap">varToParamMap</a>: <a href="../../collection/immutable/Map.scala.html#scala.collection.immutable;Map" title="Map[Types.this.Type,Types.this.Symbol]">Map</a><span class="delimiter">[</span>Type, Symbol<span class="delimiter">]</span> =
            <a href="util/Collections.scala.html#scala.reflect.internal.util;Collections.mapFrom" title="[A, A1 &gt;: A, B](xs: List[A])(f: A =&gt; B)Map[A1,B]">mapFrom</a><span title="(xs: List[Types.this.TypeVar])(f: Types.this.TypeVar =&gt; Types.this.Symbol)Map[Types.this.Type,Types.this.Symbol]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a>, <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tvs" title="scala.collection.immutable.Set[Types.this.TypeVar]">tvs</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[Types.this.TypeVar]">toList</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.varToParamMap.$anonfun.x$20" title="Types.this.TypeVar">_</a>.<a href="#scala.reflect.internal;Types;TypeVar.origin" title="=&gt; Types.this.Type">origin</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.cloneSymbol(4a4a4b92d2)" title="=&gt; Types.this.Symbol#TypeOfClonedSymbol">cloneSymbol</a><span class="delimiter">)</span>
          val paramToVarMap = <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.varToParamMap" title="Map[Types.this.Type,Types.this.Symbol]">varToParamMap</a> <a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.map" title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.paramToVarMap">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.paramToVarMap.$anonfun.x$21" title="(Types.this.Type, Types.this.Symbol)">_</a>.<a href="../../Tuple2.scala.html#scala;Tuple2.swap" title="=&gt; (Types.this.Symbol, Types.this.Type)">swap</a><span class="delimiter">)</span>
          val <a title="Types.this.TypeMap" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.varToParam">varToParam</a> = new <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="&lt;$anon: Types.this.Type =&gt; Types.this.Type&gt; extends Types.this.TypeMap" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.varToParam;$anon">TypeMap</a> <span class="delimiter">{</span>
            def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.varToParam;$anon.apply">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.varToParam;$anon.apply.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.varToParamMap" title="Map[Types.this.Type,Types.this.Symbol]">varToParamMap</a> <a href="../../collection/MapLike.scala.html#scala.collection;MapLike.get" title="(key: Types.this.Type)Option[Types.this.Symbol]">get</a> <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.varToParam;$anon.apply.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
              case Some<span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.varToParam;$anon.apply.sym">sym</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.varToParam;$anon.apply.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe_*" title="=&gt; Types.this.Type">tpe_*</a>
              case _ =&gt; <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.varToParam;$anon.apply.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          val <a title="Types.this.TypeMap" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.paramToVar">paramToVar</a> = new <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="&lt;$anon: Types.this.Type =&gt; Types.this.Type&gt; extends Types.this.TypeMap" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.paramToVar;$anon">TypeMap</a> <span class="delimiter">{</span>
            def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.paramToVar;$anon.apply">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.paramToVar;$anon.apply.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.paramToVar;$anon.apply.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
              case TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.paramToVar;$anon.apply.tsym">tsym</a>, _<span class="delimiter">)</span> if <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.paramToVarMap" title="scala.collection.immutable.Map[Types.this.Symbol,Types.this.Type]">paramToVarMap</a>.<a href="../../collection/MapLike.scala.html#scala.collection;MapLike.isDefinedAt" title="(key: Types.this.Symbol)Boolean">isDefinedAt</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.paramToVar;$anon.apply.tsym" title="Types.this.Symbol">tsym</a><span class="delimiter">)</span> =&gt; <a href="../../collection/MapLike.scala.html#scala.collection;MapLike.apply" title="(key: Types.this.Symbol)Types.this.Type">paramToVarMap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.paramToVar;$anon.apply.tsym" title="Types.this.Symbol">tsym</a><span class="delimiter">)</span>
              case _ =&gt; <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.paramToVar;$anon.apply.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
          val <a title="Types.this.BaseTypeSeq" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.bts">bts</a> = <a href="#scala.reflect.internal;Types.copyRefinedType" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Types.this.RefinedType" class="delimiter">[</span><a href="#scala.reflect.internal;Types;RefinedType" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">]</span>, <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.varToParam" title="Types.this.TypeMap">varToParam</a>, <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.varToParam" title="Types.this.TypeMap">varToParam</a> <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ba27114502)" title="(scope: Types.this.Scope)Types.this.Scope">mapOver</a> <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
          <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;CompoundType.baseTypeSeqCache_=" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.bts" title="Types.this.BaseTypeSeq">bts</a> <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.lateMap" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">lateMap</a> <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.paramToVar" title="Types.this.TypeMap">paramToVar</a>
        <span class="delimiter">}</span> else <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.incCounter(456ea4fa07)" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.compoundBaseTypeSeqCount" title="=&gt; scala.reflect.internal.util.Statistics.SubCounter">compoundBaseTypeSeqCount</a><span class="delimiter">)</span>
          val <a title="scala.reflect.internal.util.Statistics.TimerSnapshot" id="scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.start">start</a> = if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.pushTimer" title="(timers: scala.reflect.internal.util.Statistics.TimerStack, timer: =&gt; scala.reflect.internal.util.Statistics.StackableTimer)scala.reflect.internal.util.Statistics.TimerSnapshot">pushTimer</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.typeOpsStack" title="=&gt; scala.reflect.internal.util.Statistics.TimerStack">typeOpsStack</a>, <a href="#scala.reflect.internal.TypesStats.baseTypeSeqNanos" title="=&gt; scala.reflect.internal.util.Statistics.StackableTimer">baseTypeSeqNanos</a><span class="delimiter">)</span> else null
          try <span class="delimiter">{</span>
            <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;CompoundType.baseTypeSeqCache_=" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs.undetBaseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a>
            <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;CompoundType.baseTypeSeqCache_=" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> =
              if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isRefinementClass" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span>
                <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;CompoundType.memo" title="(op1: =&gt; Types.this.BaseTypeSeq)(op2: Types.this.Type =&gt; Types.this.BaseTypeSeq)Types.this.BaseTypeSeq">memo</a><span class="delimiter">(</span><a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">compoundBaseTypeSeq</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.$anonfun.x$22" title="Types.this.Type">_</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.updateHead" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">updateHead</a> <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe_*" title="=&gt; Types.this.Type">tpe_*</a><span class="delimiter">)</span>
              else
                <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs.compoundBaseTypeSeq" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">compoundBaseTypeSeq</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> finally <span class="delimiter">{</span>
            if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.popTimer" title="(timers: scala.reflect.internal.util.Statistics.TimerStack, prev: scala.reflect.internal.util.Statistics.TimerSnapshot)Unit">popTimer</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.typeOpsStack" title="=&gt; scala.reflect.internal.util.Statistics.TimerStack">typeOpsStack</a>, <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.start" title="scala.reflect.internal.util.Statistics.TimerSnapshot">start</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <span class="comment">// [Martin] suppressing memo-ization solves the problem with &quot;same type after erasure&quot; errors</span>
          <span class="comment">// when compiling with</span>
          <span class="comment">// scalac scala.collection.IterableViewLike.scala scala.collection.IterableLike.scala</span>
          <span class="comment">// I have not yet figured out precisely why this is the case.</span>
          <span class="comment">// My current assumption is that taking memos forces baseTypeSeqs to be computed</span>
          <span class="comment">// at stale types (i.e. the underlying typeSymbol has already another type).</span>
          <span class="comment">// I do not yet see precisely why this would cause a problem, but it looks</span>
          <span class="comment">// fishy in any case.</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="comment">//Console.println(&quot;baseTypeSeq(&quot; + typeSymbol + &quot;) = &quot; + baseTypeSeqCache.toList);//DEBUG</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;CompoundType.baseTypeSeqCache_=" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs.undetBaseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
      throw new <a href="#scala.reflect.internal;Types;TypeError" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic inheritance involving &quot;)" class="string">&quot;illegal cyclic inheritance involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfCompoundType.tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  object <a title="Types.this.baseClassesCycleMonitor.type" id="scala.reflect.internal;Types.baseClassesCycleMonitor">baseClassesCycleMonitor</a> <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor" title="Types.this.baseClassesCycleMonitor.type" class="delimiter">{</a>
    private var <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.baseClassesCycleMonitor.open_=">open</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
    @inline private def <a title="(msg: =&gt; String)Unit" id="scala.reflect.internal;Types.baseClassesCycleMonitor.cycleLog">cycleLog</a><span class="delimiter">(</span><a title="=&gt; String" id="scala.reflect.internal;Types.baseClassesCycleMonitor.cycleLog.msg">msg</a>: =&gt; String<span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">debug</a><span class="delimiter">)</span>
        <a href="../../Console.scala.html#scala.Console" title="Console.type">Console</a>.<a href="../../Console.scala.html#scala.Console.err" title="=&gt; java.io.PrintStream">err</a>.<span title="(x$1: String)Unit">println</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.cycleLog.msg" title="=&gt; String">msg</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    def <a title="=&gt; Int" id="scala.reflect.internal;Types.baseClassesCycleMonitor.size">size</a> = <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.open_=" title="=&gt; List[Types.this.Symbol]">open</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.size" title="=&gt; Int">size</a>
    def <a title="(clazz: Types.this.Symbol)Unit" id="scala.reflect.internal;Types.baseClassesCycleMonitor.push">push</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.baseClassesCycleMonitor.push.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.cycleLog" title="(msg: =&gt; String)Unit">cycleLog</a><span class="delimiter">(</span><span title="String(&quot;+ &quot;)" class="string">&quot;+ &quot;</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;  &quot;</a> <a href="../../collection/immutable/StringLike.scala.html#scala.collection.immutable;StringLike.*" title="(n: Int)String">*</a> <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.size" title="=&gt; Int">size</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.push.clazz" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.fullNameString" title="=&gt; String">fullNameString</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.open_=" title="(x$1: List[Types.this.Symbol])Unit">open</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::=</a> <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.push.clazz" title="Types.this.Symbol">clazz</a>
    <span class="delimiter">}</span>
    def <a title="(clazz: Types.this.Symbol)Unit" id="scala.reflect.internal;Types.baseClassesCycleMonitor.pop">pop</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.baseClassesCycleMonitor.pop.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.open_=" title="=&gt; List[Types.this.Symbol]">open</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Symbol">head</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.pop.clazz" title="Types.this.Symbol">clazz</a>, <a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: Types.this.Symbol, _2: List[Types.this.Symbol])(Types.this.Symbol, List[Types.this.Symbol])" class="delimiter">(</a><a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.pop.clazz" title="Types.this.Symbol">clazz</a>, <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.open_=" title="=&gt; List[Types.this.Symbol]">open</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.open_=" title="(x$1: List[Types.this.Symbol])Unit">open</a> = <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.open_=" title="=&gt; List[Types.this.Symbol]">open</a>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[Types.this.Symbol]">tail</a>
    <span class="delimiter">}</span>
    def <a title="(clazz: Types.this.Symbol)Boolean" id="scala.reflect.internal;Types.baseClassesCycleMonitor.isOpen">isOpen</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.baseClassesCycleMonitor.isOpen.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.open_=" title="=&gt; List[Types.this.Symbol]">open</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: Types.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.isOpen.clazz" title="Types.this.Symbol">clazz</a>
  <span class="delimiter">}</span>

  protected def <a title="(tpe: Types.this.CompoundType)Unit" id="scala.reflect.internal;Types.defineBaseClassesOfCompoundType(ef25718acb)">defineBaseClassesOfCompoundType</a><span class="delimiter">(</span><span title="Types.this.CompoundType">tpe</span>: <a href="#scala.reflect.internal;Types;CompoundType" title="Types.this.CompoundType">CompoundType</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="()Unit" id="scala.reflect.internal;Types.defineBaseClassesOfCompoundType(ef25718acb).define">define</a><span class="delimiter">(</span><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55)" title="(tpe: Types.this.CompoundType, force: Boolean)Unit">defineBaseClassesOfCompoundType</a><span class="delimiter">(</span><span title="Types.this.CompoundType">tpe</span>, force = false<span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.breakCycles" title="=&gt; Boolean">breakCycles</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.isPastTyper" title="=&gt; Boolean">isPastTyper</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(ef25718acb).define" title="()Unit">define</a><span class="delimiter">(</span><span class="delimiter">)</span>
    else <span title="Types.this.CompoundType">tpe</span> match <span class="delimiter">{</span>
      <span class="comment">// non-empty parents helpfully excludes all package classes</span>
      case <span title="Types.this.ClassInfoType">tpe</span> @ ClassInfoType<span class="delimiter">(</span>_ :: _, _, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.defineBaseClassesOfCompoundType(ef25718acb).clazz">clazz</a><span class="delimiter">)</span> if <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(ef25718acb).clazz" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAnonOrRefinementClass" title="=&gt; Boolean">isAnonOrRefinementClass</a> =&gt;
        <span class="comment">// Cycle: force update</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.baseClassesCycleMonitor" title="Types.this.baseClassesCycleMonitor.type">baseClassesCycleMonitor</a> <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.isOpen" title="(clazz: Types.this.Symbol)Boolean">isOpen</a> <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(ef25718acb).clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
          <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55)" title="(tpe: Types.this.CompoundType, force: Boolean)Unit">defineBaseClassesOfCompoundType</a><span class="delimiter">(</span><span title="Types.this.ClassInfoType">tpe</span>, force = true<span class="delimiter">)</span>
        else <span class="delimiter">{</span>
          <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor" title="Types.this.baseClassesCycleMonitor.type">baseClassesCycleMonitor</a> <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.push" title="(clazz: Types.this.Symbol)Unit">push</a> <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(ef25718acb).clazz" title="Types.this.Symbol">clazz</a>
          try <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(ef25718acb).define" title="()Unit">define</a><span class="delimiter">(</span><span class="delimiter">)</span>
          finally <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor" title="Types.this.baseClassesCycleMonitor.type">baseClassesCycleMonitor</a> <a href="#scala.reflect.internal;Types.baseClassesCycleMonitor.pop" title="(clazz: Types.this.Symbol)Unit">pop</a> <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(ef25718acb).clazz" title="Types.this.Symbol">clazz</a>
        <span class="delimiter">}</span>
      case _ =&gt;
        <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(ef25718acb).define" title="()Unit">define</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  private def <a title="(tpe: Types.this.CompoundType, force: Boolean)Unit" id="scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55)">defineBaseClassesOfCompoundType</a><span class="delimiter">(</span><a title="Types.this.CompoundType" id="scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).tpe">tpe</a>: <a href="#scala.reflect.internal;Types;CompoundType" title="Types.this.CompoundType">CompoundType</a>, <a title="Boolean" id="scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).force">force</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    val <a title="Int" id="scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).period">period</a> = <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;CompoundType.baseClassesPeriod_=" title="=&gt; Int">baseClassesPeriod</a>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).period" title="Int">period</a> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).force" title="Boolean">force</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.breakCycles" title="=&gt; Boolean">breakCycles</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        def <a title="=&gt; String" id="scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).what">what</a> = <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).tpe" title="Types.this.CompoundType">tpe</a>.<a href="../../Predef.scala.html#scala.Predef.any2stringadd(6b32434ac5)" title="(self: Types.this.Symbol)any2stringadd[Types.this.Symbol]">typeSymbol</a> <a href="../../Predef.scala.html#scala.Predef;any2stringadd.+" title="(other: String)String">+</a> <span title="String(&quot; in &quot;)" class="string">&quot; in &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.fullNameString" title="=&gt; String">fullNameString</a>
        val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).bcs">bcs</a>  = <a href="#scala.reflect.internal;Types.computeBaseClasses" title="(tpe: Types.this.Type)List[Types.this.Symbol]">computeBaseClasses</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).tpe" title="Types.this.CompoundType">tpe</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;CompoundType.baseClassesCache_=" title="(x$1: List[Types.this.Symbol])Unit">baseClassesCache</a> = <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).bcs" title="List[Types.this.Symbol]">bcs</a>
        <a href="Reporting.scala.html#scala.reflect.internal;Reporting.warning(7fc9e56e07)" title="(msg: String)Unit">warning</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;Breaking cycle in base class computation of &quot;)">Breaking cycle in base class computation of $</span><a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).what" title="=&gt; String">what</a><span title="String(&quot; (&quot;)"> ($</span><a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).bcs" title="List[Types.this.Symbol]">bcs</a><span title="String(&quot;)&quot;)" class="string">)&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    else <span class="delimiter">{</span>
      <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;CompoundType.baseClassesPeriod_=" title="(x$1: Int)Unit">baseClassesPeriod</a> = <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.isValidForBaseClasses" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).period" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="scala.reflect.internal.util.Statistics.TimerSnapshot" id="scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).start">start</a> = if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.pushTimer" title="(timers: scala.reflect.internal.util.Statistics.TimerStack, timer: =&gt; scala.reflect.internal.util.Statistics.StackableTimer)scala.reflect.internal.util.Statistics.TimerSnapshot">pushTimer</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.typeOpsStack" title="=&gt; scala.reflect.internal.util.Statistics.TimerStack">typeOpsStack</a>, <a href="#scala.reflect.internal.TypesStats.baseClassesNanos" title="=&gt; scala.reflect.internal.util.Statistics.StackableTimer">baseClassesNanos</a><span class="delimiter">)</span> else null
        try <span class="delimiter">{</span>
          <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;CompoundType.baseClassesCache_=" title="(x$1: List[Types.this.Symbol])Unit">baseClassesCache</a> = null
          <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;CompoundType.baseClassesCache_=" title="(x$1: List[Types.this.Symbol])Unit">baseClassesCache</a> = <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;CompoundType.memo" title="(op1: =&gt; List[Types.this.Symbol])(op2: Types.this.Type =&gt; List[Types.this.Symbol])List[Types.this.Symbol]">memo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.computeBaseClasses" title="(tpe: Types.this.Type)List[Types.this.Symbol]">computeBaseClasses</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).tpe" title="Types.this.CompoundType">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).$anonfun.x$23" title="Types.this.Type">_</a>.<a href="#scala.reflect.internal;Types;Type.baseClasses" title="=&gt; List[Types.this.Symbol]">baseClasses</a>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[Types.this.Symbol]">tail</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        finally <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.popTimer" title="(timers: scala.reflect.internal.util.Statistics.TimerStack, prev: scala.reflect.internal.util.Statistics.TimerSnapshot)Unit">popTimer</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.typeOpsStack" title="=&gt; scala.reflect.internal.util.Statistics.TimerStack">typeOpsStack</a>, <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).start" title="scala.reflect.internal.util.Statistics.TimerSnapshot">start</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;CompoundType.baseClassesCache_=" title="=&gt; List[Types.this.Symbol]">baseClassesCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span>
      throw new <a href="#scala.reflect.internal;Types;TypeError" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types.defineBaseClassesOfCompoundType(c3dcea1d55).tpe" title="Types.this.CompoundType">tpe</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class representing intersection types with refinements of the form
   *    `&lt;parents_0&gt; with ... with &lt;parents_n&gt; { decls }`
   *  Cannot be created directly;
   *  one should always use `refinedType` for creation.
   */</span>
  case class <a title="class RefinedType extends Types.this.CompoundType with Types.this.RefinedTypeApi with Product with Serializable" id="scala.reflect.internal;Types;RefinedType">RefinedType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a>override val <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;RefinedType.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>,
                         override val <a title="Types.this.Scope" id="scala.reflect.internal;Types;RefinedType.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;CompoundType" title="Types.this.CompoundType">CompoundType</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;RefinedTypeApi" title="Types.this.RefinedTypeApi">RefinedTypeApi</a> <span class="delimiter">{</span>

    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;RefinedType.isHigherKinded">isHigherKinded</a> = <span class="delimiter">(</span>
      <a href="#scala.reflect.internal;Types;RefinedType.parents" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
      <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinedType.parents" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a> <a href="#scala.reflect.internal;Types.typeIsHigherKinded" title="=&gt; Types.this.Type =&gt; Boolean">typeIsHigherKinded</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
      <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a>
    <span class="delimiter">)</span>

    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;RefinedType.typeParams">typeParams</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinedType.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.firstParent" title="=&gt; Types.this.Type">firstParent</a>.<a href="#scala.reflect.internal;Types;Type.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>
      else super.<a href="#scala.reflect.internal;Types;Type.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>

    <span class="comment">//@M may result in an invalid type (references to higher-order args become dangling )</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;RefinedType.typeConstructor">typeConstructor</a> =
      <a href="#scala.reflect.internal;Types.copyRefinedType" title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type">copyRefinedType</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;RefinedType.parents" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinedType.typeConstructor.$anonfun.x$25" title="Types.this.Type">_</a>.<a href="#scala.reflect.internal;Types;Type.typeConstructor" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types;RefinedType.decls" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span>

    final override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;RefinedType.normalize">normalize</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;RefinedType.normalizeImpl" title="=&gt; Types.this.Type">normalizeImpl</a>
      else <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinedType.normalized_=" title="=&gt; Types.this.Type">normalized</a> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;RefinedType.normalized_=" title="(x$1: Types.this.Type)Unit">normalized</a> = <a href="#scala.reflect.internal;Types;RefinedType.normalizeImpl" title="=&gt; Types.this.Type">normalizeImpl</a>
        <a href="#scala.reflect.internal;Types;RefinedType.normalized_=" title="=&gt; Types.this.Type">normalized</a>
      <span class="delimiter">}</span>

    private var <a title="Types.this.Type" id="scala.reflect.internal;Types;RefinedType.normalized_=">normalized</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = _
    private def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;RefinedType.normalizeImpl">normalizeImpl</a> = <span class="delimiter">{</span>
      <span class="comment">// TODO see comments around def intersectionType and def merge</span>
      def <a title="(tps: List[Types.this.Type])List[Types.this.Type]" id="scala.reflect.internal;Types;RefinedType.normalizeImpl.flatten">flatten</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types;RefinedType.normalizeImpl.flatten.tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;RefinedType.normalizeImpl.flatten.tps" title="List[Types.this.Type]">tps</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.flatMap" title="(f: Types.this.Type =&gt; scala.collection.GenTraversableOnce[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">flatMap</a> <a href="#scala.reflect.internal;Types;RefinedType.normalizeImpl.flatten.$anonfun.x0$1" title="List[Types.this.Type]" class="delimiter">{</a> case RefinedType<span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types;RefinedType.normalizeImpl.flatten.$anonfun.parents">parents</a>, <a title="Types.this.Scope" id="scala.reflect.internal;Types;RefinedType.normalizeImpl.flatten.$anonfun.ds">ds</a><span class="delimiter">)</span> if <a href="#scala.reflect.internal;Types;RefinedType.normalizeImpl.flatten.$anonfun.ds" title="Types.this.Scope">ds</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.isEmpty" title="=&gt; Boolean">isEmpty</a> =&gt; <a href="#scala.reflect.internal;Types;RefinedType.normalizeImpl.flatten" title="(tps: List[Types.this.Type])List[Types.this.Type]">flatten</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinedType.normalizeImpl.flatten.$anonfun.parents" title="List[Types.this.Type]">parents</a><span class="delimiter">)</span> case <a title="Types.this.Type" id="scala.reflect.internal;Types;RefinedType.normalizeImpl.flatten.$anonfun.tp">tp</a> =&gt; <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.List.apply" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinedType.normalizeImpl.flatten.$anonfun.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span class="delimiter">}</span>
      val <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;RefinedType.normalizeImpl.flattened">flattened</a> = <a href="#scala.reflect.internal;Types;RefinedType.normalizeImpl.flatten" title="(tps: List[Types.this.Type])List[Types.this.Type]">flatten</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinedType.parents" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.distinct" title="=&gt; List[Types.this.Type]">distinct</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinedType.decls" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.hasLength" title="(xs: List[_], len: Int)Boolean">hasLength</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinedType.normalizeImpl.flattened" title="List[Types.this.Type]">flattened</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types;RefinedType.normalizeImpl.flattened" title="List[Types.this.Type]">flattened</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Type">head</a>
      <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinedType.normalizeImpl.flattened" title="List[Types.this.Type]">flattened</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.reflect.internal;Types;RefinedType.parents" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types.refinedType(b06f606da5)" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinedType.normalizeImpl.flattened" title="List[Types.this.Type]">flattened</a>, if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a> else <a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a>, <a href="#scala.reflect.internal;Types;RefinedType.decls" title="=&gt; Types.this.Scope">decls</a>, <a href="Positions.scala.html#scala.reflect.internal;Positions.NoPosition" title="=&gt; reflect.internal.util.NoPosition.type">NoPosition</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinedType.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types;RefinedType.etaExpand" title="=&gt; Types.this.Type">etaExpand</a>
      <span class="delimiter">}</span> else super.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a>
    <span class="delimiter">}</span>

    final override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;RefinedType.etaExpand">etaExpand</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="comment">// MO to AM: This is probably not correct</span>
      <span class="comment">// If they are several higher-kinded parents with different bounds we need</span>
      <span class="comment">// to take the intersection of their bounds</span>
      <span class="comment">// !!! inconsistent with TypeRef.etaExpand that uses initializedTypeParams</span>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;RefinedType.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> this
      else <a href="#scala.reflect.internal;Types.typeFun" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span>
        <a href="#scala.reflect.internal;Types;RefinedType.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>,
        <a href="#scala.reflect.internal;Types.RefinedType.apply(37899be632)" title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span>
          <a href="#scala.reflect.internal;Types;RefinedType.parents" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#scala.reflect.internal;Types;RefinedType.etaExpand.$anonfun.x0$2" title="Types.this.Type" class="delimiter">{</a>
            case TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;RefinedType.etaExpand.$anonfun.pre">pre</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;RefinedType.etaExpand.$anonfun.sym">sym</a>, <a href="../../collection/generic/SeqFactory.scala.html#scala.collection.generic;SeqFactory.unapplySeq" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73)" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinedType.etaExpand.$anonfun.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;RefinedType.etaExpand.$anonfun.sym" title="Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types;Type.dummyArgs" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>
            case <a title="Types.this.Type" id="scala.reflect.internal;Types;RefinedType.etaExpand.$anonfun.p">p</a> =&gt; <a href="#scala.reflect.internal;Types;RefinedType.etaExpand.$anonfun.p" title="Types.this.Type">p</a>
          <span class="delimiter">}</span>,
          <a href="#scala.reflect.internal;Types;RefinedType.decls" title="=&gt; Types.this.Scope">decls</a>,
          <a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    override def <a title="=&gt; String" id="scala.reflect.internal;Types;RefinedType.kind">kind</a> = <span title="String(&quot;RefinedType&quot;)" class="string">&quot;RefinedType&quot;</span>
  <span class="delimiter">}</span>

  final class <a title="class RefinedType0 extends Types.this.RefinedType" id="scala.reflect.internal;Types;RefinedType0">RefinedType0</a><a href="#scala.reflect.internal;Types;RefinedType0" title="Types.this.RefinedType0" class="delimiter">(</a><a title="List[Types.this.Type]" id="scala.reflect.internal;Types;RefinedType0.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="scala.reflect.internal;Types;RefinedType0.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;RefinedType0.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;RefinedType" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinedType0.parents" title="List[Types.this.Type]">parents</a>, <a href="#scala.reflect.internal;Types;RefinedType0.decls" title="Types.this.Scope">decls</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;RefinedType0.typeSymbol">typeSymbol</a> = <a href="#scala.reflect.internal;Types;RefinedType0.clazz" title="Types.this.Symbol">clazz</a>
  <span class="delimiter">}</span>

  object <a title="Types.this.RefinedType.type" id="scala.reflect.internal;Types.RefinedType.readResolve">RefinedType</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;RefinedTypeExtractor" title="Types.this.RefinedTypeExtractor">RefinedTypeExtractor</a> <span class="delimiter">{</span>
    def <a title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType" id="scala.reflect.internal;Types.RefinedType.apply(37899be632)">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.RefinedType.apply(37899be632).parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="scala.reflect.internal;Types.RefinedType.apply(37899be632).decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.RefinedType.apply(37899be632).clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;RefinedType" title="Types.this.RefinedType">RefinedType</a> =
      new <a href="#scala.reflect.internal;Types;RefinedType0" title="Types.this.RefinedType0">RefinedType0</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.RefinedType.apply(37899be632).parents" title="List[Types.this.Type]">parents</a>, <a href="#scala.reflect.internal;Types.RefinedType.apply(37899be632).decls" title="Types.this.Scope">decls</a>, <a href="#scala.reflect.internal;Types.RefinedType.apply(37899be632).clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Overridden in reflection compiler */</span>
  def <a title="(tp: Types.this.ClassInfoType)Unit" id="scala.reflect.internal;Types.validateClassInfo">validateClassInfo</a><span class="delimiter">(</span><a title="Types.this.ClassInfoType" id="scala.reflect.internal;Types.validateClassInfo.tp">tp</a>: <a href="#scala.reflect.internal;Types;ClassInfoType" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">)</span> <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>

  <span class="comment">/** A class representing a class info
   */</span>
  case class <a title="class ClassInfoType extends Types.this.CompoundType with Types.this.ClassInfoTypeApi with Product with Serializable" id="scala.reflect.internal;Types;ClassInfoType">ClassInfoType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a>
    override val <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;ClassInfoType.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>,
    override val <a title="Types.this.Scope" id="scala.reflect.internal;Types;ClassInfoType.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a>,
    override val <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassInfoType.typeSymbol">typeSymbol</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;CompoundType" title="Types.this.CompoundType">CompoundType</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;ClassInfoTypeApi" title="Types.this.ClassInfoTypeApi">ClassInfoTypeApi</a>
  <span class="delimiter">{</span>
    <a href="#scala.reflect.internal;Types.validateClassInfo" title="(tp: Types.this.ClassInfoType)Unit">validateClassInfo</a><span class="delimiter">(</span>this<span class="delimiter">)</span>

    <span class="comment">/** refs indices */</span>
    private final val <a title="Int(0)" id="scala.reflect.internal;Types;ClassInfoType.NonExpansive">NonExpansive</a> = <span title="Int(0)" class="int">0</span>
    private final val <a title="Int(1)" id="scala.reflect.internal;Types;ClassInfoType.Expansive">Expansive</a> = <span title="Int(1)" class="int">1</span>

    <span class="comment">/** initialization states */</span>
    private final val <a title="Int(0)" id="scala.reflect.internal;Types;ClassInfoType.UnInitialized">UnInitialized</a> = <span title="Int(0)" class="int">0</span>
    private final val <a title="Int(1)" id="scala.reflect.internal;Types;ClassInfoType.Initializing">Initializing</a> = <span title="Int(1)" class="int">1</span>
    private final val <a title="Int(2)" id="scala.reflect.internal;Types;ClassInfoType.Initialized">Initialized</a> = <span title="Int(2)" class="int">2</span>

    private type <a title="Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]" id="scala.reflect.internal;Types;ClassInfoType;RefMap">RefMap</a> = <a href="../../collection/immutable/Map.scala.html#scala.collection.immutable;Map" title="Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">Map</a><span class="delimiter">[</span>Symbol, immutable.Set<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span>

    <span class="comment">/** All type parameters reachable from given type parameter
     *  by a path which contains at least one expansive reference.
     *  @See Kennedy, Pierce: On Decidability of Nominal Subtyping with Variance
     */</span>
    private<span class="delimiter">[</span>scala<span class="delimiter">]</span> def <a title="(tparam: Types.this.Symbol)Set[Types.this.Symbol]" id="scala.reflect.internal;Types;ClassInfoType.expansiveRefs">expansiveRefs</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassInfoType.expansiveRefs.tparam">tparam</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.state_=" title="=&gt; Int">state</a> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(0)">UnInitialized</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types;ClassInfoType.computeRefs" title="()Unit">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span>
        while <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.state_=" title="=&gt; Int">state</a> <a href="../../Int.scala.html#scala;Int.!=(5f58a84eb3)" title="(x: Int)Boolean">!=</a> <span title="Int(2)">Initialized</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;ClassInfoType.propagate" title="()Boolean">propagate</a><a href="#scala.reflect.internal;Types;ClassInfoType.expansiveRefs.while$5" title="()Unit" class="delimiter">(</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal;Types;ClassInfoType.getRefs" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#scala.reflect.internal;Types;ClassInfoType.expansiveRefs.tparam" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/* The rest of this class is auxiliary code for `expansiveRefs`
     */</span>

    <span class="comment">/** The type parameters which are referenced type parameters of this class.
     *  Two entries: refs(0): Non-expansive references
     *               refs(1): Expansive references
     *  Syncnote: This var need not be protected with synchronized, because
     *  it is accessed only from expansiveRefs, which is called only from
     *  Typer.
     */</span>
    private var <a title="Array[ClassInfoType.this.RefMap]" id="scala.reflect.internal;Types;ClassInfoType.refs_=">refs</a>: <a href="../../Array.scala.html#scala;Array" title="Array[ClassInfoType.this.RefMap]">Array</a><span class="delimiter">[</span>RefMap<span class="delimiter">]</span> = _

    <span class="comment">/** The initialization state of the class: UnInialized --&gt; Initializing --&gt; Initialized
     *  Syncnote: This var need not be protected with synchronized, because
     *  it is accessed only from expansiveRefs, which is called only from
     *  Typer.
     */</span>
    private var <a title="Int" id="scala.reflect.internal;Types;ClassInfoType.state_=">state</a> = <span title="Int(0)">UnInitialized</span>

    <span class="comment">/** Get references for given type parameter
     *  @param  which in {NonExpansive, Expansive}
     *  @param  from  The type parameter from which references originate.
     */</span>
    private def <a title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]" id="scala.reflect.internal;Types;ClassInfoType.getRefs">getRefs</a><span class="delimiter">(</span><a title="Int" id="scala.reflect.internal;Types;ClassInfoType.getRefs.which">which</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassInfoType.getRefs.from">from</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../collection/immutable/Set.scala.html#scala.collection.immutable;Set" title="Set[Types.this.Symbol]">Set</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.getRefs.which" title="Int">which</a><span class="delimiter">)</span> <a href="../../collection/MapLike.scala.html#scala.collection;MapLike.get" title="(key: Types.this.Symbol)Option[scala.collection.immutable.Set[Types.this.Symbol]]">get</a> <a href="#scala.reflect.internal;Types;ClassInfoType.getRefs.from" title="Types.this.Symbol">from</a> match <span class="delimiter">{</span>
      case Some<span class="delimiter">(</span><a title="scala.collection.immutable.Set[Types.this.Symbol]" id="scala.reflect.internal;Types;ClassInfoType.getRefs.set">set</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types;ClassInfoType.getRefs.set" title="scala.collection.immutable.Set[Types.this.Symbol]">set</a>
      case <a title="Option[scala.collection.immutable.Set[Types.this.Symbol]]" id="scala.reflect.internal;Types;ClassInfoType.getRefs.none">none</a> =&gt; <a href="../../collection/generic/GenericCompanion.scala.html#scala.collection.generic;GenericCompanion.apply" title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]">Set</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Augment existing refs map with reference &lt;pre&gt;from -&gt; to&lt;/pre&gt;
     *  @param  which &lt;- {NonExpansive, Expansive}
     */</span>
    private def <a title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit" id="scala.reflect.internal;Types;ClassInfoType.addRef">addRef</a><span class="delimiter">(</span><a title="Int" id="scala.reflect.internal;Types;ClassInfoType.addRef.which">which</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassInfoType.addRef.from">from</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassInfoType.addRef.to">to</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../Array.scala.html#scala;Array.update" title="(i: Int, x: ClassInfoType.this.RefMap)Unit">refs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.addRef.which" title="Int">which</a><span class="delimiter">)</span> = <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.addRef.which" title="Int">which</a><span class="delimiter">)</span> <a href="../../collection/immutable/Map.scala.html#scala.collection.immutable;Map.+(f81ff2b7d7)" title="(kv: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]))scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">+</a> <span class="delimiter">(</span><a href="../../Predef.scala.html#scala.Predef.ArrowAssoc(fefc64a42a)" title="(self: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">from</a> <a href="../../Predef.scala.html#scala.Predef;ArrowAssoc.->" title="(y: scala.collection.immutable.Set[Types.this.Symbol])(Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])">-&gt;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.getRefs" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.addRef.which" title="Int">which</a>, <a href="#scala.reflect.internal;Types;ClassInfoType.addRef.from" title="Types.this.Symbol">from</a><span class="delimiter">)</span> <a href="../../collection/SetLike.scala.html#scala.collection;SetLike.+(daf7108c0f)" title="(elem: Types.this.Symbol)scala.collection.immutable.Set[Types.this.Symbol]">+</a> <a href="#scala.reflect.internal;Types;ClassInfoType.addRef.to" title="Types.this.Symbol">to</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Augment existing refs map with references &lt;pre&gt;from -&gt; sym&lt;/pre&gt;, for
     *  all elements &lt;pre&gt;sym&lt;/pre&gt; of set `to`.
     *  @param  which &lt;- {NonExpansive, Expansive}
     */</span>
    private def <a title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit" id="scala.reflect.internal;Types;ClassInfoType.addRefs">addRefs</a><span class="delimiter">(</span><a title="Int" id="scala.reflect.internal;Types;ClassInfoType.addRefs.which">which</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassInfoType.addRefs.from">from</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Set[Types.this.Symbol]" id="scala.reflect.internal;Types;ClassInfoType.addRefs.to">to</a>: <a href="../../collection/immutable/Set.scala.html#scala.collection.immutable;Set" title="Set[Types.this.Symbol]">Set</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../Array.scala.html#scala;Array.update" title="(i: Int, x: ClassInfoType.this.RefMap)Unit">refs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.addRefs.which" title="Int">which</a><span class="delimiter">)</span> = <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.addRefs.which" title="Int">which</a><span class="delimiter">)</span> <a href="../../collection/immutable/Map.scala.html#scala.collection.immutable;Map.+(f81ff2b7d7)" title="(kv: (Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol]))scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">+</a> <span class="delimiter">(</span><a href="../../Predef.scala.html#scala.Predef.ArrowAssoc(fefc64a42a)" title="(self: Types.this.Symbol)ArrowAssoc[Types.this.Symbol]">from</a> <a href="../../Predef.scala.html#scala.Predef;ArrowAssoc.->" title="(y: scala.collection.immutable.Set[Types.this.Symbol])(Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])">-&gt;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.getRefs" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.addRefs.which" title="Int">which</a>, <a href="#scala.reflect.internal;Types;ClassInfoType.addRefs.from" title="Types.this.Symbol">from</a><span class="delimiter">)</span> <a href="../../collection/SetLike.scala.html#scala.collection;SetLike.++(07e1553119)" title="(elems: scala.collection.GenTraversableOnce[Types.this.Symbol])scala.collection.immutable.Set[Types.this.Symbol]">++</a> <a href="#scala.reflect.internal;Types;ClassInfoType.addRefs.to" title="Set[Types.this.Symbol]">to</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** The ClassInfoType which belongs to the class containing given type parameter
     */</span>
    private def <a title="(tparam: Types.this.Symbol)Types.this.ClassInfoType" id="scala.reflect.internal;Types;ClassInfoType.classInfo">classInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassInfoType.classInfo.tparam">tparam</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;ClassInfoType" title="Types.this.ClassInfoType">ClassInfoType</a> =
      <a href="#scala.reflect.internal;Types;ClassInfoType.classInfo.tparam" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.resultType(9b9cdebb0f)" title="=&gt; Types.this.Type">resultType</a> match <span class="delimiter">{</span>
        case <a title="Types.this.ClassInfoType" id="scala.reflect.internal;Types;ClassInfoType.classInfo.ci">ci</a>: <a href="#scala.reflect.internal;Types;ClassInfoType" title="Types.this.ClassInfoType">ClassInfoType</a> =&gt; <a href="#scala.reflect.internal;Types;ClassInfoType.classInfo.ci" title="Types.this.ClassInfoType">ci</a>
        case _ =&gt; <a href="#scala.reflect.internal;Types;ClassInfoType.classInfo" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ObjectClass" title="=&gt; Types.this.ClassSymbol">ObjectClass</a><span class="delimiter">)</span> <span class="comment">// something's wrong; fall back to safe value</span>
                                         <span class="comment">// (this can happen only for erroneous programs).</span>
      <span class="delimiter">}</span>

    private object <a title="ClassInfoType.this.enterRefs.type" id="scala.reflect.internal;Types;ClassInfoType.enterRefs">enterRefs</a> extends <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeMap" title="Types.this.TypeMap">TypeMap</a> <span class="delimiter">{</span>
      private var <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassInfoType.enterRefs.tparam_=">tparam</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = _

      def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;ClassInfoType.enterRefs.apply">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
          case <a title="Types.this.TypeRef" id="scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.tr">tr</a> @ TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.sym">sym</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.args">args</a><span class="delimiter">)</span> if <a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.args" title="List[Types.this.Type]">args</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a> =&gt;
            val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.tparams">tparams</a> = <a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.tr" title="Types.this.TypeRef">tr</a>.<a href="#scala.reflect.internal;Types;TypeRef.initializedTypeParams" title="=&gt; List[Types.this.Symbol]">initializedTypeParams</a>
            if <span class="delimiter">(</span><a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">debug</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.sameLength" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.tparams" title="List[Types.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.devWarning" title="(msg: =&gt; String)Unit">devWarning</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;Mismatched zip in computeRefs(): &quot;)">Mismatched zip in computeRefs(): $</span><span class="delimiter">{</span><a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">}</span><span title="String(&quot;, &quot;)">, $</span><a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.args" title="List[Types.this.Type]">args</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>

            <a href="util/Collections.scala.html#scala.reflect.internal.util;Collections.foreach2" title="(xs1: List[Types.this.Symbol], xs2: List[Types.this.Type])(f: (Types.this.Symbol, Types.this.Type) =&gt; Unit)Unit">foreach2</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.tparams" title="List[Types.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.$anonfun.tparam1">tparam1</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.$anonfun.arg">arg</a><span class="delimiter">)</span> =&gt;
              if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.$anonfun.arg" title="Types.this.Type">arg</a> <a href="#scala.reflect.internal;Types;Type.contains" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.tparam_=" title="=&gt; Types.this.Symbol">tparam</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="#scala.reflect.internal;Types;ClassInfoType.addRef" title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit">addRef</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.tparam_=" title="=&gt; Types.this.Symbol">tparam</a>, <a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.$anonfun.tparam1" title="Types.this.Symbol">tparam1</a><span class="delimiter">)</span>
                if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.$anonfun.arg" title="Types.this.Type">arg</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.tparam_=" title="=&gt; Types.this.Symbol">tparam</a><span class="delimiter">)</span>
                  <a href="#scala.reflect.internal;Types;ClassInfoType.addRef" title="(which: Int, from: Types.this.Symbol, to: Types.this.Symbol)Unit">addRef</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.tparam_=" title="=&gt; Types.this.Symbol">tparam</a>, <a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.$anonfun.tparam1" title="Types.this.Symbol">tparam1</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
          case _ =&gt;
        <span class="delimiter">}</span>
        <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(ad9e013c92)" title="(tp: Types.this.Type)Types.this.Type">mapOver</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.apply.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      def <a title="(tparam0: Types.this.Symbol, parent: Types.this.Type)Unit" id="scala.reflect.internal;Types;ClassInfoType.enterRefs.enter">enter</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassInfoType.enterRefs.enter.tparam0">tparam0</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;ClassInfoType.enterRefs.enter.parent">parent</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        this.<a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.tparam_=" title="(x$1: Types.this.Symbol)Unit">tparam</a> = <a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.enter.tparam0" title="Types.this.Symbol">tparam0</a>
        this<span title="Unit" class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.enter.parent" title="Types.this.Type">parent</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Compute initial (one-step) references and set state to `Initializing`.
     */</span>
    private def <a title="()Unit" id="scala.reflect.internal;Types;ClassInfoType.computeRefs">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#scala.reflect.internal;Types;ClassInfoType.refs_=" title="(x$1: Array[ClassInfoType.this.RefMap])Unit">refs</a> = <a href="../../Array.scala.html#scala.Array.apply(f425c59989)" title="(xs: ClassInfoType.this.RefMap*)(implicit evidence$2: scala.reflect.ClassTag[ClassInfoType.this.RefMap])Array[ClassInfoType.this.RefMap]">Array</a><a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(runtimeClass1: Class[_])scala.reflect.ClassTag[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" class="delimiter">(</a><a href="../../collection/generic/GenMapFactory.scala.html#scala.collection.generic;GenMapFactory.apply" title="(elems: (Types.this.Symbol, Nothing)*)scala.collection.immutable.Map[Types.this.Symbol,Nothing]">Map</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="../../collection/generic/GenMapFactory.scala.html#scala.collection.generic;GenMapFactory.apply" title="(elems: (Types.this.Symbol, Nothing)*)scala.collection.immutable.Map[Types.this.Symbol,Nothing]">Map</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types;ClassInfoType.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: Types.this.Symbol =&gt; Unit)Unit">foreach</a> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassInfoType.computeRefs.$anonfun.tparam">tparam</a> =&gt;
        <a href="#scala.reflect.internal;Types;ClassInfoType.parents" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: Types.this.Type =&gt; Unit)Unit">foreach</a> <span class="delimiter">{</span> <a title="Types.this.Type" id="scala.reflect.internal;Types;ClassInfoType.computeRefs.$anonfun.$anonfun.p">p</a> =&gt;
          <a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs" title="ClassInfoType.this.enterRefs.type">enterRefs</a>.<a href="#scala.reflect.internal;Types;ClassInfoType.enterRefs.enter" title="(tparam0: Types.this.Symbol, parent: Types.this.Type)Unit">enter</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.computeRefs.$anonfun.tparam" title="Types.this.Symbol">tparam</a>, <a href="#scala.reflect.internal;Types;ClassInfoType.computeRefs.$anonfun.$anonfun.p" title="Types.this.Type">p</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal;Types;ClassInfoType.state_=" title="(x$1: Int)Unit">state</a> = <span title="Int(1)">Initializing</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Propagate to form transitive closure.
     *  Set state to Initialized if no change resulted from propagation.
     *  @return   true iff there as a change in last iteration
     */</span>
    private def <a title="()Boolean" id="scala.reflect.internal;Types;ClassInfoType.propagate">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.state_=" title="=&gt; Int">state</a> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(0)">UnInitialized</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;ClassInfoType.computeRefs" title="()Unit">computeRefs</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="comment">//Console.println(&quot;Propagate &quot;+symbol+&quot;, initial expansive = &quot;+refs(Expansive)+&quot;, nonexpansive = &quot;+refs(NonExpansive))//DEBUG</span>
      val <a title="Array[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" id="scala.reflect.internal;Types;ClassInfoType.propagate.lastRefs">lastRefs</a> = <a href="../../Array.scala.html#scala.Array.apply(f425c59989)" title="(xs: ClassInfoType.this.RefMap*)(implicit evidence$2: scala.reflect.ClassTag[ClassInfoType.this.RefMap])Array[ClassInfoType.this.RefMap]">Array</a><a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(runtimeClass1: Class[_])scala.reflect.ClassTag[scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]]" class="delimiter">(</a><a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>, <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types;ClassInfoType.state_=" title="(x$1: Int)Unit">state</a> = <span title="Int(2)">Initialized</span>
      var <a title="Boolean" id="scala.reflect.internal;Types;ClassInfoType.propagate.change">change</a> = false
      for <span class="delimiter">(</span><span class="delimiter">(</span><span title="Types.this.Symbol">from</span>, <span title="scala.collection.immutable.Set[Types.this.Symbol]">targets</span><span class="delimiter">)</span> &lt;- <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span><span class="delimiter">)</span>.<a href="../../collection/Iterator.scala.html#scala.collection;Iterator.foreach" title="(f: ((Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])) =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
        for <span class="delimiter">(</span><span title="Types.this.Symbol">target</span> &lt;- <a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.foreach" title="(f: Types.this.Symbol =&gt; Unit)Unit">targets</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          val <span title="Types.this.ClassInfoType">thatInfo</span> = <a href="#scala.reflect.internal;Types;ClassInfoType.classInfo" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><span title="Types.this.Symbol">target</span><span class="delimiter">)</span>
          if <span class="delimiter">(</span><span title="Types.this.ClassInfoType">thatInfo</span>.<a href="#scala.reflect.internal;Types;ClassInfoType.state_=" title="=&gt; Int">state</a> <a href="../../Int.scala.html#scala;Int.!=(5f58a84eb3)" title="(x: Int)Boolean">!=</a> <span title="Int(2)">Initialized</span><span class="delimiter">)</span>
            <a href="#scala.reflect.internal;Types;ClassInfoType.propagate.change" title="Boolean">change</a> = <a href="#scala.reflect.internal;Types;ClassInfoType.propagate.change" title="Boolean">change</a> <a href="../../Boolean.scala.html#scala;Boolean.|" title="(x: Boolean)Boolean">|</a> <span title="Types.this.ClassInfoType">thatInfo</span>.<a href="#scala.reflect.internal;Types;ClassInfoType.propagate" title="()Boolean">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#scala.reflect.internal;Types;ClassInfoType.addRefs" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <span title="Types.this.Symbol">from</span>, <span title="Types.this.ClassInfoType">thatInfo</span>.<a href="#scala.reflect.internal;Types;ClassInfoType.getRefs" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <span title="Types.this.Symbol">target</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#scala.reflect.internal;Types;ClassInfoType.addRefs" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <span title="Types.this.Symbol">from</span>, <span title="Types.this.ClassInfoType">thatInfo</span>.<a href="#scala.reflect.internal;Types;ClassInfoType.getRefs" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <span title="Types.this.Symbol">target</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      for <span class="delimiter">(</span><span class="delimiter">(</span><span title="Types.this.Symbol">from</span>, <span title="scala.collection.immutable.Set[Types.this.Symbol]">targets</span><span class="delimiter">)</span> &lt;- <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span><span class="delimiter">)</span>.<a href="../../collection/Iterator.scala.html#scala.collection;Iterator.foreach" title="(f: ((Types.this.Symbol, scala.collection.immutable.Set[Types.this.Symbol])) =&gt; Unit)Unit">iterator</a><span class="delimiter">)</span>
        for <span class="delimiter">(</span><span title="Types.this.Symbol">target</span> &lt;- <a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.foreach" title="(f: Types.this.Symbol =&gt; Unit)Unit">targets</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          val <span title="Types.this.ClassInfoType">thatInfo</span> = <a href="#scala.reflect.internal;Types;ClassInfoType.classInfo" title="(tparam: Types.this.Symbol)Types.this.ClassInfoType">classInfo</a><span class="delimiter">(</span><span title="Types.this.Symbol">target</span><span class="delimiter">)</span>
          if <span class="delimiter">(</span><span title="Types.this.ClassInfoType">thatInfo</span>.<a href="#scala.reflect.internal;Types;ClassInfoType.state_=" title="=&gt; Int">state</a> <a href="../../Int.scala.html#scala;Int.!=(5f58a84eb3)" title="(x: Int)Boolean">!=</a> <span title="Int(2)">Initialized</span><span class="delimiter">)</span>
            <a href="#scala.reflect.internal;Types;ClassInfoType.propagate.change" title="Boolean">change</a> = <a href="#scala.reflect.internal;Types;ClassInfoType.propagate.change" title="Boolean">change</a> <a href="../../Boolean.scala.html#scala;Boolean.|" title="(x: Boolean)Boolean">|</a> <span title="Types.this.ClassInfoType">thatInfo</span>.<a href="#scala.reflect.internal;Types;ClassInfoType.propagate" title="()Boolean">propagate</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#scala.reflect.internal;Types;ClassInfoType.addRefs" title="(which: Int, from: Types.this.Symbol, to: Set[Types.this.Symbol])Unit">addRefs</a><span class="delimiter">(</span><span title="Int(1)">Expansive</span>, <span title="Types.this.Symbol">from</span>, <span title="Types.this.ClassInfoType">thatInfo</span>.<a href="#scala.reflect.internal;Types;ClassInfoType.getRefs" title="(which: Int, from: Types.this.Symbol)Set[Types.this.Symbol]">getRefs</a><span class="delimiter">(</span><span title="Int(0)">NonExpansive</span>, <span title="Types.this.Symbol">target</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <a href="#scala.reflect.internal;Types;ClassInfoType.propagate.change" title="Boolean">change</a> = <a href="#scala.reflect.internal;Types;ClassInfoType.propagate.change" title="Boolean">change</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x$1: Any)Boolean">!=</span> <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">lastRefs</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)ClassInfoType.this.RefMap">refs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x$1: Any)Boolean">!=</span> <a href="../../Array.scala.html#scala;Array.apply" title="(i: Int)scala.collection.immutable.Map[Types.this.Symbol,scala.collection.immutable.Set[Types.this.Symbol]]">lastRefs</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.propagate.change" title="Boolean">change</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;ClassInfoType.state_=" title="(x$1: Int)Unit">state</a> = <span title="Int(1)">Initializing</span>
      <span class="comment">//else Console.println(&quot;Propagate &quot;+symbol+&quot;, final expansive = &quot;+refs(Expansive)+&quot;, nonexpansive = &quot;+refs(NonExpansive))//DEBUG</span>
      <a href="#scala.reflect.internal;Types;ClassInfoType.propagate.change" title="Boolean">change</a>
    <span class="delimiter">}</span>

    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ClassInfoType.kind">kind</a> = <span title="String(&quot;ClassInfoType&quot;)" class="string">&quot;ClassInfoType&quot;</span>
    <span class="comment">/** A nicely formatted string with newlines and such.
     */</span>
    def <a title="=&gt; String" id="scala.reflect.internal;Types;ClassInfoType.formattedToString">formattedToString</a> = <a href="#scala.reflect.internal;Types;ClassInfoType.parents" title="=&gt; List[Types.this.Type]">parents</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;\n        with &quot;)" class="string">&quot;\n        with &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;ClassInfoType.scopeString" title="=&gt; String">scopeString</a>
    override protected def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;ClassInfoType.shouldForceScope">shouldForceScope</a> = <a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">debug</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types;ClassInfoType.decls" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.size" title="=&gt; Int">size</a> <a href="../../Int.scala.html#scala;Int.>(5f58a84eb3)" title="(x: Int)Boolean">&gt;</a> <span title="Int(1)" class="int">1</span>
    override protected def <a title="=&gt; String" id="scala.reflect.internal;Types;ClassInfoType.scopeString">scopeString</a>      = <a href="#scala.reflect.internal;Types;CompoundType.initDecls" title="=&gt; Types.this.Scope">initDecls</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot; {\n  &quot;)" class="string">&quot; {\n  &quot;</span>, <span title="String(&quot;\n  &quot;)" class="string">&quot;\n  &quot;</span>, <span title="String(&quot;\n}&quot;)" class="string">&quot;\n}&quot;</span><span class="delimiter">)</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ClassInfoType.safeToString">safeToString</a>               = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassInfoType.shouldForceScope" title="=&gt; Boolean">shouldForceScope</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;ClassInfoType.formattedToString" title="=&gt; String">formattedToString</a> else super.<a href="#scala.reflect.internal;Types;CompoundType.safeToString" title="=&gt; String">safeToString</a>
  <span class="delimiter">}</span>

  object <a title="Types.this.ClassInfoType.type" id="scala.reflect.internal;Types.ClassInfoType.readResolve">ClassInfoType</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;ClassInfoTypeExtractor" title="Types.this.ClassInfoTypeExtractor">ClassInfoTypeExtractor</a>

  class <a title="class PackageClassInfoType extends Types.this.ClassInfoType" id="scala.reflect.internal;Types;PackageClassInfoType">PackageClassInfoType</a><a href="#scala.reflect.internal;Types;PackageClassInfoType" title="Types.this.PackageClassInfoType" class="delimiter">(</a><a title="Types.this.Scope" id="scala.reflect.internal;Types;PackageClassInfoType.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;PackageClassInfoType.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
  extends <a href="#scala.reflect.internal;Types;ClassInfoType" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">(</span>List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types;PackageClassInfoType.decls" title="Types.this.Scope">decls</a>, <a href="#scala.reflect.internal;Types;PackageClassInfoType.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>

  <span class="comment">/** A class representing a constant type.
   */</span>
  abstract case class <a href="#scala.reflect.internal;Types;ConstantType.productElement.x$1" title="class ConstantType extends Types.this.SingletonType with Types.this.ConstantTypeApi with Product with Serializable" id="scala.reflect.internal;Types;ConstantType">ConstantType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Types.this.Constant" id="scala.reflect.internal;Types;ConstantType.value">value</a>: <a href="Constants.scala.html#scala.reflect.internal;Constants;Constant" title="Types.this.Constant">Constant</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;SingletonType" title="Types.this.SingletonType">SingletonType</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;ConstantTypeApi" title="Types.this.ConstantTypeApi">ConstantTypeApi</a> <span class="delimiter">{</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;ConstantType.underlying">underlying</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;ConstantType.value" title="=&gt; Types.this.Constant">value</a>.<a href="Constants.scala.html#scala.reflect.internal;Constants;Constant.tpe" title="=&gt; Types.this.Type">tpe</a>
    <a href="../../Predef.scala.html#scala.Predef.assert(65d7b4917f)" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ConstantType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: Any)Boolean">!=</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;ValueClassDefinitions.UnitClass" title="=&gt; Types.this.ClassSymbol">UnitClass</a><span class="delimiter">)</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;ConstantType.isTrivial">isTrivial</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = true
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;ConstantType.deconst">deconst</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;ConstantType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.deconst" title="=&gt; Types.this.Type">deconst</a>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ConstantType.safeToString">safeToString</a>: <span title="String">String</span> =
      <a href="#scala.reflect.internal;Types;ConstantType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.toString" title="()String">toString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;ConstantType.value" title="=&gt; Types.this.Constant">value</a>.<a href="Constants.scala.html#scala.reflect.internal;Constants;Constant.escapedStringValue" title="=&gt; String">escapedStringValue</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ConstantType.kind">kind</a> = <span title="String(&quot;ConstantType&quot;)" class="string">&quot;ConstantType&quot;</span>
  <span class="delimiter">}</span>

  final class <a title="class UniqueConstantType extends Types.this.ConstantType" id="scala.reflect.internal;Types;UniqueConstantType">UniqueConstantType</a><a href="#scala.reflect.internal;Types;UniqueConstantType" title="Types.this.UniqueConstantType" class="delimiter">(</a><a title="Types.this.Constant" id="scala.reflect.internal;Types;UniqueConstantType.value">value</a>: <a href="Constants.scala.html#scala.reflect.internal;Constants;Constant" title="Types.this.Constant">Constant</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;ConstantType" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;UniqueConstantType.value" title="Types.this.Constant">value</a><span class="delimiter">)</span>

  object <a title="Types.this.ConstantType.type" id="scala.reflect.internal;Types.ConstantType.readResolve">ConstantType</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;ConstantTypeExtractor" title="Types.this.ConstantTypeExtractor">ConstantTypeExtractor</a> <span class="delimiter">{</span>
    def <a title="(value: Types.this.Constant)Types.this.UniqueConstantType" id="scala.reflect.internal;Types.ConstantType.apply(682e31eef0)">apply</a><span class="delimiter">(</span><a title="Types.this.Constant" id="scala.reflect.internal;Types.ConstantType.apply(682e31eef0).value">value</a>: <a href="Constants.scala.html#scala.reflect.internal;Constants;Constant" title="Types.this.Constant">Constant</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.unique" title="(tp: Types.this.UniqueConstantType)Types.this.UniqueConstantType">unique</a><span class="delimiter">(</span>new <a href="#scala.reflect.internal;Types;UniqueConstantType" title="Types.this.UniqueConstantType">UniqueConstantType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.ConstantType.apply(682e31eef0).value" title="Types.this.Constant">value</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/* Syncnote: The `volatile` var and `pendingVolatiles` mutable set need not be protected
   * with synchronized, because they are accessed only from isVolatile, which is called only from
   * Typer.
   */</span>
  private var <a title="Int" id="scala.reflect.internal;Types.volatileRecursions_=">volatileRecursions</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> = <span title="Int(0)" class="int">0</span>
  private val <a title="scala.collection.mutable.HashSet[Types.this.Symbol]" id="scala.reflect.internal;Types.pendingVolatiles">pendingVolatiles</a> = new mutable.<a href="../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet" title="scala.collection.mutable.HashSet[Types.this.Symbol]">HashSet</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

  class <a title="class ArgsTypeRef extends Types.this.TypeRef" id="scala.reflect.internal;Types;ArgsTypeRef">ArgsTypeRef</a><a href="#scala.reflect.internal;Types;ArgsTypeRef" title="Types.this.ArgsTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;ArgsTypeRef.pre0">pre0</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ArgsTypeRef.sym0">sym0</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;ArgsTypeRef.args0">args0</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;TypeRef" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ArgsTypeRef.pre0" title="Types.this.Type">pre0</a>, <a href="#scala.reflect.internal;Types;ArgsTypeRef.sym0" title="Types.this.Symbol">sym0</a>, <a href="#scala.reflect.internal;Types;ArgsTypeRef.args0" title="List[Types.this.Type]">args0</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#scala.Predef.require(a2f0e4a061)" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ArgsTypeRef.args0" title="List[Types.this.Type]">args0</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, this<span class="delimiter">)</span>

    <span class="comment">/** No unapplied type params size it has (should have) equally as many args. */</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;ArgsTypeRef.isHigherKinded">isHigherKinded</a> = false
    override def <a title="=&gt; scala.collection.immutable.Nil.type" id="scala.reflect.internal;Types;ArgsTypeRef.typeParams">typeParams</a> = <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>

    override def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;ArgsTypeRef.transform">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;ArgsTypeRef.transform.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="comment">// This situation arises when a typevar is encountered for which</span>
      <span class="comment">// too little information is known to determine its kind, and</span>
      <span class="comment">// it later turns out not to have kind *. See SI-4070.  Only</span>
      <span class="comment">// logging it for now.</span>
      val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;ArgsTypeRef.transform.tparams">tparams</a> = <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ArgsTypeRef.transform.tparams" title="List[Types.this.Symbol]">tparams</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.size" title="=&gt; Int">size</a> <a href="../../Int.scala.html#scala;Int.!=(5f58a84eb3)" title="(x: Int)Boolean">!=</a> <a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.size" title="=&gt; Int">size</a><span class="delimiter">)</span>
        <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.devWarning" title="(msg: =&gt; String)Unit">devWarning</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span>this<a href="#scala.reflect.internal;Types;ArgsTypeRef" title="String(&quot;.transform(&quot;)">.transform($</a><a href="#scala.reflect.internal;Types;ArgsTypeRef.transform.tp" title="Types.this.Type">tp</a><span title="String(&quot;), but tparams.isEmpty and args=&quot;)">), but tparams.isEmpty and args=$</span><a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
      def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;ArgsTypeRef.transform.asSeenFromInstantiated">asSeenFromInstantiated</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;ArgsTypeRef.transform.asSeenFromInstantiated.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
        <a href="#scala.reflect.internal;Types;TypeRef.asSeenFromOwner" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ArgsTypeRef.transform.asSeenFromInstantiated.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ArgsTypeRef.transform.tparams" title="List[Types.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="comment">// If we're called with a poly type, and we were to run the `asSeenFrom`, over the entire</span>
      <span class="comment">// type, we can end up with new symbols for the type parameters (clones from TypeMap).</span>
      <span class="comment">// The subsequent substitution of type arguments would fail. This problem showed up during</span>
      <span class="comment">// the fix for SI-8046, however the solution taken there wasn't quite right, and led to</span>
      <span class="comment">// SI-8170.</span>
      <span class="comment">//</span>
      <span class="comment">// Now, we detect the PolyType before both the ASF *and* the substitution, and just operate</span>
      <span class="comment">// on the result type.</span>
      <span class="comment">//</span>
      <span class="comment">// TODO: Revisit this and explore the questions raised:</span>
      <span class="comment">//</span>
      <span class="comment">//  AM: I like this better than the old code, but is there any way the tparams would need the ASF treatment as well?</span>
      <span class="comment">//  JZ: I think its largely irrelevant, as they are no longer referred to in the result type.</span>
      <span class="comment">//      In fact, you can get away with returning a type of kind * here and the sky doesn't fall:</span>
      <span class="comment">//        `case PolyType(`tparams`, result) =&gt; asSeenFromInstantiated(result)`</span>
      <span class="comment">//      But I thought it was better to retain the kind.</span>
      <span class="comment">//  AM: I've been experimenting with apply-type-args-then-ASF, but running into cycles.</span>
      <span class="comment">//      In general, it seems iffy the tparams can never occur in the result</span>
      <span class="comment">//      then we might as well represent the type as a no-arg typeref.</span>
      <span class="comment">//  AM: I've also been trying to track down uses of transform (pretty generic name for something that</span>
      <span class="comment">//      does not seem that widely applicable).</span>
      <span class="comment">//      It's kind of a helper for computing baseType (since it tries to propagate our type args to some</span>
      <span class="comment">//      other type, which has to be related to this type for that to make sense).</span>
      <span class="comment">//</span>
      <a href="#scala.reflect.internal;Types;ArgsTypeRef.transform.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
        case PolyType<span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ArgsTypeRef.transform.tparams" title="List[Types.this.Symbol]">`tparams`</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;ArgsTypeRef.transform.result">result</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types;PolyType" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ArgsTypeRef.transform.tparams" title="List[Types.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal;Types;ArgsTypeRef.transform.asSeenFromInstantiated" title="(tp: Types.this.Type)Types.this.Type">asSeenFromInstantiated</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ArgsTypeRef.transform.result" title="Types.this.Type">result</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case _                           =&gt; <a href="#scala.reflect.internal;Types;ArgsTypeRef.transform.asSeenFromInstantiated" title="(tp: Types.this.Type)Types.this.Type">asSeenFromInstantiated</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ArgsTypeRef.transform.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">// note: does not go through typeRef. There's no need to because</span>
    <span class="comment">// neither `pre` nor `sym` changes.  And there's a performance</span>
    <span class="comment">// advantage to call TypeRef directly.</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;ArgsTypeRef.typeConstructor">typeConstructor</a> = <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73)" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  class <a title="class ModuleTypeRef extends Types.this.NoArgsTypeRef with Types.this.ClassTypeRef" id="scala.reflect.internal;Types;ModuleTypeRef">ModuleTypeRef</a><a href="#scala.reflect.internal;Types;ModuleTypeRef" title="Types.this.ModuleTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;ModuleTypeRef.pre0">pre0</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ModuleTypeRef.sym0">sym0</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;NoArgsTypeRef" title="Types.this.NoArgsTypeRef">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ModuleTypeRef.pre0" title="Types.this.Type">pre0</a>, <a href="#scala.reflect.internal;Types;ModuleTypeRef.sym0" title="Types.this.Symbol">sym0</a><span class="delimiter">)</span> with <a href="#scala.reflect.internal;Types;ClassTypeRef" title="Types.this.ClassTypeRef">ClassTypeRef</a> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#scala.Predef.require(a2f0e4a061)" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModuleClass" title="=&gt; Boolean">isModuleClass</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
    private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="Types.this.Type" id="scala.reflect.internal;Types;ModuleTypeRef.narrowedCache">narrowedCache</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = _
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;ModuleTypeRef.narrow">narrow</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ModuleTypeRef.narrowedCache" title="Types.this.Type">narrowedCache</a> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;ModuleTypeRef.narrowedCache" title="Types.this.Type">narrowedCache</a> = <a href="#scala.reflect.internal;Types.singleType" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.sourceModule" title="=&gt; Types.this.Symbol">sourceModule</a><span class="delimiter">)</span>

      <a href="#scala.reflect.internal;Types;ModuleTypeRef.narrowedCache" title="Types.this.Type">narrowedCache</a>
    <span class="delimiter">}</span>
    override protected def <a title="(rest: String)String" id="scala.reflect.internal;Types;ModuleTypeRef.finishPrefix">finishPrefix</a><span class="delimiter">(</span><a title="String" id="scala.reflect.internal;Types;ModuleTypeRef.finishPrefix.rest">rest</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;Type.objectPrefix" title="=&gt; String">objectPrefix</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;ModuleTypeRef.finishPrefix.rest" title="String">rest</a>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ModuleTypeRef.directObjectString">directObjectString</a> = super.<a href="#scala.reflect.internal;Types;TypeRef.safeToString" title="=&gt; String">safeToString</a>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ModuleTypeRef.toLongString">toLongString</a> = <a href="#scala.reflect.internal;Types;Type.toString" title="()String">toString</a>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ModuleTypeRef.safeToString">safeToString</a> = <a href="#scala.reflect.internal;Types;ModuleTypeRef.prefixString" title="=&gt; String">prefixString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;type&quot;)" class="string">&quot;type&quot;</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ModuleTypeRef.prefixString">prefixString</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isOmittablePrefix" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> else <a href="#scala.reflect.internal;Types;TypeRef.prefix" title="=&gt; Types.this.Type">prefix</a>.<a href="#scala.reflect.internal;Types;Type.prefixString" title="=&gt; String">prefixString</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.nameString" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
  <span class="delimiter">}</span>
  class <a title="class PackageTypeRef extends Types.this.ModuleTypeRef" id="scala.reflect.internal;Types;PackageTypeRef">PackageTypeRef</a><a href="#scala.reflect.internal;Types;PackageTypeRef" title="Types.this.PackageTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;PackageTypeRef.pre0">pre0</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;PackageTypeRef.sym0">sym0</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;ModuleTypeRef" title="Types.this.ModuleTypeRef">ModuleTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;PackageTypeRef.pre0" title="Types.this.Type">pre0</a>, <a href="#scala.reflect.internal;Types;PackageTypeRef.sym0" title="Types.this.Symbol">sym0</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#scala.Predef.require(a2f0e4a061)" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
    override protected def <a title="(rest: String)String" id="scala.reflect.internal;Types;PackageTypeRef.finishPrefix">finishPrefix</a><span class="delimiter">(</span><a title="String" id="scala.reflect.internal;Types;PackageTypeRef.finishPrefix.rest">rest</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;Type.packagePrefix" title="=&gt; String">packagePrefix</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;PackageTypeRef.finishPrefix.rest" title="String">rest</a>
  <span class="delimiter">}</span>
  class <a title="class RefinementTypeRef extends Types.this.NoArgsTypeRef with Types.this.ClassTypeRef" id="scala.reflect.internal;Types;RefinementTypeRef">RefinementTypeRef</a><a href="#scala.reflect.internal;Types;RefinementTypeRef" title="Types.this.RefinementTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;RefinementTypeRef.pre0">pre0</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;RefinementTypeRef.sym0">sym0</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;NoArgsTypeRef" title="Types.this.NoArgsTypeRef">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RefinementTypeRef.pre0" title="Types.this.Type">pre0</a>, <a href="#scala.reflect.internal;Types;RefinementTypeRef.sym0" title="Types.this.Symbol">sym0</a><span class="delimiter">)</span> with <a href="#scala.reflect.internal;Types;ClassTypeRef" title="Types.this.ClassTypeRef">ClassTypeRef</a> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#scala.Predef.require(a2f0e4a061)" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isRefinementClass" title="=&gt; Boolean">isRefinementClass</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

    <span class="comment">// I think this is okay, but see #1241 (r12414), #2208, and typedTypeConstructor in Typers</span>
    override protected def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;RefinementTypeRef.normalizeImpl">normalizeImpl</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a>
    override protected def <a title="(rest: String)String" id="scala.reflect.internal;Types;RefinementTypeRef.finishPrefix">finishPrefix</a><span class="delimiter">(</span><a title="String" id="scala.reflect.internal;Types;RefinementTypeRef.finishPrefix.rest">rest</a>: <span title="String">String</span><span class="delimiter">)</span> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeRef.thisInfo" title="=&gt; Types.this.Type">thisInfo</a>
  <span class="delimiter">}</span>

  class <a title="class NoArgsTypeRef extends Types.this.TypeRef" id="scala.reflect.internal;Types;NoArgsTypeRef">NoArgsTypeRef</a><a href="#scala.reflect.internal;Types;NoArgsTypeRef" title="Types.this.NoArgsTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;NoArgsTypeRef.pre0">pre0</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;NoArgsTypeRef.sym0">sym0</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;TypeRef" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NoArgsTypeRef.pre0" title="Types.this.Type">pre0</a>, <a href="#scala.reflect.internal;Types;NoArgsTypeRef.sym0" title="Types.this.Symbol">sym0</a>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="comment">// A reference (in a Scala program) to a type that has type parameters, but where the reference</span>
    <span class="comment">// does not include type arguments. Note that it doesn't matter whether the symbol refers</span>
    <span class="comment">// to a java or scala symbol, but it does matter whether it occurs in java or scala code.</span>
    <span class="comment">// TypeRefs w/o type params that occur in java signatures/code are considered raw types, and are</span>
    <span class="comment">// represented as existential types.</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;NoArgsTypeRef.isHigherKinded">isHigherKinded</a> = <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NoArgsTypeRef.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;NoArgsTypeRef.typeParams">typeParams</a>     = if <span class="delimiter">(</span><a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isDefinitionsInitialized" title="=&gt; Boolean">isDefinitionsInitialized</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a> else <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.unsafeTypeParams" title="=&gt; List[Types.this.Symbol]">unsafeTypeParams</a>
    private def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;NoArgsTypeRef.isRaw">isRaw</a>           = <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.isRawIfWithoutArgs" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

    override def <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types;NoArgsTypeRef.instantiateTypeParams">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;NoArgsTypeRef.instantiateTypeParams.formals">formals</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;NoArgsTypeRef.instantiateTypeParams.actuals">actuals</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NoArgsTypeRef.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.sameLength" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NoArgsTypeRef.instantiateTypeParams.formals" title="List[Types.this.Symbol]">formals</a> <a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.intersect" title="(that: scala.collection.GenSeq[Types.this.Symbol])List[Types.this.Symbol]">intersect</a> <a href="#scala.reflect.internal;Types;NoArgsTypeRef.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#scala.reflect.internal;Types;NoArgsTypeRef.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#scala.reflect.internal;Types.copyTypeRef" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types;NoArgsTypeRef.instantiateTypeParams.actuals" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
        <span class="comment">// partial application (needed in infer when bunching type arguments from classes and methods together)</span>
        else
          <a href="#scala.reflect.internal;Types.copyTypeRef" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types;Type.dummyArgs" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NoArgsTypeRef.instantiateTypeParams.formals" title="List[Types.this.Symbol]">formals</a>, <a href="#scala.reflect.internal;Types;NoArgsTypeRef.instantiateTypeParams.actuals" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      else
        super.<a href="#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NoArgsTypeRef.instantiateTypeParams.formals" title="List[Types.this.Symbol]">formals</a>, <a href="#scala.reflect.internal;Types;NoArgsTypeRef.instantiateTypeParams.actuals" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>

    override def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;NoArgsTypeRef.transform">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;NoArgsTypeRef.transform.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      val <a title="Types.this.Type" id="scala.reflect.internal;Types;NoArgsTypeRef.transform.res">res</a> = <a href="#scala.reflect.internal;Types;TypeRef.asSeenFromOwner" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NoArgsTypeRef.transform.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NoArgsTypeRef.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;NoArgsTypeRef.isRaw" title="=&gt; Boolean">isRaw</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;NoArgsTypeRef.transform.res" title="Types.this.Type">res</a>.<a href="#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NoArgsTypeRef.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#scala.reflect.internal;Types;Type.dummyArgs" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>
      else
        <a href="#scala.reflect.internal;Types;NoArgsTypeRef.transform.res" title="Types.this.Type">res</a>
    <span class="delimiter">}</span>

    override def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;NoArgsTypeRef.transformInfo">transformInfo</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;NoArgsTypeRef.transformInfo.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.asSeenFromOwner" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NoArgsTypeRef.transformInfo.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types;Type.dummyArgs" title="=&gt; List[Types.this.Type]">dummyArgs</a><span class="delimiter">)</span>

    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;NoArgsTypeRef.narrow">narrow</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModuleClass" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.singleType" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.sourceModule" title="=&gt; Types.this.Symbol">sourceModule</a><span class="delimiter">)</span>
      else super.<a href="#scala.reflect.internal;Types;Type.narrow" title="=&gt; Types.this.Type">narrow</a>

    override def <a title="=&gt; Types.this.NoArgsTypeRef" id="scala.reflect.internal;Types;NoArgsTypeRef.typeConstructor">typeConstructor</a> = this
    <span class="comment">// eta-expand, subtyping relies on eta-expansion of higher-kinded types</span>

    override protected def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;NoArgsTypeRef.normalizeImpl">normalizeImpl</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NoArgsTypeRef.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeRef.etaExpand" title="=&gt; Types.this.Type">etaExpand</a> else super.<a href="#scala.reflect.internal;Types;TypeRef.normalizeImpl" title="=&gt; Types.this.Type">normalizeImpl</a>
  <span class="delimiter">}</span>

  trait <a title="trait ClassTypeRef extends Types.this.TypeRef" id="scala.reflect.internal;Types;ClassTypeRef">ClassTypeRef</a> extends <a href="#scala.reflect.internal;Types;TypeRef" title="Types.this.TypeRef">TypeRef</a> <span class="delimiter">{</span>
    <span class="comment">// !!! There are scaladoc-created symbols arriving which violate this require.</span>
    <span class="comment">// require(sym.isClass, sym)</span>

    override def <a title="(clazz: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;ClassTypeRef.baseType">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassTypeRef.baseType.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types;ClassTypeRef.baseType.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> this
      else <a href="#scala.reflect.internal;Types;TypeRef.transform" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.baseType" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassTypeRef.baseType.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  trait <a title="trait NonClassTypeRef extends Types.this.TypeRef" id="scala.reflect.internal;Types;NonClassTypeRef">NonClassTypeRef</a> extends <a href="#scala.reflect.internal;Types;TypeRef" title="Types.this.TypeRef">TypeRef</a> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#scala.Predef.require(a2f0e4a061)" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isNonClassType" title="=&gt; Boolean">isNonClassType</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

    <span class="comment">/* Syncnote: These are pure caches for performance; no problem to evaluate these
     * several times. Hence, no need to protected with synchronzied in a mutli-threaded
     * usage scenario.
     */</span>
    private var <a title="Types.this.Type" id="scala.reflect.internal;Types;NonClassTypeRef.relativeInfoCache_=">relativeInfoCache</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = _
    private var <a title="Types.this.Type" id="scala.reflect.internal;Types;NonClassTypeRef.memberInfoCache_=">memberInfoCache</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = _

    private<span class="delimiter">[</span>Types<span class="delimiter">]</span> def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;NonClassTypeRef.relativeInfo">relativeInfo</a> = <span class="delimiter">{</span>
      val <a title="Types.this.Type" id="scala.reflect.internal;Types;NonClassTypeRef.relativeInfo.memberInfo">memberInfo</a> = <a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.memberInfo" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NonClassTypeRef.relativeInfoCache_=" title="=&gt; Types.this.Type">relativeInfoCache</a> <span title="(x$1: Any)Boolean">==</span> null <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NonClassTypeRef.relativeInfo.memberInfo" title="Types.this.Type">memberInfo</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types;NonClassTypeRef.memberInfoCache_=" title="=&gt; Types.this.Type">memberInfoCache</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types;NonClassTypeRef.memberInfoCache_=" title="(x$1: Types.this.Type)Unit">memberInfoCache</a> = <a href="#scala.reflect.internal;Types;NonClassTypeRef.relativeInfo.memberInfo" title="Types.this.Type">memberInfo</a>
        <a href="#scala.reflect.internal;Types;NonClassTypeRef.relativeInfoCache_=" title="(x$1: Types.this.Type)Unit">relativeInfoCache</a> = <a href="#scala.reflect.internal;Types;TypeRef.transformInfo" title="(tp: Types.this.Type)Types.this.Type">transformInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NonClassTypeRef.relativeInfo.memberInfo" title="Types.this.Type">memberInfo</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal;Types;NonClassTypeRef.relativeInfoCache_=" title="=&gt; Types.this.Type">relativeInfoCache</a>
    <span class="delimiter">}</span>

    override def <a title="(clazz: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;NonClassTypeRef.baseType">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;NonClassTypeRef.baseType.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types;NonClassTypeRef.baseType.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span> this else <a href="#scala.reflect.internal;Types.baseTypeOfNonClassTypeRef" title="(tpe: Types.this.NonClassTypeRef, clazz: Types.this.Symbol)Types.this.Type">baseTypeOfNonClassTypeRef</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;NonClassTypeRef.baseType.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  protected def <a title="(tpe: Types.this.NonClassTypeRef, clazz: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types.baseTypeOfNonClassTypeRef">baseTypeOfNonClassTypeRef</a><span class="delimiter">(</span><a title="Types.this.NonClassTypeRef" id="scala.reflect.internal;Types.baseTypeOfNonClassTypeRef.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;NonClassTypeRef" title="Types.this.NonClassTypeRef">NonClassTypeRef</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.baseTypeOfNonClassTypeRef.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = try <span class="delimiter">{</span>
    <a href="#scala.reflect.internal;Types.basetypeRecursions_=" title="(value: Int)Unit">basetypeRecursions</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.basetypeRecursions" title="=&gt; Int">basetypeRecursions</a> <a href="../../Int.scala.html#scala;Int.<(5f58a84eb3)" title="(x: Int)Boolean">&lt;</a> <span title="Int(50)">LogPendingBaseTypesThreshold</span><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types.baseTypeOfNonClassTypeRef.tpe" title="Types.this.NonClassTypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;NonClassTypeRef.relativeInfo" title="=&gt; Types.this.Type">relativeInfo</a>.<a href="#scala.reflect.internal;Types;Type.baseType" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.baseTypeOfNonClassTypeRef.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.pendingBaseTypes" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <a href="../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet.contains" title="(elem: Types.this.Type)Boolean">contains</a> <a href="#scala.reflect.internal;Types.baseTypeOfNonClassTypeRef.tpe" title="Types.this.NonClassTypeRef">tpe</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.baseTypeOfNonClassTypeRef.clazz" title="Types.this.Symbol">clazz</a> <span title="(x$1: Any)Boolean">==</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyClass" title="=&gt; Types.this.ClassSymbol">AnyClass</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.baseTypeOfNonClassTypeRef.clazz" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; Types.this.Type">tpe</a> else <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
    else
      try <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types.pendingBaseTypes" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <a href="../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet.+=(53f2a8289f)" title="(elem: Types.this.Type)scala.collection.mutable.HashSet[Types.this.Type]">+=</a> <a href="#scala.reflect.internal;Types.baseTypeOfNonClassTypeRef.tpe" title="Types.this.NonClassTypeRef">tpe</a>
        <a href="#scala.reflect.internal;Types.baseTypeOfNonClassTypeRef.tpe" title="Types.this.NonClassTypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;NonClassTypeRef.relativeInfo" title="=&gt; Types.this.Type">relativeInfo</a>.<a href="#scala.reflect.internal;Types;Type.baseType" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.baseTypeOfNonClassTypeRef.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> finally <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types.pendingBaseTypes" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">pendingBaseTypes</a> <a href="../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet.-=(53f2a8289f)" title="(elem: Types.this.Type)scala.collection.mutable.HashSet[Types.this.Type]">-=</a> <a href="#scala.reflect.internal;Types.baseTypeOfNonClassTypeRef.tpe" title="Types.this.NonClassTypeRef">tpe</a>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span> finally <span class="delimiter">{</span>
    <a href="#scala.reflect.internal;Types.basetypeRecursions_=" title="(value: Int)Unit">basetypeRecursions</a> <a href="../../Int.scala.html#scala;Int.-(1409840560)" title="(x: Int)Int">-=</a> <span title="Int(1)" class="int">1</span>
  <span class="delimiter">}</span>

  trait <a title="trait AliasTypeRef extends Types.this.TypeRef with Types.this.NonClassTypeRef" id="scala.reflect.internal;Types;AliasTypeRef">AliasTypeRef</a> extends <a href="#scala.reflect.internal;Types;NonClassTypeRef" title="Types.this.NonClassTypeRef">NonClassTypeRef</a> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#scala.Predef.require(a2f0e4a061)" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAliasType" title="=&gt; Boolean">isAliasType</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;AliasTypeRef.dealias">dealias</a>    = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.typeParamsMatchArgs" title="=&gt; Boolean">typeParamsMatchArgs</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;AliasTypeRef.betaReduce" title="=&gt; Types.this.Type">betaReduce</a>.<a href="#scala.reflect.internal;Types;Type.dealias" title="=&gt; Types.this.Type">dealias</a> else super.<a href="#scala.reflect.internal;Types;Type.dealias" title="=&gt; Types.this.Type">dealias</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;AliasTypeRef.narrow">narrow</a>     = <a href="#scala.reflect.internal;Types;TypeRef.normalize" title="=&gt; Types.this.Type">normalize</a>.<a href="#scala.reflect.internal;Types;Type.narrow" title="=&gt; Types.this.Type">narrow</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;AliasTypeRef.thisInfo">thisInfo</a>   = <a href="#scala.reflect.internal;Types;TypeRef.normalize" title="=&gt; Types.this.Type">normalize</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;AliasTypeRef.prefix">prefix</a>     = if <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types;TypeRef.normalize" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeRef.normalize" title="=&gt; Types.this.Type">normalize</a>.<a href="#scala.reflect.internal;Types;Type.prefix" title="=&gt; Types.this.Type">prefix</a> else <a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;AliasTypeRef.termSymbol">termSymbol</a> = if <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types;TypeRef.normalize" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeRef.normalize" title="=&gt; Types.this.Type">normalize</a>.<a href="#scala.reflect.internal;Types;Type.termSymbol" title="=&gt; Types.this.Symbol">termSymbol</a> else super.<a href="#scala.reflect.internal;Types;TypeRef.termSymbol" title="=&gt; Types.this.Symbol">termSymbol</a>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;AliasTypeRef.typeSymbol">typeSymbol</a> = if <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types;TypeRef.normalize" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeRef.normalize" title="=&gt; Types.this.Type">normalize</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> else <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>

    <span class="comment">// beta-reduce, but don't do partial application -- cycles have been checked in typeRef</span>
    override protected def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;AliasTypeRef.normalizeImpl">normalizeImpl</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.typeParamsMatchArgs" title="=&gt; Boolean">typeParamsMatchArgs</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;AliasTypeRef.betaReduce" title="=&gt; Types.this.Type">betaReduce</a>.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> super.<a href="#scala.reflect.internal;Types;TypeRef.normalizeImpl" title="=&gt; Types.this.Type">normalizeImpl</a>
      else <span class="delimiter">{</span>
        <span class="comment">// if we are overriding a type alias in an erroneous way, don't just</span>
        <span class="comment">// return an ErrorType since that will result in useless error msg.</span>
        <span class="comment">// Instead let's try to recover from it and rely on refcheck reporting the correct error,</span>
        <span class="comment">// if that fails fallback to the old behaviour.</span>
        val <a title="Types.this.Symbol" id="scala.reflect.internal;Types;AliasTypeRef.normalizeImpl.overriddenSym">overriddenSym</a> = <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.nextOverriddenSymbol" title="=&gt; Types.this.Symbol">nextOverriddenSymbol</a>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AliasTypeRef.normalizeImpl.overriddenSym" title="Types.this.Symbol">overriddenSym</a> <span title="(x$1: Any)Boolean">!=</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.memberType" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AliasTypeRef.normalizeImpl.overriddenSym" title="Types.this.Symbol">overriddenSym</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a>
        else <a href="#scala.reflect.internal;Types.ErrorType.readResolve" title="Types.this.ErrorType.type">ErrorType</a>
      <span class="delimiter">}</span>

    <span class="comment">// isHKSubType introduces synthetic type params so that</span>
    <span class="comment">// betaReduce can first apply sym.info to typeArgs before calling</span>
    <span class="comment">// asSeenFrom.  asSeenFrom then skips synthetic type params, which</span>
    <span class="comment">// are used to reduce HO subtyping to first-order subtyping, but</span>
    <span class="comment">// which can't be instantiated from the given prefix and class.</span>
    <span class="comment">//</span>
    <span class="comment">// this crashes pos/depmet_implicit_tpbetareduce.scala</span>
    <span class="comment">// appliedType(sym.info, typeArgs).asSeenFrom(pre, sym.owner)</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;AliasTypeRef.betaReduce">betaReduce</a> = <a href="#scala.reflect.internal;Types;TypeRef.transform" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.resultType(9b9cdebb0f)" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>

    <span class="comment">/** SI-3731, SI-8177: when prefix is changed to `newPre`, maintain consistency of prefix and sym
     *  (where the symbol refers to a declaration &quot;embedded&quot; in the prefix).
     *
     *  @returns newSym so that `newPre` binds `sym.name` to `newSym`,
     *                  to remain consistent with `pre` previously binding `sym.name` to `sym`.
     *
     *  `newSym` and `sym` are conceptually the same symbols, but some change to our `prefix`
     *  got them out of whack. (Usually triggered by substitution or `asSeenFrom`.)
     *  The only kind of &quot;binds&quot; we consider is where `prefix` (or its underlying type)
     *  is a refined type that declares `sym` (since the old prefix was discarded,
     *  the old symbol is now stale and we should update it, like in `def rebind`,
     *  except this is not for overriding symbols -- a vertical move -- but a &quot;lateral&quot; change.)
     *
     *  The reason for this hack is that substitution and asSeenFrom clone RefinedTypes and
     *  their members, without updating the potential references to those members -- here, we aim to patch
     *  this up, so that: when changing a TypeRef(pre, sym, args) to a TypeRef(pre', sym', args'), and pre
     *  embeds a symbol sym (pre is a RefinedType(_, Scope(..., sym,...)) or a SingleType with such an
     *  underlying type), make sure that we update sym' to compensate for the change of pre -&gt; pre' (which may
     *  have created a new symbol for the one the original sym referred to)
     */</span>
    override def <a title="(newPre: Types.this.Type)Types.this.Symbol" id="scala.reflect.internal;Types;AliasTypeRef.coevolveSym">coevolveSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;AliasTypeRef.coevolveSym.newPre">newPre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> =
      if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types;AliasTypeRef.coevolveSym.newPre" title="Types.this.Type">newPre</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.embeddedSymbol" title="(tp: Types.this.Type, name: Types.this.Name)Types.this.Symbol">embeddedSymbol</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; AliasTypeRef.this.sym.NameType">name</a><span class="delimiter">)</span> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="Types.this.Symbol" id="scala.reflect.internal;Types;AliasTypeRef.coevolveSym.newSym">newSym</a> = <a href="#scala.reflect.internal;Types.embeddedSymbol" title="(tp: Types.this.Type, name: Types.this.Name)Types.this.Symbol">embeddedSymbol</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AliasTypeRef.coevolveSym.newPre" title="Types.this.Type">newPre</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; AliasTypeRef.this.sym.NameType">name</a><span class="delimiter">)</span>
        <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;co-evolve: &quot;)">co-evolve: $</span><span class="delimiter">{</span><a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a><span class="delimiter">}</span><span title="String(&quot; -&gt; &quot;)"> -&gt; $</span><span class="delimiter">{</span><a href="#scala.reflect.internal;Types;AliasTypeRef.coevolveSym.newPre" title="Types.this.Type">newPre</a><span class="delimiter">}</span><span title="String(&quot;, &quot;)">, $</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a><span title="String(&quot; : &quot;)"> : $</span><span class="delimiter">{</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a><span class="delimiter">}</span><span title="String(&quot; -&gt; &quot;)"> -&gt; $</span><a href="#scala.reflect.internal;Types;AliasTypeRef.coevolveSym.newSym" title="Types.this.Symbol">newSym</a><span title="String(&quot; : &quot;)"> : $</span><span class="delimiter">{</span><a href="#scala.reflect.internal;Types;AliasTypeRef.coevolveSym.newSym" title="Types.this.Symbol">newSym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
        <span class="comment">// To deal with erroneous `preNew`, fallback via `orElse sym`, in case `preNew` does not have a decl named `sym.name`.</span>
        <a href="#scala.reflect.internal;Types;AliasTypeRef.coevolveSym.newSym" title="Types.this.Symbol">newSym</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.orElse" title="(alt: =&gt; Types.this.Symbol)Types.this.Symbol">orElse</a> <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>
      <span class="delimiter">}</span> else <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>

    override def <a title="=&gt; String" id="scala.reflect.internal;Types;AliasTypeRef.kind">kind</a> = <span title="String(&quot;AliasTypeRef&quot;)" class="string">&quot;AliasTypeRef&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">// Return the symbol named `name` that's &quot;embedded&quot; in tp</span>
  <span class="comment">// This is the case if `tp` is a `T{...; type/val $name ; ...}`,</span>
  <span class="comment">// or a singleton type with such an underlying type.</span>
  private def <a title="(tp: Types.this.Type, name: Types.this.Name)Types.this.Symbol" id="scala.reflect.internal;Types.embeddedSymbol">embeddedSymbol</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.embeddedSymbol.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Name" id="scala.reflect.internal;Types.embeddedSymbol.name">name</a>: <a href="Names.scala.html#scala.reflect.internal;Names;Name" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> =
    <span class="comment">// normalize to flatten nested RefinedTypes</span>
    <span class="comment">// don't check whether tp is a RefinedType -- it may be a ThisType of one, for example</span>
    <span class="comment">// TODO: check the resulting symbol is owned by the refinement class? likely an invariant...</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.embeddedSymbol.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isRefinementClass" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.embeddedSymbol.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a>.<a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.lookup" title="(name: Types.this.Name)Types.this.Symbol">lookup</a> <a href="#scala.reflect.internal;Types.embeddedSymbol.name" title="Types.this.Name">name</a>
    else <span class="delimiter">{</span>
      <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;no embedded symbol &quot;)">no embedded symbol $</span><a href="#scala.reflect.internal;Types.embeddedSymbol.name" title="Types.this.Name">name</a><span title="String(&quot; found in &quot;)"> found in $</span><span class="delimiter">{</span><a href="../api/Printers.scala.html#scala.reflect.api;Printers.showRaw(6f64b10ccf)" title="(any: Any, printTypes: Types.this.BooleanFlag, printIds: Types.this.BooleanFlag, printOwners: Types.this.BooleanFlag, printKinds: Types.this.BooleanFlag, printMirrors: Types.this.BooleanFlag, printPositions: Types.this.BooleanFlag)String">showRaw</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.embeddedSymbol.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot; --&gt; &quot;)"> --&gt; $</span><span class="delimiter">{</span><a href="#scala.reflect.internal;Types.embeddedSymbol.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a>.<a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.lookup" title="(name: Types.this.Name)Types.this.Symbol">lookup</a> <a href="#scala.reflect.internal;Types.embeddedSymbol.name" title="Types.this.Name">name</a><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
      <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a>
    <span class="delimiter">}</span>


  trait <a title="trait AbstractTypeRef extends Types.this.TypeRef with Types.this.NonClassTypeRef" id="scala.reflect.internal;Types;AbstractTypeRef">AbstractTypeRef</a> extends <a href="#scala.reflect.internal;Types;NonClassTypeRef" title="Types.this.NonClassTypeRef">NonClassTypeRef</a> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#scala.Predef.require(a2f0e4a061)" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAbstractType" title="=&gt; Boolean">isAbstractType</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

    <span class="comment">/** Syncnote: Pure performance caches; no need to synchronize in multi-threaded environment
     */</span>
    private var <a title="Types.this.Type" id="scala.reflect.internal;Types;AbstractTypeRef.symInfoCache_=">symInfoCache</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = _
    private var <a title="Types.this.Type" id="scala.reflect.internal;Types;AbstractTypeRef.thisInfoCache_=">thisInfoCache</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = _

    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;AbstractTypeRef.thisInfo">thisInfo</a>   = <span class="delimiter">{</span>
      val <a title="Types.this.Type" id="scala.reflect.internal;Types;AbstractTypeRef.thisInfo.symInfo">symInfo</a> = <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AbstractTypeRef.thisInfoCache_=" title="=&gt; Types.this.Type">thisInfoCache</a> <span title="(x$1: Any)Boolean">==</span> null <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AbstractTypeRef.thisInfo.symInfo" title="Types.this.Type">symInfo</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types;AbstractTypeRef.symInfoCache_=" title="=&gt; Types.this.Type">symInfoCache</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types;AbstractTypeRef.symInfoCache_=" title="(x$1: Types.this.Type)Unit">symInfoCache</a> = <a href="#scala.reflect.internal;Types;AbstractTypeRef.thisInfo.symInfo" title="Types.this.Type">symInfo</a>
        <a href="#scala.reflect.internal;Types;AbstractTypeRef.thisInfoCache_=" title="(x$1: Types.this.Type)Unit">thisInfoCache</a> = <a href="#scala.reflect.internal;Types;TypeRef.transformInfo" title="(tp: Types.this.Type)Types.this.Type">transformInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AbstractTypeRef.thisInfo.symInfo" title="Types.this.Type">symInfo</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
          <span class="comment">// If a subtyping cycle is not detected here, we'll likely enter an infinite</span>
          <span class="comment">// loop before a sensible error can be issued.  SI-5093 is one example.</span>
          case <a title="Types.this.SubType" id="scala.reflect.internal;Types;AbstractTypeRef.thisInfo.x">x</a>: <a href="#scala.reflect.internal;Types;SubType" title="Types.this.SubType">SubType</a> if <a href="#scala.reflect.internal;Types;AbstractTypeRef.thisInfo.x" title="Types.this.SubType">x</a>.<a href="#scala.reflect.internal;Types;SubType.supertype" title="=&gt; Types.this.Type">supertype</a> <span title="(x$1: AnyRef)Boolean">eq</span> this =&gt;
            throw new <a href="#scala.reflect.internal;Types.RecoverableCyclicReference.readResolve" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
          case <a title="Types.this.Type" id="scala.reflect.internal;Types;AbstractTypeRef.thisInfo.tp">tp</a> =&gt; <a href="#scala.reflect.internal;Types;AbstractTypeRef.thisInfo.tp" title="Types.this.Type">tp</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal;Types;AbstractTypeRef.thisInfoCache_=" title="=&gt; Types.this.Type">thisInfoCache</a>
    <span class="delimiter">}</span>
    override def <a title="=&gt; Types.this.TypeBounds" id="scala.reflect.internal;Types;AbstractTypeRef.bounds">bounds</a>   = <a href="#scala.reflect.internal;Types;AbstractTypeRef.thisInfo" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#scala.reflect.internal;Types;Type.bounds" title="=&gt; Types.this.TypeBounds">bounds</a>
    override protected<span class="delimiter">[</span>Types<span class="delimiter">]</span> def <a title="=&gt; Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;AbstractTypeRef.baseTypeSeqImpl">baseTypeSeqImpl</a>: <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#scala.reflect.internal;Types;TypeRef.transform" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AbstractTypeRef.bounds" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.prepend" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">prepend</a> this
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;AbstractTypeRef.kind">kind</a> = <span title="String(&quot;AbstractTypeRef&quot;)" class="string">&quot;AbstractTypeRef&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class for named types of the form
   *    `&lt;prefix&gt;.&lt;sym.name&gt;[args]`
   *  Cannot be created directly; one should always use `typeRef`
   *  for creation. (@M: Otherwise hashing breaks)
   *
   * @M: a higher-kinded type is represented as a TypeRef with sym.typeParams.nonEmpty, but args.isEmpty
   */</span>
  abstract case class <a href="#scala.reflect.internal;Types;TypeRef.productElement.x$1" title="class TypeRef extends Types.this.UniqueType with Types.this.TypeRefApi with Product with Serializable" id="scala.reflect.internal;Types;TypeRef">TypeRef</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeRef.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;TypeRef.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;TypeRef.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;UniqueType" title="Types.this.UniqueType">UniqueType</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;TypeRefApi" title="Types.this.TypeRefApi">TypeRefApi</a> <span class="delimiter">{</span>
    private var <a title="scala.reflect.internal.util.ThreeValues.ThreeValue" id="scala.reflect.internal;Types;TypeRef.trivial_=">trivial</a>: <a href="../../Byte.scala.html#scala;Byte" title="scala.reflect.internal.util.ThreeValues.ThreeValue">ThreeValue</a> = <span title="Byte(0)">UNKNOWN</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeRef.isTrivial">isTrivial</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.trivial_=" title="=&gt; scala.reflect.internal.util.ThreeValues.ThreeValue">trivial</a> <a href="../../Byte.scala.html#scala;Byte.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(0)">UNKNOWN</span><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;TypeRef.trivial_=" title="(x$1: scala.reflect.internal.util.ThreeValues.ThreeValue)Unit">trivial</a> = <a href="util/ThreeValues.scala.html#scala.reflect.internal.util.ThreeValues.fromBoolean" title="(b: Boolean)scala.reflect.internal.util.ThreeValues.ThreeValue">fromBoolean</a><span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isTypeParameter" title="=&gt; Boolean">isTypeParameter</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.isTrivial" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.areTrivialTypes" title="(tps: List[Types.this.Type])Boolean">areTrivialTypes</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="util/ThreeValues.scala.html#scala.reflect.internal.util.ThreeValues.toBoolean" title="(x: scala.reflect.internal.util.ThreeValues.ThreeValue)Boolean">toBoolean</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.trivial_=" title="=&gt; scala.reflect.internal.util.ThreeValues.ThreeValue">trivial</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    private<span class="delimiter">[</span>scala<span class="delimiter">]</span> def <a title="()Unit" id="scala.reflect.internal;Types;TypeRef.invalidateCaches">invalidateCaches</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <span class="delimiter">{</span>
      <a href="#scala.reflect.internal;Types;TypeRef.parentsPeriod_=" title="(x$1: Int)Unit">parentsPeriod</a> = <span title="Int(0)">NoPeriod</span>
      <a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeqPeriod_=" title="(x$1: Int)Unit">baseTypeSeqPeriod</a> = <span title="Int(0)">NoPeriod</span>
    <span class="delimiter">}</span>
    private<span class="delimiter">[</span>reflect<span class="delimiter">]</span> var <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;TypeRef.parentsCache_=">parentsCache</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>      = _
    private<span class="delimiter">[</span>reflect<span class="delimiter">]</span> var <a title="Int" id="scala.reflect.internal;Types;TypeRef.parentsPeriod_=">parentsPeriod</a>                 = <span title="Int(0)">NoPeriod</span>
    private<span class="delimiter">[</span>reflect<span class="delimiter">]</span> var <a title="Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;TypeRef.baseTypeSeqCache_=">baseTypeSeqCache</a>: <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = _
    private<span class="delimiter">[</span>reflect<span class="delimiter">]</span> var <a title="Int" id="scala.reflect.internal;Types;TypeRef.baseTypeSeqPeriod_=">baseTypeSeqPeriod</a>             = <span title="Int(0)">NoPeriod</span>
    private var <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeRef.normalized_=">normalized</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>                       = _

    <span class="comment">//OPT specialize hashCode</span>
    override final def <a title="=&gt; Int" id="scala.reflect.internal;Types;TypeRef.computeHashCode">computeHashCode</a> = <span class="delimiter">{</span>
      import scala.util.hashing.<a href="../../util/hashing/MurmurHash3.scala.html#scala.util.hashing.MurmurHash3" title="scala.util.hashing.MurmurHash3.type">MurmurHash3</a>._
      val hasArgs = <a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a> <a title="Boolean" id="scala.reflect.internal;Types;TypeRef.computeHashCode.hasArgs">ne</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
      var <a title="Int" id="scala.reflect.internal;Types;TypeRef.computeHashCode.h">h</a> = <span title="Int(-889275714)">productSeed</span>
      <a href="#scala.reflect.internal;Types;TypeRef.computeHashCode.h" title="Int">h</a> = <a href="../../util/hashing/MurmurHash3.scala.html#scala.util.hashing;MurmurHash3.mix" title="(hash: Int, data: Int)Int">mix</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.computeHashCode.h" title="Int">h</a>, <a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>.<span title="()Int">hashCode</span><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types;TypeRef.computeHashCode.h" title="Int">h</a> = <a href="../../util/hashing/MurmurHash3.scala.html#scala.util.hashing;MurmurHash3.mix" title="(hash: Int, data: Int)Int">mix</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.computeHashCode.h" title="Int">h</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<span title="()Int">hashCode</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.computeHashCode.hasArgs" title="Boolean">hasArgs</a><span class="delimiter">)</span>
        <a href="../../util/hashing/MurmurHash3.scala.html#scala.util.hashing;MurmurHash3.finalizeHash" title="(hash: Int, length: Int)Int">finalizeHash</a><span class="delimiter">(</span><a href="../../util/hashing/MurmurHash3.scala.html#scala.util.hashing;MurmurHash3.mix" title="(hash: Int, data: Int)Int">mix</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.computeHashCode.h" title="Int">h</a>, <a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../collection/LinearSeqLike.scala.html#scala.collection;LinearSeqLike.hashCode" title="()Int">hashCode</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="Int(3)" class="int">3</span><span class="delimiter">)</span>
      else
        <a href="../../util/hashing/MurmurHash3.scala.html#scala.util.hashing;MurmurHash3.finalizeHash" title="(hash: Int, length: Int)Int">finalizeHash</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.computeHashCode.h" title="Int">h</a>, <span title="Int(2)" class="int">2</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// @M: propagate actual type params (args) to `tp`, by replacing</span>
    <span class="comment">// formal type parameters with actual ones. If tp is higher kinded,</span>
    <span class="comment">// the &quot;actual&quot; type arguments are types that simply reference the</span>
    <span class="comment">// corresponding type parameters (unbound type variables)</span>
    def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;TypeRef.transform">transform</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeRef.transform.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">// eta-expand, subtyping relies on eta-expansion of higher-kinded types</span>
    protected def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;TypeRef.normalizeImpl">normalizeImpl</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeRef.etaExpand" title="=&gt; Types.this.Type">etaExpand</a> else super.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a>

    <span class="comment">// TODO: test case that is compiled in a specific order and in different runs</span>
    final override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;TypeRef.normalize">normalize</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="comment">// arises when argument-dependent types are approximated (see def depoly in implicits)</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types.WildcardType.readResolve" title="Types.this.WildcardType.type">WildcardType</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.WildcardType.readResolve" title="Types.this.WildcardType.type">WildcardType</a>
      else if <span class="delimiter">(</span><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeRef.normalizeImpl" title="=&gt; Types.this.Type">normalizeImpl</a>
      else <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.normalized_=" title="=&gt; Types.this.Type">normalized</a> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span>
          <a href="#scala.reflect.internal;Types;TypeRef.normalized_=" title="(x$1: Types.this.Type)Unit">normalized</a> = <a href="#scala.reflect.internal;Types;TypeRef.normalizeImpl" title="=&gt; Types.this.Type">normalizeImpl</a>
        <a href="#scala.reflect.internal;Types;TypeRef.normalized_=" title="=&gt; Types.this.Type">normalized</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeRef.isGround">isGround</a> = <span class="delimiter">(</span>
         <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a>
      <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.isGround" title="=&gt; Boolean">isGround</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.isGround.$anonfun.x$28" title="Types.this.Type">_</a>.<a href="#scala.reflect.internal;Types;Type.isGround" title="=&gt; Boolean">isGround</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>

    final override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;TypeRef.etaExpand">etaExpand</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <span class="comment">// must initialise symbol, see test/files/pos/ticket0137.scala</span>
      val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;TypeRef.etaExpand.tpars">tpars</a> = <a href="#scala.reflect.internal;Types;TypeRef.initializedTypeParams" title="=&gt; List[Types.this.Symbol]">initializedTypeParams</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.etaExpand.tpars" title="List[Types.this.Symbol]">tpars</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> this
      else <a href="#scala.reflect.internal;Types.typeFunAnon" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFunAnon</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.etaExpand.tpars" title="List[Types.this.Symbol]">tpars</a>, <a href="#scala.reflect.internal;Types.copyTypeRef" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types;TypeRef.etaExpand.tpars" title="List[Types.this.Symbol]">tpars</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.etaExpand.$anonfun.x$29" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpeHK" title="=&gt; Types.this.Type">tpeHK</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// todo: also beta-reduce?</span>
    <span class="delimiter">}</span>

    <span class="comment">// only need to rebind type aliases, as typeRef already handles abstract types</span>
    <span class="comment">// (they are allowed to be rebound more liberally)</span>
    def <a title="(pre1: Types.this.Type)Types.this.Symbol" id="scala.reflect.internal;Types;TypeRef.coevolveSym">coevolveSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeRef.coevolveSym.pre1">pre1</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>

    <span class="comment">//@M! use appliedType on the polytype that represents the bounds (or if aliastype, the rhs)</span>
    def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;TypeRef.transformInfo">transformInfo</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeRef.transformInfo.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.asSeenFromOwner" title="(tp: Types.this.Type)Types.this.Type">asSeenFromOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.transformInfo.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span>

    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;TypeRef.thisInfo">thisInfo</a>                  = <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>
    def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;TypeRef.initializedTypeParams">initializedTypeParams</a>     = <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeRef.typeParamsMatchArgs">typeParamsMatchArgs</a>       = <a href="#scala.reflect.internal;Types.sameLength" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.initializedTypeParams" title="=&gt; List[Types.this.Symbol]">initializedTypeParams</a>, <a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a><span class="delimiter">)</span>
    def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;TypeRef.asSeenFromOwner">asSeenFromOwner</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeRef.asSeenFromOwner.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;TypeRef.asSeenFromOwner.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.asSeenFrom" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>

    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;TypeRef.baseClasses">baseClasses</a>      = <a href="#scala.reflect.internal;Types;TypeRef.thisInfo" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#scala.reflect.internal;Types;Type.baseClasses" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    override def <a title="=&gt; scala.reflect.internal.Depth" id="scala.reflect.internal;Types;TypeRef.baseTypeSeqDepth">baseTypeSeqDepth</a> = <a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.maxDepth" title="=&gt; scala.reflect.internal.Depth">maxDepth</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;TypeRef.prefix">prefix</a>           = <a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;TypeRef.termSymbol">termSymbol</a>       = super.<a href="#scala.reflect.internal;Types;Type.termSymbol" title="=&gt; Types.this.Symbol">termSymbol</a>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;TypeRef.termSymbolDirect">termSymbolDirect</a> = super.<a href="#scala.reflect.internal;Types;Type.termSymbol" title="=&gt; Types.this.Symbol">termSymbol</a>
    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;TypeRef.typeArgs">typeArgs</a>         = <a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;TypeRef.typeOfThis">typeOfThis</a>       = <a href="#scala.reflect.internal;Types;TypeRef.transform" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeOfThis" title="=&gt; Types.this.Type">typeOfThis</a><span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;TypeRef.typeSymbol">typeSymbol</a>       = <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;TypeRef.typeSymbolDirect">typeSymbolDirect</a> = <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>

    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;TypeRef.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
      val <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;TypeRef.parents.cache">cache</a> = <a href="#scala.reflect.internal;Types;TypeRef.parentsCache_=" title="=&gt; List[Types.this.Type]">parentsCache</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.parentsPeriod_=" title="=&gt; Int">parentsPeriod</a> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;TypeRef.parents.cache" title="List[Types.this.Type]">cache</a> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeRef.parents.cache" title="List[Types.this.Type]">cache</a>
      else <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types.defineParentsOfTypeRef" title="(tpe: Types.this.TypeRef)Unit">defineParentsOfTypeRef</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;TypeRef.parentsCache_=" title="=&gt; List[Types.this.Type]">parentsCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    override def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types;TypeRef.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> = <span class="delimiter">{</span>
      <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a> match <span class="delimiter">{</span>
        case TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;TypeRef.decls.sym1">sym1</a>, _<span class="delimiter">)</span> =&gt;
          <a href="../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.decls.sym1" title="Types.this.Symbol">sym1</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>, this<span class="delimiter">)</span> <span class="comment">// @MAT was != typeSymbol</span>
        case _ =&gt;
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal;Types;TypeRef.thisInfo" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a>
    <span class="delimiter">}</span>
    protected<span class="delimiter">[</span>Types<span class="delimiter">]</span> def <a title="=&gt; Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;TypeRef.baseTypeSeqImpl">baseTypeSeqImpl</a>: <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeqImpl.$anonfun.x$30" title="Types.this.Type">_</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbolDirect" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAbstractType" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="comment">// SI-8046 base type sequence might have more elements in a subclass, we can't map it element wise.</span>
        <a href="#scala.reflect.internal;Types;TypeRef.transform" title="(tp: Types.this.Type)Types.this.Type">transform</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
      else
        <span class="comment">// Optimization: no abstract types, we can compute the BTS of this TypeRef as an element-wise map</span>
        <span class="comment">//               of the BTS of the referenced symbol.</span>
        <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">map</a> <a href="#scala.reflect.internal;Types;TypeRef.transform" title="(tp: Types.this.Type)Types.this.Type">transform</a>

    override def <a title="=&gt; Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;TypeRef.baseTypeSeq">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
      val <a title="Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;TypeRef.baseTypeSeq.cache">cache</a> = <a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeqCache_=" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeqPeriod_=" title="=&gt; Int">baseTypeSeqPeriod</a> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeq.cache" title="Types.this.BaseTypeSeq">cache</a> <span title="(x$1: Any)Boolean">!=</span> null <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeq.cache" title="Types.this.BaseTypeSeq">cache</a> <span title="(x$1: Any)Boolean">!=</span> <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs.undetBaseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeq.cache" title="Types.this.BaseTypeSeq">cache</a>
      else <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef" title="(tpe: Types.this.TypeRef)Unit">defineBaseTypeSeqOfTypeRef</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeqCache_=" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: Any)Boolean">==</span> <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs.undetBaseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
          throw new <a href="#scala.reflect.internal;Types.RecoverableCyclicReference.readResolve" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>

        <a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeqCache_=" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="comment">// ensure that symbol is not a local copy with a name coincidence</span>
    private def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeRef.needsPreString">needsPreString</a> = <span class="delimiter">(</span>
         <a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">debug</a>
      <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="../../collection/GenSetLike.scala.html#scala.collection;GenSetLike.apply" title="(elem: String)Boolean">shorthands</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.fullName(3bf7c90be7)" title="=&gt; String">fullName</a><span class="delimiter">)</span>
      <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.ownersIterator" title="=&gt; Iterator[Types.this.Symbol]">ownersIterator</a> <a href="../../collection/Iterator.scala.html#scala.collection;Iterator.exists" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;TypeRef.needsPreString.$anonfun.s">s</a> =&gt; <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;TypeRef.needsPreString.$anonfun.s" title="Types.this.Symbol">s</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isClass" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    private def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeRef.preString">preString</a>  = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.needsPreString" title="=&gt; Boolean">needsPreString</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeRef.pre" title="=&gt; Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.prefixString" title="=&gt; String">prefixString</a> else <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    private def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeRef.argsString">argsString</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> else <a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>

    private def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types;TypeRef.refinementDecls">refinementDecls</a> = <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.fullyInitializeScope" title="(scope: Types.this.Scope)Types.this.Scope">fullyInitializeScope</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.decls" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span> <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.filter" title="(p: Types.this.Symbol =&gt; Boolean)Types.this.Scope">filter</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;TypeRef.refinementDecls.$anonfun.sym">sym</a> =&gt; <a href="#scala.reflect.internal;Types;TypeRef.refinementDecls.$anonfun.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPossibleInRefinement" title="=&gt; Boolean">isPossibleInRefinement</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;TypeRef.refinementDecls.$anonfun.sym" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#scala.reflect.internal;HasFlags.isPublic" title="=&gt; Boolean">isPublic</a><span class="delimiter">)</span>
    private def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeRef.refinementString">refinementString</a> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isStructuralRefinement" title="=&gt; Boolean">isStructuralRefinement</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;TypeRef.refinementDecls" title="=&gt; Types.this.Scope">refinementDecls</a> <a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.map" title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[Types.this.Symbol],String,Iterable[String]])Iterable[String]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.refinementString.$anonfun.x$31" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.defString" title="=&gt; String">defString</a><span class="delimiter">)</span> <a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;{&quot;)" class="string">&quot;{&quot;</span>, <span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="String(&quot;}&quot;)" class="string">&quot;}&quot;</span><span class="delimiter">)</span>
      else <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="delimiter">)</span>
    protected def <a title="(rest: String)String" id="scala.reflect.internal;Types;TypeRef.finishPrefix">finishPrefix</a><span class="delimiter">(</span><a title="String" id="scala.reflect.internal;Types;TypeRef.finishPrefix.rest">rest</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isInitialized" title="=&gt; Boolean">isInitialized</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAnonymousClass" title="=&gt; Boolean">isAnonymousClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
        <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.parentsString" title="(parents: List[Types.this.Type])String">parentsString</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.thisInfo" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeRef.refinementString" title="=&gt; String">refinementString</a>
      else <a href="#scala.reflect.internal;Types;TypeRef.finishPrefix.rest" title="String">rest</a>
    <span class="delimiter">)</span>
    private def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeRef.noArgsString">noArgsString</a> = <a href="#scala.reflect.internal;Types;TypeRef.finishPrefix" title="(rest: String)String">finishPrefix</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.preString" title="=&gt; String">preString</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.nameString" title="=&gt; String">nameString</a><span class="delimiter">)</span>
    private def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeRef.tupleTypeString">tupleTypeString</a>: <span title="String">String</span> = <a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a> match <span class="delimiter">{</span>
      case <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>        =&gt; <a href="#scala.reflect.internal;Types;TypeRef.noArgsString" title="=&gt; String">noArgsString</a>
      case <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeRef.tupleTypeString.arg">arg</a> :: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> =&gt; <a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;(&quot;)">($</span><a href="#scala.reflect.internal;Types;TypeRef.tupleTypeString.arg" title="Types.this.Type">arg</a><span title="String(&quot;,)&quot;)" class="string">,)&quot;</span>
      case _          =&gt; <a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    private def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeRef.customToString">customToString</a> = <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a> match <span class="delimiter">{</span>
      case <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.RepeatedParamClass" title="=&gt; Types.this.ClassSymbol">RepeatedParamClass</a> | <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.JavaRepeatedParamClass" title="=&gt; Types.this.ClassSymbol">JavaRepeatedParamClass</a> =&gt; <a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../Predef.scala.html#scala.Predef.any2stringadd(6b32434ac5)" title="(self: Types.this.Type)any2stringadd[Types.this.Type]">head</a> <a href="../../Predef.scala.html#scala.Predef;any2stringadd.+" title="(other: String)String">+</a> <span title="String(&quot;*&quot;)" class="string">&quot;*&quot;</span>
      case <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ByNameParamClass" title="=&gt; Types.this.ClassSymbol">ByNameParamClass</a>   =&gt; <span title="String(&quot;=&gt; &quot;)" class="string">&quot;=&gt; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeRef.args" title="=&gt; List[Types.this.Type]">args</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Type">head</a>
      case _                  =&gt;
        if <span class="delimiter">(</span><a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isFunctionTypeDirect" title="(tp: Types.this.Type)Boolean">isFunctionTypeDirect</a><span class="delimiter">(</span>this<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="comment">// Aesthetics: printing Function1 as T =&gt; R rather than (T) =&gt; R</span>
          <span class="comment">// ...but only if it's not a tuple, so ((T1, T2)) =&gt; R is distinguishable</span>
          <span class="comment">// from (T1, T2) =&gt; R.</span>
          <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.unspecializedTypeArgs" title="(tp: Types.this.Type)List[Types.this.Type]">unspecializedTypeArgs</a><span class="delimiter">(</span>this<span class="delimiter">)</span> match <span class="delimiter">{</span>
            <span class="comment">// See neg/t588 for an example which arrives here - printing</span>
            <span class="comment">// the type of a Function1 after erasure.</span>
            case <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> =&gt; <a href="#scala.reflect.internal;Types;TypeRef.noArgsString" title="=&gt; String">noArgsString</a>
            case <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeRef.customToString.in">in</a> :: <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeRef.customToString.out">out</a> :: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> if <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isTupleTypeDirect" title="(tp: Types.this.Type)Boolean">isTupleTypeDirect</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.customToString.in" title="Types.this.Type">in</a><span class="delimiter">)</span> =&gt;
              <span class="comment">// A =&gt; B =&gt; C should be (A =&gt; B) =&gt; C or A =&gt; (B =&gt; C).</span>
              <span class="comment">// Also if A is byname, then we want (=&gt; A) =&gt; B because =&gt; is right associative and =&gt; A =&gt; B</span>
              <span class="comment">// would mean =&gt; (A =&gt; B) which is a different type</span>
              val <a title="String" id="scala.reflect.internal;Types;TypeRef.customToString.in_s">in_s</a>  = if <span class="delimiter">(</span><a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isFunctionTypeDirect" title="(tp: Types.this.Type)Boolean">isFunctionTypeDirect</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.customToString.in" title="Types.this.Type">in</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isByNameParamType" title="(tp: Types.this.Type)Boolean">isByNameParamType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.customToString.in" title="Types.this.Type">in</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeRef.customToString.in" title="Types.this.Type">in</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> else <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeRef.customToString.in" title="Types.this.Type">in</a>
              val <a title="String" id="scala.reflect.internal;Types;TypeRef.customToString.out_s">out_s</a> = if <span class="delimiter">(</span><a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isFunctionTypeDirect" title="(tp: Types.this.Type)Boolean">isFunctionTypeDirect</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.customToString.out" title="Types.this.Type">out</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeRef.customToString.out" title="Types.this.Type">out</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> else <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeRef.customToString.out" title="Types.this.Type">out</a>
              <a href="#scala.reflect.internal;Types;TypeRef.customToString.in_s" title="String">in_s</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; =&gt; &quot;)" class="string">&quot; =&gt; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeRef.customToString.out_s" title="String">out_s</a>
            case <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;TypeRef.customToString.xs">xs</a> =&gt;
              <a href="#scala.reflect.internal;Types;TypeRef.customToString.xs" title="List[Types.this.Type]">xs</a>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.init" title="=&gt; List[Types.this.Type]">init</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; =&gt; &quot;)" class="string">&quot; =&gt; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeRef.customToString.xs" title="List[Types.this.Type]">xs</a>.<a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.last" title="=&gt; Types.this.Type">last</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        else if <span class="delimiter">(</span><a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isTupleTypeDirect" title="(tp: Types.this.Type)Boolean">isTupleTypeDirect</a><span class="delimiter">(</span>this<span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#scala.reflect.internal;Types;TypeRef.tupleTypeString" title="=&gt; String">tupleTypeString</a>
        else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAliasType" title="=&gt; Boolean">isAliasType</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;Type.prefixChain" title="=&gt; List[Types.this.Type]">prefixChain</a>.<a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.customToString.$anonfun.x$32" title="Types.this.Type">_</a>.<a href="#scala.reflect.internal;Types;Type.termSymbol" title="=&gt; Types.this.Symbol">termSymbol</a>.<a href="HasFlags.scala.html#scala.reflect.internal;HasFlags.isSynthetic" title="=&gt; Boolean">isSynthetic</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span>this <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types;Type.dealias" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;Type.dealias" title="=&gt; Types.this.Type">dealias</a>
        else
          <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="delimiter">}</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeRef.safeToString">safeToString</a> = <span class="delimiter">{</span>
      val <a title="String" id="scala.reflect.internal;Types;TypeRef.safeToString.custom">custom</a> = if <span class="delimiter">(</span><a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">debug</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> else <a href="#scala.reflect.internal;Types;TypeRef.customToString" title="=&gt; String">customToString</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.safeToString.custom" title="String">custom</a> <span title="(x$1: Any)Boolean">!=</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeRef.safeToString.custom" title="String">custom</a>
      else <a href="#scala.reflect.internal;Types;TypeRef.finishPrefix" title="(rest: String)String">finishPrefix</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.preString" title="=&gt; String">preString</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.nameString" title="=&gt; String">nameString</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeRef.argsString" title="=&gt; String">argsString</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeRef.prefixString">prefixString</a> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">debug</a><span class="delimiter">)</span>
        super.<a href="#scala.reflect.internal;Types;Type.prefixString" title="=&gt; String">prefixString</a>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isOmittablePrefix" title="=&gt; Boolean">isOmittablePrefix</a><span class="delimiter">)</span>
        <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageObjectOrClass" title="=&gt; Boolean">isPackageObjectOrClass</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.skipPackageObject" title="=&gt; Types.this.Symbol">skipPackageObject</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.fullName(3bf7c90be7)" title="=&gt; String">fullName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;Type.isStable" title="=&gt; Boolean">isStable</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="StdNames.scala.html#scala.reflect.internal;StdNames.nme" title="Types.this.nme.type">nme</a>.<a href="StdNames.scala.html#scala.reflect.internal;StdNames;TermNames.isSingletonName" title="(name: Types.this.Name)Boolean">isSingletonName</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; TypeRef.this.sym.NameType">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="StdNames.scala.html#scala.reflect.internal;StdNames.tpnme" title="Types.this.tpnme.type">tpnme</a>.<a href="StdNames.scala.html#scala.reflect.internal;StdNames;TypeNames.dropSingletonName" title="(name: Types.this.Name)Types.this.TypeName">dropSingletonName</a><a href="../../Predef.scala.html#scala.Predef.any2stringadd(6b32434ac5)" title="(self: Types.this.TypeName)any2stringadd[Types.this.TypeName]" class="delimiter">(</a><a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; TypeRef.this.sym.NameType">name</a><span class="delimiter">)</span> <a href="../../Predef.scala.html#scala.Predef;any2stringadd.+" title="(other: String)String">+</a> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span>
      else
        super.<a href="#scala.reflect.internal;Types;Type.prefixString" title="=&gt; String">prefixString</a>
    <span class="delimiter">)</span>
    <span class="comment">// Suppressing case class copy method which risks subverting our single point of creation.</span>
    private def <a title="=&gt; Null" id="scala.reflect.internal;Types;TypeRef.copy">copy</a> = null
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeRef.kind">kind</a> = <span title="String(&quot;TypeRef&quot;)" class="string">&quot;TypeRef&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">// No longer defined as anonymous classes in `object TypeRef` to avoid an unnecessary outer pointer.</span>
  private final class <a title="class AliasArgsTypeRef extends Types.this.ArgsTypeRef with Types.this.AliasTypeRef" id="scala.reflect.internal;Types;AliasArgsTypeRef">AliasArgsTypeRef</a><a href="#scala.reflect.internal;Types;AliasArgsTypeRef" title="Types.this.AliasArgsTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;AliasArgsTypeRef.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;AliasArgsTypeRef.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;AliasArgsTypeRef.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;ArgsTypeRef" title="Types.this.ArgsTypeRef">ArgsTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AliasArgsTypeRef.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;AliasArgsTypeRef.sym" title="Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types;AliasArgsTypeRef.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> with <a href="#scala.reflect.internal;Types;AliasTypeRef" title="Types.this.AliasTypeRef">AliasTypeRef</a>
  private final class <a title="class AbstractArgsTypeRef extends Types.this.ArgsTypeRef with Types.this.AbstractTypeRef" id="scala.reflect.internal;Types;AbstractArgsTypeRef">AbstractArgsTypeRef</a><a href="#scala.reflect.internal;Types;AbstractArgsTypeRef" title="Types.this.AbstractArgsTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;AbstractArgsTypeRef.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;AbstractArgsTypeRef.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;AbstractArgsTypeRef.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;ArgsTypeRef" title="Types.this.ArgsTypeRef">ArgsTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AbstractArgsTypeRef.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;AbstractArgsTypeRef.sym" title="Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types;AbstractArgsTypeRef.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> with <a href="#scala.reflect.internal;Types;AbstractTypeRef" title="Types.this.AbstractTypeRef">AbstractTypeRef</a>
  private final class <a title="class ClassArgsTypeRef extends Types.this.ArgsTypeRef with Types.this.ClassTypeRef" id="scala.reflect.internal;Types;ClassArgsTypeRef">ClassArgsTypeRef</a><a href="#scala.reflect.internal;Types;ClassArgsTypeRef" title="Types.this.ClassArgsTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;ClassArgsTypeRef.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassArgsTypeRef.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;ClassArgsTypeRef.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;ArgsTypeRef" title="Types.this.ArgsTypeRef">ArgsTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassArgsTypeRef.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;ClassArgsTypeRef.sym" title="Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types;ClassArgsTypeRef.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> with <a href="#scala.reflect.internal;Types;ClassTypeRef" title="Types.this.ClassTypeRef">ClassTypeRef</a>
  private final class <a title="class AliasNoArgsTypeRef extends Types.this.NoArgsTypeRef with Types.this.AliasTypeRef" id="scala.reflect.internal;Types;AliasNoArgsTypeRef">AliasNoArgsTypeRef</a><a href="#scala.reflect.internal;Types;AliasNoArgsTypeRef" title="Types.this.AliasNoArgsTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;AliasNoArgsTypeRef.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;AliasNoArgsTypeRef.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;NoArgsTypeRef" title="Types.this.NoArgsTypeRef">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AliasNoArgsTypeRef.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;AliasNoArgsTypeRef.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> with <a href="#scala.reflect.internal;Types;AliasTypeRef" title="Types.this.AliasTypeRef">AliasTypeRef</a>
  private final class <a title="class AbstractNoArgsTypeRef extends Types.this.NoArgsTypeRef with Types.this.AbstractTypeRef" id="scala.reflect.internal;Types;AbstractNoArgsTypeRef">AbstractNoArgsTypeRef</a><a href="#scala.reflect.internal;Types;AbstractNoArgsTypeRef" title="Types.this.AbstractNoArgsTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;AbstractNoArgsTypeRef.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;AbstractNoArgsTypeRef.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;NoArgsTypeRef" title="Types.this.NoArgsTypeRef">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AbstractNoArgsTypeRef.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;AbstractNoArgsTypeRef.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> with <a href="#scala.reflect.internal;Types;AbstractTypeRef" title="Types.this.AbstractTypeRef">AbstractTypeRef</a>
  private final class <a title="class ClassNoArgsTypeRef extends Types.this.NoArgsTypeRef with Types.this.ClassTypeRef" id="scala.reflect.internal;Types;ClassNoArgsTypeRef">ClassNoArgsTypeRef</a><a href="#scala.reflect.internal;Types;ClassNoArgsTypeRef" title="Types.this.ClassNoArgsTypeRef" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;ClassNoArgsTypeRef.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ClassNoArgsTypeRef.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;NoArgsTypeRef" title="Types.this.NoArgsTypeRef">NoArgsTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassNoArgsTypeRef.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;ClassNoArgsTypeRef.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> with <a href="#scala.reflect.internal;Types;ClassTypeRef" title="Types.this.ClassTypeRef">ClassTypeRef</a>

  object <a title="Types.this.TypeRef.type" id="scala.reflect.internal;Types.TypeRef.readResolve">TypeRef</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;TypeRefExtractor" title="Types.this.TypeRefExtractor">TypeRefExtractor</a> <span class="delimiter">{</span>
    def <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types.TypeRef.apply(2232bf1c73)">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.unique" title="(tp: Types.this.Type)Types.this.Type">unique</a><span class="delimiter">(</span><span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).args" title="List[Types.this.Type]">args</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAliasType" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span>              new <a href="#scala.reflect.internal;Types;AliasArgsTypeRef" title="Types.this.AliasArgsTypeRef">AliasArgsTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
        else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAbstractType" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span>      new <a href="#scala.reflect.internal;Types;AbstractArgsTypeRef" title="Types.this.AbstractArgsTypeRef">AbstractArgsTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
        else                              new <a href="#scala.reflect.internal;Types;ClassArgsTypeRef" title="Types.this.ClassArgsTypeRef">ClassArgsTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      else <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAliasType" title="=&gt; Boolean">isAliasType</a><span class="delimiter">)</span>              new <a href="#scala.reflect.internal;Types;AliasNoArgsTypeRef" title="Types.this.AliasNoArgsTypeRef">AliasNoArgsTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAbstractType" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span>      new <a href="#scala.reflect.internal;Types;AbstractNoArgsTypeRef" title="Types.this.AbstractNoArgsTypeRef">AbstractNoArgsTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isRefinementClass" title="=&gt; Boolean">isRefinementClass</a><span class="delimiter">)</span>   new <a href="#scala.reflect.internal;Types;RefinementTypeRef" title="Types.this.RefinementTypeRef">RefinementTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a><span class="delimiter">)</span>      new <a href="#scala.reflect.internal;Types;PackageTypeRef" title="Types.this.PackageTypeRef">PackageTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModuleClass" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span>       new <a href="#scala.reflect.internal;Types;ModuleTypeRef" title="Types.this.ModuleTypeRef">ModuleTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        else                              new <a href="#scala.reflect.internal;Types;ClassNoArgsTypeRef" title="Types.this.ClassNoArgsTypeRef">ClassNoArgsTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73).sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  protected def <a title="(tpe: Types.this.TypeRef)Unit" id="scala.reflect.internal;Types.defineParentsOfTypeRef">defineParentsOfTypeRef</a><span class="delimiter">(</span><a title="Types.this.TypeRef" id="scala.reflect.internal;Types.defineParentsOfTypeRef.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;TypeRef" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="Int" id="scala.reflect.internal;Types.defineParentsOfTypeRef.period">period</a> = <a href="#scala.reflect.internal;Types.defineParentsOfTypeRef.tpe" title="Types.this.TypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;TypeRef.parentsPeriod_=" title="=&gt; Int">parentsPeriod</a>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineParentsOfTypeRef.period" title="Int">period</a> <a href="../../Int.scala.html#scala;Int.!=(5f58a84eb3)" title="(x: Int)Boolean">!=</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#scala.reflect.internal;Types.defineParentsOfTypeRef.tpe" title="Types.this.TypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;TypeRef.parentsPeriod_=" title="(x$1: Int)Unit">parentsPeriod</a> = <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.isValidForBaseClasses" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineParentsOfTypeRef.period" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types.defineParentsOfTypeRef.tpe" title="Types.this.TypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;TypeRef.parentsCache_=" title="(x$1: List[Types.this.Type])Unit">parentsCache</a> = <a href="#scala.reflect.internal;Types.defineParentsOfTypeRef.tpe" title="Types.this.TypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;TypeRef.thisInfo" title="=&gt; Types.this.Type">thisInfo</a>.<a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#scala.reflect.internal;Types.defineParentsOfTypeRef.tpe" title="Types.this.TypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;TypeRef.transform" title="(tp: Types.this.Type)Types.this.Type">transform</a>
      <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineParentsOfTypeRef.tpe" title="Types.this.TypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;TypeRef.parentsCache_=" title="=&gt; List[Types.this.Type]">parentsCache</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// seems this can happen if things are corrupted enough, see #2641</span>
        <a href="#scala.reflect.internal;Types.defineParentsOfTypeRef.tpe" title="Types.this.TypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;TypeRef.parentsCache_=" title="(x$1: List[Types.this.Type])Unit">parentsCache</a> = <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.List.apply" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyTpe" title="=&gt; Types.this.Type">AnyTpe</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  protected def <a title="(tpe: Types.this.TypeRef)Unit" id="scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef">defineBaseTypeSeqOfTypeRef</a><span class="delimiter">(</span><a title="Types.this.TypeRef" id="scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;TypeRef" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="Int" id="scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef.period">period</a> = <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef.tpe" title="Types.this.TypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeqPeriod_=" title="=&gt; Int">baseTypeSeqPeriod</a>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef.period" title="Int">period</a> <a href="../../Int.scala.html#scala;Int.!=(5f58a84eb3)" title="(x: Int)Boolean">!=</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef.tpe" title="Types.this.TypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeqPeriod_=" title="(x$1: Int)Unit">baseTypeSeqPeriod</a> = <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentPeriod" title="=&gt; Types.this.Period">currentPeriod</a>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.isValidForBaseClasses" title="(period: Types.this.Period)Boolean">isValidForBaseClasses</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef.period" title="Int">period</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.incCounter(456ea4fa07)" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.typerefBaseTypeSeqCount" title="=&gt; scala.reflect.internal.util.Statistics.SubCounter">typerefBaseTypeSeqCount</a><span class="delimiter">)</span>
        val <a title="scala.reflect.internal.util.Statistics.TimerSnapshot" id="scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef.start">start</a> = if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.pushTimer" title="(timers: scala.reflect.internal.util.Statistics.TimerStack, timer: =&gt; scala.reflect.internal.util.Statistics.StackableTimer)scala.reflect.internal.util.Statistics.TimerSnapshot">pushTimer</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.typeOpsStack" title="=&gt; scala.reflect.internal.util.Statistics.TimerStack">typeOpsStack</a>, <a href="#scala.reflect.internal.TypesStats.baseTypeSeqNanos" title="=&gt; scala.reflect.internal.util.Statistics.StackableTimer">baseTypeSeqNanos</a><span class="delimiter">)</span> else null
        try <span class="delimiter">{</span>
          <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef.tpe" title="Types.this.TypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeqCache_=" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs.undetBaseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a>
          <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef.tpe" title="Types.this.TypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeqCache_=" title="(x$1: Types.this.BaseTypeSeq)Unit">baseTypeSeqCache</a> = <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef.tpe" title="Types.this.TypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeqImpl" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqImpl</a>
        <span class="delimiter">}</span> finally <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.popTimer" title="(timers: scala.reflect.internal.util.Statistics.TimerStack, prev: scala.reflect.internal.util.Statistics.TimerSnapshot)Unit">popTimer</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.typeOpsStack" title="=&gt; scala.reflect.internal.util.Statistics.TimerStack">typeOpsStack</a>, <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef.start" title="scala.reflect.internal.util.Statistics.TimerSnapshot">start</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef.tpe" title="Types.this.TypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;TypeRef.baseTypeSeqCache_=" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeqCache</a> <span title="(x$1: Any)Boolean">==</span> <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs.undetBaseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">undetBaseTypeSeq</a><span class="delimiter">)</span>
      throw new <a href="#scala.reflect.internal;Types;TypeError" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic inheritance involving &quot;)" class="string">&quot;illegal cyclic inheritance involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types.defineBaseTypeSeqOfTypeRef.tpe" title="Types.this.TypeRef">tpe</a>.<a href="#scala.reflect.internal;Types;TypeRef.sym" title="=&gt; Types.this.Symbol">sym</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class representing a method type with parameters.
   *  Note that a parameterless method is represented by a NullaryMethodType:
   *
   *    def m(): Int        MethodType(Nil, Int)
   *    def m: Int          NullaryMethodType(Int)
   */</span>
  case class <a title="class MethodType extends Types.this.Type with Types.this.MethodTypeApi with Product with Serializable" id="scala.reflect.internal;Types;MethodType">MethodType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a>override val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;MethodType.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
                        override val <a title="Types.this.Type" id="scala.reflect.internal;Types;MethodType.resultType">resultType</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;MethodTypeApi" title="Types.this.MethodTypeApi">MethodTypeApi</a> <span class="delimiter">{</span>

    private var <a title="scala.reflect.internal.util.ThreeValues.ThreeValue" id="scala.reflect.internal;Types;MethodType.trivial_=">trivial</a>: <a href="../../Byte.scala.html#scala;Byte" title="scala.reflect.internal.util.ThreeValues.ThreeValue">ThreeValue</a> = <span title="Byte(0)">UNKNOWN</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;MethodType.isTrivial">isTrivial</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.trivial_=" title="=&gt; scala.reflect.internal.util.ThreeValues.ThreeValue">trivial</a> <a href="../../Byte.scala.html#scala;Byte.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(0)">UNKNOWN</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;MethodType.trivial_=" title="(x$1: scala.reflect.internal.util.ThreeValues.ThreeValue)Unit">trivial</a> = <a href="util/ThreeValues.scala.html#scala.reflect.internal.util.ThreeValues.fromBoolean" title="(b: Boolean)scala.reflect.internal.util.ThreeValues.ThreeValue">fromBoolean</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.isTrivialResult" title="=&gt; Boolean">isTrivialResult</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;MethodType.areTrivialParams" title="(ps: List[Types.this.Symbol])Boolean">areTrivialParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.params" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="util/ThreeValues.scala.html#scala.reflect.internal.util.ThreeValues.toBoolean" title="(x: scala.reflect.internal.util.ThreeValues.ThreeValue)Boolean">toBoolean</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.trivial_=" title="=&gt; scala.reflect.internal.util.ThreeValues.ThreeValue">trivial</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    private def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;MethodType.isTrivialResult">isTrivialResult</a> =
      <a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.isTrivial" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.withoutAnnotations" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span>

    private def <a title="(ps: List[Types.this.Symbol])Boolean" id="scala.reflect.internal;Types;MethodType.areTrivialParams">areTrivialParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;MethodType.areTrivialParams.ps">ps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types;MethodType.areTrivialParams.ps" title="List[Types.this.Symbol]">ps</a> match <span class="delimiter">{</span>
      case <a title="Types.this.Symbol" id="scala.reflect.internal;Types;MethodType.areTrivialParams.p">p</a> :: <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;MethodType.areTrivialParams.rest">rest</a> =&gt;
        <a href="#scala.reflect.internal;Types;MethodType.areTrivialParams.p" title="Types.this.Symbol">p</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; Types.this.Type">tpe</a>.<a href="#scala.reflect.internal;Types;Type.isTrivial" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.typesContain" title="(tps: List[Types.this.Type], sym: Types.this.Symbol)Boolean">typesContain</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.paramTypes" title="=&gt; List[Types.this.Type]">paramTypes</a>, <a href="#scala.reflect.internal;Types;MethodType.areTrivialParams.p" title="Types.this.Symbol">p</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a> <a href="#scala.reflect.internal;Types;Type.contains" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal;Types;MethodType.areTrivialParams.p" title="Types.this.Symbol">p</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
        <a href="#scala.reflect.internal;Types;MethodType.areTrivialParams" title="(ps: List[Types.this.Symbol])Boolean">areTrivialParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.areTrivialParams.rest" title="List[Types.this.Symbol]">rest</a><span class="delimiter">)</span>
      case _ =&gt;
        true
    <span class="delimiter">}</span>

    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;MethodType.isImplicit">isImplicit</a> = <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.params" title="=&gt; List[Types.this.Symbol]">params</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;MethodType.params" title="=&gt; List[Types.this.Symbol]">params</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Symbol">head</a>.<a href="HasFlags.scala.html#scala.reflect.internal;HasFlags.isImplicit" title="=&gt; Boolean">isImplicit</a>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;MethodType.isJava">isJava</a> = false <span class="comment">// can we do something like for implicits? I.e. do Java methods without parameters need to be recognized?</span>

    <span class="comment">//assert(paramTypes forall (pt =&gt; !pt.typeSymbol.isImplClass))//DEBUG</span>
    override def <a title="=&gt; Int" id="scala.reflect.internal;Types;MethodType.paramSectionCount">paramSectionCount</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> = <a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.paramSectionCount" title="=&gt; Int">paramSectionCount</a> <a href="../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+</a> <span title="Int(1)" class="int">1</span>

    override def <a title="=&gt; List[List[Types.this.Symbol]]" id="scala.reflect.internal;Types;MethodType.paramss">paramss</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Types.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;MethodType.params" title="=&gt; List[Types.this.Symbol]">params</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: List[Types.this.Symbol])List[List[Types.this.Symbol]]">::</a> <a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.paramss" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>

    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;MethodType.paramTypes">paramTypes</a> = <a href="util/Collections.scala.html#scala.reflect.internal.util;Collections.mapList" title="(as: List[Types.this.Symbol])(f: Types.this.Symbol =&gt; Types.this.Type)List[Types.this.Type]">mapList</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.params" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.symTpe" title="=&gt; Types.this.Symbol =&gt; Types.this.Type">symTpe</a><span class="delimiter">)</span> <span class="comment">// OPT use mapList rather than .map</span>

    override def <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="scala.reflect.internal;Types;MethodType.boundSyms">boundSyms</a> = <a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.boundSyms" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a> <a href="../../collection/SetLike.scala.html#scala.collection;SetLike.++(07e1553119)" title="(elems: scala.collection.GenTraversableOnce[Types.this.Symbol])scala.collection.immutable.Set[Types.this.Symbol]">++</a> <a href="#scala.reflect.internal;Types;MethodType.params" title="=&gt; List[Types.this.Symbol]">params</a>

    override def <a title="(actuals: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types;MethodType.resultType(01bbd0fc8a)">resultType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types;MethodType.resultType(01bbd0fc8a).actuals">actuals</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.isTrivial" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a>
      else if <span class="delimiter">(</span><span class="comment">/*isDependentMethodType &amp;&amp;*/</span> <a href="#scala.reflect.internal;Types.sameLength" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.resultType(01bbd0fc8a).actuals" title="List[Types.this.Type]">actuals</a>, <a href="#scala.reflect.internal;Types;MethodType.params" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="Types.this.InstantiateDependentMap" id="scala.reflect.internal;Types;MethodType.resultType(01bbd0fc8a).idm">idm</a> = new <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap" title="Types.this.InstantiateDependentMap">InstantiateDependentMap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.params" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#scala.reflect.internal;Types;MethodType.resultType(01bbd0fc8a).actuals" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
        val <a title="Types.this.Type" id="scala.reflect.internal;Types;MethodType.resultType(01bbd0fc8a).res">res</a> = <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.apply" title="(tp: Types.this.Type)Types.this.Type">idm</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types.existentialAbstraction" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.resultType(01bbd0fc8a).idm" title="Types.this.InstantiateDependentMap">idm</a>.<a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;InstantiateDependentMap.existentialsNeeded" title="=&gt; List[Types.this.Symbol]">existentialsNeeded</a>, <a href="#scala.reflect.internal;Types;MethodType.resultType(01bbd0fc8a).res" title="Types.this.Type">res</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      else <a href="#scala.reflect.internal;Types.existentialAbstraction" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.params" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span>

    private var <a title="scala.reflect.internal.util.ThreeValues.ThreeValue" id="scala.reflect.internal;Types;MethodType.isdepmeth_=">isdepmeth</a>: <a href="../../Byte.scala.html#scala;Byte" title="scala.reflect.internal.util.ThreeValues.ThreeValue">ThreeValue</a> = <span title="Byte(0)">UNKNOWN</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;MethodType.isDependentMethodType">isDependentMethodType</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.isdepmeth_=" title="=&gt; scala.reflect.internal.util.ThreeValues.ThreeValue">isdepmeth</a> <a href="../../Byte.scala.html#scala;Byte.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(0)">UNKNOWN</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;MethodType.isdepmeth_=" title="(x$1: scala.reflect.internal.util.ThreeValues.ThreeValue)Unit">isdepmeth</a> = <a href="util/ThreeValues.scala.html#scala.reflect.internal.util.ThreeValues.fromBoolean" title="(b: Boolean)scala.reflect.internal.util.ThreeValues.ThreeValue">fromBoolean</a><span class="delimiter">(</span><a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps.IsDependentCollector" title="Types.this.IsDependentCollector.type">IsDependentCollector</a>.<a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeCollector.collect" title="(tp: Types.this.Type)Boolean">collect</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.dealias" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="util/ThreeValues.scala.html#scala.reflect.internal.util.ThreeValues.toBoolean" title="(x: scala.reflect.internal.util.ThreeValues.ThreeValue)Boolean">toBoolean</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.isdepmeth_=" title="=&gt; scala.reflect.internal.util.ThreeValues.ThreeValue">isdepmeth</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// implicit args can only be depended on in result type:</span>
    <span class="comment">//TODO this may be generalised so that the only constraint is dependencies are acyclic</span>
    def <a title="=&gt; Types.this.MethodType" id="scala.reflect.internal;Types;MethodType.approximate">approximate</a>: <a href="#scala.reflect.internal;Types;MethodType" title="Types.this.MethodType">MethodType</a> = <a href="#scala.reflect.internal;Types;MethodType" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.params" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#scala.reflect.internal;Types;Type.resultApprox" title="=&gt; Types.this.Type">resultApprox</a><span class="delimiter">)</span>

    override def <a title="=&gt; String" id="scala.reflect.internal;Types;MethodType.safeToString">safeToString</a> = <a href="TypeDebugging.scala.html#scala.reflect.internal;TypeDebugging.paramString" title="(tp: Types.this.Type)String">paramString</a><span class="delimiter">(</span>this<span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a>

    override def <a title="(owner: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;MethodType.cloneInfo">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;MethodType.cloneInfo.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;MethodType.cloneInfo.vparams">vparams</a> = <a href="Symbols.scala.html#scala.reflect.internal;Symbols.cloneSymbolsAtOwner" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)List[Types.this.Symbol]">cloneSymbolsAtOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.params" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#scala.reflect.internal;Types;MethodType.cloneInfo.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types.copyMethodType" title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type">copyMethodType</a><span class="delimiter">(</span>this, <a href="#scala.reflect.internal;Types;MethodType.cloneInfo.vparams" title="List[Types.this.Symbol]">vparams</a>, <a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.substSym" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.params" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#scala.reflect.internal;Types;MethodType.cloneInfo.vparams" title="List[Types.this.Symbol]">vparams</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.cloneInfo" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.cloneInfo.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    override def <a title="(owner: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;MethodType.atOwner">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;MethodType.atOwner.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="Symbols.scala.html#scala.reflect.internal;Symbols.allSymbolsHaveOwner" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)Boolean">allSymbolsHaveOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.params" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#scala.reflect.internal;Types;MethodType.atOwner.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.atOwner" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.atOwner.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types;MethodType.resultType" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;MethodType.cloneInfo" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MethodType.atOwner.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      else
        this

    override def <a title="=&gt; String" id="scala.reflect.internal;Types;MethodType.kind">kind</a> = <span title="String(&quot;MethodType&quot;)" class="string">&quot;MethodType&quot;</span>
  <span class="delimiter">}</span>

  object <a title="Types.this.MethodType.type" id="scala.reflect.internal;Types.MethodType.readResolve">MethodType</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;MethodTypeExtractor" title="Types.this.MethodTypeExtractor">MethodTypeExtractor</a>

  class <a title="class JavaMethodType extends Types.this.MethodType" id="scala.reflect.internal;Types;JavaMethodType">JavaMethodType</a><a href="#scala.reflect.internal;Types;JavaMethodType" title="Types.this.JavaMethodType" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;JavaMethodType.ps">ps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.internal;Types;JavaMethodType.rt">rt</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;MethodType" title="Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;JavaMethodType.ps" title="List[Types.this.Symbol]">ps</a>, <a href="#scala.reflect.internal;Types;JavaMethodType.rt" title="Types.this.Type">rt</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;JavaMethodType.isJava">isJava</a> = true
  <span class="delimiter">}</span>

  case class <a title="class NullaryMethodType extends Types.this.Type with Types.this.NullaryMethodTypeApi with Product with Serializable" id="scala.reflect.internal;Types;NullaryMethodType">NullaryMethodType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a>override val <a title="Types.this.Type" id="scala.reflect.internal;Types;NullaryMethodType.resultType">resultType</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;NullaryMethodTypeApi" title="Types.this.NullaryMethodTypeApi">NullaryMethodTypeApi</a> <span class="delimiter">{</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;NullaryMethodType.isTrivial">isTrivial</a> = <a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.isTrivial" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.withoutAnnotations" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;NullaryMethodType.prefix">prefix</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.prefix" title="=&gt; Types.this.Type">prefix</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;NullaryMethodType.narrow">narrow</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.narrow" title="=&gt; Types.this.Type">narrow</a>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;NullaryMethodType.termSymbol">termSymbol</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.termSymbol" title="=&gt; Types.this.Symbol">termSymbol</a>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;NullaryMethodType.typeSymbol">typeSymbol</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>
    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;NullaryMethodType.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a>
    override def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types;NullaryMethodType.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> = <a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a>
    override def <a title="=&gt; Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;NullaryMethodType.baseTypeSeq">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    override def <a title="=&gt; scala.reflect.internal.Depth" id="scala.reflect.internal;Types;NullaryMethodType.baseTypeSeqDepth">baseTypeSeqDepth</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeqDepth" title="=&gt; scala.reflect.internal.Depth">baseTypeSeqDepth</a>
    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;NullaryMethodType.baseClasses">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.baseClasses" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    override def <a title="(clazz: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;NullaryMethodType.baseType">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;NullaryMethodType.baseType.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.baseType" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;NullaryMethodType.baseType.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    override def <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="scala.reflect.internal;Types;NullaryMethodType.boundSyms">boundSyms</a> = <a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.boundSyms" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;NullaryMethodType.safeToString">safeToString</a>: <span title="String">String</span> = <span title="String(&quot;=&gt; &quot;)" class="string">&quot;=&gt; &quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;NullaryMethodType.resultType" title="=&gt; Types.this.Type">resultType</a>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;NullaryMethodType.kind">kind</a> = <span title="String(&quot;NullaryMethodType&quot;)" class="string">&quot;NullaryMethodType&quot;</span>
  <span class="delimiter">}</span>

  object <a title="Types.this.NullaryMethodType.type" id="scala.reflect.internal;Types.NullaryMethodType.readResolve">NullaryMethodType</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;NullaryMethodTypeExtractor" title="Types.this.NullaryMethodTypeExtractor">NullaryMethodTypeExtractor</a>

  <span class="comment">/** A type function or the type of a polymorphic value (and thus of kind *).
   *
   * Before the introduction of NullaryMethodType, a polymorphic nullary method (e.g, def isInstanceOf[T]: Boolean)
   * used to be typed as PolyType(tps, restpe), and a monomorphic one as PolyType(Nil, restpe)
   * This is now: PolyType(tps, NullaryMethodType(restpe)) and NullaryMethodType(restpe)
   * by symmetry to MethodTypes: PolyType(tps, MethodType(params, restpe)) and MethodType(params, restpe)
   *
   * Thus, a PolyType(tps, TypeRef(...)) unambiguously indicates a type function (which results from eta-expanding a type constructor alias).
   * Similarly, PolyType(tps, ClassInfoType(...)) is a type constructor.
   *
   * A polytype is of kind * iff its resultType is a (nullary) method type.
   */</span>
  case class <a title="class PolyType extends Types.this.Type with Types.this.PolyTypeApi with Product with Serializable" id="scala.reflect.internal;Types;PolyType">PolyType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a>override val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;PolyType.typeParams">typeParams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, override val <a title="Types.this.Type" id="scala.reflect.internal;Types;PolyType.resultType">resultType</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>
       extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;PolyTypeApi" title="Types.this.PolyTypeApi">PolyTypeApi</a> <span class="delimiter">{</span>
    <span class="comment">//assert(!(typeParams contains NoSymbol), this)</span>
    <a href="../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;PolyType.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a>, this<span class="delimiter">)</span> <span class="comment">// used to be a marker for nullary method type, illegal now (see @NullaryMethodType)</span>

    override def <a title="=&gt; Int" id="scala.reflect.internal;Types;PolyType.paramSectionCount">paramSectionCount</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> = <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.paramSectionCount" title="=&gt; Int">paramSectionCount</a>
    override def <a title="=&gt; List[List[Types.this.Symbol]]" id="scala.reflect.internal;Types;PolyType.paramss">paramss</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Types.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.paramss" title="=&gt; List[List[Types.this.Symbol]]">paramss</a>
    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;PolyType.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.params" title="=&gt; List[Types.this.Symbol]">params</a>
    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;PolyType.paramTypes">paramTypes</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.paramTypes" title="=&gt; List[Types.this.Type]">paramTypes</a>
    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;PolyType.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a>
    override def <a title="=&gt; Types.this.Scope" id="scala.reflect.internal;Types;PolyType.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> = <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;PolyType.termSymbol">termSymbol</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.termSymbol" title="=&gt; Types.this.Symbol">termSymbol</a>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;PolyType.typeSymbol">typeSymbol</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>
    override def <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="scala.reflect.internal;Types;PolyType.boundSyms">boundSyms</a> = immutable.<a href="../../collection/generic/GenericCompanion.scala.html#scala.collection.generic;GenericCompanion.apply" title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</a><span title="(elems: Types.this.Symbol*)scala.collection.immutable.Set[Types.this.Symbol]" class="delimiter">[</span><a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;PolyType.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.++" title="(that: scala.collection.GenTraversableOnce[Types.this.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">++</a> <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.boundSyms" title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]">boundSyms</a>: _*<span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;PolyType.prefix">prefix</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.prefix" title="=&gt; Types.this.Type">prefix</a>
    override def <a title="=&gt; Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;PolyType.baseTypeSeq">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
    override def <a title="=&gt; scala.reflect.internal.Depth" id="scala.reflect.internal;Types;PolyType.baseTypeSeqDepth">baseTypeSeqDepth</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeqDepth" title="=&gt; scala.reflect.internal.Depth">baseTypeSeqDepth</a>
    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;PolyType.baseClasses">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.baseClasses" title="=&gt; List[Types.this.Symbol]">baseClasses</a>
    override def <a title="(clazz: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;PolyType.baseType">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;PolyType.baseType.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.baseType" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;PolyType.baseType.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;PolyType.narrow">narrow</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.narrow" title="=&gt; Types.this.Type">narrow</a>

    <span class="comment">/** @M: typeDefSig wraps a TypeBounds in a PolyType
     *  to represent a higher-kinded type parameter
     *  wrap lo&amp;hi in polytypes to bind variables
     */</span>
    override def <a title="=&gt; Types.this.TypeBounds" id="scala.reflect.internal;Types;PolyType.bounds">bounds</a>: <a href="#scala.reflect.internal;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a> =
      <a href="#scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3)" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeFun" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;PolyType.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.bounds" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#scala.reflect.internal;Types;TypeBounds.lo" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>,
                 <a href="#scala.reflect.internal;Types.typeFun" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;PolyType.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.bounds" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>

    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;PolyType.isHigherKinded">isHigherKinded</a> = <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;PolyType.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a>

    override def <a title="=&gt; String" id="scala.reflect.internal;Types;PolyType.safeToString">safeToString</a> = <a href="TypeDebugging.scala.html#scala.reflect.internal;TypeDebugging.typeParamsString" title="(tp: Types.this.Type)String">typeParamsString</a><span class="delimiter">(</span>this<span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>

    override def <a title="(owner: Types.this.Symbol)Types.this.PolyType" id="scala.reflect.internal;Types;PolyType.cloneInfo">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;PolyType.cloneInfo.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
      val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;PolyType.cloneInfo.tparams">tparams</a> = <a href="Symbols.scala.html#scala.reflect.internal;Symbols.cloneSymbolsAtOwner" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)List[Types.this.Symbol]">cloneSymbolsAtOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;PolyType.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#scala.reflect.internal;Types;PolyType.cloneInfo.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types;PolyType" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;PolyType.cloneInfo.tparams" title="List[Types.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.substSym" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;PolyType.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#scala.reflect.internal;Types;PolyType.cloneInfo.tparams" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.cloneInfo" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;PolyType.cloneInfo.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    override def <a title="(owner: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;PolyType.atOwner">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;PolyType.atOwner.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="Symbols.scala.html#scala.reflect.internal;Symbols.allSymbolsHaveOwner" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)Boolean">allSymbolsHaveOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;PolyType.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#scala.reflect.internal;Types;PolyType.atOwner.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a>.<a href="#scala.reflect.internal;Types;Type.atOwner" title="(owner: Types.this.Symbol)Types.this.Type">atOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;PolyType.atOwner.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types;PolyType.resultType" title="=&gt; Types.this.Type">resultType</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;PolyType.cloneInfo" title="(owner: Types.this.Symbol)Types.this.PolyType">cloneInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;PolyType.atOwner.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      else
        this

    override def <a title="=&gt; String" id="scala.reflect.internal;Types;PolyType.kind">kind</a> = <span title="String(&quot;PolyType&quot;)" class="string">&quot;PolyType&quot;</span>
  <span class="delimiter">}</span>

  object <a title="Types.this.PolyType.type" id="scala.reflect.internal;Types.PolyType.readResolve">PolyType</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;PolyTypeExtractor" title="Types.this.PolyTypeExtractor">PolyTypeExtractor</a>

  <span class="comment">/** A creator for existential types which flattens nested existentials.
   */</span>
  def <a title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.newExistentialType">newExistentialType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.newExistentialType.quantified">quantified</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.internal;Types.newExistentialType.underlying">underlying</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.newExistentialType.quantified" title="List[Types.this.Symbol]">quantified</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.newExistentialType.underlying" title="Types.this.Type">underlying</a>
    else <a href="#scala.reflect.internal;Types.newExistentialType.underlying" title="Types.this.Type">underlying</a> match <span class="delimiter">{</span>
      case ExistentialType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.newExistentialType.qs">qs</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.newExistentialType.restpe">restpe</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.newExistentialType" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.newExistentialType.quantified" title="List[Types.this.Symbol]">quantified</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.:::" title="(prefix: List[Types.this.Symbol])List[Types.this.Symbol]">:::</a> <a href="#scala.reflect.internal;Types.newExistentialType.qs" title="List[Types.this.Symbol]">qs</a>, <a href="#scala.reflect.internal;Types.newExistentialType.restpe" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
      case _                           =&gt; <a href="#scala.reflect.internal;Types;ExistentialType" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">ExistentialType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.newExistentialType.quantified" title="List[Types.this.Symbol]">quantified</a>, <a href="#scala.reflect.internal;Types.newExistentialType.underlying" title="Types.this.Type">underlying</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  case class <a title="class ExistentialType extends Types.this.Type with Types.this.RewrappingTypeProxy with Types.this.ExistentialTypeApi with Product with Serializable" id="scala.reflect.internal;Types;ExistentialType">ExistentialType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;ExistentialType.quantified">quantified</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
                             override val <a title="Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.underlying">underlying</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;RewrappingTypeProxy" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;ExistentialTypeApi" title="Types.this.ExistentialTypeApi">ExistentialTypeApi</a>
  <span class="delimiter">{</span>
    override protected def <a title="(newtp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.rewrap">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.rewrap.newtp">newtp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.existentialAbstraction" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#scala.reflect.internal;Types;ExistentialType.rewrap.newtp" title="Types.this.Type">newtp</a><span class="delimiter">)</span>

    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;ExistentialType.isTrivial">isTrivial</a> = false
    override def <a title="=&gt; Types.this.TypeBounds" id="scala.reflect.internal;Types;ExistentialType.bounds">bounds</a> = <a href="#scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3)" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.bounds" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#scala.reflect.internal;Types;TypeBounds.lo" title="=&gt; Types.this.Type">lo</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.bounds" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; Types.this.Type">hi</a><span class="delimiter">)</span><span class="delimiter">)</span>
    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;ExistentialType.parents">parents</a> = <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    override def <a title="=&gt; scala.collection.immutable.Set[Types.this.Symbol]" id="scala.reflect.internal;Types;ExistentialType.boundSyms">boundSyms</a> = <a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toSet" title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</a>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.prefix">prefix</a> = <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.prefix" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span>
    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;ExistentialType.typeArgs">typeArgs</a> = <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;ExistentialType.params">params</a> = <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.params" title="=&gt; List[Types.this.Symbol]">params</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)List[Types.this.Symbol]">mapConserve</a> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.params.$anonfun.param">param</a> =&gt;
      val <a title="Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.params.$anonfun.tpe1">tpe1</a> = <a href="#scala.reflect.internal;Types;ExistentialType.rewrap" title="(newtp: Types.this.Type)Types.this.Type">rewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.params.$anonfun.param" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpeHK" title="=&gt; Types.this.Type">tpeHK</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.params.$anonfun.tpe1" title="Types.this.Type">tpe1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;ExistentialType.params.$anonfun.param" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpeHK" title="=&gt; Types.this.Type">tpeHK</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;ExistentialType.params.$anonfun.param" title="Types.this.Symbol">param</a> else <a href="#scala.reflect.internal;Types;ExistentialType.params.$anonfun.param" title="Types.this.Symbol">param</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.cloneSymbol(4a4a4b92d2)" title="=&gt; param.TypeOfClonedSymbol">cloneSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="(info: Types.this.Type)param.TypeOfClonedSymbol">setInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.params.$anonfun.tpe1" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;ExistentialType.paramTypes">paramTypes</a> = <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.paramTypes" title="=&gt; List[Types.this.Type]">paramTypes</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    override def <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.instantiateTypeParams">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;ExistentialType.instantiateTypeParams.formals">formals</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;ExistentialType.instantiateTypeParams.actuals">actuals</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
<span class="comment">//      maybeRewrap(underlying.instantiateTypeParams(formals, actuals))</span>

      val quantified1 = new <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap" title="Types.this.SubstTypeMap">SubstTypeMap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.instantiateTypeParams.formals" title="List[Types.this.Symbol]">formals</a>, <a href="#scala.reflect.internal;Types;ExistentialType.instantiateTypeParams.actuals" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span> <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeMap.mapOver(c59a65d52b)" title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;ExistentialType.instantiateTypeParams.quantified1">mapOver</a> <a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a>
      val <a title="Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.instantiateTypeParams.underlying1">underlying1</a> = <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.instantiateTypeParams.formals" title="List[Types.this.Symbol]">formals</a>, <a href="#scala.reflect.internal;Types;ExistentialType.instantiateTypeParams.actuals" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.instantiateTypeParams.quantified1" title="List[Types.this.Symbol]">quantified1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.instantiateTypeParams.underlying1" title="Types.this.Type">underlying1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span> this
      else <a href="#scala.reflect.internal;Types.existentialAbstraction" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.instantiateTypeParams.quantified1" title="List[Types.this.Symbol]">quantified1</a>, <a href="#scala.reflect.internal;Types;ExistentialType.instantiateTypeParams.underlying1" title="Types.this.Type">underlying1</a>.<a href="#scala.reflect.internal;Types;Type.substSym" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#scala.reflect.internal;Types;ExistentialType.instantiateTypeParams.quantified1" title="List[Types.this.Symbol]">quantified1</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="delimiter">}</span>
    override def <a title="(clazz: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.baseType">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.baseType.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.baseType" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.baseType.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;ExistentialType.baseTypeSeq">baseTypeSeq</a> = <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a> <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.map" title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.BaseTypeSeq">map</a> <a href="#scala.reflect.internal;Types;RewrappingTypeProxy.maybeRewrap" title="(newtp: Types.this.Type)Types.this.Type">maybeRewrap</a>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;ExistentialType.isHigherKinded">isHigherKinded</a> = false

    <span class="comment">// TODO: check invariant that all quantifiers have the same (existing) owner</span>
    private def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.quantifierOwner">quantifierOwner</a> = <a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a> <a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.collectFirst" title="(pf: PartialFunction[Types.this.Symbol,Types.this.Symbol])Option[Types.this.Symbol]">collectFirst</a> <a title="&lt;$anon: Types.this.Symbol =&gt; Types.this.Symbol&gt; extends scala.runtime.AbstractPartialFunction[Types.this.Symbol,Types.this.Symbol] with Serializable" id="scala.reflect.internal;Types;ExistentialType.quantifierOwner;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> case <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.quantifierOwner;$anonfun.isDefinedAt.q">q</a> if <a href="#scala.reflect.internal;Types;ExistentialType.quantifierOwner;$anonfun.isDefinedAt.q" title="Types.this.Symbol">q</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.exists" title="=&gt; Boolean">exists</a> =&gt; <a href="#scala.reflect.internal;Types;ExistentialType.quantifierOwner;$anonfun.isDefinedAt.q" title="Types.this.Symbol">q</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a> <span class="delimiter">}</span> <a href="../../Option.scala.html#scala;Option.getOrElse" title="(default: =&gt; Types.this.Symbol)Types.this.Symbol">getOrElse</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a>

    <span class="comment">// Is this existential of the form: T[Q1, ..., QN] forSome { type Q1 &gt;: L1 &lt;: U1, ..., QN &gt;: LN &lt;: UN}</span>
    private def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;ExistentialType.isStraightApplication">isStraightApplication</a> = <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a> <a href="../../collection/LinearSeqLike.scala.html#scala.collection;LinearSeqLike.corresponds" title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.Symbol, Types.this.Type) =&gt; Boolean)Boolean">corresponds</a> <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a><span class="delimiter">)</span><span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.isStraightApplication.$anonfun.q">q</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.isStraightApplication.$anonfun.a">a</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types;ExistentialType.isStraightApplication.$anonfun.q" title="Types.this.Symbol">q</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; Types.this.Type">tpe</a> <a href="#scala.reflect.internal;Types;Type.=:=" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#scala.reflect.internal;Types;ExistentialType.isStraightApplication.$anonfun.a" title="Types.this.Type">a</a> <span class="delimiter">}</span>

    <span class="comment">/** [SI-6169, SI-8197 -- companion to SI-1786]
     *
     * Approximation to improve the bounds of a Java-defined existential type,
     * based on the bounds of the type parameters of the quantified type
     * In Scala syntax, given a java-defined class C[T &lt;: String], the existential type C[_]
     * is improved to C[_ &lt;: String] before skolemization, which captures (get it?) what Java does:
     * enter the type paramers' bounds into the context when checking subtyping/type equality of existential types
     *
     * Also tried doing this once during class file parsing or when creating the existential type,
     * but that causes cyclic errors because it happens too early.
     *
     * NOTE: we're only modifying the skolems to avoid leaking the sharper bounds to `quantified` (SI-8283)
     *
     * TODO: figure out how to do this earlier without running into cycles, so this can subsume the fix for SI-1786
     */</span>
    override def <a title="(owner0: Types.this.Symbol, origin: AnyRef)Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6)">skolemizeExistential</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).owner0">owner0</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="AnyRef" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).origin">origin</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      val owner = <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).owner0" title="Types.this.Symbol">owner0</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.orElse" title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).owner">orElse</a> <a href="#scala.reflect.internal;Types;ExistentialType.quantifierOwner" title="=&gt; Types.this.Symbol">quantifierOwner</a>

      <span class="comment">// do this here because it's quite close to what Java does:</span>
      <span class="comment">// when checking subtyping/type equality, enter constraints</span>
      <span class="comment">// derived from the existentially quantified type into the typing environment</span>
      <span class="comment">// (aka \Gamma, which tracks types for variables and constraints/kinds for types)</span>
      <span class="comment">// as a nice bonus, delaying this until we need it avoids cyclic errors</span>
      def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).tpars">tpars</a> = <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbolDirect" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.initialize" title="=&gt; Types.this.Symbol">initialize</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>

      def <a title="(quant: Types.this.Symbol)Types.this.TypeSkolem" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSkolem">newSkolem</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSkolem.quant">quant</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).owner" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.newExistentialSkolem(4c30eb3c49)" title="(basis: Types.this.Symbol, origin: AnyRef)Types.this.TypeSkolem">newExistentialSkolem</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSkolem.quant" title="Types.this.Symbol">quant</a>, <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).origin" title="AnyRef">origin</a><span class="delimiter">)</span>
      def <a title="(quant: Types.this.Symbol, tparam: Types.this.Symbol)Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem">newSharpenedSkolem</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.quant">quant</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.tparam">tparam</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
        def <a title="(sym: Types.this.Symbol)Boolean" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.emptyBounds">emptyBounds</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.emptyBounds.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.emptyBounds.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.bounds" title="=&gt; Types.this.TypeBounds">bounds</a>.<a href="#scala.reflect.internal;Types;TypeBounds.isEmptyBounds" title="=&gt; Boolean">isEmptyBounds</a>

        <span class="comment">// avoid creating cycles [pos/t2940] that consist of an existential quantifier's</span>
        <span class="comment">// bounded by an existential type that unhygienically has that quantifier as its own quantifier</span>
        <span class="comment">// (TODO: clone latter existential with fresh quantifiers -- not covering this case for now)</span>
        val canSharpen = <span class="delimiter">(</span>
             <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.emptyBounds" title="(sym: Types.this.Symbol)Boolean">emptyBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.quant" title="Types.this.Symbol">quant</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.emptyBounds" title="(sym: Types.this.Symbol)Boolean">emptyBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.tparam" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span>
          <a href="../../Boolean.scala.html#scala;Boolean.&&" title="Boolean" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.canSharpen">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.existentialsInType" title="(tpe: Types.this.Type)List[Types.this.Symbol]">existentialsInType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.tparam" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span> <a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.intersect" title="(that: scala.collection.GenSeq[Types.this.Symbol])List[Types.this.Symbol]">intersect</a> <a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a>
        <span class="delimiter">)</span>

        val <a title="Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.skolemInfo">skolemInfo</a> = if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.canSharpen" title="Boolean">canSharpen</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.quant" title="Types.this.Symbol">quant</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a> else <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.tparam" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.substSym" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).tpars" title="=&gt; List[Types.this.Symbol]">tpars</a>, <a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span>

        <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).owner" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.newExistentialSkolem(e613506393)" title="(name: Types.this.TypeName, info: Types.this.Type, flags: Long, pos: Types.this.Position, origin: AnyRef)Types.this.TypeSkolem">newExistentialSkolem</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.quant" title="Types.this.Symbol">quant</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; quant.NameType">name</a>.<a href="Names.scala.html#scala.reflect.internal;Names;Name.toTypeName" title="=&gt; Types.this.TypeName">toTypeName</a>, <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.skolemInfo" title="Types.this.Type">skolemInfo</a>, <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.quant" title="Types.this.Symbol">quant</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.flags" title="=&gt; Long">flags</a>, <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem.quant" title="Types.this.Symbol">quant</a>.<a href="StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.pos" title="=&gt; Types.this.Position">pos</a>, <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).origin" title="AnyRef">origin</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      val canSharpenBounds = <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="HasFlags.scala.html#scala.reflect.internal;HasFlags.isJavaDefined" title="=&gt; Boolean">isJavaDefined</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.sharperSkolems" title="=&gt; Boolean">sharperSkolems</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="Boolean" id="scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).canSharpenBounds">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;ExistentialType.isStraightApplication" title="=&gt; Boolean">isStraightApplication</a>

      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).canSharpenBounds" title="Boolean">canSharpenBounds</a><span class="delimiter">)</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.deriveType2" title="(syms: List[Types.this.Symbol], as: List[Types.this.Symbol], symFn: (Types.this.Symbol, Types.this.Symbol) =&gt; Types.this.Symbol)(tpe: Types.this.Type)Types.this.Type">deriveType2</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).tpars" title="=&gt; List[Types.this.Symbol]">tpars</a>, <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSharpenedSkolem" title="(quant: Types.this.Symbol, tparam: Types.this.Symbol)Types.this.Symbol">newSharpenedSkolem</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span>
      else <a href="Symbols.scala.html#scala.reflect.internal;Symbols.deriveType" title="(syms: List[Types.this.Symbol], symFn: Types.this.Symbol =&gt; Types.this.Symbol)(tpe: Types.this.Type)Types.this.Type">deriveType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#scala.reflect.internal;Types;ExistentialType.skolemizeExistential(93cb9bdad6).newSkolem" title="(quant: Types.this.Symbol)Types.this.TypeSkolem">newSkolem</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    private def <a title="(qset: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]" id="scala.reflect.internal;Types;ExistentialType.wildcardArgsString">wildcardArgsString</a><span class="delimiter">(</span><a title="Set[Types.this.Symbol]" id="scala.reflect.internal;Types;ExistentialType.wildcardArgsString.qset">qset</a>: <a href="../../collection/immutable/Set.scala.html#scala.collection.immutable;Set" title="Set[Types.this.Symbol]">Set</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;ExistentialType.wildcardArgsString.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[String]">List</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;ExistentialType.wildcardArgsString.args" title="List[Types.this.Type]">args</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Type =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],String,List[String]])List[String]">map</a> <a href="#scala.reflect.internal;Types;ExistentialType.wildcardArgsString.$anonfun.x0$3" title="String" class="delimiter">{</a>
      case TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.wildcardArgsString.$anonfun.sym">sym</a>, _<span class="delimiter">)</span> if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.wildcardArgsString.qset" title="Set[Types.this.Symbol]">qset</a> <a href="../../collection/SetLike.scala.html#scala.collection;SetLike.contains" title="(elem: Types.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal;Types;ExistentialType.wildcardArgsString.$anonfun.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> =&gt;
        <span title="String(&quot;_&quot;)" class="string">&quot;_&quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.reflect.internal;Types;ExistentialType.wildcardArgsString.$anonfun.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.infoString" title="(tp: Types.this.Type)String">infoString</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.wildcardArgsString.$anonfun.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span>
      case <a title="Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.wildcardArgsString.$anonfun.arg">arg</a> =&gt;
        <a href="#scala.reflect.internal;Types;ExistentialType.wildcardArgsString.$anonfun.arg" title="Types.this.Type">arg</a>.<a href="#scala.reflect.internal;Types;Type.toString" title="()String">toString</a>
    <span class="delimiter">}</span>

    <span class="comment">/** An existential can only be printed with wildcards if:
     *   - the underlying type is a typeref
     *   - every quantified variable appears at most once as a type argument and
     *     nowhere inside a type argument
     *   - no quantified type argument contains a quantified variable in its bound
     *   - the typeref's symbol is not itself quantified
     *   - the prefix is not quanitified
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards">isRepresentableWithWildcards</a> = <span class="delimiter">{</span>
      val <a title="scala.collection.immutable.Set[Types.this.Symbol]" id="scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.qset">qset</a> = <a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toSet" title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</a>
      <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a> match <span class="delimiter">{</span>
        case TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.pre">pre</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.sym">sym</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.args">args</a><span class="delimiter">)</span> =&gt;
          def <a title="(tpe: Types.this.Type)Boolean" id="scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.isQuantified">isQuantified</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.isQuantified.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
            <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.isQuantified.tpe" title="Types.this.Type">tpe</a> <a href="#scala.reflect.internal;Types;Type.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.isQuantified.$anonfun.t">t</a> =&gt; <a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.qset" title="scala.collection.immutable.Set[Types.this.Symbol]">qset</a> <a href="../../collection/SetLike.scala.html#scala.collection;SetLike.contains" title="(elem: Types.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.isQuantified.$anonfun.t" title="Types.this.Type">t</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a>
            <a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.isQuantified.tpe" title="Types.this.Type">tpe</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isRefinementClass" title="=&gt; Boolean">isRefinementClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.isQuantified.tpe" title="Types.this.Type">tpe</a>.<a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.isQuantified" title="(tpe: Types.this.Type)Boolean">isQuantified</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          val <a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: List[Types.this.Type], _2: List[Types.this.Type])(List[Types.this.Type], List[Types.this.Type])" class="delimiter">(</a><a href="../../Tuple2.scala.html#scala;Tuple2._1" title="List[Types.this.Type]" id="scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.wildcardArgs">wildcardArgs</a>, <a href="../../Tuple2.scala.html#scala;Tuple2._2" title="List[Types.this.Type]" id="scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.otherArgs">otherArgs</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.args" title="List[Types.this.Type]">args</a> <a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.partition" title="(List[Types.this.Type], List[Types.this.Type])">partition</a> <span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.x$35.$anonfun.arg">arg</a> =&gt; <a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.qset" title="scala.collection.immutable.Set[Types.this.Symbol]">qset</a> <a href="../../collection/SetLike.scala.html#scala.collection;SetLike.contains" title="(elem: Types.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.x$35.$anonfun.arg" title="Types.this.Type">arg</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
          <a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.wildcardArgs" title="List[Types.this.Type]">wildcardArgs</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.distinct" title="=&gt; List[Types.this.Type]">distinct</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.wildcardArgs" title="List[Types.this.Type]">wildcardArgs</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
          <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.otherArgs" title="List[Types.this.Type]">otherArgs</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><span title="Types.this.Type">arg</span> =&gt; <a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.isQuantified" title="(tpe: Types.this.Type)Boolean">isQuantified</a><span class="delimiter">(</span><span title="Types.this.Type">arg</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
          <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.wildcardArgs" title="List[Types.this.Type]">wildcardArgs</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><span title="Types.this.Type">arg</span> =&gt; <a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.isQuantified" title="(tpe: Types.this.Type)Boolean">isQuantified</a><span class="delimiter">(</span><span title="Types.this.Type">arg</span>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.bounds" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
          <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.qset" title="scala.collection.immutable.Set[Types.this.Symbol]">qset</a> <a href="../../collection/SetLike.scala.html#scala.collection;SetLike.contains" title="(elem: Types.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
          <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.isQuantified" title="(tpe: Types.this.Type)Boolean">isQuantified</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards.pre" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        case _ =&gt; false
    <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ExistentialType.safeToString">safeToString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
      def <a title="=&gt; String" id="scala.reflect.internal;Types;ExistentialType.safeToString.clauses">clauses</a> = <span class="delimiter">{</span>
        val str = <a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],String,List[String]])List[String]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.safeToString.clauses.str.$anonfun.x$36" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.existentialToString" title="=&gt; String">existentialToString</a><span class="delimiter">)</span> <a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="String" id="scala.reflect.internal;Types;ExistentialType.safeToString.clauses.str">mkString</a> <span class="delimiter">(</span><span title="String(&quot; forSome { &quot;)" class="string">&quot; forSome { &quot;</span>, <span title="String(&quot;; &quot;)" class="string">&quot;; &quot;</span>, <span title="String(&quot; }&quot;)" class="string">&quot; }&quot;</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">explaintypes</a><span class="delimiter">)</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;ExistentialType.safeToString.clauses.str" title="String">str</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> else <a href="#scala.reflect.internal;Types;ExistentialType.safeToString.clauses.str" title="String">str</a>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a> match <span class="delimiter">{</span>
        case TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.safeToString.pre">pre</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.safeToString.sym">sym</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;ExistentialType.safeToString.args">args</a><span class="delimiter">)</span> if <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">debug</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;ExistentialType.isRepresentableWithWildcards" title="=&gt; Boolean">isRepresentableWithWildcards</a> =&gt;
          <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73)" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.safeToString.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types;ExistentialType.safeToString.sym" title="Types.this.Symbol">sym</a>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;ExistentialType.wildcardArgsString" title="(qset: Set[Types.this.Symbol], args: List[Types.this.Type])List[String]">wildcardArgsString</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toSet" title="scala.collection.immutable.Set[Types.this.Symbol]">toSet</a>, <a href="#scala.reflect.internal;Types;ExistentialType.safeToString.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
        case MethodType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> | NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span> | PolyType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
          <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;ExistentialType.safeToString.clauses" title="=&gt; String">clauses</a>
        case _ =&gt;
          <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;ExistentialType.safeToString.clauses" title="=&gt; String">clauses</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    override def <a title="(owner: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.cloneInfo">cloneInfo</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.cloneInfo.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      <a href="Symbols.scala.html#scala.reflect.internal;Symbols.createFromClonedSymbolsAtOwner" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol, tpe: Types.this.Type)(creator: (List[Types.this.Symbol], Types.this.Type) =&gt; Types.this.Type)Types.this.Type">createFromClonedSymbolsAtOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#scala.reflect.internal;Types;ExistentialType.cloneInfo.owner" title="Types.this.Symbol">owner</a>, <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.newExistentialType" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">)</span>

    override def <a title="(owner: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.atOwner">atOwner</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.atOwner.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="Symbols.scala.html#scala.reflect.internal;Symbols.allSymbolsHaveOwner" title="(syms: List[Types.this.Symbol], owner: Types.this.Symbol)Boolean">allSymbolsHaveOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#scala.reflect.internal;Types;ExistentialType.atOwner.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;ExistentialType.cloneInfo" title="(owner: Types.this.Symbol)Types.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.atOwner.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> else this

    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ExistentialType.kind">kind</a> = <span title="String(&quot;ExistentialType&quot;)" class="string">&quot;ExistentialType&quot;</span>

    def <a title="(op: Types.this.Type =&gt; Boolean)Boolean" id="scala.reflect.internal;Types;ExistentialType.withTypeVars(b9930e495d)">withTypeVars</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types;ExistentialType.withTypeVars(b9930e495d).op">op</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f)" title="(op: Types.this.Type =&gt; Boolean, depth: scala.reflect.internal.Depth)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(b9930e495d).op" title="Types.this.Type =&gt; Boolean">op</a>, <a href="Depth.scala.html#scala.reflect.internal.Depth.AnyDepth" title="=&gt; scala.reflect.internal.Depth">AnyDepth</a><span class="delimiter">)</span>

    def <a title="(op: Types.this.Type =&gt; Boolean, depth: scala.reflect.internal.Depth)Boolean" id="scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f)">withTypeVars</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).op">op</a>: Type =&gt; Boolean, <a title="scala.reflect.internal.Depth" id="scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).depth">depth</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).quantifiedFresh">quantifiedFresh</a> = <a href="Symbols.scala.html#scala.reflect.internal;Symbols.cloneSymbols" title="(syms: List[Types.this.Symbol])List[Types.this.Symbol]">cloneSymbols</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a><span class="delimiter">)</span>
      val tvars = <a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).quantifiedFresh" title="List[Types.this.Symbol]">quantifiedFresh</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="List[Types.this.TypeVar]" id="scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).tvars">map</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).tvars.$anonfun.tparam">tparam</a> =&gt; <a href="#scala.reflect.internal;Types.TypeVar.apply(7f26fdfb66)" title="(tparam: Types.this.Symbol)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).tvars.$anonfun.tparam" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span><span class="delimiter">)</span>
      val <a title="Types.this.Type" id="scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).underlying1">underlying1</a> = <a href="#scala.reflect.internal;Types;ExistentialType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="=&gt; List[Types.this.Symbol]">quantified</a>, <a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).tvars" title="List[Types.this.TypeVar]">tvars</a><span class="delimiter">)</span> <span class="comment">// fuse subst quantified -&gt; quantifiedFresh -&gt; tvars</span>
      <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Types.this.Type)Boolean">op</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).underlying1" title="Types.this.Type">underlying1</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
        <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints.solve" title="(tvars: List[Types.this.TypeVar], tparams: List[Types.this.Symbol], variances: List[scala.reflect.internal.Variance], upper: Boolean, depth: scala.reflect.internal.Depth)Boolean">solve</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).tvars" title="List[Types.this.TypeVar]">tvars</a>, <a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).quantifiedFresh" title="List[Types.this.Symbol]">quantifiedFresh</a>, <a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).quantifiedFresh" title="List[Types.this.Symbol]">quantifiedFresh</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Symbol =&gt; scala.reflect.internal.Variance)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],scala.reflect.internal.Variance,List[scala.reflect.internal.Variance]])List[scala.reflect.internal.Variance]">map</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).$anonfun.x$37">_</a> =&gt; <a href="Variance.scala.html#scala.reflect.internal.Variance.Invariant" title="=&gt; scala.reflect.internal.Variance">Invariant</a><span class="delimiter">)</span>, upper = false, <a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
        <a href="#scala.reflect.internal;Types.isWithinBounds" title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])Boolean">isWithinBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.NoPrefix.readResolve" title="Types.this.NoPrefix.type">NoPrefix</a>, <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a>, <a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).quantifiedFresh" title="List[Types.this.Symbol]">quantifiedFresh</a>, <a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).tvars" title="List[Types.this.TypeVar]">tvars</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.TypeVar =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeVar],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(746964343f).$anonfun.x$38" title="Types.this.TypeVar">_</a>.<a href="#scala.reflect.internal;Types;TypeVar.inst" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  object <a title="Types.this.ExistentialType.type" id="scala.reflect.internal;Types.ExistentialType.readResolve">ExistentialType</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;ExistentialTypeExtractor" title="Types.this.ExistentialTypeExtractor">ExistentialTypeExtractor</a>

  <span class="comment">/** A class containing the alternatives and type prefix of an overloaded symbol.
   *  Not used after phase `typer`.
   */</span>
  case class <a title="class OverloadedType extends Types.this.Type with Product with Serializable" id="scala.reflect.internal;Types.OverloadedType.readResolve">OverloadedType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;OverloadedType.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;OverloadedType.alternatives">alternatives</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;OverloadedType.prefix">prefix</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;OverloadedType.pre" title="=&gt; Types.this.Type">pre</a>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;OverloadedType.safeToString">safeToString</a> =
      <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;OverloadedType.alternatives" title="=&gt; List[Types.this.Symbol]">alternatives</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <a href="#scala.reflect.internal;Types;OverloadedType.pre" title="=&gt; Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.memberType" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot; &lt;and&gt; &quot;)" class="string">&quot; &lt;and&gt; &quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;OverloadedType.kind">kind</a> = <span title="String(&quot;OverloadedType&quot;)" class="string">&quot;OverloadedType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The canonical creator for OverloadedTypes.
   */</span>
  def <a title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.Type" id="scala.reflect.internal;Types.overloadedType">overloadedType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.overloadedType.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.overloadedType.alternatives">alternatives</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.overloadedType.alternatives" title="List[Types.this.Symbol]">alternatives</a> match <span class="delimiter">{</span>
    case <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>        =&gt; <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
    case <a title="Types.this.Symbol" id="scala.reflect.internal;Types.overloadedType.alt">alt</a> :: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> =&gt; <a href="#scala.reflect.internal;Types.overloadedType.pre" title="Types.this.Type">pre</a> <a href="#scala.reflect.internal;Types;Type.memberType" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a> <a href="#scala.reflect.internal;Types.overloadedType.alt" title="Types.this.Symbol">alt</a>
    case _          =&gt; <a href="#scala.reflect.internal;Types.OverloadedType.readResolve" title="(pre: Types.this.Type, alternatives: List[Types.this.Symbol])Types.this.OverloadedType">OverloadedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.overloadedType.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.overloadedType.alternatives" title="List[Types.this.Symbol]">alternatives</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  case class <a title="class ImportType extends Types.this.Type with Product with Serializable" id="scala.reflect.internal;Types.ImportType.readResolve">ImportType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Types.this.Tree" id="scala.reflect.internal;Types;ImportType.expr">expr</a>: <a href="Trees.scala.html#scala.reflect.internal;Trees;Tree" title="Types.this.Tree">Tree</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ImportType.safeToString">safeToString</a> = <span title="String(&quot;ImportType(&quot;)" class="string">&quot;ImportType(&quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.reflect.internal;Types;ImportType.expr" title="=&gt; Types.this.Tree">expr</a><span title="(x$1: Any)String">+</span><span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class remembering a type instantiation for some a set of overloaded
   *  polymorphic symbols.
   *  Not used after phase `typer`.
   */</span>
  case class <a title="class AntiPolyType extends Types.this.Type with Product with Serializable" id="scala.reflect.internal;Types.AntiPolyType.readResolve">AntiPolyType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;AntiPolyType.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;AntiPolyType.targs">targs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;AntiPolyType.safeToString">safeToString</a> =
      <a href="#scala.reflect.internal;Types;AntiPolyType.pre" title="=&gt; Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.toString" title="()String">toString</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;AntiPolyType.targs" title="=&gt; List[Types.this.Type]">targs</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;(with type arguments &quot;)" class="string">&quot;(with type arguments &quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>

    override def <a title="(sym: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types;AntiPolyType.memberType">memberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;AntiPolyType.memberType.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AntiPolyType.pre" title="=&gt; Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.memberType" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AntiPolyType.memberType.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types;AntiPolyType.targs" title="=&gt; List[Types.this.Type]">targs</a><span class="delimiter">)</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;AntiPolyType.kind">kind</a> = <span title="String(&quot;AntiPolyType&quot;)" class="string">&quot;AntiPolyType&quot;</span>
  <span class="delimiter">}</span>

  object <a title="Types.this.HasTypeMember.type" id="scala.reflect.internal;Types.HasTypeMember">HasTypeMember</a> <a href="#scala.reflect.internal;Types.HasTypeMember" title="Types.this.HasTypeMember.type" class="delimiter">{</a>
    def <a title="(name: Types.this.TypeName, tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.HasTypeMember.apply">apply</a><span class="delimiter">(</span><a title="Types.this.TypeName" id="scala.reflect.internal;Types.HasTypeMember.apply.name">name</a>: <a href="Names.scala.html#scala.reflect.internal;Names;TypeName" title="Types.this.TypeName">TypeName</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.HasTypeMember.apply.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      val <a title="Types.this.Type" id="scala.reflect.internal;Types.HasTypeMember.apply.bound">bound</a> = <a href="#scala.reflect.internal;Types.refinedType(08cdf2d3e2)" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="../../collection/immutable/List.scala.html#scala.collection.immutable.List.apply" title="(xs: Types.this.WildcardType.type*)List[Types.this.WildcardType.type]">List</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.WildcardType.readResolve" title="Types.this.WildcardType.type">WildcardType</a><span class="delimiter">)</span>, <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
      val <a title="Types.this.AliasTypeSymbol" id="scala.reflect.internal;Types.HasTypeMember.apply.bsym">bsym</a> = <a href="#scala.reflect.internal;Types.HasTypeMember.apply.bound" title="Types.this.Type">bound</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="Types.this.Symbol" id="scala.reflect.internal;Types.HasTypeMember.apply.bsym.qual$1">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.newAliasType$default$2" title="Types.this.Position" id="scala.reflect.internal;Types.HasTypeMember.apply.bsym.x$76">newAliasType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.HasTypeMember.apply.name" title="Types.this.TypeName" id="scala.reflect.internal;Types.HasTypeMember.apply.bsym.x$74">name</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types.HasTypeMember.apply.bsym" title="Types.this.AliasTypeSymbol">bsym</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="(info: Types.this.Type)bsym.type">setInfo</a> <a href="#scala.reflect.internal;Types.HasTypeMember.apply.tp" title="Types.this.Type">tp</a>
      <a href="#scala.reflect.internal;Types.HasTypeMember.apply.bound" title="Types.this.Type">bound</a>.<a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.enter" title="(sym: Types.this.AliasTypeSymbol)Types.this.AliasTypeSymbol">enter</a> <a href="#scala.reflect.internal;Types.HasTypeMember.apply.bsym" title="Types.this.AliasTypeSymbol">bsym</a>
      <a href="#scala.reflect.internal;Types.HasTypeMember.apply.bound" title="Types.this.Type">bound</a>
    <span class="delimiter">}</span>
    def <a title="(tp: Types.this.Type)Option[(Types.this.TypeName, Types.this.Type)]" id="scala.reflect.internal;Types.HasTypeMember.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.HasTypeMember.unapply.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Types.this.TypeName, Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>TypeName, Type<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types.HasTypeMember.unapply.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
      case RefinedType<span class="delimiter">(</span><a href="../../collection/generic/SeqFactory.scala.html#scala.collection.generic;SeqFactory.unapplySeq" title="(x: List[Types.this.Type])Some[List[Types.this.Type]]">List</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.WildcardType.readResolve" title="Types.this.WildcardType.type">WildcardType</a><span class="delimiter">)</span>, <a href="Scopes.scala.html#scala.reflect.internal;Scopes.Scope.unapplySeq" title="(decls: Types.this.Scope)Some[Seq[Types.this.Symbol]]">Scope</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.HasTypeMember.unapply.sym">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="../../Option.scala.html#scala;Some" title="(x: (Types.this.TypeName, Types.this.Type))Some[(Types.this.TypeName, Types.this.Type)]">Some</a><span class="delimiter">(</span><a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: Types.this.TypeName, _2: Types.this.Type)(Types.this.TypeName, Types.this.Type)" class="delimiter">(</a><a href="#scala.reflect.internal;Types.HasTypeMember.unapply.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym.NameType">name</a>.<a href="Names.scala.html#scala.reflect.internal;Names;Name.toTypeName" title="=&gt; Types.this.TypeName">toTypeName</a>, <a href="#scala.reflect.internal;Types.HasTypeMember.unapply.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case _ =&gt; <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  object <a title="Types.this.ArrayTypeRef.type" id="scala.reflect.internal;Types.ArrayTypeRef">ArrayTypeRef</a> <a href="#scala.reflect.internal;Types.ArrayTypeRef" title="Types.this.ArrayTypeRef.type" class="delimiter">{</a>
    def <a title="(tp: Types.this.Type)Option[Types.this.Type]" id="scala.reflect.internal;Types.ArrayTypeRef.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.ArrayTypeRef.unapply.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.ArrayTypeRef.unapply.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
      case TypeRef<span class="delimiter">(</span>_, <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ArrayClass" title="=&gt; Types.this.ClassSymbol">ArrayClass</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.ArrayTypeRef.unapply.arg">arg</a> :: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> =&gt; <a href="../../Option.scala.html#scala;Some" title="(x: Types.this.Type)Some[Types.this.Type]">Some</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.ArrayTypeRef.unapply.arg" title="Types.this.Type">arg</a><span class="delimiter">)</span>
      case _                                  =&gt; <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">//@M</span>
  <span class="comment">// a TypeVar used to be a case class with only an origin and a constr</span>
  <span class="comment">// then, constr became mutable (to support UndoLog, I guess),</span>
  <span class="comment">// but pattern-matching returned the original constr0 (a bug)</span>
  <span class="comment">// now, pattern-matching returns the most recent constr</span>
  object <a title="Types.this.TypeVar.type" id="scala.reflect.internal;Types.TypeVar.readResolve">TypeVar</a> <a href="#scala.reflect.internal;Types.TypeVar.readResolve" title="Types.this.TypeVar.type" class="delimiter">{</a>
    @inline final def <a title="[T](action: String, msg: =&gt; String)(value: T)T" id="scala.reflect.internal;Types.TypeVar.trace">trace</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal;Types.TypeVar.trace;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="scala.reflect.internal;Types.TypeVar.trace.action">action</a>: <span title="String">String</span>, <a title="=&gt; String" id="scala.reflect.internal;Types.TypeVar.trace.msg">msg</a>: =&gt; String<span class="delimiter">)</span><span class="delimiter">(</span><a title="T" id="scala.reflect.internal;Types.TypeVar.trace.value">value</a>: <a href="#scala.reflect.internal;Types.TypeVar.trace;T" title="T">T</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types.TypeVar.trace;T" title="T">T</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.traceTypeVars" title="=&gt; Boolean">traceTypeVars</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="String" id="scala.reflect.internal;Types.TypeVar.trace.s">s</a> = <a href="#scala.reflect.internal;Types.TypeVar.trace.msg" title="=&gt; String">msg</a> match <span class="delimiter">{</span>
          case <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>   =&gt; <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
          case <a title="String" id="scala.reflect.internal;Types.TypeVar.trace.s.str">str</a>  =&gt; <span title="String(&quot;( &quot;)" class="string">&quot;( &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types.TypeVar.trace.s.str" title="String">str</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; )&quot;)" class="string">&quot; )&quot;</span>
        <span class="delimiter">}</span>
        <a href="../../Console.scala.html#scala.Console" title="Console.type">Console</a>.<a href="../../Console.scala.html#scala.Console.err" title="=&gt; java.io.PrintStream">err</a>.<span title="(x$1: String)Unit">println</span><span class="delimiter">(</span><a href="../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;[%10s] %-25s%s&quot;</a>.<a href="../../collection/immutable/StringLike.scala.html#scala.collection.immutable;StringLike.format" title="(args: Any*)String">format</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.trace.action" title="String">action</a>, <a href="#scala.reflect.internal;Types.TypeVar.trace.value" title="T">value</a>, <a href="#scala.reflect.internal;Types.TypeVar.trace.s" title="String">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal;Types.TypeVar.trace.value" title="T">value</a>
    <span class="delimiter">}</span>

    <span class="comment">/** Create a new TypeConstraint based on the given symbol.
     */</span>
    private def <a title="(tparam: Types.this.Symbol)Types.this.TypeConstraint" id="scala.reflect.internal;Types.TypeVar.deriveConstraint">deriveConstraint</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.TypeVar.deriveConstraint.tparam">tparam</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint" title="Types.this.TypeConstraint">TypeConstraint</a> = <span class="delimiter">{</span>
      <span class="comment">/** Must force the type parameter's info at this point
       *  or things don't end well for higher-order type params.
       *  See SI-5359.
       */</span>
      val <a title="Types.this.TypeBounds" id="scala.reflect.internal;Types.TypeVar.deriveConstraint.bounds">bounds</a>  = <a href="#scala.reflect.internal;Types.TypeVar.deriveConstraint.tparam" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.bounds" title="=&gt; Types.this.TypeBounds">bounds</a>
      <span class="comment">/* We can seed the type constraint with the type parameter
       * bounds as long as the types are concrete.  This should lower
       * the complexity of the search even if it doesn't improve
       * any results.
       */</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.propagateParameterBoundsToTypeVars" title="=&gt; Boolean">propagateParameterBoundsToTypeVars</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val exclude = <a href="#scala.reflect.internal;Types.TypeVar.deriveConstraint.bounds" title="Types.this.TypeBounds">bounds</a>.<a href="#scala.reflect.internal;Types;TypeBounds.isEmptyBounds" title="=&gt; Boolean">isEmptyBounds</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="Boolean" id="scala.reflect.internal;Types.TypeVar.deriveConstraint.exclude">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.deriveConstraint.bounds" title="Types.this.TypeBounds">bounds</a> <a href="#scala.reflect.internal;Types;Type.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types.typeIsNonClassType" title="=&gt; Types.this.Type =&gt; Boolean">typeIsNonClassType</a><span class="delimiter">)</span>

        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.deriveConstraint.exclude" title="Boolean">exclude</a><span class="delimiter">)</span> new <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint" title="Types.this.TypeConstraint">TypeConstraint</a>
        else <a href="#scala.reflect.internal;Types.TypeVar.readResolve" title="Types.this.TypeVar.type">TypeVar</a>.<a href="#scala.reflect.internal;Types.TypeVar.trace" title="(action: String, msg: =&gt; String)(value: Types.this.TypeConstraint)Types.this.TypeConstraint">trace</a><span class="delimiter">(</span><span title="String(&quot;constraint&quot;)" class="string">&quot;constraint&quot;</span>, <span title="String(&quot;For &quot;)" class="string">&quot;For &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types.TypeVar.deriveConstraint.tparam" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.fullLocationString" title="=&gt; String">fullLocationString</a><span class="delimiter">)</span><span class="delimiter">(</span>new <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.deriveConstraint.bounds" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      else new <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint" title="Types.this.TypeConstraint">TypeConstraint</a>
    <span class="delimiter">}</span>
    def <a title="(tparam: Types.this.Symbol)Types.this.TypeVar" id="scala.reflect.internal;Types.TypeVar.untouchable">untouchable</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.TypeVar.untouchable.tparam">tparam</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a>                 = <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(a212b80a96)" title="(tparam: Types.this.Symbol, untouchable: Boolean)Types.this.TypeVar">createTypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.untouchable.tparam" title="Types.this.Symbol">tparam</a>, untouchable = true<span class="delimiter">)</span>
    def <a title="(tparam: Types.this.Symbol)Types.this.TypeVar" id="scala.reflect.internal;Types.TypeVar.apply(7f26fdfb66)">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.TypeVar.apply(7f26fdfb66).tparam">tparam</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a>                       = <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(a212b80a96)" title="(tparam: Types.this.Symbol, untouchable: Boolean)Types.this.TypeVar">createTypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.apply(7f26fdfb66).tparam" title="Types.this.Symbol">tparam</a>, untouchable = false<span class="delimiter">)</span>
    def <a title="(origin: Types.this.Type, constr: Types.this.TypeConstraint)Types.this.TypeVar" id="scala.reflect.internal;Types.TypeVar.apply(cf74f7f79a)">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.TypeVar.apply(cf74f7f79a).origin">origin</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.TypeConstraint" id="scala.reflect.internal;Types.TypeVar.apply(cf74f7f79a).constr">constr</a>: <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint" title="Types.this.TypeConstraint">TypeConstraint</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a> = <a href="#scala.reflect.internal;Types.TypeVar.apply(d4803f064b)" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">apply</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.apply(cf74f7f79a).origin" title="Types.this.Type">origin</a>, <a href="#scala.reflect.internal;Types.TypeVar.apply(cf74f7f79a).constr" title="Types.this.TypeConstraint">constr</a>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
    def <a title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar" id="scala.reflect.internal;Types.TypeVar.apply(d4803f064b)">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.TypeVar.apply(d4803f064b).origin">origin</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.TypeConstraint" id="scala.reflect.internal;Types.TypeVar.apply(d4803f064b).constr">constr</a>: <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint" title="Types.this.TypeConstraint">TypeConstraint</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.TypeVar.apply(d4803f064b).args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.TypeVar.apply(d4803f064b).params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a> =
      <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816)" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol], untouchable: Boolean)Types.this.TypeVar">createTypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.apply(d4803f064b).origin" title="Types.this.Type">origin</a>, <a href="#scala.reflect.internal;Types.TypeVar.apply(d4803f064b).constr" title="Types.this.TypeConstraint">constr</a>, <a href="#scala.reflect.internal;Types.TypeVar.apply(d4803f064b).args" title="List[Types.this.Type]">args</a>, <a href="#scala.reflect.internal;Types.TypeVar.apply(d4803f064b).params" title="List[Types.this.Symbol]">params</a>, untouchable = false<span class="delimiter">)</span>

    <span class="comment">/** This is the only place TypeVars should be instantiated.
     */</span>
    private def <a title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol], untouchable: Boolean)Types.this.TypeVar" id="scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816)">createTypeVar</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).origin">origin</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.TypeConstraint" id="scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).constr">constr</a>: <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint" title="Types.this.TypeConstraint">TypeConstraint</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Boolean" id="scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).untouchable">untouchable</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a> = <span class="delimiter">{</span>
      val <a title="&lt;refinement of Types.this.TypeVar&gt; extends Types.this.TypeVar" id="scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).tv">tv</a> = <span class="delimiter">(</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).args" title="List[Types.this.Type]">args</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).params" title="List[Types.this.Symbol]">params</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).untouchable" title="Boolean">untouchable</a><span class="delimiter">)</span> new <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="&lt;$anon: Types.this.TypeVar with Types.this.UntouchableTypeVar&gt; extends Types.this.TypeVar with Types.this.UntouchableTypeVar">TypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).origin" title="Types.this.Type">origin</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).constr" title="Types.this.TypeConstraint">constr</a><span class="delimiter">)</span> with <a href="#scala.reflect.internal;Types;UntouchableTypeVar" title="Types.this.UntouchableTypeVar">UntouchableTypeVar</a>
          else new <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="&lt;$anon: Types.this.TypeVar&gt; extends Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).origin" title="Types.this.Type">origin</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).constr" title="Types.this.TypeConstraint">constr</a><span class="delimiter">)</span> <span class="delimiter">{</span><span class="delimiter">}</span>
        <span class="delimiter">}</span>
        else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).args" title="List[Types.this.Type]">args</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.size" title="=&gt; Int">size</a> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).params" title="List[Types.this.Symbol]">params</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.size" title="=&gt; Int">size</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).untouchable" title="Boolean">untouchable</a><span class="delimiter">)</span> new <a href="#scala.reflect.internal;Types;AppliedTypeVar" title="&lt;$anon: Types.this.AppliedTypeVar with Types.this.UntouchableTypeVar&gt; extends Types.this.AppliedTypeVar with Types.this.UntouchableTypeVar">AppliedTypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).origin" title="Types.this.Type">origin</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).constr" title="Types.this.TypeConstraint">constr</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).params" title="List[Types.this.Symbol]">params</a> <a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.zip" title="(that: scala.collection.GenIterable[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Types.this.Type),List[(Types.this.Symbol, Types.this.Type)]])List[(Types.this.Symbol, Types.this.Type)]">zip</a> <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> with <a href="#scala.reflect.internal;Types;UntouchableTypeVar" title="Types.this.UntouchableTypeVar">UntouchableTypeVar</a>
          else new <a href="#scala.reflect.internal;Types;AppliedTypeVar" title="Types.this.AppliedTypeVar">AppliedTypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).origin" title="Types.this.Type">origin</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).constr" title="Types.this.TypeConstraint">constr</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).params" title="List[Types.this.Symbol]">params</a> <a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.zip" title="(that: scala.collection.GenIterable[Types.this.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],(Types.this.Symbol, Types.this.Type),List[(Types.this.Symbol, Types.this.Type)]])List[(Types.this.Symbol, Types.this.Type)]">zip</a> <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).args" title="List[Types.this.Type]">args</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).untouchable" title="Boolean">untouchable</a><span class="delimiter">)</span> new <a href="#scala.reflect.internal;Types;HKTypeVar" title="&lt;$anon: Types.this.HKTypeVar with Types.this.UntouchableTypeVar&gt; extends Types.this.HKTypeVar with Types.this.UntouchableTypeVar">HKTypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).origin" title="Types.this.Type">origin</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).constr" title="Types.this.TypeConstraint">constr</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).params" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span> with <a href="#scala.reflect.internal;Types;UntouchableTypeVar" title="Types.this.UntouchableTypeVar">UntouchableTypeVar</a>
          else new <a href="#scala.reflect.internal;Types;HKTypeVar" title="Types.this.HKTypeVar">HKTypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).origin" title="Types.this.Type">origin</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).constr" title="Types.this.TypeConstraint">constr</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).params" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        else throw new <a href="../../package.scala.html#scala.package;Error" title="Error">Error</a><span class="delimiter">(</span><span title="String(&quot;Invalid TypeVar construction: &quot;)" class="string">&quot;Invalid TypeVar construction: &quot;</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="../../Tuple4.scala.html#scala;Tuple4" title="(_1: Types.this.Type, _2: Types.this.TypeConstraint, _3: List[Types.this.Type], _4: List[Types.this.Symbol])(Types.this.Type, Types.this.TypeConstraint, List[Types.this.Type], List[Types.this.Symbol])" class="delimiter">(</a><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).origin" title="Types.this.Type">origin</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).constr" title="Types.this.TypeConstraint">constr</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).args" title="List[Types.this.Type]">args</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).params" title="List[Types.this.Symbol]">params</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>

      <a href="#scala.reflect.internal;Types.TypeVar.trace" title="(action: String, msg: =&gt; String)(value: Types.this.TypeVar)Types.this.TypeVar">trace</a><span class="delimiter">(</span><span title="String(&quot;create&quot;)" class="string">&quot;create&quot;</span>, <span title="String(&quot;In &quot;)" class="string">&quot;In &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).tv" title="&lt;refinement of Types.this.TypeVar&gt; extends Types.this.TypeVar">tv</a>.<a href="#scala.reflect.internal;Types;TypeVar.originLocation" title="=&gt; String">originLocation</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816).tv" title="&lt;refinement of Types.this.TypeVar&gt; extends Types.this.TypeVar">tv</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    private def <a title="(tparam: Types.this.Symbol, untouchable: Boolean)Types.this.TypeVar" id="scala.reflect.internal;Types.TypeVar.createTypeVar(a212b80a96)">createTypeVar</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.TypeVar.createTypeVar(a212b80a96).tparam">tparam</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Boolean" id="scala.reflect.internal;Types.TypeVar.createTypeVar(a212b80a96).untouchable">untouchable</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a> =
      <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(431d6e1816)" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol], untouchable: Boolean)Types.this.TypeVar">createTypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(a212b80a96).tparam" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpeHK" title="=&gt; Types.this.Type">tpeHK</a>, <a href="#scala.reflect.internal;Types.TypeVar.deriveConstraint" title="(tparam: Types.this.Symbol)Types.this.TypeConstraint">deriveConstraint</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(a212b80a96).tparam" title="Types.this.Symbol">tparam</a><span class="delimiter">)</span>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(a212b80a96).tparam" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#scala.reflect.internal;Types.TypeVar.createTypeVar(a212b80a96).untouchable" title="Boolean">untouchable</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Precondition: params.nonEmpty.  (args.nonEmpty enforced structurally.)
   */</span>
  class <a title="class HKTypeVar extends Types.this.TypeVar" id="scala.reflect.internal;Types;HKTypeVar">HKTypeVar</a><a href="#scala.reflect.internal;Types;HKTypeVar" title="Types.this.HKTypeVar" class="delimiter">(</a>
    <a title="Types.this.Type" id="scala.reflect.internal;Types;HKTypeVar._origin">_origin</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>,
    <a title="Types.this.TypeConstraint" id="scala.reflect.internal;Types;HKTypeVar._constr">_constr</a>: <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint" title="Types.this.TypeConstraint">TypeConstraint</a>,
    override val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;HKTypeVar.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
  <span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;HKTypeVar._origin" title="Types.this.Type">_origin</a>, <a href="#scala.reflect.internal;Types;HKTypeVar._constr" title="Types.this.TypeConstraint">_constr</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <a href="../../Predef.scala.html#scala.Predef.require(a2f0e4a061)" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;HKTypeVar.params" title="=&gt; List[Types.this.Symbol]">params</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a>, this<span class="delimiter">)</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;HKTypeVar.isHigherKinded">isHigherKinded</a>          = true
  <span class="delimiter">}</span>

  <span class="comment">/** Precondition: zipped params/args nonEmpty.  (Size equivalence enforced structurally.)
   */</span>
  class <a title="class AppliedTypeVar extends Types.this.TypeVar" id="scala.reflect.internal;Types;AppliedTypeVar">AppliedTypeVar</a><a href="#scala.reflect.internal;Types;AppliedTypeVar" title="Types.this.AppliedTypeVar" class="delimiter">(</a>
    <a title="Types.this.Type" id="scala.reflect.internal;Types;AppliedTypeVar._origin">_origin</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>,
    <a title="Types.this.TypeConstraint" id="scala.reflect.internal;Types;AppliedTypeVar._constr">_constr</a>: <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint" title="Types.this.TypeConstraint">TypeConstraint</a>,
    <a title="List[(Types.this.Symbol, Types.this.Type)]" id="scala.reflect.internal;Types;AppliedTypeVar.zippedArgs">zippedArgs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[(Types.this.Symbol, Types.this.Type)]">List</a><span class="delimiter">[</span><span class="delimiter">(</span>Symbol, Type<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AppliedTypeVar._origin" title="Types.this.Type">_origin</a>, <a href="#scala.reflect.internal;Types;AppliedTypeVar._constr" title="Types.this.TypeConstraint">_constr</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <a href="../../Predef.scala.html#scala.Predef.require(a2f0e4a061)" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AppliedTypeVar.zippedArgs" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a>, this<span class="delimiter">)</span>

    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;AppliedTypeVar.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;AppliedTypeVar.zippedArgs" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: ((Types.this.Symbol, Types.this.Type)) =&gt; Types.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Symbol, Types.this.Type)],Types.this.Symbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AppliedTypeVar.params.$anonfun.x$39" title="(Types.this.Symbol, Types.this.Type)">_</a>.<a href="../../Tuple2.scala.html#scala;Tuple2._1" title="=&gt; Types.this.Symbol">_1</a><span class="delimiter">)</span>
    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;AppliedTypeVar.typeArgs">typeArgs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types;AppliedTypeVar.zippedArgs" title="List[(Types.this.Symbol, Types.this.Type)]">zippedArgs</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: ((Types.this.Symbol, Types.this.Type)) =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[(Types.this.Symbol, Types.this.Type)],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AppliedTypeVar.typeArgs.$anonfun.x$40" title="(Types.this.Symbol, Types.this.Type)">_</a>.<a href="../../Tuple2.scala.html#scala;Tuple2._2" title="=&gt; Types.this.Type">_2</a><span class="delimiter">)</span>

    override def <a title="=&gt; String" id="scala.reflect.internal;Types;AppliedTypeVar.safeToString">safeToString</a>: <span title="String">String</span> = super.<a href="#scala.reflect.internal;Types;TypeVar.safeToString" title="=&gt; String">safeToString</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;AppliedTypeVar.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a>.<a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Type =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],String,List[String]])List[String]">map</a><a href="../../collection/immutable/List.scala.html#scala.collection.immutable.List.canBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</a><a href="#scala.reflect.internal;Types;AppliedTypeVar.safeToString.$anonfun.x$41" title="Types.this.Type">_</a>.<a href="#scala.reflect.internal;Types;Type.safeToString" title="=&gt; String">safeToString</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  trait <a title="trait UntouchableTypeVar extends Types.this.TypeVar" id="scala.reflect.internal;Types;UntouchableTypeVar">UntouchableTypeVar</a> extends <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a> <span class="delimiter">{</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;UntouchableTypeVar.untouchable">untouchable</a> = true
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;UntouchableTypeVar.isGround">isGround</a> = true
    override def <a title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean" id="scala.reflect.internal;Types;UntouchableTypeVar.registerTypeEquality">registerTypeEquality</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;UntouchableTypeVar.registerTypeEquality.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Boolean" id="scala.reflect.internal;Types;UntouchableTypeVar.registerTypeEquality.typeVarLHS">typeVarLHS</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;UntouchableTypeVar.registerTypeEquality.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
      case <a title="Types.this.TypeVar" id="scala.reflect.internal;Types;UntouchableTypeVar.registerTypeEquality.t">t</a>: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a> if <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;UntouchableTypeVar.registerTypeEquality.t" title="Types.this.TypeVar">t</a>.<a href="#scala.reflect.internal;Types;TypeVar.untouchable" title="=&gt; Boolean">untouchable</a> =&gt;
        <a href="#scala.reflect.internal;Types;UntouchableTypeVar.registerTypeEquality.t" title="Types.this.TypeVar">t</a>.<a href="#scala.reflect.internal;Types;TypeVar.registerTypeEquality" title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean">registerTypeEquality</a><span class="delimiter">(</span>this, <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;UntouchableTypeVar.registerTypeEquality.typeVarLHS" title="Boolean">typeVarLHS</a><span class="delimiter">)</span>
      case _ =&gt;
        super.<a href="#scala.reflect.internal;Types;TypeVar.registerTypeEquality" title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean">registerTypeEquality</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;UntouchableTypeVar.registerTypeEquality.tp" title="Types.this.Type">tp</a>, <a href="#scala.reflect.internal;Types;UntouchableTypeVar.registerTypeEquality.typeVarLHS" title="Boolean">typeVarLHS</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    override def <a title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean" id="scala.reflect.internal;Types;UntouchableTypeVar.registerBound">registerBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;UntouchableTypeVar.registerBound.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Boolean" id="scala.reflect.internal;Types;UntouchableTypeVar.registerBound.isLowerBound">isLowerBound</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>, <a title="Boolean" id="scala.reflect.internal;Types;UntouchableTypeVar.registerBound$default$3">isNumericBound</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types;UntouchableTypeVar.registerBound.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
      case <a title="Types.this.TypeVar" id="scala.reflect.internal;Types;UntouchableTypeVar.registerBound.t">t</a>: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a> if <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;UntouchableTypeVar.registerBound.t" title="Types.this.TypeVar">t</a>.<a href="#scala.reflect.internal;Types;TypeVar.untouchable" title="=&gt; Boolean">untouchable</a> =&gt;
        <a href="#scala.reflect.internal;Types;UntouchableTypeVar.registerBound.t" title="Types.this.TypeVar">t</a>.<a href="#scala.reflect.internal;Types;TypeVar.registerBound" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span>this, <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;UntouchableTypeVar.registerBound.isLowerBound" title="Boolean">isLowerBound</a>, <a href="#scala.reflect.internal;Types;UntouchableTypeVar.registerBound$default$3" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
      case _ =&gt;
        super.<a href="#scala.reflect.internal;Types;TypeVar.registerBound" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;UntouchableTypeVar.registerBound.tp" title="Types.this.Type">tp</a>, <a href="#scala.reflect.internal;Types;UntouchableTypeVar.registerBound.isLowerBound" title="Boolean">isLowerBound</a>, <a href="#scala.reflect.internal;Types;UntouchableTypeVar.registerBound$default$3" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class representing a type variable: not used after phase `typer`.
   *
   *  A higher-kinded TypeVar has params (Symbols) and typeArgs (Types).
   *  A TypeVar with nonEmpty typeArgs can only be instantiated by a higher-kinded
   *  type that can be applied to those args.  A TypeVar is much like a TypeRef,
   *  except it has special logic for equality and subtyping.
   *
   *  Precondition for this class, enforced structurally: args.isEmpty &amp;&amp; params.isEmpty.
   */</span>
  abstract case class <a href="#scala.reflect.internal;Types;TypeVar.x$0" title="(x$0: Types.this.TypeVar)Option[(Types.this.Type, Types.this.TypeConstraint)]" id="scala.reflect.internal;Types;TypeVar.canEqual">TypeVar</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a>
                               <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.origin">origin</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>,
    var <a title="Types.this.TypeConstraint" id="scala.reflect.internal;Types;TypeVar.constr">constr</a>: <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint" title="Types.this.TypeConstraint">TypeConstraint</a>
  <span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> <span class="delimiter">{</span>

    <span class="comment">// We don't want case class equality/hashing as TypeVar-s are mutable,</span>
    <span class="comment">// and TypeRefs based on them get wrongly `uniqued` otherwise. See SI-7226.</span>
    override def <a title="()Int" id="scala.reflect.internal;Types;TypeVar.hashCode">hashCode</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> = <span title="System.type">System</span>.<span title="(x$1: Any)Int">identityHashCode</span><span class="delimiter">(</span>this<span class="delimiter">)</span>
    override def <a title="(other: Any)Boolean" id="scala.reflect.internal;Types;TypeVar.equals">equals</a><span class="delimiter">(</span><a title="Any" id="scala.reflect.internal;Types;TypeVar.equals.other">other</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = this <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;TypeVar.equals.other" title="Any">other</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="AnyRef" class="delimiter">[</span><span title="AnyRef">AnyRef</span><span class="delimiter">]</span>

    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeVar.untouchable">untouchable</a> = false   <span class="comment">// by other typevars</span>
    override def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.internal;Types;TypeVar.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
    override def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.internal;Types;TypeVar.typeArgs">typeArgs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeVar.isHigherKinded">isHigherKinded</a> = false

    <span class="comment">/** The constraint associated with the variable
     *  Syncnote: Type variables are assumed to be used from only one
     *  thread. They are not exposed in api.Types and are used only locally
     *  in operations that are exposed from types. Hence, no syncing of `constr`
     *  or `encounteredHigherLevel` or `suspended` accesses should be necessary.
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeVar.instValid">instValid</a> = <a href="#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.instValid" title="=&gt; Boolean">instValid</a>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;TypeVar.inst">inst</a> = <a href="#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst" title="=&gt; Types.this.Type">inst</a>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeVar.instWithinBounds">instWithinBounds</a> = <a href="#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.instWithinBounds" title="=&gt; Boolean">instWithinBounds</a>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeVar.isGround">isGround</a> = <a href="#scala.reflect.internal;Types;TypeVar.instValid" title="=&gt; Boolean">instValid</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;TypeVar.inst" title="=&gt; Types.this.Type">inst</a>.<a href="#scala.reflect.internal;Types;Type.isGround" title="=&gt; Boolean">isGround</a>

    <span class="comment">/** The variable's skolemization level */</span>
    val <a title="Int" id="scala.reflect.internal;Types;TypeVar.level">level</a> = <a href="#scala.reflect.internal;Types.skolemizationLevel" title="=&gt; Int">skolemizationLevel</a>

    <span class="comment">/** Applies this TypeVar to type arguments, if arity matches.
     *
     * Different applications of the same type constructor variable `?CC`,
     * e.g. `?CC[Int]` and `?CC[String]`, are modeled as distinct instances of `TypeVar`
     * that share a `TypeConstraint`, so that the comparisons `?CC[Int] &lt;:&lt; List[Int]`
     * and `?CC[String] &lt;:&lt; Iterable[String]` result in `?CC` being upper-bounded by `List` and `Iterable`.
     *
     * Applying the wrong number of type args results in a TypeVar whose instance is set to `ErrorType`.
     */</span>
    def <a title="(newArgs: List[Types.this.Type])Types.this.TypeVar" id="scala.reflect.internal;Types;TypeVar.applyArgs">applyArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types;TypeVar.applyArgs.newArgs">newArgs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.applyArgs.newArgs" title="List[Types.this.Type]">newArgs</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;TypeVar.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
        this
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.applyArgs.newArgs" title="List[Types.this.Type]">newArgs</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.size" title="=&gt; Int">size</a> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <a href="#scala.reflect.internal;Types;TypeVar.params" title="=&gt; List[Types.this.Symbol]">params</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.size" title="=&gt; Int">size</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="Types.this.TypeVar" id="scala.reflect.internal;Types;TypeVar.applyArgs.tv">tv</a> = <a href="#scala.reflect.internal;Types.TypeVar.apply(d4803f064b)" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.origin" title="=&gt; Types.this.Type">origin</a>, <a href="#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; Types.this.TypeConstraint">constr</a>, <a href="#scala.reflect.internal;Types;TypeVar.applyArgs.newArgs" title="List[Types.this.Type]">newArgs</a>, <a href="#scala.reflect.internal;Types;TypeVar.params" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types;TypeVar.applyArgs.tv" title="Types.this.TypeVar">tv</a>.<a href="#scala.reflect.internal;Types;TypeVar.linkSuspended" title="(origin: Types.this.TypeVar)Unit">linkSuspended</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types.TypeVar.readResolve" title="Types.this.TypeVar.type">TypeVar</a>.<a href="#scala.reflect.internal;Types.TypeVar.trace" title="(action: String, msg: =&gt; String)(value: Types.this.TypeVar)Types.this.TypeVar">trace</a><span class="delimiter">(</span><span title="String(&quot;applyArgs&quot;)" class="string">&quot;applyArgs&quot;</span>, <span title="String(&quot;In &quot;)" class="string">&quot;In &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeVar.originLocation" title="=&gt; String">originLocation</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, apply args &quot;)" class="string">&quot;, apply args &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeVar.applyArgs.newArgs" title="List[Types.this.Type]">newArgs</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; to &quot;)" class="string">&quot; to &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeVar.originName" title="=&gt; String">originName</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.applyArgs.tv" title="Types.this.TypeVar">tv</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      else
        <a href="#scala.reflect.internal;Types.TypeVar.apply(7f26fdfb66)" title="(tparam: Types.this.Symbol)Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;TypeVar.setInst" title="(tp: Types.this.Type)Types.this.TypeVar">setInst</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.ErrorType.readResolve" title="Types.this.ErrorType.type">ErrorType</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    <span class="comment">// newArgs.length may differ from args.length (could've been empty before)</span>
    <span class="comment">//</span>
    <span class="comment">// !!! @PP - I need an example of this, since this exception never triggers</span>
    <span class="comment">// even though I am requiring the size match.</span>
    <span class="comment">//</span>
    <span class="comment">// example: when making new typevars, you start out with C[A], then you replace C by ?C, which should yield ?C[A], then A by ?A, ?C[?A]</span>
    <span class="comment">// we need to track a TypeVar's arguments, and map over them (see TypeMap::mapOver)</span>
    <span class="comment">// TypeVars get applied to different arguments over time (in asSeenFrom)</span>
     <span class="comment">// -- see pos/tcpoly_infer_implicit_tuplewrapper.scala</span>
    <span class="comment">// thus: make new TypeVar's for every application of a TV to args,</span>
    <span class="comment">// inference may generate several TypeVar's for a single type parameter that must be inferred,</span>
    <span class="comment">// only one of them is in the set of tvars that need to be solved, but</span>
    <span class="comment">// they share the same TypeConstraint instance</span>

    <span class="comment">// When comparing to types containing skolems, remember the highest level</span>
    <span class="comment">// of skolemization. If that highest level is higher than our initial</span>
    <span class="comment">// skolemizationLevel, we can't re-use those skolems as the solution of this</span>
    <span class="comment">// typevar, which means we'll need to repack our inst into a fresh existential.</span>
    <span class="comment">// were we compared to skolems at a higher skolemizationLevel?</span>
    <span class="comment">// EXPERIMENTAL: value will not be considered unless enableTypeVarExperimentals is true</span>
    <span class="comment">// see SI-5729 for why this is still experimental</span>
    private var <a title="Boolean" id="scala.reflect.internal;Types;TypeVar.encounteredHigherLevel_=">encounteredHigherLevel</a> = false
    private def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeVar.shouldRepackType">shouldRepackType</a> = <a href="#scala.reflect.internal;Types.enableTypeVarExperimentals" title="=&gt; Boolean">enableTypeVarExperimentals</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;TypeVar.encounteredHigherLevel_=" title="=&gt; Boolean">encounteredHigherLevel</a>

    <span class="comment">// &lt;region name=&quot;constraint mutators + undoLog&quot;&gt;</span>
    <span class="comment">// invariant: before mutating constr, save old state in undoLog</span>
    <span class="comment">// (undoLog is used to reset constraints to avoid piling up unrelated ones)</span>
    def <a title="(tp: Types.this.Type)TypeVar.this.type" id="scala.reflect.internal;Types;TypeVar.setInst">setInst</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.setInst.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: this.type = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.setInst.tp" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> this<span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.log" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;TypeVar cycle: called setInst passing &quot;)">TypeVar cycle: called setInst passing $</span>this<a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="String(&quot; to itself.&quot;)" class="string"> to itself.&quot;</a><span class="delimiter">)</span>
        return this
      <span class="delimiter">}</span>
      <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints.undoLog" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;UndoLog.record" title="(tv: Types.this.TypeVar)Unit">record</a> this
      <span class="comment">// if we were compared against later typeskolems, repack the existential,</span>
      <span class="comment">// because skolems are only compatible if they were created at the same level</span>
      val <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.setInst.res">res</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.shouldRepackType" title="=&gt; Boolean">shouldRepackType</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.repackExistential" title="(tp: Types.this.Type)Types.this.Type">repackExistential</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.setInst.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span> else <a href="#scala.reflect.internal;Types;TypeVar.setInst.tp" title="Types.this.Type">tp</a>
      <a href="#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst_=" title="(x$1: Types.this.Type)Unit">inst</a> = <a href="#scala.reflect.internal;Types.TypeVar.readResolve" title="Types.this.TypeVar.type">TypeVar</a>.<a href="#scala.reflect.internal;Types.TypeVar.trace" title="(action: String, msg: =&gt; String)(value: Types.this.Type)Types.this.Type">trace</a><span class="delimiter">(</span><span title="String(&quot;setInst&quot;)" class="string">&quot;setInst&quot;</span>, <span title="String(&quot;In &quot;)" class="string">&quot;In &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeVar.originLocation" title="=&gt; String">originLocation</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeVar.originName" title="=&gt; String">originName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeVar.setInst.res" title="Types.this.Type">res</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.setInst.res" title="Types.this.Type">res</a><span class="delimiter">)</span>
      this
    <span class="delimiter">}</span>

    def <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="scala.reflect.internal;Types;TypeVar.addLoBound">addLoBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.addLoBound.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Boolean" id="scala.reflect.internal;Types;TypeVar.addLoBound$default$2">isNumericBound</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false<span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.addLoBound.tp" title="Types.this.Type">tp</a> <span title="(x$1: Any)Boolean">!=</span> this, <a href="#scala.reflect.internal;Types;TypeVar.addLoBound.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span> <span class="comment">// implies there is a cycle somewhere (?)</span>
      <span class="comment">//println(&quot;addLoBound: &quot;+(safeToString, debugString(tp))) //DEBUG</span>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;TypeVar.sharesConstraints" title="(other: Types.this.Type)Boolean">sharesConstraints</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.addLoBound.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints.undoLog" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;UndoLog.record" title="(tv: Types.this.TypeVar)Unit">record</a> this
        <a href="#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addLoBound" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.addLoBound.tp" title="Types.this.Type">tp</a>, <a href="#scala.reflect.internal;Types;TypeVar.addLoBound$default$2" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    def <a title="(tp: Types.this.Type, isNumericBound: Boolean)Unit" id="scala.reflect.internal;Types;TypeVar.addHiBound">addHiBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.addHiBound.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Boolean" id="scala.reflect.internal;Types;TypeVar.addHiBound$default$2">isNumericBound</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false<span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// assert(tp != this)</span>
      <span class="comment">//println(&quot;addHiBound: &quot;+(safeToString, debugString(tp))) //DEBUG</span>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;TypeVar.sharesConstraints" title="(other: Types.this.Type)Boolean">sharesConstraints</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.addHiBound.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints.undoLog" title="=&gt; Types.this.UndoLog">undoLog</a> <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;UndoLog.record" title="(tv: Types.this.TypeVar)Unit">record</a> this
        <a href="#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.addHiBound" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.addHiBound.tp" title="Types.this.Type">tp</a>, <a href="#scala.reflect.internal;Types;TypeVar.addHiBound$default$2" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="comment">// &lt;/region&gt;</span>

    <span class="comment">// ignore subtyping&amp;equality checks while true -- see findMember</span>
    <span class="comment">// OPT: This could be Either[TypeVar, Boolean], but this encoding was chosen instead to save allocations.</span>
    private var <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar._suspended_=">_suspended</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ConstantFalse" title="=&gt; Types.this.UniqueConstantType">ConstantFalse</a>
    private<span class="delimiter">[</span>Types<span class="delimiter">]</span> def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeVar.suspended">suspended</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar._suspended_=" title="=&gt; Types.this.Type">_suspended</a>: @<a href="#scala.reflect.internal;Types;Type" title="Types.this.Type @unchecked">unchecked</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ConstantFalse" title="=&gt; Types.this.UniqueConstantType">ConstantFalse</a> =&gt; false
      case <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ConstantTrue" title="=&gt; Types.this.UniqueConstantType">ConstantTrue</a>  =&gt; true
      case <a title="Types.this.TypeVar" id="scala.reflect.internal;Types;TypeVar.suspended.tv">tv</a>: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a>   =&gt; <a href="#scala.reflect.internal;Types;TypeVar.suspended.tv" title="Types.this.TypeVar">tv</a>.<a href="#scala.reflect.internal;Types;TypeVar.suspended" title="=&gt; Boolean">suspended</a>
    <span class="delimiter">}</span>

    <span class="comment">/** `AppliedTypeVar`s share the same `TypeConstraint` with the `HKTypeVar` that it was spawned from.
     *   A type inference session can also have more than one ATV.
     *   If we don't detect that, we end up with &quot;cyclic constraint&quot; when we try to instantiate type parameters
     *   after solving in, pos/t8237
     */</span>
    protected final def <a title="(other: Types.this.Type)Boolean" id="scala.reflect.internal;Types;TypeVar.sharesConstraints">sharesConstraints</a><span class="delimiter">(</span><span title="Types.this.Type">other</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span title="Types.this.Type">other</span> match <span class="delimiter">{</span>
      case <span title="Types.this.TypeVar">other</span>: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a> =&gt; <a href="#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; Types.this.TypeConstraint">constr</a> <span title="(x$1: Any)Boolean">==</span> <span title="Types.this.TypeVar">other</span>.<a href="#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; Types.this.TypeConstraint">constr</a> <span class="comment">// SI-8237 avoid cycles. Details in pos/t8237.scala</span>
      case _ =&gt; false
    <span class="delimiter">}</span>
    private<span class="delimiter">[</span>Types<span class="delimiter">]</span> def <a title="(b: Boolean)Unit" id="scala.reflect.internal;Types;TypeVar.suspended_=">suspended_=</a><span class="delimiter">(</span><a title="Boolean" id="scala.reflect.internal;Types;TypeVar.suspended_=.b">b</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <a href="#scala.reflect.internal;Types;TypeVar._suspended_=" title="(x$1: Types.this.Type)Unit">_suspended</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.suspended_=.b" title="Boolean">b</a><span class="delimiter">)</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ConstantTrue" title="=&gt; Types.this.UniqueConstantType">ConstantTrue</a> else <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ConstantFalse" title="=&gt; Types.this.UniqueConstantType">ConstantFalse</a>
    <span class="comment">// SI-7785 Link the suspended attribute of a TypeVar created in, say, a TypeMap (e.g. AsSeenFrom) to its originator</span>
    private<span class="delimiter">[</span>Types<span class="delimiter">]</span> def <a title="(origin: Types.this.TypeVar)Unit" id="scala.reflect.internal;Types;TypeVar.linkSuspended">linkSuspended</a><span class="delimiter">(</span><a title="Types.this.TypeVar" id="scala.reflect.internal;Types;TypeVar.linkSuspended.origin">origin</a>: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <a href="#scala.reflect.internal;Types;TypeVar._suspended_=" title="(x$1: Types.this.Type)Unit">_suspended</a> = <a href="#scala.reflect.internal;Types;TypeVar.linkSuspended.origin" title="Types.this.TypeVar">origin</a>

    <span class="comment">/** Called when a TypeVar is involved in a subtyping check.  Result is whether
     *  this TypeVar could plausibly be a [super/sub]type of argument `tp` and if so,
     *  tracks tp as a [lower/upper] bound of this TypeVar.
     *
     *  if (isLowerBound)   this typevar could be a subtype, track tp as a lower bound
     *  if (!isLowerBound)  this typevar could be a supertype, track tp as an upper bound
     *
     *  If isNumericBound is true, the subtype check is performed with weak_&lt;:&lt; instead of &lt;:&lt;.
     */</span>
    def <a title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean" id="scala.reflect.internal;Types;TypeVar.registerBound">registerBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.registerBound.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Boolean" id="scala.reflect.internal;Types;TypeVar.registerBound.isLowerBound">isLowerBound</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>, <a title="Boolean" id="scala.reflect.internal;Types;TypeVar.registerBound$default$3">isNumericBound</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      <span class="comment">// println(&quot;regBound: &quot;+(safeToString, debugString(tp), isLowerBound)) //@MDEBUG</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.isLowerBound" title="Boolean">isLowerBound</a><span class="delimiter">)</span>
        <a href="../../Predef.scala.html#scala.Predef.assert(65d7b4917f)" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.tp" title="Types.this.Type">tp</a> <span title="(x$1: Any)Boolean">!=</span> this<span class="delimiter">)</span>

      <span class="comment">// side effect: adds the type to upper or lower bounds</span>
      def <a title="(tp: Types.this.Type)Unit" id="scala.reflect.internal;Types;TypeVar.registerBound.addBound">addBound</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.registerBound.addBound.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.isLowerBound" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeVar.addLoBound" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addLoBound</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.addBound.tp" title="Types.this.Type">tp</a>, <a href="#scala.reflect.internal;Types;TypeVar.registerBound$default$3" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
        else <a href="#scala.reflect.internal;Types;TypeVar.addHiBound" title="(tp: Types.this.Type, isNumericBound: Boolean)Unit">addHiBound</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.addBound.tp" title="Types.this.Type">tp</a>, <a href="#scala.reflect.internal;Types;TypeVar.registerBound$default$3" title="Boolean">isNumericBound</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="comment">// swaps the arguments if it's an upper bound</span>
      def <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype">checkSubtype</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype.tp1">tp1</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype.tp2">tp2</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        val <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype.lhs">lhs</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.isLowerBound" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype.tp1" title="Types.this.Type">tp1</a> else <a href="#scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype.tp2" title="Types.this.Type">tp2</a>
        val <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype.rhs">rhs</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.isLowerBound" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype.tp2" title="Types.this.Type">tp2</a> else <a href="#scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype.tp1" title="Types.this.Type">tp1</a>

        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound$default$3" title="Boolean">isNumericBound</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype.lhs" title="Types.this.Type">lhs</a> <a href="#scala.reflect.internal;Types;Type.weak_<:<" title="(that: Types.this.Type)Boolean">weak_&lt;:&lt;</a> <a href="#scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype.rhs" title="Types.this.Type">rhs</a>
        else <a href="#scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype.lhs" title="Types.this.Type">lhs</a> <a href="#scala.reflect.internal;Types;Type.<:<" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype.rhs" title="Types.this.Type">rhs</a>
      <span class="delimiter">}</span>

      <span class="comment">/*  Simple case: type arguments can be ignored, because either this typevar has
       *  no type parameters, or we are comparing to Any/Nothing.
       *
       *  The latter condition is needed because HK unification is limited to constraints of the shape
       *  {{{
       *    TC1[T1,..., TN] &lt;: TC2[T'1,...,T'N]
       *  }}}
       *  which would preclude the following important constraints:
       *  {{{
       *    Nothing &lt;: ?TC[?T]
       *    ?TC[?T] &lt;: Any
       *  }}}
       */</span>
      def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;TypeVar.registerBound.unifySimple">unifySimple</a> = <span class="delimiter">{</span>
        val <a title="Types.this.Symbol" id="scala.reflect.internal;Types;TypeVar.registerBound.unifySimple.sym">sym</a> = <a href="#scala.reflect.internal;Types;TypeVar.registerBound.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifySimple.sym" title="Types.this.Symbol">sym</a> <span title="(x$1: Any)Boolean">==</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.NothingClass" title="Types.this.definitions.NothingClass.type">NothingClass</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifySimple.sym" title="Types.this.Symbol">sym</a> <span title="(x$1: Any)Boolean">==</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyClass" title="=&gt; Types.this.ClassSymbol">AnyClass</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// kind-polymorphic</span>
          <span class="comment">// SI-7126 if we register some type alias `T=Any`, we can later end</span>
          <span class="comment">// with malformed types like `T[T]` during type inference in</span>
          <span class="comment">// `handlePolymorphicCall`. No such problem if we register `Any`.</span>
          <a href="#scala.reflect.internal;Types;TypeVar.registerBound.addBound" title="(tp: Types.this.Type)Unit">addBound</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifySimple.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
          true
        <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.params" title="=&gt; List[Types.this.Symbol]">params</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#scala.reflect.internal;Types;TypeVar.registerBound.addBound" title="(tp: Types.this.Type)Unit">addBound</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>
          true
        <span class="delimiter">}</span> else false
      <span class="delimiter">}</span>

      <span class="comment">/*  Full case: involving a check of the form
       *  {{{
       *    TC1[T1,..., TN] &lt;: TC2[T'1,...,T'N]
       *  }}}
       *  Checks subtyping of higher-order type vars, and uses variances as defined in the
       *  type parameter we're trying to infer (the result will be sanity-checked later).
       */</span>
      def <a title="(tpe: Types.this.Type)Boolean" id="scala.reflect.internal;Types;TypeVar.registerBound.unifyFull">unifyFull</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.registerBound.unifyFull.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
        def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types;TypeVar.registerBound.unifyFull.unifySpecific">unifySpecific</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.registerBound.unifyFull.unifySpecific.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
          <a href="#scala.reflect.internal;Types.sameLength" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifyFull.unifySpecific.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
            val <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;TypeVar.registerBound.unifyFull.unifySpecific.lhs">lhs</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.isLowerBound" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifyFull.unifySpecific.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a> else <a href="#scala.reflect.internal;Types;TypeVar.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a>
            val <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;TypeVar.registerBound.unifyFull.unifySpecific.rhs">rhs</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.isLowerBound" title="Boolean">isLowerBound</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeVar.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a> else <a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifyFull.unifySpecific.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a>
            <span class="comment">// This is a higher-kinded type var with same arity as tp.</span>
            <span class="comment">// If so (see SI-7517), side effect: adds the type constructor itself as a bound.</span>
            <a href="#scala.reflect.internal;Types.isSubArgs" title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol], depth: scala.reflect.internal.Depth)Boolean">isSubArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifyFull.unifySpecific.lhs" title="List[Types.this.Type]">lhs</a>, <a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifyFull.unifySpecific.rhs" title="List[Types.this.Type]">rhs</a>, <a href="#scala.reflect.internal;Types;TypeVar.params" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="Depth.scala.html#scala.reflect.internal.Depth.AnyDepth" title="=&gt; scala.reflect.internal.Depth">AnyDepth</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span> <a href="#scala.reflect.internal;Types;TypeVar.registerBound.addBound" title="(tp: Types.this.Type)Unit">addBound</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifyFull.unifySpecific.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeConstructor" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span>; true <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <span class="comment">// The type with which we can successfully unify can be hidden</span>
        <span class="comment">// behind singleton types and type aliases.</span>
        <a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifyFull.tpe" title="Types.this.Type">tpe</a>.<a href="#scala.reflect.internal;Types;Type.dealiasWidenChain" title="=&gt; List[Types.this.Type]">dealiasWidenChain</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifyFull.unifySpecific" title="(tp: Types.this.Type)Boolean">unifySpecific</a>
      <span class="delimiter">}</span>

      <span class="comment">// There's a &lt;: test taking place right now, where tp is a concrete type and this is a typevar</span>
      <span class="comment">// attempting to satisfy that test. Either the test will be unsatisfiable, in which case</span>
      <span class="comment">// registerBound will return false; or the upper or lower bounds of this type var will be</span>
      <span class="comment">// supplemented with the type being tested against.</span>
      <span class="comment">//</span>
      <span class="comment">// Eventually the types which have accumulated in the upper and lower bounds will be lubbed</span>
      <span class="comment">// (resp. glbbed) to instantiate the typevar.</span>
      <span class="comment">//</span>
      <span class="comment">// The only types which are eligible for unification are those with the same number of</span>
      <span class="comment">// typeArgs as this typevar, or Any/Nothing, which are kind-polymorphic. For the upper bound,</span>
      <span class="comment">// any parent or base type of `tp` may be tested here (leading to a corresponding relaxation</span>
      <span class="comment">// in the upper bound.) The universe of possible glbs, being somewhat more infinite, is not</span>
      <span class="comment">// addressed here: all lower bounds are retained and their intersection calculated when the</span>
      <span class="comment">// bounds are solved.</span>
      <span class="comment">//</span>
      <span class="comment">// In a side-effect free universe, checking tp and tp.parents beofre checking tp.baseTypeSeq</span>
      <span class="comment">// would be pointless. In this case, each check we perform causes us to lose specificity: in</span>
      <span class="comment">// the end the best we'll do is the least specific type we tested against, since the typevar</span>
      <span class="comment">// does not see these checks as &quot;probes&quot; but as requirements to fulfill.</span>
      <span class="comment">// TODO: can the `suspended` flag be used to poke around without leaving a trace?</span>
      <span class="comment">//</span>
      <span class="comment">// So the strategy used here is to test first the type, then the direct parents, and finally</span>
      <span class="comment">// to fall back on the individual base types. This warrants eventual re-examination.</span>

      <span class="comment">// AM: I think we could use the `suspended` flag to avoid side-effecting during unification</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.suspended" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span>         <span class="comment">// constraint accumulation is disabled</span>
        <a href="#scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtype</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.tp" title="Types.this.Type">tp</a>, <a href="#scala.reflect.internal;Types;TypeVar.origin" title="=&gt; Types.this.Type">origin</a><span class="delimiter">)</span>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.instValid" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span>  <span class="comment">// type var is already set</span>
        <a href="#scala.reflect.internal;Types;TypeVar.registerBound.checkSubtype" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">checkSubtype</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.tp" title="Types.this.Type">tp</a>, <a href="#scala.reflect.internal;Types;TypeVar.inst" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
      else <a href="#scala.reflect.internal;Types;TypeVar.isRelatable" title="(tp: Types.this.Type)Boolean">isRelatable</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
        <a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifySimple" title="=&gt; Boolean">unifySimple</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifyFull" title="(tpe: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span>
          <span class="comment">// only look harder if our gaze is oriented toward Any</span>
          <a href="#scala.reflect.internal;Types;TypeVar.registerBound.isLowerBound" title="Boolean">isLowerBound</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span>
            <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifyFull" title="(tpe: Types.this.Type)Boolean">unifyFull</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span>
              <span class="comment">// @PP: Is it going to be faster to filter out the parents we just checked?</span>
              <span class="comment">// That's what's done here but I'm not sure it matters.</span>
              <a href="#scala.reflect.internal;Types;TypeVar.registerBound.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>.<a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.toList" title="=&gt; List[Types.this.Type]">toList</a>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[Types.this.Type]">tail</a> <a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filterNot" title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerBound.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.parents" title="=&gt; List[Types.this.Type]">parents</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: Types.this.Type)Boolean">contains</a> <a href="#scala.reflect.internal;Types;TypeVar.registerBound.$anonfun.x$42" title="Types.this.Type">_</a><span class="delimiter">)</span> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types;TypeVar.registerBound.unifyFull" title="(tpe: Types.this.Type)Boolean">unifyFull</a>
            <span class="delimiter">)</span>
          <span class="delimiter">)</span>
        <span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    def <a title="(tp: Types.this.Type, typeVarLHS: Boolean)Boolean" id="scala.reflect.internal;Types;TypeVar.registerTypeEquality">registerTypeEquality</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.registerTypeEquality.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Boolean" id="scala.reflect.internal;Types;TypeVar.registerTypeEquality.typeVarLHS">typeVarLHS</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
<span class="comment">//      println(&quot;regTypeEq: &quot;+(safeToString, debugString(tp), tp.getClass, if (typeVarLHS) &quot;in LHS&quot; else &quot;in RHS&quot;, if (suspended) &quot;ZZ&quot; else if (instValid) &quot;IV&quot; else &quot;&quot;)) //@MDEBUG</span>
      def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types;TypeVar.registerTypeEquality.checkIsSameType">checkIsSameType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.registerTypeEquality.checkIsSameType.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerTypeEquality.typeVarLHS" title="Boolean">typeVarLHS</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeVar.inst" title="=&gt; Types.this.Type">inst</a> <a href="#scala.reflect.internal;Types;Type.=:=" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#scala.reflect.internal;Types;TypeVar.registerTypeEquality.checkIsSameType.tp" title="Types.this.Type">tp</a>
        else            <a href="#scala.reflect.internal;Types;TypeVar.registerTypeEquality.checkIsSameType.tp" title="Types.this.Type">tp</a>   <a href="#scala.reflect.internal;Types;Type.=:=" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#scala.reflect.internal;Types;TypeVar.inst" title="=&gt; Types.this.Type">inst</a>
      <span class="delimiter">)</span>

      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.suspended" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeVar.registerTypeEquality.tp" title="Types.this.Type">tp</a> <a href="#scala.reflect.internal;Types;Type.=:=" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#scala.reflect.internal;Types;TypeVar.origin" title="=&gt; Types.this.Type">origin</a>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.instValid" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeVar.registerTypeEquality.checkIsSameType" title="(tp: Types.this.Type)Boolean">checkIsSameType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerTypeEquality.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>
      else <a href="#scala.reflect.internal;Types;TypeVar.isRelatable" title="(tp: Types.this.Type)Boolean">isRelatable</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerTypeEquality.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
        val <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.registerTypeEquality.newInst">newInst</a> = <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps.wildcardToTypeVarMap.apply" title="(tp: Types.this.Type)Types.this.Type">wildcardToTypeVarMap</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerTypeEquality.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; Types.this.TypeConstraint">constr</a> <a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.isWithinBounds" title="(tp: Types.this.Type)Boolean">isWithinBounds</a> <a href="#scala.reflect.internal;Types;TypeVar.registerTypeEquality.newInst" title="Types.this.Type">newInst</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
          <a href="#scala.reflect.internal;Types;TypeVar.setInst" title="(tp: Types.this.Type)TypeVar.this.type">setInst</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerTypeEquality.newInst" title="Types.this.Type">newInst</a><span class="delimiter">)</span>
          true
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * `?A.T =:= tp` is rewritten as the constraint `?A &lt;: {type T = tp}`
     *
     * TODO: make these constraints count (incorporate them into implicit search in `applyImplicitArgs`)
     * (`T` corresponds to @param sym)
     */</span>
    def <a title="(sym: Types.this.Symbol, tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types;TypeVar.registerTypeSelection">registerTypeSelection</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;TypeVar.registerTypeSelection.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.registerTypeSelection.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      <a href="#scala.reflect.internal;Types;TypeVar.registerBound" title="(tp: Types.this.Type, isLowerBound: Boolean, isNumericBound: Boolean)Boolean">registerBound</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.HasTypeMember.apply" title="(name: Types.this.TypeName, tp: Types.this.Type)Types.this.Type">HasTypeMember</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.registerTypeSelection.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym.NameType">name</a>.<a href="Names.scala.html#scala.reflect.internal;Names;Name.toTypeName" title="=&gt; Types.this.TypeName">toTypeName</a>, <a href="#scala.reflect.internal;Types;TypeVar.registerTypeSelection.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>, isLowerBound = false<span class="delimiter">)</span>
    <span class="delimiter">}</span>

    private def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types;TypeVar.isSkolemAboveLevel">isSkolemAboveLevel</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.isSkolemAboveLevel.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;TypeVar.isSkolemAboveLevel.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> match <span class="delimiter">{</span>
      case <a title="Types.this.TypeSkolem" id="scala.reflect.internal;Types;TypeVar.isSkolemAboveLevel.ts">ts</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;TypeSkolem" title="Types.this.TypeSkolem">TypeSkolem</a> =&gt; <a href="#scala.reflect.internal;Types;TypeVar.isSkolemAboveLevel.ts" title="Types.this.TypeSkolem">ts</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;TypeSkolem.level" title="=&gt; Int">level</a> <a href="../../Int.scala.html#scala;Int.>(5f58a84eb3)" title="(x: Int)Boolean">&gt;</a> <a href="#scala.reflect.internal;Types;TypeVar.level" title="=&gt; Int">level</a>
      case _              =&gt; false
    <span class="delimiter">}</span>
    <span class="comment">// side-effects encounteredHigherLevel</span>
    private def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types;TypeVar.containsSkolemAboveLevel">containsSkolemAboveLevel</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.containsSkolemAboveLevel.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> =
      <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.containsSkolemAboveLevel.tp" title="Types.this.Type">tp</a> <a href="#scala.reflect.internal;Types;Type.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types;TypeVar.isSkolemAboveLevel" title="(tp: Types.this.Type)Boolean">isSkolemAboveLevel</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span> <a href="#scala.reflect.internal;Types;TypeVar.encounteredHigherLevel_=" title="(x$1: Boolean)Unit">encounteredHigherLevel</a> = true ; true <span class="delimiter">}</span>

     <span class="comment">/** Can this variable be related in a constraint to type `tp`?
      *  This is not the case if `tp` contains type skolems whose
      *  skolemization level is higher than the level of this variable.
      */</span>
    def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types;TypeVar.isRelatable">isRelatable</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;TypeVar.isRelatable.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
         <a href="#scala.reflect.internal;Types;TypeVar.shouldRepackType" title="=&gt; Boolean">shouldRepackType</a>               <span class="comment">// short circuit if we already know we've seen higher levels</span>
      <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;TypeVar.containsSkolemAboveLevel" title="(tp: Types.this.Type)Boolean">containsSkolemAboveLevel</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.isRelatable.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>  <span class="comment">// side-effects tracking boolean</span>
      <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.enableTypeVarExperimentals" title="=&gt; Boolean">enableTypeVarExperimentals</a>     <span class="comment">// -Xexperimental: always say we're relatable, track consequences</span>
    <span class="delimiter">)</span>

    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;TypeVar.normalize">normalize</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.instValid" title="=&gt; Boolean">instValid</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeVar.inst" title="=&gt; Types.this.Type">inst</a>
      <span class="comment">// get here when checking higher-order subtyping of the typevar by itself</span>
      <span class="comment">// TODO: check whether this ever happens?</span>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeVar.etaExpand" title="=&gt; Types.this.Type">etaExpand</a>
      else super.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a>
    <span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;TypeVar.etaExpand">etaExpand</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;TypeVar.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a><span class="delimiter">)</span> this
      else <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.logResult" title="(msg: =&gt; String)(result: Types.this.Type)Types.this.Type">logResult</a><span class="delimiter">(</span><span title="String(&quot;Normalizing HK $this&quot;)" class="string">&quot;Normalizing HK $this&quot;</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeFun" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.params" title="=&gt; List[Types.this.Symbol]">params</a>, <a href="#scala.reflect.internal;Types;TypeVar.applyArgs" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.params" title="=&gt; List[Types.this.Symbol]">params</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.etaExpand.$anonfun.x$43" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeConstructor" title="=&gt; Types.this.Type">typeConstructor</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    override def <a title="=&gt; Types.this.Symbol" id="scala.reflect.internal;Types;TypeVar.typeSymbol">typeSymbol</a> = <a href="#scala.reflect.internal;Types;TypeVar.origin" title="=&gt; Types.this.Type">origin</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>

    private def <a title="(sym: Types.this.Symbol)String" id="scala.reflect.internal;Types;TypeVar.tparamsOfSym">tparamsOfSym</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;TypeVar.tparamsOfSym.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;TypeVar.tparamsOfSym.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a> match <span class="delimiter">{</span>
      case PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;TypeVar.tparamsOfSym.tparams">tparams</a>, _<span class="delimiter">)</span> if <a href="#scala.reflect.internal;Types;TypeVar.tparamsOfSym.tparams" title="List[Types.this.Symbol]">tparams</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a> =&gt;
        <a href="#scala.reflect.internal;Types;TypeVar.tparamsOfSym.tparams" title="List[Types.this.Symbol]">tparams</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],String,List[String]])List[String]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.tparamsOfSym.$anonfun.x$44" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.defString" title="=&gt; String">defString</a><span class="delimiter">)</span> <a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span>, <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span>, <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>
      case _ =&gt; <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="delimiter">}</span>
    def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeVar.originName">originName</a> = <a href="#scala.reflect.internal;Types;TypeVar.origin" title="=&gt; Types.this.Type">origin</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbolDirect" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.decodedName" title="=&gt; String">decodedName</a>
    def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeVar.originLocation">originLocation</a> = <span class="delimiter">{</span>
      val <a title="Types.this.Symbol" id="scala.reflect.internal;Types;TypeVar.originLocation.sym">sym</a>  = <a href="#scala.reflect.internal;Types;TypeVar.origin" title="=&gt; Types.this.Type">origin</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbolDirect" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>
      val <a title="Types.this.Symbol" id="scala.reflect.internal;Types;TypeVar.originLocation.encl">encl</a> = <a href="#scala.reflect.internal;Types;TypeVar.originLocation.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.logicallyEnclosingMember" title="=&gt; Types.this.Symbol">logicallyEnclosingMember</a>

      <span class="comment">// This should display somewhere between one and three</span>
      <span class="comment">// things which enclose the origin: at most, a class, a</span>
      <span class="comment">// a method, and a term.  At least, a class.</span>
      <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.List.apply" title="(xs: Option[Types.this.Symbol]*)List[Option[Types.this.Symbol]]">List</a><span class="delimiter">(</span>
        <a href="../../Option.scala.html#scala;Some" title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.originLocation.encl" title="Types.this.Symbol">encl</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.enclClass" title="=&gt; Types.this.Symbol">enclClass</a><span class="delimiter">)</span>,
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.originLocation.encl" title="Types.this.Symbol">encl</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isMethod" title="=&gt; Boolean">isMethod</a><span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Some" title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.originLocation.encl" title="Types.this.Symbol">encl</a><span class="delimiter">)</span> else <a href="../../Option.scala.html#scala.None" title="None.type">None</a>,
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.originLocation.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isTerm" title="=&gt; Boolean">isTerm</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.originLocation.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.reflect.internal;Types;TypeVar.originLocation.encl" title="Types.this.Symbol">encl</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Some" title="(x: Types.this.Symbol)Some[Types.this.Symbol]">Some</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.originLocation.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span> else <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
      <span class="delimiter">)</span>.<a href="../../collection/generic/GenericTraversableTemplate.scala.html#scala.collection.generic;GenericTraversableTemplate.flatten" title="(implicit asTraversable: Option[Types.this.Symbol] =&gt; scala.collection.GenTraversableOnce[Types.this.Symbol])List[Types.this.Symbol]">flatten</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Symbol =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],String,List[String]])List[String]">map</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;TypeVar.originLocation.$anonfun.s">s</a> =&gt; <a href="#scala.reflect.internal;Types;TypeVar.originLocation.$anonfun.s" title="Types.this.Symbol">s</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.decodedName" title="=&gt; String">decodedName</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeVar.tparamsOfSym" title="(sym: Types.this.Symbol)String">tparamsOfSym</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.originLocation.$anonfun.s" title="Types.this.Symbol">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a> <span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span>
    <span class="delimiter">}</span>
    private def <a title="=&gt; Any" id="scala.reflect.internal;Types;TypeVar.levelString">levelString</a> = if <span class="delimiter">(</span><a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">explaintypes</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;TypeVar.level" title="=&gt; Int">level</a> else <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeVar.safeToString">safeToString</a> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; Types.this.TypeConstraint">constr</a> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.inst" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span><span class="delimiter">)</span> <span title="String(&quot;TVar&lt;&quot;)" class="string">&quot;TVar&lt;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeVar.originName" title="=&gt; String">originName</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;=null&gt;&quot;)" class="string">&quot;=null&gt;&quot;</span>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.inst" title="=&gt; Types.this.Type">inst</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <span title="String(&quot;=?&quot;)" class="string">&quot;=?&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeVar.inst" title="=&gt; Types.this.Type">inst</a>
      else <span class="delimiter">(</span>if<span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.untouchable" title="=&gt; Boolean">untouchable</a><span class="delimiter">)</span> <span title="String(&quot;!?&quot;)" class="string">&quot;!?&quot;</span> else <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeVar.levelString" title="=&gt; Any">levelString</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;TypeVar.originName" title="=&gt; String">originName</a>
    <span class="delimiter">)</span>
    def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeVar.originString">originString</a> = <a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span><a href="#scala.reflect.internal;Types;TypeVar.originName" title="=&gt; String">originName</a><span title="String(&quot; in &quot;)"> in $</span><a href="#scala.reflect.internal;Types;TypeVar.originLocation" title="=&gt; String">originLocation</a><span title="String(&quot;&quot;)" class="string">&quot;</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;TypeVar.kind">kind</a> = <span title="String(&quot;TypeVar&quot;)" class="string">&quot;TypeVar&quot;</span>

    def <a title="=&gt; Types.this.TypeVar" id="scala.reflect.internal;Types;TypeVar.cloneInternal">cloneInternal</a> = <span class="delimiter">{</span>
      <span class="comment">// cloning a suspended type variable when it's suspended will cause the clone</span>
      <span class="comment">// to never be resumed with the current implementation</span>
      <a href="../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;TypeVar.suspended" title="=&gt; Boolean">suspended</a>, this<span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types.TypeVar.readResolve" title="Types.this.TypeVar.type">TypeVar</a>.<a href="#scala.reflect.internal;Types.TypeVar.trace" title="(action: String, msg: =&gt; String)(value: Types.this.TypeVar)Types.this.TypeVar">trace</a><span class="delimiter">(</span><span title="String(&quot;clone&quot;)" class="string">&quot;clone&quot;</span>, <a href="#scala.reflect.internal;Types;TypeVar.originLocation" title="=&gt; String">originLocation</a><span class="delimiter">)</span><span class="delimiter">(</span>
        <a href="#scala.reflect.internal;Types.TypeVar.apply(d4803f064b)" title="(origin: Types.this.Type, constr: Types.this.TypeConstraint, args: List[Types.this.Type], params: List[Types.this.Symbol])Types.this.TypeVar">TypeVar</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeVar.origin" title="=&gt; Types.this.Type">origin</a>, <a href="#scala.reflect.internal;Types;TypeVar.constr" title="=&gt; Types.this.TypeConstraint">constr</a>.<a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.cloneInternal" title="=&gt; Types.this.TypeConstraint">cloneInternal</a>, <a href="#scala.reflect.internal;Types;TypeVar.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a>, <a href="#scala.reflect.internal;Types;TypeVar.params" title="=&gt; List[Types.this.Symbol]">params</a><span class="delimiter">)</span> <span class="comment">// @M TODO: clone args/params?</span>
      <span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A type carrying some annotations. Created by the typechecker
   *  when eliminating ''Annotated'' trees (see typedAnnotated).
   *
   *  @param annotations the list of annotations on the type
   *  @param underlying the type without the annotation
   */</span>
  case class <a title="class AnnotatedType extends Types.this.Type with Types.this.RewrappingTypeProxy with Types.this.AnnotatedTypeApi with Product with Serializable" id="scala.reflect.internal;Types;AnnotatedType">AnnotatedType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a>override val <a title="List[Types.this.AnnotationInfo]" id="scala.reflect.internal;Types;AnnotatedType.annotations">annotations</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>,
                           override val <a title="Types.this.Type" id="scala.reflect.internal;Types;AnnotatedType.underlying">underlying</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>
  extends <a href="#scala.reflect.internal;Types;RewrappingTypeProxy" title="Types.this.RewrappingTypeProxy">RewrappingTypeProxy</a> with <a href="../api/Types.scala.html#scala.reflect.api;Types;AnnotatedTypeApi" title="Types.this.AnnotatedTypeApi">AnnotatedTypeApi</a> <span class="delimiter">{</span>

    <a href="../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types;AnnotatedType.annotations" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;AnnotatedType.underlying" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span>

    override protected def <a title="(tp: Types.this.Type)Types.this.AnnotatedType" id="scala.reflect.internal;Types;AnnotatedType.rewrap">rewrap</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;AnnotatedType.rewrap.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;AnnotatedType.annotations" title="List[Types.this.AnnotationInfo] @scala.reflect.internal.annotations.uncheckedBounds" id="scala.reflect.internal;Types;AnnotatedType.rewrap.x$78">copy</a><span class="delimiter">(</span>underlying = <a href="#scala.reflect.internal;Types;AnnotatedType.rewrap.tp" title="Types.this.Type" id="scala.reflect.internal;Types;AnnotatedType.rewrap.x$77">tp</a><span class="delimiter">)</span>

    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;AnnotatedType.isTrivial">isTrivial</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types;AnnotatedType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.isTrivial" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types;AnnotatedType.annotations" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: Types.this.AnnotationInfo =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AnnotatedType.isTrivial.$anonfun.x$45" title="Types.this.AnnotationInfo">_</a>.<a href="AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;AnnotationInfo.isTrivial" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span>

    override def <a title="=&gt; String" id="scala.reflect.internal;Types;AnnotatedType.safeToString">safeToString</a> = <a href="#scala.reflect.internal;Types;AnnotatedType.annotations" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><a href="../../Predef.scala.html#scala.Predef.any2stringadd(6b32434ac5)" title="(self: Types.this.Type)any2stringadd[Types.this.Type]">underlying</a> <a href="../../Predef.scala.html#scala.Predef;any2stringadd.+" title="(other: String)String">+</a> <span title="String(&quot; @&quot;)" class="string">&quot; @&quot;</span>, <span title="String(&quot; @&quot;)" class="string">&quot; @&quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>

    override def <a title="(p: Types.this.AnnotationInfo =&gt; Boolean)Types.this.Type" id="scala.reflect.internal;Types;AnnotatedType.filterAnnotations">filterAnnotations</a><span class="delimiter">(</span><a title="Types.this.AnnotationInfo =&gt; Boolean" id="scala.reflect.internal;Types;AnnotatedType.filterAnnotations.p">p</a>: AnnotationInfo =&gt; Boolean<span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      val <a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: List[Types.this.AnnotationInfo], _2: List[Types.this.AnnotationInfo])(List[Types.this.AnnotationInfo], List[Types.this.AnnotationInfo])" class="delimiter">(</a><a href="../../Tuple2.scala.html#scala;Tuple2._1" title="List[Types.this.AnnotationInfo]" id="scala.reflect.internal;Types;AnnotatedType.filterAnnotations.yes">yes</a>, <a href="../../Tuple2.scala.html#scala;Tuple2._2" title="List[Types.this.AnnotationInfo]" id="scala.reflect.internal;Types;AnnotatedType.filterAnnotations.no">no</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types;AnnotatedType.annotations" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a> <a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.partition" title="(List[Types.this.AnnotationInfo], List[Types.this.AnnotationInfo])">partition</a> <a href="#scala.reflect.internal;Types;AnnotatedType.filterAnnotations.p" title="Types.this.AnnotationInfo =&gt; Boolean">p</a>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AnnotatedType.filterAnnotations.yes" title="List[Types.this.AnnotationInfo]">yes</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;AnnotatedType.underlying" title="=&gt; Types.this.Type">underlying</a>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AnnotatedType.filterAnnotations.no" title="List[Types.this.AnnotationInfo]">no</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> this
      else <a href="#scala.reflect.internal;Types;AnnotatedType" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type)Types.this.AnnotatedType">copy</a><span class="delimiter">(</span>annotations = <a href="#scala.reflect.internal;Types;AnnotatedType.filterAnnotations.yes" title="List[Types.this.AnnotationInfo]">yes</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    override def <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="scala.reflect.internal;Types;AnnotatedType.setAnnotations">setAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="scala.reflect.internal;Types;AnnotatedType.setAnnotations.annots">annots</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AnnotatedType.setAnnotations.annots" title="List[Types.this.AnnotationInfo]">annots</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;AnnotatedType.underlying" title="=&gt; Types.this.Type">underlying</a>
      else <a href="#scala.reflect.internal;Types;AnnotatedType" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type)Types.this.AnnotatedType">copy</a><span class="delimiter">(</span>annotations = <a href="#scala.reflect.internal;Types;AnnotatedType.setAnnotations.annots" title="List[Types.this.AnnotationInfo]">annots</a><span class="delimiter">)</span>

    <span class="comment">/** Add a number of annotations to this type */</span>
    override def <a title="(annots: List[Types.this.AnnotationInfo])Types.this.Type" id="scala.reflect.internal;Types;AnnotatedType.withAnnotations">withAnnotations</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="scala.reflect.internal;Types;AnnotatedType.withAnnotations.annots">annots</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AnnotatedType.withAnnotations.annots" title="List[Types.this.AnnotationInfo]">annots</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> this
      else <a href="#scala.reflect.internal;Types;AnnotatedType" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type)Types.this.AnnotatedType">copy</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AnnotatedType.withAnnotations.annots" title="List[Types.this.AnnotationInfo]">annots</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.:::" title="(prefix: List[Types.this.AnnotationInfo])List[Types.this.AnnotationInfo]">:::</a> this.<a href="#scala.reflect.internal;Types;AnnotatedType.annotations" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a><span class="delimiter">)</span>

    <span class="comment">/** Remove any annotations from this type.
     *  TODO - is it allowed to nest AnnotatedTypes? If not then let's enforce
     *  that at creation.  At the moment if they do ever turn up nested this
     *  recursively calls withoutAnnotations.
     */</span>
    override def <a title="=&gt; Types.this.Type" id="scala.reflect.internal;Types;AnnotatedType.withoutAnnotations">withoutAnnotations</a> = <a href="#scala.reflect.internal;Types;AnnotatedType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.withoutAnnotations" title="=&gt; Types.this.Type">withoutAnnotations</a>

    <span class="comment">/** Drop the annotations on the bounds, unless the low and high
     *  bounds are exactly tp.
     */</span>
    override def <a title="=&gt; Types.this.TypeBounds" id="scala.reflect.internal;Types;AnnotatedType.bounds">bounds</a>: <a href="#scala.reflect.internal;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a> = <a href="#scala.reflect.internal;Types;AnnotatedType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.bounds" title="=&gt; Types.this.TypeBounds">bounds</a> match <span class="delimiter">{</span>
      case TypeBounds<span class="delimiter">(</span>_: this.type, _: this.type<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3)" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span>this, this<span class="delimiter">)</span>
      case <a title="Types.this.TypeBounds" id="scala.reflect.internal;Types;AnnotatedType.bounds.oftp">oftp</a>                                   =&gt; <a href="#scala.reflect.internal;Types;AnnotatedType.bounds.oftp" title="Types.this.TypeBounds">oftp</a>
    <span class="delimiter">}</span>

    <span class="comment">// ** Replace formal type parameter symbols with actual type arguments. * /</span>
    override def <a title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams">instantiateTypeParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.formals">formals</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.actuals">actuals</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      val <a title="List[Types.this.AnnotationInfo]" id="scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.annotations1">annotations1</a> = <a href="#scala.reflect.internal;Types;AnnotatedType.annotations" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a>.<a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.AnnotationInfo =&gt; Types.this.AnnotationInfo)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.AnnotationInfo],Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]])List[Types.this.AnnotationInfo]">map</a><a href="../../collection/immutable/List.scala.html#scala.collection.immutable.List.canBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Types.this.AnnotationInfo,List[Types.this.AnnotationInfo]]" class="delimiter">(</a><a title="Types.this.AnnotationInfo" id="scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.annotations1.$anonfun.info">info</a> =&gt; <a href="AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos.AnnotationInfo.apply" title="(atp: Types.this.Type, args: List[Types.this.Tree], assocs: List[(Types.this.Name, Types.this.ClassfileAnnotArg)])Types.this.AnnotationInfo">AnnotationInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.annotations1.$anonfun.info" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;AnnotationInfo.atp" title="=&gt; Types.this.Type">atp</a>.<a href="#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span>
          <a href="#scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.formals" title="List[Types.this.Symbol]">formals</a>, <a href="#scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.actuals" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.annotations1.$anonfun.info" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;AnnotationInfo.args" title="=&gt; List[Types.this.Tree]">args</a>, <a href="#scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.annotations1.$anonfun.info" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;AnnotationInfo.assocs" title="=&gt; List[(Types.this.Name, Types.this.ClassfileAnnotArg)]">assocs</a><span class="delimiter">)</span>.<a href="AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;AnnotationInfo.setPos" title="(pos: scala.reflect.internal.util.Position)Types.this.AnnotationInfo">setPos</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.annotations1.$anonfun.info" title="Types.this.AnnotationInfo">info</a>.<a href="AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;AnnotationInfo.pos" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span><span class="delimiter">)</span>
      val <a title="Types.this.Type" id="scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.underlying1">underlying1</a> = <a href="#scala.reflect.internal;Types;AnnotatedType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.formals" title="List[Types.this.Symbol]">formals</a>, <a href="#scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.actuals" title="List[Types.this.Type]">actuals</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.annotations1" title="List[Types.this.AnnotationInfo]">annotations1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;AnnotatedType.annotations" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.underlying1" title="Types.this.Type">underlying1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;AnnotatedType.underlying" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span> this
      else <a href="#scala.reflect.internal;Types;AnnotatedType" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.annotations1" title="List[Types.this.AnnotationInfo]">annotations1</a>, <a href="#scala.reflect.internal;Types;AnnotatedType.instantiateTypeParams.underlying1" title="Types.this.Type">underlying1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Return the base type sequence of tp, dropping the annotations, unless the base type sequence of tp
      * is precisely tp itself. */</span>
    override def <a title="=&gt; Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;AnnotatedType.baseTypeSeq">baseTypeSeq</a>: <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq" title="Types.this.BaseTypeSeq">BaseTypeSeq</a> = <span class="delimiter">{</span>
       val <a title="Types.this.BaseTypeSeq" id="scala.reflect.internal;Types;AnnotatedType.baseTypeSeq.oftp">oftp</a> = <a href="#scala.reflect.internal;Types;AnnotatedType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeq" title="=&gt; Types.this.BaseTypeSeq">baseTypeSeq</a>
       if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;AnnotatedType.baseTypeSeq.oftp" title="Types.this.BaseTypeSeq">oftp</a>.<a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.length" title="=&gt; Int">length</a> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs;BaseTypeSeq.apply" title="(i: Int)Types.this.Type">oftp</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types;AnnotatedType.underlying" title="=&gt; Types.this.Type">underlying</a><span class="delimiter">)</span><span class="delimiter">)</span>
         <a href="BaseTypeSeqs.scala.html#scala.reflect.internal;BaseTypeSeqs.baseTypeSingletonSeq" title="(tp: Types.this.Type)Types.this.BaseTypeSeq">baseTypeSingletonSeq</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
       else
         <a href="#scala.reflect.internal;Types;AnnotatedType.baseTypeSeq.oftp" title="Types.this.BaseTypeSeq">oftp</a>
     <span class="delimiter">}</span>

    override def <a title="=&gt; String" id="scala.reflect.internal;Types;AnnotatedType.kind">kind</a> = <span title="String(&quot;AnnotatedType&quot;)" class="string">&quot;AnnotatedType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Creator for AnnotatedTypes.  It returns the underlying type if annotations.isEmpty
   *  rather than walking into the assertion.
   */</span>
  def <a title="(annots: List[Types.this.AnnotationInfo], underlying: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.annotatedType">annotatedType</a><span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="scala.reflect.internal;Types.annotatedType.annots">annots</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.AnnotationInfo]">List</a><span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.internal;Types.annotatedType.underlying">underlying</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.annotatedType.annots" title="List[Types.this.AnnotationInfo]">annots</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.annotatedType.underlying" title="Types.this.Type">underlying</a>
    else <a href="#scala.reflect.internal;Types;AnnotatedType" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.annotatedType.annots" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#scala.reflect.internal;Types.annotatedType.underlying" title="Types.this.Type">underlying</a><span class="delimiter">)</span>

  object <a title="Types.this.AnnotatedType.type" id="scala.reflect.internal;Types.AnnotatedType.readResolve">AnnotatedType</a> extends <a href="../api/Types.scala.html#scala.reflect.api;Types;AnnotatedTypeExtractor" title="Types.this.AnnotatedTypeExtractor">AnnotatedTypeExtractor</a>

  object <a title="Types.this.StaticallyAnnotatedType.type" id="scala.reflect.internal;Types.StaticallyAnnotatedType">StaticallyAnnotatedType</a> <a href="#scala.reflect.internal;Types.StaticallyAnnotatedType" title="Types.this.StaticallyAnnotatedType.type" class="delimiter">{</a>
    def <a title="(tp: Types.this.Type)Option[(List[Types.this.AnnotationInfo], Types.this.Type)]" id="scala.reflect.internal;Types.StaticallyAnnotatedType.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.StaticallyAnnotatedType.unapply.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(List[Types.this.AnnotationInfo], Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>AnnotationInfo<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types.StaticallyAnnotatedType.unapply.tp" title="Types.this.Type">tp</a>.<a href="AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;Annotatable.staticAnnotations" title="=&gt; List[Types.this.AnnotationInfo]">staticAnnotations</a> match <span class="delimiter">{</span>
      case <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>    =&gt; <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
      case <a title="List[Types.this.AnnotationInfo]" id="scala.reflect.internal;Types.StaticallyAnnotatedType.unapply.annots">annots</a> =&gt; <a href="../../Option.scala.html#scala;Some" title="(x: (List[Types.this.AnnotationInfo], Types.this.Type))Some[(List[Types.this.AnnotationInfo], Types.this.Type)]">Some</a><span class="delimiter">(</span><a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: List[Types.this.AnnotationInfo], _2: Types.this.Type)(List[Types.this.AnnotationInfo], Types.this.Type)" class="delimiter">(</a><a href="#scala.reflect.internal;Types.StaticallyAnnotatedType.unapply.annots" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#scala.reflect.internal;Types.StaticallyAnnotatedType.unapply.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.withoutAnnotations" title="=&gt; Types.this.Type">withoutAnnotations</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class representing types with a name. When an application uses
   *  named arguments, the named argument types for calling isApplicable
   *  are represented as NamedType.
   */</span>
  case class <a title="class NamedType extends Types.this.Type with Product with Serializable" id="scala.reflect.internal;Types.NamedType.readResolve">NamedType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Types.this.Name" id="scala.reflect.internal;Types;NamedType.name">name</a>: <a href="Names.scala.html#scala.reflect.internal;Names;Name" title="Types.this.Name">Name</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;NamedType.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;NamedType.safeToString">safeToString</a>: <span title="String">String</span> = <a href="#scala.reflect.internal;Types;NamedType.name" title="=&gt; Types.this.Name">name</a>.<span title="()String">toString</span> <span title="(x$1: Any)String">+</span><span title="String(&quot;: &quot;)" class="string">&quot;: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;NamedType.tp" title="=&gt; Types.this.Type">tp</a>
  <span class="delimiter">}</span>
  <span class="comment">/** As with NamedType, used only when calling isApplicable.
   *  Records that the application has a wildcard star (aka _*)
   *  at the end of it.
   */</span>
  case class <a title="class RepeatedType extends Types.this.Type with Product with Serializable" id="scala.reflect.internal;Types.RepeatedType.readResolve">RepeatedType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Types.this.Type" id="scala.reflect.internal;Types;RepeatedType.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;RepeatedType.safeToString">safeToString</a>: <span title="String">String</span> = <a href="../../Predef.scala.html#scala.Predef.any2stringadd(6b32434ac5)" title="(self: Types.this.Type)any2stringadd[Types.this.Type]">tp</a> <a href="../../Predef.scala.html#scala.Predef;any2stringadd.+" title="(other: String)String">+</a> <span title="String(&quot;: _*&quot;)" class="string">&quot;: _*&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A temporary type representing the erasure of a user-defined value type.
   *  Created during phase erasure, eliminated again in posterasure.
   *
   *  SI-6385 Erasure's creation of bridges considers method signatures `exitingErasure`,
   *          which contain `ErasedValueType`-s. In order to correctly consider the overriding
   *          and overriden signatures as equivalent in `run/t6385.scala`, it is critical that
   *          this type contains the erasure of the wrapped type, rather than the unerased type
   *          of the value class itself, as was originally done.
   *
   *  @param   valueClazz        The value class symbol
   *  @param   erasedUnderlying  The erased type of the unboxed value
   */</span>
  abstract case class <a href="#scala.reflect.internal;Types;ErasedValueType.productElement.x$1" title="class ErasedValueType extends Types.this.UniqueType with Product with Serializable" id="scala.reflect.internal;Types;ErasedValueType">ErasedValueType</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Types.this.Symbol" id="scala.reflect.internal;Types;ErasedValueType.valueClazz">valueClazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;ErasedValueType.erasedUnderlying">erasedUnderlying</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;UniqueType" title="Types.this.UniqueType">UniqueType</a> <span class="delimiter">{</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;ErasedValueType.safeToString">safeToString</a> = <a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;ErasedValueType(&quot;)">ErasedValueType($</span><a href="#scala.reflect.internal;Types;ErasedValueType.valueClazz" title="=&gt; Types.this.Symbol">valueClazz</a><span title="String(&quot;, &quot;)">, $</span><a href="#scala.reflect.internal;Types;ErasedValueType.erasedUnderlying" title="=&gt; Types.this.Type">erasedUnderlying</a><span title="String(&quot;)&quot;)" class="string">)&quot;</span>
  <span class="delimiter">}</span>

  final class <a title="class UniqueErasedValueType extends Types.this.ErasedValueType" id="scala.reflect.internal;Types;UniqueErasedValueType">UniqueErasedValueType</a><a href="#scala.reflect.internal;Types;UniqueErasedValueType" title="Types.this.UniqueErasedValueType" class="delimiter">(</a><a title="Types.this.Symbol" id="scala.reflect.internal;Types;UniqueErasedValueType.valueClazz">valueClazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types;UniqueErasedValueType.erasedUnderlying">erasedUnderlying</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;ErasedValueType" title="Types.this.ErasedValueType">ErasedValueType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;UniqueErasedValueType.valueClazz" title="Types.this.Symbol">valueClazz</a>, <a href="#scala.reflect.internal;Types;UniqueErasedValueType.erasedUnderlying" title="Types.this.Type">erasedUnderlying</a><span class="delimiter">)</span>

  object <a title="Types.this.ErasedValueType.type" id="scala.reflect.internal;Types.ErasedValueType.readResolve">ErasedValueType</a> <a href="#scala.reflect.internal;Types.ErasedValueType.readResolve" title="Types.this.ErasedValueType.type" class="delimiter">{</a>
    def <a title="(valueClazz: Types.this.Symbol, erasedUnderlying: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.ErasedValueType.apply">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.ErasedValueType.apply.valueClazz">valueClazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.ErasedValueType.apply.erasedUnderlying">erasedUnderlying</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.ErasedValueType.apply.valueClazz" title="Types.this.Symbol">valueClazz</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a>, <span title="String(&quot;ErasedValueType over NoSymbol&quot;)" class="string">&quot;ErasedValueType over NoSymbol&quot;</span><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types.unique" title="(tp: Types.this.UniqueErasedValueType)Types.this.UniqueErasedValueType">unique</a><span class="delimiter">(</span>new <a href="#scala.reflect.internal;Types;UniqueErasedValueType" title="Types.this.UniqueErasedValueType">UniqueErasedValueType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.ErasedValueType.apply.valueClazz" title="Types.this.Symbol">valueClazz</a>, <a href="#scala.reflect.internal;Types.ErasedValueType.apply.erasedUnderlying" title="Types.this.Type">erasedUnderlying</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A class representing an as-yet unevaluated type.
   */</span>
  abstract class <a title="class LazyType extends Types.this.Type" id="scala.reflect.internal;Types;LazyType">LazyType</a> extends <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> <span class="delimiter">{</span>
    override def <a title="=&gt; Boolean" id="scala.reflect.internal;Types;LazyType.isComplete">isComplete</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false
    override def <a title="(sym: Types.this.Symbol)Unit" id="scala.reflect.internal;Types;LazyType.complete">complete</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types;LazyType.complete.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;LazyType.safeToString">safeToString</a> = <span title="String(&quot;&lt;?&gt;&quot;)" class="string">&quot;&lt;?&gt;&quot;</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;LazyType.kind">kind</a> = <span title="String(&quot;LazyType&quot;)" class="string">&quot;LazyType&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A marker trait representing an as-yet unevaluated type
   *  which doesn't assign flags to the underlying symbol.
   */</span>
  trait <a title="trait FlagAgnosticCompleter extends Types.this.LazyType" id="scala.reflect.internal;Types;FlagAgnosticCompleter">FlagAgnosticCompleter</a> extends <a href="#scala.reflect.internal;Types;LazyType" title="Types.this.LazyType">LazyType</a>

  <span class="comment">/** A marker trait representing an as-yet unevaluated type
   *  which assigns flags to the underlying symbol.
   */</span>
  trait <a title="trait FlagAssigningCompleter extends Types.this.LazyType" id="scala.reflect.internal;Types;FlagAssigningCompleter">FlagAssigningCompleter</a> extends <a href="#scala.reflect.internal;Types;LazyType" title="Types.this.LazyType">LazyType</a>

  abstract class <a title="class LazyPolyType extends Types.this.LazyType" id="scala.reflect.internal;Types;LazyPolyType">LazyPolyType</a><a href="#scala.reflect.internal;Types;LazyPolyType" title="Types.this.LazyPolyType" class="delimiter">(</a>override val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types;LazyPolyType.typeParams">typeParams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;LazyType" title="Types.this.LazyType">LazyType</a> <span class="delimiter">{</span>
    override def <a title="=&gt; String" id="scala.reflect.internal;Types;LazyPolyType.safeToString">safeToString</a> =
      <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types;LazyPolyType.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> else <a href="TypeDebugging.scala.html#scala.reflect.internal;TypeDebugging.typeParamsString" title="(tp: Types.this.Type)String">typeParamsString</a><span class="delimiter">(</span>this<span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> super.<a href="#scala.reflect.internal;Types;LazyType.safeToString" title="=&gt; String">safeToString</a>
  <span class="delimiter">}</span>

<span class="comment">// Creators ---------------------------------------------------------------</span>

  <span class="comment">/** Rebind symbol `sym` to an overriding member in type `pre`. */</span>
  private def <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol" id="scala.reflect.internal;Types.rebind">rebind</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.rebind.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.rebind.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.rebind.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isOverridableMember" title="=&gt; Boolean">isOverridableMember</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.rebind.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types.rebind.pre" title="Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.rebind.sym" title="Types.this.Symbol">sym</a>
    else <a href="#scala.reflect.internal;Types.rebind.pre" title="Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.nonPrivateMember" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.rebind.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym.NameType">name</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.suchThat" title="(cond: Types.this.Symbol =&gt; Boolean)Types.this.Symbol">suchThat</a> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="scala.reflect.internal;Types.rebind.$anonfun.sym">sym</a> =&gt;
      <span class="comment">// SI-7928 `isModuleNotMethod` is here to avoid crashing with spuriously &quot;overloaded&quot; module accessor and module symbols.</span>
      <span class="comment">//         These appear after refchecks eliminates ModuleDefs that implement an interface.</span>
      <span class="comment">//         Here, we exclude the module symbol, which allows us to bind to the accessor.</span>
      <span class="comment">// SI-8054 We must only do this after refchecks, otherwise we exclude the module symbol which does not yet have an accessor!</span>
      val isModuleWithAccessor = <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.refChecked" title="=&gt; Boolean">refChecked</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="Boolean" id="scala.reflect.internal;Types.rebind.$anonfun.isModuleWithAccessor">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.rebind.$anonfun.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isModuleNotMethod" title="=&gt; Boolean">isModuleNotMethod</a>
      <a href="#scala.reflect.internal;Types.rebind.$anonfun.sym" title="Types.this.Symbol">sym</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isType" title="=&gt; Boolean">isType</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.rebind.$anonfun.isModuleWithAccessor" title="Boolean">isModuleWithAccessor</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.rebind.$anonfun.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isStable" title="=&gt; Boolean">isStable</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.rebind.$anonfun.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.hasVolatileType" title="=&gt; Boolean">hasVolatileType</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.orElse" title="(alt: =&gt; Types.this.Symbol)Types.this.Symbol">orElse</a> <a href="#scala.reflect.internal;Types.rebind.sym" title="Types.this.Symbol">sym</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Convert a `super` prefix to a this-type if `sym` is abstract or final. */</span>
  private def <a title="(tp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types.removeSuper">removeSuper</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.removeSuper.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.removeSuper.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.removeSuper.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case SuperType<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.removeSuper.thistp">thistp</a>, _<span class="delimiter">)</span> =&gt;
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.removeSuper.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isEffectivelyFinal" title="=&gt; Boolean">isEffectivelyFinal</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.removeSuper.sym" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#scala.reflect.internal;HasFlags.isDeferred" title="=&gt; Boolean">isDeferred</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.removeSuper.thistp" title="Types.this.Type">thistp</a>
      else <a href="#scala.reflect.internal;Types.removeSuper.tp" title="Types.this.Type">tp</a>
    case _ =&gt;
      <a href="#scala.reflect.internal;Types.removeSuper.tp" title="Types.this.Type">tp</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The canonical creator for single-types */</span>
  def <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types.singleType">singleType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.singleType.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.singleType.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types.singleType.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; Types.this.Type">tpe</a>.<a href="#scala.reflect.internal;Types;Type.resultType(9b9cdebb0f)" title="=&gt; Types.this.Type">resultType</a>
    else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.singleType.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isRootPackage" title="=&gt; Boolean">isRootPackage</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types.ThisType.apply(a489b0ed7a)" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.singleType.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.moduleClass" title="=&gt; Types.this.Symbol">moduleClass</a><span class="delimiter">)</span>
    else <span class="delimiter">{</span>
      var <a title="Types.this.Symbol" id="scala.reflect.internal;Types.singleType.sym1">sym1</a> = <a href="#scala.reflect.internal;Types.rebind" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.singleType.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.singleType.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
      val <a title="Types.this.Type" id="scala.reflect.internal;Types.singleType.pre1">pre1</a> = <a href="#scala.reflect.internal;Types.removeSuper" title="(tp: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">removeSuper</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.singleType.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.singleType.sym1" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.singleType.pre1" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types.singleType.pre" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.singleType.sym1" title="Types.this.Symbol">sym1</a> = <a href="#scala.reflect.internal;Types.rebind" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.singleType.pre1" title="Types.this.Type">pre1</a>, <a href="#scala.reflect.internal;Types.singleType.sym1" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types.SingleType.apply(383b209a7d)" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">SingleType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.singleType.pre1" title="Types.this.Type">pre1</a>, <a href="#scala.reflect.internal;Types.singleType.sym1" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** the canonical creator for a refined type with a given scope */</span>
  def <a title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type" id="scala.reflect.internal;Types.refinedType(b06f606da5)">refinedType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.refinedType(b06f606da5).parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.refinedType(b06f606da5).owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Scope" id="scala.reflect.internal;Types.refinedType(b06f606da5).decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a>, <a title="Types.this.Position" id="scala.reflect.internal;Types.refinedType(b06f606da5).pos">pos</a>: <a href="util/Position.scala.html#scala.reflect.internal.util;Position" title="Types.this.Position">Position</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.refinedType(b06f606da5).parents" title="List[Types.this.Type]">parents</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ObjectTpe" title="=&gt; Types.this.Type">ObjectTpe</a> else <a href="#scala.reflect.internal;Types.refinedType(b06f606da5).parents" title="List[Types.this.Type]">parents</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Type">head</a>
    else <span class="delimiter">{</span>
      val <a title="Types.this.RefinementClassSymbol" id="scala.reflect.internal;Types.refinedType(b06f606da5).clazz">clazz</a> = <a href="#scala.reflect.internal;Types.refinedType(b06f606da5).owner" title="Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.newRefinementClass" title="(pos: Types.this.Position)Types.this.RefinementClassSymbol">newRefinementClass</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.refinedType(b06f606da5).pos" title="Types.this.Position">pos</a><span class="delimiter">)</span>
      val <a title="Types.this.RefinedType" id="scala.reflect.internal;Types.refinedType(b06f606da5).result">result</a> = <a href="#scala.reflect.internal;Types.RefinedType.apply(37899be632)" title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.refinedType(b06f606da5).parents" title="List[Types.this.Type]">parents</a>, <a href="#scala.reflect.internal;Types.refinedType(b06f606da5).decls" title="Types.this.Scope">decls</a>, <a href="#scala.reflect.internal;Types.refinedType(b06f606da5).clazz" title="Types.this.RefinementClassSymbol">clazz</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types.refinedType(b06f606da5).clazz" title="Types.this.RefinementClassSymbol">clazz</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="(info: Types.this.Type)clazz.type">setInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.refinedType(b06f606da5).result" title="Types.this.RefinedType">result</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types.refinedType(b06f606da5).result" title="Types.this.RefinedType">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The canonical creator for a refined type with an initially empty scope.
   */</span>
  def <a title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types.refinedType(08cdf2d3e2)">refinedType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.refinedType(08cdf2d3e2).parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.refinedType(08cdf2d3e2).owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
    <a href="#scala.reflect.internal;Types.refinedType(b06f606da5)" title="(parents: List[Types.this.Type], owner: Types.this.Symbol, decls: Types.this.Scope, pos: Types.this.Position)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.refinedType(08cdf2d3e2).parents" title="List[Types.this.Type]">parents</a>, <a href="#scala.reflect.internal;Types.refinedType(08cdf2d3e2).owner" title="Types.this.Symbol">owner</a>, <a href="Scopes.scala.html#scala.reflect.internal;Scopes.newScope" title="=&gt; Types.this.Scope">newScope</a>, <a href="#scala.reflect.internal;Types.refinedType(08cdf2d3e2).owner" title="Types.this.Symbol">owner</a>.<a href="StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.pos" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span>

  def <a title="(original: Types.this.RefinedType, parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.Type" id="scala.reflect.internal;Types.copyRefinedType">copyRefinedType</a><span class="delimiter">(</span><a title="Types.this.RefinedType" id="scala.reflect.internal;Types.copyRefinedType.original">original</a>: <a href="#scala.reflect.internal;Types;RefinedType" title="Types.this.RefinedType">RefinedType</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.copyRefinedType.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="scala.reflect.internal;Types.copyRefinedType.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a><span class="delimiter">)</span> =
    if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.copyRefinedType.parents" title="List[Types.this.Type]">parents</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types.copyRefinedType.original" title="Types.this.RefinedType">original</a>.<a href="#scala.reflect.internal;Types;RefinedType.parents" title="=&gt; List[Types.this.Type]">parents</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.copyRefinedType.decls" title="Types.this.Scope">decls</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types.copyRefinedType.original" title="Types.this.RefinedType">original</a>.<a href="#scala.reflect.internal;Types;RefinedType.decls" title="=&gt; Types.this.Scope">decls</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.copyRefinedType.original" title="Types.this.RefinedType">original</a>
    else <span class="delimiter">{</span>
      val <a title="Types.this.Symbol" id="scala.reflect.internal;Types.copyRefinedType.owner">owner</a> = <a href="#scala.reflect.internal;Types.copyRefinedType.original" title="Types.this.RefinedType">original</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a>
      val <a title="Types.this.Type" id="scala.reflect.internal;Types.copyRefinedType.result">result</a> = <a href="#scala.reflect.internal;Types.refinedType(08cdf2d3e2)" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.copyRefinedType.parents" title="List[Types.this.Type]">parents</a>, <a href="#scala.reflect.internal;Types.copyRefinedType.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
      val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.copyRefinedType.syms1">syms1</a> = <a href="#scala.reflect.internal;Types.copyRefinedType.decls" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.toList" title="=&gt; List[Types.this.Symbol]">toList</a>
      for <span class="delimiter">(</span><span title="Types.this.Symbol">sym</span> &lt;- <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: Types.this.Symbol =&gt; Types.this.Symbol#TypeOfClonedSymbol)Unit">syms1</a><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types.copyRefinedType.result" title="Types.this.Type">result</a>.<a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.enter" title="(sym: sym.TypeOfClonedSymbol)sym.TypeOfClonedSymbol">enter</a><span class="delimiter">(</span><span title="Types.this.Symbol">sym</span>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.cloneSymbol(d28285cb23)" title="(newOwner: Types.this.Symbol)sym.TypeOfClonedSymbol">cloneSymbol</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.copyRefinedType.result" title="Types.this.Type">result</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span>
      val <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.copyRefinedType.syms2">syms2</a> = <a href="#scala.reflect.internal;Types.copyRefinedType.result" title="Types.this.Type">result</a>.<a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.toList" title="=&gt; List[Types.this.Symbol]">toList</a>
      val <a title="Types.this.Type" id="scala.reflect.internal;Types.copyRefinedType.resultThis">resultThis</a> = <a href="#scala.reflect.internal;Types.copyRefinedType.result" title="Types.this.Type">result</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.thisType" title="=&gt; Types.this.Type">thisType</a>
      for <span class="delimiter">(</span><span title="Types.this.Symbol">sym</span> &lt;- <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: Types.this.Symbol =&gt; Types.this.Symbol)Unit">syms2</a><span class="delimiter">)</span>
        <span title="Types.this.Symbol">sym</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.modifyInfo" title="(f: Types.this.Type =&gt; Types.this.Type)sym.type">modifyInfo</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.copyRefinedType.$anonfun.$anonfun.x$48" title="Types.this.Type">_</a> <a href="#scala.reflect.internal;Types;Type.substThisAndSym" title="(from: Types.this.Symbol, to: Types.this.Type, symsFrom: List[Types.this.Symbol], symsTo: List[Types.this.Symbol])Types.this.Type">substThisAndSym</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.copyRefinedType.original" title="Types.this.RefinedType">original</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#scala.reflect.internal;Types.copyRefinedType.resultThis" title="Types.this.Type">resultThis</a>, <a href="#scala.reflect.internal;Types.copyRefinedType.syms1" title="List[Types.this.Symbol]">syms1</a>, <a href="#scala.reflect.internal;Types.copyRefinedType.syms2" title="List[Types.this.Symbol]">syms2</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#scala.reflect.internal;Types.copyRefinedType.result" title="Types.this.Type">result</a>
    <span class="delimiter">}</span>

  <span class="comment">/** The canonical creator for typerefs
   *  todo: see how we can clean this up a bit
   */</span>
  def <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types.typeRef">typeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.typeRef.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.typeRef.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.typeRef.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <span class="comment">// type alias selections are rebound in TypeMap (&quot;coevolved&quot;,</span>
    <span class="comment">// actually -- see #3731) e.g., when type parameters that are</span>
    <span class="comment">// referenced by the alias are instantiated in the prefix. See</span>
    <span class="comment">// pos/depmet_rebind_typealias.</span>

    val <a title="Types.this.Symbol" id="scala.reflect.internal;Types.typeRef.sym1">sym1</a> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeRef.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAbstractType" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.rebind" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeRef.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.typeRef.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> else <a href="#scala.reflect.internal;Types.typeRef.sym" title="Types.this.Symbol">sym</a>
    <span class="comment">// don't expand cyclical type alias</span>
    <span class="comment">// we require that object is initialized, thus info.typeParams instead of typeParams.</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeRef.sym1" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAliasType" title="=&gt; Boolean">isAliasType</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.sameLength" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeRef.sym1" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#scala.reflect.internal;Types.typeRef.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.typeRef.sym1" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.lockOK" title="=&gt; Boolean">lockOK</a><span class="delimiter">)</span>
      throw new <a href="#scala.reflect.internal;Types.RecoverableCyclicReference.readResolve" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeRef.sym1" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>

    val <a title="Types.this.Type" id="scala.reflect.internal;Types.typeRef.pre1">pre1</a> = <a href="#scala.reflect.internal;Types.typeRef.pre" title="Types.this.Type">pre</a> match <span class="delimiter">{</span>
      case <a title="Types.this.SuperType" id="scala.reflect.internal;Types.typeRef.pre1.x">x</a>: <a href="#scala.reflect.internal;Types;SuperType" title="Types.this.SuperType">SuperType</a> if <a href="#scala.reflect.internal;Types.typeRef.sym1" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isEffectivelyFinal" title="=&gt; Boolean">isEffectivelyFinal</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.typeRef.sym1" title="Types.this.Symbol">sym1</a>.<a href="HasFlags.scala.html#scala.reflect.internal;HasFlags.isDeferred" title="=&gt; Boolean">isDeferred</a> =&gt;
        <a href="#scala.reflect.internal;Types.typeRef.pre1.x" title="Types.this.SuperType">x</a>.<a href="#scala.reflect.internal;Types;SuperType.thistpe" title="=&gt; Types.this.Type">thistpe</a>
      case _ =&gt; <a href="#scala.reflect.internal;Types.typeRef.pre" title="Types.this.Type">pre</a>
    <span class="delimiter">}</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeRef.pre" title="Types.this.Type">pre</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types.typeRef.pre1" title="Types.this.Type">pre1</a><span class="delimiter">)</span>                                <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73)" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeRef.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.typeRef.sym1" title="Types.this.Symbol">sym1</a>, <a href="#scala.reflect.internal;Types.typeRef.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeRef.sym1" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAbstractType" title="=&gt; Boolean">isAbstractType</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.typeRef.sym1" title="Types.this.Symbol">sym1</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isClass" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span>  <a href="#scala.reflect.internal;Types.typeRef" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeRef.pre1" title="Types.this.Type">pre1</a>, <a href="#scala.reflect.internal;Types.rebind" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Symbol">rebind</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeRef.pre1" title="Types.this.Type">pre1</a>, <a href="#scala.reflect.internal;Types.typeRef.sym1" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types.typeRef.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    else                                            <a href="#scala.reflect.internal;Types.typeRef" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeRef.pre1" title="Types.this.Type">pre1</a>, <a href="#scala.reflect.internal;Types.typeRef.sym1" title="Types.this.Symbol">sym1</a>, <a href="#scala.reflect.internal;Types.typeRef.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// Optimization to avoid creating unnecessary new typerefs.</span>
  def <a title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types.copyTypeRef">copyTypeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.copyTypeRef.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.copyTypeRef.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.copyTypeRef.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.copyTypeRef.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.copyTypeRef.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.copyTypeRef.pre0">pre0</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.copyTypeRef.sym0">sym0</a>, _<span class="delimiter">)</span> if <a href="#scala.reflect.internal;Types.copyTypeRef.pre" title="Types.this.Type">pre</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types.copyTypeRef.pre0" title="Types.this.Type">pre0</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.copyTypeRef.sym0" title="Types.this.Symbol">sym0</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym0.NameType">name</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types.copyTypeRef.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym.NameType">name</a> =&gt;
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.copyTypeRef.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAliasType" title="=&gt; Boolean">isAliasType</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.sameLength" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.copyTypeRef.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#scala.reflect.internal;Types.copyTypeRef.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.copyTypeRef.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.lockOK" title="=&gt; Boolean">lockOK</a><span class="delimiter">)</span>
        throw new <a href="#scala.reflect.internal;Types.RecoverableCyclicReference.readResolve" title="Types.this.RecoverableCyclicReference">RecoverableCyclicReference</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.copyTypeRef.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>

      <a href="#scala.reflect.internal;Types.TypeRef.apply(2232bf1c73)" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">TypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.copyTypeRef.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.copyTypeRef.sym" title="Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types.copyTypeRef.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
    case _ =&gt;
      <a href="#scala.reflect.internal;Types.typeRef" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.copyTypeRef.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.copyTypeRef.sym" title="Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types.copyTypeRef.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The canonical creator for implicit method types */</span>
  def <a title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.JavaMethodType" id="scala.reflect.internal;Types.JavaMethodType">JavaMethodType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.JavaMethodType.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.internal;Types.JavaMethodType.resultType">resultType</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;JavaMethodType" title="Types.this.JavaMethodType">JavaMethodType</a> =
    new <a href="#scala.reflect.internal;Types;JavaMethodType" title="Types.this.JavaMethodType">JavaMethodType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.JavaMethodType.params" title="List[Types.this.Symbol]">params</a>, <a href="#scala.reflect.internal;Types.JavaMethodType.resultType" title="Types.this.Type">resultType</a><span class="delimiter">)</span> <span class="comment">// don't unique this!</span>

  <span class="comment">/** Create a new MethodType of the same class as tp, i.e. keep JavaMethodType */</span>
  def <a title="(tp: Types.this.Type, params: List[Types.this.Symbol], restpe: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.copyMethodType">copyMethodType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.copyMethodType.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.copyMethodType.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.internal;Types.copyMethodType.restpe">restpe</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.copyMethodType.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case _: <a href="#scala.reflect.internal;Types;JavaMethodType" title="Types.this.JavaMethodType">JavaMethodType</a> =&gt; <a href="#scala.reflect.internal;Types.JavaMethodType" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.JavaMethodType">JavaMethodType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.copyMethodType.params" title="List[Types.this.Symbol]">params</a>, <a href="#scala.reflect.internal;Types.copyMethodType.restpe" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
    case _                 =&gt; <a href="#scala.reflect.internal;Types;MethodType" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">MethodType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.copyMethodType.params" title="List[Types.this.Symbol]">params</a>, <a href="#scala.reflect.internal;Types.copyMethodType.restpe" title="Types.this.Type">restpe</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A creator for intersection type where intersections of a single type are
   *  replaced by the type itself, and repeated parent classes are merged.
   *
   *  !!! Repeated parent classes are not merged - is this a bug in the
   *  comment or in the code?
   */</span>
  def <a title="(tps: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types.intersectionType(b28944ca7d)">intersectionType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.intersectionType(b28944ca7d).tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.intersectionType(b28944ca7d).owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.intersectionType(b28944ca7d).tps" title="List[Types.this.Type]">tps</a> match <span class="delimiter">{</span>
    case <a title="Types.this.Type" id="scala.reflect.internal;Types.intersectionType(b28944ca7d).tp">tp</a> :: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> =&gt; <a href="#scala.reflect.internal;Types.intersectionType(b28944ca7d).tp" title="Types.this.Type">tp</a>
    case _         =&gt; <a href="#scala.reflect.internal;Types.refinedType(08cdf2d3e2)" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.intersectionType(b28944ca7d).tps" title="List[Types.this.Type]">tps</a>, <a href="#scala.reflect.internal;Types.intersectionType(b28944ca7d).owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/** A creator for intersection type where intersections of a single type are
   *  replaced by the type itself.
   */</span>
  def <a title="(tps: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types.intersectionType(8490c4bc7b)">intersectionType</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.intersectionType(8490c4bc7b).tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.intersectionType(8490c4bc7b).tps" title="List[Types.this.Type]">tps</a> match <span class="delimiter">{</span>
    case <a title="Types.this.Type" id="scala.reflect.internal;Types.intersectionType(8490c4bc7b).tp">tp</a> :: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>  =&gt; <a href="#scala.reflect.internal;Types.intersectionType(8490c4bc7b).tp" title="Types.this.Type">tp</a>
    case _          =&gt; <a href="#scala.reflect.internal;Types.refinedType(08cdf2d3e2)" title="(parents: List[Types.this.Type], owner: Types.this.Symbol)Types.this.Type">refinedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.intersectionType(8490c4bc7b).tps" title="List[Types.this.Type]">tps</a>, <a href="tpe/CommonOwners.scala.html#scala.reflect.internal.tpe;CommonOwners.commonOwner(91644a9783)" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.intersectionType(8490c4bc7b).tps" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

<span class="comment">/**** This implementation to merge parents was checked in in commented-out
      form and has languished unaltered for five years.  I think we should
      use it or lose it.

      def merge(tps: List[Type]): List[Type] = tps match {
        case tp :: tps1 =&gt;
          val tps1a = tps1 filter (_.typeSymbol.==(tp.typeSymbol))
          val tps1b = tps1 filter (_.typeSymbol.!=(tp.typeSymbol))
          mergePrefixAndArgs(tps1a, -1) match {
            case Some(tp1) =&gt; tp1 :: merge(tps1b)
            case None =&gt; throw new MalformedType(
              &quot;malformed type: &quot;+refinedType(tps, owner)+&quot; has repeated parent class &quot;+
              tp.typeSymbol+&quot; with incompatible prefixes or type arguments&quot;)
          }
        case _ =&gt; tps
      }
      refinedType(merge(tps), owner)
*/</span>

  <span class="comment">/** A creator for type applications */</span>
  def <a title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types.appliedType(c7fb433f73)">appliedType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.appliedType(c7fb433f73).tycon">tycon</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.appliedType(c7fb433f73).args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).args" title="List[Types.this.Type]">args</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span>
      return <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).tycon" title="Types.this.Type">tycon</a> <span class="comment">//@M! `if (args.isEmpty) tycon' is crucial (otherwise we create new types in phases after typer and then they don't get adapted (??))</span>

    <span class="comment">/* Disabled - causes cycles in tcpoly tests. */</span>
    if <span class="delimiter">(</span>false <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isDefinitionsInitialized" title="=&gt; Boolean">isDefinitionsInitialized</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isUseableAsTypeArgs" title="(tps: List[Types.this.Type])Boolean">isUseableAsTypeArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <span class="delimiter">{</span>
        val <a title="String" id="scala.reflect.internal;Types.appliedType(c7fb433f73).tapp_s">tapp_s</a> = <a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;&quot;&quot;<span title="String(&quot;&quot;)">$</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).tycon" title="Types.this.Type">tycon</a><span title="String(&quot;[&quot;)">[$</span><span class="delimiter">{</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).args" title="List[Types.this.Type]">args</a> <a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">}</span><span title="String(&quot;]&quot;)" class="string">]&quot;&quot;&quot;</span>
        val arg_s  = <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).args" title="List[Types.this.Type]">args</a> <a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filterNot" title="(p: Types.this.Type =&gt; Boolean)List[Types.this.Type]">filterNot</a> <a href="#scala.reflect.internal;Types.isUseableAsTypeArg" title="(tp: Types.this.Type)Boolean">isUseableAsTypeArg</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Type =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],String,List[String]])List[String]">map</a> <span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.appliedType(c7fb433f73).arg_s.$anonfun.t">t</a> =&gt; <a href="../../Predef.scala.html#scala.Predef.any2stringadd(6b32434ac5)" title="(self: Types.this.Type)any2stringadd[Types.this.Type]">t</a> <a href="../../Predef.scala.html#scala.Predef;any2stringadd.+" title="(other: String)String">+</a> <span title="String(&quot;/&quot;)" class="string">&quot;/&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).arg_s.$anonfun.t" title="Types.this.Type">t</a>.<span title="()Class[_]">getClass</span><span class="delimiter">)</span> <a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="String" id="scala.reflect.internal;Types.appliedType(c7fb433f73).arg_s">mkString</a> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>
        <a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).tapp_s" title="String">tapp_s</a><span title="String(&quot; includes illegal type argument &quot;)"> includes illegal type argument $</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).arg_s" title="String">arg_s</a><span title="String(&quot;&quot;)" class="string">&quot;</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).tycon" title="Types.this.Type">tycon</a> match <span class="delimiter">{</span>
      case TypeRef<span class="delimiter">(</span><span title="Types.this.Type">pre</span>, <span title="Types.this.Symbol">sym</span> @ <span class="delimiter">(</span><a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.NothingClass" title="Types.this.definitions.NothingClass.type">NothingClass</a>|<a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyClass" title="=&gt; Types.this.ClassSymbol">AnyClass</a><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.copyTypeRef" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).tycon" title="Types.this.Type">tycon</a>, <span title="Types.this.Type">pre</span>, <span title="Types.this.Symbol">sym</span>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>   <span class="comment">//@M drop type args to Any/Nothing</span>
      case TypeRef<span class="delimiter">(</span><span title="Types.this.Type">pre</span>, <span title="Types.this.Symbol">sym</span>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>                         =&gt; <a href="#scala.reflect.internal;Types.copyTypeRef" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).tycon" title="Types.this.Type">tycon</a>, <span title="Types.this.Type">pre</span>, <span title="Types.this.Symbol">sym</span>, <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      case TypeRef<span class="delimiter">(</span><span title="Types.this.Type">pre</span>, <span title="Types.this.Symbol">sym</span>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.appliedType(c7fb433f73).bogons">bogons</a><span class="delimiter">)</span>                      =&gt; <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.devWarning" title="(msg: =&gt; String)Unit">devWarning</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;Dropping &quot;)">Dropping $</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).bogons" title="List[Types.this.Type]">bogons</a><span title="String(&quot; from &quot;)"> from $</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).tycon" title="Types.this.Type">tycon</a><span title="String(&quot; in appliedType.&quot;)" class="string"> in appliedType.&quot;</span><span class="delimiter">)</span> ; <a href="#scala.reflect.internal;Types.copyTypeRef" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).tycon" title="Types.this.Type">tycon</a>, <span title="Types.this.Type">pre</span>, <span title="Types.this.Symbol">sym</span>, <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      case PolyType<span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams</span>, <span title="Types.this.Type">restpe</span><span class="delimiter">)</span>                      =&gt; <span title="Types.this.Type">restpe</span>.<a href="#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams</span>, <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      case ExistentialType<span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams</span>, <span title="Types.this.Type">restpe</span><span class="delimiter">)</span>               =&gt; <a href="#scala.reflect.internal;Types.newExistentialType" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams</span>, <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><span title="Types.this.Type">restpe</span>, <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case <a title="Types.this.SingletonType" id="scala.reflect.internal;Types.appliedType(c7fb433f73).st">st</a>: <a href="#scala.reflect.internal;Types;SingletonType" title="Types.this.SingletonType">SingletonType</a>                              =&gt; <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).st" title="Types.this.SingletonType">st</a>.<a href="#scala.reflect.internal;Types;SingletonType.widen" title="=&gt; Types.this.Type">widen</a>, <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span> <span class="comment">// @M TODO: what to do? see bug1</span>
      case RefinedType<span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.appliedType(c7fb433f73).parents">parents</a>, <a title="Types.this.Scope" id="scala.reflect.internal;Types.appliedType(c7fb433f73).decls">decls</a><span class="delimiter">)</span>                    =&gt; <a href="#scala.reflect.internal;Types;RefinedType" title="(parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.RefinedType">RefinedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).parents" title="List[Types.this.Type]">parents</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Type =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Type],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).$anonfun.x$49" title="Types.this.Type">_</a>, <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).decls" title="Types.this.Scope">decls</a><span class="delimiter">)</span>   <span class="comment">// @PP: Can this be right?</span>
      case TypeBounds<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.appliedType(c7fb433f73).lo">lo</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.appliedType(c7fb433f73).hi">hi</a><span class="delimiter">)</span>                             =&gt; <a href="#scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3)" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).lo" title="Types.this.Type">lo</a>, <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).hi" title="Types.this.Type">hi</a>, <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// @PP: Can this be right?</span>
      case <a title="Types.this.TypeVar" id="scala.reflect.internal;Types.appliedType(c7fb433f73).tv">tv</a>@TypeVar<span class="delimiter">(</span>_, _<span class="delimiter">)</span>                               =&gt; <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).tv" title="Types.this.TypeVar">tv</a>.<a href="#scala.reflect.internal;Types;TypeVar.applyArgs" title="(newArgs: List[Types.this.Type])Types.this.TypeVar">applyArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
      case AnnotatedType<span class="delimiter">(</span><a title="List[Types.this.AnnotationInfo]" id="scala.reflect.internal;Types.appliedType(c7fb433f73).annots">annots</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.appliedType(c7fb433f73).underlying">underlying</a><span class="delimiter">)</span>              =&gt; <a href="#scala.reflect.internal;Types;AnnotatedType" title="(annotations: List[Types.this.AnnotationInfo], underlying: Types.this.Type)Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).annots" title="List[Types.this.AnnotationInfo]">annots</a>, <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).underlying" title="Types.this.Type">underlying</a>, <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case <a href="#scala.reflect.internal;Types.ErrorType.readResolve" title="Types.this.ErrorType.type">ErrorType</a> | <a href="#scala.reflect.internal;Types.WildcardType.readResolve" title="Types.this.WildcardType.type">WildcardType</a>                       =&gt; <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).tycon" title="Types.this.Type">tycon</a>
      case _                                              =&gt; <a href="Reporting.scala.html#scala.reflect.internal;Reporting.abort" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><a href="TypeDebugging.scala.html#scala.reflect.internal;TypeDebugging.debugString" title="(tp: Types.this.Type)String">debugString</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(c7fb433f73).tycon" title="Types.this.Type">tycon</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(tycon: Types.this.Type, args: Types.this.Type*)Types.this.Type" id="scala.reflect.internal;Types.appliedType(aa8684a9c7)">appliedType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.appliedType(aa8684a9c7).tycon">tycon</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type*" id="scala.reflect.internal;Types.appliedType(aa8684a9c7).args">args</a>: <span title="Types.this.Type*">Type</span>*<span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
    <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(aa8684a9c7).tycon" title="Types.this.Type">tycon</a>, <a href="#scala.reflect.internal;Types.appliedType(aa8684a9c7).args" title="Types.this.Type*">args</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[Types.this.Type]">toList</a><span class="delimiter">)</span>

  def <a title="(tyconSym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="scala.reflect.internal;Types.appliedType(9431dfc716)">appliedType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.appliedType(9431dfc716).tyconSym">tyconSym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.appliedType(9431dfc716).args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
    <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(9431dfc716).tyconSym" title="Types.this.Symbol">tyconSym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeConstructor" title="=&gt; Types.this.Type">typeConstructor</a>, <a href="#scala.reflect.internal;Types.appliedType(9431dfc716).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>

  <span class="comment">/** Very convenient. */</span>
  def <a title="(tyconSym: Types.this.Symbol, args: Types.this.Type*)Types.this.Type" id="scala.reflect.internal;Types.appliedType(e35fed9e9d)">appliedType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.appliedType(e35fed9e9d).tyconSym">tyconSym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type*" id="scala.reflect.internal;Types.appliedType(e35fed9e9d).args">args</a>: <span title="Types.this.Type*">Type</span>*<span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
    <a href="#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.appliedType(e35fed9e9d).tyconSym" title="Types.this.Symbol">tyconSym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeConstructor" title="=&gt; Types.this.Type">typeConstructor</a>, <a href="#scala.reflect.internal;Types.appliedType(e35fed9e9d).args" title="Types.this.Type*">args</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[Types.this.Type]">toList</a><span class="delimiter">)</span>

  <span class="comment">/** A creator and extractor for type parameterizations that strips empty type parameter lists.
   *  Use this factory method to indicate the type has kind * (it's a polymorphic value)
   *  until we start tracking explicit kinds equivalent to typeFun (except that the latter requires tparams nonEmpty).
   *
   *  PP to AM: I've co-opted this for where I know tparams may well be empty, and
   *  expecting to get back `tpe` in such cases.  Re being &quot;forgiving&quot; below,
   *  can we instead say this is the canonical creator for polyTypes which
   *  may or may not be poly? (It filched the standard &quot;canonical creator&quot; name.)
   */</span>
  object <a title="Types.this.GenPolyType.type" id="scala.reflect.internal;Types.GenPolyType">GenPolyType</a> <a href="#scala.reflect.internal;Types.GenPolyType" title="Types.this.GenPolyType.type" class="delimiter">{</a>
    def <a title="(tparams: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.GenPolyType.apply">apply</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.GenPolyType.apply.tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.internal;Types.GenPolyType.apply.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      <a href="#scala.reflect.internal;Types.GenPolyType.apply.tpe" title="Types.this.Type">tpe</a> match <span class="delimiter">{</span>
        case MethodType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
          <a href="../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.GenPolyType.apply.tparams" title="List[Types.this.Symbol]">tparams</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.GenPolyType.apply.$anonfun.x$50" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isInvariant" title="=&gt; Boolean">isInvariant</a><span class="delimiter">)</span>, <span title="String(&quot;Trying to create a method with variant type parameters: &quot;)" class="string">&quot;Trying to create a method with variant type parameters: &quot;</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: List[Types.this.Symbol], _2: Types.this.Type)(List[Types.this.Symbol], Types.this.Type)" class="delimiter">(</a><a href="#scala.reflect.internal;Types.GenPolyType.apply.tparams" title="List[Types.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal;Types.GenPolyType.apply.tpe" title="Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case _                =&gt;
      <span class="delimiter">}</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.GenPolyType.apply.tparams" title="List[Types.this.Symbol]">tparams</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.typeFun" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.GenPolyType.apply.tparams" title="List[Types.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal;Types.GenPolyType.apply.tpe" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
      else <a href="#scala.reflect.internal;Types.GenPolyType.apply.tpe" title="Types.this.Type">tpe</a> <span class="comment">// it's okay to be forgiving here</span>
    <span class="delimiter">}</span>
    def <a title="(tpe: Types.this.Type)Option[(List[Types.this.Symbol], Types.this.Type)]" id="scala.reflect.internal;Types.GenPolyType.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.GenPolyType.unapply.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(List[Types.this.Symbol], Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#scala.reflect.internal;Types.GenPolyType.unapply.tpe" title="Types.this.Type">tpe</a> match <span class="delimiter">{</span>
      case PolyType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.GenPolyType.unapply.tparams">tparams</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.GenPolyType.unapply.restpe">restpe</a><span class="delimiter">)</span> =&gt; <a href="../../Option.scala.html#scala;Some" title="(x: (List[Types.this.Symbol], Types.this.Type))Some[(List[Types.this.Symbol], Types.this.Type)]">Some</a><span class="delimiter">(</span><a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: List[Types.this.Symbol], _2: Types.this.Type)(List[Types.this.Symbol], Types.this.Type)" class="delimiter">(</a><a href="#scala.reflect.internal;Types.GenPolyType.unapply.tparams" title="List[Types.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal;Types.GenPolyType.unapply.restpe" title="Types.this.Type">restpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case _                         =&gt; <a href="../../Option.scala.html#scala;Some" title="(x: (scala.collection.immutable.Nil.type, Types.this.Type))Some[(scala.collection.immutable.Nil.type, Types.this.Type)]">Some</a><span class="delimiter">(</span><a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: scala.collection.immutable.Nil.type, _2: Types.this.Type)(scala.collection.immutable.Nil.type, Types.this.Type)" class="delimiter">(</a><a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#scala.reflect.internal;Types.GenPolyType.unapply.tpe" title="Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  def <a title="(params: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.genPolyType">genPolyType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.genPolyType.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.internal;Types.genPolyType.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.GenPolyType.apply" title="(tparams: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type">GenPolyType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.genPolyType.params" title="List[Types.this.Symbol]">params</a>, <a href="#scala.reflect.internal;Types.genPolyType.tpe" title="Types.this.Type">tpe</a><span class="delimiter">)</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;use genPolyType(...) instead&quot;</span>, <span class="string">&quot;2.10.0&quot;</span><span class="delimiter">)</span> <span class="comment">// Used in reflection API</span>
  def <a title="(params: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.polyType">polyType</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.polyType.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.internal;Types.polyType.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.GenPolyType.apply" title="(tparams: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.Type">GenPolyType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.polyType.params" title="List[Types.this.Symbol]">params</a>, <a href="#scala.reflect.internal;Types.polyType.tpe" title="Types.this.Type">tpe</a><span class="delimiter">)</span>

  <span class="comment">/** A creator for anonymous type functions, where the symbol for the type function still needs to be created.
   *
   * TODO:
   * type params of anonymous type functions, which currently can only arise from normalising type aliases, are owned by the type alias of which they are the eta-expansion
   * higher-order subtyping expects eta-expansion of type constructors that arise from a class; here, the type params are owned by that class, but is that the right thing to do?
   */</span>
  def <a title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.typeFunAnon">typeFunAnon</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.typeFunAnon.tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.internal;Types.typeFunAnon.body">body</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.typeFun" title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type">typeFun</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeFunAnon.tps" title="List[Types.this.Symbol]">tps</a>, <a href="#scala.reflect.internal;Types.typeFunAnon.body" title="Types.this.Type">body</a><span class="delimiter">)</span>

  <span class="comment">/** A creator for a type functions, assuming the type parameters tps already have the right owner. */</span>
  def <a title="(tps: List[Types.this.Symbol], body: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.typeFun">typeFun</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.typeFun.tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.internal;Types.typeFun.body">body</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types;PolyType" title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.PolyType">PolyType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeFun.tps" title="List[Types.this.Symbol]">tps</a>, <a href="#scala.reflect.internal;Types.typeFun.body" title="Types.this.Type">body</a><span class="delimiter">)</span>

  <span class="comment">/** A creator for existential types. This generates:
   *
   *  tpe1 where { tparams }
   *
   *  where `tpe1` is the result of extrapolating `tpe` with respect to `tparams`.
   *  Extrapolating means that type variables in `tparams` occurring
   *  in covariant positions are replaced by upper bounds, (minus any
   *  SingletonClass markers), type variables in `tparams` occurring in
   *  contravariant positions are replaced by upper bounds, provided the
   *  resulting type is legal with regard to stability, and does not contain any type
   *  variable in `tparams`.
   *
   *  The abstraction drops all type parameters that are not directly or
   *  indirectly referenced by type `tpe1`. If there are no remaining type
   *  parameters, simply returns result type `tpe`.
   */</span>
  def <a title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.existentialAbstraction">existentialAbstraction</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.existentialAbstraction.tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.internal;Types.existentialAbstraction.tpe0">tpe0</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.existentialAbstraction.tparams" title="List[Types.this.Symbol]">tparams</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.existentialAbstraction.tpe0" title="Types.this.Type">tpe0</a>
    else <span class="delimiter">{</span>
      val <a title="Types.this.Type" id="scala.reflect.internal;Types.existentialAbstraction.tpe">tpe</a>      = <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps.normalizeAliases.apply" title="(tp: Types.this.Type)Types.this.Type">normalizeAliases</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.existentialAbstraction.tpe0" title="Types.this.Type">tpe0</a><span class="delimiter">)</span>
      val tpe1     = new <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation" title="Types.this.ExistentialExtrapolation">ExistentialExtrapolation</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.existentialAbstraction.tparams" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span> <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;ExistentialExtrapolation.extrapolate" title="Types.this.Type" id="scala.reflect.internal;Types.existentialAbstraction.tpe1">extrapolate</a> <a href="#scala.reflect.internal;Types.existentialAbstraction.tpe" title="Types.this.Type">tpe</a>
      var <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.existentialAbstraction.tparams0">tparams0</a> = <a href="#scala.reflect.internal;Types.existentialAbstraction.tparams" title="List[Types.this.Symbol]">tparams</a>
      var tparams1 = <a href="#scala.reflect.internal;Types.existentialAbstraction.tparams0" title="List[Types.this.Symbol]">tparams0</a> <a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filter" title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.existentialAbstraction.tparams1">filter</a> <a href="#scala.reflect.internal;Types.existentialAbstraction.tpe1" title="Types.this.Type">tpe1</a>.<a href="#scala.reflect.internal;Types;Type.contains" title="(sym: Types.this.Symbol)Boolean">contains</a>

      while <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.existentialAbstraction.tparams1" title="List[Types.this.Symbol]">tparams1</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.reflect.internal;Types.existentialAbstraction.tparams0" title="List[Types.this.Symbol]">tparams0</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.existentialAbstraction.while$6" title="()Unit" class="delimiter">{</a>
        <a href="#scala.reflect.internal;Types.existentialAbstraction.tparams0" title="List[Types.this.Symbol]">tparams0</a> = <a href="#scala.reflect.internal;Types.existentialAbstraction.tparams1" title="List[Types.this.Symbol]">tparams1</a>
        <a href="#scala.reflect.internal;Types.existentialAbstraction.tparams1" title="List[Types.this.Symbol]">tparams1</a> = <a href="#scala.reflect.internal;Types.existentialAbstraction.tparams" title="List[Types.this.Symbol]">tparams</a> <a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filter" title="(p: Types.this.Symbol =&gt; Boolean)List[Types.this.Symbol]">filter</a> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="scala.reflect.internal;Types.existentialAbstraction.$anonfun.p">p</a> =&gt;
          <a href="#scala.reflect.internal;Types.existentialAbstraction.tparams1" title="List[Types.this.Symbol]">tparams1</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a> <span class="delimiter">{</span> <a title="Types.this.Symbol" id="scala.reflect.internal;Types.existentialAbstraction.$anonfun.$anonfun.p1">p1</a> =&gt; <a href="#scala.reflect.internal;Types.existentialAbstraction.$anonfun.$anonfun.p1" title="Types.this.Symbol">p1</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types.existentialAbstraction.$anonfun.p" title="Types.this.Symbol">p</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.existentialAbstraction.$anonfun.$anonfun.p1" title="Types.this.Symbol">p1</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a> <a href="#scala.reflect.internal;Types;Type.contains" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal;Types.existentialAbstraction.$anonfun.p" title="Types.this.Symbol">p</a><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
      <a href="#scala.reflect.internal;Types.newExistentialType" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.Type">newExistentialType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.existentialAbstraction.tparams1" title="List[Types.this.Symbol]">tparams1</a>, <a href="#scala.reflect.internal;Types.existentialAbstraction.tpe1" title="Types.this.Type">tpe1</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>



<span class="comment">// Hash consing --------------------------------------------------------------</span>

  private val <a title="Int" id="scala.reflect.internal;Types.initialUniquesCapacity">initialUniquesCapacity</a> = <span title="Int(4096)" class="int">4096</span>
  private var <a title="scala.reflect.internal.util.WeakHashSet[Types.this.Type]" id="scala.reflect.internal;Types.uniques_=">uniques</a>: util.<a href="util/WeakHashSet.scala.html#scala.reflect.internal.util;WeakHashSet" title="scala.reflect.internal.util.WeakHashSet[Types.this.Type]">WeakHashSet</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = _
  private var <a title="Int" id="scala.reflect.internal;Types.uniqueRunId_=">uniqueRunId</a> = <span title="Int(0)">NoRunId</span>

  protected def <a title="[T &lt;: Types.this.Type](tp: T)T" id="scala.reflect.internal;Types.unique">unique</a><span class="delimiter">[</span><a title=" &lt;: Types.this.Type" id="scala.reflect.internal;Types.unique;T">T</a> &lt;: Type<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="scala.reflect.internal;Types.unique.tp">tp</a>: <a href="#scala.reflect.internal;Types.unique;T" title="T">T</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types.unique;T" title="T">T</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.incCounter(456ea4fa07)" title="(c: scala.reflect.internal.util.Statistics.Counter)Unit">incCounter</a><span class="delimiter">(</span><a href="#scala.reflect.internal.TypesStats.rawTypeCount" title="=&gt; scala.reflect.internal.util.Statistics.Counter">rawTypeCount</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.uniqueRunId_=" title="=&gt; Int">uniqueRunId</a> <a href="../../Int.scala.html#scala;Int.!=(5f58a84eb3)" title="(x: Int)Boolean">!=</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentRunId" title="=&gt; Types.this.RunId">currentRunId</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#scala.reflect.internal;Types.uniques_=" title="(x$1: scala.reflect.internal.util.WeakHashSet[Types.this.Type])Unit">uniques</a> = util.<a href="util/WeakHashSet.scala.html#scala.reflect.internal.util.WeakHashSet.apply" title="[A &lt;: AnyRef](initialCapacity: Int, loadFactor: Double)scala.reflect.internal.util.WeakHashSet[A]">WeakHashSet</a><a href="util/WeakHashSet.scala.html#scala.reflect.internal.util.WeakHashSet.apply$default$2" title="(initialCapacity: Int, loadFactor: Double)scala.reflect.internal.util.WeakHashSet[Types.this.Type]" class="delimiter">[</a><a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.initialUniquesCapacity" title="=&gt; Int">initialUniquesCapacity</a><span class="delimiter">)</span>
      <span class="comment">// JZ: We used to register this as a perRunCache so it would be cleared eagerly at</span>
      <span class="comment">// the end of the compilation run. But, that facility didn't actually clear this map (SI-8129)!</span>
      <span class="comment">// When i fixed that bug, run/tpeCache-tyconCache.scala started failing. Why was that?</span>
      <span class="comment">// I've removed the registration for now. I don't think its particularly harmful anymore</span>
      <span class="comment">// as a) this is now a weak set, and b) it is discarded completely before the next run.</span>
      <a href="#scala.reflect.internal;Types.uniqueRunId_=" title="(x$1: Int)Unit">uniqueRunId</a> = <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.currentRunId" title="=&gt; Types.this.RunId">currentRunId</a>
    <span class="delimiter">}</span>
    <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.uniques_=" title="=&gt; scala.reflect.internal.util.WeakHashSet[Types.this.Type]">uniques</a> <a href="util/WeakHashSet.scala.html#scala.reflect.internal.util;WeakHashSet.findEntryOrUpdate" title="(elem: Types.this.Type)Types.this.Type">findEntryOrUpdate</a> <a href="#scala.reflect.internal;Types.unique.tp" title="T">tp</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#scala.reflect.internal;Types.unique;T" title="T">T</a><span class="delimiter">]</span>
  <span class="delimiter">}</span>

<span class="comment">// Helper Classes ---------------------------------------------------------</span>

  class <a title="class TypeUnwrapper extends AnyRef with Types.this.Type =&gt; Types.this.Type" id="scala.reflect.internal;Types;TypeUnwrapper">TypeUnwrapper</a><a href="#scala.reflect.internal;Types;TypeUnwrapper" title="Types.this.TypeUnwrapper" class="delimiter">(</a><a title="Boolean" id="scala.reflect.internal;Types;TypeUnwrapper.poly">poly</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>, <a title="Boolean" id="scala.reflect.internal;Types;TypeUnwrapper.existential">existential</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>, <a title="Boolean" id="scala.reflect.internal;Types;TypeUnwrapper.annotated">annotated</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>, <a title="Boolean" id="scala.reflect.internal;Types;TypeUnwrapper.nullary">nullary</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a><span class="delimiter">)</span> extends <span class="delimiter">(</span>Type =&gt; Type<span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;TypeUnwrapper.apply">apply</a><span class="delimiter">(</span><span title="Types.this.Type">tp</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span title="Types.this.Type">tp</span> match <span class="delimiter">{</span>
      case AnnotatedType<span class="delimiter">(</span>_, <span title="Types.this.Type">underlying</span><span class="delimiter">)</span> if <a href="#scala.reflect.internal;Types;TypeUnwrapper.annotated" title="Boolean">annotated</a>      =&gt; <a href="#scala.reflect.internal;Types;TypeUnwrapper.apply" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><span title="Types.this.Type">underlying</span><span class="delimiter">)</span>
      case ExistentialType<span class="delimiter">(</span>_, <span title="Types.this.Type">underlying</span><span class="delimiter">)</span> if <a href="#scala.reflect.internal;Types;TypeUnwrapper.existential" title="Boolean">existential</a>  =&gt; <a href="#scala.reflect.internal;Types;TypeUnwrapper.apply" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><span title="Types.this.Type">underlying</span><span class="delimiter">)</span>
      case PolyType<span class="delimiter">(</span>_, <span title="Types.this.Type">underlying</span><span class="delimiter">)</span> if <a href="#scala.reflect.internal;Types;TypeUnwrapper.poly" title="Boolean">poly</a>                =&gt; <a href="#scala.reflect.internal;Types;TypeUnwrapper.apply" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><span title="Types.this.Type">underlying</span><span class="delimiter">)</span>
      case NullaryMethodType<span class="delimiter">(</span><span title="Types.this.Type">underlying</span><span class="delimiter">)</span> if <a href="#scala.reflect.internal;Types;TypeUnwrapper.nullary" title="Boolean">nullary</a>       =&gt; <a href="#scala.reflect.internal;Types;TypeUnwrapper.apply" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><span title="Types.this.Type">underlying</span><span class="delimiter">)</span>
      case <span title="Types.this.Type">tp</span>                                             =&gt; <span title="Types.this.Type">tp</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  class <a title="class ClassUnwrapper extends Types.this.TypeUnwrapper" id="scala.reflect.internal;Types;ClassUnwrapper">ClassUnwrapper</a><a href="#scala.reflect.internal;Types;ClassUnwrapper" title="Types.this.ClassUnwrapper" class="delimiter">(</a><a title="Boolean" id="scala.reflect.internal;Types;ClassUnwrapper.existential">existential</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;TypeUnwrapper" title="Types.this.TypeUnwrapper">TypeUnwrapper</a><span class="delimiter">(</span>poly = true, <a href="#scala.reflect.internal;Types;ClassUnwrapper.existential" title="Boolean">existential</a>, annotated = true, nullary = false<span class="delimiter">)</span> <span class="delimiter">{</span>
    override def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types;ClassUnwrapper.apply">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;ClassUnwrapper.apply.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = super.<a href="#scala.reflect.internal;Types;TypeUnwrapper.apply" title="(tp: Types.this.Type)Types.this.Type">apply</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;ClassUnwrapper.apply.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a><span class="delimiter">)</span> <span class="comment">// normalize is required here</span>
  <span class="delimiter">}</span>

  object        <a title="Types.this.unwrapToClass.type" id="scala.reflect.internal;Types.unwrapToClass">unwrapToClass</a> extends <a href="#scala.reflect.internal;Types;ClassUnwrapper" title="Types.this.ClassUnwrapper">ClassUnwrapper</a><span class="delimiter">(</span>existential = true<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">}</span>
  object  <a title="Types.this.unwrapToStableClass.type" id="scala.reflect.internal;Types.unwrapToStableClass">unwrapToStableClass</a> extends <a href="#scala.reflect.internal;Types;ClassUnwrapper" title="Types.this.ClassUnwrapper">ClassUnwrapper</a><span class="delimiter">(</span>existential = false<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">}</span>
  object   <a title="Types.this.unwrapWrapperTypes.type" id="scala.reflect.internal;Types.unwrapWrapperTypes">unwrapWrapperTypes</a> extends  <a href="#scala.reflect.internal;Types;TypeUnwrapper" title="Types.this.TypeUnwrapper">TypeUnwrapper</a><span class="delimiter">(</span>true, true, true, true<span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">}</span>

  def <a title="(container: Types.this.Symbol, tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.elementExtract">elementExtract</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.elementExtract.container">container</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.elementExtract.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.elementExtract.container" title="Types.this.Symbol">container</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAliasType" title="=&gt; Boolean">isAliasType</a>, <a href="#scala.reflect.internal;Types.elementExtract.container" title="Types.this.Symbol">container</a><span class="delimiter">)</span>
    <a href="#scala.reflect.internal;Types;TypeUnwrapper.apply" title="(tp: Types.this.Type)Types.this.Type">unwrapWrapperTypes</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.elementExtract.tp" title="Types.this.Type">tp</a> <a href="#scala.reflect.internal;Types;Type.baseType" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a> <a href="#scala.reflect.internal;Types.elementExtract.container" title="Types.this.Symbol">container</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.dealiasWiden" title="=&gt; Types.this.Type">dealiasWiden</a> match <span class="delimiter">{</span>
      case TypeRef<span class="delimiter">(</span>_, <a href="#scala.reflect.internal;Types.elementExtract.container" title="Types.this.Symbol">`container`</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.elementExtract.arg">arg</a> :: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>  =&gt; <a href="#scala.reflect.internal;Types.elementExtract.arg" title="Types.this.Type">arg</a>
      case _                                    =&gt; <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  def <a title="(container: Types.this.Symbol, tp: Types.this.Type)Option[Types.this.Type]" id="scala.reflect.internal;Types.elementExtractOption">elementExtractOption</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.elementExtractOption.container">container</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <span title="Types.this.Type">tp</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Types.this.Type]">Option</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#scala.reflect.internal;Types.elementExtract" title="(container: Types.this.Symbol, tp: Types.this.Type)Types.this.Type">elementExtract</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.elementExtractOption.container" title="Types.this.Symbol">container</a>, <span title="Types.this.Type">tp</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a> =&gt; <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
      case <span title="Types.this.Type">tp</span> =&gt; <a href="../../Option.scala.html#scala;Some" title="(x: Types.this.Type)Some[Types.this.Type]">Some</a><span class="delimiter">(</span><span title="Types.this.Type">tp</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  def <a title="(container: Types.this.Symbol, tp: Types.this.Type)(f: Types.this.Type =&gt; Boolean)Boolean" id="scala.reflect.internal;Types.elementTest">elementTest</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.elementTest.container">container</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <span title="Types.this.Type">tp</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types.elementTest.f">f</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    <a href="#scala.reflect.internal;Types.elementExtract" title="(container: Types.this.Symbol, tp: Types.this.Type)Types.this.Type">elementExtract</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.elementTest.container" title="Types.this.Symbol">container</a>, <span title="Types.this.Type">tp</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a> =&gt; false
      case <span title="Types.this.Type">tp</span> =&gt; <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Types.this.Type)Boolean">f</a><span class="delimiter">(</span><span title="Types.this.Type">tp</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  def <a title="(container: Types.this.Symbol, tp: Types.this.Type)(f: Types.this.Type =&gt; Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.elementTransform">elementTransform</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.elementTransform.container">container</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <span title="Types.this.Type">tp</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; Types.this.Type" id="scala.reflect.internal;Types.elementTransform.f">f</a>: Type =&gt; Type<span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    <a href="#scala.reflect.internal;Types.elementExtract" title="(container: Types.this.Symbol, tp: Types.this.Type)Types.this.Type">elementExtract</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.elementTransform.container" title="Types.this.Symbol">container</a>, <span title="Types.this.Type">tp</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a> =&gt; <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
      case <span title="Types.this.Type">tp</span> =&gt; <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Types.this.Type)Types.this.Type">f</a><span class="delimiter">(</span><span title="Types.this.Type">tp</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(container: Types.this.Symbol, tp: Types.this.Type)(f: Types.this.Type =&gt; Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.transparentShallowTransform">transparentShallowTransform</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.transparentShallowTransform.container">container</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.transparentShallowTransform.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Types.this.Type =&gt; Types.this.Type" id="scala.reflect.internal;Types.transparentShallowTransform.f">f</a>: Type =&gt; Type<span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.transparentShallowTransform.loop">loop</a><span class="delimiter">(</span><span title="Types.this.Type">tp</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span title="Types.this.Type">tp</span> match <span class="delimiter">{</span>
      case <span title="Types.this.AnnotatedType">tp</span> @ AnnotatedType<span class="delimiter">(</span>_, <span title="Types.this.Type">underlying</span><span class="delimiter">)</span>        =&gt; <span title="Types.this.AnnotatedType">tp</span>.<a href="#scala.reflect.internal;Types;AnnotatedType.annotations" title="List[Types.this.AnnotationInfo] @scala.reflect.internal.annotations.uncheckedBounds" id="scala.reflect.internal;Types.transparentShallowTransform.loop.x$80">copy</a><span class="delimiter">(</span>underlying = <a href="#scala.reflect.internal;Types.transparentShallowTransform.loop" title="(tp: Types.this.Type)Types.this.Type">loop</a><a title="Types.this.Type" id="scala.reflect.internal;Types.transparentShallowTransform.loop.x$79" class="delimiter">(</a><span title="Types.this.Type">underlying</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case <span title="Types.this.ExistentialType">tp</span> @ ExistentialType<span class="delimiter">(</span>_, <span title="Types.this.Type">underlying</span><span class="delimiter">)</span>      =&gt; <span title="Types.this.ExistentialType">tp</span>.<a href="#scala.reflect.internal;Types;ExistentialType.quantified" title="List[Types.this.Symbol] @scala.reflect.internal.annotations.uncheckedBounds" id="scala.reflect.internal;Types.transparentShallowTransform.loop.x$82">copy</a><span class="delimiter">(</span>underlying = <a href="#scala.reflect.internal;Types.transparentShallowTransform.loop" title="(tp: Types.this.Type)Types.this.Type">loop</a><a title="Types.this.Type" id="scala.reflect.internal;Types.transparentShallowTransform.loop.x$81" class="delimiter">(</a><span title="Types.this.Type">underlying</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case <span title="Types.this.PolyType">tp</span> @ PolyType<span class="delimiter">(</span>_, <span title="Types.this.Type">resultType</span><span class="delimiter">)</span>             =&gt; <span title="Types.this.PolyType">tp</span>.<a href="#scala.reflect.internal;Types;PolyType.typeParams" title="List[Types.this.Symbol] @scala.reflect.internal.annotations.uncheckedBounds" id="scala.reflect.internal;Types.transparentShallowTransform.loop.x$84">copy</a><span class="delimiter">(</span>resultType = <a href="#scala.reflect.internal;Types.transparentShallowTransform.loop" title="(tp: Types.this.Type)Types.this.Type">loop</a><a title="Types.this.Type" id="scala.reflect.internal;Types.transparentShallowTransform.loop.x$83" class="delimiter">(</a><span title="Types.this.Type">resultType</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case <span title="Types.this.NullaryMethodType">tp</span> @ NullaryMethodType<span class="delimiter">(</span><span title="Types.this.Type">resultType</span><span class="delimiter">)</span>       =&gt; <span title="Types.this.NullaryMethodType">tp</span>.<a href="#scala.reflect.internal;Types;NullaryMethodType" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">copy</a><span class="delimiter">(</span>resultType = <a href="#scala.reflect.internal;Types.transparentShallowTransform.loop" title="(tp: Types.this.Type)Types.this.Type">loop</a><span class="delimiter">(</span><span title="Types.this.Type">resultType</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case <span title="Types.this.Type">tp</span>                                       =&gt; <a href="#scala.reflect.internal;Types.elementTransform" title="(container: Types.this.Symbol, tp: Types.this.Type)(f: Types.this.Type =&gt; Types.this.Type)Types.this.Type">elementTransform</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.transparentShallowTransform.container" title="Types.this.Symbol">container</a>, <span title="Types.this.Type">tp</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.transparentShallowTransform.loop.$anonfun.el">el</a> =&gt; <a href="#scala.reflect.internal;Types.appliedType(e35fed9e9d)" title="(tyconSym: Types.this.Symbol, args: Types.this.Type*)Types.this.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.transparentShallowTransform.container" title="Types.this.Symbol">container</a>, <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Types.this.Type)Types.this.Type">f</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.transparentShallowTransform.loop.$anonfun.el" title="Types.this.Type">el</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.orElse" title="(alt: =&gt; Types.this.Type)Types.this.Type">orElse</a><span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Types.this.Type)Types.this.Type">f</a><span class="delimiter">(</span><span title="Types.this.Type">tp</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#scala.reflect.internal;Types.transparentShallowTransform.loop" title="(tp: Types.this.Type)Types.this.Type">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.transparentShallowTransform.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Repack existential types, otherwise they sometimes get unpacked in the
   *  wrong location (type inference comes up with an unexpected skolem)
   */</span>
  def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.repackExistential">repackExistential</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.repackExistential.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">(</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.repackExistential.tp" title="Types.this.Type">tp</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.repackExistential.tp" title="Types.this.Type">tp</a>
    else <a href="#scala.reflect.internal;Types.existentialAbstraction" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.existentialsInType" title="(tpe: Types.this.Type)List[Types.this.Symbol]">existentialsInType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.repackExistential.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types.repackExistential.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>
  <span class="delimiter">)</span>

  def <a title="(tpe: Types.this.Type)Boolean" id="scala.reflect.internal;Types.containsExistential">containsExistential</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.containsExistential.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.containsExistential.tpe" title="Types.this.Type">tpe</a> <a href="#scala.reflect.internal;Types;Type.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types.typeIsExistentiallyBound" title="=&gt; Types.this.Type =&gt; Boolean">typeIsExistentiallyBound</a>
  def <a title="(tpe: Types.this.Type)List[Types.this.Symbol]" id="scala.reflect.internal;Types.existentialsInType">existentialsInType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.existentialsInType.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.existentialsInType.tpe" title="Types.this.Type">tpe</a> <a href="#scala.reflect.internal;Types;Type.withFilter" title="(p: Types.this.Type =&gt; Boolean)tpe.FilterMapForeach">withFilter</a> <a href="#scala.reflect.internal;Types.typeIsExistentiallyBound" title="=&gt; Types.this.Type =&gt; Boolean">typeIsExistentiallyBound</a> <a href="#scala.reflect.internal;Types;Type;FilterMapForeach.map" title="(f: Types.this.Type =&gt; Types.this.Symbol)List[Types.this.Symbol]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.existentialsInType.$anonfun.x$51" title="Types.this.Type">_</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>

  private def <a title="(tpe: Types.this.Type)(targ: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isDummyOf">isDummyOf</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isDummyOf.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isDummyOf.targ">targ</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="Types.this.Symbol" id="scala.reflect.internal;Types.isDummyOf.sym">sym</a> = <a href="#scala.reflect.internal;Types.isDummyOf.targ" title="Types.this.Type">targ</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>
    <a href="#scala.reflect.internal;Types.isDummyOf.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isTypeParameter" title="=&gt; Boolean">isTypeParameter</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.isDummyOf.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types.isDummyOf.tpe" title="Types.this.Type">tpe</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>
  <span class="delimiter">}</span>
  def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isDummyAppliedType">isDummyAppliedType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isDummyAppliedType.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.isDummyAppliedType.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.dealias" title="=&gt; Types.this.Type">dealias</a> match <span class="delimiter">{</span>
    case <a title="Types.this.TypeRef" id="scala.reflect.internal;Types.isDummyAppliedType.tr">tr</a> @ TypeRef<span class="delimiter">(</span>_, _, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.isDummyAppliedType.args">args</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.isDummyAppliedType.args" title="List[Types.this.Type]">args</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types.isDummyOf" title="(tpe: Types.this.Type)(targ: Types.this.Type)Boolean">isDummyOf</a><a href="#scala.reflect.internal;Types.isDummyAppliedType.$anonfun.targ" title="Types.this.Type" class="delimiter">(</a><a href="#scala.reflect.internal;Types.isDummyAppliedType.tr" title="Types.this.TypeRef">tr</a><span class="delimiter">)</span>
    case _                        =&gt; false
  <span class="delimiter">}</span>

  def <a title="(clazz: Types.this.Symbol, tparams: List[Types.this.Symbol])List[Types.this.Symbol]" id="scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a)">typeParamsToExistentials</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a).clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a).tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="List[Types.this.TypeSymbol]" id="scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a).eparams">eparams</a> = <a href="util/Collections.scala.html#scala.reflect.internal.util;Collections.mapWithIndex" title="(xs: List[Types.this.Symbol])(f: (Types.this.Symbol, Int) =&gt; Types.this.TypeSymbol)List[Types.this.TypeSymbol]">mapWithIndex</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a).tparams" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a).eparams.$anonfun.tparam">tparam</a>, <a title="Int" id="scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a).eparams.$anonfun.i">i</a><span class="delimiter">)</span> =&gt;
      <a href="#scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a).clazz" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.newExistential" title="(name: Types.this.TypeName, pos: Types.this.Position, newFlags: Long)Types.this.TypeSymbol">newExistential</a><span class="delimiter">(</span><a href="Names.scala.html#scala.reflect.internal;Names.newTypeName(0c257fd14d)" title="(s: String)Types.this.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span><span title="(x$1: Any)String">+</span><a href="#scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a).eparams.$anonfun.i" title="Int">i</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a).clazz" title="Types.this.Symbol">clazz</a>.<a href="StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.pos" title="=&gt; Types.this.Position">pos</a><span class="delimiter">)</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="(info: Types.this.Type)Types.this.TypeSymbol">setInfo</a> <a href="#scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a).eparams.$anonfun.tparam" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.bounds" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>

    <a href="#scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a).eparams" title="List[Types.this.TypeSymbol]">eparams</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.TypeSymbol =&gt; Types.this.TypeSymbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.TypeSymbol],Types.this.TypeSymbol,List[Types.this.Symbol]])List[Types.this.Symbol]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a).$anonfun.x$52" title="Types.this.TypeSymbol">_</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.substInfo" title="(syms0: List[Types.this.Symbol], syms1: List[Types.this.Symbol])x$52.type">substInfo</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a).tparams" title="List[Types.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a).eparams" title="List[Types.this.TypeSymbol]">eparams</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  def <a title="(clazz: Types.this.Symbol)List[Types.this.Symbol]" id="scala.reflect.internal;Types.typeParamsToExistentials(b9dabede8a)">typeParamsToExistentials</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.typeParamsToExistentials(b9dabede8a).clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> =
    <a href="#scala.reflect.internal;Types.typeParamsToExistentials(460d899c6a)" title="(clazz: Types.this.Symbol, tparams: List[Types.this.Symbol])List[Types.this.Symbol]">typeParamsToExistentials</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeParamsToExistentials(b9dabede8a).clazz" title="Types.this.Symbol">clazz</a>, <a href="#scala.reflect.internal;Types.typeParamsToExistentials(b9dabede8a).clazz" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span>

  def <a title="(sym: Types.this.Symbol)Boolean" id="scala.reflect.internal;Types.isRawIfWithoutArgs">isRawIfWithoutArgs</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.isRawIfWithoutArgs.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.isRawIfWithoutArgs.sym" title="Types.this.Symbol">sym</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isClass" title="=&gt; Boolean">isClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.isRawIfWithoutArgs.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.nonEmpty" title="=&gt; Boolean">nonEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.isRawIfWithoutArgs.sym" title="Types.this.Symbol">sym</a>.<a href="HasFlags.scala.html#scala.reflect.internal;HasFlags.isJavaDefined" title="=&gt; Boolean">isJavaDefined</a>
  <span class="comment">/** Is type tp a ''raw type''? */</span>
  <span class="comment">//  note: it's important to write the two tests in this order,</span>
  <span class="comment">//  as only typeParams forces the classfile to be read. See #400</span>
  def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isRawType">isRawType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isRawType.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isRawType.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.isRawType.sym">sym</a>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.isRawIfWithoutArgs" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isRawType.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    case _                    =&gt; false
  <span class="delimiter">}</span><span class="delimiter">)</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use isRawType&quot;</span>, <span class="string">&quot;2.10.1&quot;</span><span class="delimiter">)</span> <span class="comment">// presently used by sbt</span>
  def <a title="(sym: Types.this.Symbol, args: List[Types.this.Type])Boolean" id="scala.reflect.internal;Types.isRaw">isRaw</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.isRaw.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.isRaw.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">(</span>
       <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a>
    <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.isRaw.args" title="List[Types.this.Type]">args</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a>
    <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.isRawIfWithoutArgs" title="(sym: Types.this.Symbol)Boolean">isRawIfWithoutArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isRaw.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
  <span class="delimiter">)</span>

  def <a title="(hi: Types.this.Type)Types.this.TypeBounds" id="scala.reflect.internal;Types.singletonBounds">singletonBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.singletonBounds.hi">hi</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.TypeBounds.readResolve" title="Types.this.TypeBounds.type">TypeBounds</a>.<a href="#scala.reflect.internal;Types.TypeBounds.upper" title="(hi: Types.this.Type)Types.this.TypeBounds">upper</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.intersectionType(8490c4bc7b)" title="(tps: List[Types.this.Type])Types.this.Type">intersectionType</a><span class="delimiter">(</span><a href="../../collection/immutable/List.scala.html#scala.collection.immutable.List.apply" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.singletonBounds.hi" title="Types.this.Type">hi</a>, <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.SingletonClass" title="=&gt; Types.this.ClassSymbol">SingletonClass</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * A more persistent version of `Type#memberType` which does not require
   * that the symbol is a direct member of the prefix.
   *
   * For instance:
   *
   * {{{
   * class C[T] {
   *   sealed trait F[A]
   *   object X {
   *     object S1 extends F[T]
   *   }
   *   class S2 extends F[T]
   * }
   * object O extends C[Int] {
   *   def foo(f: F[Int]) = f match {...} // need to enumerate sealed subtypes of the scrutinee here.
   * }
   * class S3 extends O.F[String]
   *
   * nestedMemberType(&lt;S1&gt;, &lt;O.type&gt;, &lt;C&gt;) = O.X.S1.type
   * nestedMemberType(&lt;S2&gt;, &lt;O.type&gt;, &lt;C&gt;) = O.S2.type
   * nestedMemberType(&lt;S3&gt;, &lt;O.type&gt;, &lt;C&gt;) = S3.type
   * }}}
   *
   * @param sym    The symbol of the subtype
   * @param pre    The prefix from which the symbol is seen
   * @param owner
   */</span>
  def <a title="(sym: Types.this.Symbol, pre: Types.this.Type, owner: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types.nestedMemberType">nestedMemberType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.nestedMemberType.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.nestedMemberType.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.nestedMemberType.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.nestedMemberType.loop">loop</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.nestedMemberType.loop.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.nestedMemberType.loop.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.isTrivial" title="=&gt; Boolean">isTrivial</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.nestedMemberType.loop.tp" title="Types.this.Type">tp</a>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.nestedMemberType.loop.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.prefix" title="=&gt; Types.this.Type">prefix</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isNonBottomSubClass" title="(that: Types.this.Symbol)Boolean">isNonBottomSubClass</a> <a href="#scala.reflect.internal;Types.nestedMemberType.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="Types.this.Type" id="scala.reflect.internal;Types.nestedMemberType.loop.widened">widened</a> = <a href="#scala.reflect.internal;Types.nestedMemberType.loop.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
          case _: <a href="#scala.reflect.internal;Types;ConstantType" title="Types.this.ConstantType">ConstantType</a> =&gt; <a href="#scala.reflect.internal;Types.nestedMemberType.loop.tp" title="Types.this.Type">tp</a> <span class="comment">// Java enum constants: don't widen to the enum type!</span>
          case _               =&gt; <a href="#scala.reflect.internal;Types.nestedMemberType.loop.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a> <span class="comment">// C.X.type widens to C.this.X.type, otherwise `tp asSeenFrom (pre, C)` has no effect.</span>
        <span class="delimiter">}</span>
        val memType = <a href="#scala.reflect.internal;Types.nestedMemberType.loop.widened" title="Types.this.Type">widened</a> <a href="#scala.reflect.internal;Types;Type.asSeenFrom" title="Types.this.Type" id="scala.reflect.internal;Types.nestedMemberType.loop.memType">asSeenFrom</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.nestedMemberType.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.nestedMemberType.loop.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.nestedMemberType.loop.tp" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types.nestedMemberType.loop.widened" title="Types.this.Type">widened</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.nestedMemberType.loop.memType" title="Types.this.Type">memType</a> else <a href="#scala.reflect.internal;Types.nestedMemberType.loop.memType" title="Types.this.Type">memType</a>.<a href="#scala.reflect.internal;Types;Type.narrow" title="=&gt; Types.this.Type">narrow</a>
      <span class="delimiter">}</span>
      else <a href="#scala.reflect.internal;Types.nestedMemberType.loop" title="(tp: Types.this.Type)Types.this.Type">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.nestedMemberType.loop.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.prefix" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types;Type.memberType" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a> <a href="#scala.reflect.internal;Types.nestedMemberType.loop.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>

    val <a title="Types.this.Type" id="scala.reflect.internal;Types.nestedMemberType.result">result</a> = <a href="#scala.reflect.internal;Types.nestedMemberType.loop" title="(tp: Types.this.Type)Types.this.Type">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.nestedMemberType.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpeHK" title="=&gt; Types.this.Type">tpeHK</a><span class="delimiter">)</span>
    <a href="../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.nestedMemberType.sym" title="Types.this.Symbol">sym</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isTerm" title="=&gt; Boolean">isTerm</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.nestedMemberType.result" title="Types.this.Type">result</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types.nestedMemberType.sym" title="Types.this.Symbol">sym</a>, <a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;(&quot;)">($</span><a href="#scala.reflect.internal;Types.nestedMemberType.result" title="Types.this.Type">result</a><span title="String(&quot;).typeSymbol = &quot;)">).typeSymbol = $</span><span class="delimiter">{</span><a href="#scala.reflect.internal;Types.nestedMemberType.result" title="Types.this.Type">result</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">}</span><span title="String(&quot;; expected &quot;)">; expected $</span><span class="delimiter">{</span><a href="#scala.reflect.internal;Types.nestedMemberType.sym" title="Types.this.Symbol">sym</a><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
    <a href="#scala.reflect.internal;Types.nestedMemberType.result" title="Types.this.Type">result</a>
  <span class="delimiter">}</span>

  class <a title="class MissingAliasControl extends Throwable with scala.util.control.ControlThrowable" id="scala.reflect.internal;Types;MissingAliasControl">MissingAliasControl</a> extends <a href="../../util/control/ControlThrowable.scala.html#scala.util.control;ControlThrowable" title="scala.util.control.ControlThrowable">ControlThrowable</a>
  val <a title="Types.this.MissingAliasControl" id="scala.reflect.internal;Types.missingAliasException">missingAliasException</a> = new <a href="#scala.reflect.internal;Types;MissingAliasControl" title="Types.this.MissingAliasControl">MissingAliasControl</a>
  class <a title="class MissingTypeControl extends Throwable with scala.util.control.ControlThrowable" id="scala.reflect.internal;Types;MissingTypeControl">MissingTypeControl</a> extends <a href="../../util/control/ControlThrowable.scala.html#scala.util.control;ControlThrowable" title="scala.util.control.ControlThrowable">ControlThrowable</a>

<span class="comment">// Helper Methods  -------------------------------------------------------------</span>

  <span class="comment">/** The maximum allowable depth of lubs or glbs over types `ts`.
    */</span>
  def <a title="(ts: List[Types.this.Type])scala.reflect.internal.Depth" id="scala.reflect.internal;Types.lubDepth">lubDepth</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.lubDepth.ts">ts</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <span class="delimiter">{</span>
    val <a title="scala.reflect.internal.Depth" id="scala.reflect.internal;Types.lubDepth.td">td</a> = <a href="#scala.reflect.internal;Types.typeDepth(79231ea494)" title="(tps: List[Types.this.Type])scala.reflect.internal.Depth">typeDepth</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.lubDepth.ts" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
    val <a title="scala.reflect.internal.Depth" id="scala.reflect.internal;Types.lubDepth.bd">bd</a> = <a href="#scala.reflect.internal;Types.baseTypeSeqDepth" title="(tps: List[Types.this.Type])scala.reflect.internal.Depth">baseTypeSeqDepth</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.lubDepth.ts" title="List[Types.this.Type]">ts</a><span class="delimiter">)</span>
    <a href="#scala.reflect.internal;Types.lubDepthAdjust" title="(td: scala.reflect.internal.Depth, bd: scala.reflect.internal.Depth)scala.reflect.internal.Depth">lubDepthAdjust</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.lubDepth.td" title="scala.reflect.internal.Depth">td</a>, <a href="#scala.reflect.internal;Types.lubDepth.td" title="scala.reflect.internal.Depth">td</a> <a href="Depth.scala.html#scala.reflect.internal;Depth.max" title="(that: scala.reflect.internal.Depth)scala.reflect.internal.Depth">max</a> <a href="#scala.reflect.internal;Types.lubDepth.bd" title="scala.reflect.internal.Depth">bd</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The maximum allowable depth of lubs or glbs over given types,
   *  as a function over the maximum depth `td` of these types, and
   *  the maximum depth `bd` of all types in the base type sequences of these types.
   */</span>
  private def <a title="(td: scala.reflect.internal.Depth, bd: scala.reflect.internal.Depth)scala.reflect.internal.Depth" id="scala.reflect.internal;Types.lubDepthAdjust">lubDepthAdjust</a><span class="delimiter">(</span><a title="scala.reflect.internal.Depth" id="scala.reflect.internal;Types.lubDepthAdjust.td">td</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a>, <a title="scala.reflect.internal.Depth" id="scala.reflect.internal;Types.lubDepthAdjust.bd">bd</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a><span class="delimiter">)</span>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <span class="delimiter">(</span>
    if <span class="delimiter">(</span><a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">XfullLubs</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.lubDepthAdjust.bd" title="scala.reflect.internal.Depth">bd</a>
    else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.lubDepthAdjust.bd" title="scala.reflect.internal.Depth">bd</a> <a href="../../math/Ordered.scala.html#scala.math;Ordered.<=" title="(that: scala.reflect.internal.Depth)Boolean">&lt;=</a> <a href="Depth.scala.html#scala.reflect.internal.Depth.apply" title="(depth: Int)scala.reflect.internal.Depth">Depth</a><span class="delimiter">(</span><span title="Int(3)" class="int">3</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.lubDepthAdjust.bd" title="scala.reflect.internal.Depth">bd</a>
    else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.lubDepthAdjust.bd" title="scala.reflect.internal.Depth">bd</a> <a href="../../math/Ordered.scala.html#scala.math;Ordered.<=" title="(that: scala.reflect.internal.Depth)Boolean">&lt;=</a> <a href="Depth.scala.html#scala.reflect.internal.Depth.apply" title="(depth: Int)scala.reflect.internal.Depth">Depth</a><span class="delimiter">(</span><span title="Int(5)" class="int">5</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.lubDepthAdjust.td" title="scala.reflect.internal.Depth">td</a> <a href="Depth.scala.html#scala.reflect.internal;Depth.max" title="(that: scala.reflect.internal.Depth)scala.reflect.internal.Depth">max</a> <a href="#scala.reflect.internal;Types.lubDepthAdjust.bd" title="scala.reflect.internal.Depth">bd</a>.<a href="Depth.scala.html#scala.reflect.internal;Depth.decr(a73a950bc7)" title="=&gt; scala.reflect.internal.Depth">decr</a>
    else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.lubDepthAdjust.bd" title="scala.reflect.internal.Depth">bd</a> <a href="../../math/Ordered.scala.html#scala.math;Ordered.<=" title="(that: scala.reflect.internal.Depth)Boolean">&lt;=</a> <a href="Depth.scala.html#scala.reflect.internal.Depth.apply" title="(depth: Int)scala.reflect.internal.Depth">Depth</a><span class="delimiter">(</span><span title="Int(7)" class="int">7</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.lubDepthAdjust.td" title="scala.reflect.internal.Depth">td</a> <a href="Depth.scala.html#scala.reflect.internal;Depth.max" title="(that: scala.reflect.internal.Depth)scala.reflect.internal.Depth">max</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.lubDepthAdjust.bd" title="scala.reflect.internal.Depth">bd</a> <a href="Depth.scala.html#scala.reflect.internal;Depth.decr(82603ba5b2)" title="(n: Int)scala.reflect.internal.Depth">decr</a> <span title="Int(2)" class="int">2</span><span class="delimiter">)</span>
    else <a href="#scala.reflect.internal;Types.lubDepthAdjust.td" title="scala.reflect.internal.Depth">td</a>.<a href="Depth.scala.html#scala.reflect.internal;Depth.decr(a73a950bc7)" title="=&gt; scala.reflect.internal.Depth">decr</a> <a href="Depth.scala.html#scala.reflect.internal;Depth.max" title="(that: scala.reflect.internal.Depth)scala.reflect.internal.Depth">max</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.lubDepthAdjust.bd" title="scala.reflect.internal.Depth">bd</a> <a href="Depth.scala.html#scala.reflect.internal;Depth.decr(82603ba5b2)" title="(n: Int)scala.reflect.internal.Depth">decr</a> <span title="Int(3)" class="int">3</span><span class="delimiter">)</span>
  <span class="delimiter">)</span>

  private def <a title="(syms: List[Types.this.Symbol])scala.reflect.internal.Depth" id="scala.reflect.internal;Types.symTypeDepth">symTypeDepth</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.symTypeDepth.syms">syms</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a>  = <a href="#scala.reflect.internal;Types.typeDepth(79231ea494)" title="(tps: List[Types.this.Type])scala.reflect.internal.Depth">typeDepth</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.symTypeDepth.syms" title="List[Types.this.Symbol]">syms</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Types.this.Symbol =&gt; Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[Types.this.Symbol],Types.this.Type,List[Types.this.Type]])List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.symTypeDepth.$anonfun.x$53" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a><span class="delimiter">)</span><span class="delimiter">)</span>
  private def <a title="(tps: List[Types.this.Type])scala.reflect.internal.Depth" id="scala.reflect.internal;Types.typeDepth(79231ea494)">typeDepth</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.typeDepth(79231ea494).tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a>        = <a href="#scala.reflect.internal;Types.maxDepth" title="(tps: List[Types.this.Type])scala.reflect.internal.Depth">maxDepth</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeDepth(79231ea494).tps" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>
  private def <a title="(tps: List[Types.this.Type])scala.reflect.internal.Depth" id="scala.reflect.internal;Types.baseTypeSeqDepth">baseTypeSeqDepth</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.baseTypeSeqDepth.tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <a href="#scala.reflect.internal;Types.maxbaseTypeSeqDepth" title="(tps: List[Types.this.Type])scala.reflect.internal.Depth">maxbaseTypeSeqDepth</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.baseTypeSeqDepth.tps" title="List[Types.this.Type]">tps</a><span class="delimiter">)</span>

  <span class="comment">/** Is intersection of given types populated? That is,
   *  for all types tp1, tp2 in intersection
   *    for all common base classes bc of tp1 and tp2
   *      let bt1, bt2 be the base types of tp1, tp2 relative to class bc
   *      Then:
   *        bt1 and bt2 have the same prefix, and
   *        any corresponding non-variant type arguments of bt1 and bt2 are the same
   */</span>
  def <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isPopulated">isPopulated</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isPopulated.tp1">tp1</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.isPopulated.tp2">tp2</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    def <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isPopulated.isConsistent">isConsistent</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isPopulated.isConsistent.tp1">tp1</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.isPopulated.isConsistent.tp2">tp2</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: Types.this.Type, _2: Types.this.Type)(Types.this.Type, Types.this.Type)" class="delimiter">(</a><a href="#scala.reflect.internal;Types.isPopulated.isConsistent.tp1" title="Types.this.Type">tp1</a>, <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.tp2" title="Types.this.Type">tp2</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case <span class="delimiter">(</span>TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isPopulated.isConsistent.pre1">pre1</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.isPopulated.isConsistent.sym1">sym1</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.isPopulated.isConsistent.args1">args1</a><span class="delimiter">)</span>, TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isPopulated.isConsistent.pre2">pre2</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.isPopulated.isConsistent.sym2">sym2</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.isPopulated.isConsistent.args2">args2</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="../../Predef.scala.html#scala.Predef.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.isConsistent.sym1" title="Types.this.Symbol">sym1</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.sym2" title="Types.this.Symbol">sym2</a>, <a href="../../Tuple2.scala.html#scala;Tuple2" title="(_1: Types.this.Symbol, _2: Types.this.Symbol)(Types.this.Symbol, Types.this.Symbol)" class="delimiter">(</a><a href="#scala.reflect.internal;Types.isPopulated.isConsistent.sym1" title="Types.this.Symbol">sym1</a>, <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.sym2" title="Types.this.Symbol">sym2</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">(</span>    <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.pre1" title="Types.this.Type">pre1</a> <a href="#scala.reflect.internal;Types;Type.=:=" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.pre2" title="Types.this.Type">pre2</a>
          <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="util/Collections.scala.html#scala.reflect.internal.util;Collections.forall3" title="(xs1: List[Types.this.Type], xs2: List[Types.this.Type], xs3: List[Types.this.Symbol])(f: (Types.this.Type, Types.this.Type, Types.this.Symbol) =&gt; Boolean)Boolean">forall3</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.isConsistent.args1" title="List[Types.this.Type]">args1</a>, <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.args2" title="List[Types.this.Type]">args2</a>, <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.sym1" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isPopulated.isConsistent.$anonfun.arg1">arg1</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.isPopulated.isConsistent.$anonfun.arg2">arg2</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.isPopulated.isConsistent.$anonfun.tparam">tparam</a><span class="delimiter">)</span> =&gt;
               <span class="comment">// if left-hand argument is a typevar, make it compatible with variance</span>
               <span class="comment">// this is for more precise pattern matching</span>
               <span class="comment">// todo: work this in the spec of this method</span>
               <span class="comment">// also: think what happens if there are embedded typevars?</span>
               if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.isConsistent.$anonfun.tparam" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.variance" title="=&gt; scala.reflect.internal.Variance">variance</a>.<a href="Variance.scala.html#scala.reflect.internal;Variance.isInvariant" title="=&gt; Boolean">isInvariant</a><span class="delimiter">)</span>
                 <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.$anonfun.arg1" title="Types.this.Type">arg1</a> <a href="#scala.reflect.internal;Types;Type.=:=" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.$anonfun.arg2" title="Types.this.Type">arg2</a>
               else <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.isPopulated.isConsistent.$anonfun.arg1" title="Types.this.Type">arg1</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">{</span>
                 if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.isConsistent.$anonfun.tparam" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.variance" title="=&gt; scala.reflect.internal.Variance">variance</a>.<a href="Variance.scala.html#scala.reflect.internal;Variance.isContravariant" title="=&gt; Boolean">isContravariant</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.$anonfun.arg1" title="Types.this.Type">arg1</a> <a href="#scala.reflect.internal;Types;Type.<:<" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.$anonfun.arg2" title="Types.this.Type">arg2</a>
                 else <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.$anonfun.arg2" title="Types.this.Type">arg2</a> <a href="#scala.reflect.internal;Types;Type.<:<" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.$anonfun.arg1" title="Types.this.Type">arg1</a>
               <span class="delimiter">}</span>
             <span class="delimiter">}</span>
        <span class="delimiter">)</span>
      case <span class="delimiter">(</span><span title="Types.this.ExistentialType">et</span>: <a href="#scala.reflect.internal;Types;ExistentialType" title="Types.this.ExistentialType">ExistentialType</a>, _<span class="delimiter">)</span> =&gt;
        <span title="Types.this.ExistentialType">et</span>.<a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(b9930e495d)" title="(op: Types.this.Type =&gt; Boolean)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.isConsistent" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.isConsistent.$anonfun.x$54" title="Types.this.Type">_</a>, <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.tp2" title="Types.this.Type">tp2</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>_, <span title="Types.this.ExistentialType">et</span>: <a href="#scala.reflect.internal;Types;ExistentialType" title="Types.this.ExistentialType">ExistentialType</a><span class="delimiter">)</span> =&gt;
        <span title="Types.this.ExistentialType">et</span>.<a href="#scala.reflect.internal;Types;ExistentialType.withTypeVars(b9930e495d)" title="(op: Types.this.Type =&gt; Boolean)Boolean">withTypeVars</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.isConsistent" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.isConsistent.tp1" title="Types.this.Type">tp1</a>, <a href="#scala.reflect.internal;Types.isPopulated.isConsistent.$anonfun.x$55" title="Types.this.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    def <a title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isPopulated.check">check</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isPopulated.check.tp1">tp1</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.isPopulated.check.tp2">tp2</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.check.tp1" title="Types.this.Type">tp1</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isClass" title="=&gt; Boolean">isClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.isPopulated.check.tp1" title="Types.this.Type">tp1</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.hasFlag(26ea2e307b)" title="(mask: Int)Boolean">hasFlag</a><span class="delimiter">(</span><span title="Int(32)">FINAL</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#scala.reflect.internal;Types.isPopulated.check.tp1" title="Types.this.Type">tp1</a> <a href="#scala.reflect.internal;Types;Type.<:<" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#scala.reflect.internal;Types.isPopulated.check.tp2" title="Types.this.Type">tp2</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;ValueClassDefinitions.isNumericValueClass" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.check.tp1" title="Types.this.Type">tp1</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;ValueClassDefinitions.isNumericValueClass" title="(sym: Types.this.Symbol)Boolean">isNumericValueClass</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.check.tp2" title="Types.this.Type">tp2</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
      else <a href="#scala.reflect.internal;Types.isPopulated.check.tp1" title="Types.this.Type">tp1</a>.<a href="#scala.reflect.internal;Types;Type.baseClasses" title="=&gt; List[Types.this.Symbol]">baseClasses</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.isPopulated.check.$anonfun.bc">bc</a> =&gt;
        <a href="#scala.reflect.internal;Types.isPopulated.check.tp2" title="Types.this.Type">tp2</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeIndex" title="(sym: Types.this.Symbol)Int">baseTypeIndex</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.check.$anonfun.bc" title="Types.this.Symbol">bc</a><span class="delimiter">)</span> <a href="../../Int.scala.html#scala;Int.<(5f58a84eb3)" title="(x: Int)Boolean">&lt;</a> <span title="Int(0)" class="int">0</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.isPopulated.isConsistent" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isConsistent</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.check.tp1" title="Types.this.Type">tp1</a>.<a href="#scala.reflect.internal;Types;Type.baseType" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.check.$anonfun.bc" title="Types.this.Symbol">bc</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types.isPopulated.check.tp2" title="Types.this.Type">tp2</a>.<a href="#scala.reflect.internal;Types;Type.baseType" title="(clazz: Types.this.Symbol)Types.this.Type">baseType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.check.$anonfun.bc" title="Types.this.Symbol">bc</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>

    <a href="#scala.reflect.internal;Types.isPopulated.check" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">check</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.tp1" title="Types.this.Type">tp1</a>, <a href="#scala.reflect.internal;Types.isPopulated.tp2" title="Types.this.Type">tp2</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.isPopulated.check" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">check</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isPopulated.tp2" title="Types.this.Type">tp2</a>, <a href="#scala.reflect.internal;Types.isPopulated.tp1" title="Types.this.Type">tp1</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Does a pattern of type `patType` need an outer test when executed against
   *  selector type `selType` in context defined by `currentOwner`?
   */</span>
  def <a title="(patType: Types.this.Type, selType: Types.this.Type, currentOwner: Types.this.Symbol)Boolean" id="scala.reflect.internal;Types.needsOuterTest">needsOuterTest</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.needsOuterTest.patType">patType</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.needsOuterTest.selType">selType</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.needsOuterTest.currentOwner">currentOwner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    def <a title="(pre: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.needsOuterTest.createDummyClone">createDummyClone</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.needsOuterTest.createDummyClone.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
      val <a title="Types.this.TermSymbol" id="scala.reflect.internal;Types.needsOuterTest.createDummyClone.dummy">dummy</a> = <a href="#scala.reflect.internal;Types.needsOuterTest.currentOwner" title="Types.this.Symbol">currentOwner</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.enclClass" title="Types.this.Symbol" id="scala.reflect.internal;Types.needsOuterTest.createDummyClone.dummy.qual$2">enclClass</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.newValue$default$2" title="Types.this.Position" id="scala.reflect.internal;Types.needsOuterTest.createDummyClone.dummy.x$87">newValue</a><span class="delimiter">(</span><a href="StdNames.scala.html#scala.reflect.internal;StdNames.nme" title="Types.this.nme.type">nme</a>.<a href="StdNames.scala.html#scala.reflect.internal;StdNames;TermNames.ANYname" title="Types.this.nme.NameType" id="scala.reflect.internal;Types.needsOuterTest.createDummyClone.dummy.x$85">ANYname</a><span class="delimiter">)</span>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="(info: Types.this.Type)Types.this.TermSymbol">setInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.createDummyClone.pre" title="Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.widen" title="=&gt; Types.this.Type">widen</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types.singleType" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.ThisType.apply(a489b0ed7a)" title="(sym: Types.this.Symbol)Types.this.Type">ThisType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.currentOwner" title="Types.this.Symbol">currentOwner</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.enclClass" title="=&gt; Types.this.Symbol">enclClass</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types.needsOuterTest.createDummyClone.dummy" title="Types.this.TermSymbol">dummy</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    def <a title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type" id="scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone">maybeCreateDummyClone</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.pre" title="Types.this.Type">pre</a> match <span class="delimiter">{</span>
      case SingleType<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.pre1">pre1</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.sym1">sym1</a><span class="delimiter">)</span> =&gt;
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.sym1" title="Types.this.Symbol">sym1</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModule" title="=&gt; Boolean">isModule</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.sym1" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isStatic" title="=&gt; Boolean">isStatic</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
        <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.sym1" title="Types.this.Symbol">sym1</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModule" title="=&gt; Boolean">isModule</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.sym1" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.moduleClass" title="=&gt; Types.this.Symbol">moduleClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          val <a title="Types.this.Type" id="scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.pre2">pre2</a> = <a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.pre1" title="Types.this.Type">pre1</a>, <a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.sym1" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.pre2" title="Types.this.Type">pre2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.pre2" title="Types.this.Type">pre2</a>
          else <a href="#scala.reflect.internal;Types.singleType" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.pre2" title="Types.this.Type">pre2</a>, <a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.sym1" title="Types.this.Symbol">sym1</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> else <span class="delimiter">{</span>
          <a href="#scala.reflect.internal;Types.needsOuterTest.createDummyClone" title="(pre: Types.this.Type)Types.this.Type">createDummyClone</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.pre" title="Types.this.Type">pre</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      case ThisType<span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.clazz">clazz</a><span class="delimiter">)</span> =&gt;
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.clazz" title="Types.this.Symbol">clazz</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModuleClass" title="=&gt; Boolean">isModuleClass</a><span class="delimiter">)</span>
          <a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.clazz" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeOfThis" title="=&gt; Types.this.Type">typeOfThis</a>, <a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.clazz" title="Types.this.Symbol">clazz</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.hasFlag(26ea2e307b)" title="(mask: Int)Boolean">hasFlag</a><span class="delimiter">(</span><span title="Int(4)">PRIVATE</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.privateWithin" title="=&gt; Types.this.Symbol">privateWithin</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
        else
          <a href="#scala.reflect.internal;Types.needsOuterTest.createDummyClone" title="(pre: Types.this.Type)Types.this.Type">createDummyClone</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone.pre" title="Types.this.Type">pre</a><span class="delimiter">)</span>
      case _ =&gt;
        <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
    <span class="delimiter">}</span>
    <span class="comment">// See the test for SI-7214 for motivation for dealias. Later `treeCondStrategy#outerTest`</span>
    <span class="comment">// generates an outer test based on `patType.prefix` with automatically dealises.</span>
    <a href="#scala.reflect.internal;Types.needsOuterTest.patType" title="Types.this.Type">patType</a>.<a href="#scala.reflect.internal;Types;Type.dealias" title="=&gt; Types.this.Type">dealias</a> match <span class="delimiter">{</span>
      case TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.needsOuterTest.pre">pre</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.needsOuterTest.sym">sym</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.needsOuterTest.args">args</a><span class="delimiter">)</span> =&gt;
        val <a title="Types.this.Type" id="scala.reflect.internal;Types.needsOuterTest.pre1">pre1</a> = <a href="#scala.reflect.internal;Types.needsOuterTest.maybeCreateDummyClone" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">maybeCreateDummyClone</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.needsOuterTest.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.pre1" title="Types.this.Type">pre1</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.isPopulated" title="(tp1: Types.this.Type, tp2: Types.this.Type)Boolean">isPopulated</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.copyTypeRef" title="(tp: Types.this.Type, pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">copyTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.needsOuterTest.patType" title="Types.this.Type">patType</a>, <a href="#scala.reflect.internal;Types.needsOuterTest.pre1" title="Types.this.Type">pre1</a>, <a href="#scala.reflect.internal;Types.needsOuterTest.sym" title="Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types.needsOuterTest.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types.needsOuterTest.selType" title="Types.this.Type">selType</a><span class="delimiter">)</span>
      case _ =&gt;
        false
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.normalizePlus">normalizePlus</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.normalizePlus.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isRawType" title="(tp: Types.this.Type)Boolean">isRawType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.normalizePlus.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;TypeMap.apply" title="(tp: Types.this.Type)Types.this.Type">rawToExistential</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.normalizePlus.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>
    else <a href="#scala.reflect.internal;Types.normalizePlus.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a> match <span class="delimiter">{</span>
      <span class="comment">// Unify the two representations of module classes</span>
      case <a title="Types.this.SingleType" id="scala.reflect.internal;Types.normalizePlus.st">st</a> @ SingleType<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.normalizePlus.sym">sym</a><span class="delimiter">)</span> if <a href="#scala.reflect.internal;Types.normalizePlus.sym" title="Types.this.Symbol">sym</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModule" title="=&gt; Boolean">isModule</a> =&gt; <a href="#scala.reflect.internal;Types.normalizePlus.st" title="Types.this.SingleType">st</a>.<a href="#scala.reflect.internal;Types;SingleType.underlying" title="=&gt; Types.this.Type">underlying</a>.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a>
      case _                                       =&gt; <a href="#scala.reflect.internal;Types.normalizePlus.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a>
    <span class="delimiter">}</span>
  <span class="delimiter">)</span>

  <span class="comment">/*
  todo: change to:
  def normalizePlus(tp: Type) = tp match {
    case TypeRef(pre, sym, List()) =&gt;
      if (!sym.isInitialized) sym.rawInfo.load(sym)
      if (sym.isJavaDefined &amp;&amp; !sym.typeParams.isEmpty) rawToExistential(tp)
      else tp.normalize
    case _ =&gt; tp.normalize
  }
  */</span>


  <span class="comment">/** Are `tps1` and `tps2` lists of pairwise equivalent types? */</span>
  def <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type])Boolean" id="scala.reflect.internal;Types.isSameTypes">isSameTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.isSameTypes.tps1">tps1</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.isSameTypes.tps2">tps2</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isSameTypes.tps1" title="List[Types.this.Type]">tps1</a> <a href="../../collection/LinearSeqLike.scala.html#scala.collection;LinearSeqLike.corresponds" title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.Type, Types.this.Type) =&gt; Boolean)Boolean">corresponds</a> <a href="#scala.reflect.internal;Types.isSameTypes.tps2" title="List[Types.this.Type]">tps2</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isSameTypes.$anonfun.x$56" title="Types.this.Type">_</a> <a href="#scala.reflect.internal;Types;Type.=:=" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#scala.reflect.internal;Types.isSameTypes.$anonfun.x$57" title="Types.this.Type">_</a><span class="delimiter">)</span>

  <span class="comment">/** True if two lists have the same length.  Since calling length on linear sequences
   *  is O(n), it is an inadvisable way to test length equality.
   */</span>
  final def <a title="(xs1: List[_], xs2: List[_])Boolean" id="scala.reflect.internal;Types.sameLength">sameLength</a><span class="delimiter">(</span><a title="List[_]" id="scala.reflect.internal;Types.sameLength.xs1">xs1</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[_]">List</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="List[_]" id="scala.reflect.internal;Types.sameLength.xs2">xs2</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[_]">List</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.compareLengths" title="(xs1: List[_], xs2: List[_])Int">compareLengths</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.sameLength.xs1" title="List[_]">xs1</a>, <a href="#scala.reflect.internal;Types.sameLength.xs2" title="List[_]">xs2</a><span class="delimiter">)</span> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span>
  @tailrec final def <a title="(xs1: List[_], xs2: List[_])Int" id="scala.reflect.internal;Types.compareLengths">compareLengths</a><span class="delimiter">(</span><a title="List[_]" id="scala.reflect.internal;Types.compareLengths.xs1">xs1</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[_]">List</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="List[_]" id="scala.reflect.internal;Types.compareLengths.xs2">xs2</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[_]">List</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> =
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.compareLengths.xs1" title="List[_]">xs1</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span> if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.compareLengths.xs2" title="List[_]">xs2</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> else -<span title="Int(-1)" class="int">1</span> <span class="delimiter">}</span>
    else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.compareLengths.xs2" title="List[_]">xs2</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span title="Int(1)" class="int">1</span>
    else <a href="#scala.reflect.internal;Types.compareLengths" title="(xs1: List[_], xs2: List[_])Int">compareLengths</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.compareLengths.xs1" title="List[_]">xs1</a>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[_$3]">tail</a>, <a href="#scala.reflect.internal;Types.compareLengths.xs2" title="List[_]">xs2</a>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[_$4]">tail</a><span class="delimiter">)</span>

  <span class="comment">/** Again avoiding calling length, but the lengthCompare interface is clunky.
   */</span>
  final def <a title="(xs: List[_], len: Int)Boolean" id="scala.reflect.internal;Types.hasLength">hasLength</a><span class="delimiter">(</span><a title="List[_]" id="scala.reflect.internal;Types.hasLength.xs">xs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[_]">List</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="Int" id="scala.reflect.internal;Types.hasLength.len">len</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.hasLength.xs" title="List[_]">xs</a>.<a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.lengthCompare" title="(len: Int)Int">lengthCompare</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.hasLength.len" title="Int">len</a><span class="delimiter">)</span> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span>

  private var <a title="Int" id="scala.reflect.internal;Types._basetypeRecursions_=">_basetypeRecursions</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a> = <span title="Int(0)" class="int">0</span>
  def <a title="=&gt; Int" id="scala.reflect.internal;Types.basetypeRecursions">basetypeRecursions</a> = <a href="#scala.reflect.internal;Types._basetypeRecursions_=" title="=&gt; Int">_basetypeRecursions</a>
  def <a title="(value: Int)Unit" id="scala.reflect.internal;Types.basetypeRecursions_=">basetypeRecursions_=</a><span class="delimiter">(</span><a title="Int" id="scala.reflect.internal;Types.basetypeRecursions_=.value">value</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types._basetypeRecursions_=" title="(x$1: Int)Unit">_basetypeRecursions</a> = <a href="#scala.reflect.internal;Types.basetypeRecursions_=.value" title="Int">value</a>

  private val <a title="scala.collection.mutable.HashSet[Types.this.Type]" id="scala.reflect.internal;Types._pendingBaseTypes">_pendingBaseTypes</a> = new mutable.<a href="../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet" title="scala.collection.mutable.HashSet[Types.this.Type]">HashSet</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>
  def <a title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]" id="scala.reflect.internal;Types.pendingBaseTypes">pendingBaseTypes</a> = <a href="#scala.reflect.internal;Types._pendingBaseTypes" title="=&gt; scala.collection.mutable.HashSet[Types.this.Type]">_pendingBaseTypes</a>

  <span class="comment">/** Does this type have a prefix that begins with a type variable,
   *  or is it a refinement type? For type prefixes that fulfil this condition,
   *  type selections with the same name of equal (as determined by `=:=`) prefixes are
   *  considered equal in regard to `=:=`.
   */</span>
  def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isEligibleForPrefixUnification">isEligibleForPrefixUnification</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isEligibleForPrefixUnification.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types.isEligibleForPrefixUnification.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case SingleType<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isEligibleForPrefixUnification.pre">pre</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.isEligibleForPrefixUnification.sym">sym</a><span class="delimiter">)</span>  =&gt; <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isEligibleForPrefixUnification.sym" title="Types.this.Symbol">sym</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.hasFlag(26ea2e307b)" title="(mask: Int)Boolean">hasFlag</a> <span title="Int(16384)">PACKAGE</span><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.isEligibleForPrefixUnification" title="(tp: Types.this.Type)Boolean">isEligibleForPrefixUnification</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isEligibleForPrefixUnification.pre" title="Types.this.Type">pre</a><span class="delimiter">)</span>
    case <a title="Types.this.TypeVar" id="scala.reflect.internal;Types.isEligibleForPrefixUnification.tv">tv</a>@TypeVar<span class="delimiter">(</span>_, <a title="Types.this.TypeConstraint" id="scala.reflect.internal;Types.isEligibleForPrefixUnification.constr">constr</a><span class="delimiter">)</span> =&gt; <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.isEligibleForPrefixUnification.tv" title="Types.this.TypeVar">tv</a>.<a href="#scala.reflect.internal;Types;TypeVar.instValid" title="=&gt; Boolean">instValid</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.isEligibleForPrefixUnification" title="(tp: Types.this.Type)Boolean">isEligibleForPrefixUnification</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isEligibleForPrefixUnification.constr" title="Types.this.TypeConstraint">constr</a>.<a href="tpe/TypeConstraints.scala.html#scala.reflect.internal.tpe;TypeConstraints;TypeConstraint.inst" title="=&gt; Types.this.Type">inst</a><span class="delimiter">)</span>
    case RefinedType<span class="delimiter">(</span>_, _<span class="delimiter">)</span>     =&gt; true
    case _                     =&gt; false
  <span class="delimiter">}</span>

  def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isErrorOrWildcard">isErrorOrWildcard</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isErrorOrWildcard.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isErrorOrWildcard.tp" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types.ErrorType.readResolve" title="Types.this.ErrorType.type">ErrorType</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isErrorOrWildcard.tp" title="Types.this.Type">tp</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types.WildcardType.readResolve" title="Types.this.WildcardType.type">WildcardType</a><span class="delimiter">)</span>

  <span class="comment">/** This appears to be equivalent to tp.isInstanceof[SingletonType],
   *  except it excludes ConstantTypes.
   */</span>
  def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isSingleType">isSingleType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isSingleType.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.isSingleType.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case ThisType<span class="delimiter">(</span>_<span class="delimiter">)</span> | SuperType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> | SingleType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt; true
    case _                                                =&gt; false
  <span class="delimiter">}</span>

  def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isConstantType">isConstantType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isConstantType.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.isConstantType.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case ConstantType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; true
    case _               =&gt; false
  <span class="delimiter">}</span>

  def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isExistentialType">isExistentialType</a><span class="delimiter">(</span><span title="Types.this.Type">tp</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span title="Types.this.Type">tp</span> match <span class="delimiter">{</span>
    case _: <a href="#scala.reflect.internal;Types;ExistentialType" title="Types.this.ExistentialType">ExistentialType</a>           =&gt; true
    case <span title="Types.this.Type">tp</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> if <span title="Types.this.Type">tp</span>.<a href="#scala.reflect.internal;Types;Type.dealias" title="=&gt; Types.this.Type">dealias</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Types.this.Type">tp</span> =&gt; <a href="#scala.reflect.internal;Types.isExistentialType" title="(tp: Types.this.Type)Boolean">isExistentialType</a><span class="delimiter">(</span><span title="Types.this.Type">tp</span>.<a href="#scala.reflect.internal;Types;Type.dealias" title="=&gt; Types.this.Type">dealias</a><span class="delimiter">)</span>
    case _                            =&gt; false
  <span class="delimiter">}</span>

  def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isImplicitMethodType">isImplicitMethodType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isImplicitMethodType.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.isImplicitMethodType.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case <a title="Types.this.MethodType" id="scala.reflect.internal;Types.isImplicitMethodType.mt">mt</a>: <a href="#scala.reflect.internal;Types;MethodType" title="Types.this.MethodType">MethodType</a> =&gt; <a href="#scala.reflect.internal;Types.isImplicitMethodType.mt" title="Types.this.MethodType">mt</a>.<a href="#scala.reflect.internal;Types;MethodType.isImplicit" title="=&gt; Boolean">isImplicit</a>
    case _              =&gt; false
  <span class="delimiter">}</span>

  <span class="comment">/** This is defined and named as it is because the goal is to exclude source
   *  level types which are not value types (e.g. MethodType) without excluding
   *  necessary internal types such as WildcardType.  There are also non-value
   *  types which can be used as type arguments (e.g. type constructors.)
   */</span>
  def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isUseableAsTypeArg">isUseableAsTypeArg</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isUseableAsTypeArg.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
       <a href="#scala.reflect.internal;Types.isInternalTypeUsedAsTypeArg" title="(tp: Types.this.Type)Boolean">isInternalTypeUsedAsTypeArg</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isUseableAsTypeArg.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>  <span class="comment">// the subset of internal types which can be type args</span>
    <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.isHKTypeRef" title="(tp: Types.this.Type)Boolean">isHKTypeRef</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isUseableAsTypeArg.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>                  <span class="comment">// not a value type, but ok as a type arg</span>
    <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.isValueElseNonValue" title="(tp: Types.this.Type)Boolean">isValueElseNonValue</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isUseableAsTypeArg.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span>          <span class="comment">// otherwise only value types</span>
  <span class="delimiter">)</span>

  private def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isHKTypeRef">isHKTypeRef</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isHKTypeRef.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.isHKTypeRef.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.isHKTypeRef.sym">sym</a>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.isHKTypeRef.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a>
    case _                    =&gt; false
  <span class="delimiter">}</span>
  @tailrec final def <a title="(tps: List[Types.this.Type])Boolean" id="scala.reflect.internal;Types.isUseableAsTypeArgs">isUseableAsTypeArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.isUseableAsTypeArgs.tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types.isUseableAsTypeArgs.tps" title="List[Types.this.Type]">tps</a> match <span class="delimiter">{</span>
    case <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>     =&gt; true
    case <a title="Types.this.Type" id="scala.reflect.internal;Types.isUseableAsTypeArgs.x">x</a> :: <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.isUseableAsTypeArgs.xs">xs</a> =&gt; <a href="#scala.reflect.internal;Types.isUseableAsTypeArg" title="(tp: Types.this.Type)Boolean">isUseableAsTypeArg</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isUseableAsTypeArgs.x" title="Types.this.Type">x</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.isUseableAsTypeArgs" title="(tps: List[Types.this.Type])Boolean">isUseableAsTypeArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isUseableAsTypeArgs.xs" title="List[Types.this.Type]">xs</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The &quot;third way&quot;, types which are neither value types nor
   *  non-value types as defined in the SLS, further divided into
   *  types which are used internally in type applications and
   *  types which are not.
   */</span>
  <span class="comment">/**** Not used right now, but kept around to document which Types
   *    land in which bucket.
  private def isInternalTypeNotUsedAsTypeArg(tp: Type): Boolean = tp match {
    case AntiPolyType(pre, targs)            =&gt; true
    case ClassInfoType(parents, defs, clazz) =&gt; true
    case ErasedValueType(tref)               =&gt; true
    case NoPrefix                            =&gt; true
    case NoType                              =&gt; true
    case SuperType(thistpe, supertpe)        =&gt; true
    case TypeBounds(lo, hi)                  =&gt; true
    case _                                   =&gt; false
  }
  ****/</span>
  private def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isInternalTypeUsedAsTypeArg">isInternalTypeUsedAsTypeArg</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isInternalTypeUsedAsTypeArg.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types.isInternalTypeUsedAsTypeArg.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case <a href="#scala.reflect.internal;Types.WildcardType.readResolve" title="Types.this.WildcardType.type">WildcardType</a>           =&gt; true
    case BoundedWildcardType<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt; true
    case <a href="#scala.reflect.internal;Types.ErrorType.readResolve" title="Types.this.ErrorType.type">ErrorType</a>              =&gt; true
    case _: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a>             =&gt; true
    case _                      =&gt; false
  <span class="delimiter">}</span>
  private def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isAlwaysValueType">isAlwaysValueType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isAlwaysValueType.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.isAlwaysValueType.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case RefinedType<span class="delimiter">(</span>_, _<span class="delimiter">)</span>       =&gt; true
    case ExistentialType<span class="delimiter">(</span>_, _<span class="delimiter">)</span>   =&gt; true
    case ConstantType<span class="delimiter">(</span>_<span class="delimiter">)</span>         =&gt; true
    case _                       =&gt; false
  <span class="delimiter">}</span>
  private def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isAlwaysNonValueType">isAlwaysNonValueType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isAlwaysNonValueType.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.isAlwaysNonValueType.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case OverloadedType<span class="delimiter">(</span>_, _<span class="delimiter">)</span>          =&gt; true
    case NullaryMethodType<span class="delimiter">(</span>_<span class="delimiter">)</span>          =&gt; true
    case MethodType<span class="delimiter">(</span>_, _<span class="delimiter">)</span>              =&gt; true
    case PolyType<span class="delimiter">(</span>_, MethodType<span class="delimiter">(</span>_, _<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; true
    case _                             =&gt; false
  <span class="delimiter">}</span>
  <span class="comment">/** Should be called only with types for which a clear true/false answer
   *  can be given: true == value type, false == non-value type.  Otherwise,
   *  an exception is thrown.
   */</span>
  private def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isValueElseNonValue">isValueElseNonValue</a><span class="delimiter">(</span><span title="Types.this.Type">tp</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span title="Types.this.Type">tp</span> match <span class="delimiter">{</span>
    case <span title="Types.this.Type">tp</span> if <a href="#scala.reflect.internal;Types.isAlwaysValueType" title="(tp: Types.this.Type)Boolean">isAlwaysValueType</a><span class="delimiter">(</span><span title="Types.this.Type">tp</span><span class="delimiter">)</span>           =&gt; true
    case <span title="Types.this.Type">tp</span> if <a href="#scala.reflect.internal;Types.isAlwaysNonValueType" title="(tp: Types.this.Type)Boolean">isAlwaysNonValueType</a><span class="delimiter">(</span><span title="Types.this.Type">tp</span><span class="delimiter">)</span>        =&gt; false
    case AnnotatedType<span class="delimiter">(</span>_, <a title="Types.this.Type" id="scala.reflect.internal;Types.isValueElseNonValue.underlying">underlying</a><span class="delimiter">)</span>          =&gt; <a href="#scala.reflect.internal;Types.isValueElseNonValue" title="(tp: Types.this.Type)Boolean">isValueElseNonValue</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isValueElseNonValue.underlying" title="Types.this.Type">underlying</a><span class="delimiter">)</span>
    case SingleType<span class="delimiter">(</span>_, <span title="Types.this.Symbol">sym</span><span class="delimiter">)</span>                    =&gt; <span title="Types.this.Symbol">sym</span>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isValue" title="=&gt; Boolean">isValue</a>           <span class="comment">// excludes packages and statics</span>
    case TypeRef<span class="delimiter">(</span>_, _, _<span class="delimiter">)</span> if <span title="Types.this.Type">tp</span>.<a href="#scala.reflect.internal;Types;Type.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a> =&gt; false                 <span class="comment">// excludes type constructors</span>
    case ThisType<span class="delimiter">(</span><span title="Types.this.Symbol">sym</span><span class="delimiter">)</span>                         =&gt; <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span title="Types.this.Symbol">sym</span>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a>   <span class="comment">// excludes packages</span>
    case TypeRef<span class="delimiter">(</span>_, <span title="Types.this.Symbol">sym</span>, _<span class="delimiter">)</span>                    =&gt; <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span title="Types.this.Symbol">sym</span>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isPackageClass" title="=&gt; Boolean">isPackageClass</a>   <span class="comment">// excludes packages</span>
    case PolyType<span class="delimiter">(</span>_, _<span class="delimiter">)</span>                        =&gt; true                  <span class="comment">// poly-methods excluded earlier</span>
    case <span title="Types.this.Type">tp</span>                                    =&gt; sys.<a href="../../sys/package.scala.html#scala.sys.package.error" title="(message: String)Nothing">error</a><span class="delimiter">(</span><span title="String(&quot;isValueElseNonValue called with third-way type &quot;)" class="string">&quot;isValueElseNonValue called with third-way type &quot;</span> <span title="(x$1: Any)String">+</span> <span title="Types.this.Type">tp</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** SLS 3.2, Value Types
   *  Is the given type definitely a value type? A true result means
   *  it verifiably is, but a false result does not mean it is not,
   *  only that it cannot be assured.  To avoid false positives, this
   *  defaults to false, but since Type is not sealed, one should take
   *  a false answer with a grain of salt.  This method may be primarily
   *  useful as documentation; it is likely that !isNonValueType(tp)
   *  will serve better than isValueType(tp).
   */</span>
  <span class="comment">/** def isValueType(tp: Type) = isValueElseNonValue(tp) */</span>

  <span class="comment">/** SLS 3.3, Non-Value Types
   *  Is the given type definitely a non-value type, as defined in SLS 3.3?
   *  The specification-enumerated non-value types are method types, polymorphic
   *  method types, and type constructors.  Supplements to the specified set of
   *  non-value types include: types which wrap non-value symbols (packages
   *  abd statics), overloaded types. Varargs and by-name types T* and (=&gt;T) are
   *  not designated non-value types because there is code which depends on using
   *  them as type arguments, but their precise status is unclear.
   */</span>
  <span class="comment">/** def isNonValueType(tp: Type) = !isValueElseNonValue(tp) */</span>

  def <a title="(tpe: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isNonRefinementClassType">isNonRefinementClassType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isNonRefinementClassType.tpe">tpe</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.isNonRefinementClassType.tpe" title="Types.this.Type">tpe</a> match <span class="delimiter">{</span>
    case SingleType<span class="delimiter">(</span>_, <span title="Types.this.Symbol">sym</span><span class="delimiter">)</span> =&gt; <span title="Types.this.Symbol">sym</span>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModuleClass" title="=&gt; Boolean">isModuleClass</a>
    case TypeRef<span class="delimiter">(</span>_, <span title="Types.this.Symbol">sym</span>, _<span class="delimiter">)</span> =&gt; <span title="Types.this.Symbol">sym</span>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isClass" title="=&gt; Boolean">isClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span title="Types.this.Symbol">sym</span>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isRefinementClass" title="=&gt; Boolean">isRefinementClass</a>
    case <a href="#scala.reflect.internal;Types.ErrorType.readResolve" title="Types.this.ErrorType.type">ErrorType</a>          =&gt; true
    case _                  =&gt; false
  <span class="delimiter">}</span>

  def <a title="(tps1: List[Types.this.Type], tps2: List[Types.this.Type], tparams: List[Types.this.Symbol], depth: scala.reflect.internal.Depth)Boolean" id="scala.reflect.internal;Types.isSubArgs">isSubArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.isSubArgs.tps1">tps1</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.isSubArgs.tps2">tps2</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.isSubArgs.tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="scala.reflect.internal.Depth" id="scala.reflect.internal;Types.isSubArgs.depth">depth</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    def <a title="(t1: Types.this.Type, t2: Types.this.Type, variance: scala.reflect.internal.Variance)Boolean" id="scala.reflect.internal;Types.isSubArgs.isSubArg">isSubArg</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isSubArgs.isSubArg.t1">t1</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.isSubArgs.isSubArg.t2">t2</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="scala.reflect.internal.Variance" id="scala.reflect.internal;Types.isSubArgs.isSubArg.variance">variance</a>: <a href="Variance.scala.html#scala.reflect.internal;Variance" title="scala.reflect.internal.Variance">Variance</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
         <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isSubArgs.isSubArg.variance" title="scala.reflect.internal.Variance">variance</a>.<a href="Variance.scala.html#scala.reflect.internal;Variance.isCovariant" title="=&gt; Boolean">isCovariant</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="tpe/TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isSubType" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: scala.reflect.internal.Depth)Boolean">isSubType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isSubArgs.isSubArg.t2" title="Types.this.Type">t2</a>, <a href="#scala.reflect.internal;Types.isSubArgs.isSubArg.t1" title="Types.this.Type">t1</a>, <a href="#scala.reflect.internal;Types.isSubArgs.depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>     <span class="comment">// The order of these two checks can be material for performance (SI-8478)</span>
      <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isSubArgs.isSubArg.variance" title="scala.reflect.internal.Variance">variance</a>.<a href="Variance.scala.html#scala.reflect.internal;Variance.isContravariant" title="=&gt; Boolean">isContravariant</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="tpe/TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isSubType" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: scala.reflect.internal.Depth)Boolean">isSubType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isSubArgs.isSubArg.t1" title="Types.this.Type">t1</a>, <a href="#scala.reflect.internal;Types.isSubArgs.isSubArg.t2" title="Types.this.Type">t2</a>, <a href="#scala.reflect.internal;Types.isSubArgs.depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>

    <a href="util/Collections.scala.html#scala.reflect.internal.util;Collections.corresponds3" title="(xs1: List[Types.this.Type], xs2: List[Types.this.Type], xs3: List[scala.reflect.internal.Variance])(f: (Types.this.Type, Types.this.Type, scala.reflect.internal.Variance) =&gt; Boolean)Boolean">corresponds3</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isSubArgs.tps1" title="List[Types.this.Type]">tps1</a>, <a href="#scala.reflect.internal;Types.isSubArgs.tps2" title="List[Types.this.Type]">tps2</a>, <a href="util/Collections.scala.html#scala.reflect.internal.util;Collections.mapList" title="(as: List[Types.this.Symbol])(f: Types.this.Symbol =&gt; scala.reflect.internal.Variance)List[scala.reflect.internal.Variance]">mapList</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isSubArgs.tparams" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isSubArgs.$anonfun.x$58" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.variance" title="=&gt; scala.reflect.internal.Variance">variance</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isSubArgs.isSubArg" title="(t1: Types.this.Type, t2: Types.this.Type, variance: scala.reflect.internal.Variance)Boolean">isSubArg</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(tp: Types.this.Type, sym: Types.this.Symbol, depth: scala.reflect.internal.Depth)Boolean" id="scala.reflect.internal;Types.specializesSym(a94a1d1410)">specializesSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.specializesSym(a94a1d1410).tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.specializesSym(a94a1d1410).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="scala.reflect.internal.Depth" id="scala.reflect.internal;Types.specializesSym(a94a1d1410).depth">depth</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    def <a title="(member: Types.this.Symbol)Boolean" id="scala.reflect.internal;Types.specializesSym(a94a1d1410).directlySpecializedBy">directlySpecializedBy</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.specializesSym(a94a1d1410).directlySpecializedBy.member">member</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">(</span>
         <a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).directlySpecializedBy.member" title="Types.this.Symbol">member</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).sym" title="Types.this.Symbol">sym</a>
      <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88)" title="(preLo: Types.this.Type, symLo: Types.this.Symbol, preHi: Types.this.Type, symHi: Types.this.Symbol, depth: scala.reflect.internal.Depth)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.narrow" title="=&gt; Types.this.Type">narrow</a>, <a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).directlySpecializedBy.member" title="Types.this.Symbol">member</a>, <a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.thisType" title="=&gt; Types.this.Type">thisType</a>, <a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).sym" title="Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    <span class="comment">// Closure reduction, else this would be simply `member exists directlySpecializedBy`</span>
    def <a title="(member: Types.this.Symbol)Boolean" id="scala.reflect.internal;Types.specializesSym(a94a1d1410).specializedBy">specializedBy</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.specializesSym(a94a1d1410).specializedBy.member">member</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">(</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).specializedBy.member" title="Types.this.Symbol">member</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> false
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).specializedBy.member" title="Types.this.Symbol">member</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isOverloaded" title="=&gt; Boolean">isOverloaded</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).specializedBy.member" title="Types.this.Symbol">member</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.alternatives" title="=&gt; List[Types.this.Symbol]">alternatives</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).directlySpecializedBy" title="(member: Types.this.Symbol)Boolean">directlySpecializedBy</a>
      else <a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).directlySpecializedBy" title="(member: Types.this.Symbol)Boolean">directlySpecializedBy</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).specializedBy.member" title="Types.this.Symbol">member</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>

    <span class="delimiter">(</span>    <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isBottomSubClass" title="(that: Types.this.Symbol)Boolean">isBottomSubClass</a> <a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).specializedBy" title="(member: Types.this.Symbol)Boolean">specializedBy</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).tp" title="Types.this.Type">tp</a> <a href="#scala.reflect.internal;Types;Type.nonPrivateMember" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateMember</a> <a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410).sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym.NameType">name</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Does member `symLo` of `tpLo` have a stronger type
   *  than member `symHi` of `tpHi`?
   */</span>
  protected<span class="delimiter">[</span>internal<span class="delimiter">]</span> def <a title="(preLo: Types.this.Type, symLo: Types.this.Symbol, preHi: Types.this.Type, symHi: Types.this.Symbol, depth: scala.reflect.internal.Depth)Boolean" id="scala.reflect.internal;Types.specializesSym(bf05deaf88)">specializesSym</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.specializesSym(bf05deaf88).preLo">preLo</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.specializesSym(bf05deaf88).symLo">symLo</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.specializesSym(bf05deaf88).preHi">preHi</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.specializesSym(bf05deaf88).symHi">symHi</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="scala.reflect.internal.Depth" id="scala.reflect.internal;Types.specializesSym(bf05deaf88).depth">depth</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> =
    <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symHi" title="Types.this.Symbol">symHi</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAliasType" title="=&gt; Boolean">isAliasType</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symHi" title="Types.this.Symbol">symHi</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isTerm" title="=&gt; Boolean">isTerm</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symHi" title="Types.this.Symbol">symHi</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAbstractType" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
      <span class="comment">// only now that we know symHi is a viable candidate ^^^^^^^, do the expensive checks: ----V</span>
      <a href="../../Predef.scala.html#scala.Predef.require(a2f0e4a061)" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symLo" title="Types.this.Symbol">symLo</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symHi" title="Types.this.Symbol">symHi</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>, <span class="delimiter">(</span><a href="../../Tuple5.scala.html#scala;Tuple5" title="(_1: Types.this.Type, _2: Types.this.Symbol, _3: Types.this.Type, _4: Types.this.Symbol, _5: scala.reflect.internal.Depth)(Types.this.Type, Types.this.Symbol, Types.this.Type, Types.this.Symbol, scala.reflect.internal.Depth)" class="delimiter">(</a><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).preLo" title="Types.this.Type">preLo</a>, <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symLo" title="Types.this.Symbol">symLo</a>, <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).preHi" title="Types.this.Type">preHi</a>, <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symHi" title="Types.this.Symbol">symHi</a>, <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

      val <a title="Types.this.Type" id="scala.reflect.internal;Types.specializesSym(bf05deaf88).tpHi">tpHi</a> = <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).preHi" title="Types.this.Type">preHi</a>.<a href="#scala.reflect.internal;Types;Type.memberInfo" title="(sym: Types.this.Symbol)Types.this.Type">memberInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symHi" title="Types.this.Symbol">symHi</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.substThis(9f714a76d3)" title="(from: Types.this.Symbol, to: Types.this.Type)Types.this.Type">substThis</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).preHi" title="Types.this.Type">preHi</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>, <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).preLo" title="Types.this.Type">preLo</a><span class="delimiter">)</span>

      <span class="comment">// Should we use memberType or memberInfo?</span>
      <span class="comment">// memberType transforms (using `asSeenFrom`) `sym.tpe`,</span>
      <span class="comment">// whereas memberInfo performs the same transform on `sym.info`.</span>
      <span class="comment">// For term symbols, this ends up being the same thing (`sym.tpe == sym.info`).</span>
      <span class="comment">// For type symbols, however, the `.info` of an abstract type member</span>
      <span class="comment">// is defined by its bounds, whereas its `.tpe` is a `TypeRef` to that type symbol,</span>
      <span class="comment">// so that `sym.tpe &lt;:&lt; sym.info`, but not the other way around.</span>
      <span class="comment">//</span>
      <span class="comment">// Thus, for the strongest (correct) result,</span>
      <span class="comment">// we should use `memberType` on the low side.</span>
      <span class="comment">//</span>
      <span class="comment">// On the high side, we should use the result appropriate</span>
      <span class="comment">// for the right side of the `&lt;:&lt;` above (`memberInfo`).</span>
      val <a title="Types.this.Type" id="scala.reflect.internal;Types.specializesSym(bf05deaf88).tpLo">tpLo</a> = <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).preLo" title="Types.this.Type">preLo</a>.<a href="#scala.reflect.internal;Types;Type.memberType" title="(sym: Types.this.Symbol)Types.this.Type">memberType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symLo" title="Types.this.Symbol">symLo</a><span class="delimiter">)</span>

      <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;specializesSymHi: &quot;)">specializesSymHi: $</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).preHi" title="Types.this.Type">preHi</a><span title="String(&quot; . &quot;)"> . $</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symHi" title="Types.this.Symbol">symHi</a><span title="String(&quot; : &quot;)"> : $</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).tpHi" title="Types.this.Type">tpHi</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
      <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;specializesSymLo: &quot;)">specializesSymLo: $</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).preLo" title="Types.this.Type">preLo</a><span title="String(&quot; . &quot;)"> . $</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symLo" title="Types.this.Symbol">symLo</a><span title="String(&quot; : &quot;)"> : $</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).tpLo" title="Types.this.Type">tpLo</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>

      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symHi" title="Types.this.Symbol">symHi</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isTerm" title="=&gt; Boolean">isTerm</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="tpe/TypeComparers.scala.html#scala.reflect.internal.tpe;TypeComparers.isSubType" title="(tp1: Types.this.Type, tp2: Types.this.Type, depth: scala.reflect.internal.Depth)Boolean">isSubType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).tpLo" title="Types.this.Type">tpLo</a>, <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).tpHi" title="Types.this.Type">tpHi</a>, <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span>        <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
         <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symHi" title="Types.this.Symbol">symHi</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isStable" title="=&gt; Boolean">isStable</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symLo" title="Types.this.Symbol">symLo</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isStable" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>                                <span class="comment">// sub-member must remain stable</span>
         <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symLo" title="Types.this.Symbol">symLo</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.hasVolatileType" title="=&gt; Boolean">hasVolatileType</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symHi" title="Types.this.Symbol">symHi</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.hasVolatileType" title="=&gt; Boolean">hasVolatileType</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).tpHi" title="Types.this.Type">tpHi</a>.<a href="#scala.reflect.internal;Types;Type.isWildcard" title="=&gt; Boolean">isWildcard</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// sub-member must not introduce volatility</span>
      else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symHi" title="Types.this.Symbol">symHi</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAbstractType" title="=&gt; Boolean">isAbstractType</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).tpHi" title="Types.this.Type">tpHi</a>.<a href="#scala.reflect.internal;Types;Type.bounds" title="=&gt; Types.this.TypeBounds">bounds</a> <a href="#scala.reflect.internal;Types;TypeBounds.containsType" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).tpLo" title="Types.this.Type">tpLo</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
         <a href="Kinds.scala.html#scala.reflect.internal;Kinds.kindsConform" title="(tparams: List[Types.this.Symbol], targs: List[Types.this.Type], pre: Types.this.Type, owner: Types.this.Symbol)Boolean">kindsConform</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symHi" title="Types.this.Symbol">symHi</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.Symbol)List[Types.this.Symbol]">::</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).tpLo" title="Types.this.Type">tpLo</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).preLo" title="Types.this.Type">preLo</a>, <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).symLo" title="Types.this.Symbol">symLo</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>
      else <span class="comment">// we know `symHi.isAliasType` (see above)</span>
        <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).tpLo" title="Types.this.Type">tpLo</a> <a href="#scala.reflect.internal;Types;Type.=:=" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88).tpHi" title="Types.this.Type">tpHi</a>
    <span class="delimiter">}</span>

  <span class="comment">/** A function implementing `tp1` matches `tp2`. */</span>
  final def <a title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean" id="scala.reflect.internal;Types.matchesType">matchesType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.matchesType.tp1">tp1</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.matchesType.tp2">tp2</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Boolean" id="scala.reflect.internal;Types.matchesType.alwaysMatchSimple">alwaysMatchSimple</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    def <a title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean" id="scala.reflect.internal;Types.matchesType.matchesQuantified">matchesQuantified</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.matchesType.matchesQuantified.tparams1">tparams1</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.matchesType.matchesQuantified.tparams2">tparams2</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.internal;Types.matchesType.matchesQuantified.res1">res1</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.matchesType.matchesQuantified.res2">res2</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">(</span>
      <a href="#scala.reflect.internal;Types.sameLength" title="(xs1: List[_], xs2: List[_])Boolean">sameLength</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.matchesQuantified.tparams1" title="List[Types.this.Symbol]">tparams1</a>, <a href="#scala.reflect.internal;Types.matchesType.matchesQuantified.tparams2" title="List[Types.this.Symbol]">tparams2</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
      <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.matchesQuantified.res1" title="Types.this.Type">res1</a>, <a href="#scala.reflect.internal;Types.matchesType.matchesQuantified.res2" title="Types.this.Type">res2</a>.<a href="#scala.reflect.internal;Types;Type.substSym" title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type">substSym</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.matchesQuantified.tparams2" title="List[Types.this.Symbol]">tparams2</a>, <a href="#scala.reflect.internal;Types.matchesType.matchesQuantified.tparams1" title="List[Types.this.Symbol]">tparams1</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    def <a title="=&gt; Boolean" id="scala.reflect.internal;Types.matchesType.lastTry">lastTry</a> =
      <a href="#scala.reflect.internal;Types.matchesType.tp2" title="Types.this.Type">tp2</a> match <span class="delimiter">{</span>
        case ExistentialType<span class="delimiter">(</span>_, <a title="Types.this.Type" id="scala.reflect.internal;Types.matchesType.lastTry.res2">res2</a><span class="delimiter">)</span> if <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a> =&gt;
          <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.tp1" title="Types.this.Type">tp1</a>, <a href="#scala.reflect.internal;Types.matchesType.lastTry.res2" title="Types.this.Type">res2</a>, alwaysMatchSimple = true<span class="delimiter">)</span>
        case MethodType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
          false
        case PolyType<span class="delimiter">(</span>_, _<span class="delimiter">)</span> =&gt;
          false
        case _ =&gt;
          <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.matchesType.tp1" title="Types.this.Type">tp1</a> <a href="#scala.reflect.internal;Types;Type.=:=" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#scala.reflect.internal;Types.matchesType.tp2" title="Types.this.Type">tp2</a>
      <span class="delimiter">}</span>
    <a href="#scala.reflect.internal;Types.matchesType.tp1" title="Types.this.Type">tp1</a> match <span class="delimiter">{</span>
      case <span title="Types.this.MethodType">mt1</span> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.matchesType.params1">params1</a>, <span title="Types.this.Type">res1</span><span class="delimiter">)</span> =&gt;
        <a href="#scala.reflect.internal;Types.matchesType.tp2" title="Types.this.Type">tp2</a> match <span class="delimiter">{</span>
          case <span title="Types.this.MethodType">mt2</span> @ MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.matchesType.params2">params2</a>, <span title="Types.this.Type">res2</span><span class="delimiter">)</span> =&gt;
            <span class="comment">// sameLength(params1, params2) was used directly as pre-screening optimization (now done by matchesQuantified -- is that ok, performancewise?)</span>
            <span title="Types.this.MethodType">mt1</span>.<a href="#scala.reflect.internal;Types;MethodType.isImplicit" title="=&gt; Boolean">isImplicit</a> <a href="../../Boolean.scala.html#scala;Boolean.==(763c96e1b1)" title="(x: Boolean)Boolean">==</a> <span title="Types.this.MethodType">mt2</span>.<a href="#scala.reflect.internal;Types;MethodType.isImplicit" title="=&gt; Boolean">isImplicit</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
            <a href="#scala.reflect.internal;Types.matchingParams" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.params1" title="List[Types.this.Symbol]">params1</a>, <a href="#scala.reflect.internal;Types.matchesType.params2" title="List[Types.this.Symbol]">params2</a>, <span title="Types.this.MethodType">mt1</span>.<a href="#scala.reflect.internal;Types;MethodType.isJava" title="=&gt; Boolean">isJava</a>, <span title="Types.this.MethodType">mt2</span>.<a href="#scala.reflect.internal;Types;MethodType.isJava" title="=&gt; Boolean">isJava</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
            <a href="#scala.reflect.internal;Types.matchesType.matchesQuantified" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.params1" title="List[Types.this.Symbol]">params1</a>, <a href="#scala.reflect.internal;Types.matchesType.params2" title="List[Types.this.Symbol]">params2</a>, <span title="Types.this.Type">res1</span>, <span title="Types.this.Type">res2</span><span class="delimiter">)</span>
          case NullaryMethodType<span class="delimiter">(</span><span title="Types.this.Type">res2</span><span class="delimiter">)</span> =&gt;
            if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.params1" title="List[Types.this.Symbol]">params1</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><span title="Types.this.Type">res1</span>, <span title="Types.this.Type">res2</span>, <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
            else <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.tp1" title="Types.this.Type">tp1</a>, <span title="Types.this.Type">res2</span>, <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          case ExistentialType<span class="delimiter">(</span>_, <span title="Types.this.Type">res2</span><span class="delimiter">)</span> =&gt;
            <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.tp1" title="Types.this.Type">tp1</a>, <span title="Types.this.Type">res2</span>, alwaysMatchSimple = true<span class="delimiter">)</span>
          case TypeRef<span class="delimiter">(</span>_, <span title="Types.this.Symbol">sym</span>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> =&gt;
            <a href="#scala.reflect.internal;Types.matchesType.params1" title="List[Types.this.Symbol]">params1</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span title="Types.this.Symbol">sym</span>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModuleClass" title="=&gt; Boolean">isModuleClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><span title="Types.this.Type">res1</span>, <a href="#scala.reflect.internal;Types.matchesType.tp2" title="Types.this.Type">tp2</a>, <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          case _ =&gt;
            false
        <span class="delimiter">}</span>
      case <span title="Types.this.NullaryMethodType">mt1</span> @ NullaryMethodType<span class="delimiter">(</span><span title="Types.this.Type">res1</span><span class="delimiter">)</span> =&gt;
        <a href="#scala.reflect.internal;Types.matchesType.tp2" title="Types.this.Type">tp2</a> match <span class="delimiter">{</span>
          case <span title="Types.this.MethodType">mt2</span> @ MethodType<span class="delimiter">(</span><a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <span title="Types.this.Type">res2</span><span class="delimiter">)</span>  =&gt; <span class="comment">// could never match if params nonEmpty, and !mt2.isImplicit is implied by empty param list</span>
            <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><span title="Types.this.Type">res1</span>, <span title="Types.this.Type">res2</span>, <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          case NullaryMethodType<span class="delimiter">(</span><span title="Types.this.Type">res2</span><span class="delimiter">)</span> =&gt;
            <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><span title="Types.this.Type">res1</span>, <span title="Types.this.Type">res2</span>, <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          case ExistentialType<span class="delimiter">(</span>_, <span title="Types.this.Type">res2</span><span class="delimiter">)</span> =&gt;
            <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.tp1" title="Types.this.Type">tp1</a>, <span title="Types.this.Type">res2</span>, alwaysMatchSimple = true<span class="delimiter">)</span>
          case TypeRef<span class="delimiter">(</span>_, <span title="Types.this.Symbol">sym</span>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> if <span title="Types.this.Symbol">sym</span>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModuleClass" title="=&gt; Boolean">isModuleClass</a> =&gt;
            <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><span title="Types.this.Type">res1</span>, <a href="#scala.reflect.internal;Types.matchesType.tp2" title="Types.this.Type">tp2</a>, <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          case _ =&gt;
            <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><span title="Types.this.Type">res1</span>, <a href="#scala.reflect.internal;Types.matchesType.tp2" title="Types.this.Type">tp2</a>, <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      case PolyType<span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams1</span>, <span title="Types.this.Type">res1</span><span class="delimiter">)</span> =&gt;
        <a href="#scala.reflect.internal;Types.matchesType.tp2" title="Types.this.Type">tp2</a> match <span class="delimiter">{</span>
          case PolyType<span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams2</span>, <span title="Types.this.Type">res2</span><span class="delimiter">)</span> =&gt;
            if <span class="delimiter">(</span><span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams1</span> <a href="../../collection/LinearSeqLike.scala.html#scala.collection;LinearSeqLike.corresponds" title="(that: scala.collection.GenSeq[Types.this.Symbol])(p: (Types.this.Symbol, Types.this.Symbol) =&gt; Boolean)Boolean">corresponds</a> <span title="List[Types.this.Symbol]">tparams2</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.$anonfun.x$61" title="Types.this.Symbol">_</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;Types.matchesType.$anonfun.x$62" title="Types.this.Symbol">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><span title="Types.this.Type">res1</span>, <span title="Types.this.Type">res2</span>, <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
            else
              <a href="#scala.reflect.internal;Types.matchesType.matchesQuantified" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams1</span>, <span title="List[Types.this.Symbol]">tparams2</span>, <span title="Types.this.Type">res1</span>, <span title="Types.this.Type">res2</span><span class="delimiter">)</span>
          case ExistentialType<span class="delimiter">(</span>_, <span title="Types.this.Type">res2</span><span class="delimiter">)</span> =&gt;
            <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.tp1" title="Types.this.Type">tp1</a>, <span title="Types.this.Type">res2</span>, alwaysMatchSimple = true<span class="delimiter">)</span>
          case _ =&gt;
            false <span class="comment">// remember that tparams1.nonEmpty is now an invariant of PolyType</span>
        <span class="delimiter">}</span>
      case ExistentialType<span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams1</span>, <span title="Types.this.Type">res1</span><span class="delimiter">)</span> =&gt;
        <a href="#scala.reflect.internal;Types.matchesType.tp2" title="Types.this.Type">tp2</a> match <span class="delimiter">{</span>
          case ExistentialType<span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams2</span>, <span title="Types.this.Type">res2</span><span class="delimiter">)</span> =&gt;
            <a href="#scala.reflect.internal;Types.matchesType.matchesQuantified" title="(tparams1: List[Types.this.Symbol], tparams2: List[Types.this.Symbol], res1: Types.this.Type, res2: Types.this.Type)Boolean">matchesQuantified</a><span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams1</span>, <span title="List[Types.this.Symbol]">tparams2</span>, <span title="Types.this.Type">res1</span>, <span title="Types.this.Type">res2</span><span class="delimiter">)</span>
          case _ =&gt;
            if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><span title="Types.this.Type">res1</span>, <a href="#scala.reflect.internal;Types.matchesType.tp2" title="Types.this.Type">tp2</a>, alwaysMatchSimple = true<span class="delimiter">)</span>
            else <a href="#scala.reflect.internal;Types.matchesType.lastTry" title="=&gt; Boolean">lastTry</a>
        <span class="delimiter">}</span>
      case TypeRef<span class="delimiter">(</span>_, <span title="Types.this.Symbol">sym</span>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> if <span title="Types.this.Symbol">sym</span>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModuleClass" title="=&gt; Boolean">isModuleClass</a> =&gt;
        <a href="#scala.reflect.internal;Types.matchesType.tp2" title="Types.this.Type">tp2</a> match <span class="delimiter">{</span>
          case MethodType<span class="delimiter">(</span><a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <span title="Types.this.Type">res2</span><span class="delimiter">)</span>   =&gt; <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.tp1" title="Types.this.Type">tp1</a>, <span title="Types.this.Type">res2</span>, <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          case NullaryMethodType<span class="delimiter">(</span><span title="Types.this.Type">res2</span><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.matchesType" title="(tp1: Types.this.Type, tp2: Types.this.Type, alwaysMatchSimple: Boolean)Boolean">matchesType</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchesType.tp1" title="Types.this.Type">tp1</a>, <span title="Types.this.Type">res2</span>, <a href="#scala.reflect.internal;Types.matchesType.alwaysMatchSimple" title="Boolean">alwaysMatchSimple</a><span class="delimiter">)</span>
          case _                       =&gt; <a href="#scala.reflect.internal;Types.matchesType.lastTry" title="=&gt; Boolean">lastTry</a>
        <span class="delimiter">}</span>
      case _ =&gt;
        <a href="#scala.reflect.internal;Types.matchesType.lastTry" title="=&gt; Boolean">lastTry</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="comment">/** matchesType above is an optimized version of the following implementation:

  def matchesType2(tp1: Type, tp2: Type, alwaysMatchSimple: Boolean): Boolean = {
    def matchesQuantified(tparams1: List[Symbol], tparams2: List[Symbol], res1: Type, res2: Type): Boolean =
      tparams1.length == tparams2.length &amp;&amp;
      matchesType(res1, res2.substSym(tparams2, tparams1), alwaysMatchSimple)
    (tp1, tp2) match {
      case (MethodType(params1, res1), MethodType(params2, res2)) =&gt;
        params1.length == params2.length &amp;&amp; // useful pre-secreening optimization
        matchingParams(params1, params2, tp1.isInstanceOf[JavaMethodType], tp2.isInstanceOf[JavaMethodType]) &amp;&amp;
        matchesType(res1, res2, alwaysMatchSimple) &amp;&amp;
        tp1.isImplicit == tp2.isImplicit
      case (PolyType(tparams1, res1), PolyType(tparams2, res2)) =&gt;
        matchesQuantified(tparams1, tparams2, res1, res2)
      case (NullaryMethodType(rtp1), MethodType(List(), rtp2)) =&gt;
        matchesType(rtp1, rtp2, alwaysMatchSimple)
      case (MethodType(List(), rtp1), NullaryMethodType(rtp2)) =&gt;
        matchesType(rtp1, rtp2, alwaysMatchSimple)
      case (ExistentialType(tparams1, res1), ExistentialType(tparams2, res2)) =&gt;
        matchesQuantified(tparams1, tparams2, res1, res2)
      case (ExistentialType(_, res1), _) if alwaysMatchSimple =&gt;
        matchesType(res1, tp2, alwaysMatchSimple)
      case (_, ExistentialType(_, res2)) if alwaysMatchSimple =&gt;
        matchesType(tp1, res2, alwaysMatchSimple)
      case (NullaryMethodType(rtp1), _) =&gt;
        matchesType(rtp1, tp2, alwaysMatchSimple)
      case (_, NullaryMethodType(rtp2)) =&gt;
        matchesType(tp1, rtp2, alwaysMatchSimple)
      case (MethodType(_, _), _) =&gt; false
      case (PolyType(_, _), _)   =&gt; false
      case (_, MethodType(_, _)) =&gt; false
      case (_, PolyType(_, _))   =&gt; false
      case _ =&gt;
        alwaysMatchSimple || tp1 =:= tp2
    }
  }
*/</span>

  <span class="comment">/** Are `syms1` and `syms2` parameter lists with pairwise equivalent types? */</span>
  protected<span class="delimiter">[</span>internal<span class="delimiter">]</span> def <a title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean" id="scala.reflect.internal;Types.matchingParams">matchingParams</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.matchingParams.syms1">syms1</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.matchingParams.syms2">syms2</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Boolean" id="scala.reflect.internal;Types.matchingParams.syms1isJava">syms1isJava</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>, <a title="Boolean" id="scala.reflect.internal;Types.matchingParams.syms2isJava">syms2isJava</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types.matchingParams.syms1" title="List[Types.this.Symbol]">syms1</a> match <span class="delimiter">{</span>
    case <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> =&gt;
      <a href="#scala.reflect.internal;Types.matchingParams.syms2" title="List[Types.this.Symbol]">syms2</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a>
    case <a title="Types.this.Symbol" id="scala.reflect.internal;Types.matchingParams.sym1">sym1</a> :: <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.matchingParams.rest1">rest1</a> =&gt;
      <a href="#scala.reflect.internal;Types.matchingParams.syms2" title="List[Types.this.Symbol]">syms2</a> match <span class="delimiter">{</span>
        case <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> =&gt;
          false
        case <a title="Types.this.Symbol" id="scala.reflect.internal;Types.matchingParams.sym2">sym2</a> :: <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.matchingParams.rest2">rest2</a> =&gt;
          val <a title="Types.this.Type" id="scala.reflect.internal;Types.matchingParams.tp1">tp1</a> = <a href="#scala.reflect.internal;Types.matchingParams.sym1" title="Types.this.Symbol">sym1</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; Types.this.Type">tpe</a>
          val <a title="Types.this.Type" id="scala.reflect.internal;Types.matchingParams.tp2">tp2</a> = <a href="#scala.reflect.internal;Types.matchingParams.sym2" title="Types.this.Symbol">sym2</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; Types.this.Type">tpe</a>
          <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchingParams.tp1" title="Types.this.Type">tp1</a> <a href="#scala.reflect.internal;Types;Type.=:=" title="(that: Types.this.Type)Boolean">=:=</a> <a href="#scala.reflect.internal;Types.matchingParams.tp2" title="Types.this.Type">tp2</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a>
           <a href="#scala.reflect.internal;Types.matchingParams.syms1isJava" title="Boolean">syms1isJava</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.matchingParams.tp2" title="Types.this.Type">tp2</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: Any)Boolean">==</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ObjectClass" title="=&gt; Types.this.ClassSymbol">ObjectClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.matchingParams.tp1" title="Types.this.Type">tp1</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: Any)Boolean">==</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyClass" title="=&gt; Types.this.ClassSymbol">AnyClass</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a>
           <a href="#scala.reflect.internal;Types.matchingParams.syms2isJava" title="Boolean">syms2isJava</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.matchingParams.tp1" title="Types.this.Type">tp1</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: Any)Boolean">==</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ObjectClass" title="=&gt; Types.this.ClassSymbol">ObjectClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.matchingParams.tp2" title="Types.this.Type">tp2</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: Any)Boolean">==</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyClass" title="=&gt; Types.this.ClassSymbol">AnyClass</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
          <a href="#scala.reflect.internal;Types.matchingParams" title="(syms1: List[Types.this.Symbol], syms2: List[Types.this.Symbol], syms1isJava: Boolean, syms2isJava: Boolean)Boolean">matchingParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.matchingParams.rest1" title="List[Types.this.Symbol]">rest1</a>, <a href="#scala.reflect.internal;Types.matchingParams.rest2" title="List[Types.this.Symbol]">rest2</a>, <a href="#scala.reflect.internal;Types.matchingParams.syms1isJava" title="Boolean">syms1isJava</a>, <a href="#scala.reflect.internal;Types.matchingParams.syms2isJava" title="Boolean">syms2isJava</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Do type arguments `targs` conform to formal parameters `tparams`?
   */</span>
  def <a title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])Boolean" id="scala.reflect.internal;Types.isWithinBounds">isWithinBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isWithinBounds.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.isWithinBounds.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.isWithinBounds.tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.isWithinBounds.targs">targs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    var <a title="List[Types.this.TypeBounds]" id="scala.reflect.internal;Types.isWithinBounds.bounds">bounds</a> = <a href="#scala.reflect.internal;Types.instantiatedBounds" title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]">instantiatedBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isWithinBounds.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.isWithinBounds.owner" title="Types.this.Symbol">owner</a>, <a href="#scala.reflect.internal;Types.isWithinBounds.tparams" title="List[Types.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal;Types.isWithinBounds.targs" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isWithinBounds.targs" title="List[Types.this.Type]">targs</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types.typeHasAnnotations" title="=&gt; Types.this.Type =&gt; Boolean">typeHasAnnotations</a><span class="delimiter">)</span>
      <a href="#scala.reflect.internal;Types.isWithinBounds.bounds" title="List[Types.this.TypeBounds]">bounds</a> = <a href="AnnotationCheckers.scala.html#scala.reflect.internal;AnnotationCheckers.adaptBoundsToAnnotations" title="(bounds: List[Types.this.TypeBounds], tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]">adaptBoundsToAnnotations</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isWithinBounds.bounds" title="List[Types.this.TypeBounds]">bounds</a>, <a href="#scala.reflect.internal;Types.isWithinBounds.tparams" title="List[Types.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal;Types.isWithinBounds.targs" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>
    <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isWithinBounds.bounds" title="List[Types.this.TypeBounds]">bounds</a> <a href="../../collection/LinearSeqLike.scala.html#scala.collection;LinearSeqLike.corresponds" title="(that: scala.collection.GenSeq[Types.this.Type])(p: (Types.this.TypeBounds, Types.this.Type) =&gt; Boolean)Boolean">corresponds</a> <a href="#scala.reflect.internal;Types.isWithinBounds.targs" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.boundsContainType" title="=&gt; (Types.this.TypeBounds, Types.this.Type) =&gt; Boolean">boundsContainType</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(pre: Types.this.Type, owner: Types.this.Symbol, tparams: List[Types.this.Symbol], targs: List[Types.this.Type])List[Types.this.TypeBounds]" id="scala.reflect.internal;Types.instantiatedBounds">instantiatedBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.instantiatedBounds.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.instantiatedBounds.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.instantiatedBounds.tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.instantiatedBounds.targs">targs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.TypeBounds]">List</a><span class="delimiter">[</span>TypeBounds<span class="delimiter">]</span> =
    <a href="util/Collections.scala.html#scala.reflect.internal.util;Collections.mapList" title="(as: List[Types.this.Symbol])(f: Types.this.Symbol =&gt; Types.this.TypeBounds)List[Types.this.TypeBounds]">mapList</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.instantiatedBounds.tparams" title="List[Types.this.Symbol]">tparams</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.instantiatedBounds.$anonfun.x$63" title="Types.this.Symbol">_</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.asSeenFrom" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.instantiatedBounds.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.instantiatedBounds.owner" title="Types.this.Symbol">owner</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.instantiateTypeParams" title="(formals: List[Types.this.Symbol], actuals: List[Types.this.Type])Types.this.Type">instantiateTypeParams</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.instantiatedBounds.tparams" title="List[Types.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal;Types.instantiatedBounds.targs" title="List[Types.this.Type]">targs</a><span class="delimiter">)</span>.<a href="#scala.reflect.internal;Types;Type.bounds" title="=&gt; Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>

  def <a title="(t: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.elimAnonymousClass">elimAnonymousClass</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.elimAnonymousClass.t">t</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.elimAnonymousClass.t" title="Types.this.Type">t</a> match <span class="delimiter">{</span>
    case TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.elimAnonymousClass.pre">pre</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.elimAnonymousClass.clazz">clazz</a>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> if <a href="#scala.reflect.internal;Types.elimAnonymousClass.clazz" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAnonymousClass" title="=&gt; Boolean">isAnonymousClass</a> =&gt;
      <a href="#scala.reflect.internal;Types.elimAnonymousClass.clazz" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.classBound" title="=&gt; Types.this.Type">classBound</a>.<a href="#scala.reflect.internal;Types;Type.asSeenFrom" title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type">asSeenFrom</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.elimAnonymousClass.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.internal;Types.elimAnonymousClass.clazz" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; Types.this.Symbol">owner</a><span class="delimiter">)</span>
    case _ =&gt;
      <a href="#scala.reflect.internal;Types.elimAnonymousClass.t" title="Types.this.Type">t</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A list of the typevars in a type. */</span>
  def <a title="(tp: Types.this.Type)List[Types.this.TypeVar]" id="scala.reflect.internal;Types.typeVarsInType">typeVarsInType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.typeVarsInType.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.TypeVar]">List</a><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <span class="delimiter">{</span>
    var <a title="List[Types.this.TypeVar]" id="scala.reflect.internal;Types.typeVarsInType.tvs">tvs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.TypeVar]">List</a><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span> = <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
    <a href="#scala.reflect.internal;Types.typeVarsInType.tp" title="Types.this.Type">tp</a> <a href="#scala.reflect.internal;Types;Type.foreach" title="(f: Types.this.Type =&gt; Unit)Unit">foreach</a> <a href="#scala.reflect.internal;Types.typeVarsInType.$anonfun.x0$4" title="Unit" class="delimiter">{</a>
      case <a title="Types.this.TypeVar" id="scala.reflect.internal;Types.typeVarsInType.$anonfun.t">t</a>: <a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a> =&gt; <a href="#scala.reflect.internal;Types.typeVarsInType.tvs" title="List[Types.this.TypeVar]">tvs</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.TypeVar)List[Types.this.TypeVar]">::=</a> <a href="#scala.reflect.internal;Types.typeVarsInType.$anonfun.t" title="Types.this.TypeVar">t</a>
      case _          =&gt;
    <span class="delimiter">}</span>
    <a href="#scala.reflect.internal;Types.typeVarsInType.tvs" title="List[Types.this.TypeVar]">tvs</a>.<a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.reverse" title="=&gt; List[Types.this.TypeVar]">reverse</a>
  <span class="delimiter">}</span>

  <span class="comment">// If this type contains type variables, put them to sleep for a while.</span>
  <span class="comment">// Don't just wipe them out by replacing them by the corresponding type</span>
  <span class="comment">// parameter, as that messes up (e.g.) type variables in type refinements.</span>
  <span class="comment">// Without this, the matchesType call would lead to type variables on both</span>
  <span class="comment">// sides of a subtyping/equality judgement, which can lead to recursive types</span>
  <span class="comment">// being constructed. See pos/t0851 for a situation where this happens.</span>
  @inline final def <a title="[T](tvs: List[Types.this.TypeVar])(op: =&gt; T)T" id="scala.reflect.internal;Types.suspendingTypeVars">suspendingTypeVars</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal;Types.suspendingTypeVars;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[Types.this.TypeVar]" id="scala.reflect.internal;Types.suspendingTypeVars.tvs">tvs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.TypeVar]">List</a><span class="delimiter">[</span>TypeVar<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; T" id="scala.reflect.internal;Types.suspendingTypeVars.op">op</a>: =&gt; T<span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types.suspendingTypeVars;T" title="T">T</a> = <span class="delimiter">{</span>
    val saved = <a href="#scala.reflect.internal;Types.suspendingTypeVars.tvs" title="List[Types.this.TypeVar]">tvs</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="List[Boolean]" id="scala.reflect.internal;Types.suspendingTypeVars.saved">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.suspendingTypeVars.saved.$anonfun.x$64" title="Types.this.TypeVar">_</a>.<a href="#scala.reflect.internal;Types;TypeVar.suspended" title="=&gt; Boolean">suspended</a><span class="delimiter">)</span>
    <a href="#scala.reflect.internal;Types.suspendingTypeVars.tvs" title="List[Types.this.TypeVar]">tvs</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: Types.this.TypeVar =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.suspendingTypeVars.$anonfun.x$65" title="Types.this.TypeVar">_</a>.<a href="#scala.reflect.internal;Types;TypeVar.suspended_=" title="(b: Boolean)Unit">suspended</a> = true<span class="delimiter">)</span>

    try <a href="#scala.reflect.internal;Types.suspendingTypeVars.op" title="=&gt; T">op</a>
    finally <a href="util/Collections.scala.html#scala.reflect.internal.util;Collections.foreach2" title="(xs1: List[Types.this.TypeVar], xs2: List[Boolean])(f: (Types.this.TypeVar, Boolean) =&gt; Unit)Unit">foreach2</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.suspendingTypeVars.tvs" title="List[Types.this.TypeVar]">tvs</a>, <a href="#scala.reflect.internal;Types.suspendingTypeVars.saved" title="List[Boolean]">saved</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.suspendingTypeVars.$anonfun.x$66" title="Types.this.TypeVar">_</a>.<a href="#scala.reflect.internal;Types;TypeVar.suspended_=" title="(b: Boolean)Unit">suspended</a> = <a href="#scala.reflect.internal;Types.suspendingTypeVars.$anonfun.x$67" title="Boolean">_</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Compute lub (if `variance == Covariant`) or glb (if `variance == Contravariant`) of given list
   *  of types `tps`. All types in `tps` are typerefs or singletypes
   *  with the same symbol.
   *  Return `x` if the computation succeeds with result `x`.
   *  Return `NoType` if the computation fails.
   */</span>
  def <a title="(tps: List[Types.this.Type], variance: scala.reflect.internal.Variance, depth: scala.reflect.internal.Depth)Types.this.Type" id="scala.reflect.internal;Types.mergePrefixAndArgs">mergePrefixAndArgs</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.mergePrefixAndArgs.tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="scala.reflect.internal.Variance" id="scala.reflect.internal;Types.mergePrefixAndArgs.variance">variance</a>: <a href="Variance.scala.html#scala.reflect.internal;Variance" title="scala.reflect.internal.Variance">Variance</a>, <a title="scala.reflect.internal.Depth" id="scala.reflect.internal;Types.mergePrefixAndArgs.depth">depth</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.tps" title="List[Types.this.Type]">tps</a> match <span class="delimiter">{</span>
    case <a title="Types.this.Type" id="scala.reflect.internal;Types.mergePrefixAndArgs.tp">tp</a> :: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> =&gt; <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.tp" title="Types.this.Type">tp</a>
    case TypeRef<span class="delimiter">(</span>_, <span title="Types.this.Symbol">sym</span>, _<span class="delimiter">)</span> :: <span title="List[Types.this.Type]">rest</span> =&gt;
      val pres = <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.tps" title="List[Types.this.Type]">tps</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.pres.$anonfun.x$68" title="Types.this.Type">_</a>.<a href="#scala.reflect.internal;Types;Type.prefix" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span> <span class="comment">// prefix normalizes automatically</span>
      val <span title="Types.this.Type">pre</span> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.variance" title="scala.reflect.internal.Variance">variance</a>.<a href="Variance.scala.html#scala.reflect.internal;Variance.isPositive" title="=&gt; Boolean">isPositive</a><span class="delimiter">)</span> <a href="tpe/GlbLubs.scala.html#scala.reflect.internal.tpe;GlbLubs.lub(f19b6da1b5)" title="(ts: List[Types.this.Type], depth: scala.reflect.internal.Depth)Types.this.Type">lub</a><span class="delimiter">(</span><span title="List[Types.this.Type]">pres</span>, <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span> else <a href="tpe/GlbLubs.scala.html#scala.reflect.internal.tpe;GlbLubs.glb(f19b6da1b5)" title="(ts: List[Types.this.Type], depth: scala.reflect.internal.Depth)Types.this.Type">glb</a><span class="delimiter">(</span><span title="List[Types.this.Type]">pres</span>, <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span>
      val argss = <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.tps" title="List[Types.this.Type]">tps</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="List[List[Types.this.Type]]" id="scala.reflect.internal;Types.mergePrefixAndArgs.argss">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.argss.$anonfun.x$69" title="Types.this.Type">_</a>.<a href="#scala.reflect.internal;Types;Type.normalize" title="=&gt; Types.this.Type">normalize</a>.<a href="#scala.reflect.internal;Types;Type.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a><span class="delimiter">)</span> <span class="comment">// symbol equality (of the tp in tps) was checked using typeSymbol, which normalizes, so should normalize before retrieving arguments</span>
      val <a title="scala.collection.mutable.ListBuffer[Types.this.Symbol]" id="scala.reflect.internal;Types.mergePrefixAndArgs.capturedParams">capturedParams</a> = new <a href="../../collection/mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer" title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">ListBuffer</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
      try <span class="delimiter">{</span>
        if <span class="delimiter">(</span><span title="Types.this.Symbol">sym</span> <span title="(x$1: Any)Boolean">==</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ArrayClass" title="=&gt; Types.this.ClassSymbol">ArrayClass</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="comment">// special treatment for lubs of array types after erasure:</span>
          <span class="comment">// if argss contain one value type and some other type, the lub is Object</span>
          <span class="comment">// if argss contain several reference types, the lub is an array over lub of argtypes</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.argss" title="List[List[Types.this.Type]]">argss</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: List[Types.this.Type] =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types.typeListIsEmpty" title="=&gt; List[Types.this.Type] =&gt; Boolean">typeListIsEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>  <span class="comment">// something is wrong: an array without a type arg.</span>
          <span class="delimiter">}</span>
          else <span class="delimiter">{</span>
            val args = <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.argss" title="List[List[Types.this.Type]]">argss</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.x$70" title="List[Types.this.Type]">_</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Type">head</a><span class="delimiter">)</span>
            if <span class="delimiter">(</span><span title="List[Types.this.Type]">args</span>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tail" title="=&gt; List[Types.this.Type]">tail</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: Types.this.Type =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.$anonfun.x$71" title="Types.this.Type">_</a> <a href="#scala.reflect.internal;Types;Type.=:=" title="(that: Types.this.Type)Boolean">=:=</a> <span title="List[Types.this.Type]">args</span>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Type">head</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.typeRef" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><span title="Types.this.Type">pre</span>, <span title="Types.this.Symbol">sym</span>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.List.apply" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><span title="List[Types.this.Type]">args</span>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Type">head</a><span class="delimiter">)</span><span class="delimiter">)</span>
            else if <span class="delimiter">(</span><span title="List[Types.this.Type]">args</span> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.mergePrefixAndArgs.$anonfun.arg">arg</a> =&gt; <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isPrimitiveValueClass" title="(sym: Types.this.Symbol)Boolean">isPrimitiveValueClass</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.$anonfun.arg" title="Types.this.Type">arg</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ObjectTpe" title="=&gt; Types.this.Type">ObjectTpe</a>
            else <a href="#scala.reflect.internal;Types.typeRef" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><span title="Types.this.Type">pre</span>, <span title="Types.this.Symbol">sym</span>, <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.List.apply" title="(xs: Types.this.Type*)List[Types.this.Type]">List</a><span class="delimiter">(</span><a href="tpe/GlbLubs.scala.html#scala.reflect.internal.tpe;GlbLubs.lub(d5711a700e)" title="(ts: List[Types.this.Type])Types.this.Type">lub</a><span class="delimiter">(</span><span title="List[Types.this.Type]">args</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        else <a href="util/Collections.scala.html#scala.reflect.internal.util;Collections.transposeSafe" title="(ass: List[List[Types.this.Type]])Option[List[List[Types.this.Type]]]">transposeSafe</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.argss" title="List[List[Types.this.Type]]">argss</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case <a href="../../Option.scala.html#scala.None" title="None.type">None</a> =&gt;
            <span class="comment">// transpose freaked out because of irregular argss</span>
            <span class="comment">// catching just in case (shouldn't happen, but also doesn't cost us)</span>
            <span class="comment">// [JZ] It happens: see SI-5683.</span>
            <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.debuglog" title="(msg: =&gt; String)Unit">debuglog</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;transposed irregular matrix!? tps=&quot;)">transposed irregular matrix!? tps=$</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.tps" title="List[Types.this.Type]">tps</a><span title="String(&quot; argss=&quot;)"> argss=$</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.argss" title="List[List[Types.this.Type]]">argss</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
            <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
          case Some<span class="delimiter">(</span><a title="List[List[Types.this.Type]]" id="scala.reflect.internal;Types.mergePrefixAndArgs.argsst">argsst</a><span class="delimiter">)</span> =&gt;
            val <span title="List[Types.this.Type]">args</span> = <a href="util/Collections.scala.html#scala.reflect.internal.util;Collections.map2" title="(xs1: List[Types.this.Symbol], xs2: List[List[Types.this.Type]])(f: (Types.this.Symbol, List[Types.this.Type]) =&gt; Types.this.Type)List[Types.this.Type]">map2</a><span class="delimiter">(</span><span title="Types.this.Symbol">sym</span>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.typeParams" title="=&gt; List[Types.this.Symbol]">typeParams</a>, <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.argsst" title="List[List[Types.this.Type]]">argsst</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.tparam">tparam</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.as0">as0</a><span class="delimiter">)</span> =&gt;
              val <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.as">as</a> = <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.as0" title="List[Types.this.Type]">as0</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.distinct" title="=&gt; List[Types.this.Type]">distinct</a>
              if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.as" title="List[Types.this.Type]">as</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.size" title="=&gt; Int">size</a> <a href="../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.as" title="List[Types.this.Type]">as</a>.<a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; Types.this.Type">head</a>
              else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.depth" title="scala.reflect.internal.Depth">depth</a>.<a href="Depth.scala.html#scala.reflect.internal;Depth.isZero" title="=&gt; Boolean">isZero</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                <a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.log" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><a href="../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Giving up merging args: can't unify %s under %s&quot;</a>.<a href="../../collection/immutable/StringLike.scala.html#scala.collection.immutable;StringLike.format" title="(args: Any*)String">format</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.as" title="List[Types.this.Type]">as</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span>, <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.tparam" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.fullLocationString" title="=&gt; String">fullLocationString</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="comment">// Don't return &quot;Any&quot; (or &quot;Nothing&quot;) when we have to give up due to</span>
                <span class="comment">// recursion depth. Return NoType, which prevents us from poisoning</span>
                <span class="comment">// lublist's results. It can recognize the recursion and deal with it, but</span>
                <span class="comment">// only if we aren't returning invalid types.</span>
                <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
              <span class="delimiter">}</span>
              else <span class="delimiter">{</span>
                if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.tparam" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.variance" title="=&gt; scala.reflect.internal.Variance">variance</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.variance" title="scala.reflect.internal.Variance">variance</a><span class="delimiter">)</span> <a href="tpe/GlbLubs.scala.html#scala.reflect.internal.tpe;GlbLubs.lub(f19b6da1b5)" title="(ts: List[Types.this.Type], depth: scala.reflect.internal.Depth)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.as" title="List[Types.this.Type]">as</a>, <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.depth" title="scala.reflect.internal.Depth">depth</a>.<a href="Depth.scala.html#scala.reflect.internal;Depth.decr(a73a950bc7)" title="=&gt; scala.reflect.internal.Depth">decr</a><span class="delimiter">)</span>
                else if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.tparam" title="Types.this.Symbol">tparam</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.variance" title="=&gt; scala.reflect.internal.Variance">variance</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.variance" title="scala.reflect.internal.Variance">variance</a>.<a href="Variance.scala.html#scala.reflect.internal;Variance.flip" title="=&gt; scala.reflect.internal.Variance">flip</a><span class="delimiter">)</span> <a href="tpe/GlbLubs.scala.html#scala.reflect.internal.tpe;GlbLubs.glb(f19b6da1b5)" title="(ts: List[Types.this.Type], depth: scala.reflect.internal.Depth)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.as" title="List[Types.this.Type]">as</a>, <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.depth" title="scala.reflect.internal.Depth">depth</a>.<a href="Depth.scala.html#scala.reflect.internal;Depth.decr(a73a950bc7)" title="=&gt; scala.reflect.internal.Depth">decr</a><span class="delimiter">)</span>
                else <span class="delimiter">{</span>
                  val <a title="Types.this.Type" id="scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.l">l</a> = <a href="tpe/GlbLubs.scala.html#scala.reflect.internal.tpe;GlbLubs.lub(f19b6da1b5)" title="(ts: List[Types.this.Type], depth: scala.reflect.internal.Depth)Types.this.Type">lub</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.as" title="List[Types.this.Type]">as</a>, <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.depth" title="scala.reflect.internal.Depth">depth</a>.<a href="Depth.scala.html#scala.reflect.internal;Depth.decr(a73a950bc7)" title="=&gt; scala.reflect.internal.Depth">decr</a><span class="delimiter">)</span>
                  val <a title="Types.this.Type" id="scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.g">g</a> = <a href="tpe/GlbLubs.scala.html#scala.reflect.internal.tpe;GlbLubs.glb(f19b6da1b5)" title="(ts: List[Types.this.Type], depth: scala.reflect.internal.Depth)Types.this.Type">glb</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.as" title="List[Types.this.Type]">as</a>, <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.depth" title="scala.reflect.internal.Depth">depth</a>.<a href="Depth.scala.html#scala.reflect.internal;Depth.decr(a73a950bc7)" title="=&gt; scala.reflect.internal.Depth">decr</a><span class="delimiter">)</span>
                  if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.l" title="Types.this.Type">l</a> <a href="#scala.reflect.internal;Types;Type.<:<" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.g" title="Types.this.Type">g</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.l" title="Types.this.Type">l</a>
                  else <span class="delimiter">{</span> <span class="comment">// Martin: I removed this, because incomplete. Not sure there is a good way to fix it. For the moment we</span>
                       <span class="comment">// just err on the conservative side, i.e. with a bound that is too high.</span>
                       <span class="comment">// if(!(tparam.info.bounds contains tparam))   //@M can't deal with f-bounds, see #2251</span>

                    val qvar = <a href="tpe/CommonOwners.scala.html#scala.reflect.internal.tpe;CommonOwners.commonOwner(91644a9783)" title="(tps: List[Types.this.Type])Types.this.Symbol">commonOwner</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.as" title="List[Types.this.Type]">as</a><span class="delimiter">)</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.freshExistential" title="(suffix: String)Types.this.TypeSymbol">freshExistential</a> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="Types.this.TypeSymbol" id="scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.qvar">setInfo</a> <a href="#scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3)" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.g" title="Types.this.Type">g</a>, <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.l" title="Types.this.Type">l</a><span class="delimiter">)</span>
                    <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.capturedParams" title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">capturedParams</a> <a href="../../collection/mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.+=(f93df146a4)" title="(x: Types.this.Symbol)capturedParams.type">+=</a> <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.qvar" title="Types.this.TypeSymbol">qvar</a>
                    <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.args.$anonfun.qvar" title="Types.this.TypeSymbol">qvar</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; Types.this.Type">tpe</a>
                  <span class="delimiter">}</span>
                <span class="delimiter">}</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            if <span class="delimiter">(</span><span title="List[Types.this.Type]">args</span> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: Types.this.Type)Boolean">contains</a> <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
            else <a href="#scala.reflect.internal;Types.existentialAbstraction" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.capturedParams" title="scala.collection.mutable.ListBuffer[Types.this.Symbol]">capturedParams</a>.<a href="../../collection/mutable/ListBuffer.scala.html#scala.collection.mutable;ListBuffer.toList" title="=&gt; List[Types.this.Symbol]">toList</a>, <a href="#scala.reflect.internal;Types.typeRef" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><span title="Types.this.Type">pre</span>, <span title="Types.this.Symbol">sym</span>, <span title="List[Types.this.Type]">args</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> catch <span class="delimiter">{</span>
        case <span title="Types.this.MalformedType">ex</span>: <a href="#scala.reflect.internal;Types;MalformedType" title="Types.this.MalformedType">MalformedType</a> =&gt; <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
      <span class="delimiter">}</span>
    case SingleType<span class="delimiter">(</span>_, <span title="Types.this.Symbol">sym</span><span class="delimiter">)</span> :: <span title="List[Types.this.Type]">rest</span> =&gt;
      val pres = <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.tps" title="List[Types.this.Type]">tps</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="List[Types.this.Type]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.pres.$anonfun.x$72" title="Types.this.Type">_</a>.<a href="#scala.reflect.internal;Types;Type.prefix" title="=&gt; Types.this.Type">prefix</a><span class="delimiter">)</span>
      val <span title="Types.this.Type">pre</span> = if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.variance" title="scala.reflect.internal.Variance">variance</a>.<a href="Variance.scala.html#scala.reflect.internal;Variance.isPositive" title="=&gt; Boolean">isPositive</a><span class="delimiter">)</span> <a href="tpe/GlbLubs.scala.html#scala.reflect.internal.tpe;GlbLubs.lub(f19b6da1b5)" title="(ts: List[Types.this.Type], depth: scala.reflect.internal.Depth)Types.this.Type">lub</a><span class="delimiter">(</span><span title="List[Types.this.Type]">pres</span>, <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span> else <a href="tpe/GlbLubs.scala.html#scala.reflect.internal.tpe;GlbLubs.glb(f19b6da1b5)" title="(ts: List[Types.this.Type], depth: scala.reflect.internal.Depth)Types.this.Type">glb</a><span class="delimiter">(</span><span title="List[Types.this.Type]">pres</span>, <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span>
      try <a href="#scala.reflect.internal;Types.singleType" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><span title="Types.this.Type">pre</span>, <span title="Types.this.Symbol">sym</span><span class="delimiter">)</span>
      catch <span class="delimiter">{</span> case <span title="Types.this.MalformedType">ex</span>: <a href="#scala.reflect.internal;Types;MalformedType" title="Types.this.MalformedType">MalformedType</a> =&gt; <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a> <span class="delimiter">}</span>
    case ExistentialType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.mergePrefixAndArgs.tparams">tparams</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.mergePrefixAndArgs.quantified">quantified</a><span class="delimiter">)</span> :: <span title="List[Types.this.Type]">rest</span> =&gt;
      <a href="#scala.reflect.internal;Types.mergePrefixAndArgs" title="(tps: List[Types.this.Type], variance: scala.reflect.internal.Variance, depth: scala.reflect.internal.Depth)Types.this.Type">mergePrefixAndArgs</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.quantified" title="Types.this.Type">quantified</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Types.this.Type)List[Types.this.Type]">::</a> <span title="List[Types.this.Type]">rest</span>, <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.variance" title="scala.reflect.internal.Variance">variance</a>, <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
        case <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a> =&gt; <a href="#scala.reflect.internal;Types.NoType.readResolve" title="Types.this.NoType.type">NoType</a>
        case <a title="Types.this.Type" id="scala.reflect.internal;Types.mergePrefixAndArgs.tpe">tpe</a>    =&gt; <a href="#scala.reflect.internal;Types.existentialAbstraction" title="(tparams: List[Types.this.Symbol], tpe0: Types.this.Type)Types.this.Type">existentialAbstraction</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.tparams" title="List[Types.this.Symbol]">tparams</a>, <a href="#scala.reflect.internal;Types.mergePrefixAndArgs.tpe" title="Types.this.Type">tpe</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    case _ =&gt;
      <a href="Reporting.scala.html#scala.reflect.internal;Reporting.abort" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;mergePrefixAndArgs(&quot;)">mergePrefixAndArgs($</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.tps" title="List[Types.this.Type]">tps</a><span title="String(&quot;, &quot;)">, $</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.variance" title="scala.reflect.internal.Variance">variance</a><span title="String(&quot;, &quot;)">, $</span><a href="#scala.reflect.internal;Types.mergePrefixAndArgs.depth" title="scala.reflect.internal.Depth">depth</a><span title="String(&quot;): unsupported tps&quot;)" class="string">): unsupported tps&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol)Unit" id="scala.reflect.internal;Types.addMember(8add381462)">addMember</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.addMember(8add381462).thistp">thistp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.addMember(8add381462).tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.addMember(8add381462).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <a href="#scala.reflect.internal;Types.addMember(22d215d0ce)" title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol, depth: scala.reflect.internal.Depth)Unit">addMember</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.addMember(8add381462).thistp" title="Types.this.Type">thistp</a>, <a href="#scala.reflect.internal;Types.addMember(8add381462).tp" title="Types.this.Type">tp</a>, <a href="#scala.reflect.internal;Types.addMember(8add381462).sym" title="Types.this.Symbol">sym</a>, <a href="Depth.scala.html#scala.reflect.internal.Depth.AnyDepth" title="=&gt; scala.reflect.internal.Depth">AnyDepth</a><span class="delimiter">)</span>

  <span class="comment">/** Make symbol `sym` a member of scope `tp.decls`
   *  where `thistp` is the narrowed owner type of the scope.
   */</span>
  def <a title="(thistp: Types.this.Type, tp: Types.this.Type, sym: Types.this.Symbol, depth: scala.reflect.internal.Depth)Unit" id="scala.reflect.internal;Types.addMember(22d215d0ce)">addMember</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.addMember(22d215d0ce).thistp">thistp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.addMember(22d215d0ce).tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.addMember(22d215d0ce).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="scala.reflect.internal.Depth" id="scala.reflect.internal;Types.addMember(22d215d0ce).depth">depth</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../../Predef.scala.html#scala.Predef.assert(65d7b4917f)" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.addMember(22d215d0ce).sym" title="Types.this.Symbol">sym</a> <span title="(x$1: Any)Boolean">!=</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>
    <span class="comment">// debuglog(&quot;add member &quot; + sym+&quot;:&quot;+sym.info+&quot; to &quot;+thistp) //DEBUG</span>
    if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.reflect.internal;Types.specializesSym(a94a1d1410)" title="(tp: Types.this.Type, sym: Types.this.Symbol, depth: scala.reflect.internal.Depth)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.addMember(22d215d0ce).thistp" title="Types.this.Type">thistp</a>, <a href="#scala.reflect.internal;Types.addMember(22d215d0ce).sym" title="Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types.addMember(22d215d0ce).depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.addMember(22d215d0ce).sym" title="Types.this.Symbol">sym</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isTerm" title="=&gt; Boolean">isTerm</a><span class="delimiter">)</span>
        for <span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.addMember(22d215d0ce).$anonfun.alt">alt</a> &lt;- <a href="#scala.reflect.internal;Types.addMember(22d215d0ce).tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.nonPrivateDecl" title="(name: Types.this.Name)Types.this.Symbol">nonPrivateDecl</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.addMember(22d215d0ce).sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym.NameType">name</a><span class="delimiter">)</span>.<a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: Types.this.Symbol =&gt; Unit)Unit">alternatives</a><span class="delimiter">)</span>
          if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.specializesSym(bf05deaf88)" title="(preLo: Types.this.Type, symLo: Types.this.Symbol, preHi: Types.this.Type, symHi: Types.this.Symbol, depth: scala.reflect.internal.Depth)Boolean">specializesSym</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.addMember(22d215d0ce).thistp" title="Types.this.Type">thistp</a>, <a href="#scala.reflect.internal;Types.addMember(22d215d0ce).sym" title="Types.this.Symbol">sym</a>, <a href="#scala.reflect.internal;Types.addMember(22d215d0ce).thistp" title="Types.this.Type">thistp</a>, <a href="#scala.reflect.internal;Types.addMember(22d215d0ce).$anonfun.alt" title="Types.this.Symbol">alt</a>, <a href="#scala.reflect.internal;Types.addMember(22d215d0ce).depth" title="scala.reflect.internal.Depth">depth</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#scala.reflect.internal;Types.addMember(22d215d0ce).tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.unlink(f75a85baae)" title="(sym: Types.this.Symbol)Unit">unlink</a> <a href="#scala.reflect.internal;Types.addMember(22d215d0ce).$anonfun.alt" title="Types.this.Symbol">alt</a>
      <a href="#scala.reflect.internal;Types.addMember(22d215d0ce).tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.decls" title="=&gt; Types.this.Scope">decls</a> <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.enter" title="(sym: Types.this.Symbol)Types.this.Symbol">enter</a> <a href="#scala.reflect.internal;Types.addMember(22d215d0ce).sym" title="Types.this.Symbol">sym</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(clazz: Types.this.Symbol)Boolean" id="scala.reflect.internal;Types.isJavaVarargsAncestor">isJavaVarargsAncestor</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.isJavaVarargsAncestor.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="delimiter">(</span>
       <a href="#scala.reflect.internal;Types.isJavaVarargsAncestor.clazz" title="Types.this.Symbol">clazz</a>.<a href="../api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isClass" title="=&gt; Boolean">isClass</a>
    <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.isJavaVarargsAncestor.clazz" title="Types.this.Symbol">clazz</a>.<a href="HasFlags.scala.html#scala.reflect.internal;HasFlags.isJavaDefined" title="=&gt; Boolean">isJavaDefined</a>
    <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isJavaVarargsAncestor.clazz" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.nonPrivateDecls" title="=&gt; List[Types.this.Symbol]">nonPrivateDecls</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isJavaVarArgsMethod" title="(m: Types.this.Symbol)Boolean">isJavaVarArgsMethod</a><span class="delimiter">)</span>
  <span class="delimiter">)</span>
  def <a title="(clazz: Types.this.Symbol)Boolean" id="scala.reflect.internal;Types.inheritsJavaVarArgsMethod">inheritsJavaVarArgsMethod</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.inheritsJavaVarArgsMethod.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =
    <a href="#scala.reflect.internal;Types.inheritsJavaVarArgsMethod.clazz" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.thisType" title="=&gt; Types.this.Type">thisType</a>.<a href="#scala.reflect.internal;Types;Type.baseClasses" title="=&gt; List[Types.this.Symbol]">baseClasses</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Types.this.Symbol =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types.isJavaVarargsAncestor" title="(clazz: Types.this.Symbol)Boolean">isJavaVarargsAncestor</a>

<span class="comment">// Errors and Diagnostics -----------------------------------------------------</span>

  <span class="comment">/** A throwable signalling a type error */</span>
  class <a title="class TypeError extends Throwable" id="scala.reflect.internal;Types;TypeError">TypeError</a><a href="#scala.reflect.internal;Types;TypeError" title="Types.this.TypeError" class="delimiter">(</a>var <a title="Types.this.Position" id="scala.reflect.internal;Types;TypeError.pos">pos</a>: <a href="util/Position.scala.html#scala.reflect.internal.util;Position" title="Types.this.Position">Position</a>, val <a title="String" id="scala.reflect.internal;Types;TypeError.msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span> extends <a href="../../package.scala.html#scala.package;Throwable" title="Throwable">Throwable</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;TypeError.msg" title="String">msg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def this<span class="delimiter">(</span><a title="String" id="scala.reflect.internal;Types;TypeError.<init>(9990e26be3).msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span> = this<span class="delimiter">(</span><a href="Positions.scala.html#scala.reflect.internal;Positions.NoPosition" title="=&gt; reflect.internal.util.NoPosition.type">NoPosition</a>, <a href="#scala.reflect.internal;Types;TypeError.<init>(9990e26be3).msg" title="String">msg</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// TODO: RecoverableCyclicReference should be separated from TypeError,</span>
  <span class="comment">// but that would be a big change. Left for further refactoring.</span>
  <span class="comment">/** An exception for cyclic references from which we can recover */</span>
  case class <a title="class RecoverableCyclicReference extends Types.this.TypeError with Product with Serializable" id="scala.reflect.internal;Types.RecoverableCyclicReference.readResolve">RecoverableCyclicReference</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Types.this.Symbol" id="scala.reflect.internal;Types;RecoverableCyclicReference.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>
    extends <a href="#scala.reflect.internal;Types;TypeError" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><span title="String(&quot;illegal cyclic reference involving &quot;)" class="string">&quot;illegal cyclic reference involving &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;RecoverableCyclicReference.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">debug</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.RecoverableCyclicReference.readResolve" title="()Unit">printStackTrace</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  class <a title="class NoCommonType extends Throwable with scala.util.control.ControlThrowable" id="scala.reflect.internal;Types;NoCommonType">NoCommonType</a><a href="#scala.reflect.internal;Types;NoCommonType" title="Types.this.NoCommonType" class="delimiter">(</a><a title="List[Types.this.Type]" id="scala.reflect.internal;Types;NoCommonType.tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="../../package.scala.html#scala.package;Throwable" title="Throwable">Throwable</a><span class="delimiter">(</span>
    <span title="String(&quot;lub/glb of incompatible types: &quot;)" class="string">&quot;lub/glb of incompatible types: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;NoCommonType.tps" title="List[Types.this.Type]">tps</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot; and &quot;)" class="string">&quot; and &quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> with <a href="../../util/control/ControlThrowable.scala.html#scala.util.control;ControlThrowable" title="scala.util.control.ControlThrowable">ControlThrowable</a>

  <span class="comment">/** A throwable signalling a malformed type */</span>
  class <a title="class MalformedType extends Types.this.TypeError" id="scala.reflect.internal;Types;MalformedType">MalformedType</a><a href="#scala.reflect.internal;Types;MalformedType" title="Types.this.MalformedType" class="delimiter">(</a><a title="String" id="scala.reflect.internal;Types;MalformedType.msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span> extends <a href="#scala.reflect.internal;Types;TypeError" title="Types.this.TypeError">TypeError</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types;MalformedType.msg" title="String">msg</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def this<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types;MalformedType.<init>(28f2481346).pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="String" id="scala.reflect.internal;Types;MalformedType.<init>(28f2481346).tp">tp</a>: <span title="String">String</span><span class="delimiter">)</span> = this<span class="delimiter">(</span><span title="String(&quot;malformed type: &quot;)" class="string">&quot;malformed type: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;MalformedType.<init>(28f2481346).pre" title="Types.this.Type">pre</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types;MalformedType.<init>(28f2481346).tp" title="String">tp</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The current indentation string for traces */</span>
  private var <a title="String" id="scala.reflect.internal;Types._indent_=">_indent</a>: <span title="String">String</span> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>
  protected def <a title="=&gt; String" id="scala.reflect.internal;Types.indent">indent</a> = <a href="#scala.reflect.internal;Types._indent_=" title="=&gt; String">_indent</a>
  protected def <a title="(value: String)Unit" id="scala.reflect.internal;Types.indent_=">indent_=</a><span class="delimiter">(</span><a title="String" id="scala.reflect.internal;Types.indent_=.value">value</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types._indent_=" title="(x$1: String)Unit">_indent</a> = <a href="#scala.reflect.internal;Types.indent_=.value" title="String">value</a>

  <span class="comment">/** Perform operation `p` on arguments `tp1`, `arg2` and print trace of computation. */</span>
  protected def <a title="[T](op: String, p: (Types.this.Type, T) =&gt; Boolean, tp1: Types.this.Type, arg2: T)Boolean" id="scala.reflect.internal;Types.explain">explain</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal;Types.explain;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="scala.reflect.internal;Types.explain.op">op</a>: <span title="String">String</span>, <a title="(Types.this.Type, T) =&gt; Boolean" id="scala.reflect.internal;Types.explain.p">p</a>: <span class="delimiter">(</span>Type, T<span class="delimiter">)</span> =&gt; Boolean, <a title="Types.this.Type" id="scala.reflect.internal;Types.explain.tp1">tp1</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="T" id="scala.reflect.internal;Types.explain.arg2">arg2</a>: <a href="#scala.reflect.internal;Types.explain;T" title="T">T</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
    <a href="Reporting.scala.html#scala.reflect.internal;Reporting.inform(7fc9e56e07)" title="(msg: String)Unit">inform</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.indent" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types.explain.tp1" title="Types.this.Type">tp1</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types.explain.op" title="String">op</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; &quot;)" class="string">&quot; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types.explain.arg2" title="T">arg2</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span> <span class="comment">/* + &quot;(&quot;+tp1.getClass+&quot;,&quot;+arg2.getClass+&quot;)&quot;*/</span><span class="delimiter">)</span>
    <a href="#scala.reflect.internal;Types.indent_=" title="(value: String)Unit">indent</a> = <a href="#scala.reflect.internal;Types.indent" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
    val <a title="Boolean" id="scala.reflect.internal;Types.explain.result">result</a> = <a href="../../Function2.scala.html#scala;Function2.apply" title="(v1: Types.this.Type, v2: T)Boolean">p</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.explain.tp1" title="Types.this.Type">tp1</a>, <a href="#scala.reflect.internal;Types.explain.arg2" title="T">arg2</a><span class="delimiter">)</span>
    <a href="#scala.reflect.internal;Types.indent_=" title="(value: String)Unit">indent</a> = <a href="../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">indent</a> <a href="../../collection/immutable/StringLike.scala.html#scala.collection.immutable;StringLike.stripSuffix" title="(suffix: String)String">stripSuffix</a> <span title="String(&quot;  &quot;)" class="string">&quot;  &quot;</span>
    <a href="Reporting.scala.html#scala.reflect.internal;Reporting.inform(7fc9e56e07)" title="(msg: String)Unit">inform</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.indent" title="=&gt; String">indent</a> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.internal;Types.explain.result" title="Boolean">result</a><span class="delimiter">)</span>
    <a href="#scala.reflect.internal;Types.explain.result" title="Boolean">result</a>
  <span class="delimiter">}</span>

  <span class="comment">/** If option `explaintypes` is set, print a subtype trace for `found &lt;:&lt; required`. */</span>
  def <a title="(found: Types.this.Type, required: Types.this.Type)Unit" id="scala.reflect.internal;Types.explainTypes(41e171a6c4)">explainTypes</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.explainTypes(41e171a6c4).found">found</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.explainTypes(41e171a6c4).required">required</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">explaintypes</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.withTypesExplained" title="(op: =&gt; Boolean)Boolean">withTypesExplained</a><span title="Unit" class="delimiter">(</span><a href="#scala.reflect.internal;Types.explainTypes(41e171a6c4).found" title="Types.this.Type">found</a> <a href="#scala.reflect.internal;Types;Type.<:<" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="#scala.reflect.internal;Types.explainTypes(41e171a6c4).required" title="Types.this.Type">required</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** If option `explaintypes` is set, print a subtype trace for `op(found, required)`. */</span>
  def <a title="(op: (Types.this.Type, Types.this.Type) =&gt; Any, found: Types.this.Type, required: Types.this.Type)Unit" id="scala.reflect.internal;Types.explainTypes(9f556ccaaa)">explainTypes</a><span class="delimiter">(</span><a title="(Types.this.Type, Types.this.Type) =&gt; Any" id="scala.reflect.internal;Types.explainTypes(9f556ccaaa).op">op</a>: <span class="delimiter">(</span>Type, Type<span class="delimiter">)</span> =&gt; Any, <a title="Types.this.Type" id="scala.reflect.internal;Types.explainTypes(9f556ccaaa).found">found</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.explainTypes(9f556ccaaa).required">required</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="Required.scala.html#scala.reflect.internal;Required.settings" title="=&gt; scala.reflect.internal.settings.MutableSettings">settings</a>.<a href="settings/MutableSettings.scala.html#scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean" title="implicit scala.reflect.internal.settings.MutableSettings.reflectSettingToBoolean : (s: scala.reflect.internal.settings.MutableSettings#BooleanSetting)Boolean">explaintypes</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.withTypesExplained" title="(op: =&gt; Any)Any">withTypesExplained</a><span title="Unit" class="delimiter">(</span><a href="../../Function2.scala.html#scala;Function2.apply" title="(v1: Types.this.Type, v2: Types.this.Type)Any">op</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.explainTypes(9f556ccaaa).found" title="Types.this.Type">found</a>, <a href="#scala.reflect.internal;Types.explainTypes(9f556ccaaa).required" title="Types.this.Type">required</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Execute `op` while printing a trace of the operations on types executed. */</span>
  def <a title="[A](op: =&gt; A)A" id="scala.reflect.internal;Types.withTypesExplained">withTypesExplained</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal;Types.withTypesExplained;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="scala.reflect.internal;Types.withTypesExplained.op">op</a>: =&gt; A<span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types.withTypesExplained;A" title="A">A</a> = <span class="delimiter">{</span>
    val <a title="Boolean" id="scala.reflect.internal;Types.withTypesExplained.s">s</a> = <a href="#scala.reflect.internal;Types.explainSwitch_=" title="=&gt; Boolean">explainSwitch</a>
    try <span class="delimiter">{</span> <a href="#scala.reflect.internal;Types.explainSwitch_=" title="(x$1: Boolean)Unit">explainSwitch</a> = true; <a href="#scala.reflect.internal;Types.withTypesExplained.op" title="=&gt; A">op</a> <span class="delimiter">}</span> finally <span class="delimiter">{</span> <a href="#scala.reflect.internal;Types.explainSwitch_=" title="(x$1: Boolean)Unit">explainSwitch</a> = <a href="#scala.reflect.internal;Types.withTypesExplained.s" title="Boolean">s</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isUnboundedGeneric">isUnboundedGeneric</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isUnboundedGeneric.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.isUnboundedGeneric.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case <a title="Types.this.TypeRef" id="scala.reflect.internal;Types.isUnboundedGeneric.t">t</a> @ TypeRef<span class="delimiter">(</span>_, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.isUnboundedGeneric.sym">sym</a>, _<span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.isUnboundedGeneric.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAbstractType" title="=&gt; Boolean">isAbstractType</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isUnboundedGeneric.t" title="Types.this.TypeRef">t</a> <a href="#scala.reflect.internal;Types;Type.<:<" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyRefTpe" title="=&gt; Types.this.Type">AnyRefTpe</a><span class="delimiter">)</span>
    case _                      =&gt; false
  <span class="delimiter">}</span>
  def <a title="(tp: Types.this.Type)Boolean" id="scala.reflect.internal;Types.isBoundedGeneric">isBoundedGeneric</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.isBoundedGeneric.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;Types.isBoundedGeneric.tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case TypeRef<span class="delimiter">(</span>_, <span title="Types.this.Symbol">sym</span>, _<span class="delimiter">)</span> if <span title="Types.this.Symbol">sym</span>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isAbstractType" title="=&gt; Boolean">isAbstractType</a> =&gt; <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.isBoundedGeneric.tp" title="Types.this.Type">tp</a> <a href="#scala.reflect.internal;Types;Type.<:<" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyRefTpe" title="=&gt; Types.this.Type">AnyRefTpe</a><span class="delimiter">)</span>
    case TypeRef<span class="delimiter">(</span>_, <span title="Types.this.Symbol">sym</span>, _<span class="delimiter">)</span>                       =&gt; <a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isPrimitiveValueClass" title="(sym: Types.this.Symbol)Boolean">isPrimitiveValueClass</a><span class="delimiter">(</span><span title="Types.this.Symbol">sym</span><span class="delimiter">)</span>
    case _                                        =&gt; false
  <span class="delimiter">}</span>
  <span class="comment">// Add serializable to a list of parents, unless one of them already is</span>
  def <a title="(ps: Types.this.Type*)List[Types.this.Type]" id="scala.reflect.internal;Types.addSerializable">addSerializable</a><span class="delimiter">(</span><a title="Types.this.Type*" id="scala.reflect.internal;Types.addSerializable.ps">ps</a>: <span title="Types.this.Type*">Type</span>*<span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <span class="delimiter">(</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.addSerializable.ps" title="Types.this.Type*">ps</a> <a href="../../collection/IterableLike.scala.html#scala.collection;IterableLike.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types.typeIsSubTypeOfSerializable" title="=&gt; Types.this.Type =&gt; Boolean">typeIsSubTypeOfSerializable</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.addSerializable.ps" title="Types.this.Type*">ps</a>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[Types.this.Type]">toList</a>
    else <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.addSerializable.ps" title="Types.this.Type*">ps</a> <a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.:+" title="(elem: Types.this.Type)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Types.this.Type],Types.this.Type,Seq[Types.this.Type]])Seq[Types.this.Type]">:+</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.SerializableTpe" title="=&gt; Types.this.Type">SerializableTpe</a><span class="delimiter">)</span>.<a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[Types.this.Type]">toList</a>
  <span class="delimiter">)</span>

  <span class="comment">/** Adds the @uncheckedBound annotation if the given `tp` has type arguments */</span>
  final def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.uncheckedBounds">uncheckedBounds</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.uncheckedBounds.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.uncheckedBounds.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeArgs" title="=&gt; List[Types.this.Type]">typeArgs</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.UncheckedBoundsClass" title="=&gt; Types.this.Symbol">UncheckedBoundsClass</a> <span title="(x$1: Any)Boolean">==</span> <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; Types.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;Types.uncheckedBounds.tp" title="Types.this.Type">tp</a> <span class="comment">// second condition for backwards compatibilty with older scala-reflect.jar</span>
    else <a href="#scala.reflect.internal;Types.uncheckedBounds.tp" title="Types.this.Type">tp</a>.<a href="AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos;Annotatable.withAnnotation" title="(annot: Types.this.AnnotationInfo)Types.this.Type">withAnnotation</a><span class="delimiter">(</span><a href="AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos.AnnotationInfo" title="Types.this.AnnotationInfo.type">AnnotationInfo</a> <a href="AnnotationInfos.scala.html#scala.reflect.internal;AnnotationInfos.AnnotationInfo.marker" title="(atp: Types.this.Type)Types.this.AnnotationInfo">marker</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.UncheckedBoundsClass" title="=&gt; Types.this.Symbol">UncheckedBoundsClass</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; Types.this.Type">tpe</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Members of the given class, other than those inherited
   *  from Any or AnyRef.
   */</span>
  def <a title="(clazz: Types.this.Symbol)Types.this.Scope" id="scala.reflect.internal;Types.nonTrivialMembers">nonTrivialMembers</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.internal;Types.nonTrivialMembers.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> = <a href="#scala.reflect.internal;Types.nonTrivialMembers.clazz" title="Types.this.Symbol">clazz</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>.<a href="#scala.reflect.internal;Types;Type.members" title="=&gt; Types.this.Scope">members</a> <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.filterNot" title="(p: Types.this.Symbol =&gt; Boolean)Types.this.Scope">filterNot</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isUniversalMember" title="(sym: Types.this.Symbol)Boolean">isUniversalMember</a>

  <span class="comment">/** Members which can be imported into other scopes.
   */</span>
  def <a title="(pre: Types.this.Type)Types.this.Scope" id="scala.reflect.internal;Types.importableMembers">importableMembers</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.importableMembers.pre">pre</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope" title="Types.this.Scope">Scope</a> = <a href="#scala.reflect.internal;Types.importableMembers.pre" title="Types.this.Type">pre</a>.<a href="#scala.reflect.internal;Types;Type.members" title="=&gt; Types.this.Scope">members</a> <a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.filter" title="(p: Types.this.Symbol =&gt; Boolean)Types.this.Scope">filter</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isImportable" title="(sym: Types.this.Symbol)Boolean">isImportable</a>

  def <a title="(tp: Types.this.Type)Types.this.Type" id="scala.reflect.internal;Types.objToAny">objToAny</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.objToAny.tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a> =
    if <span class="delimiter">(</span><a href="../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="SymbolTable.scala.html#scala.reflect.internal;SymbolTable.phase" title="=&gt; scala.reflect.internal.Phase">phase</a>.<a href="Phase.scala.html#scala.reflect.internal;Phase.erasedTypes" title="=&gt; Boolean">erasedTypes</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.objToAny.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a> <span title="(x$1: Any)Boolean">==</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ObjectClass" title="=&gt; Types.this.ClassSymbol">ObjectClass</a><span class="delimiter">)</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyTpe" title="=&gt; Types.this.Type">AnyTpe</a>
    else <a href="#scala.reflect.internal;Types.objToAny.tp" title="Types.this.Type">tp</a>

  val <a title="scala.collection.immutable.Set[String]" id="scala.reflect.internal;Types.shorthands">shorthands</a> = <a href="../../collection/generic/GenericCompanion.scala.html#scala.collection.generic;GenericCompanion.apply" title="(elems: String*)scala.collection.immutable.Set[String]">Set</a><span class="delimiter">(</span>
    <span title="String(&quot;scala.collection.immutable.List&quot;)" class="string">&quot;scala.collection.immutable.List&quot;</span>,
    <span title="String(&quot;scala.collection.immutable.Nil&quot;)" class="string">&quot;scala.collection.immutable.Nil&quot;</span>,
    <span title="String(&quot;scala.collection.Seq&quot;)" class="string">&quot;scala.collection.Seq&quot;</span>,
    <span title="String(&quot;scala.collection.Traversable&quot;)" class="string">&quot;scala.collection.Traversable&quot;</span>,
    <span title="String(&quot;scala.collection.Iterable&quot;)" class="string">&quot;scala.collection.Iterable&quot;</span>,
    <span title="String(&quot;scala.collection.mutable.StringBuilder&quot;)" class="string">&quot;scala.collection.mutable.StringBuilder&quot;</span>,
    <span title="String(&quot;scala.collection.IndexedSeq&quot;)" class="string">&quot;scala.collection.IndexedSeq&quot;</span>,
    <span title="String(&quot;scala.collection.Iterator&quot;)" class="string">&quot;scala.collection.Iterator&quot;</span><span class="delimiter">)</span>

<span class="comment">// ----- Hoisted closures and convenience methods, for compile time reductions -------</span>

  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types.isTypeVar">isTypeVar</a> = <span class="delimiter">(</span>tp: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.isTypeVar.$anonfun.tp" title="Types.this.Type">tp</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#scala.reflect.internal;Types;TypeVar.canEqual" title="Types.this.TypeVar">TypeVar</a><span class="delimiter">]</span>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types.typeContainsTypeVar">typeContainsTypeVar</a> = <span class="delimiter">(</span>tp: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.typeContainsTypeVar.$anonfun.tp" title="Types.this.Type">tp</a> <a href="#scala.reflect.internal;Types;Type.exists" title="(p: Types.this.Type =&gt; Boolean)Boolean">exists</a> <a href="#scala.reflect.internal;Types.isTypeVar" title="=&gt; Types.this.Type =&gt; Boolean">isTypeVar</a>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types.typeIsNonClassType">typeIsNonClassType</a> = <span class="delimiter">(</span>tp: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.typeIsNonClassType.$anonfun.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbolDirect" title="=&gt; Types.this.Symbol">typeSymbolDirect</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isNonClassType" title="=&gt; Boolean">isNonClassType</a>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types.typeIsExistentiallyBound">typeIsExistentiallyBound</a> = <span class="delimiter">(</span>tp: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.typeIsExistentiallyBound.$anonfun.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; Types.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isExistentiallyBound" title="=&gt; Boolean">isExistentiallyBound</a>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types.typeIsErroneous">typeIsErroneous</a> = <span class="delimiter">(</span>tp: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.typeIsErroneous.$anonfun.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.isErroneous" title="=&gt; Boolean">isErroneous</a>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="Types.this.Symbol =&gt; Boolean" id="scala.reflect.internal;Types.symTypeIsError">symTypeIsError</a> = <span class="delimiter">(</span>sym: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.symTypeIsError.$anonfun.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; Types.this.Type">tpe</a>.<a href="#scala.reflect.internal;Types;Type.isError" title="=&gt; Boolean">isError</a>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="Types.this.Tree =&gt; Types.this.Type" id="scala.reflect.internal;Types.treeTpe">treeTpe</a> = <span class="delimiter">(</span>t: <a href="Trees.scala.html#scala.reflect.internal;Trees;Tree" title="Types.this.Tree">Tree</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.treeTpe.$anonfun.t" title="Types.this.Tree">t</a>.<a href="Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; Types.this.Type">tpe</a>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="Types.this.Symbol =&gt; Types.this.Type" id="scala.reflect.internal;Types.symTpe">symTpe</a> = <span class="delimiter">(</span>sym: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.symTpe.$anonfun.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; Types.this.Type">tpe</a>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="Types.this.Symbol =&gt; Types.this.Type" id="scala.reflect.internal;Types.symInfo">symInfo</a> = <span class="delimiter">(</span>sym: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.symInfo.$anonfun.sym" title="Types.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; Types.this.Type">info</a>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types.typeHasAnnotations">typeHasAnnotations</a> = <span class="delimiter">(</span>tp: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.typeHasAnnotations.$anonfun.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.annotations" title="=&gt; List[Types.this.AnnotationInfo]">annotations</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="(Types.this.TypeBounds, Types.this.Type) =&gt; Boolean" id="scala.reflect.internal;Types.boundsContainType">boundsContainType</a> = <span class="delimiter">(</span>bounds: <a href="#scala.reflect.internal;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a>, tp: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.boundsContainType.$anonfun.bounds" title="Types.this.TypeBounds">bounds</a> <a href="#scala.reflect.internal;Types;TypeBounds.containsType" title="(that: Types.this.Type)Boolean">containsType</a> <a href="#scala.reflect.internal;Types.boundsContainType.$anonfun.tp" title="Types.this.Type">tp</a>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="List[Types.this.Type] =&gt; Boolean" id="scala.reflect.internal;Types.typeListIsEmpty">typeListIsEmpty</a> = <span class="delimiter">(</span>ts: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.typeListIsEmpty.$anonfun.ts" title="List[Types.this.Type]">ts</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types.typeIsSubTypeOfSerializable">typeIsSubTypeOfSerializable</a> = <span class="delimiter">(</span>tp: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.typeIsSubTypeOfSerializable.$anonfun.tp" title="Types.this.Type">tp</a> <a href="#scala.reflect.internal;Types;Type.<:<" title="(that: Types.this.Type)Boolean">&lt;:&lt;</a> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.SerializableTpe" title="=&gt; Types.this.Type">SerializableTpe</a>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types.typeIsNothing">typeIsNothing</a> = <span class="delimiter">(</span>tp: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.typeIsNothing.$anonfun.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbolDirect" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.NothingClass" title="Types.this.definitions.NothingClass.type">NothingClass</a>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types.typeIsAny">typeIsAny</a> = <span class="delimiter">(</span>tp: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.typeIsAny.$anonfun.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.typeSymbolDirect" title="=&gt; Types.this.Symbol">typeSymbolDirect</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyClass" title="=&gt; Types.this.ClassSymbol">AnyClass</a>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> val <a title="Types.this.Type =&gt; Boolean" id="scala.reflect.internal;Types.typeIsHigherKinded">typeIsHigherKinded</a> = <span class="delimiter">(</span>tp: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.typeIsHigherKinded.$anonfun.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.isHigherKinded" title="=&gt; Boolean">isHigherKinded</a>

  <span class="comment">/** The maximum depth of type `tp` */</span>
  def <a title="(tp: Types.this.Type)scala.reflect.internal.Depth" id="scala.reflect.internal;Types.typeDepth(6d5725dfee)">typeDepth</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.typeDepth(6d5725dfee).tp">tp</a>: <a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee).tp" title="Types.this.Type">tp</a> match <span class="delimiter">{</span>
    case TypeRef<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.typeDepth(6d5725dfee).pre">pre</a>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.typeDepth(6d5725dfee).sym">sym</a>, <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.typeDepth(6d5725dfee).args">args</a><span class="delimiter">)</span>          =&gt; <a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee)" title="(tp: Types.this.Type)scala.reflect.internal.Depth">typeDepth</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee).pre" title="Types.this.Type">pre</a><span class="delimiter">)</span> <a href="Depth.scala.html#scala.reflect.internal;Depth.max" title="(that: scala.reflect.internal.Depth)scala.reflect.internal.Depth">max</a> <a href="#scala.reflect.internal;Types.typeDepth(79231ea494)" title="(tps: List[Types.this.Type])scala.reflect.internal.Depth">typeDepth</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee).args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>.<a href="Depth.scala.html#scala.reflect.internal;Depth.incr(a73a950bc7)" title="=&gt; scala.reflect.internal.Depth">incr</a>
    case RefinedType<span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.typeDepth(6d5725dfee).parents">parents</a>, <a title="Types.this.Scope" id="scala.reflect.internal;Types.typeDepth(6d5725dfee).decls">decls</a><span class="delimiter">)</span>      =&gt; <a href="#scala.reflect.internal;Types.typeDepth(79231ea494)" title="(tps: List[Types.this.Type])scala.reflect.internal.Depth">typeDepth</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee).parents" title="List[Types.this.Type]">parents</a><span class="delimiter">)</span> <a href="Depth.scala.html#scala.reflect.internal;Depth.max" title="(that: scala.reflect.internal.Depth)scala.reflect.internal.Depth">max</a> <a href="#scala.reflect.internal;Types.symTypeDepth" title="(syms: List[Types.this.Symbol])scala.reflect.internal.Depth">symTypeDepth</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee).decls" title="Types.this.Scope">decls</a>.<a href="Scopes.scala.html#scala.reflect.internal;Scopes;Scope.toList" title="=&gt; List[Types.this.Symbol]">toList</a><span class="delimiter">)</span>.<a href="Depth.scala.html#scala.reflect.internal;Depth.incr(a73a950bc7)" title="=&gt; scala.reflect.internal.Depth">incr</a>
    case TypeBounds<span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.internal;Types.typeDepth(6d5725dfee).lo">lo</a>, <a title="Types.this.Type" id="scala.reflect.internal;Types.typeDepth(6d5725dfee).hi">hi</a><span class="delimiter">)</span>               =&gt; <a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee)" title="(tp: Types.this.Type)scala.reflect.internal.Depth">typeDepth</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee).lo" title="Types.this.Type">lo</a><span class="delimiter">)</span> <a href="Depth.scala.html#scala.reflect.internal;Depth.max" title="(that: scala.reflect.internal.Depth)scala.reflect.internal.Depth">max</a> <a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee)" title="(tp: Types.this.Type)scala.reflect.internal.Depth">typeDepth</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee).hi" title="Types.this.Type">hi</a><span class="delimiter">)</span>
    case MethodType<span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.internal;Types.typeDepth(6d5725dfee).paramtypes">paramtypes</a>, <span title="Types.this.Type">result</span><span class="delimiter">)</span>   =&gt; <a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee)" title="(tp: Types.this.Type)scala.reflect.internal.Depth">typeDepth</a><span class="delimiter">(</span><span title="Types.this.Type">result</span><span class="delimiter">)</span>
    case NullaryMethodType<span class="delimiter">(</span><span title="Types.this.Type">result</span><span class="delimiter">)</span>        =&gt; <a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee)" title="(tp: Types.this.Type)scala.reflect.internal.Depth">typeDepth</a><span class="delimiter">(</span><span title="Types.this.Type">result</span><span class="delimiter">)</span>
    case PolyType<span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams</span>, <span title="Types.this.Type">result</span><span class="delimiter">)</span>        =&gt; <a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee)" title="(tp: Types.this.Type)scala.reflect.internal.Depth">typeDepth</a><span class="delimiter">(</span><span title="Types.this.Type">result</span><span class="delimiter">)</span> <a href="Depth.scala.html#scala.reflect.internal;Depth.max" title="(that: scala.reflect.internal.Depth)scala.reflect.internal.Depth">max</a> <a href="#scala.reflect.internal;Types.symTypeDepth" title="(syms: List[Types.this.Symbol])scala.reflect.internal.Depth">symTypeDepth</a><span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams</span><span class="delimiter">)</span>.<a href="Depth.scala.html#scala.reflect.internal;Depth.incr(a73a950bc7)" title="=&gt; scala.reflect.internal.Depth">incr</a>
    case ExistentialType<span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams</span>, <span title="Types.this.Type">result</span><span class="delimiter">)</span> =&gt; <a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee)" title="(tp: Types.this.Type)scala.reflect.internal.Depth">typeDepth</a><span class="delimiter">(</span><span title="Types.this.Type">result</span><span class="delimiter">)</span> <a href="Depth.scala.html#scala.reflect.internal;Depth.max" title="(that: scala.reflect.internal.Depth)scala.reflect.internal.Depth">max</a> <a href="#scala.reflect.internal;Types.symTypeDepth" title="(syms: List[Types.this.Symbol])scala.reflect.internal.Depth">symTypeDepth</a><span class="delimiter">(</span><span title="List[Types.this.Symbol]">tparams</span><span class="delimiter">)</span>.<a href="Depth.scala.html#scala.reflect.internal;Depth.incr(a73a950bc7)" title="=&gt; scala.reflect.internal.Depth">incr</a>
    case _                                =&gt; <a href="Depth.scala.html#scala.reflect.internal.Depth.apply" title="(depth: Int)scala.reflect.internal.Depth">Depth</a><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">//OPT replaced with tailrecursive function to save on #closures</span>
  <span class="comment">// was:</span>
  <span class="comment">//    var d = 0</span>
  <span class="comment">//    for (tp &lt;- tps) d = d max by(tp) //!!!OPT!!!</span>
  <span class="comment">//    d</span>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> def <a title="(tps: List[Types.this.Type])scala.reflect.internal.Depth" id="scala.reflect.internal;Types.maxDepth">maxDepth</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.maxDepth.tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <span class="delimiter">{</span>
    @tailrec def <a title="(tps: List[Types.this.Type], acc: scala.reflect.internal.Depth)scala.reflect.internal.Depth" id="scala.reflect.internal;Types.maxDepth.loop">loop</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.maxDepth.loop.tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="scala.reflect.internal.Depth" id="scala.reflect.internal;Types.maxDepth.loop.acc">acc</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a><span class="delimiter">)</span>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <a href="#scala.reflect.internal;Types.maxDepth.loop.tps" title="List[Types.this.Type]">tps</a> match <span class="delimiter">{</span>
      case <a title="Types.this.Type" id="scala.reflect.internal;Types.maxDepth.loop.tp">tp</a> :: <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.maxDepth.loop.rest">rest</a> =&gt; <a href="#scala.reflect.internal;Types.maxDepth.loop" title="(tps: List[Types.this.Type], acc: scala.reflect.internal.Depth)scala.reflect.internal.Depth">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.maxDepth.loop.rest" title="List[Types.this.Type]">rest</a>, <a href="#scala.reflect.internal;Types.maxDepth.loop.acc" title="scala.reflect.internal.Depth">acc</a> <a href="Depth.scala.html#scala.reflect.internal;Depth.max" title="(that: scala.reflect.internal.Depth)scala.reflect.internal.Depth">max</a> <a href="#scala.reflect.internal;Types.typeDepth(6d5725dfee)" title="(tp: Types.this.Type)scala.reflect.internal.Depth">typeDepth</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.maxDepth.loop.tp" title="Types.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case _          =&gt; <a href="#scala.reflect.internal;Types.maxDepth.loop.acc" title="scala.reflect.internal.Depth">acc</a>
    <span class="delimiter">}</span>
    <a href="#scala.reflect.internal;Types.maxDepth.loop" title="(tps: List[Types.this.Type], acc: scala.reflect.internal.Depth)scala.reflect.internal.Depth">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.maxDepth.tps" title="List[Types.this.Type]">tps</a>, <a href="Depth.scala.html#scala.reflect.internal.Depth" title="scala.reflect.internal.Depth.type">Depth</a>.<a href="Depth.scala.html#scala.reflect.internal.Depth.Zero" title="=&gt; scala.reflect.internal.Depth">Zero</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  private<span class="delimiter">[</span>scala<span class="delimiter">]</span> def <a title="(tps: List[Types.this.Type])scala.reflect.internal.Depth" id="scala.reflect.internal;Types.maxbaseTypeSeqDepth">maxbaseTypeSeqDepth</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.maxbaseTypeSeqDepth.tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <span class="delimiter">{</span>
    @tailrec def <a title="(tps: List[Types.this.Type], acc: scala.reflect.internal.Depth)scala.reflect.internal.Depth" id="scala.reflect.internal;Types.maxbaseTypeSeqDepth.loop">loop</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.maxbaseTypeSeqDepth.loop.tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="scala.reflect.internal.Depth" id="scala.reflect.internal;Types.maxbaseTypeSeqDepth.loop.acc">acc</a>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a><span class="delimiter">)</span>: <a href="Depth.scala.html#scala.reflect.internal;Depth" title="scala.reflect.internal.Depth">Depth</a> = <a href="#scala.reflect.internal;Types.maxbaseTypeSeqDepth.loop.tps" title="List[Types.this.Type]">tps</a> match <span class="delimiter">{</span>
      case <a title="Types.this.Type" id="scala.reflect.internal;Types.maxbaseTypeSeqDepth.loop.tp">tp</a> :: <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.maxbaseTypeSeqDepth.loop.rest">rest</a> =&gt; <a href="#scala.reflect.internal;Types.maxbaseTypeSeqDepth.loop" title="(tps: List[Types.this.Type], acc: scala.reflect.internal.Depth)scala.reflect.internal.Depth">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.maxbaseTypeSeqDepth.loop.rest" title="List[Types.this.Type]">rest</a>, <a href="#scala.reflect.internal;Types.maxbaseTypeSeqDepth.loop.acc" title="scala.reflect.internal.Depth">acc</a> <a href="Depth.scala.html#scala.reflect.internal;Depth.max" title="(that: scala.reflect.internal.Depth)scala.reflect.internal.Depth">max</a> <a href="#scala.reflect.internal;Types.maxbaseTypeSeqDepth.loop.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.baseTypeSeqDepth" title="=&gt; scala.reflect.internal.Depth">baseTypeSeqDepth</a><span class="delimiter">)</span>
      case _          =&gt; <a href="#scala.reflect.internal;Types.maxbaseTypeSeqDepth.loop.acc" title="scala.reflect.internal.Depth">acc</a>
    <span class="delimiter">}</span>
    <a href="#scala.reflect.internal;Types.maxbaseTypeSeqDepth.loop" title="(tps: List[Types.this.Type], acc: scala.reflect.internal.Depth)scala.reflect.internal.Depth">loop</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.maxbaseTypeSeqDepth.tps" title="List[Types.this.Type]">tps</a>, <a href="Depth.scala.html#scala.reflect.internal.Depth" title="scala.reflect.internal.Depth.type">Depth</a>.<a href="Depth.scala.html#scala.reflect.internal.Depth.Zero" title="=&gt; scala.reflect.internal.Depth">Zero</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  @tailrec private def <a title="(tps: List[Types.this.Type], sym: Types.this.Symbol)Boolean" id="scala.reflect.internal;Types.typesContain">typesContain</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.typesContain.tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Symbol" id="scala.reflect.internal;Types.typesContain.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types.typesContain.tps" title="List[Types.this.Type]">tps</a> match <span class="delimiter">{</span>
    case <a title="Types.this.Type" id="scala.reflect.internal;Types.typesContain.tp">tp</a> :: <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.typesContain.rest">rest</a> =&gt; <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typesContain.tp" title="Types.this.Type">tp</a> <a href="#scala.reflect.internal;Types;Type.contains" title="(sym: Types.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal;Types.typesContain.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.internal;Types.typesContain" title="(tps: List[Types.this.Type], sym: Types.this.Symbol)Boolean">typesContain</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.typesContain.rest" title="List[Types.this.Type]">rest</a>, <a href="#scala.reflect.internal;Types.typesContain.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
    case _ =&gt; false
  <span class="delimiter">}</span>

  @tailrec private def <a title="(tps: List[Types.this.Type])Boolean" id="scala.reflect.internal;Types.areTrivialTypes">areTrivialTypes</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.internal;Types.areTrivialTypes.tps">tps</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.reflect.internal;Types.areTrivialTypes.tps" title="List[Types.this.Type]">tps</a> match <span class="delimiter">{</span>
    case <a title="Types.this.Type" id="scala.reflect.internal;Types.areTrivialTypes.tp">tp</a> :: <a title="List[Types.this.Type]" id="scala.reflect.internal;Types.areTrivialTypes.rest">rest</a> =&gt; <a href="#scala.reflect.internal;Types.areTrivialTypes.tp" title="Types.this.Type">tp</a>.<a href="#scala.reflect.internal;Types;Type.isTrivial" title="=&gt; Boolean">isTrivial</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;Types.areTrivialTypes" title="(tps: List[Types.this.Type])Boolean">areTrivialTypes</a><span class="delimiter">(</span><a href="#scala.reflect.internal;Types.areTrivialTypes.rest" title="List[Types.this.Type]">rest</a><span class="delimiter">)</span>
    case _ =&gt; true
  <span class="delimiter">}</span>

<span class="comment">// -------------- Classtags --------------------------------------------------------</span>

  implicit val <a title="scala.reflect.ClassTag[Types.this.AnnotatedType]" id="scala.reflect.internal;Types.AnnotatedTypeTag">AnnotatedTypeTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.AnnotatedType]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;AnnotatedType" title="Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.AnnotatedType](classOf[scala.reflect.internal.Types$AnnotatedType])" class="delimiter">[</span>AnnotatedType<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.BoundedWildcardType]" id="scala.reflect.internal;Types.BoundedWildcardTypeTag">BoundedWildcardTypeTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.BoundedWildcardType]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;BoundedWildcardType" title="Types.this.BoundedWildcardType">BoundedWildcardType</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.BoundedWildcardType](classOf[scala.reflect.internal.Types$BoundedWildcardType])" class="delimiter">[</span>BoundedWildcardType<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.ClassInfoType]" id="scala.reflect.internal;Types.ClassInfoTypeTag">ClassInfoTypeTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.ClassInfoType]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;ClassInfoType" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.ClassInfoType](classOf[scala.reflect.internal.Types$ClassInfoType])" class="delimiter">[</span>ClassInfoType<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.CompoundType]" id="scala.reflect.internal;Types.CompoundTypeTag">CompoundTypeTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.CompoundType]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;CompoundType" title="Types.this.CompoundType">CompoundType</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.CompoundType](classOf[scala.reflect.internal.Types$CompoundType])" class="delimiter">[</span>CompoundType<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.ConstantType]" id="scala.reflect.internal;Types.ConstantTypeTag">ConstantTypeTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.ConstantType]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;ConstantType" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.ConstantType](classOf[scala.reflect.internal.Types$ConstantType])" class="delimiter">[</span>ConstantType<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.ExistentialType]" id="scala.reflect.internal;Types.ExistentialTypeTag">ExistentialTypeTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.ExistentialType]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;ExistentialType" title="Types.this.ExistentialType">ExistentialType</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.ExistentialType](classOf[scala.reflect.internal.Types$ExistentialType])" class="delimiter">[</span>ExistentialType<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.MethodType]" id="scala.reflect.internal;Types.MethodTypeTag">MethodTypeTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.MethodType]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;MethodType" title="Types.this.MethodType">MethodType</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.MethodType](classOf[scala.reflect.internal.Types$MethodType])" class="delimiter">[</span>MethodType<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.NullaryMethodType]" id="scala.reflect.internal;Types.NullaryMethodTypeTag">NullaryMethodTypeTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.NullaryMethodType]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;NullaryMethodType" title="Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.NullaryMethodType](classOf[scala.reflect.internal.Types$NullaryMethodType])" class="delimiter">[</span>NullaryMethodType<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.PolyType]" id="scala.reflect.internal;Types.PolyTypeTag">PolyTypeTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.PolyType]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;PolyType" title="Types.this.PolyType">PolyType</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.PolyType](classOf[scala.reflect.internal.Types$PolyType])" class="delimiter">[</span>PolyType<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.RefinedType]" id="scala.reflect.internal;Types.RefinedTypeTag">RefinedTypeTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.RefinedType]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;RefinedType" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.RefinedType](classOf[scala.reflect.internal.Types$RefinedType])" class="delimiter">[</span>RefinedType<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.SingletonType]" id="scala.reflect.internal;Types.SingletonTypeTag">SingletonTypeTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.SingletonType]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;SingletonType" title="Types.this.SingletonType">SingletonType</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.SingletonType](classOf[scala.reflect.internal.Types$SingletonType])" class="delimiter">[</span>SingletonType<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.SingleType]" id="scala.reflect.internal;Types.SingleTypeTag">SingleTypeTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.SingleType]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;SingleType" title="Types.this.SingleType">SingleType</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.SingleType](classOf[scala.reflect.internal.Types$SingleType])" class="delimiter">[</span>SingleType<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.SuperType]" id="scala.reflect.internal;Types.SuperTypeTag">SuperTypeTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.SuperType]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;SuperType" title="Types.this.SuperType">SuperType</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.SuperType](classOf[scala.reflect.internal.Types$SuperType])" class="delimiter">[</span>SuperType<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.ThisType]" id="scala.reflect.internal;Types.ThisTypeTag">ThisTypeTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.ThisType]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;ThisType" title="Types.this.ThisType">ThisType</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.ThisType](classOf[scala.reflect.internal.Types$ThisType])" class="delimiter">[</span>ThisType<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.TypeBounds]" id="scala.reflect.internal;Types.TypeBoundsTag">TypeBoundsTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.TypeBounds]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.TypeBounds](classOf[scala.reflect.internal.Types$TypeBounds])" class="delimiter">[</span>TypeBounds<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.TypeRef]" id="scala.reflect.internal;Types.TypeRefTag">TypeRefTag</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.TypeRef]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;TypeRef" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.TypeRef](classOf[scala.reflect.internal.Types$TypeRef])" class="delimiter">[</span>TypeRef<span class="delimiter">]</span><span class="delimiter">)</span>
  implicit val <a title="scala.reflect.ClassTag[Types.this.Type]" id="scala.reflect.internal;Types.TypeTagg">TypeTagg</a> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Types.this.Type]" class="delimiter">[</span><a href="#scala.reflect.internal;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[Types.this.Type](classOf[scala.reflect.internal.Types$Type])" class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>

<span class="comment">// -------------- Statistics --------------------------------------------------------</span>

  <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newView" title="(prefix: String, phases: String*)(quant: =&gt; Any)scala.reflect.internal.util.Statistics.View">newView</a><span class="delimiter">(</span><span title="String(&quot;#unique types&quot;)" class="string">&quot;#unique types&quot;</span><span class="delimiter">)</span> <span class="delimiter">{</span> if <span class="delimiter">(</span><a href="#scala.reflect.internal;Types.uniques_=" title="=&gt; scala.reflect.internal.util.WeakHashSet[Types.this.Type]">uniques</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> else <a href="#scala.reflect.internal;Types.uniques_=" title="=&gt; scala.reflect.internal.util.WeakHashSet[Types.this.Type]">uniques</a>.<a href="util/WeakHashSet.scala.html#scala.reflect.internal.util;WeakHashSet.size" title="=&gt; Int">size</a> <span class="delimiter">}</span>

<span class="delimiter">}</span>

object <a title="scala.reflect.internal.TypeConstants.type" id="scala.reflect.internal.TypeConstants">TypeConstants</a> <a href="#scala.reflect.internal.TypeConstants" title="scala.reflect.internal.TypeConstants.type" class="delimiter">{</a>
  final val <a title="Int(50)" id="scala.reflect.internal.TypeConstants.DefaultLogThreshhold">DefaultLogThreshhold</a>         = <span title="Int(50)" class="int">50</span>
  final val <a title="Int(50)" id="scala.reflect.internal.TypeConstants.LogPendingBaseTypesThreshold">LogPendingBaseTypesThreshold</a> = <span title="Int(50)">DefaultLogThreshhold</span>
  final val <a title="Int(50)" id="scala.reflect.internal.TypeConstants.LogVolatileThreshold">LogVolatileThreshold</a>         = <span title="Int(50)">DefaultLogThreshhold</span>
<span class="delimiter">}</span>

object <a title="scala.reflect.internal.TypesStats.type" id="scala.reflect.internal.TypesStats">TypesStats</a> <a href="#scala.reflect.internal.TypesStats" title="scala.reflect.internal.TypesStats.type" class="delimiter">{</a>
  import <a href="BaseTypeSeqs.scala.html#scala.reflect.internal.BaseTypeSeqsStats" title="scala.reflect.internal.BaseTypeSeqsStats.type">BaseTypeSeqsStats</a>._
  val <a title="scala.reflect.internal.util.Statistics.Counter" id="scala.reflect.internal.TypesStats.rawTypeCount">rawTypeCount</a>        = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newCounter" title="(prefix: String, phases: String*)scala.reflect.internal.util.Statistics.Counter">newCounter</a>   <span class="delimiter">(</span><span title="String(&quot;#raw type creations&quot;)" class="string">&quot;#raw type creations&quot;</span><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.Counter" id="scala.reflect.internal.TypesStats.subtypeCount">subtypeCount</a>        = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newCounter" title="(prefix: String, phases: String*)scala.reflect.internal.util.Statistics.Counter">newCounter</a>   <span class="delimiter">(</span><span title="String(&quot;#subtype ops&quot;)" class="string">&quot;#subtype ops&quot;</span><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.Counter" id="scala.reflect.internal.TypesStats.sametypeCount">sametypeCount</a>       = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newCounter" title="(prefix: String, phases: String*)scala.reflect.internal.util.Statistics.Counter">newCounter</a>   <span class="delimiter">(</span><span title="String(&quot;#sametype ops&quot;)" class="string">&quot;#sametype ops&quot;</span><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.Counter" id="scala.reflect.internal.TypesStats.lubCount">lubCount</a>            = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newCounter" title="(prefix: String, phases: String*)scala.reflect.internal.util.Statistics.Counter">newCounter</a>   <span class="delimiter">(</span><span title="String(&quot;#toplevel lubs/glbs&quot;)" class="string">&quot;#toplevel lubs/glbs&quot;</span><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.Counter" id="scala.reflect.internal.TypesStats.nestedLubCount">nestedLubCount</a>      = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newCounter" title="(prefix: String, phases: String*)scala.reflect.internal.util.Statistics.Counter">newCounter</a>   <span class="delimiter">(</span><span title="String(&quot;#all lubs/glbs&quot;)" class="string">&quot;#all lubs/glbs&quot;</span><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.Counter" id="scala.reflect.internal.TypesStats.findMemberCount">findMemberCount</a>     = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newCounter" title="(prefix: String, phases: String*)scala.reflect.internal.util.Statistics.Counter">newCounter</a>   <span class="delimiter">(</span><span title="String(&quot;#findMember ops&quot;)" class="string">&quot;#findMember ops&quot;</span><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.Counter" id="scala.reflect.internal.TypesStats.findMembersCount">findMembersCount</a>    = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newCounter" title="(prefix: String, phases: String*)scala.reflect.internal.util.Statistics.Counter">newCounter</a>   <span class="delimiter">(</span><span title="String(&quot;#findMembers ops&quot;)" class="string">&quot;#findMembers ops&quot;</span><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.SubCounter" id="scala.reflect.internal.TypesStats.noMemberCount">noMemberCount</a>       = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newSubCounter" title="(prefix: String, ctr: scala.reflect.internal.util.Statistics.Counter)scala.reflect.internal.util.Statistics.SubCounter">newSubCounter</a><span class="delimiter">(</span><span title="String(&quot;  of which not found&quot;)" class="string">&quot;  of which not found&quot;</span>, <a href="#scala.reflect.internal.TypesStats.findMemberCount" title="=&gt; scala.reflect.internal.util.Statistics.Counter">findMemberCount</a><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.SubCounter" id="scala.reflect.internal.TypesStats.multMemberCount">multMemberCount</a>     = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newSubCounter" title="(prefix: String, ctr: scala.reflect.internal.util.Statistics.Counter)scala.reflect.internal.util.Statistics.SubCounter">newSubCounter</a><span class="delimiter">(</span><span title="String(&quot;  of which multiple overloaded&quot;)" class="string">&quot;  of which multiple overloaded&quot;</span>, <a href="#scala.reflect.internal.TypesStats.findMemberCount" title="=&gt; scala.reflect.internal.util.Statistics.Counter">findMemberCount</a><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.Timer" id="scala.reflect.internal.TypesStats.typerNanos">typerNanos</a>          = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newTimer" title="(prefix: String, phases: String*)scala.reflect.internal.util.Statistics.Timer">newTimer</a>     <span class="delimiter">(</span><span title="String(&quot;time spent typechecking&quot;)" class="string">&quot;time spent typechecking&quot;</span>, <span title="String(&quot;typer&quot;)" class="string">&quot;typer&quot;</span><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.StackableTimer" id="scala.reflect.internal.TypesStats.lubNanos">lubNanos</a>            = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newStackableTimer" title="(prefix: String, timer: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.StackableTimer">newStackableTimer</a><span class="delimiter">(</span><span title="String(&quot;time spent in lubs&quot;)" class="string">&quot;time spent in lubs&quot;</span>, <a href="#scala.reflect.internal.TypesStats.typerNanos" title="=&gt; scala.reflect.internal.util.Statistics.Timer">typerNanos</a><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.StackableTimer" id="scala.reflect.internal.TypesStats.subtypeNanos">subtypeNanos</a>        = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newStackableTimer" title="(prefix: String, timer: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.StackableTimer">newStackableTimer</a><span class="delimiter">(</span><span title="String(&quot;time spent in &lt;:&lt;&quot;)" class="string">&quot;time spent in &lt;:&lt;&quot;</span>, <a href="#scala.reflect.internal.TypesStats.typerNanos" title="=&gt; scala.reflect.internal.util.Statistics.Timer">typerNanos</a><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.StackableTimer" id="scala.reflect.internal.TypesStats.findMemberNanos">findMemberNanos</a>     = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newStackableTimer" title="(prefix: String, timer: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.StackableTimer">newStackableTimer</a><span class="delimiter">(</span><span title="String(&quot;time spent in findmember&quot;)" class="string">&quot;time spent in findmember&quot;</span>, <a href="#scala.reflect.internal.TypesStats.typerNanos" title="=&gt; scala.reflect.internal.util.Statistics.Timer">typerNanos</a><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.StackableTimer" id="scala.reflect.internal.TypesStats.findMembersNanos">findMembersNanos</a>    = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newStackableTimer" title="(prefix: String, timer: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.StackableTimer">newStackableTimer</a><span class="delimiter">(</span><span title="String(&quot;time spent in findmembers&quot;)" class="string">&quot;time spent in findmembers&quot;</span>, <a href="#scala.reflect.internal.TypesStats.typerNanos" title="=&gt; scala.reflect.internal.util.Statistics.Timer">typerNanos</a><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.StackableTimer" id="scala.reflect.internal.TypesStats.asSeenFromNanos">asSeenFromNanos</a>     = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newStackableTimer" title="(prefix: String, timer: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.StackableTimer">newStackableTimer</a><span class="delimiter">(</span><span title="String(&quot;time spent in asSeenFrom&quot;)" class="string">&quot;time spent in asSeenFrom&quot;</span>, <a href="#scala.reflect.internal.TypesStats.typerNanos" title="=&gt; scala.reflect.internal.util.Statistics.Timer">typerNanos</a><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.StackableTimer" id="scala.reflect.internal.TypesStats.baseTypeSeqNanos">baseTypeSeqNanos</a>    = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newStackableTimer" title="(prefix: String, timer: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.StackableTimer">newStackableTimer</a><span class="delimiter">(</span><span title="String(&quot;time spent in baseTypeSeq&quot;)" class="string">&quot;time spent in baseTypeSeq&quot;</span>, <a href="#scala.reflect.internal.TypesStats.typerNanos" title="=&gt; scala.reflect.internal.util.Statistics.Timer">typerNanos</a><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.StackableTimer" id="scala.reflect.internal.TypesStats.baseClassesNanos">baseClassesNanos</a>    = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newStackableTimer" title="(prefix: String, timer: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.StackableTimer">newStackableTimer</a><span class="delimiter">(</span><span title="String(&quot;time spent in baseClasses&quot;)" class="string">&quot;time spent in baseClasses&quot;</span>, <a href="#scala.reflect.internal.TypesStats.typerNanos" title="=&gt; scala.reflect.internal.util.Statistics.Timer">typerNanos</a><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.SubCounter" id="scala.reflect.internal.TypesStats.compoundBaseTypeSeqCount">compoundBaseTypeSeqCount</a> = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newSubCounter" title="(prefix: String, ctr: scala.reflect.internal.util.Statistics.Counter)scala.reflect.internal.util.Statistics.SubCounter">newSubCounter</a><span class="delimiter">(</span><span title="String(&quot;  of which for compound types&quot;)" class="string">&quot;  of which for compound types&quot;</span>, <a href="BaseTypeSeqs.scala.html#scala.reflect.internal.BaseTypeSeqsStats.baseTypeSeqCount" title="=&gt; scala.reflect.internal.util.Statistics.Counter">baseTypeSeqCount</a><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.SubCounter" id="scala.reflect.internal.TypesStats.typerefBaseTypeSeqCount">typerefBaseTypeSeqCount</a> = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newSubCounter" title="(prefix: String, ctr: scala.reflect.internal.util.Statistics.Counter)scala.reflect.internal.util.Statistics.SubCounter">newSubCounter</a><span class="delimiter">(</span><span title="String(&quot;  of which for typerefs&quot;)" class="string">&quot;  of which for typerefs&quot;</span>, <a href="BaseTypeSeqs.scala.html#scala.reflect.internal.BaseTypeSeqsStats.baseTypeSeqCount" title="=&gt; scala.reflect.internal.util.Statistics.Counter">baseTypeSeqCount</a><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.SubCounter" id="scala.reflect.internal.TypesStats.singletonBaseTypeSeqCount">singletonBaseTypeSeqCount</a> = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newSubCounter" title="(prefix: String, ctr: scala.reflect.internal.util.Statistics.Counter)scala.reflect.internal.util.Statistics.SubCounter">newSubCounter</a><span class="delimiter">(</span><span title="String(&quot;  of which for singletons&quot;)" class="string">&quot;  of which for singletons&quot;</span>, <a href="BaseTypeSeqs.scala.html#scala.reflect.internal.BaseTypeSeqsStats.baseTypeSeqCount" title="=&gt; scala.reflect.internal.util.Statistics.Counter">baseTypeSeqCount</a><span class="delimiter">)</span>
  val <a title="scala.reflect.internal.util.Statistics.TimerStack" id="scala.reflect.internal.TypesStats.typeOpsStack">typeOpsStack</a> = <a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="util/Statistics.scala.html#scala.reflect.internal.util.Statistics.newTimerStack" title="()scala.reflect.internal.util.Statistics.TimerStack">newTimerStack</a><span class="delimiter">(</span><span class="delimiter">)</span>

  <span class="comment">/* Commented out, because right now this does not inline, so creates a closure which will distort statistics
  @inline final def timedTypeOp[T](c: Statistics.StackableTimer)(op: =&gt; T): T = {
    val start = Statistics.pushTimer(typeOpsStack, c)
    try op
    finally
  }
  */</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
