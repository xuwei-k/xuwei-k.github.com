<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/reflect/internal/ExistentialsAndSkolems.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* NSC -- new scala compiler
 * Copyright 2005-2013 LAMP/EPFL
 * @author  Martin Odersky
 */</span>

package scala
package reflect
package internal

import scala.collection.<span class="delimiter">{</span> mutable, immutable <span class="delimiter">}</span>

<span class="comment">/** The name of this trait defines the eventual intent better than
 *  it does the initial contents.
 */</span>
trait <a title="trait ExistentialsAndSkolems extends AnyRef" id="scala.reflect.internal;ExistentialsAndSkolems">ExistentialsAndSkolems</a> <a href="../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a>
  self: SymbolTable =&gt;

  <span class="comment">/** Map a list of type parameter symbols to skolemized symbols, which
   *  can be deskolemized to the original type parameter. (A skolem is a
   *  representation of a bound variable when viewed inside its scope.)
   *  !!!Adriaan: this does not work for hk types.
   *
   *  Skolems will be created at level 0, rather than the current value
   *  of `skolemizationLevel`. (See SI-7782)
   */</span>
  def <a title="(tparams: List[ExistentialsAndSkolems.this.Symbol])List[ExistentialsAndSkolems.this.Symbol]" id="scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems">deriveFreshSkolems</a><span class="delimiter">(</span><a title="List[ExistentialsAndSkolems.this.Symbol]" id="scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems.tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[ExistentialsAndSkolems.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[ExistentialsAndSkolems.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <span class="delimiter">{</span>
    class <a title="class Deskolemizer extends ExistentialsAndSkolems.this.LazyType" id="scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems;Deskolemizer">Deskolemizer</a> extends <a href="Types.scala.html#scala.reflect.internal;Types;LazyType" title="ExistentialsAndSkolems.this.LazyType">LazyType</a> <span class="delimiter">{</span>
      override val <a title="List[ExistentialsAndSkolems.this.Symbol]" id="scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems;Deskolemizer.typeParams">typeParams</a> = <a href="#scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems.tparams" title="List[ExistentialsAndSkolems.this.Symbol]">tparams</a>
      val typeSkolems  = <a href="#scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems;Deskolemizer.typeParams" title="=&gt; List[ExistentialsAndSkolems.this.Symbol]">typeParams</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="List[ExistentialsAndSkolems.this.TypeSkolem]" id="scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems;Deskolemizer.typeSkolems">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems;Deskolemizer.typeSkolems.$anonfun.x$1" title="ExistentialsAndSkolems.this.Symbol">_</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.newTypeSkolem" title="=&gt; ExistentialsAndSkolems.this.TypeSkolem">newTypeSkolem</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="(info: ExistentialsAndSkolems.this.Type)ExistentialsAndSkolems.this.TypeSkolem">setInfo</a> this<span class="delimiter">)</span>
      override def <a title="(sym: ExistentialsAndSkolems.this.Symbol)Unit" id="scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems;Deskolemizer.complete">complete</a><span class="delimiter">(</span><a title="ExistentialsAndSkolems.this.Symbol" id="scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems;Deskolemizer.complete.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="ExistentialsAndSkolems.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// The info of a skolem is the skolemized info of the</span>
        <span class="comment">// actual type parameter of the skolem</span>
        <a href="#scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems;Deskolemizer.complete.sym" title="ExistentialsAndSkolems.this.Symbol">sym</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="(info: ExistentialsAndSkolems.this.Type)sym.type">setInfo</a> <a href="#scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems;Deskolemizer.complete.sym" title="ExistentialsAndSkolems.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.deSkolemize" title="=&gt; ExistentialsAndSkolems.this.Symbol">deSkolemize</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; ExistentialsAndSkolems.this.Type">info</a>.<a href="Types.scala.html#scala.reflect.internal;Types;Type.substSym" title="(from: List[ExistentialsAndSkolems.this.Symbol], to: List[ExistentialsAndSkolems.this.Symbol])ExistentialsAndSkolems.this.Type">substSym</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems;Deskolemizer.typeParams" title="=&gt; List[ExistentialsAndSkolems.this.Symbol]">typeParams</a>, <a href="#scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems;Deskolemizer.typeSkolems" title="=&gt; List[ExistentialsAndSkolems.this.TypeSkolem]">typeSkolems</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    val <a title="Int" id="scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems.saved">saved</a> = <a href="Types.scala.html#scala.reflect.internal;Types.skolemizationLevel" title="=&gt; Int">skolemizationLevel</a>
    <a href="Types.scala.html#scala.reflect.internal;Types.skolemizationLevel_=" title="(value: Int)Unit">skolemizationLevel</a> = <span title="Int(0)" class="int">0</span>
    try new <a href="#scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems;Deskolemizer" title="Deskolemizer">Deskolemizer</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems;Deskolemizer.typeSkolems" title="=&gt; List[ExistentialsAndSkolems.this.TypeSkolem]">typeSkolems</a>
    finally <a href="Types.scala.html#scala.reflect.internal;Types.skolemizationLevel_=" title="(value: Int)Unit">skolemizationLevel</a> = <a href="#scala.reflect.internal;ExistentialsAndSkolems.deriveFreshSkolems.saved" title="Int">saved</a>
  <span class="delimiter">}</span>

  def <a title="(sym: ExistentialsAndSkolems.this.Symbol)Boolean" id="scala.reflect.internal;ExistentialsAndSkolems.isRawParameter">isRawParameter</a><span class="delimiter">(</span><a title="ExistentialsAndSkolems.this.Symbol" id="scala.reflect.internal;ExistentialsAndSkolems.isRawParameter.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="ExistentialsAndSkolems.this.Symbol">Symbol</a><span class="delimiter">)</span> = <span class="comment">// is it a type parameter leaked by a raw type?</span>
    <a href="#scala.reflect.internal;ExistentialsAndSkolems.isRawParameter.sym" title="ExistentialsAndSkolems.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isTypeParameter" title="=&gt; Boolean">isTypeParameter</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.internal;ExistentialsAndSkolems.isRawParameter.sym" title="ExistentialsAndSkolems.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; ExistentialsAndSkolems.this.Symbol">owner</a>.<a href="HasFlags.scala.html#scala.reflect.internal;HasFlags.isJavaDefined" title="=&gt; Boolean">isJavaDefined</a>

  <span class="comment">/** If we map a set of hidden symbols to their existential bounds, we
   *  have a problem: the bounds may themselves contain references to the
   *  hidden symbols.  So this recursively calls existentialBound until
   *  the typeSymbol is not amongst the symbols being hidden.
   */</span>
  private def <a title="(hidden: List[ExistentialsAndSkolems.this.Symbol])Map[ExistentialsAndSkolems.this.Symbol,ExistentialsAndSkolems.this.Type]" id="scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden">existentialBoundsExcludingHidden</a><span class="delimiter">(</span><a title="List[ExistentialsAndSkolems.this.Symbol]" id="scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hidden">hidden</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[ExistentialsAndSkolems.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/Map.scala.html#scala.collection.immutable;Map" title="Map[ExistentialsAndSkolems.this.Symbol,ExistentialsAndSkolems.this.Type]">Map</a><span class="delimiter">[</span>Symbol, Type<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(t: ExistentialsAndSkolems.this.Type)ExistentialsAndSkolems.this.Type" id="scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.safeBound">safeBound</a><span class="delimiter">(</span><a title="ExistentialsAndSkolems.this.Type" id="scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.safeBound.t">t</a>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="ExistentialsAndSkolems.this.Type">Type</a><span class="delimiter">)</span>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="ExistentialsAndSkolems.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hidden" title="List[ExistentialsAndSkolems.this.Symbol]">hidden</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: ExistentialsAndSkolems.this.Symbol)Boolean">contains</a> <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.safeBound.t" title="ExistentialsAndSkolems.this.Type">t</a>.<a href="Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; ExistentialsAndSkolems.this.Symbol">typeSymbol</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.safeBound" title="(t: ExistentialsAndSkolems.this.Type)ExistentialsAndSkolems.this.Type">safeBound</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.safeBound.t" title="ExistentialsAndSkolems.this.Type">t</a>.<a href="Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; ExistentialsAndSkolems.this.Symbol">typeSymbol</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.existentialBound" title="=&gt; ExistentialsAndSkolems.this.Type">existentialBound</a>.<a href="Types.scala.html#scala.reflect.internal;Types;Type.bounds" title="=&gt; ExistentialsAndSkolems.this.TypeBounds">bounds</a>.<a href="Types.scala.html#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; ExistentialsAndSkolems.this.Type">hi</a><span class="delimiter">)</span> else <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.safeBound.t" title="ExistentialsAndSkolems.this.Type">t</a>

    def <a title="(s: ExistentialsAndSkolems.this.Symbol)ExistentialsAndSkolems.this.Type" id="scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hiBound">hiBound</a><span class="delimiter">(</span><a title="ExistentialsAndSkolems.this.Symbol" id="scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hiBound.s">s</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="ExistentialsAndSkolems.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="ExistentialsAndSkolems.this.Type">Type</a> = <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.safeBound" title="(t: ExistentialsAndSkolems.this.Type)ExistentialsAndSkolems.this.Type">safeBound</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hiBound.s" title="ExistentialsAndSkolems.this.Symbol">s</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.existentialBound" title="=&gt; ExistentialsAndSkolems.this.Type">existentialBound</a>.<a href="Types.scala.html#scala.reflect.internal;Types;Type.bounds" title="=&gt; ExistentialsAndSkolems.this.TypeBounds">bounds</a>.<a href="Types.scala.html#scala.reflect.internal;Types;TypeBounds.hi" title="=&gt; ExistentialsAndSkolems.this.Type">hi</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case <span title="ExistentialsAndSkolems.this.RefinedType">tp</span> @ RefinedType<span class="delimiter">(</span><a title="List[ExistentialsAndSkolems.this.Type]" id="scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hiBound.parents">parents</a>, <a title="ExistentialsAndSkolems.this.Scope" id="scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hiBound.decls">decls</a><span class="delimiter">)</span> =&gt;
        val parents1 = <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hiBound.parents" title="List[ExistentialsAndSkolems.this.Type]">parents</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="List[ExistentialsAndSkolems.this.Type]" id="scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hiBound.parents1">mapConserve</a> <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.safeBound" title="(t: ExistentialsAndSkolems.this.Type)ExistentialsAndSkolems.this.Type">safeBound</a>
        if <span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hiBound.parents" title="List[ExistentialsAndSkolems.this.Type]">parents</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hiBound.parents1" title="List[ExistentialsAndSkolems.this.Type]">parents1</a><span class="delimiter">)</span> <span title="ExistentialsAndSkolems.this.RefinedType">tp</span>
        else <a href="Types.scala.html#scala.reflect.internal;Types.copyRefinedType" title="(original: ExistentialsAndSkolems.this.RefinedType, parents: List[ExistentialsAndSkolems.this.Type], decls: ExistentialsAndSkolems.this.Scope)ExistentialsAndSkolems.this.Type">copyRefinedType</a><span class="delimiter">(</span><span title="ExistentialsAndSkolems.this.RefinedType">tp</span>, <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hiBound.parents1" title="List[ExistentialsAndSkolems.this.Type]">parents1</a>, <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hiBound.decls" title="ExistentialsAndSkolems.this.Scope">decls</a><span class="delimiter">)</span>
      case <span title="ExistentialsAndSkolems.this.Type">tp</span> =&gt; <span title="ExistentialsAndSkolems.this.Type">tp</span>
    <span class="delimiter">}</span>

    <span class="comment">// Hanging onto lower bound in case anything interesting</span>
    <span class="comment">// happens with it.</span>
    <a href="util/Collections.scala.html#scala.reflect.internal.util;Collections.mapFrom" title="(xs: List[ExistentialsAndSkolems.this.Symbol])(f: ExistentialsAndSkolems.this.Symbol =&gt; ExistentialsAndSkolems.this.Type)Map[ExistentialsAndSkolems.this.Symbol,ExistentialsAndSkolems.this.Type]">mapFrom</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hidden" title="List[ExistentialsAndSkolems.this.Symbol]">hidden</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="ExistentialsAndSkolems.this.Symbol" id="scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.$anonfun.s">s</a> =&gt; <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.$anonfun.s" title="ExistentialsAndSkolems.this.Symbol">s</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.existentialBound" title="=&gt; ExistentialsAndSkolems.this.Type">existentialBound</a> match <span class="delimiter">{</span>
      case TypeBounds<span class="delimiter">(</span><a title="ExistentialsAndSkolems.this.Type" id="scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.$anonfun.lo">lo</a>, <a title="ExistentialsAndSkolems.this.Type" id="scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.$anonfun.hi">hi</a><span class="delimiter">)</span> =&gt; <a href="Types.scala.html#scala.reflect.internal;Types.TypeBounds.apply(e5f6c793f3)" title="(lo: ExistentialsAndSkolems.this.Type, hi: ExistentialsAndSkolems.this.Type)ExistentialsAndSkolems.this.TypeBounds">TypeBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.$anonfun.lo" title="ExistentialsAndSkolems.this.Type">lo</a>, <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hiBound" title="(s: ExistentialsAndSkolems.this.Symbol)ExistentialsAndSkolems.this.Type">hiBound</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.$anonfun.s" title="ExistentialsAndSkolems.this.Symbol">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case _                  =&gt; <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.hiBound" title="(s: ExistentialsAndSkolems.this.Symbol)ExistentialsAndSkolems.this.Type">hiBound</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden.$anonfun.s" title="ExistentialsAndSkolems.this.Symbol">s</a><span class="delimiter">)</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Given a set `rawSyms` of term- and type-symbols, and a type
   *  `tp`, produce a set of fresh type parameters and a type so that
   *  it can be abstracted to an existential type. Every type symbol
   *  `T` in `rawSyms` is mapped to a clone. Every term symbol `x` of
   *  type `T` in `rawSyms` is given an associated type symbol of the
   *  following form:
   *
   *    type x.type &lt;: T with Singleton
   *
   *  The name of the type parameter is `x.type`, to produce nice
   *  diagnostics. The Singleton parent ensures that the type
   *  parameter is still seen as a stable type. Type symbols in
   *  rawSyms are fully replaced by the new symbols. Term symbols are
   *  also replaced, except for term symbols of an Ident tree, where
   *  only the type of the Ident is changed.
   */</span>
  final def <a title="[T](rawSyms: List[ExistentialsAndSkolems.this.Symbol], tp: ExistentialsAndSkolems.this.Type, rawOwner: ExistentialsAndSkolems.this.Symbol)(creator: (List[ExistentialsAndSkolems.this.Symbol], ExistentialsAndSkolems.this.Type) =&gt; T)T" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform">existentialTransform</a><span class="delimiter">[</span><a title="" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform$default$3;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[ExistentialsAndSkolems.this.Symbol]" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.rawSyms">rawSyms</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[ExistentialsAndSkolems.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="ExistentialsAndSkolems.this.Type" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.tp">tp</a>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="ExistentialsAndSkolems.this.Type">Type</a>, <a title="ExistentialsAndSkolems.this.Symbol" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform$default$3">rawOwner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="ExistentialsAndSkolems.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; ExistentialsAndSkolems.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(List[ExistentialsAndSkolems.this.Symbol], ExistentialsAndSkolems.this.Type) =&gt; T" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.creator">creator</a>: <span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span> =&gt; T<span class="delimiter">)</span>: <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform$default$3;T" title="T">T</a> = <span class="delimiter">{</span>
    val <a title="Map[ExistentialsAndSkolems.this.Symbol,ExistentialsAndSkolems.this.Type]" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.allBounds">allBounds</a> = <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialBoundsExcludingHidden" title="(hidden: List[ExistentialsAndSkolems.this.Symbol])Map[ExistentialsAndSkolems.this.Symbol,ExistentialsAndSkolems.this.Type]">existentialBoundsExcludingHidden</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.rawSyms" title="List[ExistentialsAndSkolems.this.Symbol]">rawSyms</a><span class="delimiter">)</span>
    val typeParams: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[ExistentialsAndSkolems.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span> = <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.rawSyms" title="List[ExistentialsAndSkolems.this.Symbol]">rawSyms</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="List[ExistentialsAndSkolems.this.Symbol]" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams">map</a> <span class="delimiter">{</span> <a title="ExistentialsAndSkolems.this.Symbol" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.sym">sym</a> =&gt;
      val <a title="ExistentialsAndSkolems.this.TypeName" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.name">name</a> = <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.sym" title="ExistentialsAndSkolems.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym.NameType">name</a> match <span class="delimiter">{</span>
        case <span title="ExistentialsAndSkolems.this.TypeName">x</span>: <a href="Names.scala.html#scala.reflect.internal;Names;TypeName" title="ExistentialsAndSkolems.this.TypeName">TypeName</a>  =&gt; <span title="ExistentialsAndSkolems.this.TypeName">x</span>
        case <span title="sym.NameType">x</span>            =&gt; <a href="StdNames.scala.html#scala.reflect.internal;StdNames.tpnme" title="ExistentialsAndSkolems.this.tpnme.type">tpnme</a>.<a href="StdNames.scala.html#scala.reflect.internal;StdNames;TypeNames.singletonName" title="(name: ExistentialsAndSkolems.this.Name)ExistentialsAndSkolems.this.TypeName">singletonName</a><span class="delimiter">(</span><span title="sym.NameType">x</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      def <a title="=&gt; ExistentialsAndSkolems.this.Symbol" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.rawOwner0">rawOwner0</a>  = <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform$default$3" title="ExistentialsAndSkolems.this.Symbol">rawOwner</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.orElse" title="(alt: =&gt; ExistentialsAndSkolems.this.Symbol)ExistentialsAndSkolems.this.Symbol">orElse</a> <a href="Reporting.scala.html#scala.reflect.internal;Reporting.abort" title="(msg: String)Nothing">abort</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;no owner provided for existential transform over raw parameter: &quot;)">no owner provided for existential transform over raw parameter: $</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.sym" title="ExistentialsAndSkolems.this.Symbol">sym</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
      val <a title="ExistentialsAndSkolems.this.Type" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.bound">bound</a>      = <a href="../../collection/MapLike.scala.html#scala.collection;MapLike.apply" title="(key: ExistentialsAndSkolems.this.Symbol)ExistentialsAndSkolems.this.Type">allBounds</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.sym" title="ExistentialsAndSkolems.this.Symbol">sym</a><span class="delimiter">)</span>
      val <a title="ExistentialsAndSkolems.this.Symbol" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.sowner">sowner</a>     = if <span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.isRawParameter" title="(sym: ExistentialsAndSkolems.this.Symbol)Boolean">isRawParameter</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.sym" title="ExistentialsAndSkolems.this.Symbol">sym</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.rawOwner0" title="=&gt; ExistentialsAndSkolems.this.Symbol">rawOwner0</a> else <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.sym" title="ExistentialsAndSkolems.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; ExistentialsAndSkolems.this.Symbol">owner</a>
      val <a title="ExistentialsAndSkolems.this.TypeSymbol" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.quantified">quantified</a> = <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.sowner" title="ExistentialsAndSkolems.this.Symbol">sowner</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.newExistential" title="(name: ExistentialsAndSkolems.this.TypeName, pos: ExistentialsAndSkolems.this.Position, newFlags: Long)ExistentialsAndSkolems.this.TypeSymbol">newExistential</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.name" title="ExistentialsAndSkolems.this.TypeName">name</a>, <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.sym" title="ExistentialsAndSkolems.this.Symbol">sym</a>.<a href="StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.pos" title="=&gt; ExistentialsAndSkolems.this.Position">pos</a><span class="delimiter">)</span>

      <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.quantified" title="ExistentialsAndSkolems.this.TypeSymbol">quantified</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="(info: ExistentialsAndSkolems.this.Type)quantified.type">setInfo</a> <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.bound" title="ExistentialsAndSkolems.this.Type">bound</a>.<a href="Types.scala.html#scala.reflect.internal;Types;Type.cloneInfo" title="(owner: ExistentialsAndSkolems.this.Symbol)ExistentialsAndSkolems.this.Type">cloneInfo</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams.$anonfun.quantified" title="ExistentialsAndSkolems.this.TypeSymbol">quantified</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="comment">// Higher-kinded existentials are not yet supported, but this is</span>
    <span class="comment">// tpeHK for when they are: &quot;if a type constructor is expected/allowed,</span>
    <span class="comment">// tpeHK must be called instead of tpe.&quot;</span>
    val typeParamTypes = <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams" title="List[ExistentialsAndSkolems.this.Symbol]">typeParams</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="List[ExistentialsAndSkolems.this.Type]" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParamTypes">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParamTypes.$anonfun.x$2" title="ExistentialsAndSkolems.this.Symbol">_</a>.<a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpeHK" title="=&gt; ExistentialsAndSkolems.this.Type">tpeHK</a><span class="delimiter">)</span>
    def <a title="(info: ExistentialsAndSkolems.this.Type)ExistentialsAndSkolems.this.Type" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.doSubst">doSubst</a><span class="delimiter">(</span><a title="ExistentialsAndSkolems.this.Type" id="scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.doSubst.info">info</a>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="ExistentialsAndSkolems.this.Type">Type</a><span class="delimiter">)</span> = <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.doSubst.info" title="ExistentialsAndSkolems.this.Type">info</a>.<a href="Types.scala.html#scala.reflect.internal;Types;Type.subst" title="(from: List[ExistentialsAndSkolems.this.Symbol], to: List[ExistentialsAndSkolems.this.Type])ExistentialsAndSkolems.this.Type">subst</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.rawSyms" title="List[ExistentialsAndSkolems.this.Symbol]">rawSyms</a>, <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParamTypes" title="List[ExistentialsAndSkolems.this.Type]">typeParamTypes</a><span class="delimiter">)</span>

    <a href="../../Function2.scala.html#scala;Function2.apply" title="(v1: List[ExistentialsAndSkolems.this.Symbol], v2: ExistentialsAndSkolems.this.Type)T">creator</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.typeParams" title="List[ExistentialsAndSkolems.this.Symbol]">typeParams</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: ExistentialsAndSkolems.this.Symbol =&gt; ExistentialsAndSkolems.this.Symbol)(implicit bf: scala.collection.generic.CanBuildFrom[List[ExistentialsAndSkolems.this.Symbol],ExistentialsAndSkolems.this.Symbol,List[ExistentialsAndSkolems.this.Symbol]])List[ExistentialsAndSkolems.this.Symbol]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.$anonfun.x$3" title="ExistentialsAndSkolems.this.Symbol">_</a> <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.modifyInfo" title="(f: ExistentialsAndSkolems.this.Type =&gt; ExistentialsAndSkolems.this.Type)x$3.type">modifyInfo</a> <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.doSubst" title="(info: ExistentialsAndSkolems.this.Type)ExistentialsAndSkolems.this.Type">doSubst</a><span class="delimiter">)</span>, <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.doSubst" title="(info: ExistentialsAndSkolems.this.Type)ExistentialsAndSkolems.this.Type">doSubst</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform.tp" title="ExistentialsAndSkolems.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Compute an existential type from hidden symbols `hidden` and type `tp`.
   * @param hidden   The symbols that will be existentially abstracted
   * @param hidden   The original type
   * @param rawOwner The owner for Java raw types.
   */</span>
  final def <a title="(hidden: List[ExistentialsAndSkolems.this.Symbol], tp: ExistentialsAndSkolems.this.Type, rawOwner: ExistentialsAndSkolems.this.Symbol)ExistentialsAndSkolems.this.Type" id="scala.reflect.internal;ExistentialsAndSkolems.packSymbols">packSymbols</a><span class="delimiter">(</span><a title="List[ExistentialsAndSkolems.this.Symbol]" id="scala.reflect.internal;ExistentialsAndSkolems.packSymbols.hidden">hidden</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[ExistentialsAndSkolems.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="ExistentialsAndSkolems.this.Type" id="scala.reflect.internal;ExistentialsAndSkolems.packSymbols.tp">tp</a>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="ExistentialsAndSkolems.this.Type">Type</a>, <a title="ExistentialsAndSkolems.this.Symbol" id="scala.reflect.internal;ExistentialsAndSkolems.packSymbols$default$3">rawOwner</a>: <a href="Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="ExistentialsAndSkolems.this.Symbol">Symbol</a> = <a href="Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; ExistentialsAndSkolems.this.NoSymbol">NoSymbol</a><span class="delimiter">)</span>: <a href="Types.scala.html#scala.reflect.internal;Types;Type" title="ExistentialsAndSkolems.this.Type">Type</a> =
    if <span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.packSymbols.hidden" title="List[ExistentialsAndSkolems.this.Symbol]">hidden</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.internal;ExistentialsAndSkolems.packSymbols.tp" title="ExistentialsAndSkolems.this.Type">tp</a>
    else <a href="#scala.reflect.internal;ExistentialsAndSkolems.existentialTransform" title="(rawSyms: List[ExistentialsAndSkolems.this.Symbol], tp: ExistentialsAndSkolems.this.Type, rawOwner: ExistentialsAndSkolems.this.Symbol)(creator: (List[ExistentialsAndSkolems.this.Symbol], ExistentialsAndSkolems.this.Type) =&gt; ExistentialsAndSkolems.this.Type)ExistentialsAndSkolems.this.Type">existentialTransform</a><span class="delimiter">(</span><a href="#scala.reflect.internal;ExistentialsAndSkolems.packSymbols.hidden" title="List[ExistentialsAndSkolems.this.Symbol]">hidden</a>, <a href="#scala.reflect.internal;ExistentialsAndSkolems.packSymbols.tp" title="ExistentialsAndSkolems.this.Type">tp</a>, <a href="#scala.reflect.internal;ExistentialsAndSkolems.packSymbols$default$3" title="ExistentialsAndSkolems.this.Symbol">rawOwner</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Types.scala.html#scala.reflect.internal;Types.existentialAbstraction" title="(tparams: List[ExistentialsAndSkolems.this.Symbol], tpe0: ExistentialsAndSkolems.this.Type)ExistentialsAndSkolems.this.Type">existentialAbstraction</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
