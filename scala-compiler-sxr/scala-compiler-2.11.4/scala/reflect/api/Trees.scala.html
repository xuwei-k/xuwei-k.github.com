<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/reflect/api/Trees.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* NSC -- new Scala compiler
 * Copyright 2005-2013 LAMP/EPFL
 * @author  Martin Odersky
 */</span>
package scala
package reflect
package api

<span class="comment">/**
 * &lt;span class=&quot;badge badge-red&quot; style=&quot;float: right;&quot;&gt;EXPERIMENTAL&lt;/span&gt;
 *
 * This trait defines the node types used in Scala abstract syntax trees (AST) and operations on them.
 *
 * Trees are the basis for Scala's abstract syntax that is used to represent programs. They are also called
 * abstract syntax trees and commonly abbreviated as ASTs.
 *
 * In Scala reflection, APIs that produce or use `Tree`s are:
 *
 *   - '''Annotations''' which use trees to represent their arguments, exposed in [[scala.reflect.api.Annotations#scalaArgs Annotation.scalaArgs]].
 *   - '''[[scala.reflect.api.Universe#reify reify]]''', a special method on [[scala.reflect.api.Universe]] that takes an expression and returns an AST which represents the expression.
 *   - '''Macros and runtime compilation with toolboxes''' which both use trees as their program representation medium.
 *
 *  Trees are immutable, except for three fields
 *  [[Trees#TreeApi.pos pos]], [[Trees#TreeApi.symbol symbol]], and [[Trees#TreeApi.tpe tpe]], which are assigned when a tree is typechecked
 *  to attribute it with the information gathered by the typechecker.
 *
 *  === Examples ===
 *
 *  The following creates an AST representing a literal 5 in Scala source code:
 *  {{{
 *    Literal(Constant(5))
 *  }}}
 *
 *  The following creates an AST representing `print(&quot;Hello World&quot;)`:
 *  {{{
 *    Apply(Select(Select(This(newTypeName(&quot;scala&quot;)), newTermName(&quot;Predef&quot;)), newTermName(&quot;print&quot;)), List(Literal(Constant(&quot;Hello World&quot;))))
 *  }}}
 *
 *  The following creates an AST from a literal 5, and then uses `showRaw` to print it in a readable format.
 *  {{{
 *    import scala.reflect.runtime.universe.{ reify, showRaw }
 *    print( showRaw( reify{5}.tree ) )` // prints Literal(Constant(5))
 *  }}}
 *
 *  For more information about `Tree`s, see the [[http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html Reflection Guide: Symbols, Trees, Types]].
 *
 *  @groupname Traversal Tree Traversal and Transformation
 *  @groupprio Traversal 1
 *  @groupprio Factories 1
 *  @groupname Copying   Tree Copying
 *  @groupprio Copying   1
 *
 *  @contentDiagram hideNodes &quot;*Api&quot;
 *  @group ReflectionAPI
 */</span>
trait <a title="trait Trees extends AnyRef" id="scala.reflect.api;Trees">Trees</a> <a href="../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a> self: Universe =&gt;

  <span class="comment">/** The type of Scala abstract syntax trees.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.TreeApi" id="scala.reflect.api;Trees;Tree">Tree</a> &gt;: Null &lt;: AnyRef with TreeApi

  <span class="comment">/** The API that all trees support.
   *  The main source of information about trees is the [[scala.reflect.api.Trees]] page.
   *  @group API
   */</span>
  trait <a title="trait TreeApi extends AnyRef with Product" id="scala.reflect.api;Trees;TreeApi">TreeApi</a> extends <a href="../../Product.scala.html#scala;Product" title="Product">Product</a> <span class="delimiter">{</span> this: Tree =&gt;
    <span class="comment">/** Does this tree represent a definition? (of a method, of a class, etc) */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Trees;TreeApi.isDef">isDef</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Is this tree one of the empty trees?
     *
     *  Empty trees are: the `EmptyTree` null object and `TypeTree` instances that don't carry a type.
     *
     *  @see `canHaveAttrs`
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Trees;TreeApi.isEmpty">isEmpty</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Is this tree not an empty tree?
     *
     *  @see `isEmpty`
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Trees;TreeApi.nonEmpty">nonEmpty</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Can this tree carry attributes (i.e. symbols, types or positions)?
     *  Typically the answer is yes, except for the `EmptyTree` null object and
     *  two special singletons: `noSelfType` and `pendingSuperCall`.
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Trees;TreeApi.canHaveAttrs">canHaveAttrs</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** The canonical way to test if a Tree represents a term.
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Trees;TreeApi.isTerm">isTerm</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** The canonical way to test if a Tree represents a type.
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Trees;TreeApi.isType">isType</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Position of the tree. */</span>
    def <a title="=&gt; Trees.this.Position" id="scala.reflect.api;Trees;TreeApi.pos">pos</a>: <a href="Positions.scala.html#scala.reflect.api;Positions;Position" title="Trees.this.Position">Position</a>

    <span class="comment">/** Type of the tree.
     *
     *  Upon creation most trees have their `tpe` set to `null`.
     *  Types are typically assigned to trees during typechecking.
     *  Some node factory methods set `tpe` immediately after creation.
     *
     *  When the typechecker encounters a tree with a non-null tpe,
     *  it will assume it to be correct and not check it again. This means one has
     *  to be careful not to erase the `tpe` field of subtrees.
     */</span>
    def <a title="=&gt; Trees.this.Type" id="scala.reflect.api;Trees;TreeApi.tpe">tpe</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Trees.this.Type">Type</a>

    <span class="comment">/** Symbol of the tree.
     *
     *  For most trees symbol is `null`. In `SymTree`s,
     *  it is overridden and implemented with a var, initialized to `NoSymbol`.
     *
     *  Trees which are not `SymTree`s but which carry symbols do so by
     *  overriding `def symbol` to forward it elsewhere.  Examples:
     *
     *    - `Super(qual, _)`              has `qual`'s symbol,
     *    - `Apply(fun, args)`            has `fun`'s symbol,
     *    - `TypeApply(fun, args)`        has `fun`'s symbol,
     *    - `AppliedTypeTree(tpt, args)`  has `tpt`'s symbol,
     *    - `TypeTree(tpe)`               has `tpe`'s `typeSymbol`, if `tpe != null`.
     */</span>
    def <a title="=&gt; Trees.this.Symbol" id="scala.reflect.api;Trees;TreeApi.symbol">symbol</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>

    <span class="comment">/** Provides an alternate if tree is empty
     *  @param  alt  The alternate tree
     *  @return If this tree is non empty, this tree, otherwise `alt`.
     */</span>
    def <a title="(alt: =&gt; Trees.this.Tree)Trees.this.Tree" id="scala.reflect.api;Trees;TreeApi.orElse">orElse</a><span class="delimiter">(</span><a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;TreeApi.orElse.alt">alt</a>: =&gt; Tree<span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** Apply `f` to each subtree */</span>
    def <a title="(f: Trees.this.Tree =&gt; Unit)Unit" id="scala.reflect.api;Trees;TreeApi.foreach">foreach</a><span class="delimiter">(</span><a title="Trees.this.Tree =&gt; Unit" id="scala.reflect.api;Trees;TreeApi.foreach.f">f</a>: Tree =&gt; Unit<span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>

    <span class="comment">/** Find all subtrees matching predicate `p`. Same as `filter` */</span>
    def <a title="(f: Trees.this.Tree =&gt; Boolean)List[Trees.this.Tree]" id="scala.reflect.api;Trees;TreeApi.withFilter">withFilter</a><span class="delimiter">(</span><a title="Trees.this.Tree =&gt; Boolean" id="scala.reflect.api;Trees;TreeApi.withFilter.f">f</a>: Tree =&gt; Boolean<span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

    <span class="comment">/** Find all subtrees matching predicate `p`. Same as `withFilter` */</span>
    def <a title="(f: Trees.this.Tree =&gt; Boolean)List[Trees.this.Tree]" id="scala.reflect.api;Trees;TreeApi.filter">filter</a><span class="delimiter">(</span><a title="Trees.this.Tree =&gt; Boolean" id="scala.reflect.api;Trees;TreeApi.filter.f">f</a>: Tree =&gt; Boolean<span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

    <span class="comment">/** Apply `pf' to each subtree on which the function is defined and collect the results.
     */</span>
    def <a title="[T](pf: PartialFunction[Trees.this.Tree,T])List[T]" id="scala.reflect.api;Trees;TreeApi.collect">collect</a><span class="delimiter">[</span><a title="" id="scala.reflect.api;Trees;TreeApi.collect;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[Trees.this.Tree,T]" id="scala.reflect.api;Trees;TreeApi.collect.pf">pf</a>: <a href="../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[Trees.this.Tree,T]">PartialFunction</a><span class="delimiter">[</span>Tree, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

    <span class="comment">/** Returns optionally first tree (in a preorder traversal) which satisfies predicate `p`,
     *  or None if none exists.
     */</span>
    def <a title="(p: Trees.this.Tree =&gt; Boolean)Option[Trees.this.Tree]" id="scala.reflect.api;Trees;TreeApi.find">find</a><span class="delimiter">(</span><a title="Trees.this.Tree =&gt; Boolean" id="scala.reflect.api;Trees;TreeApi.find.p">p</a>: Tree =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Trees.this.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

    <span class="comment">/** Is there exists a part of this tree which satisfies predicate `p`? */</span>
    def <a title="(p: Trees.this.Tree =&gt; Boolean)Boolean" id="scala.reflect.api;Trees;TreeApi.exists">exists</a><span class="delimiter">(</span><a title="Trees.this.Tree =&gt; Boolean" id="scala.reflect.api;Trees;TreeApi.exists.p">p</a>: Tree =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Do all parts of this tree satisfy predicate `p`? */</span>
    def <a title="(p: Trees.this.Tree =&gt; Boolean)Boolean" id="scala.reflect.api;Trees;TreeApi.forAll">forAll</a><span class="delimiter">(</span><a title="Trees.this.Tree =&gt; Boolean" id="scala.reflect.api;Trees;TreeApi.forAll.p">p</a>: Tree =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Tests whether two trees are structurall equal.
     *  Note that `==` on trees is reference equality.
     */</span>
    def <a title="(that: Trees.this.Tree)Boolean" id="scala.reflect.api;Trees;TreeApi.equalsStructure">equalsStructure</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeApi.equalsStructure.that">that</a> : <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** The direct child trees of this tree.
     *  EmptyTrees are always omitted.  Lists are flattened.
     */</span>
    def <a title="=&gt; List[Trees.this.Tree]" id="scala.reflect.api;Trees;TreeApi.children">children</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

    <span class="comment">/** Make a copy of this tree, keeping all attributes,
     *  except that all positions are focused (so nothing
     *  in this tree will be found when searching by position).
     */</span>
    def <a title="=&gt; TreeApi.this.type" id="scala.reflect.api;Trees;TreeApi.duplicate">duplicate</a>: this.type

    <span class="comment">/** Obtains string representation of a tree */</span>
    override def <a title="()String" id="scala.reflect.api;Trees;TreeApi.toString">toString</a>: <span title="String">String</span> = <a href="Printers.scala.html#scala.reflect.api;Printers.treeToString" title="(tree: Trees.this.Tree)String">treeToString</a><span class="delimiter">(</span>this<span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Obtains string representation of a tree
   *  @group Trees
   */</span>
  protected def <a title="(tree: Trees.this.Tree)String" id="scala.reflect.api;Trees.treeToString">treeToString</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees.treeToString.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <span title="String">String</span>

  <span class="comment">/** The empty tree
   *  @group Trees
   */</span>
  val <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees.EmptyTree">EmptyTree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

  <span class="comment">/** A tree for a term.  Not all trees representing terms are TermTrees; use isTerm
   *  to reliably identify terms.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.TermTreeApi with Trees.this.Tree" id="scala.reflect.api;Trees;TermTree">TermTree</a> &gt;: Null &lt;: TermTreeApi with Tree

  <span class="comment">/** The API that all term trees support
   *  @group API
   */</span>
  trait <a title="trait TermTreeApi extends AnyRef with Trees.this.TreeApi" id="scala.reflect.api;Trees;TermTreeApi">TermTreeApi</a> extends <a href="#scala.reflect.api;Trees;TreeApi" title="Trees.this.TreeApi">TreeApi</a> <span class="delimiter">{</span> this: TermTree =&gt;
  <span class="delimiter">}</span>

  <span class="comment">/** A tree for a type. Not all trees representing types are TypTrees; use isType
   *  to reliably identify types.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.TypTreeApi with Trees.this.Tree" id="scala.reflect.api;Trees;TypTree">TypTree</a> &gt;: Null &lt;: TypTreeApi with Tree

  <span class="comment">/** The API that all typ trees support
   *  @group API
   */</span>
  trait <a title="trait TypTreeApi extends AnyRef with Trees.this.TreeApi" id="scala.reflect.api;Trees;TypTreeApi">TypTreeApi</a> extends <a href="#scala.reflect.api;Trees;TreeApi" title="Trees.this.TreeApi">TreeApi</a> <span class="delimiter">{</span> this: TypTree =&gt;
  <span class="delimiter">}</span>

  <span class="comment">/** A tree that carries a symbol, e.g. by defining it (`DefTree`) or by referring to it (`RefTree`).
   *  Such trees start their life naked, returning `NoSymbol`, but after being typechecked without errors
   *  they hold non-empty symbols.
   *
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.SymTreeApi with Trees.this.Tree" id="scala.reflect.api;Trees;SymTree">SymTree</a> &gt;: Null &lt;: SymTreeApi with Tree

  <span class="comment">/** The API that all sym trees support
   *  @group API
   */</span>
  trait <a title="trait SymTreeApi extends AnyRef with Trees.this.TreeApi" id="scala.reflect.api;Trees;SymTreeApi">SymTreeApi</a> extends <a href="#scala.reflect.api;Trees;TreeApi" title="Trees.this.TreeApi">TreeApi</a> <span class="delimiter">{</span> this: SymTree =&gt;
    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Symbol" id="scala.reflect.api;Trees;SymTreeApi.symbol">symbol</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A tree that carries a name, e.g. by defining it (`DefTree`) or by referring to it (`RefTree`).
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.NameTreeApi with Trees.this.Tree" id="scala.reflect.api;Trees;NameTree">NameTree</a> &gt;: Null &lt;: NameTreeApi with Tree

  <span class="comment">/** The API that all name trees support
   *  @group API
   */</span>
  trait <a title="trait NameTreeApi extends AnyRef with Trees.this.TreeApi" id="scala.reflect.api;Trees;NameTreeApi">NameTreeApi</a> extends <a href="#scala.reflect.api;Trees;TreeApi" title="Trees.this.TreeApi">TreeApi</a> <span class="delimiter">{</span> this: NameTree =&gt;
    <span class="comment">/** The underlying name.
     *  For example, the `List` part of `Ident(TermName(&quot;List&quot;))`.
     */</span>
    def <a title="=&gt; Trees.this.Name" id="scala.reflect.api;Trees;NameTreeApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A tree which references a symbol-carrying entity.
   *  References one, as opposed to defining one; definitions
   *  are in DefTrees.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.RefTreeApi with Trees.this.SymTree with Trees.this.NameTree" id="scala.reflect.api;Trees;RefTree">RefTree</a> &gt;: Null &lt;: RefTreeApi with SymTree with NameTree

  <span class="comment">/** The API that all ref trees support
   *  @group API
   */</span>
  trait <a title="trait RefTreeApi extends AnyRef with Trees.this.SymTreeApi with Trees.this.NameTreeApi" id="scala.reflect.api;Trees;RefTreeApi">RefTreeApi</a> extends <a href="#scala.reflect.api;Trees;SymTreeApi" title="Trees.this.SymTreeApi">SymTreeApi</a> with <a href="#scala.reflect.api;Trees;NameTreeApi" title="Trees.this.NameTreeApi">NameTreeApi</a> <span class="delimiter">{</span> this: RefTree =&gt;
    <span class="comment">/** The qualifier of the reference.
     *  For example, the `Ident(TermName(&quot;scala&quot;))` part of `Select(Ident(TermName(&quot;scala&quot;)), TermName(&quot;List&quot;))`.
     *  `EmptyTree` for `Ident` instances.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;RefTreeApi.qualifier">qualifier</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Name" id="scala.reflect.api;Trees;RefTreeApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The constructor/extractor for `RefTree` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.RefTreeExtractor" id="scala.reflect.api;Trees.RefTree">RefTree</a>: <a href="#scala.reflect.api;Trees;RefTreeExtractor" title="Trees.this.RefTreeExtractor">RefTreeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `RefTree(qual, name)`.
   *  This AST node corresponds to either Ident, Select or SelectFromTypeTree.
   *  @group Extractors
   */</span>
  abstract class <a title="class RefTreeExtractor extends AnyRef" id="scala.reflect.api;Trees;RefTreeExtractor">RefTreeExtractor</a> <a href="#scala.reflect.api;Trees;RefTreeExtractor" title="Trees.this.RefTreeExtractor" class="delimiter">{</a>
    def <a title="(qualifier: Trees.this.Tree, name: Trees.this.Name)Trees.this.RefTree" id="scala.reflect.api;Trees;RefTreeExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;RefTreeExtractor.apply.qualifier">qualifier</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;RefTreeExtractor.apply.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;RefTree" title="Trees.this.RefTree">RefTree</a>
    def <a title="(refTree: Trees.this.RefTree)Option[(Trees.this.Tree, Trees.this.Name)]" id="scala.reflect.api;Trees;RefTreeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.RefTree" id="scala.reflect.api;Trees;RefTreeExtractor.unapply.refTree">refTree</a>: <a href="#scala.reflect.api;Trees;RefTree" title="Trees.this.RefTree">RefTree</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, Trees.this.Name)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Name<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A tree representing a symbol-defining entity:
   *    1) A declaration or a definition (type, class, object, package, val, var, or def)
   *    2) `Bind` that is used to represent binding occurrences in pattern matches
   *    3) `LabelDef` that is used internally to represent while loops
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.DefTreeApi with Trees.this.SymTree with Trees.this.NameTree" id="scala.reflect.api;Trees;DefTree">DefTree</a> &gt;: Null &lt;: DefTreeApi with SymTree with NameTree

  <span class="comment">/** The API that all def trees support
   *  @group API
   */</span>
  trait <a title="trait DefTreeApi extends AnyRef with Trees.this.SymTreeApi with Trees.this.NameTreeApi" id="scala.reflect.api;Trees;DefTreeApi">DefTreeApi</a> extends <a href="#scala.reflect.api;Trees;SymTreeApi" title="Trees.this.SymTreeApi">SymTreeApi</a> with <a href="#scala.reflect.api;Trees;NameTreeApi" title="Trees.this.NameTreeApi">NameTreeApi</a> <span class="delimiter">{</span> this: DefTree =&gt;
    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Name" id="scala.reflect.api;Trees;DefTreeApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Common base class for all member definitions: types, classes,
   *  objects, packages, vals and vars, defs.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.MemberDefApi with Trees.this.DefTree" id="scala.reflect.api;Trees;MemberDef">MemberDef</a> &gt;: Null &lt;: MemberDefApi with DefTree

  <span class="comment">/** The API that all member defs support
   *  @group API
   */</span>
  trait <a title="trait MemberDefApi extends AnyRef with Trees.this.DefTreeApi" id="scala.reflect.api;Trees;MemberDefApi">MemberDefApi</a> extends <a href="#scala.reflect.api;Trees;DefTreeApi" title="Trees.this.DefTreeApi">DefTreeApi</a> <span class="delimiter">{</span> this: MemberDef =&gt;
    <span class="comment">/** Modifiers of the declared member. */</span>
    def <a title="=&gt; Trees.this.Modifiers" id="scala.reflect.api;Trees;MemberDefApi.mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A packaging, such as `package pid { stats }`
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.PackageDefApi with Trees.this.MemberDef" id="scala.reflect.api;Trees;PackageDef">PackageDef</a> &gt;: Null &lt;: PackageDefApi with MemberDef

  <span class="comment">/** The constructor/extractor for `PackageDef` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.PackageDefExtractor" id="scala.reflect.api;Trees.PackageDef">PackageDef</a>: <a href="#scala.reflect.api;Trees;PackageDefExtractor" title="Trees.this.PackageDefExtractor">PackageDefExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `PackageDef(pid, stats)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `package` pid { stats }
   *  @group Extractors
   */</span>
  abstract class <a title="class PackageDefExtractor extends AnyRef" id="scala.reflect.api;Trees;PackageDefExtractor">PackageDefExtractor</a> <a href="#scala.reflect.api;Trees;PackageDefExtractor" title="Trees.this.PackageDefExtractor" class="delimiter">{</a>
    def <a title="(pid: Trees.this.RefTree, stats: List[Trees.this.Tree])Trees.this.PackageDef" id="scala.reflect.api;Trees;PackageDefExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.RefTree" id="scala.reflect.api;Trees;PackageDefExtractor.apply.pid">pid</a>: <a href="#scala.reflect.api;Trees;RefTree" title="Trees.this.RefTree">RefTree</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;PackageDefExtractor.apply.stats">stats</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;PackageDef" title="Trees.this.PackageDef">PackageDef</a>
    def <a title="(packageDef: Trees.this.PackageDef)Option[(Trees.this.RefTree, List[Trees.this.Tree])]" id="scala.reflect.api;Trees;PackageDefExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.PackageDef" id="scala.reflect.api;Trees;PackageDefExtractor.unapply.packageDef">packageDef</a>: <a href="#scala.reflect.api;Trees;PackageDef" title="Trees.this.PackageDef">PackageDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.RefTree, List[Trees.this.Tree])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>RefTree, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all package defs support
   *  @group API
   */</span>
  trait <a title="trait PackageDefApi extends AnyRef with Trees.this.MemberDefApi" id="scala.reflect.api;Trees;PackageDefApi">PackageDefApi</a> extends <a href="#scala.reflect.api;Trees;MemberDefApi" title="Trees.this.MemberDefApi">MemberDefApi</a> <span class="delimiter">{</span> this: PackageDef =&gt;
    <span class="comment">/** The (possibly, fully-qualified) name of the package. */</span>
    def <a title="=&gt; Trees.this.RefTree" id="scala.reflect.api;Trees;PackageDefApi.pid">pid</a>: <a href="#scala.reflect.api;Trees;RefTree" title="Trees.this.RefTree">RefTree</a>

    <span class="comment">/** Body of the package definition. */</span>
    def <a title="=&gt; List[Trees.this.Tree]" id="scala.reflect.api;Trees;PackageDefApi.stats">stats</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A common base class for class and object definitions.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.ImplDefApi with Trees.this.MemberDef" id="scala.reflect.api;Trees;ImplDef">ImplDef</a> &gt;: Null &lt;: ImplDefApi with MemberDef

  <span class="comment">/** The API that all impl defs support
   *  @group API
   */</span>
  trait <a title="trait ImplDefApi extends AnyRef with Trees.this.MemberDefApi" id="scala.reflect.api;Trees;ImplDefApi">ImplDefApi</a> extends <a href="#scala.reflect.api;Trees;MemberDefApi" title="Trees.this.MemberDefApi">MemberDefApi</a> <span class="delimiter">{</span> this: ImplDef =&gt;
    <span class="comment">/** The body of the definition. */</span>
    def <a title="=&gt; Trees.this.Template" id="scala.reflect.api;Trees;ImplDefApi.impl">impl</a>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A class definition.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.ClassDefApi with Trees.this.ImplDef" id="scala.reflect.api;Trees;ClassDef">ClassDef</a> &gt;: Null &lt;: ClassDefApi with ImplDef

  <span class="comment">/** The constructor/extractor for `ClassDef` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.ClassDefExtractor" id="scala.reflect.api;Trees.ClassDef">ClassDef</a>: <a href="#scala.reflect.api;Trees;ClassDefExtractor" title="Trees.this.ClassDefExtractor">ClassDefExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `ClassDef(mods, name, tparams, impl)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    mods `class` name [tparams] impl
   *
   *  Where impl stands for:
   *
   *    `extends` parents { defs }
   *  @group Extractors
   */</span>
  abstract class <a title="class ClassDefExtractor extends AnyRef" id="scala.reflect.api;Trees;ClassDefExtractor">ClassDefExtractor</a> <a href="#scala.reflect.api;Trees;ClassDefExtractor" title="Trees.this.ClassDefExtractor" class="delimiter">{</a>
    def <a title="(mods: Trees.this.Modifiers, name: Trees.this.TypeName, tparams: List[Trees.this.TypeDef], impl: Trees.this.Template)Trees.this.ClassDef" id="scala.reflect.api;Trees;ClassDefExtractor.apply(6121b2e0f1)">apply</a><span class="delimiter">(</span><a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;ClassDefExtractor.apply(6121b2e0f1).mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.TypeName" id="scala.reflect.api;Trees;ClassDefExtractor.apply(6121b2e0f1).name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TypeName" title="Trees.this.TypeName">TypeName</a>, <a title="List[Trees.this.TypeDef]" id="scala.reflect.api;Trees;ClassDefExtractor.apply(6121b2e0f1).tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, <a title="Trees.this.Template" id="scala.reflect.api;Trees;ClassDefExtractor.apply(6121b2e0f1).impl">impl</a>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;ClassDef" title="Trees.this.ClassDef">ClassDef</a>
    def <a title="(classDef: Trees.this.ClassDef)Option[(Trees.this.Modifiers, Trees.this.TypeName, List[Trees.this.TypeDef], Trees.this.Template)]" id="scala.reflect.api;Trees;ClassDefExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.ClassDef" id="scala.reflect.api;Trees;ClassDefExtractor.unapply.classDef">classDef</a>: <a href="#scala.reflect.api;Trees;ClassDef" title="Trees.this.ClassDef">ClassDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Modifiers, Trees.this.TypeName, List[Trees.this.TypeDef], Trees.this.Template)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Modifiers, TypeName, List<span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, Template<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.classDef]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.classDef` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(sym: Trees.this.Symbol, impl: Trees.this.Template)(implicit token: Trees.this.CompatToken)Trees.this.ClassDef" id="scala.reflect.api;Trees;ClassDefExtractor.apply(61fb86a7cd)">apply</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;ClassDefExtractor.apply(61fb86a7cd).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Template" id="scala.reflect.api;Trees;ClassDefExtractor.apply(61fb86a7cd).impl">impl</a>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Trees.this.CompatToken" id="scala.reflect.api;Trees;ClassDefExtractor.apply(61fb86a7cd).token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Trees.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;ClassDef" title="Trees.this.ClassDef">ClassDef</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Trees.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.classDef" title="(sym: Trees.this.Symbol, impl: Trees.this.Template)Trees.this.ClassDef">classDef</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;ClassDefExtractor.apply(61fb86a7cd).sym" title="Trees.this.Symbol">sym</a>, <a href="#scala.reflect.api;Trees;ClassDefExtractor.apply(61fb86a7cd).impl" title="Trees.this.Template">impl</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all class defs support
   *  @group API
   */</span>
  trait <a title="trait ClassDefApi extends AnyRef with Trees.this.ImplDefApi" id="scala.reflect.api;Trees;ClassDefApi">ClassDefApi</a> extends <a href="#scala.reflect.api;Trees;ImplDefApi" title="Trees.this.ImplDefApi">ImplDefApi</a> <span class="delimiter">{</span> this: ClassDef =&gt;
    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Modifiers" id="scala.reflect.api;Trees;ClassDefApi.mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>

    <span class="comment">/** The name of the class. */</span>
    def <a title="=&gt; Trees.this.TypeName" id="scala.reflect.api;Trees;ClassDefApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TypeName" title="Trees.this.TypeName">TypeName</a>

    <span class="comment">/** The type parameters of the class. */</span>
    def <a title="=&gt; List[Trees.this.TypeDef]" id="scala.reflect.api;Trees;ClassDefApi.tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>

    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Template" id="scala.reflect.api;Trees;ClassDefApi.impl">impl</a>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a>
  <span class="delimiter">}</span>

  <span class="comment">/** An object definition, e.g. `object Foo`.  Internally, objects are
   *  quite frequently called modules to reduce ambiguity.
   *  Eliminated by compiler phase refcheck.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.ModuleDefApi with Trees.this.ImplDef" id="scala.reflect.api;Trees;ModuleDef">ModuleDef</a> &gt;: Null &lt;: ModuleDefApi with ImplDef

  <span class="comment">/** The constructor/extractor for `ModuleDef` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.ModuleDefExtractor" id="scala.reflect.api;Trees.ModuleDef">ModuleDef</a>: <a href="#scala.reflect.api;Trees;ModuleDefExtractor" title="Trees.this.ModuleDefExtractor">ModuleDefExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `ModuleDef(mods, name, impl)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    mods `object` name impl
   *
   *  Where impl stands for:
   *
   *    `extends` parents { defs }
   *  @group Extractors
   */</span>
  abstract class <a title="class ModuleDefExtractor extends AnyRef" id="scala.reflect.api;Trees;ModuleDefExtractor">ModuleDefExtractor</a> <a href="#scala.reflect.api;Trees;ModuleDefExtractor" title="Trees.this.ModuleDefExtractor" class="delimiter">{</a>
    def <a title="(mods: Trees.this.Modifiers, name: Trees.this.TermName, impl: Trees.this.Template)Trees.this.ModuleDef" id="scala.reflect.api;Trees;ModuleDefExtractor.apply(5cce59c3a4)">apply</a><span class="delimiter">(</span><a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;ModuleDefExtractor.apply(5cce59c3a4).mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.TermName" id="scala.reflect.api;Trees;ModuleDefExtractor.apply(5cce59c3a4).name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TermName" title="Trees.this.TermName">TermName</a>, <a title="Trees.this.Template" id="scala.reflect.api;Trees;ModuleDefExtractor.apply(5cce59c3a4).impl">impl</a>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;ModuleDef" title="Trees.this.ModuleDef">ModuleDef</a>
    def <a title="(moduleDef: Trees.this.ModuleDef)Option[(Trees.this.Modifiers, Trees.this.TermName, Trees.this.Template)]" id="scala.reflect.api;Trees;ModuleDefExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.ModuleDef" id="scala.reflect.api;Trees;ModuleDefExtractor.unapply.moduleDef">moduleDef</a>: <a href="#scala.reflect.api;Trees;ModuleDef" title="Trees.this.ModuleDef">ModuleDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Modifiers, Trees.this.TermName, Trees.this.Template)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Modifiers, TermName, Template<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.moduleDef]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.moduleDef` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(sym: Trees.this.Symbol, impl: Trees.this.Template)(implicit token: Trees.this.CompatToken)Trees.this.ModuleDef" id="scala.reflect.api;Trees;ModuleDefExtractor.apply(2ced7ae935)">apply</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;ModuleDefExtractor.apply(2ced7ae935).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Template" id="scala.reflect.api;Trees;ModuleDefExtractor.apply(2ced7ae935).impl">impl</a>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Trees.this.CompatToken" id="scala.reflect.api;Trees;ModuleDefExtractor.apply(2ced7ae935).token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Trees.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;ModuleDef" title="Trees.this.ModuleDef">ModuleDef</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Trees.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.moduleDef" title="(sym: Trees.this.Symbol, impl: Trees.this.Template)Trees.this.ModuleDef">moduleDef</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;ModuleDefExtractor.apply(2ced7ae935).sym" title="Trees.this.Symbol">sym</a>, <a href="#scala.reflect.api;Trees;ModuleDefExtractor.apply(2ced7ae935).impl" title="Trees.this.Template">impl</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all module defs support
   *  @group API
   */</span>
  trait <a title="trait ModuleDefApi extends AnyRef with Trees.this.ImplDefApi" id="scala.reflect.api;Trees;ModuleDefApi">ModuleDefApi</a> extends <a href="#scala.reflect.api;Trees;ImplDefApi" title="Trees.this.ImplDefApi">ImplDefApi</a> <span class="delimiter">{</span> this: ModuleDef =&gt;
    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Modifiers" id="scala.reflect.api;Trees;ModuleDefApi.mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>

    <span class="comment">/** The name of the module. */</span>
    def <a title="=&gt; Trees.this.TermName" id="scala.reflect.api;Trees;ModuleDefApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TermName" title="Trees.this.TermName">TermName</a>

    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Template" id="scala.reflect.api;Trees;ModuleDefApi.impl">impl</a>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A common base class for ValDefs and DefDefs.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.ValOrDefDefApi with Trees.this.MemberDef" id="scala.reflect.api;Trees;ValOrDefDef">ValOrDefDef</a> &gt;: Null &lt;: ValOrDefDefApi with MemberDef

  <span class="comment">/** The API that all val defs and def defs support
   *  @group API
   */</span>
  trait <a title="trait ValOrDefDefApi extends AnyRef with Trees.this.MemberDefApi" id="scala.reflect.api;Trees;ValOrDefDefApi">ValOrDefDefApi</a> extends <a href="#scala.reflect.api;Trees;MemberDefApi" title="Trees.this.MemberDefApi">MemberDefApi</a> <span class="delimiter">{</span> this: ValOrDefDef =&gt;
    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.TermName" id="scala.reflect.api;Trees;ValOrDefDefApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TermName" title="Trees.this.TermName">TermName</a>

    <span class="comment">/** The type ascribed to the definition.
     *  An empty `TypeTree` if the type hasn't been specified explicitly
     *  and is supposed to be inferred.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;ValOrDefDefApi.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The body of the definition.
     *  The `EmptyTree` is the body is empty (e.g. for abstract members).
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;ValOrDefDefApi.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Broadly speaking, a value definition.  All these are encoded as ValDefs:
   *
   *   - immutable values, e.g. &quot;val x&quot;
   *   - mutable values, e.g. &quot;var x&quot; - the MUTABLE flag set in mods
   *   - lazy values, e.g. &quot;lazy val x&quot; - the LAZY flag set in mods
   *   - method parameters, see vparamss in [[scala.reflect.api.Trees#DefDef]] - the PARAM flag is set in mods
   *   - explicit self-types, e.g. class A { self: Bar =&gt; }
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.ValDefApi with Trees.this.ValOrDefDef" id="scala.reflect.api;Trees;ValDef">ValDef</a> &gt;: Null &lt;: ValDefApi with ValOrDefDef

  <span class="comment">/** The constructor/extractor for `ValDef` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.ValDefExtractor" id="scala.reflect.api;Trees.ValDef">ValDef</a>: <a href="#scala.reflect.api;Trees;ValDefExtractor" title="Trees.this.ValDefExtractor">ValDefExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `ValDef(mods, name, tpt, rhs)`.
   *  This AST node corresponds to any of the following Scala code:
   *
   *    mods `val` name: tpt = rhs
   *
   *    mods `var` name: tpt = rhs
   *
   *    mods name: tpt = rhs        // in signatures of function and method definitions
   *
   *    self: Bar =&gt;                // self-types
   *
   *  If the type of a value is not specified explicitly (i.e. is meant to be inferred),
   *  this is expressed by having `tpt` set to `TypeTree()` (but not to an `EmptyTree`!).
   *  @group Extractors
   */</span>
  abstract class <a title="class ValDefExtractor extends AnyRef" id="scala.reflect.api;Trees;ValDefExtractor">ValDefExtractor</a> <a href="#scala.reflect.api;Trees;ValDefExtractor" title="Trees.this.ValDefExtractor" class="delimiter">{</a>
    def <a title="(mods: Trees.this.Modifiers, name: Trees.this.TermName, tpt: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.ValDef" id="scala.reflect.api;Trees;ValDefExtractor.apply(54e2c78944)">apply</a><span class="delimiter">(</span><a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;ValDefExtractor.apply(54e2c78944).mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.TermName" id="scala.reflect.api;Trees;ValDefExtractor.apply(54e2c78944).name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TermName" title="Trees.this.TermName">TermName</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;ValDefExtractor.apply(54e2c78944).tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;ValDefExtractor.apply(54e2c78944).rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;ValDef" title="Trees.this.ValDef">ValDef</a>
    def <a title="(valDef: Trees.this.ValDef)Option[(Trees.this.Modifiers, Trees.this.TermName, Trees.this.Tree, Trees.this.Tree)]" id="scala.reflect.api;Trees;ValDefExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.ValDef" id="scala.reflect.api;Trees;ValDefExtractor.unapply.valDef">valDef</a>: <a href="#scala.reflect.api;Trees;ValDef" title="Trees.this.ValDef">ValDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Modifiers, Trees.this.TermName, Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Modifiers, TermName, Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.valDef]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.valDef` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(sym: Trees.this.Symbol, rhs: Trees.this.Tree)(implicit token: Trees.this.CompatToken)Trees.this.ValDef" id="scala.reflect.api;Trees;ValDefExtractor.apply(528bd513a2)">apply</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;ValDefExtractor.apply(528bd513a2).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;ValDefExtractor.apply(528bd513a2).rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Trees.this.CompatToken" id="scala.reflect.api;Trees;ValDefExtractor.apply(528bd513a2).token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Trees.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;ValDef" title="Trees.this.ValDef">ValDef</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Trees.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.valDef(33dac0daf0)" title="(sym: Trees.this.Symbol, rhs: Trees.this.Tree)Trees.this.ValDef">valDef</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;ValDefExtractor.apply(528bd513a2).sym" title="Trees.this.Symbol">sym</a>, <a href="#scala.reflect.api;Trees;ValDefExtractor.apply(528bd513a2).rhs" title="Trees.this.Tree">rhs</a><span class="delimiter">)</span>

    <span class="comment">/** @see [[InternalApi.valDef]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.valDef` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(sym: Trees.this.Symbol)(implicit token: Trees.this.CompatToken)Trees.this.ValDef" id="scala.reflect.api;Trees;ValDefExtractor.apply(fd64861127)">apply</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;ValDefExtractor.apply(fd64861127).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Trees.this.CompatToken" id="scala.reflect.api;Trees;ValDefExtractor.apply(fd64861127).token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Trees.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;ValDef" title="Trees.this.ValDef">ValDef</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Trees.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.valDef(5d4a47a62f)" title="(sym: Trees.this.Symbol)Trees.this.ValDef">valDef</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;ValDefExtractor.apply(fd64861127).sym" title="Trees.this.Symbol">sym</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all val defs support
   *  @group API
   */</span>
  trait <a title="trait ValDefApi extends AnyRef with Trees.this.ValOrDefDefApi" id="scala.reflect.api;Trees;ValDefApi">ValDefApi</a> extends <a href="#scala.reflect.api;Trees;ValOrDefDefApi" title="Trees.this.ValOrDefDefApi">ValOrDefDefApi</a> <span class="delimiter">{</span> this: ValDef =&gt;
    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Modifiers" id="scala.reflect.api;Trees;ValDefApi.mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>

    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.TermName" id="scala.reflect.api;Trees;ValDefApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TermName" title="Trees.this.TermName">TermName</a>

    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;ValDefApi.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;ValDefApi.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A method or macro definition.
   *  @param name   The name of the method or macro. Can be a type name in case this is a type macro
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.DefDefApi with Trees.this.ValOrDefDef" id="scala.reflect.api;Trees;DefDef">DefDef</a> &gt;: Null &lt;: DefDefApi with ValOrDefDef

  <span class="comment">/** The constructor/extractor for `DefDef` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.DefDefExtractor" id="scala.reflect.api;Trees.DefDef">DefDef</a>: <a href="#scala.reflect.api;Trees;DefDefExtractor" title="Trees.this.DefDefExtractor">DefDefExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `DefDef(mods, name, tparams, vparamss, tpt, rhs)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    mods `def` name[tparams](vparams_1)...(vparams_n): tpt = rhs
   *
   *  If the return type is not specified explicitly (i.e. is meant to be inferred),
   *  this is expressed by having `tpt` set to `TypeTree()` (but not to an `EmptyTree`!).
   *  @group Extractors
   */</span>
  abstract class <a title="class DefDefExtractor extends AnyRef" id="scala.reflect.api;Trees;DefDefExtractor">DefDefExtractor</a> <a href="#scala.reflect.api;Trees;DefDefExtractor" title="Trees.this.DefDefExtractor" class="delimiter">{</a>
    def <a title="(mods: Trees.this.Modifiers, name: Trees.this.TermName, tparams: List[Trees.this.TypeDef], vparamss: List[List[Trees.this.ValDef]], tpt: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.DefDef" id="scala.reflect.api;Trees;DefDefExtractor.apply(d8f4c12dc2)">apply</a><span class="delimiter">(</span><a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;DefDefExtractor.apply(d8f4c12dc2).mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.TermName" id="scala.reflect.api;Trees;DefDefExtractor.apply(d8f4c12dc2).name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TermName" title="Trees.this.TermName">TermName</a>, <a title="List[Trees.this.TypeDef]" id="scala.reflect.api;Trees;DefDefExtractor.apply(d8f4c12dc2).tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, <a title="List[List[Trees.this.ValDef]]" id="scala.reflect.api;Trees;DefDefExtractor.apply(d8f4c12dc2).vparamss">vparamss</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Trees.this.ValDef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;DefDefExtractor.apply(d8f4c12dc2).tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;DefDefExtractor.apply(d8f4c12dc2).rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;DefDef" title="Trees.this.DefDef">DefDef</a>
    def <a title="(defDef: Trees.this.DefDef)Option[(Trees.this.Modifiers, Trees.this.TermName, List[Trees.this.TypeDef], List[List[Trees.this.ValDef]], Trees.this.Tree, Trees.this.Tree)]" id="scala.reflect.api;Trees;DefDefExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.DefDef" id="scala.reflect.api;Trees;DefDefExtractor.unapply.defDef">defDef</a>: <a href="#scala.reflect.api;Trees;DefDef" title="Trees.this.DefDef">DefDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Modifiers, Trees.this.TermName, List[Trees.this.TypeDef], List[List[Trees.this.ValDef]], Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Modifiers, TermName, List<span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, List<span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span>, Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.defDef]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.defDef` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(sym: Trees.this.Symbol, mods: Trees.this.Modifiers, vparamss: List[List[Trees.this.ValDef]], rhs: Trees.this.Tree)(implicit token: Trees.this.CompatToken)Trees.this.DefDef" id="scala.reflect.api;Trees;DefDefExtractor.apply(4c6876ac41)">apply</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;DefDefExtractor.apply(4c6876ac41).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;DefDefExtractor.apply(4c6876ac41).mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>, <a title="List[List[Trees.this.ValDef]]" id="scala.reflect.api;Trees;DefDefExtractor.apply(4c6876ac41).vparamss">vparamss</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Trees.this.ValDef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;DefDefExtractor.apply(4c6876ac41).rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Trees.this.CompatToken" id="scala.reflect.api;Trees;DefDefExtractor.apply(4c6876ac41).token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Trees.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;DefDef" title="Trees.this.DefDef">DefDef</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Trees.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.defDef(e9cfc2bd3f)" title="(sym: Trees.this.Symbol, mods: Trees.this.Modifiers, vparamss: List[List[Trees.this.ValDef]], rhs: Trees.this.Tree)Trees.this.DefDef">defDef</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;DefDefExtractor.apply(4c6876ac41).sym" title="Trees.this.Symbol">sym</a>, <a href="#scala.reflect.api;Trees;DefDefExtractor.apply(4c6876ac41).mods" title="Trees.this.Modifiers">mods</a>, <a href="#scala.reflect.api;Trees;DefDefExtractor.apply(4c6876ac41).vparamss" title="List[List[Trees.this.ValDef]]">vparamss</a>, <a href="#scala.reflect.api;Trees;DefDefExtractor.apply(4c6876ac41).rhs" title="Trees.this.Tree">rhs</a><span class="delimiter">)</span>

    <span class="comment">/** @see [[InternalApi.defDef]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.defDef` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(sym: Trees.this.Symbol, vparamss: List[List[Trees.this.ValDef]], rhs: Trees.this.Tree)(implicit token: Trees.this.CompatToken)Trees.this.DefDef" id="scala.reflect.api;Trees;DefDefExtractor.apply(41a79af49d)">apply</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;DefDefExtractor.apply(41a79af49d).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>, <a title="List[List[Trees.this.ValDef]]" id="scala.reflect.api;Trees;DefDefExtractor.apply(41a79af49d).vparamss">vparamss</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Trees.this.ValDef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;DefDefExtractor.apply(41a79af49d).rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Trees.this.CompatToken" id="scala.reflect.api;Trees;DefDefExtractor.apply(41a79af49d).token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Trees.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;DefDef" title="Trees.this.DefDef">DefDef</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Trees.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.defDef(b3ef84d69e)" title="(sym: Trees.this.Symbol, vparamss: List[List[Trees.this.ValDef]], rhs: Trees.this.Tree)Trees.this.DefDef">defDef</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;DefDefExtractor.apply(41a79af49d).sym" title="Trees.this.Symbol">sym</a>, <a href="#scala.reflect.api;Trees;DefDefExtractor.apply(41a79af49d).vparamss" title="List[List[Trees.this.ValDef]]">vparamss</a>, <a href="#scala.reflect.api;Trees;DefDefExtractor.apply(41a79af49d).rhs" title="Trees.this.Tree">rhs</a><span class="delimiter">)</span>

    <span class="comment">/** @see [[InternalApi.defDef]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.defDef` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(sym: Trees.this.Symbol, mods: Trees.this.Modifiers, rhs: Trees.this.Tree)(implicit token: Trees.this.CompatToken)Trees.this.DefDef" id="scala.reflect.api;Trees;DefDefExtractor.apply(2681fd6c37)">apply</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;DefDefExtractor.apply(2681fd6c37).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;DefDefExtractor.apply(2681fd6c37).mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;DefDefExtractor.apply(2681fd6c37).rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Trees.this.CompatToken" id="scala.reflect.api;Trees;DefDefExtractor.apply(2681fd6c37).token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Trees.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;DefDef" title="Trees.this.DefDef">DefDef</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Trees.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.defDef(d659df50eb)" title="(sym: Trees.this.Symbol, mods: Trees.this.Modifiers, rhs: Trees.this.Tree)Trees.this.DefDef">defDef</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;DefDefExtractor.apply(2681fd6c37).sym" title="Trees.this.Symbol">sym</a>, <a href="#scala.reflect.api;Trees;DefDefExtractor.apply(2681fd6c37).mods" title="Trees.this.Modifiers">mods</a>, <a href="#scala.reflect.api;Trees;DefDefExtractor.apply(2681fd6c37).rhs" title="Trees.this.Tree">rhs</a><span class="delimiter">)</span>

    <span class="comment">/** @see [[InternalApi.defDef]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.defDef` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(sym: Trees.this.Symbol, rhs: Trees.this.Tree)(implicit token: Trees.this.CompatToken)Trees.this.DefDef" id="scala.reflect.api;Trees;DefDefExtractor.apply(8ff1aee89d)">apply</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;DefDefExtractor.apply(8ff1aee89d).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;DefDefExtractor.apply(8ff1aee89d).rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Trees.this.CompatToken" id="scala.reflect.api;Trees;DefDefExtractor.apply(8ff1aee89d).token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Trees.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;DefDef" title="Trees.this.DefDef">DefDef</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Trees.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.defDef(02bbc3ad78)" title="(sym: Trees.this.Symbol, rhs: Trees.this.Tree)Trees.this.DefDef">defDef</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;DefDefExtractor.apply(8ff1aee89d).sym" title="Trees.this.Symbol">sym</a>, <a href="#scala.reflect.api;Trees;DefDefExtractor.apply(8ff1aee89d).rhs" title="Trees.this.Tree">rhs</a><span class="delimiter">)</span>

    <span class="comment">/** @see [[InternalApi.defDef]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.defDef` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(sym: Trees.this.Symbol, rhs: List[List[Trees.this.Symbol]] =&gt; Trees.this.Tree)(implicit token: Trees.this.CompatToken)Trees.this.DefDef" id="scala.reflect.api;Trees;DefDefExtractor.apply(ed81e2a2af)">apply</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;DefDefExtractor.apply(ed81e2a2af).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>, <a title="List[List[Trees.this.Symbol]] =&gt; Trees.this.Tree" id="scala.reflect.api;Trees;DefDefExtractor.apply(ed81e2a2af).rhs">rhs</a>: List<span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span> =&gt; Tree<span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Trees.this.CompatToken" id="scala.reflect.api;Trees;DefDefExtractor.apply(ed81e2a2af).token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Trees.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;DefDef" title="Trees.this.DefDef">DefDef</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Trees.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.defDef(6b19a2cb0b)" title="(sym: Trees.this.Symbol, rhs: List[List[Trees.this.Symbol]] =&gt; Trees.this.Tree)Trees.this.DefDef">defDef</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;DefDefExtractor.apply(ed81e2a2af).sym" title="Trees.this.Symbol">sym</a>, <a href="#scala.reflect.api;Trees;DefDefExtractor.apply(ed81e2a2af).rhs" title="List[List[Trees.this.Symbol]] =&gt; Trees.this.Tree">rhs</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all def defs support
   *  @group API
   */</span>
  trait <a title="trait DefDefApi extends AnyRef with Trees.this.ValOrDefDefApi" id="scala.reflect.api;Trees;DefDefApi">DefDefApi</a> extends <a href="#scala.reflect.api;Trees;ValOrDefDefApi" title="Trees.this.ValOrDefDefApi">ValOrDefDefApi</a> <span class="delimiter">{</span> this: DefDef =&gt;
    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Modifiers" id="scala.reflect.api;Trees;DefDefApi.mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>

    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.TermName" id="scala.reflect.api;Trees;DefDefApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TermName" title="Trees.this.TermName">TermName</a>

    <span class="comment">/** The type parameters of the method. */</span>
    def <a title="=&gt; List[Trees.this.TypeDef]" id="scala.reflect.api;Trees;DefDefApi.tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>

    <span class="comment">/** The parameter lists of the method. */</span>
    def <a title="=&gt; List[List[Trees.this.ValDef]]" id="scala.reflect.api;Trees;DefDefApi.vparamss">vparamss</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Trees.this.ValDef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span>

    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;DefDefApi.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;DefDefApi.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** An abstract type, a type parameter, or a type alias.
   *  Eliminated by erasure.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.TypeDefApi with Trees.this.MemberDef" id="scala.reflect.api;Trees;TypeDef">TypeDef</a> &gt;: Null &lt;: TypeDefApi with MemberDef

  <span class="comment">/** The constructor/extractor for `TypeDef` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.TypeDefExtractor" id="scala.reflect.api;Trees.TypeDef">TypeDef</a>: <a href="#scala.reflect.api;Trees;TypeDefExtractor" title="Trees.this.TypeDefExtractor">TypeDefExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `TypeDef(mods, name, tparams, rhs)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    mods `type` name[tparams] = rhs
   *
   *    mods `type` name[tparams] &gt;: lo &lt;: hi
   *
   *  First usage illustrates `TypeDefs` representing type aliases and type parameters.
   *  Second usage illustrates `TypeDefs` representing abstract types,
   *  where lo and hi are both `TypeBoundsTrees` and `Modifier.deferred` is set in mods.
   *  @group Extractors
   */</span>
  abstract class <a title="class TypeDefExtractor extends AnyRef" id="scala.reflect.api;Trees;TypeDefExtractor">TypeDefExtractor</a> <a href="#scala.reflect.api;Trees;TypeDefExtractor" title="Trees.this.TypeDefExtractor" class="delimiter">{</a>
    def <a title="(mods: Trees.this.Modifiers, name: Trees.this.TypeName, tparams: List[Trees.this.TypeDef], rhs: Trees.this.Tree)Trees.this.TypeDef" id="scala.reflect.api;Trees;TypeDefExtractor.apply(26a974d728)">apply</a><span class="delimiter">(</span><a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;TypeDefExtractor.apply(26a974d728).mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.TypeName" id="scala.reflect.api;Trees;TypeDefExtractor.apply(26a974d728).name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TypeName" title="Trees.this.TypeName">TypeName</a>, <a title="List[Trees.this.TypeDef]" id="scala.reflect.api;Trees;TypeDefExtractor.apply(26a974d728).tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TypeDefExtractor.apply(26a974d728).rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;TypeDef" title="Trees.this.TypeDef">TypeDef</a>
    def <a title="(typeDef: Trees.this.TypeDef)Option[(Trees.this.Modifiers, Trees.this.TypeName, List[Trees.this.TypeDef], Trees.this.Tree)]" id="scala.reflect.api;Trees;TypeDefExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.TypeDef" id="scala.reflect.api;Trees;TypeDefExtractor.unapply.typeDef">typeDef</a>: <a href="#scala.reflect.api;Trees;TypeDef" title="Trees.this.TypeDef">TypeDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Modifiers, Trees.this.TypeName, List[Trees.this.TypeDef], Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Modifiers, TypeName, List<span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, Tree<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.typeDef]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.typeDef` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(sym: Trees.this.Symbol, rhs: Trees.this.Tree)(implicit token: Trees.this.CompatToken)Trees.this.TypeDef" id="scala.reflect.api;Trees;TypeDefExtractor.apply(b40ce12fad)">apply</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;TypeDefExtractor.apply(b40ce12fad).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TypeDefExtractor.apply(b40ce12fad).rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Trees.this.CompatToken" id="scala.reflect.api;Trees;TypeDefExtractor.apply(b40ce12fad).token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Trees.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;TypeDef" title="Trees.this.TypeDef">TypeDef</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Trees.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.typeDef(2dba5c5981)" title="(sym: Trees.this.Symbol, rhs: Trees.this.Tree)Trees.this.TypeDef">typeDef</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;TypeDefExtractor.apply(b40ce12fad).sym" title="Trees.this.Symbol">sym</a>, <a href="#scala.reflect.api;Trees;TypeDefExtractor.apply(b40ce12fad).rhs" title="Trees.this.Tree">rhs</a><span class="delimiter">)</span>

    <span class="comment">/** @see [[InternalApi.typeDef]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.typeDef` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(sym: Trees.this.Symbol)(implicit token: Trees.this.CompatToken)Trees.this.TypeDef" id="scala.reflect.api;Trees;TypeDefExtractor.apply(43397f6a81)">apply</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;TypeDefExtractor.apply(43397f6a81).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Trees.this.CompatToken" id="scala.reflect.api;Trees;TypeDefExtractor.apply(43397f6a81).token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Trees.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;TypeDef" title="Trees.this.TypeDef">TypeDef</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Trees.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.typeDef(713287f3b8)" title="(sym: Trees.this.Symbol)Trees.this.TypeDef">typeDef</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;TypeDefExtractor.apply(43397f6a81).sym" title="Trees.this.Symbol">sym</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all type defs support
   *  @group API
   */</span>
  trait <a title="trait TypeDefApi extends AnyRef with Trees.this.MemberDefApi" id="scala.reflect.api;Trees;TypeDefApi">TypeDefApi</a> extends <a href="#scala.reflect.api;Trees;MemberDefApi" title="Trees.this.MemberDefApi">MemberDefApi</a> <span class="delimiter">{</span> this: TypeDef =&gt;
    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Modifiers" id="scala.reflect.api;Trees;TypeDefApi.mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>

    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.TypeName" id="scala.reflect.api;Trees;TypeDefApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TypeName" title="Trees.this.TypeName">TypeName</a>

    <span class="comment">/** The type parameters of this type definition. */</span>
    def <a title="=&gt; List[Trees.this.TypeDef]" id="scala.reflect.api;Trees;TypeDefApi.tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>

    <span class="comment">/** The body of the definition.
     *  The `EmptyTree` is the body is empty (e.g. for abstract type members).
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;TypeDefApi.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A labelled expression.  Not expressible in language syntax, but
   *  generated by the compiler to simulate while/do-while loops, and
   *  also by the pattern matcher.
   *
   *  The label acts much like a nested function, where `params` represents
   *  the incoming parameters.  The symbol given to the LabelDef should have
   *  a MethodType, as if it were a nested function.
   *
   *  Jumps are apply nodes attributed with a label's symbol.  The
   *  arguments from the apply node will be passed to the label and
   *  assigned to the Idents.
   *
   *  Forward jumps within a block are allowed.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.LabelDefApi with Trees.this.DefTree with Trees.this.TermTree" id="scala.reflect.api;Trees;LabelDef">LabelDef</a> &gt;: Null &lt;: LabelDefApi with DefTree with TermTree

  <span class="comment">/** The constructor/extractor for `LabelDef` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.LabelDefExtractor" id="scala.reflect.api;Trees.LabelDef">LabelDef</a>: <a href="#scala.reflect.api;Trees;LabelDefExtractor" title="Trees.this.LabelDefExtractor">LabelDefExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `LabelDef(name, params, rhs)`.
   *
   *  This AST node does not have direct correspondence to Scala code.
   *  It is used for tailcalls and like.
   *  For example, while/do are desugared to label defs as follows:
   *  {{{
   *    while (cond) body ==&gt; LabelDef(\$L, List(), if (cond) { body; L\$() } else ())
   *  }}}
   *  {{{
   *    do body while (cond) ==&gt; LabelDef(\$L, List(), body; if (cond) L\$() else ())
   *  }}}
   *  @group Extractors
   */</span>
  abstract class <a title="class LabelDefExtractor extends AnyRef" id="scala.reflect.api;Trees;LabelDefExtractor">LabelDefExtractor</a> <a href="#scala.reflect.api;Trees;LabelDefExtractor" title="Trees.this.LabelDefExtractor" class="delimiter">{</a>
    def <a title="(name: Trees.this.TermName, params: List[Trees.this.Ident], rhs: Trees.this.Tree)Trees.this.LabelDef" id="scala.reflect.api;Trees;LabelDefExtractor.apply(4e97a71d31)">apply</a><span class="delimiter">(</span><a title="Trees.this.TermName" id="scala.reflect.api;Trees;LabelDefExtractor.apply(4e97a71d31).name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TermName" title="Trees.this.TermName">TermName</a>, <a title="List[Trees.this.Ident]" id="scala.reflect.api;Trees;LabelDefExtractor.apply(4e97a71d31).params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Ident]">List</a><span class="delimiter">[</span>Ident<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;LabelDefExtractor.apply(4e97a71d31).rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;LabelDef" title="Trees.this.LabelDef">LabelDef</a>
    def <a title="(labelDef: Trees.this.LabelDef)Option[(Trees.this.TermName, List[Trees.this.Ident], Trees.this.Tree)]" id="scala.reflect.api;Trees;LabelDefExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.LabelDef" id="scala.reflect.api;Trees;LabelDefExtractor.unapply.labelDef">labelDef</a>: <a href="#scala.reflect.api;Trees;LabelDef" title="Trees.this.LabelDef">LabelDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.TermName, List[Trees.this.Ident], Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>TermName, List<span class="delimiter">[</span>Ident<span class="delimiter">]</span>, Tree<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.labelDef]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.labelDef` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(sym: Trees.this.Symbol, params: List[Trees.this.Symbol], rhs: Trees.this.Tree)(implicit token: Trees.this.CompatToken)Trees.this.LabelDef" id="scala.reflect.api;Trees;LabelDefExtractor.apply(f544783e72)">apply</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;LabelDefExtractor.apply(f544783e72).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>, <a title="List[Trees.this.Symbol]" id="scala.reflect.api;Trees;LabelDefExtractor.apply(f544783e72).params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;LabelDefExtractor.apply(f544783e72).rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Trees.this.CompatToken" id="scala.reflect.api;Trees;LabelDefExtractor.apply(f544783e72).token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Trees.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;LabelDef" title="Trees.this.LabelDef">LabelDef</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Trees.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.labelDef" title="(sym: Trees.this.Symbol, params: List[Trees.this.Symbol], rhs: Trees.this.Tree)Trees.this.LabelDef">labelDef</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;LabelDefExtractor.apply(f544783e72).sym" title="Trees.this.Symbol">sym</a>, <a href="#scala.reflect.api;Trees;LabelDefExtractor.apply(f544783e72).params" title="List[Trees.this.Symbol]">params</a>, <a href="#scala.reflect.api;Trees;LabelDefExtractor.apply(f544783e72).rhs" title="Trees.this.Tree">rhs</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all label defs support
   *  @group API
   */</span>
  trait <a title="trait LabelDefApi extends AnyRef with Trees.this.DefTreeApi with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;LabelDefApi">LabelDefApi</a> extends <a href="#scala.reflect.api;Trees;DefTreeApi" title="Trees.this.DefTreeApi">DefTreeApi</a> with <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: LabelDef =&gt;
    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.TermName" id="scala.reflect.api;Trees;LabelDefApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TermName" title="Trees.this.TermName">TermName</a>

    <span class="comment">/** Label's parameters - names that can be used in the body of the label.
     *  See the example for [[scala.reflect.api.Trees#LabelDefExtractor]].
     */</span>
    def <a title="=&gt; List[Trees.this.Ident]" id="scala.reflect.api;Trees;LabelDefApi.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Ident]">List</a><span class="delimiter">[</span>Ident<span class="delimiter">]</span>

    <span class="comment">/** The body of the label.
     *  See the example for [[scala.reflect.api.Trees#LabelDefExtractor]].
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;LabelDefApi.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Import selector (not a tree, but a component of the `Import` tree)
   *
   *  Representation of an imported name its optional rename and their optional positions
   *
   *  Eliminated by typecheck.
   *
   * @param name      the imported name
   * @param namePos   its position or -1 if undefined
   * @param rename    the name the import is renamed to (== name if no renaming)
   * @param renamePos the position of the rename or -1 if undefined
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.ImportSelectorApi" id="scala.reflect.api;Trees;ImportSelector">ImportSelector</a> &gt;: Null &lt;: AnyRef with ImportSelectorApi

  <span class="comment">/** The constructor/extractor for `ImportSelector` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.ImportSelectorExtractor" id="scala.reflect.api;Trees.ImportSelector">ImportSelector</a>: <a href="#scala.reflect.api;Trees;ImportSelectorExtractor" title="Trees.this.ImportSelectorExtractor">ImportSelectorExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `ImportSelector(name:, namePos, rename, renamePos)`.
   *  This is not an AST node, it is used as a part of the `Import` node.
   *  @group Extractors
   */</span>
  abstract class <a title="class ImportSelectorExtractor extends AnyRef" id="scala.reflect.api;Trees;ImportSelectorExtractor">ImportSelectorExtractor</a> <a href="#scala.reflect.api;Trees;ImportSelectorExtractor" title="Trees.this.ImportSelectorExtractor" class="delimiter">{</a>
    def <a title="(name: Trees.this.Name, namePos: Int, rename: Trees.this.Name, renamePos: Int)Trees.this.ImportSelector" id="scala.reflect.api;Trees;ImportSelectorExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Name" id="scala.reflect.api;Trees;ImportSelectorExtractor.apply.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>, <a title="Int" id="scala.reflect.api;Trees;ImportSelectorExtractor.apply.namePos">namePos</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;ImportSelectorExtractor.apply.rename">rename</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>, <a title="Int" id="scala.reflect.api;Trees;ImportSelectorExtractor.apply.renamePos">renamePos</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;ImportSelector" title="Trees.this.ImportSelector">ImportSelector</a>
    def <a title="(importSelector: Trees.this.ImportSelector)Option[(Trees.this.Name, Int, Trees.this.Name, Int)]" id="scala.reflect.api;Trees;ImportSelectorExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.ImportSelector" id="scala.reflect.api;Trees;ImportSelectorExtractor.unapply.importSelector">importSelector</a>: <a href="#scala.reflect.api;Trees;ImportSelector" title="Trees.this.ImportSelector">ImportSelector</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Name, Int, Trees.this.Name, Int)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Name, Int, Name, Int<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all import selectors support
   *  @group API
   */</span>
  trait <a title="trait ImportSelectorApi extends AnyRef" id="scala.reflect.api;Trees;ImportSelectorApi">ImportSelectorApi</a> <span class="delimiter">{</span> this: ImportSelector =&gt;
    <span class="comment">/** The imported name. */</span>
    def <a title="=&gt; Trees.this.Name" id="scala.reflect.api;Trees;ImportSelectorApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>

    <span class="comment">/** Offset of the position of the importing part of the selector in the source file.
     *  Is equal to -1 is the position is unknown.
     */</span>
    def <a title="=&gt; Int" id="scala.reflect.api;Trees;ImportSelectorApi.namePos">namePos</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>

    <span class="comment">/** The name the import is renamed to.
     *  Is equal to `name` if it's not a renaming import.
     */</span>
    def <a title="=&gt; Trees.this.Name" id="scala.reflect.api;Trees;ImportSelectorApi.rename">rename</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>

    <span class="comment">/** Offset of the position of the renaming part of the selector in the source file.
     *  Is equal to -1 is the position is unknown.
     */</span>
    def <a title="=&gt; Int" id="scala.reflect.api;Trees;ImportSelectorApi.renamePos">renamePos</a>: <a href="../../Int.scala.html#scala;Int" title="Int">Int</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Import clause
   *
   *  @param expr
   *  @param selectors
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.ImportApi with Trees.this.SymTree" id="scala.reflect.api;Trees;Import">Import</a> &gt;: Null &lt;: ImportApi with SymTree

  <span class="comment">/** The constructor/extractor for `Import` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.ImportExtractor" id="scala.reflect.api;Trees.Import">Import</a>: <a href="#scala.reflect.api;Trees;ImportExtractor" title="Trees.this.ImportExtractor">ImportExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Import(expr, selectors)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    import expr.{selectors}
   *
   *  Selectors are a list of ImportSelectors, which conceptually are pairs of names (from, to).
   *  The last (and maybe only name) may be a nme.WILDCARD. For instance:
   *
   *    import qual.{x, y =&gt; z, _}
   *
   *  Would be represented as:
   *
   *    Import(qual, List((&quot;x&quot;, &quot;x&quot;), (&quot;y&quot;, &quot;z&quot;), (WILDCARD, null)))
   *
   *  The symbol of an `Import` is an import symbol @see Symbol.newImport.
   *  It's used primarily as a marker to check that the import has been typechecked.
   *  @group Extractors
   */</span>
  abstract class <a title="class ImportExtractor extends AnyRef" id="scala.reflect.api;Trees;ImportExtractor">ImportExtractor</a> <a href="#scala.reflect.api;Trees;ImportExtractor" title="Trees.this.ImportExtractor" class="delimiter">{</a>
    def <a title="(expr: Trees.this.Tree, selectors: List[Trees.this.ImportSelector])Trees.this.Import" id="scala.reflect.api;Trees;ImportExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;ImportExtractor.apply.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.ImportSelector]" id="scala.reflect.api;Trees;ImportExtractor.apply.selectors">selectors</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.ImportSelector]">List</a><span class="delimiter">[</span>ImportSelector<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Import" title="Trees.this.Import">Import</a>
    def <a title="(import_: Trees.this.Import)Option[(Trees.this.Tree, List[Trees.this.ImportSelector])]" id="scala.reflect.api;Trees;ImportExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Import" id="scala.reflect.api;Trees;ImportExtractor.unapply.import_">import_</a> : <a href="#scala.reflect.api;Trees;Import" title="Trees.this.Import">Import</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, List[Trees.this.ImportSelector])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>ImportSelector<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all imports support
   *  @group API
   */</span>
  trait <a title="trait ImportApi extends AnyRef with Trees.this.SymTreeApi" id="scala.reflect.api;Trees;ImportApi">ImportApi</a> extends <a href="#scala.reflect.api;Trees;SymTreeApi" title="Trees.this.SymTreeApi">SymTreeApi</a> <span class="delimiter">{</span> this: Import =&gt;
    <span class="comment">/** The qualifier of the import.
     *  See the example for [[scala.reflect.api.Trees#ImportExtractor]].
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;ImportApi.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The selectors of the import.
     *  See the example for [[scala.reflect.api.Trees#ImportExtractor]].
     */</span>
    def <a title="=&gt; List[Trees.this.ImportSelector]" id="scala.reflect.api;Trees;ImportApi.selectors">selectors</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.ImportSelector]">List</a><span class="delimiter">[</span>ImportSelector<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Instantiation template of a class or trait
   *
   *  @param parents
   *  @param body
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.TemplateApi with Trees.this.SymTree" id="scala.reflect.api;Trees;Template">Template</a> &gt;: Null &lt;: TemplateApi with SymTree

  <span class="comment">/** The constructor/extractor for `Template` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.TemplateExtractor" id="scala.reflect.api;Trees.Template">Template</a>: <a href="#scala.reflect.api;Trees;TemplateExtractor" title="Trees.this.TemplateExtractor">TemplateExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Template(parents, self, body)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `extends` parents { self =&gt; body }
   *
   *  In case when the self-type annotation is missing, it is represented as
   *  an empty value definition with nme.WILDCARD as name and NoType as type.
   *
   *  The symbol of a template is a local dummy. @see Symbol.newLocalDummy
   *  The owner of the local dummy is the enclosing trait or class.
   *  The local dummy is itself the owner of any local blocks. For example:
   *
   *    class C {
   *      def foo { // owner is C
   *        def bar  // owner is local dummy
   *      }
   *    }
   *  @group Extractors
   */</span>
  abstract class <a title="class TemplateExtractor extends AnyRef" id="scala.reflect.api;Trees;TemplateExtractor">TemplateExtractor</a> <a href="#scala.reflect.api;Trees;TemplateExtractor" title="Trees.this.TemplateExtractor" class="delimiter">{</a>
    def <a title="(parents: List[Trees.this.Tree], self: Trees.this.ValDef, body: List[Trees.this.Tree])Trees.this.Template" id="scala.reflect.api;Trees;TemplateExtractor.apply">apply</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;TemplateExtractor.apply.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="Trees.this.ValDef" id="scala.reflect.api;Trees;TemplateExtractor.apply.self">self</a>: <a href="#scala.reflect.api;Trees;ValDef" title="Trees.this.ValDef">ValDef</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;TemplateExtractor.apply.body">body</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a>
    def <a title="(template: Trees.this.Template)Option[(List[Trees.this.Tree], Trees.this.ValDef, List[Trees.this.Tree])]" id="scala.reflect.api;Trees;TemplateExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Template" id="scala.reflect.api;Trees;TemplateExtractor.unapply.template">template</a>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(List[Trees.this.Tree], Trees.this.ValDef, List[Trees.this.Tree])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span>, ValDef, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all templates support
   *  @group API
   */</span>
  trait <a title="trait TemplateApi extends AnyRef with Trees.this.SymTreeApi" id="scala.reflect.api;Trees;TemplateApi">TemplateApi</a> extends <a href="#scala.reflect.api;Trees;SymTreeApi" title="Trees.this.SymTreeApi">SymTreeApi</a> <span class="delimiter">{</span> this: Template =&gt;
    <span class="comment">/** Superclasses of the template. */</span>
    def <a title="=&gt; List[Trees.this.Tree]" id="scala.reflect.api;Trees;TemplateApi.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

    <span class="comment">/** Self type of the template.
     *  Is equal to `noSelfType` if the self type is not specified.
     */</span>
    def <a title="=&gt; Trees.this.ValDef" id="scala.reflect.api;Trees;TemplateApi.self">self</a>: <a href="#scala.reflect.api;Trees;ValDef" title="Trees.this.ValDef">ValDef</a>

    <span class="comment">/** Body of the template.
     */</span>
    def <a title="=&gt; List[Trees.this.Tree]" id="scala.reflect.api;Trees;TemplateApi.body">body</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Block of expressions (semicolon separated expressions)
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.BlockApi with Trees.this.TermTree" id="scala.reflect.api;Trees;Block">Block</a> &gt;: Null &lt;: BlockApi with TermTree

  <span class="comment">/** The constructor/extractor for `Block` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.BlockExtractor" id="scala.reflect.api;Trees.Block(fcd816a793)">Block</a>: <a href="#scala.reflect.api;Trees;BlockExtractor" title="Trees.this.BlockExtractor">BlockExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Block(stats, expr)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    { stats; expr }
   *
   *  If the block is empty, the `expr` is set to `Literal(Constant(()))`.
   *  @group Extractors
   */</span>
  abstract class <a title="class BlockExtractor extends AnyRef" id="scala.reflect.api;Trees;BlockExtractor">BlockExtractor</a> <a href="#scala.reflect.api;Trees;BlockExtractor" title="Trees.this.BlockExtractor" class="delimiter">{</a>
    def <a title="(stats: List[Trees.this.Tree], expr: Trees.this.Tree)Trees.this.Block" id="scala.reflect.api;Trees;BlockExtractor.apply">apply</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;BlockExtractor.apply.stats">stats</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;BlockExtractor.apply.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Block" title="Trees.this.Block">Block</a>
    def <a title="(block: Trees.this.Block)Option[(List[Trees.this.Tree], Trees.this.Tree)]" id="scala.reflect.api;Trees;BlockExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Block" id="scala.reflect.api;Trees;BlockExtractor.unapply.block">block</a>: <a href="#scala.reflect.api;Trees;Block" title="Trees.this.Block">Block</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(List[Trees.this.Tree], Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span>, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all blocks support
   *  @group API
   */</span>
  trait <a title="trait BlockApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;BlockApi">BlockApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: Block =&gt;
    <span class="comment">/** All, but the last, expressions in the block.
     *  Can very well be an empty list.
     */</span>
    def <a title="=&gt; List[Trees.this.Tree]" id="scala.reflect.api;Trees;BlockApi.stats">stats</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

    <span class="comment">/** The last expression in the block. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;BlockApi.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Case clause in a pattern match.
   *  (except for occurrences in switch statements).
   *  Eliminated by compiler phases patmat (in the new pattern matcher of 2.10) or explicitouter (in the old pre-2.10 pattern matcher)
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.CaseDefApi with Trees.this.Tree" id="scala.reflect.api;Trees;CaseDef">CaseDef</a> &gt;: Null &lt;: CaseDefApi with Tree

  <span class="comment">/** The constructor/extractor for `CaseDef` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.CaseDefExtractor" id="scala.reflect.api;Trees.CaseDef(8e199c83f0)">CaseDef</a>: <a href="#scala.reflect.api;Trees;CaseDefExtractor" title="Trees.this.CaseDefExtractor">CaseDefExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `CaseDef(pat, guard, body)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `case` pat `if` guard =&gt; body
   *
   *  If the guard is not present, the `guard` is set to `EmptyTree`.
   *  If the body is not specified, the `body` is set to `Literal(Constant(()))`
   *  @group Extractors
   */</span>
  abstract class <a title="class CaseDefExtractor extends AnyRef" id="scala.reflect.api;Trees;CaseDefExtractor">CaseDefExtractor</a> <a href="#scala.reflect.api;Trees;CaseDefExtractor" title="Trees.this.CaseDefExtractor" class="delimiter">{</a>
    def <a title="(pat: Trees.this.Tree, guard: Trees.this.Tree, body: Trees.this.Tree)Trees.this.CaseDef" id="scala.reflect.api;Trees;CaseDefExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;CaseDefExtractor.apply.pat">pat</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;CaseDefExtractor.apply.guard">guard</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;CaseDefExtractor.apply.body">body</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;CaseDef" title="Trees.this.CaseDef">CaseDef</a>
    def <a title="(caseDef: Trees.this.CaseDef)Option[(Trees.this.Tree, Trees.this.Tree, Trees.this.Tree)]" id="scala.reflect.api;Trees;CaseDefExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.CaseDef" id="scala.reflect.api;Trees;CaseDefExtractor.unapply.caseDef">caseDef</a>: <a href="#scala.reflect.api;Trees;CaseDef" title="Trees.this.CaseDef">CaseDef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all case defs support
   *  @group API
   */</span>
  trait <a title="trait CaseDefApi extends AnyRef with Trees.this.TreeApi" id="scala.reflect.api;Trees;CaseDefApi">CaseDefApi</a> extends <a href="#scala.reflect.api;Trees;TreeApi" title="Trees.this.TreeApi">TreeApi</a> <span class="delimiter">{</span> this: CaseDef =&gt;
    <span class="comment">/** The pattern of the pattern matching clause. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;CaseDefApi.pat">pat</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The guard of the pattern matching clause.
     *  Is equal to `EmptyTree` if the guard is not specified.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;CaseDefApi.guard">guard</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The body of the pattern matching clause.
     *  Is equal to `Literal(Constant(()))` if the body is not specified.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;CaseDefApi.body">body</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Alternatives of patterns.
   *
   * Eliminated by compiler phases Eliminated by compiler phases patmat (in the new pattern matcher of 2.10) or explicitouter (in the old pre-2.10 pattern matcher),
   * except for
   *  occurrences in encoded Switch stmt (i.e. remaining Match(CaseDef(...)))
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.AlternativeApi with Trees.this.TermTree" id="scala.reflect.api;Trees;Alternative">Alternative</a> &gt;: Null &lt;: AlternativeApi with TermTree

  <span class="comment">/** The constructor/extractor for `Alternative` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.AlternativeExtractor" id="scala.reflect.api;Trees.Alternative">Alternative</a>: <a href="#scala.reflect.api;Trees;AlternativeExtractor" title="Trees.this.AlternativeExtractor">AlternativeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Alternative(trees)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    pat1 | ... | patn
   *  @group Extractors
   */</span>
  abstract class <a title="class AlternativeExtractor extends AnyRef" id="scala.reflect.api;Trees;AlternativeExtractor">AlternativeExtractor</a> <a href="#scala.reflect.api;Trees;AlternativeExtractor" title="Trees.this.AlternativeExtractor" class="delimiter">{</a>
    def <a title="(trees: List[Trees.this.Tree])Trees.this.Alternative" id="scala.reflect.api;Trees;AlternativeExtractor.apply">apply</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;AlternativeExtractor.apply.trees">trees</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Alternative" title="Trees.this.Alternative">Alternative</a>
    def <a title="(alternative: Trees.this.Alternative)Option[List[Trees.this.Tree]]" id="scala.reflect.api;Trees;AlternativeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Alternative" id="scala.reflect.api;Trees;AlternativeExtractor.unapply.alternative">alternative</a>: <a href="#scala.reflect.api;Trees;Alternative" title="Trees.this.Alternative">Alternative</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[List[Trees.this.Tree]]">Option</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all alternatives support
   *  @group API
   */</span>
  trait <a title="trait AlternativeApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;AlternativeApi">AlternativeApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: Alternative =&gt;
    <span class="comment">/** Alternatives of the pattern matching clause. */</span>
    def <a title="=&gt; List[Trees.this.Tree]" id="scala.reflect.api;Trees;AlternativeApi.trees">trees</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Repetition of pattern.
   *
   *  Eliminated by compiler phases patmat (in the new pattern matcher of 2.10) or explicitouter (in the old pre-2.10 pattern matcher).
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.StarApi with Trees.this.TermTree" id="scala.reflect.api;Trees;Star">Star</a> &gt;: Null &lt;: StarApi with TermTree

  <span class="comment">/** The constructor/extractor for `Star` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.StarExtractor" id="scala.reflect.api;Trees.Star">Star</a>: <a href="#scala.reflect.api;Trees;StarExtractor" title="Trees.this.StarExtractor">StarExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Star(elem)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    pat*
   *  @group Extractors
   */</span>
  abstract class <a title="class StarExtractor extends AnyRef" id="scala.reflect.api;Trees;StarExtractor">StarExtractor</a> <a href="#scala.reflect.api;Trees;StarExtractor" title="Trees.this.StarExtractor" class="delimiter">{</a>
    def <a title="(elem: Trees.this.Tree)Trees.this.Star" id="scala.reflect.api;Trees;StarExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;StarExtractor.apply.elem">elem</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Star" title="Trees.this.Star">Star</a>
    def <a title="(star: Trees.this.Star)Option[Trees.this.Tree]" id="scala.reflect.api;Trees;StarExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Star" id="scala.reflect.api;Trees;StarExtractor.unapply.star">star</a>: <a href="#scala.reflect.api;Trees;Star" title="Trees.this.Star">Star</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Trees.this.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all stars support
   *  @group API
   */</span>
  trait <a title="trait StarApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;StarApi">StarApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: Star =&gt;
    <span class="comment">/** The quantified pattern. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;StarApi.elem">elem</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Bind a variable to a rhs pattern.
   *
   * Eliminated by compiler phases patmat (in the new pattern matcher of 2.10) or explicitouter (in the old pre-2.10 pattern matcher).
   *
   *  @param name
   *  @param body
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.BindApi with Trees.this.DefTree" id="scala.reflect.api;Trees;Bind">Bind</a> &gt;: Null &lt;: BindApi with DefTree

  <span class="comment">/** The constructor/extractor for `Bind` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.BindExtractor" id="scala.reflect.api;Trees.Bind(4649317b37)">Bind</a>: <a href="#scala.reflect.api;Trees;BindExtractor" title="Trees.this.BindExtractor">BindExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Bind(name, body)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    pat*
   *  @group Extractors
   */</span>
  abstract class <a title="class BindExtractor extends AnyRef" id="scala.reflect.api;Trees;BindExtractor">BindExtractor</a> <a href="#scala.reflect.api;Trees;BindExtractor" title="Trees.this.BindExtractor" class="delimiter">{</a>
    def <a title="(name: Trees.this.Name, body: Trees.this.Tree)Trees.this.Bind" id="scala.reflect.api;Trees;BindExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Name" id="scala.reflect.api;Trees;BindExtractor.apply.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;BindExtractor.apply.body">body</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Bind" title="Trees.this.Bind">Bind</a>
    def <a title="(bind: Trees.this.Bind)Option[(Trees.this.Name, Trees.this.Tree)]" id="scala.reflect.api;Trees;BindExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Bind" id="scala.reflect.api;Trees;BindExtractor.unapply.bind">bind</a>: <a href="#scala.reflect.api;Trees;Bind" title="Trees.this.Bind">Bind</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Name, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Name, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all binds support
   *  @group API
   */</span>
  trait <a title="trait BindApi extends AnyRef with Trees.this.DefTreeApi" id="scala.reflect.api;Trees;BindApi">BindApi</a> extends <a href="#scala.reflect.api;Trees;DefTreeApi" title="Trees.this.DefTreeApi">DefTreeApi</a> <span class="delimiter">{</span> this: Bind =&gt;
    <span class="comment">/** The name that can be used to refer to this fragment of the matched expression.
     *  The `list` part of the `list @ List(x, y)`.
     */</span>
    def <a title="=&gt; Trees.this.Name" id="scala.reflect.api;Trees;BindApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>

    <span class="comment">/** The pattern that represents this fragment of the matched expression.
     *  The `List(x, y)` part of the `list @ List(x, y)`.
     *  Is equal to `EmptyTree` if the pattern is not specified as in `case x =&gt; x`.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;BindApi.body">body</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Used to represent `unapply` methods in pattern matching.
   *
   *  For example:
   *  {{{
   *    2 match { case Foo(x) =&gt; x }
   *  }}}
   *
   *  Is represented as:
   *  {{{
   *    Match(
   *      Literal(Constant(2)),
   *      List(
   *        CaseDef(
   *          UnApply(
   *            // a dummy node that carries the type of unapplication to patmat
   *            // the &lt;unapply-selector&gt; here doesn't have an underlying symbol
   *            // it only has a type assigned, therefore after `untypecheck` this tree is no longer typeable
   *            Apply(Select(Ident(Foo), newTermName(&quot;unapply&quot;)), List(Ident(newTermName(&quot;&lt;unapply-selector&gt;&quot;)))),
   *            // arguments of the unapply =&gt; nothing synthetic here
   *            List(Bind(newTermName(&quot;x&quot;), Ident(nme.WILDCARD)))),
   *          EmptyTree,
   *          Ident(newTermName(&quot;x&quot;)))))
   *  }}}
   *
   * Introduced by typer. Eliminated by compiler phases patmat (in the new pattern matcher of 2.10) or explicitouter (in the old pre-2.10 pattern matcher).
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.UnApplyApi with Trees.this.TermTree" id="scala.reflect.api;Trees;UnApply">UnApply</a> &gt;: Null &lt;: UnApplyApi with TermTree

  <span class="comment">/** The constructor/extractor for `UnApply` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.UnApplyExtractor" id="scala.reflect.api;Trees.UnApply">UnApply</a>: <a href="#scala.reflect.api;Trees;UnApplyExtractor" title="Trees.this.UnApplyExtractor">UnApplyExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `UnApply(fun, args)`.
   *  This AST node does not have direct correspondence to Scala code,
   *  and is introduced when typechecking pattern matches and `try` blocks.
   *  @group Extractors
   */</span>
  abstract class <a title="class UnApplyExtractor extends AnyRef" id="scala.reflect.api;Trees;UnApplyExtractor">UnApplyExtractor</a> <a href="#scala.reflect.api;Trees;UnApplyExtractor" title="Trees.this.UnApplyExtractor" class="delimiter">{</a>
    def <a title="(fun: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.UnApply" id="scala.reflect.api;Trees;UnApplyExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;UnApplyExtractor.apply.fun">fun</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;UnApplyExtractor.apply.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;UnApply" title="Trees.this.UnApply">UnApply</a>
    def <a title="(unApply: Trees.this.UnApply)Option[(Trees.this.Tree, List[Trees.this.Tree])]" id="scala.reflect.api;Trees;UnApplyExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.UnApply" id="scala.reflect.api;Trees;UnApplyExtractor.unapply.unApply">unApply</a>: <a href="#scala.reflect.api;Trees;UnApply" title="Trees.this.UnApply">UnApply</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, List[Trees.this.Tree])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all unapplies support
   *  @group API
   */</span>
  trait <a title="trait UnApplyApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;UnApplyApi">UnApplyApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: UnApply =&gt;
    <span class="comment">/** A dummy node that carries the type of unapplication.
     *  See the example for [[scala.reflect.api.Trees#UnApplyExtractor]].
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;UnApplyApi.fun">fun</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The arguments of the unapplication.
     *  See the example for [[scala.reflect.api.Trees#UnApplyExtractor]].
     */</span>
    def <a title="=&gt; List[Trees.this.Tree]" id="scala.reflect.api;Trees;UnApplyApi.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Anonymous function, eliminated by compiler phase lambdalift
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.FunctionApi with Trees.this.TermTree with Trees.this.SymTree" id="scala.reflect.api;Trees;Function">Function</a> &gt;: Null &lt;: FunctionApi with TermTree with SymTree

  <span class="comment">/** The constructor/extractor for `Function` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.FunctionExtractor" id="scala.reflect.api;Trees.Function">Function</a>: <a href="#scala.reflect.api;Trees;FunctionExtractor" title="Trees.this.FunctionExtractor">FunctionExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Function(vparams, body)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    vparams =&gt; body
   *
   *  The symbol of a Function is a synthetic TermSymbol.
   *  It is the owner of the function's parameters.
   *  @group Extractors
   */</span>
  abstract class <a title="class FunctionExtractor extends AnyRef" id="scala.reflect.api;Trees;FunctionExtractor">FunctionExtractor</a> <a href="#scala.reflect.api;Trees;FunctionExtractor" title="Trees.this.FunctionExtractor" class="delimiter">{</a>
    def <a title="(vparams: List[Trees.this.ValDef], body: Trees.this.Tree)Trees.this.Function" id="scala.reflect.api;Trees;FunctionExtractor.apply">apply</a><span class="delimiter">(</span><a title="List[Trees.this.ValDef]" id="scala.reflect.api;Trees;FunctionExtractor.apply.vparams">vparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.ValDef]">List</a><span class="delimiter">[</span>ValDef<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;FunctionExtractor.apply.body">body</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Function" title="Trees.this.Function">Function</a>
    def <a title="(function: Trees.this.Function)Option[(List[Trees.this.ValDef], Trees.this.Tree)]" id="scala.reflect.api;Trees;FunctionExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Function" id="scala.reflect.api;Trees;FunctionExtractor.unapply.function">function</a>: <a href="#scala.reflect.api;Trees;Function" title="Trees.this.Function">Function</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(List[Trees.this.ValDef], Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span>, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all functions support
   *  @group API
   */</span>
  trait <a title="trait FunctionApi extends AnyRef with Trees.this.TermTreeApi with Trees.this.SymTreeApi" id="scala.reflect.api;Trees;FunctionApi">FunctionApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> with <a href="#scala.reflect.api;Trees;SymTreeApi" title="Trees.this.SymTreeApi">SymTreeApi</a> <span class="delimiter">{</span> this: Function =&gt;
    <span class="comment">/** The list of parameters of the function.
     */</span>
    def <a title="=&gt; List[Trees.this.ValDef]" id="scala.reflect.api;Trees;FunctionApi.vparams">vparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.ValDef]">List</a><span class="delimiter">[</span>ValDef<span class="delimiter">]</span>

    <span class="comment">/** The body of the function.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;FunctionApi.body">body</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Assignment
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.AssignApi with Trees.this.TermTree" id="scala.reflect.api;Trees;Assign">Assign</a> &gt;: Null &lt;: AssignApi with TermTree

  <span class="comment">/** The constructor/extractor for `Assign` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.AssignExtractor" id="scala.reflect.api;Trees.Assign">Assign</a>: <a href="#scala.reflect.api;Trees;AssignExtractor" title="Trees.this.AssignExtractor">AssignExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Assign(lhs, rhs)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    lhs = rhs
   *  @group Extractors
   */</span>
  abstract class <a title="class AssignExtractor extends AnyRef" id="scala.reflect.api;Trees;AssignExtractor">AssignExtractor</a> <a href="#scala.reflect.api;Trees;AssignExtractor" title="Trees.this.AssignExtractor" class="delimiter">{</a>
    def <a title="(lhs: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.Assign" id="scala.reflect.api;Trees;AssignExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;AssignExtractor.apply.lhs">lhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;AssignExtractor.apply.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Assign" title="Trees.this.Assign">Assign</a>
    def <a title="(assign: Trees.this.Assign)Option[(Trees.this.Tree, Trees.this.Tree)]" id="scala.reflect.api;Trees;AssignExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Assign" id="scala.reflect.api;Trees;AssignExtractor.unapply.assign">assign</a>: <a href="#scala.reflect.api;Trees;Assign" title="Trees.this.Assign">Assign</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all assigns support
   *  @group API
   */</span>
  trait <a title="trait AssignApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;AssignApi">AssignApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: Assign =&gt;
    <span class="comment">/** The left-hand side of the assignment.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;AssignApi.lhs">lhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The right-hand side of the assignment.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;AssignApi.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Either an assignment or a named argument. Only appears in argument lists,
   *  eliminated by compiler phase typecheck (doTypedApply), resurrected by reifier.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.AssignOrNamedArgApi with Trees.this.TermTree" id="scala.reflect.api;Trees;AssignOrNamedArg">AssignOrNamedArg</a> &gt;: Null &lt;: AssignOrNamedArgApi with TermTree

  <span class="comment">/** The constructor/extractor for `AssignOrNamedArg` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.AssignOrNamedArgExtractor" id="scala.reflect.api;Trees.AssignOrNamedArg">AssignOrNamedArg</a>: <a href="#scala.reflect.api;Trees;AssignOrNamedArgExtractor" title="Trees.this.AssignOrNamedArgExtractor">AssignOrNamedArgExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `AssignOrNamedArg(lhs, rhs)`.
   *  This AST node corresponds to the following Scala code:
   *
   *  {{{
   *    m.f(lhs = rhs)
   *  }}}
   *  {{{
   *    @annotation(lhs = rhs)
   *  }}}
   *
   *  @group Extractors
   */</span>
  abstract class <a title="class AssignOrNamedArgExtractor extends AnyRef" id="scala.reflect.api;Trees;AssignOrNamedArgExtractor">AssignOrNamedArgExtractor</a> <a href="#scala.reflect.api;Trees;AssignOrNamedArgExtractor" title="Trees.this.AssignOrNamedArgExtractor" class="delimiter">{</a>
    def <a title="(lhs: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.AssignOrNamedArg" id="scala.reflect.api;Trees;AssignOrNamedArgExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;AssignOrNamedArgExtractor.apply.lhs">lhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;AssignOrNamedArgExtractor.apply.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;AssignOrNamedArg" title="Trees.this.AssignOrNamedArg">AssignOrNamedArg</a>
    def <a title="(assignOrNamedArg: Trees.this.AssignOrNamedArg)Option[(Trees.this.Tree, Trees.this.Tree)]" id="scala.reflect.api;Trees;AssignOrNamedArgExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.AssignOrNamedArg" id="scala.reflect.api;Trees;AssignOrNamedArgExtractor.unapply.assignOrNamedArg">assignOrNamedArg</a>: <a href="#scala.reflect.api;Trees;AssignOrNamedArg" title="Trees.this.AssignOrNamedArg">AssignOrNamedArg</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all assigns support
   *  @group API
   */</span>
  trait <a title="trait AssignOrNamedArgApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;AssignOrNamedArgApi">AssignOrNamedArgApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: AssignOrNamedArg =&gt;
    <span class="comment">/** The left-hand side of the expression.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;AssignOrNamedArgApi.lhs">lhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The right-hand side of the expression.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;AssignOrNamedArgApi.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Conditional expression
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.IfApi with Trees.this.TermTree" id="scala.reflect.api;Trees;If">If</a> &gt;: Null &lt;: IfApi with TermTree

  <span class="comment">/** The constructor/extractor for `If` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.IfExtractor" id="scala.reflect.api;Trees.If">If</a>: <a href="#scala.reflect.api;Trees;IfExtractor" title="Trees.this.IfExtractor">IfExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `If(cond, thenp, elsep)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `if` (cond) thenp `else` elsep
   *
   *  If the alternative is not present, the `elsep` is set to `Literal(Constant(()))`.
   *  @group Extractors
   */</span>
  abstract class <a title="class IfExtractor extends AnyRef" id="scala.reflect.api;Trees;IfExtractor">IfExtractor</a> <a href="#scala.reflect.api;Trees;IfExtractor" title="Trees.this.IfExtractor" class="delimiter">{</a>
    def <a title="(cond: Trees.this.Tree, thenp: Trees.this.Tree, elsep: Trees.this.Tree)Trees.this.If" id="scala.reflect.api;Trees;IfExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;IfExtractor.apply.cond">cond</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;IfExtractor.apply.thenp">thenp</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;IfExtractor.apply.elsep">elsep</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;If" title="Trees.this.If">If</a>
    def <a title="(if_: Trees.this.If)Option[(Trees.this.Tree, Trees.this.Tree, Trees.this.Tree)]" id="scala.reflect.api;Trees;IfExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.If" id="scala.reflect.api;Trees;IfExtractor.unapply.if_">if_</a> : <a href="#scala.reflect.api;Trees;If" title="Trees.this.If">If</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all ifs support
   *  @group API
   */</span>
  trait <a title="trait IfApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;IfApi">IfApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: If =&gt;
    <span class="comment">/** The condition of the if.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;IfApi.cond">cond</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The main branch of the if.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;IfApi.thenp">thenp</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The alternative of the if.
     *  Is equal to `Literal(Constant(()))` if not specified.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;IfApi.elsep">elsep</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** - Pattern matching expression  (before compiler phase explicitouter before 2.10 / patmat from 2.10)
   *  - Switch statements            (after compiler phase explicitouter before 2.10 / patmat from 2.10)
   *
   *  After compiler phase explicitouter before 2.10 / patmat from 2.10, cases will satisfy the following constraints:
   *
   *  - all guards are `EmptyTree`,
   *  - all patterns will be either `Literal(Constant(x:Int))`
   *    or `Alternative(lit|...|lit)`
   *  - except for an &quot;otherwise&quot; branch, which has pattern
   *    `Ident(nme.WILDCARD)`
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.MatchApi with Trees.this.TermTree" id="scala.reflect.api;Trees;Match">Match</a> &gt;: Null &lt;: MatchApi with TermTree

  <span class="comment">/** The constructor/extractor for `Match` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.MatchExtractor" id="scala.reflect.api;Trees.Match">Match</a>: <a href="#scala.reflect.api;Trees;MatchExtractor" title="Trees.this.MatchExtractor">MatchExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Match(selector, cases)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    selector `match` { cases }
   *
   * `Match` is also used in pattern matching assignments like `val (foo, bar) = baz`.
   *  @group Extractors
   */</span>
  abstract class <a title="class MatchExtractor extends AnyRef" id="scala.reflect.api;Trees;MatchExtractor">MatchExtractor</a> <a href="#scala.reflect.api;Trees;MatchExtractor" title="Trees.this.MatchExtractor" class="delimiter">{</a>
    def <a title="(selector: Trees.this.Tree, cases: List[Trees.this.CaseDef])Trees.this.Match" id="scala.reflect.api;Trees;MatchExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;MatchExtractor.apply.selector">selector</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.CaseDef]" id="scala.reflect.api;Trees;MatchExtractor.apply.cases">cases</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Match" title="Trees.this.Match">Match</a>
    def <a title="(match_: Trees.this.Match)Option[(Trees.this.Tree, List[Trees.this.CaseDef])]" id="scala.reflect.api;Trees;MatchExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Match" id="scala.reflect.api;Trees;MatchExtractor.unapply.match_">match_</a> : <a href="#scala.reflect.api;Trees;Match" title="Trees.this.Match">Match</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, List[Trees.this.CaseDef])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all matches support
   *  @group API
   */</span>
  trait <a title="trait MatchApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;MatchApi">MatchApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: Match =&gt;
    <span class="comment">/** The scrutinee of the pattern match. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;MatchApi.selector">selector</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The arms of the pattern match. */</span>
    def <a title="=&gt; List[Trees.this.CaseDef]" id="scala.reflect.api;Trees;MatchApi.cases">cases</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Return expression
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.ReturnApi with Trees.this.SymTree with Trees.this.TermTree" id="scala.reflect.api;Trees;Return">Return</a> &gt;: Null &lt;: ReturnApi with SymTree with TermTree

  <span class="comment">/** The constructor/extractor for `Return` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.ReturnExtractor" id="scala.reflect.api;Trees.Return">Return</a>: <a href="#scala.reflect.api;Trees;ReturnExtractor" title="Trees.this.ReturnExtractor">ReturnExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Return(expr)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `return` expr
   *
   *  The symbol of a Return node is the enclosing method.
   *  @group Extractors
   */</span>
  abstract class <a title="class ReturnExtractor extends AnyRef" id="scala.reflect.api;Trees;ReturnExtractor">ReturnExtractor</a> <a href="#scala.reflect.api;Trees;ReturnExtractor" title="Trees.this.ReturnExtractor" class="delimiter">{</a>
    def <a title="(expr: Trees.this.Tree)Trees.this.Return" id="scala.reflect.api;Trees;ReturnExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;ReturnExtractor.apply.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Return" title="Trees.this.Return">Return</a>
    def <a title="(return_: Trees.this.Return)Option[Trees.this.Tree]" id="scala.reflect.api;Trees;ReturnExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Return" id="scala.reflect.api;Trees;ReturnExtractor.unapply.return_">return_</a> : <a href="#scala.reflect.api;Trees;Return" title="Trees.this.Return">Return</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Trees.this.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all returns support
   *  @group API
   */</span>
  trait <a title="trait ReturnApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;ReturnApi">ReturnApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: Return =&gt;
    <span class="comment">/** The returned expression. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;ReturnApi.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Try catch node
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.TryApi with Trees.this.TermTree" id="scala.reflect.api;Trees;Try">Try</a> &gt;: Null &lt;: TryApi with TermTree

  <span class="comment">/** The constructor/extractor for `Try` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.TryExtractor" id="scala.reflect.api;Trees.Try(6640da6372)">Try</a>: <a href="#scala.reflect.api;Trees;TryExtractor" title="Trees.this.TryExtractor">TryExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Try(block, catches, finalizer)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `try` block `catch` { catches } `finally` finalizer
   *
   *  If the finalizer is not present, the `finalizer` is set to `EmptyTree`.
   *  @group Extractors
   */</span>
  abstract class <a title="class TryExtractor extends AnyRef" id="scala.reflect.api;Trees;TryExtractor">TryExtractor</a> <a href="#scala.reflect.api;Trees;TryExtractor" title="Trees.this.TryExtractor" class="delimiter">{</a>
    def <a title="(block: Trees.this.Tree, catches: List[Trees.this.CaseDef], finalizer: Trees.this.Tree)Trees.this.Try" id="scala.reflect.api;Trees;TryExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TryExtractor.apply.block">block</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.CaseDef]" id="scala.reflect.api;Trees;TryExtractor.apply.catches">catches</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TryExtractor.apply.finalizer">finalizer</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Try" title="Trees.this.Try">Try</a>
    def <a title="(try_: Trees.this.Try)Option[(Trees.this.Tree, List[Trees.this.CaseDef], Trees.this.Tree)]" id="scala.reflect.api;Trees;TryExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Try" id="scala.reflect.api;Trees;TryExtractor.unapply.try_">try_</a> : <a href="#scala.reflect.api;Trees;Try" title="Trees.this.Try">Try</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, List[Trees.this.CaseDef], Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>CaseDef<span class="delimiter">]</span>, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all tries support
   *  @group API
   */</span>
  trait <a title="trait TryApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;TryApi">TryApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: Try =&gt;
    <span class="comment">/** The protected block. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;TryApi.block">block</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The `catch` pattern-matching clauses of the try. */</span>
    def <a title="=&gt; List[Trees.this.CaseDef]" id="scala.reflect.api;Trees;TryApi.catches">catches</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span>

    <span class="comment">/** The `finally` part of the try. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;TryApi.finalizer">finalizer</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Throw expression
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.ThrowApi with Trees.this.TermTree" id="scala.reflect.api;Trees;Throw">Throw</a> &gt;: Null &lt;: ThrowApi with TermTree

  <span class="comment">/** The constructor/extractor for `Throw` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.ThrowExtractor" id="scala.reflect.api;Trees.Throw(b261fb18db)">Throw</a>: <a href="#scala.reflect.api;Trees;ThrowExtractor" title="Trees.this.ThrowExtractor">ThrowExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Throw(expr)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `throw` expr
   *  @group Extractors
   */</span>
  abstract class <a title="class ThrowExtractor extends AnyRef" id="scala.reflect.api;Trees;ThrowExtractor">ThrowExtractor</a> <a href="#scala.reflect.api;Trees;ThrowExtractor" title="Trees.this.ThrowExtractor" class="delimiter">{</a>
    def <a title="(expr: Trees.this.Tree)Trees.this.Throw" id="scala.reflect.api;Trees;ThrowExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;ThrowExtractor.apply.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Throw" title="Trees.this.Throw">Throw</a>
    def <a title="(throw_: Trees.this.Throw)Option[Trees.this.Tree]" id="scala.reflect.api;Trees;ThrowExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Throw" id="scala.reflect.api;Trees;ThrowExtractor.unapply.throw_">throw_</a> : <a href="#scala.reflect.api;Trees;Throw" title="Trees.this.Throw">Throw</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Trees.this.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all tries support
   *  @group API
   */</span>
  trait <a title="trait ThrowApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;ThrowApi">ThrowApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: Throw =&gt;
    <span class="comment">/** The thrown expression. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;ThrowApi.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Object instantiation
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.NewApi with Trees.this.TermTree" id="scala.reflect.api;Trees;New">New</a> &gt;: Null &lt;: NewApi with TermTree

  <span class="comment">/** The constructor/extractor for `New` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.NewExtractor" id="scala.reflect.api;Trees.New(84c82d27e0)">New</a>: <a href="#scala.reflect.api;Trees;NewExtractor" title="Trees.this.NewExtractor">NewExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `New(tpt)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    `new` T
   *
   *  This node always occurs in the following context:
   *
   *    (`new` tpt).&lt;init&gt;[targs](args)
   *
   *  For example, an AST representation of:
   *
   *    new Example[Int](2)(3)
   *
   *  is the following code:
   *
   *    Apply(
   *      Apply(
   *        TypeApply(
   *          Select(New(TypeTree(typeOf[Example])), nme.CONSTRUCTOR)
   *          TypeTree(typeOf[Int])),
   *        List(Literal(Constant(2)))),
   *      List(Literal(Constant(3))))
   *  @group Extractors
   */</span>
  abstract class <a title="class NewExtractor extends AnyRef" id="scala.reflect.api;Trees;NewExtractor">NewExtractor</a> <a href="#scala.reflect.api;Trees;NewExtractor" title="Trees.this.NewExtractor" class="delimiter">{</a>
    def <a title="(tpt: Trees.this.Tree)Trees.this.New" id="scala.reflect.api;Trees;NewExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;NewExtractor.apply.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;New" title="Trees.this.New">New</a>
    def <a title="(new_: Trees.this.New)Option[Trees.this.Tree]" id="scala.reflect.api;Trees;NewExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.New" id="scala.reflect.api;Trees;NewExtractor.unapply.new_">new_</a> : <a href="#scala.reflect.api;Trees;New" title="Trees.this.New">New</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Trees.this.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all news support
   *  @group API
   */</span>
  trait <a title="trait NewApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;NewApi">NewApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: New =&gt;
    <span class="comment">/** The tree that represents the type being instantiated.
     *  See the example for [[scala.reflect.api.Trees#NewExtractor]].
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;NewApi.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Type annotation, eliminated by compiler phase cleanup
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.TypedApi with Trees.this.TermTree" id="scala.reflect.api;Trees;Typed">Typed</a> &gt;: Null &lt;: TypedApi with TermTree

  <span class="comment">/** The constructor/extractor for `Typed` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.TypedExtractor" id="scala.reflect.api;Trees.Typed">Typed</a>: <a href="#scala.reflect.api;Trees;TypedExtractor" title="Trees.this.TypedExtractor">TypedExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Typed(expr, tpt)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    expr: tpt
   *  @group Extractors
   */</span>
  abstract class <a title="class TypedExtractor extends AnyRef" id="scala.reflect.api;Trees;TypedExtractor">TypedExtractor</a> <a href="#scala.reflect.api;Trees;TypedExtractor" title="Trees.this.TypedExtractor" class="delimiter">{</a>
    def <a title="(expr: Trees.this.Tree, tpt: Trees.this.Tree)Trees.this.Typed" id="scala.reflect.api;Trees;TypedExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TypedExtractor.apply.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TypedExtractor.apply.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Typed" title="Trees.this.Typed">Typed</a>
    def <a title="(typed: Trees.this.Typed)Option[(Trees.this.Tree, Trees.this.Tree)]" id="scala.reflect.api;Trees;TypedExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Typed" id="scala.reflect.api;Trees;TypedExtractor.unapply.typed">typed</a>: <a href="#scala.reflect.api;Trees;Typed" title="Trees.this.Typed">Typed</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all typeds support
   *  @group API
   */</span>
  trait <a title="trait TypedApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;TypedApi">TypedApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: Typed =&gt;
    <span class="comment">/** The expression being ascribed with the type. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;TypedApi.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The type being ascribed to the expression. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;TypedApi.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Common base class for Apply and TypeApply.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.GenericApplyApi with Trees.this.TermTree" id="scala.reflect.api;Trees;GenericApply">GenericApply</a> &gt;: Null &lt;: GenericApplyApi with TermTree

  <span class="comment">/** The API that all applies support
   *  @group API
   */</span>
  trait <a title="trait GenericApplyApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;GenericApplyApi">GenericApplyApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: GenericApply =&gt;
    <span class="comment">/** The target of the application. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;GenericApplyApi.fun">fun</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The arguments of the application. */</span>
    def <a title="=&gt; List[Trees.this.Tree]" id="scala.reflect.api;Trees;GenericApplyApi.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/* @PP: All signs point toward it being a requirement that args.nonEmpty,
   *  but I can't find that explicitly stated anywhere.  Unless your last name
   *  is odersky, you should probably treat it as true.
   */</span>
  <span class="comment">/** Explicit type application.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.TypeApplyApi with Trees.this.GenericApply" id="scala.reflect.api;Trees;TypeApply">TypeApply</a> &gt;: Null &lt;: TypeApplyApi with GenericApply

  <span class="comment">/** The constructor/extractor for `TypeApply` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.TypeApplyExtractor" id="scala.reflect.api;Trees.TypeApply">TypeApply</a>: <a href="#scala.reflect.api;Trees;TypeApplyExtractor" title="Trees.this.TypeApplyExtractor">TypeApplyExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `TypeApply(fun, args)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    fun[args]
   *
   *  Should only be used with `fun` nodes which are terms, i.e. which have `isTerm` returning `true`.
   *  Otherwise `AppliedTypeTree` should be used instead.
   *
   *    def foo[T] = ???
   *    foo[Int] // represented as TypeApply(Ident(&lt;foo&gt;), List(TypeTree(&lt;Int&gt;)))
   *
   *    List[Int] as in `val x: List[Int] = ???`
   *    // represented as AppliedTypeTree(Ident(&lt;List&gt;), List(TypeTree(&lt;Int&gt;)))
   *
   *  @group Extractors
   */</span>
  abstract class <a title="class TypeApplyExtractor extends AnyRef" id="scala.reflect.api;Trees;TypeApplyExtractor">TypeApplyExtractor</a> <a href="#scala.reflect.api;Trees;TypeApplyExtractor" title="Trees.this.TypeApplyExtractor" class="delimiter">{</a>
    def <a title="(fun: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.TypeApply" id="scala.reflect.api;Trees;TypeApplyExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TypeApplyExtractor.apply.fun">fun</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;TypeApplyExtractor.apply.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;TypeApply" title="Trees.this.TypeApply">TypeApply</a>
    def <a title="(typeApply: Trees.this.TypeApply)Option[(Trees.this.Tree, List[Trees.this.Tree])]" id="scala.reflect.api;Trees;TypeApplyExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.TypeApply" id="scala.reflect.api;Trees;TypeApplyExtractor.unapply.typeApply">typeApply</a>: <a href="#scala.reflect.api;Trees;TypeApply" title="Trees.this.TypeApply">TypeApply</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, List[Trees.this.Tree])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all type applies support
   *  @group API
   */</span>
  trait <a title="trait TypeApplyApi extends AnyRef with Trees.this.GenericApplyApi" id="scala.reflect.api;Trees;TypeApplyApi">TypeApplyApi</a> extends <a href="#scala.reflect.api;Trees;GenericApplyApi" title="Trees.this.GenericApplyApi">GenericApplyApi</a> <span class="delimiter">{</span> this: TypeApply =&gt;
  <span class="delimiter">}</span>

  <span class="comment">/** Value application
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.ApplyApi with Trees.this.GenericApply" id="scala.reflect.api;Trees;Apply">Apply</a> &gt;: Null &lt;: ApplyApi with GenericApply

  <span class="comment">/** The constructor/extractor for `Apply` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.ApplyExtractor" id="scala.reflect.api;Trees.Apply(b50d7e8c11)">Apply</a>: <a href="#scala.reflect.api;Trees;ApplyExtractor" title="Trees.this.ApplyExtractor">ApplyExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Apply(fun, args)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    fun(args)
   *
   *  For instance:
   *
   *    fun[targs](args)
   *
   *  Is expressed as:
   *
   *    Apply(TypeApply(fun, targs), args)
   *  @group Extractors
   */</span>
  abstract class <a title="class ApplyExtractor extends AnyRef" id="scala.reflect.api;Trees;ApplyExtractor">ApplyExtractor</a> <a href="#scala.reflect.api;Trees;ApplyExtractor" title="Trees.this.ApplyExtractor" class="delimiter">{</a>
    def <a title="(fun: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.Apply" id="scala.reflect.api;Trees;ApplyExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;ApplyExtractor.apply.fun">fun</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;ApplyExtractor.apply.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Apply" title="Trees.this.Apply">Apply</a>
    def <a title="(apply: Trees.this.Apply)Option[(Trees.this.Tree, List[Trees.this.Tree])]" id="scala.reflect.api;Trees;ApplyExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Apply" id="scala.reflect.api;Trees;ApplyExtractor.unapply.apply">apply</a>: <a href="#scala.reflect.api;Trees;Apply" title="Trees.this.Apply">Apply</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, List[Trees.this.Tree])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all applies support
   *  @group API
   */</span>
  trait <a title="trait ApplyApi extends AnyRef with Trees.this.GenericApplyApi" id="scala.reflect.api;Trees;ApplyApi">ApplyApi</a> extends <a href="#scala.reflect.api;Trees;GenericApplyApi" title="Trees.this.GenericApplyApi">GenericApplyApi</a> <span class="delimiter">{</span> this: Apply =&gt;
  <span class="delimiter">}</span>

  <span class="comment">/** Super reference, where `qual` is the corresponding `this` reference.
   *  A super reference `C.super[M]` is represented as `Super(This(C), M)`.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.SuperApi with Trees.this.TermTree" id="scala.reflect.api;Trees;Super">Super</a> &gt;: Null &lt;: SuperApi with TermTree

  <span class="comment">/** The constructor/extractor for `Super` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.SuperExtractor" id="scala.reflect.api;Trees.Super(eb516570fb)">Super</a>: <a href="#scala.reflect.api;Trees;SuperExtractor" title="Trees.this.SuperExtractor">SuperExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Super(qual, mix)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    C.super[M]
   *
   *  Which is represented as:
   *
   *    Super(This(C), M)
   *
   *  If `mix` is empty, it is tpnme.EMPTY.
   *
   *  The symbol of a Super is the class _from_ which the super reference is made.
   *  For instance in C.super(...), it would be C.
   *  @group Extractors
   */</span>
  abstract class <a title="class SuperExtractor extends AnyRef" id="scala.reflect.api;Trees;SuperExtractor">SuperExtractor</a> <a href="#scala.reflect.api;Trees;SuperExtractor" title="Trees.this.SuperExtractor" class="delimiter">{</a>
    def <a title="(qual: Trees.this.Tree, mix: Trees.this.TypeName)Trees.this.Super" id="scala.reflect.api;Trees;SuperExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;SuperExtractor.apply.qual">qual</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.TypeName" id="scala.reflect.api;Trees;SuperExtractor.apply.mix">mix</a>: <a href="Names.scala.html#scala.reflect.api;Names;TypeName" title="Trees.this.TypeName">TypeName</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Super" title="Trees.this.Super">Super</a>
    def <a title="(super_: Trees.this.Super)Option[(Trees.this.Tree, Trees.this.TypeName)]" id="scala.reflect.api;Trees;SuperExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Super" id="scala.reflect.api;Trees;SuperExtractor.unapply.super_">super_</a> : <a href="#scala.reflect.api;Trees;Super" title="Trees.this.Super">Super</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, Trees.this.TypeName)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, TypeName<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all supers support
   *  @group API
   */</span>
  trait <a title="trait SuperApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;SuperApi">SuperApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: Super =&gt;
    <span class="comment">/** The qualifier of the `super` expression.
     *  See the example for [[scala.reflect.api.Trees#SuperExtractor]].
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;SuperApi.qual">qual</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The selector of the `super` expression.
     *  See the example for [[scala.reflect.api.Trees#SuperExtractor]].
     */</span>
    def <a title="=&gt; Trees.this.TypeName" id="scala.reflect.api;Trees;SuperApi.mix">mix</a>: <a href="Names.scala.html#scala.reflect.api;Names;TypeName" title="Trees.this.TypeName">TypeName</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Self reference
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.ThisApi with Trees.this.TermTree with Trees.this.SymTree" id="scala.reflect.api;Trees;This">This</a> &gt;: Null &lt;: ThisApi with TermTree with SymTree

  <span class="comment">/** The constructor/extractor for `This` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.ThisExtractor" id="scala.reflect.api;Trees.This(3341486125)">This</a>: <a href="#scala.reflect.api;Trees;ThisExtractor" title="Trees.this.ThisExtractor">ThisExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `This(qual)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    qual.this
   *
   *  The symbol of a This is the class to which the this refers.
   *  For instance in C.this, it would be C.
   *  @group Extractors
   */</span>
  abstract class <a title="class ThisExtractor extends AnyRef" id="scala.reflect.api;Trees;ThisExtractor">ThisExtractor</a> <a href="#scala.reflect.api;Trees;ThisExtractor" title="Trees.this.ThisExtractor" class="delimiter">{</a>
    def <a title="(qual: Trees.this.TypeName)Trees.this.This" id="scala.reflect.api;Trees;ThisExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.TypeName" id="scala.reflect.api;Trees;ThisExtractor.apply.qual">qual</a>: <a href="Names.scala.html#scala.reflect.api;Names;TypeName" title="Trees.this.TypeName">TypeName</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;This" title="Trees.this.This">This</a>
    def <a title="(this_: Trees.this.This)Option[Trees.this.TypeName]" id="scala.reflect.api;Trees;ThisExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.This" id="scala.reflect.api;Trees;ThisExtractor.unapply.this_">this_</a> : <a href="#scala.reflect.api;Trees;This" title="Trees.this.This">This</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Trees.this.TypeName]">Option</a><span class="delimiter">[</span>TypeName<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all thises support
   *  @group API
   */</span>
  trait <a title="trait ThisApi extends AnyRef with Trees.this.TermTreeApi with Trees.this.SymTreeApi" id="scala.reflect.api;Trees;ThisApi">ThisApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> with <a href="#scala.reflect.api;Trees;SymTreeApi" title="Trees.this.SymTreeApi">SymTreeApi</a> <span class="delimiter">{</span> this: This =&gt;
    <span class="comment">/** The qualifier of the `this` expression.
     *  For an unqualified `this` refers to the enclosing class.
     */</span>
    def <a title="=&gt; Trees.this.TypeName" id="scala.reflect.api;Trees;ThisApi.qual">qual</a>: <a href="Names.scala.html#scala.reflect.api;Names;TypeName" title="Trees.this.TypeName">TypeName</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A member selection &lt;qualifier&gt; . &lt;name&gt;
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.SelectApi with Trees.this.RefTree" id="scala.reflect.api;Trees;Select">Select</a> &gt;: Null &lt;: SelectApi with RefTree

  <span class="comment">/** The constructor/extractor for `Select` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.SelectExtractor" id="scala.reflect.api;Trees.Select(75d753c638)">Select</a>: <a href="#scala.reflect.api;Trees;SelectExtractor" title="Trees.this.SelectExtractor">SelectExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Select(qual, name)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    qualifier.selector
   *
   *  Should only be used with `qualifier` nodes which are terms, i.e. which have `isTerm` returning `true`.
   *  Otherwise `SelectFromTypeTree` should be used instead.
   *
   *    foo.Bar // represented as Select(Ident(&lt;foo&gt;), &lt;Bar&gt;)
   *    Foo#Bar // represented as SelectFromTypeTree(Ident(&lt;Foo&gt;), &lt;Bar&gt;)
   *  @group Extractors
   */</span>
  abstract class <a title="class SelectExtractor extends AnyRef" id="scala.reflect.api;Trees;SelectExtractor">SelectExtractor</a> <a href="#scala.reflect.api;Trees;SelectExtractor" title="Trees.this.SelectExtractor" class="delimiter">{</a>
    def <a title="(qualifier: Trees.this.Tree, name: Trees.this.Name)Trees.this.Select" id="scala.reflect.api;Trees;SelectExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;SelectExtractor.apply.qualifier">qualifier</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;SelectExtractor.apply.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Select" title="Trees.this.Select">Select</a>
    def <a title="(select: Trees.this.Select)Option[(Trees.this.Tree, Trees.this.Name)]" id="scala.reflect.api;Trees;SelectExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Select" id="scala.reflect.api;Trees;SelectExtractor.unapply.select">select</a>: <a href="#scala.reflect.api;Trees;Select" title="Trees.this.Select">Select</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, Trees.this.Name)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Name<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all selects support
   *  @group API
   */</span>
  trait <a title="trait SelectApi extends AnyRef with Trees.this.RefTreeApi" id="scala.reflect.api;Trees;SelectApi">SelectApi</a> extends <a href="#scala.reflect.api;Trees;RefTreeApi" title="Trees.this.RefTreeApi">RefTreeApi</a> <span class="delimiter">{</span> this: Select =&gt;
    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;SelectApi.qualifier">qualifier</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Name" id="scala.reflect.api;Trees;SelectApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A reference to identifier `name`.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.IdentApi with Trees.this.RefTree" id="scala.reflect.api;Trees;Ident">Ident</a> &gt;: Null &lt;: IdentApi with RefTree

  <span class="comment">/** The constructor/extractor for `Ident` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.IdentExtractor" id="scala.reflect.api;Trees.Ident(62870dd2b4)">Ident</a>: <a href="#scala.reflect.api;Trees;IdentExtractor" title="Trees.this.IdentExtractor">IdentExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Ident(qual, name)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    name
   *
   *  Type checker converts idents that refer to enclosing fields or methods to selects.
   *  For example, name ==&gt; this.name
   *  @group Extractors
   */</span>
  abstract class <a title="class IdentExtractor extends AnyRef" id="scala.reflect.api;Trees;IdentExtractor">IdentExtractor</a> <a href="#scala.reflect.api;Trees;IdentExtractor" title="Trees.this.IdentExtractor" class="delimiter">{</a>
    def <a title="(name: Trees.this.Name)Trees.this.Ident" id="scala.reflect.api;Trees;IdentExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Name" id="scala.reflect.api;Trees;IdentExtractor.apply.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Ident" title="Trees.this.Ident">Ident</a>
    def <a title="(ident: Trees.this.Ident)Option[Trees.this.Name]" id="scala.reflect.api;Trees;IdentExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Ident" id="scala.reflect.api;Trees;IdentExtractor.unapply.ident">ident</a>: <a href="#scala.reflect.api;Trees;Ident" title="Trees.this.Ident">Ident</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Trees.this.Name]">Option</a><span class="delimiter">[</span>Name<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all idents support
   *  @group API
   */</span>
  trait <a title="trait IdentApi extends AnyRef with Trees.this.RefTreeApi" id="scala.reflect.api;Trees;IdentApi">IdentApi</a> extends <a href="#scala.reflect.api;Trees;RefTreeApi" title="Trees.this.RefTreeApi">RefTreeApi</a> <span class="delimiter">{</span> this: Ident =&gt;
    <span class="comment">/** Was this ident created from a backquoted identifier? */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Trees;IdentApi.isBackquoted">isBackquoted</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Name" id="scala.reflect.api;Trees;IdentApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Literal
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.LiteralApi with Trees.this.TermTree" id="scala.reflect.api;Trees;Literal">Literal</a> &gt;: Null &lt;: LiteralApi with TermTree

  <span class="comment">/** The constructor/extractor for `Literal` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.LiteralExtractor" id="scala.reflect.api;Trees.Literal">Literal</a>: <a href="#scala.reflect.api;Trees;LiteralExtractor" title="Trees.this.LiteralExtractor">LiteralExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Literal(value)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    value
   *  @group Extractors
   */</span>
  abstract class <a title="class LiteralExtractor extends AnyRef" id="scala.reflect.api;Trees;LiteralExtractor">LiteralExtractor</a> <a href="#scala.reflect.api;Trees;LiteralExtractor" title="Trees.this.LiteralExtractor" class="delimiter">{</a>
    def <a title="(value: Trees.this.Constant)Trees.this.Literal" id="scala.reflect.api;Trees;LiteralExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Constant" id="scala.reflect.api;Trees;LiteralExtractor.apply.value">value</a>: <a href="Constants.scala.html#scala.reflect.api;Constants;Constant" title="Trees.this.Constant">Constant</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Literal" title="Trees.this.Literal">Literal</a>
    def <a title="(literal: Trees.this.Literal)Option[Trees.this.Constant]" id="scala.reflect.api;Trees;LiteralExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Literal" id="scala.reflect.api;Trees;LiteralExtractor.unapply.literal">literal</a>: <a href="#scala.reflect.api;Trees;Literal" title="Trees.this.Literal">Literal</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Trees.this.Constant]">Option</a><span class="delimiter">[</span>Constant<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all literals support
   *  @group API
   */</span>
  trait <a title="trait LiteralApi extends AnyRef with Trees.this.TermTreeApi" id="scala.reflect.api;Trees;LiteralApi">LiteralApi</a> extends <a href="#scala.reflect.api;Trees;TermTreeApi" title="Trees.this.TermTreeApi">TermTreeApi</a> <span class="delimiter">{</span> this: Literal =&gt;
    <span class="comment">/** The compile-time constant underlying the literal. */</span>
    def <a title="=&gt; Trees.this.Constant" id="scala.reflect.api;Trees;LiteralApi.value">value</a>: <a href="Constants.scala.html#scala.reflect.api;Constants;Constant" title="Trees.this.Constant">Constant</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A tree that has an annotation attached to it. Only used for annotated types and
   *  annotation ascriptions, annotations on definitions are stored in the Modifiers.
   *  Eliminated by typechecker (typedAnnotated), the annotations are then stored in
   *  an AnnotatedType.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.AnnotatedApi with Trees.this.Tree" id="scala.reflect.api;Trees;Annotated">Annotated</a> &gt;: Null &lt;: AnnotatedApi with Tree

  <span class="comment">/** The constructor/extractor for `Annotated` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.AnnotatedExtractor" id="scala.reflect.api;Trees.Annotated">Annotated</a>: <a href="#scala.reflect.api;Trees;AnnotatedExtractor" title="Trees.this.AnnotatedExtractor">AnnotatedExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Annotated(annot, arg)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    arg @annot    // for types
   *    arg: @annot   // for exprs
   *  @group Extractors
   */</span>
  abstract class <a title="class AnnotatedExtractor extends AnyRef" id="scala.reflect.api;Trees;AnnotatedExtractor">AnnotatedExtractor</a> <a href="#scala.reflect.api;Trees;AnnotatedExtractor" title="Trees.this.AnnotatedExtractor" class="delimiter">{</a>
    def <a title="(annot: Trees.this.Tree, arg: Trees.this.Tree)Trees.this.Annotated" id="scala.reflect.api;Trees;AnnotatedExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;AnnotatedExtractor.apply.annot">annot</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;AnnotatedExtractor.apply.arg">arg</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Annotated" title="Trees.this.Annotated">Annotated</a>
    def <a title="(annotated: Trees.this.Annotated)Option[(Trees.this.Tree, Trees.this.Tree)]" id="scala.reflect.api;Trees;AnnotatedExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Annotated" id="scala.reflect.api;Trees;AnnotatedExtractor.unapply.annotated">annotated</a>: <a href="#scala.reflect.api;Trees;Annotated" title="Trees.this.Annotated">Annotated</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all annotateds support
   *  @group API
   */</span>
  trait <a title="trait AnnotatedApi extends AnyRef with Trees.this.TreeApi" id="scala.reflect.api;Trees;AnnotatedApi">AnnotatedApi</a> extends <a href="#scala.reflect.api;Trees;TreeApi" title="Trees.this.TreeApi">TreeApi</a> <span class="delimiter">{</span> this: Annotated =&gt;
    <span class="comment">/** The annotation. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;AnnotatedApi.annot">annot</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The annotee. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;AnnotatedApi.arg">arg</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Singleton type, eliminated by RefCheck
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.SingletonTypeTreeApi with Trees.this.TypTree" id="scala.reflect.api;Trees;SingletonTypeTree">SingletonTypeTree</a> &gt;: Null &lt;: SingletonTypeTreeApi with TypTree

  <span class="comment">/** The constructor/extractor for `SingletonTypeTree` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.SingletonTypeTreeExtractor" id="scala.reflect.api;Trees.SingletonTypeTree">SingletonTypeTree</a>: <a href="#scala.reflect.api;Trees;SingletonTypeTreeExtractor" title="Trees.this.SingletonTypeTreeExtractor">SingletonTypeTreeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `SingletonTypeTree(ref)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    ref.type
   *  @group Extractors
   */</span>
  abstract class <a title="class SingletonTypeTreeExtractor extends AnyRef" id="scala.reflect.api;Trees;SingletonTypeTreeExtractor">SingletonTypeTreeExtractor</a> <a href="#scala.reflect.api;Trees;SingletonTypeTreeExtractor" title="Trees.this.SingletonTypeTreeExtractor" class="delimiter">{</a>
    def <a title="(ref: Trees.this.Tree)Trees.this.SingletonTypeTree" id="scala.reflect.api;Trees;SingletonTypeTreeExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;SingletonTypeTreeExtractor.apply.ref">ref</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;SingletonTypeTree" title="Trees.this.SingletonTypeTree">SingletonTypeTree</a>
    def <a title="(singletonTypeTree: Trees.this.SingletonTypeTree)Option[Trees.this.Tree]" id="scala.reflect.api;Trees;SingletonTypeTreeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.SingletonTypeTree" id="scala.reflect.api;Trees;SingletonTypeTreeExtractor.unapply.singletonTypeTree">singletonTypeTree</a>: <a href="#scala.reflect.api;Trees;SingletonTypeTree" title="Trees.this.SingletonTypeTree">SingletonTypeTree</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Trees.this.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all singleton type trees support
   *  @group API
   */</span>
  trait <a title="trait SingletonTypeTreeApi extends AnyRef with Trees.this.TypTreeApi" id="scala.reflect.api;Trees;SingletonTypeTreeApi">SingletonTypeTreeApi</a> extends <a href="#scala.reflect.api;Trees;TypTreeApi" title="Trees.this.TypTreeApi">TypTreeApi</a> <span class="delimiter">{</span> this: SingletonTypeTree =&gt;
    <span class="comment">/** The underlying reference. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;SingletonTypeTreeApi.ref">ref</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Type selection &lt;qualifier&gt; # &lt;name&gt;, eliminated by RefCheck
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.SelectFromTypeTreeApi with Trees.this.TypTree with Trees.this.RefTree" id="scala.reflect.api;Trees;SelectFromTypeTree">SelectFromTypeTree</a> &gt;: Null &lt;: SelectFromTypeTreeApi with TypTree with RefTree

  <span class="comment">/** The constructor/extractor for `SelectFromTypeTree` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.SelectFromTypeTreeExtractor" id="scala.reflect.api;Trees.SelectFromTypeTree">SelectFromTypeTree</a>: <a href="#scala.reflect.api;Trees;SelectFromTypeTreeExtractor" title="Trees.this.SelectFromTypeTreeExtractor">SelectFromTypeTreeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `SelectFromTypeTree(qualifier, name)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    qualifier # selector
   *
   *  Note: a path-dependent type p.T is expressed as p.type # T
   *
   *  Should only be used with `qualifier` nodes which are types, i.e. which have `isType` returning `true`.
   *  Otherwise `Select` should be used instead.
   *
   *    Foo#Bar // represented as SelectFromTypeTree(Ident(&lt;Foo&gt;), &lt;Bar&gt;)
   *    foo.Bar // represented as Select(Ident(&lt;foo&gt;), &lt;Bar&gt;)
   *  @group Extractors
   */</span>
  abstract class <a title="class SelectFromTypeTreeExtractor extends AnyRef" id="scala.reflect.api;Trees;SelectFromTypeTreeExtractor">SelectFromTypeTreeExtractor</a> <a href="#scala.reflect.api;Trees;SelectFromTypeTreeExtractor" title="Trees.this.SelectFromTypeTreeExtractor" class="delimiter">{</a>
    def <a title="(qualifier: Trees.this.Tree, name: Trees.this.TypeName)Trees.this.SelectFromTypeTree" id="scala.reflect.api;Trees;SelectFromTypeTreeExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;SelectFromTypeTreeExtractor.apply.qualifier">qualifier</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.TypeName" id="scala.reflect.api;Trees;SelectFromTypeTreeExtractor.apply.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TypeName" title="Trees.this.TypeName">TypeName</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;SelectFromTypeTree" title="Trees.this.SelectFromTypeTree">SelectFromTypeTree</a>
    def <a title="(selectFromTypeTree: Trees.this.SelectFromTypeTree)Option[(Trees.this.Tree, Trees.this.TypeName)]" id="scala.reflect.api;Trees;SelectFromTypeTreeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.SelectFromTypeTree" id="scala.reflect.api;Trees;SelectFromTypeTreeExtractor.unapply.selectFromTypeTree">selectFromTypeTree</a>: <a href="#scala.reflect.api;Trees;SelectFromTypeTree" title="Trees.this.SelectFromTypeTree">SelectFromTypeTree</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, Trees.this.TypeName)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, TypeName<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all selects from type trees support
   *  @group API
   */</span>
  trait <a title="trait SelectFromTypeTreeApi extends AnyRef with Trees.this.TypTreeApi with Trees.this.RefTreeApi" id="scala.reflect.api;Trees;SelectFromTypeTreeApi">SelectFromTypeTreeApi</a> extends <a href="#scala.reflect.api;Trees;TypTreeApi" title="Trees.this.TypTreeApi">TypTreeApi</a> with <a href="#scala.reflect.api;Trees;RefTreeApi" title="Trees.this.RefTreeApi">RefTreeApi</a> <span class="delimiter">{</span> this: SelectFromTypeTree =&gt;
    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;SelectFromTypeTreeApi.qualifier">qualifier</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** @inheritdoc */</span>
    def <a title="=&gt; Trees.this.TypeName" id="scala.reflect.api;Trees;SelectFromTypeTreeApi.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;TypeName" title="Trees.this.TypeName">TypeName</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Intersection type &lt;parent1&gt; with ... with &lt;parentN&gt; { &lt;decls&gt; }, eliminated by RefCheck
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.CompoundTypeTreeApi with Trees.this.TypTree" id="scala.reflect.api;Trees;CompoundTypeTree">CompoundTypeTree</a> &gt;: Null &lt;: CompoundTypeTreeApi with TypTree

  <span class="comment">/** The constructor/extractor for `CompoundTypeTree` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.CompoundTypeTreeExtractor" id="scala.reflect.api;Trees.CompoundTypeTree">CompoundTypeTree</a>: <a href="#scala.reflect.api;Trees;CompoundTypeTreeExtractor" title="Trees.this.CompoundTypeTreeExtractor">CompoundTypeTreeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `CompoundTypeTree(templ)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    parent1 with ... with parentN { refinement }
   *  @group Extractors
   */</span>
  abstract class <a title="class CompoundTypeTreeExtractor extends AnyRef" id="scala.reflect.api;Trees;CompoundTypeTreeExtractor">CompoundTypeTreeExtractor</a> <a href="#scala.reflect.api;Trees;CompoundTypeTreeExtractor" title="Trees.this.CompoundTypeTreeExtractor" class="delimiter">{</a>
    def <a title="(templ: Trees.this.Template)Trees.this.CompoundTypeTree" id="scala.reflect.api;Trees;CompoundTypeTreeExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Template" id="scala.reflect.api;Trees;CompoundTypeTreeExtractor.apply.templ">templ</a>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;CompoundTypeTree" title="Trees.this.CompoundTypeTree">CompoundTypeTree</a>
    def <a title="(compoundTypeTree: Trees.this.CompoundTypeTree)Option[Trees.this.Template]" id="scala.reflect.api;Trees;CompoundTypeTreeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.CompoundTypeTree" id="scala.reflect.api;Trees;CompoundTypeTreeExtractor.unapply.compoundTypeTree">compoundTypeTree</a>: <a href="#scala.reflect.api;Trees;CompoundTypeTree" title="Trees.this.CompoundTypeTree">CompoundTypeTree</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Trees.this.Template]">Option</a><span class="delimiter">[</span>Template<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all compound type trees support
   *  @group API
   */</span>
  trait <a title="trait CompoundTypeTreeApi extends AnyRef with Trees.this.TypTreeApi" id="scala.reflect.api;Trees;CompoundTypeTreeApi">CompoundTypeTreeApi</a> extends <a href="#scala.reflect.api;Trees;TypTreeApi" title="Trees.this.TypTreeApi">TypTreeApi</a> <span class="delimiter">{</span> this: CompoundTypeTree =&gt;
    <span class="comment">/** The template of the compound type - represents the parents, the optional self-type and the optional definitions. */</span>
    def <a title="=&gt; Trees.this.Template" id="scala.reflect.api;Trees;CompoundTypeTreeApi.templ">templ</a>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Applied type &lt;tpt&gt; [ &lt;args&gt; ], eliminated by RefCheck
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.AppliedTypeTreeApi with Trees.this.TypTree" id="scala.reflect.api;Trees;AppliedTypeTree">AppliedTypeTree</a> &gt;: Null &lt;: AppliedTypeTreeApi with TypTree

  <span class="comment">/** The constructor/extractor for `AppliedTypeTree` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.AppliedTypeTreeExtractor" id="scala.reflect.api;Trees.AppliedTypeTree">AppliedTypeTree</a>: <a href="#scala.reflect.api;Trees;AppliedTypeTreeExtractor" title="Trees.this.AppliedTypeTreeExtractor">AppliedTypeTreeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `AppliedTypeTree(tpt, args)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    tpt[args]
   *
   *  Should only be used with `tpt` nodes which are types, i.e. which have `isType` returning `true`.
   *  Otherwise `TypeApply` should be used instead.
   *
   *    List[Int] as in `val x: List[Int] = ???`
   *    // represented as AppliedTypeTree(Ident(&lt;List&gt;), List(TypeTree(&lt;Int&gt;)))
   *
   *    def foo[T] = ???
   *    foo[Int] // represented as TypeApply(Ident(&lt;foo&gt;), List(TypeTree(&lt;Int&gt;)))
   *  @group Extractors
   */</span>
  abstract class <a title="class AppliedTypeTreeExtractor extends AnyRef" id="scala.reflect.api;Trees;AppliedTypeTreeExtractor">AppliedTypeTreeExtractor</a> <a href="#scala.reflect.api;Trees;AppliedTypeTreeExtractor" title="Trees.this.AppliedTypeTreeExtractor" class="delimiter">{</a>
    def <a title="(tpt: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.AppliedTypeTree" id="scala.reflect.api;Trees;AppliedTypeTreeExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;AppliedTypeTreeExtractor.apply.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;AppliedTypeTreeExtractor.apply.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;AppliedTypeTree" title="Trees.this.AppliedTypeTree">AppliedTypeTree</a>
    def <a title="(appliedTypeTree: Trees.this.AppliedTypeTree)Option[(Trees.this.Tree, List[Trees.this.Tree])]" id="scala.reflect.api;Trees;AppliedTypeTreeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.AppliedTypeTree" id="scala.reflect.api;Trees;AppliedTypeTreeExtractor.unapply.appliedTypeTree">appliedTypeTree</a>: <a href="#scala.reflect.api;Trees;AppliedTypeTree" title="Trees.this.AppliedTypeTree">AppliedTypeTree</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, List[Trees.this.Tree])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all applied type trees support
   *  @group API
   */</span>
  trait <a title="trait AppliedTypeTreeApi extends AnyRef with Trees.this.TypTreeApi" id="scala.reflect.api;Trees;AppliedTypeTreeApi">AppliedTypeTreeApi</a> extends <a href="#scala.reflect.api;Trees;TypTreeApi" title="Trees.this.TypTreeApi">TypTreeApi</a> <span class="delimiter">{</span> this: AppliedTypeTree =&gt;
    <span class="comment">/** The target of the application. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;AppliedTypeTreeApi.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The arguments of the application. */</span>
    def <a title="=&gt; List[Trees.this.Tree]" id="scala.reflect.api;Trees;AppliedTypeTreeApi.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Type bounds tree node
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.TypeBoundsTreeApi with Trees.this.TypTree" id="scala.reflect.api;Trees;TypeBoundsTree">TypeBoundsTree</a> &gt;: Null &lt;: TypeBoundsTreeApi with TypTree

  <span class="comment">/** The constructor/extractor for `TypeBoundsTree` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.TypeBoundsTreeExtractor" id="scala.reflect.api;Trees.TypeBoundsTree">TypeBoundsTree</a>: <a href="#scala.reflect.api;Trees;TypeBoundsTreeExtractor" title="Trees.this.TypeBoundsTreeExtractor">TypeBoundsTreeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `TypeBoundsTree(lo, hi)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    &gt;: lo &lt;: hi
   *  @group Extractors
   */</span>
  abstract class <a title="class TypeBoundsTreeExtractor extends AnyRef" id="scala.reflect.api;Trees;TypeBoundsTreeExtractor">TypeBoundsTreeExtractor</a> <a href="#scala.reflect.api;Trees;TypeBoundsTreeExtractor" title="Trees.this.TypeBoundsTreeExtractor" class="delimiter">{</a>
    def <a title="(lo: Trees.this.Tree, hi: Trees.this.Tree)Trees.this.TypeBoundsTree" id="scala.reflect.api;Trees;TypeBoundsTreeExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TypeBoundsTreeExtractor.apply.lo">lo</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TypeBoundsTreeExtractor.apply.hi">hi</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;TypeBoundsTree" title="Trees.this.TypeBoundsTree">TypeBoundsTree</a>
    def <a title="(typeBoundsTree: Trees.this.TypeBoundsTree)Option[(Trees.this.Tree, Trees.this.Tree)]" id="scala.reflect.api;Trees;TypeBoundsTreeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.TypeBoundsTree" id="scala.reflect.api;Trees;TypeBoundsTreeExtractor.unapply.typeBoundsTree">typeBoundsTree</a>: <a href="#scala.reflect.api;Trees;TypeBoundsTree" title="Trees.this.TypeBoundsTree">TypeBoundsTree</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, Trees.this.Tree)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all type bound trees support
   *  @group API
   */</span>
  trait <a title="trait TypeBoundsTreeApi extends AnyRef with Trees.this.TypTreeApi" id="scala.reflect.api;Trees;TypeBoundsTreeApi">TypeBoundsTreeApi</a> extends <a href="#scala.reflect.api;Trees;TypTreeApi" title="Trees.this.TypTreeApi">TypTreeApi</a> <span class="delimiter">{</span> this: TypeBoundsTree =&gt;
    <span class="comment">/** The lower bound.
     *  Is equal to `Ident(&lt;scala.Nothing&gt;)` if not specified explicitly.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;TypeBoundsTreeApi.lo">lo</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The upper bound.
     *  Is equal to `Ident(&lt;scala.Any&gt;)` if not specified explicitly.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;TypeBoundsTreeApi.hi">hi</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Existential type tree node
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.ExistentialTypeTreeApi with Trees.this.TypTree" id="scala.reflect.api;Trees;ExistentialTypeTree">ExistentialTypeTree</a> &gt;: Null &lt;: ExistentialTypeTreeApi with TypTree

  <span class="comment">/** The constructor/extractor for `ExistentialTypeTree` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.ExistentialTypeTreeExtractor" id="scala.reflect.api;Trees.ExistentialTypeTree">ExistentialTypeTree</a>: <a href="#scala.reflect.api;Trees;ExistentialTypeTreeExtractor" title="Trees.this.ExistentialTypeTreeExtractor">ExistentialTypeTreeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `ExistentialTypeTree(tpt, whereClauses)`.
   *  This AST node corresponds to the following Scala code:
   *
   *    tpt forSome { whereClauses }
   *  @group Extractors
   */</span>
  abstract class <a title="class ExistentialTypeTreeExtractor extends AnyRef" id="scala.reflect.api;Trees;ExistentialTypeTreeExtractor">ExistentialTypeTreeExtractor</a> <a href="#scala.reflect.api;Trees;ExistentialTypeTreeExtractor" title="Trees.this.ExistentialTypeTreeExtractor" class="delimiter">{</a>
    def <a title="(tpt: Trees.this.Tree, whereClauses: List[Trees.this.MemberDef])Trees.this.ExistentialTypeTree" id="scala.reflect.api;Trees;ExistentialTypeTreeExtractor.apply">apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;ExistentialTypeTreeExtractor.apply.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.MemberDef]" id="scala.reflect.api;Trees;ExistentialTypeTreeExtractor.apply.whereClauses">whereClauses</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.MemberDef]">List</a><span class="delimiter">[</span>MemberDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;ExistentialTypeTree" title="Trees.this.ExistentialTypeTree">ExistentialTypeTree</a>
    def <a title="(existentialTypeTree: Trees.this.ExistentialTypeTree)Option[(Trees.this.Tree, List[Trees.this.MemberDef])]" id="scala.reflect.api;Trees;ExistentialTypeTreeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.ExistentialTypeTree" id="scala.reflect.api;Trees;ExistentialTypeTreeExtractor.unapply.existentialTypeTree">existentialTypeTree</a>: <a href="#scala.reflect.api;Trees;ExistentialTypeTree" title="Trees.this.ExistentialTypeTree">ExistentialTypeTree</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.Tree, List[Trees.this.MemberDef])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Tree, List<span class="delimiter">[</span>MemberDef<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all existential type trees support
   *  @group API
   */</span>
  trait <a title="trait ExistentialTypeTreeApi extends AnyRef with Trees.this.TypTreeApi" id="scala.reflect.api;Trees;ExistentialTypeTreeApi">ExistentialTypeTreeApi</a> extends <a href="#scala.reflect.api;Trees;TypTreeApi" title="Trees.this.TypTreeApi">TypTreeApi</a> <span class="delimiter">{</span> this: ExistentialTypeTree =&gt;
    <span class="comment">/** The underlying type of the existential type. */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;ExistentialTypeTreeApi.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

    <span class="comment">/** The clauses of the definition of the existential type.
     *  Elements are one of the following:
     *    1) TypeDef with TypeBoundsTree right-hand side
     *    2) ValDef with empty right-hand side
     */</span>
    def <a title="=&gt; List[Trees.this.MemberDef]" id="scala.reflect.api;Trees;ExistentialTypeTreeApi.whereClauses">whereClauses</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.MemberDef]">List</a><span class="delimiter">[</span>MemberDef<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A synthetic tree holding an arbitrary type.  Not to be confused with
   *  with TypTree, the trait for trees that are only used for type trees.
   *  TypeTree's are inserted in several places, but most notably in
   *  `RefCheck`, where the arbitrary type trees are all replaced by
   *  TypeTree's.
   *  @group Trees
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.TypeTreeApi with Trees.this.TypTree" id="scala.reflect.api;Trees;TypeTree">TypeTree</a> &gt;: Null &lt;: TypeTreeApi with TypTree

  <span class="comment">/** The constructor/extractor for `TypeTree` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Trees.this.TypeTreeExtractor" id="scala.reflect.api;Trees.TypeTree(feb2ac9d69)">TypeTree</a>: <a href="#scala.reflect.api;Trees;TypeTreeExtractor" title="Trees.this.TypeTreeExtractor">TypeTreeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `TypeTree()`.
   *  This AST node does not have direct correspondence to Scala code,
   *  and is emitted by everywhere when we want to wrap a `Type` in a `Tree`.
   *  @group Extractors
   */</span>
  abstract class <a title="class TypeTreeExtractor extends AnyRef" id="scala.reflect.api;Trees;TypeTreeExtractor">TypeTreeExtractor</a> <a href="#scala.reflect.api;Trees;TypeTreeExtractor" title="Trees.this.TypeTreeExtractor" class="delimiter">{</a>
    def <a title="()Trees.this.TypeTree" id="scala.reflect.api;Trees;TypeTreeExtractor.apply">apply</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;TypeTree" title="Trees.this.TypeTree">TypeTree</a>
    def <a title="(typeTree: Trees.this.TypeTree)Boolean" id="scala.reflect.api;Trees;TypeTreeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.TypeTree" id="scala.reflect.api;Trees;TypeTreeExtractor.unapply.typeTree">typeTree</a>: <a href="#scala.reflect.api;Trees;TypeTree" title="Trees.this.TypeTree">TypeTree</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all type trees support
   *  @group API
   */</span>
  trait <a title="trait TypeTreeApi extends AnyRef with Trees.this.TypTreeApi" id="scala.reflect.api;Trees;TypeTreeApi">TypeTreeApi</a> extends <a href="#scala.reflect.api;Trees;TypTreeApi" title="Trees.this.TypTreeApi">TypTreeApi</a> <span class="delimiter">{</span> this: TypeTree =&gt;
    <span class="comment">/** The precursor of this tree.
     *  Is equal to `EmptyTree` if this type tree doesn't have precursors.
     */</span>
    def <a title="=&gt; Trees.this.Tree" id="scala.reflect.api;Trees;TypeTreeApi.original">original</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** An empty deferred value definition corresponding to:
   *    val _: _
   *  This is used as a placeholder in the `self` parameter Template if there is
   *  no definition of a self value of self type.
   *  @group Trees
   */</span>
  val <a title="=&gt; Trees.this.ValDef" id="scala.reflect.api;Trees.noSelfType">noSelfType</a>: <a href="#scala.reflect.api;Trees;ValDef" title="Trees.this.ValDef">ValDef</a>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `noSelfType` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
  val <a title="=&gt; Trees.this.ValDef" id="scala.reflect.api;Trees.emptyValDef">emptyValDef</a>: <a href="#scala.reflect.api;Trees;ValDef" title="Trees.this.ValDef">ValDef</a>

  <span class="comment">/** An empty superclass constructor call corresponding to:
   *    super.&lt;init&gt;()
   *  This is used as a placeholder in the primary constructor body in class templates
   *  to denote the insertion point of a call to superclass constructor after the typechecker
   *  figures out the superclass of a given template.
   *  @group Trees
   */</span>
  val <a title="=&gt; Trees.this.Apply" id="scala.reflect.api;Trees.pendingSuperCall">pendingSuperCall</a>: <a href="#scala.reflect.api;Trees;Apply" title="Trees.this.Apply">Apply</a>

<span class="comment">// ---------------------- factories ----------------------------------------------</span>

  <span class="comment">/** A factory method for `Block` nodes.
   *  Flattens directly nested blocks.
   *  @group Factories
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use q\&quot;{..$stats}\&quot; instead. Flatten directly nested blocks manually if needed&quot;</span>, <span class="string">&quot;2.10.1&quot;</span><span class="delimiter">)</span>
  def <a title="(stats: Trees.this.Tree*)Trees.this.Block" id="scala.reflect.api;Trees.Block(29b0c14cf1)">Block</a><span class="delimiter">(</span><a title="Trees.this.Tree*" id="scala.reflect.api;Trees.Block(29b0c14cf1).stats">stats</a>: <span title="Trees.this.Tree*">Tree</span>*<span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Block" title="Trees.this.Block">Block</a>

  <span class="comment">/** A factory method for `CaseDef` nodes.
   *  @group Factories
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use cq\&quot;$pat =&gt; $body\&quot; instead&quot;</span>, <span class="string">&quot;2.10.1&quot;</span><span class="delimiter">)</span>
  def <a title="(pat: Trees.this.Tree, body: Trees.this.Tree)Trees.this.CaseDef" id="scala.reflect.api;Trees.CaseDef(0e192c8c93)">CaseDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees.CaseDef(0e192c8c93).pat">pat</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees.CaseDef(0e192c8c93).body">body</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;CaseDef" title="Trees.this.CaseDef">CaseDef</a>

  <span class="comment">/** A factory method for `Bind` nodes.
   *  @group Factories
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use the canonical Bind constructor to create a bind and then initialize its symbol manually&quot;</span>, <span class="string">&quot;2.10.1&quot;</span><span class="delimiter">)</span>
  def <a title="(sym: Trees.this.Symbol, body: Trees.this.Tree)Trees.this.Bind" id="scala.reflect.api;Trees.Bind(deb2955bab)">Bind</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees.Bind(deb2955bab).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees.Bind(deb2955bab).body">body</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Bind" title="Trees.this.Bind">Bind</a>

  <span class="comment">/** A factory method for `Try` nodes.
   *  @group Factories
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Convert cases into casedefs and use q\&quot;try $body catch { case ..$newcases }\&quot; instead&quot;</span>, <span class="string">&quot;2.10.1&quot;</span><span class="delimiter">)</span>
  def <a title="(body: Trees.this.Tree, cases: (Trees.this.Tree, Trees.this.Tree)*)Trees.this.Try" id="scala.reflect.api;Trees.Try(2a4d469202)">Try</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees.Try(2a4d469202).body">body</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="(Trees.this.Tree, Trees.this.Tree)*" id="scala.reflect.api;Trees.Try(2a4d469202).cases">cases</a>: <span title="(Trees.this.Tree, Trees.this.Tree)*" class="delimiter">(</span>Tree, Tree<span class="delimiter">)</span>*<span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Try" title="Trees.this.Try">Try</a>

  <span class="comment">/** A factory method for `Throw` nodes.
   *  @group Factories
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use q\&quot;throw new $tpe(..$args)\&quot; instead&quot;</span>, <span class="string">&quot;2.10.1&quot;</span><span class="delimiter">)</span>
  def <a title="(tpe: Trees.this.Type, args: Trees.this.Tree*)Trees.this.Throw" id="scala.reflect.api;Trees.Throw(7ab2c72ed6)">Throw</a><span class="delimiter">(</span><a title="Trees.this.Type" id="scala.reflect.api;Trees.Throw(7ab2c72ed6).tpe">tpe</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Trees.this.Type">Type</a>, <a title="Trees.this.Tree*" id="scala.reflect.api;Trees.Throw(7ab2c72ed6).args">args</a>: <span title="Trees.this.Tree*">Tree</span>*<span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Throw" title="Trees.this.Throw">Throw</a>

  <span class="comment">/** Factory method for object creation `new tpt(args_1)...(args_n)`
   *  A `New(t, as)` is expanded to: `(new t).&lt;init&gt;(as)`
   *  @group Factories
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use q\&quot;new $tpt(...$argss)\&quot; instead&quot;</span>, <span class="string">&quot;2.10.1&quot;</span><span class="delimiter">)</span>
  def <a title="(tpt: Trees.this.Tree, argss: List[List[Trees.this.Tree]])Trees.this.Tree" id="scala.reflect.api;Trees.New(57d0b484ba)">New</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees.New(57d0b484ba).tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[List[Trees.this.Tree]]" id="scala.reflect.api;Trees.New(57d0b484ba).argss">argss</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Trees.this.Tree]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

  <span class="comment">/** 0-1 argument list new, based on a type.
   *  @group Factories
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use q\&quot;new $tpe(..$args)\&quot; instead&quot;</span>, <span class="string">&quot;2.10.1&quot;</span><span class="delimiter">)</span>
  def <a title="(tpe: Trees.this.Type, args: Trees.this.Tree*)Trees.this.Tree" id="scala.reflect.api;Trees.New(05bd7cb144)">New</a><span class="delimiter">(</span><a title="Trees.this.Type" id="scala.reflect.api;Trees.New(05bd7cb144).tpe">tpe</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Trees.this.Type">Type</a>, <a title="Trees.this.Tree*" id="scala.reflect.api;Trees.New(05bd7cb144).args">args</a>: <span title="Trees.this.Tree*">Tree</span>*<span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

  <span class="comment">/** 0-1 argument list new, based on a symbol.
   *  @group Factories
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use q\&quot;new ${sym.toType}(..$args)\&quot; instead&quot;</span>, <span class="string">&quot;2.10.1&quot;</span><span class="delimiter">)</span>
  def <a title="(sym: Trees.this.Symbol, args: Trees.this.Tree*)Trees.this.Tree" id="scala.reflect.api;Trees.New(4de1e94e7d)">New</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees.New(4de1e94e7d).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Tree*" id="scala.reflect.api;Trees.New(4de1e94e7d).args">args</a>: <span title="Trees.this.Tree*">Tree</span>*<span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

  <span class="comment">/** A factory method for `Apply` nodes.
   *  @group Factories
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use q\&quot;$sym(..$args)\&quot; instead&quot;</span>, <span class="string">&quot;2.10.1&quot;</span><span class="delimiter">)</span>
  def <a title="(sym: Trees.this.Symbol, args: Trees.this.Tree*)Trees.this.Tree" id="scala.reflect.api;Trees.Apply(4de1e94e7d)">Apply</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees.Apply(4de1e94e7d).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.Tree*" id="scala.reflect.api;Trees.Apply(4de1e94e7d).args">args</a>: <span title="Trees.this.Tree*">Tree</span>*<span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

  <span class="comment">/** 0-1 argument list new, based on a type tree.
   *  @group Factories
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use q\&quot;new $tpt(..$args)\&quot; instead&quot;</span>, <span class="string">&quot;2.10.1&quot;</span><span class="delimiter">)</span>
  def <a title="(tpt: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.Tree" id="scala.reflect.api;Trees.ApplyConstructor">ApplyConstructor</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees.ApplyConstructor.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees.ApplyConstructor.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

  <span class="comment">/** A factory method for `Super` nodes.
   *  @group Factories
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use q\&quot;$sym.super[$mix].x\&quot;.qualifier instead&quot;</span>, <span class="string">&quot;2.10.1&quot;</span><span class="delimiter">)</span>
  def <a title="(sym: Trees.this.Symbol, mix: Trees.this.TypeName)Trees.this.Tree" id="scala.reflect.api;Trees.Super(71be4da37b)">Super</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees.Super(71be4da37b).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a>, <a title="Trees.this.TypeName" id="scala.reflect.api;Trees.Super(71be4da37b).mix">mix</a>: <a href="Names.scala.html#scala.reflect.api;Names;TypeName" title="Trees.this.TypeName">TypeName</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

  <span class="comment">/** A factory method for `This` nodes.
   *  @group Factories
   */</span>
  def <a title="(sym: Trees.this.Symbol)Trees.this.Tree" id="scala.reflect.api;Trees.This(3731e4786e)">This</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees.This(3731e4786e).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>

  <span class="comment">/** A factory method for `Select` nodes.
   *  The string `name` argument is assumed to represent a [[scala.reflect.api.Names#TermName `TermName`]].
   *  @group Factories
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use Select(tree, TermName(name)) instead&quot;</span>, <span class="string">&quot;2.10.1&quot;</span><span class="delimiter">)</span>
  def <a title="(qualifier: Trees.this.Tree, name: String)Trees.this.Select" id="scala.reflect.api;Trees.Select(f8122702da)">Select</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees.Select(f8122702da).qualifier">qualifier</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="String" id="scala.reflect.api;Trees.Select(f8122702da).name">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Select" title="Trees.this.Select">Select</a>

  <span class="comment">/** A factory method for `Select` nodes.
   *  @group Factories
   */</span>
  def <a title="(qualifier: Trees.this.Tree, sym: Trees.this.Symbol)Trees.this.Select" id="scala.reflect.api;Trees.Select(dd97d6dc80)">Select</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees.Select(dd97d6dc80).qualifier">qualifier</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Symbol" id="scala.reflect.api;Trees.Select(dd97d6dc80).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Select" title="Trees.this.Select">Select</a>

  <span class="comment">/** A factory method for `Ident` nodes.
   *  @group Factories
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use Ident(TermName(name)) instead&quot;</span>, <span class="string">&quot;2.10.1&quot;</span><span class="delimiter">)</span>
  def <a title="(name: String)Trees.this.Ident" id="scala.reflect.api;Trees.Ident(b2a46809c4)">Ident</a><span class="delimiter">(</span><a title="String" id="scala.reflect.api;Trees.Ident(b2a46809c4).name">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Ident" title="Trees.this.Ident">Ident</a>

  <span class="comment">/** A factory method for `Ident` nodes.
   *  @group Factories
   */</span>
  def <a title="(sym: Trees.this.Symbol)Trees.this.Ident" id="scala.reflect.api;Trees.Ident(e8c336bf3b)">Ident</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees.Ident(e8c336bf3b).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Ident" title="Trees.this.Ident">Ident</a>

  <span class="comment">/** A factory method for `TypeTree` nodes.
   *  @group Factories
   */</span>
  def <a title="(tp: Trees.this.Type)Trees.this.TypeTree" id="scala.reflect.api;Trees.TypeTree(559e7d9959)">TypeTree</a><span class="delimiter">(</span><a title="Trees.this.Type" id="scala.reflect.api;Trees.TypeTree(559e7d9959).tp">tp</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Trees.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;TypeTree" title="Trees.this.TypeTree">TypeTree</a>

<span class="comment">// ---------------------- copying ------------------------------------------------</span>

  <span class="comment">/** The type of standard (lazy) tree copiers.
   *  @template
   *  @group Copying
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.TreeCopierOps" id="scala.reflect.api;Trees;TreeCopier">TreeCopier</a> &gt;: Null &lt;: AnyRef with TreeCopierOps

  <span class="comment">/** The standard (lazy) tree copier.
   *  @group Copying
   */</span>
  val <a title="Trees.this.TreeCopier" id="scala.reflect.api;Trees.treeCopy">treeCopy</a>: <a href="#scala.reflect.api;Trees;TreeCopier" title="Trees.this.TreeCopier">TreeCopier</a> = <a href="#scala.reflect.api;Trees.newLazyTreeCopier" title="=&gt; Trees.this.TreeCopier">newLazyTreeCopier</a>

  <span class="comment">/** Creates a strict tree copier.
   *  @group Copying
   */</span>
  def <a title="=&gt; Trees.this.TreeCopier" id="scala.reflect.api;Trees.newStrictTreeCopier">newStrictTreeCopier</a>: <a href="#scala.reflect.api;Trees;TreeCopier" title="Trees.this.TreeCopier">TreeCopier</a>

  <span class="comment">/** Creates a lazy tree copier.
   *  @group Copying
   */</span>
  def <a title="=&gt; Trees.this.TreeCopier" id="scala.reflect.api;Trees.newLazyTreeCopier">newLazyTreeCopier</a>: <a href="#scala.reflect.api;Trees;TreeCopier" title="Trees.this.TreeCopier">TreeCopier</a>

  <span class="comment">/** The API of a tree copier.
   *  @group API
   */</span>
  abstract class <a title="class TreeCopierOps extends AnyRef" id="scala.reflect.api;Trees;TreeCopierOps">TreeCopierOps</a> <a href="#scala.reflect.api;Trees;TreeCopierOps" title="Trees.this.TreeCopierOps" class="delimiter">{</a>
    <span class="comment">/** Creates a `ClassDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, mods: Trees.this.Modifiers, name: Trees.this.Name, tparams: List[Trees.this.TypeDef], impl: Trees.this.Template)Trees.this.ClassDef" id="scala.reflect.api;Trees;TreeCopierOps.ClassDef">ClassDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.ClassDef.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;TreeCopierOps.ClassDef.mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;TreeCopierOps.ClassDef.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>, <a title="List[Trees.this.TypeDef]" id="scala.reflect.api;Trees;TreeCopierOps.ClassDef.tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, <a title="Trees.this.Template" id="scala.reflect.api;Trees;TreeCopierOps.ClassDef.impl">impl</a>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;ClassDef" title="Trees.this.ClassDef">ClassDef</a>

    <span class="comment">/** Creates a `PackageDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, pid: Trees.this.RefTree, stats: List[Trees.this.Tree])Trees.this.PackageDef" id="scala.reflect.api;Trees;TreeCopierOps.PackageDef">PackageDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.PackageDef.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.RefTree" id="scala.reflect.api;Trees;TreeCopierOps.PackageDef.pid">pid</a>: <a href="#scala.reflect.api;Trees;RefTree" title="Trees.this.RefTree">RefTree</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;TreeCopierOps.PackageDef.stats">stats</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;PackageDef" title="Trees.this.PackageDef">PackageDef</a>

    <span class="comment">/** Creates a `ModuleDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, mods: Trees.this.Modifiers, name: Trees.this.Name, impl: Trees.this.Template)Trees.this.ModuleDef" id="scala.reflect.api;Trees;TreeCopierOps.ModuleDef">ModuleDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.ModuleDef.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;TreeCopierOps.ModuleDef.mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;TreeCopierOps.ModuleDef.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>, <a title="Trees.this.Template" id="scala.reflect.api;Trees;TreeCopierOps.ModuleDef.impl">impl</a>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;ModuleDef" title="Trees.this.ModuleDef">ModuleDef</a>

    <span class="comment">/** Creates a `ValDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, mods: Trees.this.Modifiers, name: Trees.this.Name, tpt: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.ValDef" id="scala.reflect.api;Trees;TreeCopierOps.ValDef">ValDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.ValDef.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;TreeCopierOps.ValDef.mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;TreeCopierOps.ValDef.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.ValDef.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.ValDef.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;ValDef" title="Trees.this.ValDef">ValDef</a>

    <span class="comment">/** Creates a `DefDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, mods: Trees.this.Modifiers, name: Trees.this.Name, tparams: List[Trees.this.TypeDef], vparamss: List[List[Trees.this.ValDef]], tpt: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.DefDef" id="scala.reflect.api;Trees;TreeCopierOps.DefDef">DefDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.DefDef.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;TreeCopierOps.DefDef.mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;TreeCopierOps.DefDef.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>, <a title="List[Trees.this.TypeDef]" id="scala.reflect.api;Trees;TreeCopierOps.DefDef.tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, <a title="List[List[Trees.this.ValDef]]" id="scala.reflect.api;Trees;TreeCopierOps.DefDef.vparamss">vparamss</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Trees.this.ValDef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.DefDef.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.DefDef.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;DefDef" title="Trees.this.DefDef">DefDef</a>

    <span class="comment">/** Creates a `TypeDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, mods: Trees.this.Modifiers, name: Trees.this.Name, tparams: List[Trees.this.TypeDef], rhs: Trees.this.Tree)Trees.this.TypeDef" id="scala.reflect.api;Trees;TreeCopierOps.TypeDef">TypeDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.TypeDef.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;TreeCopierOps.TypeDef.mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;TreeCopierOps.TypeDef.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>, <a title="List[Trees.this.TypeDef]" id="scala.reflect.api;Trees;TreeCopierOps.TypeDef.tparams">tparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.TypeDef.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;TypeDef" title="Trees.this.TypeDef">TypeDef</a>

    <span class="comment">/** Creates a `LabelDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, name: Trees.this.Name, params: List[Trees.this.Ident], rhs: Trees.this.Tree)Trees.this.LabelDef" id="scala.reflect.api;Trees;TreeCopierOps.LabelDef">LabelDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.LabelDef.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;TreeCopierOps.LabelDef.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>, <a title="List[Trees.this.Ident]" id="scala.reflect.api;Trees;TreeCopierOps.LabelDef.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Ident]">List</a><span class="delimiter">[</span>Ident<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.LabelDef.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;LabelDef" title="Trees.this.LabelDef">LabelDef</a>

    <span class="comment">/** Creates a `Import` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, expr: Trees.this.Tree, selectors: List[Trees.this.ImportSelector])Trees.this.Import" id="scala.reflect.api;Trees;TreeCopierOps.Import">Import</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Import.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Import.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.ImportSelector]" id="scala.reflect.api;Trees;TreeCopierOps.Import.selectors">selectors</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.ImportSelector]">List</a><span class="delimiter">[</span>ImportSelector<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Import" title="Trees.this.Import">Import</a>

    <span class="comment">/** Creates a `Template` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, parents: List[Trees.this.Tree], self: Trees.this.ValDef, body: List[Trees.this.Tree])Trees.this.Template" id="scala.reflect.api;Trees;TreeCopierOps.Template">Template</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Template.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;TreeCopierOps.Template.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="Trees.this.ValDef" id="scala.reflect.api;Trees;TreeCopierOps.Template.self">self</a>: <a href="#scala.reflect.api;Trees;ValDef" title="Trees.this.ValDef">ValDef</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;TreeCopierOps.Template.body">body</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a>

    <span class="comment">/** Creates a `Block` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, stats: List[Trees.this.Tree], expr: Trees.this.Tree)Trees.this.Block" id="scala.reflect.api;Trees;TreeCopierOps.Block">Block</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Block.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;TreeCopierOps.Block.stats">stats</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Block.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Block" title="Trees.this.Block">Block</a>

    <span class="comment">/** Creates a `CaseDef` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, pat: Trees.this.Tree, guard: Trees.this.Tree, body: Trees.this.Tree)Trees.this.CaseDef" id="scala.reflect.api;Trees;TreeCopierOps.CaseDef">CaseDef</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.CaseDef.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.CaseDef.pat">pat</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.CaseDef.guard">guard</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.CaseDef.body">body</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;CaseDef" title="Trees.this.CaseDef">CaseDef</a>

    <span class="comment">/** Creates a `Alternative` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, trees: List[Trees.this.Tree])Trees.this.Alternative" id="scala.reflect.api;Trees;TreeCopierOps.Alternative">Alternative</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Alternative.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;TreeCopierOps.Alternative.trees">trees</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Alternative" title="Trees.this.Alternative">Alternative</a>

    <span class="comment">/** Creates a `Star` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, elem: Trees.this.Tree)Trees.this.Star" id="scala.reflect.api;Trees;TreeCopierOps.Star">Star</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Star.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Star.elem">elem</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Star" title="Trees.this.Star">Star</a>

    <span class="comment">/** Creates a `Bind` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, name: Trees.this.Name, body: Trees.this.Tree)Trees.this.Bind" id="scala.reflect.api;Trees;TreeCopierOps.Bind">Bind</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Bind.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;TreeCopierOps.Bind.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Bind.body">body</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Bind" title="Trees.this.Bind">Bind</a>

    <span class="comment">/** Creates a `UnApply` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, fun: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.UnApply" id="scala.reflect.api;Trees;TreeCopierOps.UnApply">UnApply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.UnApply.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.UnApply.fun">fun</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;TreeCopierOps.UnApply.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;UnApply" title="Trees.this.UnApply">UnApply</a>

    <span class="comment">/** Creates a `Function` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, vparams: List[Trees.this.ValDef], body: Trees.this.Tree)Trees.this.Function" id="scala.reflect.api;Trees;TreeCopierOps.Function">Function</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Function.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.ValDef]" id="scala.reflect.api;Trees;TreeCopierOps.Function.vparams">vparams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.ValDef]">List</a><span class="delimiter">[</span>ValDef<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Function.body">body</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Function" title="Trees.this.Function">Function</a>

    <span class="comment">/** Creates a `Assign` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, lhs: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.Assign" id="scala.reflect.api;Trees;TreeCopierOps.Assign">Assign</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Assign.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Assign.lhs">lhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Assign.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Assign" title="Trees.this.Assign">Assign</a>

    <span class="comment">/** Creates a `AssignOrNamedArg` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, lhs: Trees.this.Tree, rhs: Trees.this.Tree)Trees.this.AssignOrNamedArg" id="scala.reflect.api;Trees;TreeCopierOps.AssignOrNamedArg">AssignOrNamedArg</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.AssignOrNamedArg.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.AssignOrNamedArg.lhs">lhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.AssignOrNamedArg.rhs">rhs</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;AssignOrNamedArg" title="Trees.this.AssignOrNamedArg">AssignOrNamedArg</a>

    <span class="comment">/** Creates a `If` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, cond: Trees.this.Tree, thenp: Trees.this.Tree, elsep: Trees.this.Tree)Trees.this.If" id="scala.reflect.api;Trees;TreeCopierOps.If">If</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.If.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.If.cond">cond</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.If.thenp">thenp</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.If.elsep">elsep</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;If" title="Trees.this.If">If</a>

    <span class="comment">/** Creates a `Match` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, selector: Trees.this.Tree, cases: List[Trees.this.CaseDef])Trees.this.Match" id="scala.reflect.api;Trees;TreeCopierOps.Match">Match</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Match.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Match.selector">selector</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.CaseDef]" id="scala.reflect.api;Trees;TreeCopierOps.Match.cases">cases</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Match" title="Trees.this.Match">Match</a>

    <span class="comment">/** Creates a `Return` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, expr: Trees.this.Tree)Trees.this.Return" id="scala.reflect.api;Trees;TreeCopierOps.Return">Return</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Return.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Return.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Return" title="Trees.this.Return">Return</a>

    <span class="comment">/** Creates a `Try` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, block: Trees.this.Tree, catches: List[Trees.this.CaseDef], finalizer: Trees.this.Tree)Trees.this.Try" id="scala.reflect.api;Trees;TreeCopierOps.Try">Try</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Try.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Try.block">block</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.CaseDef]" id="scala.reflect.api;Trees;TreeCopierOps.Try.catches">catches</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Try.finalizer">finalizer</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Try" title="Trees.this.Try">Try</a>

    <span class="comment">/** Creates a `Throw` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, expr: Trees.this.Tree)Trees.this.Throw" id="scala.reflect.api;Trees;TreeCopierOps.Throw">Throw</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Throw.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Throw.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Throw" title="Trees.this.Throw">Throw</a>

    <span class="comment">/** Creates a `New` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, tpt: Trees.this.Tree)Trees.this.New" id="scala.reflect.api;Trees;TreeCopierOps.New">New</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.New.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.New.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;New" title="Trees.this.New">New</a>

    <span class="comment">/** Creates a `Typed` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, expr: Trees.this.Tree, tpt: Trees.this.Tree)Trees.this.Typed" id="scala.reflect.api;Trees;TreeCopierOps.Typed">Typed</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Typed.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Typed.expr">expr</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Typed.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Typed" title="Trees.this.Typed">Typed</a>

    <span class="comment">/** Creates a `TypeApply` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, fun: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.TypeApply" id="scala.reflect.api;Trees;TreeCopierOps.TypeApply">TypeApply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.TypeApply.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.TypeApply.fun">fun</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;TreeCopierOps.TypeApply.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;TypeApply" title="Trees.this.TypeApply">TypeApply</a>

    <span class="comment">/** Creates a `Apply` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, fun: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.Apply" id="scala.reflect.api;Trees;TreeCopierOps.Apply">Apply</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Apply.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Apply.fun">fun</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;TreeCopierOps.Apply.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Apply" title="Trees.this.Apply">Apply</a>

    <span class="comment">/** Creates a `Super` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, qual: Trees.this.Tree, mix: Trees.this.TypeName)Trees.this.Super" id="scala.reflect.api;Trees;TreeCopierOps.Super">Super</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Super.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Super.qual">qual</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.TypeName" id="scala.reflect.api;Trees;TreeCopierOps.Super.mix">mix</a>: <a href="Names.scala.html#scala.reflect.api;Names;TypeName" title="Trees.this.TypeName">TypeName</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Super" title="Trees.this.Super">Super</a>

    <span class="comment">/** Creates a `This` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, qual: Trees.this.Name)Trees.this.This" id="scala.reflect.api;Trees;TreeCopierOps.This">This</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.This.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;TreeCopierOps.This.qual">qual</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;This" title="Trees.this.This">This</a>

    <span class="comment">/** Creates a `Select` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, qualifier: Trees.this.Tree, selector: Trees.this.Name)Trees.this.Select" id="scala.reflect.api;Trees;TreeCopierOps.Select">Select</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Select.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Select.qualifier">qualifier</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;TreeCopierOps.Select.selector">selector</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Select" title="Trees.this.Select">Select</a>

    <span class="comment">/** Creates a `Ident` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, name: Trees.this.Name)Trees.this.Ident" id="scala.reflect.api;Trees;TreeCopierOps.Ident">Ident</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Ident.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;TreeCopierOps.Ident.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Ident" title="Trees.this.Ident">Ident</a>

    <span class="comment">/** Creates a `RefTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, qualifier: Trees.this.Tree, selector: Trees.this.Name)Trees.this.RefTree" id="scala.reflect.api;Trees;TreeCopierOps.RefTree">RefTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.RefTree.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.RefTree.qualifier">qualifier</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;TreeCopierOps.RefTree.selector">selector</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;RefTree" title="Trees.this.RefTree">RefTree</a>

    <span class="comment">/** Creates a `ReferenceToBoxed` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, idt: Trees.this.Ident)Trees.this.ReferenceToBoxed" id="scala.reflect.api;Trees;TreeCopierOps.ReferenceToBoxed">ReferenceToBoxed</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.ReferenceToBoxed.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Ident" id="scala.reflect.api;Trees;TreeCopierOps.ReferenceToBoxed.idt">idt</a>: <a href="#scala.reflect.api;Trees;Ident" title="Trees.this.Ident">Ident</a><span class="delimiter">)</span>: <a href="Internals.scala.html#scala.reflect.api;Internals;ReferenceToBoxed" title="Trees.this.ReferenceToBoxed">ReferenceToBoxed</a>

    <span class="comment">/** Creates a `Literal` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, value: Trees.this.Constant)Trees.this.Literal" id="scala.reflect.api;Trees;TreeCopierOps.Literal">Literal</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Literal.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Constant" id="scala.reflect.api;Trees;TreeCopierOps.Literal.value">value</a>: <a href="Constants.scala.html#scala.reflect.api;Constants;Constant" title="Trees.this.Constant">Constant</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Literal" title="Trees.this.Literal">Literal</a>

    <span class="comment">/** Creates a `TypeTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree)Trees.this.TypeTree" id="scala.reflect.api;Trees;TreeCopierOps.TypeTree">TypeTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.TypeTree.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;TypeTree" title="Trees.this.TypeTree">TypeTree</a>

    <span class="comment">/** Creates a `Annotated` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, annot: Trees.this.Tree, arg: Trees.this.Tree)Trees.this.Annotated" id="scala.reflect.api;Trees;TreeCopierOps.Annotated">Annotated</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Annotated.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Annotated.annot">annot</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.Annotated.arg">arg</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Annotated" title="Trees.this.Annotated">Annotated</a>

    <span class="comment">/** Creates a `SingletonTypeTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, ref: Trees.this.Tree)Trees.this.SingletonTypeTree" id="scala.reflect.api;Trees;TreeCopierOps.SingletonTypeTree">SingletonTypeTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.SingletonTypeTree.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.SingletonTypeTree.ref">ref</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;SingletonTypeTree" title="Trees.this.SingletonTypeTree">SingletonTypeTree</a>

    <span class="comment">/** Creates a `SelectFromTypeTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, qualifier: Trees.this.Tree, selector: Trees.this.Name)Trees.this.SelectFromTypeTree" id="scala.reflect.api;Trees;TreeCopierOps.SelectFromTypeTree">SelectFromTypeTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.SelectFromTypeTree.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.SelectFromTypeTree.qualifier">qualifier</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;TreeCopierOps.SelectFromTypeTree.selector">selector</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;SelectFromTypeTree" title="Trees.this.SelectFromTypeTree">SelectFromTypeTree</a>

    <span class="comment">/** Creates a `CompoundTypeTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, templ: Trees.this.Template)Trees.this.CompoundTypeTree" id="scala.reflect.api;Trees;TreeCopierOps.CompoundTypeTree">CompoundTypeTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.CompoundTypeTree.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Template" id="scala.reflect.api;Trees;TreeCopierOps.CompoundTypeTree.templ">templ</a>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;CompoundTypeTree" title="Trees.this.CompoundTypeTree">CompoundTypeTree</a>

    <span class="comment">/** Creates a `AppliedTypeTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, tpt: Trees.this.Tree, args: List[Trees.this.Tree])Trees.this.AppliedTypeTree" id="scala.reflect.api;Trees;TreeCopierOps.AppliedTypeTree">AppliedTypeTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.AppliedTypeTree.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.AppliedTypeTree.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;TreeCopierOps.AppliedTypeTree.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;AppliedTypeTree" title="Trees.this.AppliedTypeTree">AppliedTypeTree</a>

    <span class="comment">/** Creates a `TypeBoundsTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, lo: Trees.this.Tree, hi: Trees.this.Tree)Trees.this.TypeBoundsTree" id="scala.reflect.api;Trees;TreeCopierOps.TypeBoundsTree">TypeBoundsTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.TypeBoundsTree.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.TypeBoundsTree.lo">lo</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.TypeBoundsTree.hi">hi</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;TypeBoundsTree" title="Trees.this.TypeBoundsTree">TypeBoundsTree</a>

    <span class="comment">/** Creates a `ExistentialTypeTree` node from the given components, having a given `tree` as a prototype.
     *  Having a tree as a prototype means that the tree's attachments, type and symbol will be copied into the result.
     */</span>
    def <a title="(tree: Trees.this.Tree, tpt: Trees.this.Tree, whereClauses: List[Trees.this.MemberDef])Trees.this.ExistentialTypeTree" id="scala.reflect.api;Trees;TreeCopierOps.ExistentialTypeTree">ExistentialTypeTree</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.ExistentialTypeTree.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees;TreeCopierOps.ExistentialTypeTree.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a>, <a title="List[Trees.this.MemberDef]" id="scala.reflect.api;Trees;TreeCopierOps.ExistentialTypeTree.whereClauses">whereClauses</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.MemberDef]">List</a><span class="delimiter">[</span>MemberDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;ExistentialTypeTree" title="Trees.this.ExistentialTypeTree">ExistentialTypeTree</a>
  <span class="delimiter">}</span>

<span class="comment">// ---------------------- traversing and transforming ------------------------------</span>

  <span class="comment">/** A class that implement a default tree traversal strategy: breadth-first component-wise.
   *  @group Traversal
   */</span>
  class <a title="class Traverser extends AnyRef" id="scala.reflect.api;Trees;Traverser">Traverser</a> <a href="#scala.reflect.api;Trees;Traverser" title="Trees.this.Traverser" class="delimiter">{</a>
    protected<span class="delimiter">[</span>scala<span class="delimiter">]</span> var <a title="Trees.this.Symbol" id="scala.reflect.api;Trees;Traverser.currentOwner_=">currentOwner</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a> = <a href="Mirrors.scala.html#scala.reflect.api;Mirrors.rootMirror" title="=&gt; Trees.this.Mirror">rootMirror</a>.<a href="Mirror.scala.html#scala.reflect.api;Mirror.RootClass" title="=&gt; Trees.this.ClassSymbol">RootClass</a>

    <span class="comment">/** Traverse something which Trees contain, but which isn't a Tree itself. */</span>
    def <a title="(name: Trees.this.Name)Unit" id="scala.reflect.api;Trees;Traverser.traverseName">traverseName</a><span class="delimiter">(</span><a title="Trees.this.Name" id="scala.reflect.api;Trees;Traverser.traverseName.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>                    = <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
    def <a title="(c: Trees.this.Constant)Unit" id="scala.reflect.api;Trees;Traverser.traverseConstant">traverseConstant</a><span class="delimiter">(</span><a title="Trees.this.Constant" id="scala.reflect.api;Trees;Traverser.traverseConstant.c">c</a>: <a href="Constants.scala.html#scala.reflect.api;Constants;Constant" title="Trees.this.Constant">Constant</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>               = <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
    def <a title="(sel: Trees.this.ImportSelector)Unit" id="scala.reflect.api;Trees;Traverser.traverseImportSelector">traverseImportSelector</a><span class="delimiter">(</span><a title="Trees.this.ImportSelector" id="scala.reflect.api;Trees;Traverser.traverseImportSelector.sel">sel</a>: <a href="#scala.reflect.api;Trees;ImportSelector" title="Trees.this.ImportSelector">ImportSelector</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
    def <a title="(mods: Trees.this.Modifiers)Unit" id="scala.reflect.api;Trees;Traverser.traverseModifiers">traverseModifiers</a><span class="delimiter">(</span><a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;Traverser.traverseModifiers.mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>          = <a href="#scala.reflect.api;Trees;Traverser.traverseAnnotations" title="(annots: List[Trees.this.Tree])Unit">traverseAnnotations</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverseModifiers.mods" title="Trees.this.Modifiers">mods</a>.<a href="#scala.reflect.api;Trees;ModifiersApi.annotations" title="=&gt; List[Trees.this.Tree]">annotations</a><span class="delimiter">)</span>

    <span class="comment">/** Traverses a single tree. */</span>
    def <a title="(tree: Trees.this.Tree)Unit" id="scala.reflect.api;Trees;Traverser.traverse">traverse</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;Traverser.traverse.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>              = <a href="#scala.reflect.api;Trees.itraverse" title="(traverser: Trees.this.Traverser, tree: Trees.this.Tree)Unit">itraverse</a><span class="delimiter">(</span>this, <a href="#scala.reflect.api;Trees;Traverser.traverse.tree" title="Trees.this.Tree">tree</a><span class="delimiter">)</span>
    def <a title="(pat: Trees.this.Tree)Unit" id="scala.reflect.api;Trees;Traverser.traversePattern">traversePattern</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;Traverser.traversePattern.pat">pat</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>        = <a href="#scala.reflect.api;Trees;Traverser.traverse" title="(tree: Trees.this.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traversePattern.pat" title="Trees.this.Tree">pat</a><span class="delimiter">)</span>
    def <a title="(guard: Trees.this.Tree)Unit" id="scala.reflect.api;Trees;Traverser.traverseGuard">traverseGuard</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;Traverser.traverseGuard.guard">guard</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>        = <a href="#scala.reflect.api;Trees;Traverser.traverse" title="(tree: Trees.this.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverseGuard.guard" title="Trees.this.Tree">guard</a><span class="delimiter">)</span>
    def <a title="(tpt: Trees.this.Tree)Unit" id="scala.reflect.api;Trees;Traverser.traverseTypeAscription">traverseTypeAscription</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;Traverser.traverseTypeAscription.tpt">tpt</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <a href="#scala.reflect.api;Trees;Traverser.traverse" title="(tree: Trees.this.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverseTypeAscription.tpt" title="Trees.this.Tree">tpt</a><span class="delimiter">)</span>
    <span class="comment">// Special handling of noSelfType necessary for backward compat: existing</span>
    <span class="comment">// traversers break down when they see the unexpected tree.</span>
    def <a title="(self: Trees.this.ValDef)Unit" id="scala.reflect.api;Trees;Traverser.traverseSelfType">traverseSelfType</a><span class="delimiter">(</span><a title="Trees.this.ValDef" id="scala.reflect.api;Trees;Traverser.traverseSelfType.self">self</a>: <a href="#scala.reflect.api;Trees;ValDef" title="Trees.this.ValDef">ValDef</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>    = if <span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverseSelfType.self" title="Trees.this.ValDef">self</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#scala.reflect.api;Trees.noSelfType" title="=&gt; Trees.this.ValDef">noSelfType</a><span class="delimiter">)</span> <a href="#scala.reflect.api;Trees;Traverser.traverse" title="(tree: Trees.this.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverseSelfType.self" title="Trees.this.ValDef">self</a><span class="delimiter">)</span>

    <span class="comment">/** Traverses a list of trees. */</span>
    def <a title="(trees: List[Trees.this.Tree])Unit" id="scala.reflect.api;Trees;Traverser.traverseTrees">traverseTrees</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;Traverser.traverseTrees.trees">trees</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>          = <a href="#scala.reflect.api;Trees;Traverser.traverseTrees.trees" title="List[Trees.this.Tree]">trees</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: Trees.this.Tree =&gt; Unit)Unit">foreach</a> <a href="#scala.reflect.api;Trees;Traverser.traverse" title="(tree: Trees.this.Tree)Unit">traverse</a>
    def <a title="(args: List[Trees.this.Tree])Unit" id="scala.reflect.api;Trees;Traverser.traverseTypeArgs">traverseTypeArgs</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;Traverser.traverseTypeArgs.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>        = <a href="#scala.reflect.api;Trees;Traverser.traverseTrees" title="(trees: List[Trees.this.Tree])Unit">traverseTrees</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverseTypeArgs.args" title="List[Trees.this.Tree]">args</a><span class="delimiter">)</span>
    def <a title="(parents: List[Trees.this.Tree])Unit" id="scala.reflect.api;Trees;Traverser.traverseParents">traverseParents</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;Traverser.traverseParents.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>      = <a href="#scala.reflect.api;Trees;Traverser.traverseTrees" title="(trees: List[Trees.this.Tree])Unit">traverseTrees</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverseParents.parents" title="List[Trees.this.Tree]">parents</a><span class="delimiter">)</span>
    def <a title="(cases: List[Trees.this.CaseDef])Unit" id="scala.reflect.api;Trees;Traverser.traverseCases">traverseCases</a><span class="delimiter">(</span><a title="List[Trees.this.CaseDef]" id="scala.reflect.api;Trees;Traverser.traverseCases.cases">cases</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>       = <a href="#scala.reflect.api;Trees;Traverser.traverseTrees" title="(trees: List[Trees.this.Tree])Unit">traverseTrees</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverseCases.cases" title="List[Trees.this.CaseDef]">cases</a><span class="delimiter">)</span>
    def <a title="(annots: List[Trees.this.Tree])Unit" id="scala.reflect.api;Trees;Traverser.traverseAnnotations">traverseAnnotations</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;Traverser.traverseAnnotations.annots">annots</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>   = <a href="#scala.reflect.api;Trees;Traverser.traverseTrees" title="(trees: List[Trees.this.Tree])Unit">traverseTrees</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverseAnnotations.annots" title="List[Trees.this.Tree]">annots</a><span class="delimiter">)</span>

    <span class="comment">/** Traverses a list of lists of trees. */</span>
    def <a title="(treess: List[List[Trees.this.Tree]])Unit" id="scala.reflect.api;Trees;Traverser.traverseTreess">traverseTreess</a><span class="delimiter">(</span><a title="List[List[Trees.this.Tree]]" id="scala.reflect.api;Trees;Traverser.traverseTreess.treess">treess</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Trees.this.Tree]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>    = <a href="#scala.reflect.api;Trees;Traverser.traverseTreess.treess" title="List[List[Trees.this.Tree]]">treess</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: List[Trees.this.Tree] =&gt; Unit)Unit">foreach</a> <a href="#scala.reflect.api;Trees;Traverser.traverseTrees" title="(trees: List[Trees.this.Tree])Unit">traverseTrees</a>
    def <a title="(params: List[Trees.this.Tree])Unit" id="scala.reflect.api;Trees;Traverser.traverseParams">traverseParams</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;Traverser.traverseParams.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>          = <a href="#scala.reflect.api;Trees;Traverser.traverseTrees" title="(trees: List[Trees.this.Tree])Unit">traverseTrees</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverseParams.params" title="List[Trees.this.Tree]">params</a><span class="delimiter">)</span>
    def <a title="(vparamss: List[List[Trees.this.Tree]])Unit" id="scala.reflect.api;Trees;Traverser.traverseParamss">traverseParamss</a><span class="delimiter">(</span><a title="List[List[Trees.this.Tree]]" id="scala.reflect.api;Trees;Traverser.traverseParamss.vparamss">vparamss</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Trees.this.Tree]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <a href="#scala.reflect.api;Trees;Traverser.traverseParamss.vparamss" title="List[List[Trees.this.Tree]]">vparamss</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: List[Trees.this.Tree] =&gt; Unit)Unit">foreach</a> <a href="#scala.reflect.api;Trees;Traverser.traverseParams" title="(params: List[Trees.this.Tree])Unit">traverseParams</a>

    <span class="comment">/** Traverses a list of trees with a given owner symbol. */</span>
    def <a title="(stats: List[Trees.this.Tree], exprOwner: Trees.this.Symbol)Unit" id="scala.reflect.api;Trees;Traverser.traverseStats">traverseStats</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;Traverser.traverseStats.stats">stats</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="Trees.this.Symbol" id="scala.reflect.api;Trees;Traverser.traverseStats.exprOwner">exprOwner</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#scala.reflect.api;Trees;Traverser.traverseStats.stats" title="List[Trees.this.Tree]">stats</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: Trees.this.Tree =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;Traverser.traverseStats.$anonfun.stat">stat</a> =&gt;
        if <span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverseStats.exprOwner" title="Trees.this.Symbol">exprOwner</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.reflect.api;Trees;Traverser.currentOwner_=" title="=&gt; Trees.this.Symbol">currentOwner</a><span class="delimiter">)</span> <a href="#scala.reflect.api;Trees;Traverser.atOwner" title="(owner: Trees.this.Symbol)(traverse: =&gt; Unit)Unit">atOwner</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverseStats.exprOwner" title="Trees.this.Symbol">exprOwner</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverse" title="(tree: Trees.this.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverseStats.$anonfun.stat" title="Trees.this.Tree">stat</a><span class="delimiter">)</span><span class="delimiter">)</span>
        else <a href="#scala.reflect.api;Trees;Traverser.traverse" title="(tree: Trees.this.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.traverseStats.$anonfun.stat" title="Trees.this.Tree">stat</a><span class="delimiter">)</span>
      <span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Performs a traversal with a given owner symbol. */</span>
    def <a title="(owner: Trees.this.Symbol)(traverse: =&gt; Unit)Unit" id="scala.reflect.api;Trees;Traverser.atOwner">atOwner</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;Traverser.atOwner.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; Unit" id="scala.reflect.api;Trees;Traverser.atOwner.traverse">traverse</a>: =&gt; Unit<span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="Trees.this.Symbol" id="scala.reflect.api;Trees;Traverser.atOwner.prevOwner">prevOwner</a> = <a href="#scala.reflect.api;Trees;Traverser.currentOwner_=" title="=&gt; Trees.this.Symbol">currentOwner</a>
      <a href="#scala.reflect.api;Trees;Traverser.currentOwner_=" title="(x$1: Trees.this.Symbol)Unit">currentOwner</a> = <a href="#scala.reflect.api;Trees;Traverser.atOwner.owner" title="Trees.this.Symbol">owner</a>
      <a href="#scala.reflect.api;Trees;Traverser.atOwner.traverse" title="=&gt; Unit">traverse</a>
      <a href="#scala.reflect.api;Trees;Traverser.currentOwner_=" title="(x$1: Trees.this.Symbol)Unit">currentOwner</a> = <a href="#scala.reflect.api;Trees;Traverser.atOwner.prevOwner" title="Trees.this.Symbol">prevOwner</a>
    <span class="delimiter">}</span>

    <span class="comment">/** Leave apply available in the generic traverser to do something else.
     */</span>
    def <a title="[T &lt;: Trees.this.Tree](tree: T)T" id="scala.reflect.api;Trees;Traverser.apply">apply</a><span class="delimiter">[</span><a title=" &lt;: Trees.this.Tree" id="scala.reflect.api;Trees;Traverser.apply;T">T</a> &lt;: Tree<span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="scala.reflect.api;Trees;Traverser.apply.tree">tree</a>: <a href="#scala.reflect.api;Trees;Traverser.apply;T" title="T">T</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Traverser.apply;T" title="T">T</a> = <span class="delimiter">{</span> <a href="#scala.reflect.api;Trees;Traverser.traverse" title="(tree: Trees.this.Tree)Unit">traverse</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Traverser.apply.tree" title="T">tree</a><span class="delimiter">)</span>; <a href="#scala.reflect.api;Trees;Traverser.apply.tree" title="T">tree</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Delegates the traversal strategy to `scala.reflect.internal.Trees`,
   *  because pattern matching on abstract types we have here degrades performance.
   *  @group Traversal
   */</span>
  protected def <a title="(traverser: Trees.this.Traverser, tree: Trees.this.Tree)Unit" id="scala.reflect.api;Trees.itraverse">itraverse</a><span class="delimiter">(</span><a title="Trees.this.Traverser" id="scala.reflect.api;Trees.itraverse.traverser">traverser</a>: <a href="#scala.reflect.api;Trees;Traverser" title="Trees.this.Traverser">Traverser</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees.itraverse.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = throw new <a href="../../MatchError.scala.html#scala;MatchError" title="MatchError">MatchError</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees.itraverse.tree" title="Trees.this.Tree">tree</a><span class="delimiter">)</span>

  <span class="comment">/** Provides an extension hook for the traversal strategy.
   *  Future-proofs against new node types.
   *  @group Traversal
   */</span>
  protected def <a title="(traverser: Trees.this.Traverser, tree: Trees.this.Tree)Unit" id="scala.reflect.api;Trees.xtraverse">xtraverse</a><span class="delimiter">(</span><a title="Trees.this.Traverser" id="scala.reflect.api;Trees.xtraverse.traverser">traverser</a>: <a href="#scala.reflect.api;Trees;Traverser" title="Trees.this.Traverser">Traverser</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees.xtraverse.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = throw new <a href="../../MatchError.scala.html#scala;MatchError" title="MatchError">MatchError</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees.xtraverse.tree" title="Trees.this.Tree">tree</a><span class="delimiter">)</span>

  <span class="comment">/** A class that implement a default tree transformation strategy: breadth-first component-wise cloning.
   *  @group Traversal
   */</span>
  abstract class <a title="class Transformer extends AnyRef" id="scala.reflect.api;Trees;Transformer">Transformer</a> <a href="#scala.reflect.api;Trees;Transformer" title="Trees.this.Transformer" class="delimiter">{</a>
    <span class="comment">/** The underlying tree copier. */</span>
    val <a title="Trees.this.TreeCopier" id="scala.reflect.api;Trees;Transformer.treeCopy">treeCopy</a>: <a href="#scala.reflect.api;Trees;TreeCopier" title="Trees.this.TreeCopier">TreeCopier</a> = <a href="#scala.reflect.api;Trees.newLazyTreeCopier" title="=&gt; Trees.this.TreeCopier">newLazyTreeCopier</a>

    <span class="comment">/** The current owner symbol. */</span>
    protected<span class="delimiter">[</span>scala<span class="delimiter">]</span> var <a title="Trees.this.Symbol" id="scala.reflect.api;Trees;Transformer.currentOwner_=">currentOwner</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a> = <a href="Mirrors.scala.html#scala.reflect.api;Mirrors.rootMirror" title="=&gt; Trees.this.Mirror">rootMirror</a>.<a href="Mirror.scala.html#scala.reflect.api;Mirror.RootClass" title="=&gt; Trees.this.ClassSymbol">RootClass</a>

    <span class="comment">/** The enclosing method of the currently transformed tree. */</span>
    protected def <a title="=&gt; Trees.this.Symbol" id="scala.reflect.api;Trees;Transformer.currentMethod">currentMethod</a> = <span class="delimiter">{</span>
      def <a title="(sym: Trees.this.Symbol)Trees.this.Symbol" id="scala.reflect.api;Trees;Transformer.currentMethod.enclosingMethod">enclosingMethod</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;Transformer.currentMethod.enclosingMethod.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a> =
        if <span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.currentMethod.enclosingMethod.sym" title="Trees.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isMethod" title="=&gt; Boolean">isMethod</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.api;Trees;Transformer.currentMethod.enclosingMethod.sym" title="Trees.this.Symbol">sym</a> <span title="(x$1: Any)Boolean">==</span> <a href="Symbols.scala.html#scala.reflect.api;Symbols.NoSymbol" title="=&gt; Trees.this.Symbol">NoSymbol</a><span class="delimiter">)</span> <a href="#scala.reflect.api;Trees;Transformer.currentMethod.enclosingMethod.sym" title="Trees.this.Symbol">sym</a> else <a href="#scala.reflect.api;Trees;Transformer.currentMethod.enclosingMethod" title="(sym: Trees.this.Symbol)Trees.this.Symbol">enclosingMethod</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.currentMethod.enclosingMethod.sym" title="Trees.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.owner" title="=&gt; Trees.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#scala.reflect.api;Trees;Transformer.currentMethod.enclosingMethod" title="(sym: Trees.this.Symbol)Trees.this.Symbol">enclosingMethod</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.currentOwner_=" title="=&gt; Trees.this.Symbol">currentOwner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** The enclosing class of the currently transformed tree. */</span>
    protected def <a title="=&gt; Trees.this.Symbol" id="scala.reflect.api;Trees;Transformer.currentClass">currentClass</a> = <span class="delimiter">{</span>
      def <a title="(sym: Trees.this.Symbol)Trees.this.Symbol" id="scala.reflect.api;Trees;Transformer.currentClass.enclosingClass">enclosingClass</a><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;Transformer.currentClass.enclosingClass.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a> =
        if <span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.currentClass.enclosingClass.sym" title="Trees.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isClass" title="=&gt; Boolean">isClass</a> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.api;Trees;Transformer.currentClass.enclosingClass.sym" title="Trees.this.Symbol">sym</a> <span title="(x$1: Any)Boolean">==</span> <a href="Symbols.scala.html#scala.reflect.api;Symbols.NoSymbol" title="=&gt; Trees.this.Symbol">NoSymbol</a><span class="delimiter">)</span> <a href="#scala.reflect.api;Trees;Transformer.currentClass.enclosingClass.sym" title="Trees.this.Symbol">sym</a> else <a href="#scala.reflect.api;Trees;Transformer.currentClass.enclosingClass" title="(sym: Trees.this.Symbol)Trees.this.Symbol">enclosingClass</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.currentClass.enclosingClass.sym" title="Trees.this.Symbol">sym</a>.<a href="Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.owner" title="=&gt; Trees.this.Symbol">owner</a><span class="delimiter">)</span>
      <a href="#scala.reflect.api;Trees;Transformer.currentClass.enclosingClass" title="(sym: Trees.this.Symbol)Trees.this.Symbol">enclosingClass</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.currentOwner_=" title="=&gt; Trees.this.Symbol">currentOwner</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

<span class="comment">//    protected def currentPackage = currentOwner.enclosingTopLevelClass.owner</span>

    <span class="comment">/** Transforms a single tree. */</span>
    def <a title="(tree: Trees.this.Tree)Trees.this.Tree" id="scala.reflect.api;Trees;Transformer.transform">transform</a><span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;Transformer.transform.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a> = <a href="#scala.reflect.api;Trees.itransform" title="(transformer: Trees.this.Transformer, tree: Trees.this.Tree)Trees.this.Tree">itransform</a><span class="delimiter">(</span>this, <a href="#scala.reflect.api;Trees;Transformer.transform.tree" title="Trees.this.Tree">tree</a><span class="delimiter">)</span>

    <span class="comment">/** Transforms a list of trees. */</span>
    def <a title="(trees: List[Trees.this.Tree])List[Trees.this.Tree]" id="scala.reflect.api;Trees;Transformer.transformTrees">transformTrees</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;Transformer.transformTrees.trees">trees</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformTrees.trees" title="List[Trees.this.Tree]">trees</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> else <a href="#scala.reflect.api;Trees;Transformer.transformTrees.trees" title="List[Trees.this.Tree]">trees</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="(f: Trees.this.Tree =&gt; Trees.this.Tree)List[Trees.this.Tree]">mapConserve</a> <a href="#scala.reflect.api;Trees;Transformer.transform" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a>

    <span class="comment">/** Transforms a `Template`. */</span>
    def <a title="(tree: Trees.this.Template)Trees.this.Template" id="scala.reflect.api;Trees;Transformer.transformTemplate">transformTemplate</a><span class="delimiter">(</span><a title="Trees.this.Template" id="scala.reflect.api;Trees;Transformer.transformTemplate.tree">tree</a>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a> =
      <a href="#scala.reflect.api;Trees;Transformer.transform" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformTemplate.tree" title="Trees.this.Template">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Trees.this.Template" class="delimiter">[</span><a href="#scala.reflect.api;Trees;Template" title="Trees.this.Template">Template</a><span class="delimiter">]</span>
    <span class="comment">/** Transforms a list of `TypeDef` trees. */</span>
    def <a title="(trees: List[Trees.this.TypeDef])List[Trees.this.TypeDef]" id="scala.reflect.api;Trees;Transformer.transformTypeDefs">transformTypeDefs</a><span class="delimiter">(</span><a title="List[Trees.this.TypeDef]" id="scala.reflect.api;Trees;Transformer.transformTypeDefs.trees">trees</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.TypeDef]">List</a><span class="delimiter">[</span>TypeDef<span class="delimiter">]</span> =
      <a href="#scala.reflect.api;Trees;Transformer.transformTypeDefs.trees" title="List[Trees.this.TypeDef]">trees</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="(f: Trees.this.TypeDef =&gt; Trees.this.TypeDef)List[Trees.this.TypeDef]">mapConserve</a> <span class="delimiter">(</span><a title="Trees.this.TypeDef" id="scala.reflect.api;Trees;Transformer.transformTypeDefs.$anonfun.tree">tree</a> =&gt; <a href="#scala.reflect.api;Trees;Transformer.transform" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformTypeDefs.$anonfun.tree" title="Trees.this.TypeDef">tree</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Trees.this.TypeDef" class="delimiter">[</span><a href="#scala.reflect.api;Trees;TypeDef" title="Trees.this.TypeDef">TypeDef</a><span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="comment">/** Transforms a `ValDef`. */</span>
    def <a title="(tree: Trees.this.ValDef)Trees.this.ValDef" id="scala.reflect.api;Trees;Transformer.transformValDef">transformValDef</a><span class="delimiter">(</span><a title="Trees.this.ValDef" id="scala.reflect.api;Trees;Transformer.transformValDef.tree">tree</a>: <a href="#scala.reflect.api;Trees;ValDef" title="Trees.this.ValDef">ValDef</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;ValDef" title="Trees.this.ValDef">ValDef</a> =
      if <span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformValDef.tree" title="Trees.this.ValDef">tree</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#scala.reflect.api;Trees.noSelfType" title="=&gt; Trees.this.ValDef">noSelfType</a><span class="delimiter">)</span> <a href="#scala.reflect.api;Trees;Transformer.transformValDef.tree" title="Trees.this.ValDef">tree</a>
      else <a href="#scala.reflect.api;Trees;Transformer.transform" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformValDef.tree" title="Trees.this.ValDef">tree</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Trees.this.ValDef" class="delimiter">[</span><a href="#scala.reflect.api;Trees;ValDef" title="Trees.this.ValDef">ValDef</a><span class="delimiter">]</span>
    <span class="comment">/** Transforms a list of `ValDef` nodes. */</span>
    def <a title="(trees: List[Trees.this.ValDef])List[Trees.this.ValDef]" id="scala.reflect.api;Trees;Transformer.transformValDefs">transformValDefs</a><span class="delimiter">(</span><a title="List[Trees.this.ValDef]" id="scala.reflect.api;Trees;Transformer.transformValDefs.trees">trees</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.ValDef]">List</a><span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.ValDef]">List</a><span class="delimiter">[</span>ValDef<span class="delimiter">]</span> =
      <a href="#scala.reflect.api;Trees;Transformer.transformValDefs.trees" title="List[Trees.this.ValDef]">trees</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="(f: Trees.this.ValDef =&gt; Trees.this.ValDef)List[Trees.this.ValDef]">mapConserve</a> <span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformValDef" title="(tree: Trees.this.ValDef)Trees.this.ValDef">transformValDef</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformValDefs.$anonfun.x$1" title="Trees.this.ValDef">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="comment">/** Transforms a list of lists of `ValDef` nodes. */</span>
    def <a title="(treess: List[List[Trees.this.ValDef]])List[List[Trees.this.ValDef]]" id="scala.reflect.api;Trees;Transformer.transformValDefss">transformValDefss</a><span class="delimiter">(</span><a title="List[List[Trees.this.ValDef]]" id="scala.reflect.api;Trees;Transformer.transformValDefss.treess">treess</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Trees.this.ValDef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Trees.this.ValDef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#scala.reflect.api;Trees;Transformer.transformValDefss.treess" title="List[List[Trees.this.ValDef]]">treess</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="(f: List[Trees.this.ValDef] =&gt; List[Trees.this.ValDef])List[List[Trees.this.ValDef]]">mapConserve</a> <span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformValDefs" title="(trees: List[Trees.this.ValDef])List[Trees.this.ValDef]">transformValDefs</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformValDefss.$anonfun.x$2" title="List[Trees.this.ValDef]">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="comment">/** Transforms a list of `CaseDef` nodes. */</span>
    def <a title="(trees: List[Trees.this.MemberDef])List[Trees.this.MemberDef]" id="scala.reflect.api;Trees;Transformer.transformMemberDefs">transformMemberDefs</a><span class="delimiter">(</span><a title="List[Trees.this.MemberDef]" id="scala.reflect.api;Trees;Transformer.transformMemberDefs.trees">trees</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.MemberDef]">List</a><span class="delimiter">[</span>MemberDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.MemberDef]">List</a><span class="delimiter">[</span>MemberDef<span class="delimiter">]</span> =
      <a href="#scala.reflect.api;Trees;Transformer.transformMemberDefs.trees" title="List[Trees.this.MemberDef]">trees</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="(f: Trees.this.MemberDef =&gt; Trees.this.MemberDef)List[Trees.this.MemberDef]">mapConserve</a> <span class="delimiter">(</span><a title="Trees.this.MemberDef" id="scala.reflect.api;Trees;Transformer.transformMemberDefs.$anonfun.tree">tree</a> =&gt; <a href="#scala.reflect.api;Trees;Transformer.transform" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformMemberDefs.$anonfun.tree" title="Trees.this.MemberDef">tree</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Trees.this.MemberDef" class="delimiter">[</span><a href="#scala.reflect.api;Trees;MemberDef" title="Trees.this.MemberDef">MemberDef</a><span class="delimiter">]</span><span class="delimiter">)</span>
    def <a title="(trees: List[Trees.this.CaseDef])List[Trees.this.CaseDef]" id="scala.reflect.api;Trees;Transformer.transformCaseDefs">transformCaseDefs</a><span class="delimiter">(</span><a title="List[Trees.this.CaseDef]" id="scala.reflect.api;Trees;Transformer.transformCaseDefs.trees">trees</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.CaseDef]">List</a><span class="delimiter">[</span>CaseDef<span class="delimiter">]</span> =
      <a href="#scala.reflect.api;Trees;Transformer.transformCaseDefs.trees" title="List[Trees.this.CaseDef]">trees</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="(f: Trees.this.CaseDef =&gt; Trees.this.CaseDef)List[Trees.this.CaseDef]">mapConserve</a> <span class="delimiter">(</span><a title="Trees.this.CaseDef" id="scala.reflect.api;Trees;Transformer.transformCaseDefs.$anonfun.tree">tree</a> =&gt; <a href="#scala.reflect.api;Trees;Transformer.transform" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformCaseDefs.$anonfun.tree" title="Trees.this.CaseDef">tree</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Trees.this.CaseDef" class="delimiter">[</span><a href="#scala.reflect.api;Trees;CaseDef" title="Trees.this.CaseDef">CaseDef</a><span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="comment">/** Transforms a list of `Ident` nodes. */</span>
    def <a title="(trees: List[Trees.this.Ident])List[Trees.this.Ident]" id="scala.reflect.api;Trees;Transformer.transformIdents">transformIdents</a><span class="delimiter">(</span><a title="List[Trees.this.Ident]" id="scala.reflect.api;Trees;Transformer.transformIdents.trees">trees</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Ident]">List</a><span class="delimiter">[</span>Ident<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Ident]">List</a><span class="delimiter">[</span>Ident<span class="delimiter">]</span> =
      <a href="#scala.reflect.api;Trees;Transformer.transformIdents.trees" title="List[Trees.this.Ident]">trees</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="(f: Trees.this.Ident =&gt; Trees.this.Ident)List[Trees.this.Ident]">mapConserve</a> <span class="delimiter">(</span><a title="Trees.this.Ident" id="scala.reflect.api;Trees;Transformer.transformIdents.$anonfun.tree">tree</a> =&gt; <a href="#scala.reflect.api;Trees;Transformer.transform" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformIdents.$anonfun.tree" title="Trees.this.Ident">tree</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Trees.this.Ident" class="delimiter">[</span><a href="#scala.reflect.api;Trees;Ident" title="Trees.this.Ident">Ident</a><span class="delimiter">]</span><span class="delimiter">)</span>
    <span class="comment">/** Traverses a list of trees with a given owner symbol. */</span>
    def <a title="(stats: List[Trees.this.Tree], exprOwner: Trees.this.Symbol)List[Trees.this.Tree]" id="scala.reflect.api;Trees;Transformer.transformStats">transformStats</a><span class="delimiter">(</span><a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;Transformer.transformStats.stats">stats</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="Trees.this.Symbol" id="scala.reflect.api;Trees;Transformer.transformStats.exprOwner">exprOwner</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span> =
      <a href="#scala.reflect.api;Trees;Transformer.transformStats.stats" title="List[Trees.this.Tree]">stats</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.mapConserve" title="(f: Trees.this.Tree =&gt; Trees.this.Tree)List[Trees.this.Tree]">mapConserve</a> <span class="delimiter">(</span><a title="Trees.this.Tree" id="scala.reflect.api;Trees;Transformer.transformStats.$anonfun.stat">stat</a> =&gt;
        if <span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformStats.exprOwner" title="Trees.this.Symbol">exprOwner</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.reflect.api;Trees;Transformer.currentOwner_=" title="=&gt; Trees.this.Symbol">currentOwner</a> <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.api;Trees;Transformer.transformStats.$anonfun.stat" title="Trees.this.Tree">stat</a>.<a href="#scala.reflect.api;Trees;TreeApi.isTerm" title="=&gt; Boolean">isTerm</a><span class="delimiter">)</span> <a href="#scala.reflect.api;Trees;Transformer.atOwner" title="(owner: Trees.this.Symbol)(trans: =&gt; Trees.this.Tree)Trees.this.Tree">atOwner</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformStats.exprOwner" title="Trees.this.Symbol">exprOwner</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transform" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformStats.$anonfun.stat" title="Trees.this.Tree">stat</a><span class="delimiter">)</span><span class="delimiter">)</span>
        else <a href="#scala.reflect.api;Trees;Transformer.transform" title="(tree: Trees.this.Tree)Trees.this.Tree">transform</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformStats.$anonfun.stat" title="Trees.this.Tree">stat</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filter" title="(p: Trees.this.Tree =&gt; Boolean)List[Trees.this.Tree]">filter</a> <span class="delimiter">(</span><a href="#scala.reflect.api;Trees.EmptyTree" title="=&gt; Trees.this.Tree">EmptyTree</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.reflect.api;Trees;Transformer.transformStats.$anonfun.x$3" title="Trees.this.Tree">_</a><span class="delimiter">)</span>
    <span class="comment">/** Transforms `Modifiers`. */</span>
    def <a title="(mods: Trees.this.Modifiers)Trees.this.Modifiers" id="scala.reflect.api;Trees;Transformer.transformModifiers">transformModifiers</a><span class="delimiter">(</span><a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;Transformer.transformModifiers.mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.api;Trees;Transformer.transformModifiers.mods" title="Trees.this.Modifiers">mods</a>.<a href="#scala.reflect.api;Trees;ModifiersApi.annotations" title="=&gt; List[Trees.this.Tree]">annotations</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.api;Trees;Transformer.transformModifiers.mods" title="Trees.this.Modifiers">mods</a>
      else <a href="#scala.reflect.api;Trees;Transformer.transformModifiers.mods" title="Trees.this.Modifiers">mods</a> <a href="#scala.reflect.api;Trees;ModifiersApi.mapAnnotations" title="(f: List[Trees.this.Tree] =&gt; List[Trees.this.Tree])Trees.this.Modifiers">mapAnnotations</a> <a href="#scala.reflect.api;Trees;Transformer.transformTrees" title="(trees: List[Trees.this.Tree])List[Trees.this.Tree]">transformTrees</a>
    <span class="delimiter">}</span>

    <span class="comment">/** Transforms a tree with a given owner symbol. */</span>
    def <a title="[A](owner: Trees.this.Symbol)(trans: =&gt; A)A" id="scala.reflect.api;Trees;Transformer.atOwner">atOwner</a><span class="delimiter">[</span><a title="" id="scala.reflect.api;Trees;Transformer.atOwner;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Trees.this.Symbol" id="scala.reflect.api;Trees;Transformer.atOwner.owner">owner</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Trees.this.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; A" id="scala.reflect.api;Trees;Transformer.atOwner.trans">trans</a>: =&gt; A<span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Transformer.atOwner;A" title="A">A</a> = <span class="delimiter">{</span>
      val <a title="Trees.this.Symbol" id="scala.reflect.api;Trees;Transformer.atOwner.prevOwner">prevOwner</a> = <a href="#scala.reflect.api;Trees;Transformer.currentOwner_=" title="=&gt; Trees.this.Symbol">currentOwner</a>
      <a href="#scala.reflect.api;Trees;Transformer.currentOwner_=" title="(x$1: Trees.this.Symbol)Unit">currentOwner</a> = <a href="#scala.reflect.api;Trees;Transformer.atOwner.owner" title="Trees.this.Symbol">owner</a>
      val <a title="A" id="scala.reflect.api;Trees;Transformer.atOwner.result">result</a> = <a href="#scala.reflect.api;Trees;Transformer.atOwner.trans" title="=&gt; A">trans</a>
      <a href="#scala.reflect.api;Trees;Transformer.currentOwner_=" title="(x$1: Trees.this.Symbol)Unit">currentOwner</a> = <a href="#scala.reflect.api;Trees;Transformer.atOwner.prevOwner" title="Trees.this.Symbol">prevOwner</a>
      <a href="#scala.reflect.api;Trees;Transformer.atOwner.result" title="A">result</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Delegates the transformation strategy to `scala.reflect.internal.Trees`,
   *  because pattern matching on abstract types we have here degrades performance.
   *  @group Traversal
   */</span>
  protected def <a title="(transformer: Trees.this.Transformer, tree: Trees.this.Tree)Trees.this.Tree" id="scala.reflect.api;Trees.itransform">itransform</a><span class="delimiter">(</span><a title="Trees.this.Transformer" id="scala.reflect.api;Trees.itransform.transformer">transformer</a>: <a href="#scala.reflect.api;Trees;Transformer" title="Trees.this.Transformer">Transformer</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees.itransform.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a> = throw new <a href="../../MatchError.scala.html#scala;MatchError" title="MatchError">MatchError</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees.itransform.tree" title="Trees.this.Tree">tree</a><span class="delimiter">)</span>

  <span class="comment">/** Provides an extension hook for the transformation strategy.
   *  Future-proofs against new node types.
   *  @group Traversal
   */</span>
  protected def <a title="(transformer: Trees.this.Transformer, tree: Trees.this.Tree)Trees.this.Tree" id="scala.reflect.api;Trees.xtransform">xtransform</a><span class="delimiter">(</span><a title="Trees.this.Transformer" id="scala.reflect.api;Trees.xtransform.transformer">transformer</a>: <a href="#scala.reflect.api;Trees;Transformer" title="Trees.this.Transformer">Transformer</a>, <a title="Trees.this.Tree" id="scala.reflect.api;Trees.xtransform.tree">tree</a>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Tree" title="Trees.this.Tree">Tree</a> = throw new <a href="../../MatchError.scala.html#scala;MatchError" title="MatchError">MatchError</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees.xtransform.tree" title="Trees.this.Tree">tree</a><span class="delimiter">)</span>

  <span class="comment">/** The type of tree modifiers (not a tree, but rather part of DefTrees).
   *  @group Traversal
   */</span>
  type <a title=" &gt;: Null &lt;: Trees.this.ModifiersApi" id="scala.reflect.api;Trees;Modifiers">Modifiers</a> &gt;: Null &lt;: AnyRef with ModifiersApi

  <span class="comment">/** The API that all Modifiers support
   *  @group API
   */</span>
  abstract class <a title="class ModifiersApi extends AnyRef" id="scala.reflect.api;Trees;ModifiersApi">ModifiersApi</a> <a href="#scala.reflect.api;Trees;ModifiersApi" title="Trees.this.ModifiersApi" class="delimiter">{</a>
    <span class="comment">/** The underlying flags of the enclosing definition.
     *  Is equal to `NoFlags` if none are specified explicitly.
     */</span>
    def <a title="=&gt; Trees.this.FlagSet" id="scala.reflect.api;Trees;ModifiersApi.flags">flags</a>: <a href="FlagSets.scala.html#scala.reflect.api;FlagSets;FlagSet" title="Trees.this.FlagSet">FlagSet</a>

    def <a title="(flag: Trees.this.FlagSet)Boolean" id="scala.reflect.api;Trees;ModifiersApi.hasFlag">hasFlag</a><span class="delimiter">(</span><a title="Trees.this.FlagSet" id="scala.reflect.api;Trees;ModifiersApi.hasFlag.flag">flag</a>: <a href="FlagSets.scala.html#scala.reflect.api;FlagSets;FlagSet" title="Trees.this.FlagSet">FlagSet</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** The visibility scope of the enclosing definition.
     *  Is equal to `tpnme.EMPTY` if none is specified explicitly.
     */</span>
    def <a title="=&gt; Trees.this.Name" id="scala.reflect.api;Trees;ModifiersApi.privateWithin">privateWithin</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>

    <span class="comment">/** The annotations of the enclosing definition.
     *  Empty list if none are specified explicitly.
     */</span>
    def <a title="=&gt; List[Trees.this.Tree]" id="scala.reflect.api;Trees;ModifiersApi.annotations">annotations</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>

    <span class="comment">/** Creates a new instance of `Modifiers` with
     *  the annotations transformed according to the given function.
     */</span>
    def <a title="(f: List[Trees.this.Tree] =&gt; List[Trees.this.Tree])Trees.this.Modifiers" id="scala.reflect.api;Trees;ModifiersApi.mapAnnotations">mapAnnotations</a><span class="delimiter">(</span><a title="List[Trees.this.Tree] =&gt; List[Trees.this.Tree]" id="scala.reflect.api;Trees;ModifiersApi.mapAnnotations.f">f</a>: List<span class="delimiter">[</span>Tree<span class="delimiter">]</span> =&gt; List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a> =
      <a href="#scala.reflect.api;Trees;ModifiersExtractor.apply(5371d70171)" title="(flags: Trees.this.FlagSet, privateWithin: Trees.this.Name, annotations: List[Trees.this.Tree])Trees.this.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;ModifiersApi.flags" title="=&gt; Trees.this.FlagSet">flags</a>, <a href="#scala.reflect.api;Trees;ModifiersApi.privateWithin" title="=&gt; Trees.this.Name">privateWithin</a>, <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: List[Trees.this.Tree])List[Trees.this.Tree]">f</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees;ModifiersApi.annotations" title="=&gt; List[Trees.this.Tree]">annotations</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The constructor/extractor for `Modifiers` instances.
   *  @group Traversal
   */</span>
  val <a title="=&gt; Trees.this.ModifiersExtractor" id="scala.reflect.api;Trees.Modifiers(c33ce9d7a0)">Modifiers</a>: <a href="#scala.reflect.api;Trees;ModifiersExtractor" title="Trees.this.ModifiersExtractor">ModifiersExtractor</a>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use ModifiersExtractor instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
  type <a title="Trees.this.ModifiersExtractor" id="scala.reflect.api;Trees;ModifiersCreator">ModifiersCreator</a> = <a href="#scala.reflect.api;Trees;ModifiersExtractor" title="Trees.this.ModifiersExtractor">ModifiersExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `Modifiers(flags, privateWithin, annotations)`.
   *  Modifiers encapsulate flags, visibility annotations and Scala annotations for member definitions.
   *  @group Traversal
   */</span>
  abstract class <a title="class ModifiersExtractor extends AnyRef" id="scala.reflect.api;Trees;ModifiersExtractor">ModifiersExtractor</a> <a href="#scala.reflect.api;Trees;ModifiersExtractor" title="Trees.this.ModifiersExtractor" class="delimiter">{</a>
    def <a title="()Trees.this.Modifiers" id="scala.reflect.api;Trees;ModifiersExtractor.apply(e2309c55b7)">apply</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a> = <a href="#scala.reflect.api;Trees;ModifiersExtractor.apply(5371d70171)" title="(flags: Trees.this.FlagSet, privateWithin: Trees.this.Name, annotations: List[Trees.this.Tree])Trees.this.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="FlagSets.scala.html#scala.reflect.api;FlagSets.NoFlags" title="=&gt; Trees.this.FlagSet">NoFlags</a>, <a href="StandardNames.scala.html#scala.reflect.api;StandardNames.tpnme" title="=&gt; Trees.this.TypeNamesApi">tpnme</a>.<a href="StandardNames.scala.html#scala.reflect.api;StandardNames;NamesApi.EMPTY" title="=&gt; Trees.this.tpnme.NameType">EMPTY</a>, List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span>
    def <a title="(flags: Trees.this.FlagSet, privateWithin: Trees.this.Name, annotations: List[Trees.this.Tree])Trees.this.Modifiers" id="scala.reflect.api;Trees;ModifiersExtractor.apply(5371d70171)">apply</a><span class="delimiter">(</span><a title="Trees.this.FlagSet" id="scala.reflect.api;Trees;ModifiersExtractor.apply(5371d70171).flags">flags</a>: <a href="FlagSets.scala.html#scala.reflect.api;FlagSets;FlagSet" title="Trees.this.FlagSet">FlagSet</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees;ModifiersExtractor.apply(5371d70171).privateWithin">privateWithin</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a>, <a title="List[Trees.this.Tree]" id="scala.reflect.api;Trees;ModifiersExtractor.apply(5371d70171).annotations">annotations</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Trees.this.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a>
    def <a title="(mods: Trees.this.Modifiers)Option[(Trees.this.FlagSet, Trees.this.Name, List[Trees.this.Tree])]" id="scala.reflect.api;Trees;ModifiersExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Trees.this.Modifiers" id="scala.reflect.api;Trees;ModifiersExtractor.unapply.mods">mods</a>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Trees.this.FlagSet, Trees.this.Name, List[Trees.this.Tree])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>FlagSet, Name, List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The factory for `Modifiers` instances.
   *  @group Traversal
   */</span>
  def <a title="(flags: Trees.this.FlagSet, privateWithin: Trees.this.Name)Trees.this.Modifiers" id="scala.reflect.api;Trees.Modifiers(d7bc6d495b)">Modifiers</a><span class="delimiter">(</span><a title="Trees.this.FlagSet" id="scala.reflect.api;Trees.Modifiers(d7bc6d495b).flags">flags</a>: <a href="FlagSets.scala.html#scala.reflect.api;FlagSets;FlagSet" title="Trees.this.FlagSet">FlagSet</a>, <a title="Trees.this.Name" id="scala.reflect.api;Trees.Modifiers(d7bc6d495b).privateWithin">privateWithin</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Trees.this.Name">Name</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a> = <a href="#scala.reflect.api;Trees;ModifiersExtractor.apply(5371d70171)" title="(flags: Trees.this.FlagSet, privateWithin: Trees.this.Name, annotations: List[Trees.this.Tree])Trees.this.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees.Modifiers(d7bc6d495b).flags" title="Trees.this.FlagSet">flags</a>, <a href="#scala.reflect.api;Trees.Modifiers(d7bc6d495b).privateWithin" title="Trees.this.Name">privateWithin</a>, List<a href="../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** The factory for `Modifiers` instances.
   *  @group Traversal
   */</span>
  def <a title="(flags: Trees.this.FlagSet)Trees.this.Modifiers" id="scala.reflect.api;Trees.Modifiers(0bd5630316)">Modifiers</a><span class="delimiter">(</span><a title="Trees.this.FlagSet" id="scala.reflect.api;Trees.Modifiers(0bd5630316).flags">flags</a>: <a href="FlagSets.scala.html#scala.reflect.api;FlagSets;FlagSet" title="Trees.this.FlagSet">FlagSet</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Trees;Modifiers" title="Trees.this.Modifiers">Modifiers</a> = <a href="#scala.reflect.api;Trees.Modifiers(d7bc6d495b)" title="(flags: Trees.this.FlagSet, privateWithin: Trees.this.Name)Trees.this.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#scala.reflect.api;Trees.Modifiers(0bd5630316).flags" title="Trees.this.FlagSet">flags</a>, <a href="StandardNames.scala.html#scala.reflect.api;StandardNames.tpnme" title="=&gt; Trees.this.TypeNamesApi">tpnme</a>.<a href="StandardNames.scala.html#scala.reflect.api;StandardNames;NamesApi.EMPTY" title="=&gt; Trees.this.tpnme.NameType">EMPTY</a><span class="delimiter">)</span>

  <span class="comment">/** An empty `Modifiers` object: no flags, empty visibility annotation and no Scala annotations.
   *  @group Traversal
   */</span>
  lazy val <a title="Trees.this.Modifiers" id="scala.reflect.api;Trees.NoMods">NoMods</a> = <a href="#scala.reflect.api;Trees;ModifiersExtractor.apply(e2309c55b7)" title="()Trees.this.Modifiers">Modifiers</a><span class="delimiter">(</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
