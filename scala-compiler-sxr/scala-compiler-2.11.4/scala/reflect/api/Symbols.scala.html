<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/reflect/api/Symbols.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scala
package reflect
package api

<span class="comment">/**
 * &lt;span class=&quot;badge badge-red&quot; style=&quot;float: right;&quot;&gt;EXPERIMENTAL&lt;/span&gt;
 *
 *  This trait defines symbols and operations on them.
 *
 *  Symbols are used to establish bindings between a name and the entity it refers to, such as a class or a method.
 *  Anything you define and can give a name to in Scala has an associated symbol.
 *
 *  Symbols contain all available information about the declaration of an entity (class/object/trait etc.) or a
 *  member (vals/vars/defs etc.), and as such are an integral abstraction central to both runtime
 *  reflection and macros.
 *
 *  A symbol can provide a wealth of information ranging from the basic `name` method available on all symbols to
 *  other, more involved, concepts such as getting the `baseClasses` from `ClassSymbol`. Other common use cases of
 *  symbols include inspecting members' signatures, getting type parameters of a class, getting the parameter type
 *  of a method or finding out the type of a field.
 *
 *  Example usage of runtime reflection; getting a method's type signature:
 *  {{{
 *    scala&gt; import scala.reflect.runtime.universe._
 *    import scala.reflect.runtime.universe._
 *
 *    scala&gt; class C[T] { def test[U](x: T)(y: U): Int = ??? }
 *    defined class C
 *
 *    scala&gt; val test = typeOf[C[Int]].member(newTermName(&quot;test&quot;)).asMethod
 *    test: reflect.runtime.universe.MethodSymbol = method test
 *
 *    scala&gt; test.info
 *    res0: reflect.runtime.universe.Type = [U](x: T)(y: U)scala.Int
 *  }}}
 *
 *  Symbols are organized in a hierarchy. For example, a symbol that represents a parameter of a method is owned by
 *  the corresponding method symbol, a method symbol is owned by its enclosing class, a class is owned by a
 *  containing package and so on.
 *
 *  Certain types of tree nodes, such as [[Trees#Ident Ident]] (references to identifiers) and
 *  [[Trees#Select Select]] (references to members) expose method [[Trees.SymTreeApi.symbol `symbol`]]
 *  to obtain the symbol that represents their declaration. During the typechecking phase, the compiler looks up the
 *  symbol based on the name and scope and sets the [[Trees.SymTreeApi.symbol `symbol` field]] of tree nodes.
 *
 *  For more information about `Symbol` usage and attached intricacies, see the [[http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html Reflection Guide: Symbols]]
 *
 *  @group ReflectionAPI
 *
 *  @contentDiagram hideNodes &quot;*Api&quot;
 *
 *  @define SYMACCESSORS Class [[Symbol]] defines `isXXX` test methods such as `isPublic` or `isFinal`, `params` and
 *  `returnType` methods for method symbols, `baseClasses` for class symbols and so on. Some of these methods don't
 *  make sense for certain subclasses of `Symbol` and return `NoSymbol`, `Nil` or other empty values.
 *
 */</span>
trait <a title="trait Symbols extends AnyRef" id="scala.reflect.api;Symbols">Symbols</a> <a href="../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a> self: Universe =&gt;

  <span class="comment">/** The type of symbols representing declarations.
   *  @group Symbols
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Symbols.this.SymbolApi" id="scala.reflect.api;Symbols;Symbol">Symbol</a> &gt;: Null &lt;: AnyRef with SymbolApi

  <span class="comment">/** The type of type symbols representing type, class, and trait declarations,
   *  as well as type parameters.
   *  @group Symbols
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Symbols.this.TypeSymbolApi with Symbols.this.Symbol" id="scala.reflect.api;Symbols;TypeSymbol">TypeSymbol</a> &gt;: Null &lt;: TypeSymbolApi with Symbol

  <span class="comment">/** The type of term symbols representing val, var, def, and object declarations as
   *  well as packages and value parameters.
   *  @group Symbols
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Symbols.this.TermSymbolApi with Symbols.this.Symbol" id="scala.reflect.api;Symbols;TermSymbol">TermSymbol</a> &gt;: Null &lt;: TermSymbolApi with Symbol

  <span class="comment">/** The type of method symbols representing def declarations.
   *  @group Symbols
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Symbols.this.MethodSymbolApi with Symbols.this.TermSymbol" id="scala.reflect.api;Symbols;MethodSymbol">MethodSymbol</a> &gt;: Null &lt;: MethodSymbolApi with TermSymbol

  <span class="comment">/** The type of module symbols representing object declarations.
   *  @group Symbols
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Symbols.this.ModuleSymbolApi with Symbols.this.TermSymbol" id="scala.reflect.api;Symbols;ModuleSymbol">ModuleSymbol</a> &gt;: Null &lt;: ModuleSymbolApi with TermSymbol

  <span class="comment">/** The type of class symbols representing class and trait definitions.
   *  @group Symbols
   *  @template
   */</span>
  type <a title=" &gt;: Null &lt;: Symbols.this.ClassSymbolApi with Symbols.this.TypeSymbol" id="scala.reflect.api;Symbols;ClassSymbol">ClassSymbol</a> &gt;: Null &lt;: ClassSymbolApi with TypeSymbol

  <span class="comment">/** A special &quot;missing&quot; symbol. Commonly used in the API to denote a default or empty value.
   *  @group Symbols
   *  @template
   */</span>
  val <a title="=&gt; Symbols.this.Symbol" id="scala.reflect.api;Symbols.NoSymbol">NoSymbol</a>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a>

  <span class="comment">/** The API of symbols.
   *  The main source of information about symbols is the [[Symbols]] page.
   *
   *  $SYMACCESSORS
   *  @group API
   *  @groupname Basics        Symbol Basic Information
   *  @groupprio Basics        0
   *  @groupname Tests         Symbol Type Tests
   *  @groupprio Tests         1
   *  @groupname Conversions   Symbol Conversions
   *  @groupprio Conversions   2
   *  @groupname Constructors  New Symbol Constructors
   *  @groupprio Constructors  3
   *  @groupdesc Constructors  These methods construct new symbols owned by the current symbol.
   *  @groupname Helpers       Iteration Helpers
   *  @groupprio Helpers       4
   *  @groupdesc Helpers       These methods enable collections-like operations on symbols.
   *  @groupname Type          TypeSymbol Members
   *  @groupprio Type          -1
   *  @groupname Term          TermSymbol Members
   *  @groupprio Term          -1
   *  @groupname Class         Class Symbol Members
   *  @groupprio Class         -2
   *  @groupname Method        Method Symbol Members
   *  @groupprio Method        -2
   *  @groupname Module        Module Symbol Members
   *  @groupprio Module        -2
   */</span>
  trait <a title="trait SymbolApi extends AnyRef" id="scala.reflect.api;Symbols;SymbolApi">SymbolApi</a> <a href="../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a> this: Symbol =&gt;

    <span class="comment">/** The owner of this symbol. This is the symbol
     *  that directly contains the current symbol's definition.
     *  The `NoSymbol` symbol does not have an owner, and calling this method
     *  on one causes an internal error.
     *  The owner of the Scala root class [[scala.reflect.api.Mirror.RootClass]]
     *  and the Scala root object [[scala.reflect.api.Mirror.RootPackage]] is `NoSymbol`.
     *  Every other symbol has a chain of owners that ends in
     *  [[scala.reflect.api.Mirror.RootClass]].
     *
     *  @group Basics
     */</span>
    def <a title="=&gt; Symbols.this.Symbol" id="scala.reflect.api;Symbols;SymbolApi.owner">owner</a>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a>

    <span class="comment">/** The type of the symbol name.
     *  Can be either `TermName` or `TypeName` depending on whether this is a `TermSymbol` or a `TypeSymbol`.
     *
     *  Type name namespaces do not intersect with term name namespaces.
     *  This fact is reflected in different types for names of `TermSymbol` and `TypeSymbol`.
     *  @group Basics
     */</span>
    type <a title=" &gt;: Null &lt;: Symbols.this.Name" id="scala.reflect.api;Symbols;SymbolApi;NameType">NameType</a> &gt;: Null &lt;: Name

    <span class="comment">/** The name of the symbol as a member of the `Name` type.
     *  @group Basics
     */</span>
    def <a title="=&gt; SymbolApi.this.NameType" id="scala.reflect.api;Symbols;SymbolApi.name">name</a>: <a href="#scala.reflect.api;Symbols;SymbolApi;NameType" title="SymbolApi.this.NameType">NameType</a>

    <span class="comment">/** The encoded full path name of this symbol, where outer names and inner names
     *  are separated by periods.
     *  @group Basics
     */</span>
    def <a title="=&gt; String" id="scala.reflect.api;Symbols;SymbolApi.fullName">fullName</a>: <span title="String">String</span>

    <span class="comment">/** Position of the tree. */</span>
    def <a title="=&gt; Symbols.this.Position" id="scala.reflect.api;Symbols;SymbolApi.pos">pos</a>: <a href="Positions.scala.html#scala.reflect.api;Positions;Position" title="Symbols.this.Position">Position</a>

    <span class="comment">/** Does this symbol represent the definition of a type?
     *  Note that every symbol is either a term or a type.
     *  So for every symbol `sym` (except for `NoSymbol`),
     *  either `sym.isTerm` is true or `sym.isType` is true.
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isType">isType</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false

    <span class="comment">/** This symbol cast to a TypeSymbol.
     *  @throws ScalaReflectionException if `isType` is false.
     *
     *  @group Conversions
     */</span>
    def <a title="=&gt; Symbols.this.TypeSymbol" id="scala.reflect.api;Symbols;SymbolApi.asType">asType</a>: <a href="#scala.reflect.api;Symbols;TypeSymbol" title="Symbols.this.TypeSymbol">TypeSymbol</a> = throw new <a href="../package.scala.html#scala;ScalaReflectionException" title="ScalaReflectionException">ScalaReflectionException</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span>this<a href="#scala.reflect.api;Symbols;SymbolApi" title="String(&quot; is not a type&quot;)" class="string"> is not a type&quot;</a><span class="delimiter">)</span>

    <span class="comment">/** Does this symbol represent the definition of a term?
     *  Note that every symbol is either a term or a type.
     *  So for every symbol `sym` (except for `NoSymbol`),
     *  either `sym.isTerm` is true or `sym.isType` is true.
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isTerm">isTerm</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false

    <span class="comment">/** This symbol cast to a TermSymbol.
     *  @throws ScalaReflectionException if `isTerm` is false.
     *
     *  @group Conversions
     */</span>
    def <a title="=&gt; Symbols.this.TermSymbol" id="scala.reflect.api;Symbols;SymbolApi.asTerm">asTerm</a>: <a href="#scala.reflect.api;Symbols;TermSymbol" title="Symbols.this.TermSymbol">TermSymbol</a> = throw new <a href="../package.scala.html#scala;ScalaReflectionException" title="ScalaReflectionException">ScalaReflectionException</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span>this<a href="#scala.reflect.api;Symbols;SymbolApi" title="String(&quot; is not a term&quot;)" class="string"> is not a term&quot;</a><span class="delimiter">)</span>

    <span class="comment">/** Does this symbol represent the definition of a method?
     *  If yes, `isTerm` is also guaranteed to be true.
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isMethod">isMethod</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false

    <span class="comment">/** Does this method represent a constructor?
     *
     *  If `owner` is a class, then this is a vanilla JVM constructor.
     *  If `owner` is a trait, then this is a mixin constructor.
     *
     *  @group Method
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isConstructor">isConstructor</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** This symbol cast to a MethodSymbol.
     *  @throws ScalaReflectionException if `isMethod` is false.
     *
     *  @group Conversions
     */</span>
    def <a title="=&gt; Symbols.this.MethodSymbol" id="scala.reflect.api;Symbols;SymbolApi.asMethod">asMethod</a>: <a href="#scala.reflect.api;Symbols;MethodSymbol" title="Symbols.this.MethodSymbol">MethodSymbol</a> = <span class="delimiter">{</span>
      def <a title="=&gt; String" id="scala.reflect.api;Symbols;SymbolApi.asMethod.overloadedMsg">overloadedMsg</a> =
        <span class="string">&quot;encapsulates multiple overloaded alternatives and cannot be treated as a method. &quot;</span><span title="String(&quot;encapsulates multiple overloaded alternatives and cannot be treated as a method. Consider invoking `&lt;offending symbol&gt;.asTerm.alternatives` and manually picking the required method&quot;)">+</span>
        <span class="string">&quot;Consider invoking `&lt;offending symbol&gt;.asTerm.alternatives` and manually picking the required method&quot;</span>
      def <a title="=&gt; String" id="scala.reflect.api;Symbols;SymbolApi.asMethod.vanillaMsg">vanillaMsg</a> = <span title="String(&quot;is not a method&quot;)" class="string">&quot;is not a method&quot;</span>
      val <a title="String" id="scala.reflect.api;Symbols;SymbolApi.asMethod.msg">msg</a> = if <span class="delimiter">(</span><a href="#scala.reflect.api;Symbols;SymbolApi.isOverloadedMethod" title="=&gt; Boolean">isOverloadedMethod</a><span class="delimiter">)</span> <a href="#scala.reflect.api;Symbols;SymbolApi.asMethod.overloadedMsg" title="=&gt; String">overloadedMsg</a> else <a href="#scala.reflect.api;Symbols;SymbolApi.asMethod.vanillaMsg" title="=&gt; String">vanillaMsg</a>
      throw new <a href="../package.scala.html#scala;ScalaReflectionException" title="ScalaReflectionException">ScalaReflectionException</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span>this<a href="#scala.reflect.api;Symbols;SymbolApi" title="String(&quot; &quot;)"> $</a><a href="#scala.reflect.api;Symbols;SymbolApi.asMethod.msg" title="String">msg</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/** Used to provide a better error message for `asMethod`
     *
     *  @group Tests
     */</span>
    protected def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isOverloadedMethod">isOverloadedMethod</a> = false

    <span class="comment">/** Does this symbol represent the definition of a module (i.e. it
     *  results from an object definition?).
     *  If yes, `isTerm` is also guaranteed to be true.
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isModule">isModule</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false

    <span class="comment">/** This symbol cast to a ModuleSymbol defined by an object definition.
     *  @throws ScalaReflectionException if `isModule` is false.
     *
     *  @group Conversions
     */</span>
    def <a title="=&gt; Symbols.this.ModuleSymbol" id="scala.reflect.api;Symbols;SymbolApi.asModule">asModule</a>: <a href="#scala.reflect.api;Symbols;ModuleSymbol" title="Symbols.this.ModuleSymbol">ModuleSymbol</a> = throw new <a href="../package.scala.html#scala;ScalaReflectionException" title="ScalaReflectionException">ScalaReflectionException</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span>this<a href="#scala.reflect.api;Symbols;SymbolApi" title="String(&quot; is not a module&quot;)" class="string"> is not a module&quot;</a><span class="delimiter">)</span>

    <span class="comment">/** Does this symbol represent the definition of a class or trait?
     *  If yes, `isType` is also guaranteed to be true.
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isClass">isClass</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false

    <span class="comment">/** Does this symbol represent the definition of a class implicitly associated
     *  with an object definition (module class in scala compiler parlance).
     *  If yes, `isType` is also guaranteed to be true.
     *
     *  Note to compiler developers: During the &quot;mixin&quot; phase, trait implementation class symbols
     *  receive the `lateMODULE` flag, hence `isImplClass &amp;&amp; isModuleClass` becomes true.
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isModuleClass">isModuleClass</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false

    <span class="comment">/** This symbol cast to a ClassSymbol representing a class or trait.
     *  @throws ScalaReflectionException if `isClass` is false.
     *
     *  @group Conversions
     */</span>
    def <a title="=&gt; Symbols.this.ClassSymbol" id="scala.reflect.api;Symbols;SymbolApi.asClass">asClass</a>: <a href="#scala.reflect.api;Symbols;ClassSymbol" title="Symbols.this.ClassSymbol">ClassSymbol</a> = throw new <a href="../package.scala.html#scala;ScalaReflectionException" title="ScalaReflectionException">ScalaReflectionException</a><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span>this<a href="#scala.reflect.api;Symbols;SymbolApi" title="String(&quot; is not a class&quot;)" class="string"> is not a class&quot;</a><span class="delimiter">)</span>

    <span class="comment">/** Source file if this symbol is created during this compilation run,
     *  or a class file if this symbol is loaded from a *.class or *.jar.
     *
     *  The return type is `scala.reflect.io.AbstractFile`, which belongs to an experimental part of Scala reflection.
     *  It should not be used unless you know what you are doing. In subsequent releases, this API will be refined
     *  and exposed as a part of scala.reflect.api.
     *
     *  @group Basics
     */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `pos.source.file` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="=&gt; scala.reflect.io.AbstractFile" id="scala.reflect.api;Symbols;SymbolApi.associatedFile">associatedFile</a>: scala.reflect.io.<a href="../io/AbstractFile.scala.html#scala.reflect.io;AbstractFile" title="scala.reflect.io.AbstractFile">AbstractFile</a>

    <span class="comment">/** A list of annotations attached to this Symbol.
     *
     *  @group Basics
     */</span>
    def <a title="=&gt; List[Symbols.this.Annotation]" id="scala.reflect.api;Symbols;SymbolApi.annotations">annotations</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Symbols.this.Annotation]">List</a><span class="delimiter">[</span>Annotation<span class="delimiter">]</span>

    <span class="comment">/** For a class: the module or case class factory with the same name in the same package.
     *  For a module: the class with the same name in the same package.
     *  For all others: NoSymbol
     *
     *  This API may return unexpected results for module classes, packages and package classes.
     *  Use `companion` instead in order to get predictable results.
     *
     *  @group Basics
     */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `companion` instead, but beware of possible changes in behavior&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="=&gt; Symbols.this.Symbol" id="scala.reflect.api;Symbols;SymbolApi.companionSymbol">companionSymbol</a>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a>

    <span class="comment">/** For a class: its companion object if exists.
     *  For a module or a module class: companion class of the module if exists.
     *  For a package or a package class: NoSymbol.
     *  For all others: NoSymbol.
     */</span>
    def <a title="=&gt; Symbols.this.Symbol" id="scala.reflect.api;Symbols;SymbolApi.companion">companion</a>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a>

    <span class="comment">/** @see [[infoIn]] */</span>
    def <a title="(site: Symbols.this.Type)Symbols.this.Type" id="scala.reflect.api;Symbols;SymbolApi.typeSignatureIn">typeSignatureIn</a><span class="delimiter">(</span><a title="Symbols.this.Type" id="scala.reflect.api;Symbols;SymbolApi.typeSignatureIn.site">site</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a><span class="delimiter">)</span>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a>

    <span class="comment">/** The type signature of this symbol seen as a member of given type `site`.
     *
     *  @group Basics
     */</span>
    def <a title="(site: Symbols.this.Type)Symbols.this.Type" id="scala.reflect.api;Symbols;SymbolApi.infoIn">infoIn</a><span class="delimiter">(</span><a title="Symbols.this.Type" id="scala.reflect.api;Symbols;SymbolApi.infoIn.site">site</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a><span class="delimiter">)</span>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a>

    <span class="comment">/** @see [[info]] */</span>
    def <a title="=&gt; Symbols.this.Type" id="scala.reflect.api;Symbols;SymbolApi.typeSignature">typeSignature</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a>

    <span class="comment">/** The type signature of this symbol.
     *
     *  This method always returns signatures in the most generic way possible, even if the underlying symbol is obtained from an
     *  instantiation of a generic type. For example, signature
     *  of the method `def map[B](f: (A) â‡’ B): List[B]`, which refers to the type parameter `A` of the declaring class `List[A]`,
     *  will always feature `A`, regardless of whether `map` is loaded from the `List[_]` or from `List[Int]`. To get a signature
     *  with type parameters appropriately instantiated, one should use `infoIn`.
     *
     *  @group Basics
     */</span>
    def <a title="=&gt; Symbols.this.Type" id="scala.reflect.api;Symbols;SymbolApi.info">info</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a>

    <span class="comment">/** @see [[overrides]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `overrides` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="=&gt; List[Symbols.this.Symbol]" id="scala.reflect.api;Symbols;SymbolApi.allOverriddenSymbols">allOverriddenSymbols</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Symbols.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    <span class="comment">/** Returns all symbols overriden by this symbol.
     *
     *  @group Basics
     */</span>
    def <a title="=&gt; List[Symbols.this.Symbol]" id="scala.reflect.api;Symbols;SymbolApi.overrides">overrides</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Symbols.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    <span class="comment">/** The overloaded alternatives of this symbol
     *
     *  @group Basics
     */</span>
    def <a title="=&gt; List[Symbols.this.Symbol]" id="scala.reflect.api;Symbols;SymbolApi.alternatives">alternatives</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Symbols.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    <span class="comment">/******************* tests *******************/</span>

    <span class="comment">/** Does this symbol represent a synthetic (i.e. a compiler-generated) entity?
     *  Examples of synthetic entities are accessors for vals and vars
     *  or mixin constructors in trait implementation classes.
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isSynthetic">isSynthetic</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent an implementation artifact that isn't meant for public use?
     *  Examples of such artifacts are erasure bridges and outer fields.
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isImplementationArtifact">isImplementationArtifact</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a declaration or definition written in a source file as `private[this]`
     *  or generated in tree/symbol form with the combination of flags LOCAL and PRIVATE?
     *  If yes, `isPrivate` is guaranteed to be true,
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isPrivateThis">isPrivateThis</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a private declaration or definition?
     *  If yes, `privateWithin` might tell more about this symbol's visibility scope.
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isPrivate">isPrivate</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a declaration or definition written in a source file as `protected[this]`
     *  or generated in tree/symbol form with the combination of flags LOCAL and PROTECTED?
     *  If yes, `isProtected` is guaranteed to be true,
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isProtectedThis">isProtectedThis</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a protected declaration or definition?
     *  If yes, `privateWithin` might tell more about this symbol's visibility scope.
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isProtected">isProtected</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a public declaration or definition?
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isPublic">isPublic</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/**
     *  Set when symbol has a modifier of the form private[X] or protected[X], NoSymbol otherwise.
     *
     *  Access level encoding: there are three scala flags (PRIVATE, PROTECTED,
     *  and LOCAL) which combine with value privateWithin (the &quot;foo&quot; in private[foo])
     *  to define from where an entity can be accessed.  The meanings are as follows:
     *
     *  PRIVATE     access restricted to class only.
     *  PROTECTED   access restricted to class and subclasses only.
     *  LOCAL       can only be set in conjunction with PRIVATE or PROTECTED.
     *              Further restricts access to the same object instance.
     *
     *  In addition, privateWithin can be used to set a visibility barrier.
     *  When set, everything contained in the named enclosing package or class
     *  has access.  It is incompatible with PRIVATE or LOCAL, but is additive
     *  with PROTECTED (i.e. if either the flags or privateWithin allow access,
     *  then it is allowed.)
     *
     *  The java access levels translate as follows:
     *
     *  java private:     isPrivate                  &amp;&amp; (privateWithin == NoSymbol)
     *  java package:     !isPrivate &amp;&amp; !isProtected &amp;&amp; (privateWithin == enclosingPackage)
     *  java protected:   isProtected                &amp;&amp; (privateWithin == enclosingPackage)
     *  java public:      !isPrivate &amp;&amp; !isProtected &amp;&amp; (privateWithin == NoSymbol)
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Symbols.this.Symbol" id="scala.reflect.api;Symbols;SymbolApi.privateWithin">privateWithin</a>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a>

    <span class="comment">/** Does this symbol represent the definition of a package?
     *  Known issues: [[https://issues.scala-lang.org/browse/SI-6732]].
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isPackage">isPackage</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a package class?
     *  If yes, `isClass` is also guaranteed to be true.
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isPackageClass">isPackageClass</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Is this symbol static (i.e. with no outer instance)?
     *  Q: When exactly is a sym marked as STATIC?
     *  A: If it's a member of a toplevel object, or of an object contained in a toplevel object, or any number of levels deep.
     *  http://groups.google.com/group/scala-internals/browse_thread/thread/d385bcd60b08faf6
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isStatic">isStatic</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Is this symbol final?
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isFinal">isFinal</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Is this symbol abstract (i.e. an abstract class, an abstract method, value or type member)?
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isAbstract">isAbstract</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Is this symbol labelled as &quot;abstract override&quot;?
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isAbstractOverride">isAbstractOverride</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Is this symbol a macro?
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isMacro">isMacro</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Is this symbol a parameter (either a method parameter or a type parameter)?
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isParameter">isParameter</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Is this symbol a specialized type parameter or a generated specialized member?
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isSpecialized">isSpecialized</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Is this symbol defined by Java?
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isJava">isJava</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent an implicit value, definition, class or parameter?
     *
     *  @group Tests
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.isImplicit">isImplicit</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/******************* helpers *******************/</span>

    <span class="comment">/** Provides an alternate if symbol is a NoSymbol.
     *
     *  @group Helpers
     */</span>
    def <a title="(alt: =&gt; Symbols.this.Symbol)Symbols.this.Symbol" id="scala.reflect.api;Symbols;SymbolApi.orElse">orElse</a><span class="delimiter">(</span><a title="=&gt; Symbols.this.Symbol" id="scala.reflect.api;Symbols;SymbolApi.orElse.alt">alt</a>: =&gt; Symbol<span class="delimiter">)</span>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a>

    <span class="comment">/** Filters the underlying alternatives (or a single-element list
     *  composed of the symbol itself if the symbol is not overloaded).
     *  Returns an overloaded symbol is there are multiple matches.
     *  Returns a NoSymbol if there are no matches.
     *
     *  @group Helpers
     */</span>
    def <a title="(cond: Symbols.this.Symbol =&gt; Boolean)Symbols.this.Symbol" id="scala.reflect.api;Symbols;SymbolApi.filter">filter</a><span class="delimiter">(</span><a title="Symbols.this.Symbol =&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.filter.cond">cond</a>: Symbol =&gt; Boolean<span class="delimiter">)</span>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a>

    <span class="comment">/** If this is a NoSymbol, returns NoSymbol, otherwise
     *  returns the result of applying `f` to this symbol.
     *
     *  @group Helpers
     */</span>
    def <a title="(f: Symbols.this.Symbol =&gt; Symbols.this.Symbol)Symbols.this.Symbol" id="scala.reflect.api;Symbols;SymbolApi.map">map</a><span class="delimiter">(</span><a title="Symbols.this.Symbol =&gt; Symbols.this.Symbol" id="scala.reflect.api;Symbols;SymbolApi.map.f">f</a>: Symbol =&gt; Symbol<span class="delimiter">)</span>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a>

    <span class="comment">/** Does the same as `filter`, but crashes if there are multiple matches.
     *
     *  @group Helpers
     */</span>
    def <a title="(cond: Symbols.this.Symbol =&gt; Boolean)Symbols.this.Symbol" id="scala.reflect.api;Symbols;SymbolApi.suchThat">suchThat</a><span class="delimiter">(</span><a title="Symbols.this.Symbol =&gt; Boolean" id="scala.reflect.api;Symbols;SymbolApi.suchThat.cond">cond</a>: Symbol =&gt; Boolean<span class="delimiter">)</span>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The API of term symbols.
   *  The main source of information about symbols is the [[Symbols]] page.
   *
   *  $SYMACCESSORS
   *  @group API
   */</span>
  trait <a title="trait TermSymbolApi extends AnyRef with Symbols.this.SymbolApi" id="scala.reflect.api;Symbols;TermSymbolApi">TermSymbolApi</a> extends <a href="#scala.reflect.api;Symbols;SymbolApi" title="Symbols.this.SymbolApi">SymbolApi</a> <span class="delimiter">{</span> this: TermSymbol =&gt;
    <span class="comment">/** Term symbols have their names of type `TermName`.
     */</span>
    final type <a title="Symbols.this.TermName" id="scala.reflect.api;Symbols;TermSymbolApi;NameType">NameType</a> = <a href="Names.scala.html#scala.reflect.api;Names;TermName" title="Symbols.this.TermName">TermName</a>

    final override def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TermSymbolApi.isTerm">isTerm</a> = true
    final override def <a title="=&gt; Symbols.this.TermSymbol" id="scala.reflect.api;Symbols;TermSymbolApi.asTerm">asTerm</a> = this

    <span class="comment">/** Is this symbol introduced as `val`?
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TermSymbolApi.isVal">isVal</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol denote a stable value?
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TermSymbolApi.isStable">isStable</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Is this symbol introduced as `var`?
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TermSymbolApi.isVar">isVar</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a getter or a setter?
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TermSymbolApi.isAccessor">isAccessor</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a getter of a field?
     *  If yes, `isMethod` is also guaranteed to be true.
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TermSymbolApi.isGetter">isGetter</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a setter of a field?
     *  If yes, `isMethod` is also guaranteed to be true.
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TermSymbolApi.isSetter">isSetter</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent an overloaded method?
     *  If yes, `isMethod` is false, and the list of the enclosed alternatives can be found out via `alternatives`.
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TermSymbolApi.isOverloaded">isOverloaded</a>   : <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a lazy value?
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TermSymbolApi.isLazy">isLazy</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Used to provide a better error message for `asMethod` */</span>
    override protected def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TermSymbolApi.isOverloadedMethod">isOverloadedMethod</a> = <a href="#scala.reflect.api;Symbols;SymbolApi.alternatives" title="=&gt; List[Symbols.this.Symbol]">alternatives</a> <a href="../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: Symbols.this.Symbol =&gt; Boolean)Boolean">exists</a> <span class="delimiter">(</span><a href="#scala.reflect.api;Symbols;TermSymbolApi.isOverloadedMethod.$anonfun.x$1" title="Symbols.this.Symbol">_</a>.<a href="#scala.reflect.api;Symbols;SymbolApi.isMethod" title="=&gt; Boolean">isMethod</a><span class="delimiter">)</span>

    <span class="comment">/** Backing field for an accessor method, NoSymbol for all other term symbols.
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Symbols.this.Symbol" id="scala.reflect.api;Symbols;TermSymbolApi.accessed">accessed</a>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a>

    <span class="comment">/** Getter method for a backing field of a val or a val, NoSymbol for all other term symbols.
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Symbols.this.Symbol" id="scala.reflect.api;Symbols;TermSymbolApi.getter">getter</a>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a>

    <span class="comment">/** Setter method for a backing field of a val or a val, NoSymbol for all other term symbols.
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Symbols.this.Symbol" id="scala.reflect.api;Symbols;TermSymbolApi.setter">setter</a>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a>

    <span class="comment">/** Does this symbol represent a field of a class
     *  that was generated from a parameter of that class?
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TermSymbolApi.isParamAccessor">isParamAccessor</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a field of a case class
     *  that corresponds to a parameter in the first parameter list of the
     *  primary constructor of that class?
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TermSymbolApi.isCaseAccessor">isCaseAccessor</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a parameter with a default value?
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TermSymbolApi.isParamWithDefault">isParamWithDefault</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a by-name parameter?
     *
     *  @group Term
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TermSymbolApi.isByNameParam">isByNameParam</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The API of type symbols.
   *  The main source of information about symbols is the [[Symbols]] page.
   *
   *  $SYMACCESSORS
   *  @group API
   */</span>
  trait <a title="trait TypeSymbolApi extends AnyRef with Symbols.this.SymbolApi" id="scala.reflect.api;Symbols;TypeSymbolApi">TypeSymbolApi</a> extends <a href="#scala.reflect.api;Symbols;SymbolApi" title="Symbols.this.SymbolApi">SymbolApi</a> <span class="delimiter">{</span> this: TypeSymbol =&gt;
    <span class="comment">/** Type symbols have their names of type `TypeName`.
     */</span>
    final type <a title="Symbols.this.TypeName" id="scala.reflect.api;Symbols;TypeSymbolApi;NameType">NameType</a> = <a href="Names.scala.html#scala.reflect.api;Names;TypeName" title="Symbols.this.TypeName">TypeName</a>

    <span class="comment">/** The type constructor corresponding to this type symbol.
     *  This is different from `toType` in that type parameters
     *  are part of results of `toType`, but not of `toTypeConstructor`.
     *
     *  Example: Given a class declaration `class C[T] { ... } `, that generates a symbol
     *  `C`. Then `C.toType` is the type `C[T]`, but `C.toTypeConstructor` is `C`.
     *
     *  @group Type
     */</span>
    def <a title="=&gt; Symbols.this.Type" id="scala.reflect.api;Symbols;TypeSymbolApi.toTypeConstructor">toTypeConstructor</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a>

    <span class="comment">/** A type reference that refers to this type symbol seen
     *  as a member of given type `site`.
     *
     *  @group Type
     */</span>
    def <a title="(site: Symbols.this.Type)Symbols.this.Type" id="scala.reflect.api;Symbols;TypeSymbolApi.toTypeIn">toTypeIn</a><span class="delimiter">(</span><a title="Symbols.this.Type" id="scala.reflect.api;Symbols;TypeSymbolApi.toTypeIn.site">site</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a><span class="delimiter">)</span>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a>

    <span class="comment">/**  A type reference that refers to this type symbol
      *  Note if symbol is a member of a class, one almost always is interested
      *  in `asTypeIn` with a site type instead.
      *
      *  Example: Given a class declaration `class C[T] { ... } `, that generates a symbol
      *  `C`. Then `C.toType` is the type `C[T]`.
      *
      *  By contrast, `C.info` would be a type signature of form
      *  `PolyType(ClassInfoType(...))` that describes type parameters, value
      *  parameters, parent types, and members of `C`.
     *
     *  @group Type
     */</span>
    def <a title="=&gt; Symbols.this.Type" id="scala.reflect.api;Symbols;TypeSymbolApi.toType">toType</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a>

    final override def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TypeSymbolApi.isType">isType</a> = true
    final override def <a title="=&gt; Symbols.this.TypeSymbol" id="scala.reflect.api;Symbols;TypeSymbolApi.asType">asType</a> = this

    <span class="comment">/** Is the type parameter represented by this symbol contravariant?
     *
     *  @group Type
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TypeSymbolApi.isContravariant">isContravariant</a> : <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Is the type parameter represented by this symbol contravariant?
     *
     *  @group Type
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TypeSymbolApi.isCovariant">isCovariant</a>     : <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent the definition of a type alias?
     *
     *  @group Type
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TypeSymbolApi.isAliasType">isAliasType</a>    : <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent the definition of an abstract type?
     *
     *  @group Type
     */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use isAbstract instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TypeSymbolApi.isAbstractType">isAbstractType</a> : <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent an existentially bound type?
     *
     *  @group Type
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;TypeSymbolApi.isExistential">isExistential</a>  : <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** For a polymorphic type, its type parameters, the empty list for all other types
     *
     *  @group Type
     */</span>
    def <a title="=&gt; List[Symbols.this.Symbol]" id="scala.reflect.api;Symbols;TypeSymbolApi.typeParams">typeParams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Symbols.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API of method symbols.
   *  The main source of information about symbols is the [[Symbols]] page.
   *
   *  $SYMACCESSORS
   *  @group API
   */</span>
  trait <a title="trait MethodSymbolApi extends AnyRef with Symbols.this.TermSymbolApi" id="scala.reflect.api;Symbols;MethodSymbolApi">MethodSymbolApi</a> extends <a href="#scala.reflect.api;Symbols;TermSymbolApi" title="Symbols.this.TermSymbolApi">TermSymbolApi</a> <span class="delimiter">{</span> this: MethodSymbol =&gt;
    final override def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;MethodSymbolApi.isMethod">isMethod</a> = true
    final override def <a title="=&gt; Symbols.this.MethodSymbol" id="scala.reflect.api;Symbols;MethodSymbolApi.asMethod">asMethod</a> = this

    <span class="comment">/** Does this symbol denote the primary constructor of its enclosing class?
     *
     *  @group Method
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;MethodSymbolApi.isPrimaryConstructor">isPrimaryConstructor</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** For a polymorphic method, its type parameters, the empty list for all other methods
     *
     *  @group Method
     */</span>
    def <a title="=&gt; List[Symbols.this.Symbol]" id="scala.reflect.api;Symbols;MethodSymbolApi.typeParams">typeParams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Symbols.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    <span class="comment">/** @see [[paramLists]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `paramLists` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="=&gt; List[List[Symbols.this.Symbol]]" id="scala.reflect.api;Symbols;MethodSymbolApi.paramss">paramss</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Symbols.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span>

    <span class="comment">/** All parameter lists of the method.
     *  The name ending with &quot;ss&quot; indicates that the result type is a list of lists.
     *
     *  Can be used to distinguish nullary methods and methods with empty parameter lists.
     *  For a nullary method, returns the empty list (i.e. `List()`).
     *  For a method with an empty parameter list, returns a list that contains the empty list (i.e. `List(List())`).
     *
     *  @group Method
     */</span>
    def <a title="=&gt; List[List[Symbols.this.Symbol]]" id="scala.reflect.api;Symbols;MethodSymbolApi.paramLists">paramLists</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Symbols.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span>

    <span class="comment">/** Does this method support variable length argument lists?
     *
     *  @group Method
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;MethodSymbolApi.isVarargs">isVarargs</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** The return type of the method
     *
     *  @group Method
     */</span>
    def <a title="=&gt; Symbols.this.Type" id="scala.reflect.api;Symbols;MethodSymbolApi.returnType">returnType</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a>

    <span class="comment">/** Exceptions that this method is known to throw.
     *  For Scala methods, the list is calculated from [[throws]] annotations present on a method.
     *  For Java methods, the list is calculated from `throws` clauses attached to the method and stored in bytecode.
     *
     *  @group Method
     */</span>
    def <a title="=&gt; List[Symbols.this.Symbol]" id="scala.reflect.api;Symbols;MethodSymbolApi.exceptions">exceptions</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Symbols.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API of module symbols.
   *  The main source of information about symbols is the [[Symbols]] page.
   *
   *  $SYMACCESSORS
   *  @group API
   */</span>
  trait <a title="trait ModuleSymbolApi extends AnyRef with Symbols.this.TermSymbolApi" id="scala.reflect.api;Symbols;ModuleSymbolApi">ModuleSymbolApi</a> extends <a href="#scala.reflect.api;Symbols;TermSymbolApi" title="Symbols.this.TermSymbolApi">TermSymbolApi</a> <span class="delimiter">{</span> this: ModuleSymbol =&gt;
    <span class="comment">/** The class implicitly associated with the object definition.
     *  One can go back from a module class to the associated module symbol
     *  by inspecting its `selfType.termSymbol`.
     *
     *  @group Module
     */</span>
    def <a title="=&gt; Symbols.this.Symbol" id="scala.reflect.api;Symbols;ModuleSymbolApi.moduleClass">moduleClass</a>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a> <span class="comment">// needed for tree traversals</span>
    <span class="comment">// when this becomes `moduleClass: ClassSymbol`, it will be the happiest day in my life</span>

    final override def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;ModuleSymbolApi.isModule">isModule</a> = true
    final override def <a title="=&gt; Symbols.this.ModuleSymbol" id="scala.reflect.api;Symbols;ModuleSymbolApi.asModule">asModule</a> = this
  <span class="delimiter">}</span>

  <span class="comment">/** The API of class symbols.
   *  The main source of information about symbols is the [[Symbols]] page.
   *
   *  $SYMACCESSORS
   *  @group API
   */</span>
  trait <a title="trait ClassSymbolApi extends AnyRef with Symbols.this.TypeSymbolApi" id="scala.reflect.api;Symbols;ClassSymbolApi">ClassSymbolApi</a> extends <a href="#scala.reflect.api;Symbols;TypeSymbolApi" title="Symbols.this.TypeSymbolApi">TypeSymbolApi</a> <span class="delimiter">{</span> this: ClassSymbol =&gt;
    final override def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;ClassSymbolApi.isClass">isClass</a> = true
    final override def <a title="=&gt; Symbols.this.ClassSymbol" id="scala.reflect.api;Symbols;ClassSymbolApi.asClass">asClass</a> = this

    <span class="comment">/** Does this symbol represent the definition of a primitive class?
     *  Namely, is it one of [[scala.Double]], [[scala.Float]], [[scala.Long]], [[scala.Int]], [[scala.Char]],
     *  [[scala.Short]], [[scala.Byte]], [[scala.Unit]] or [[scala.Boolean]]?
     *
     *  @group Class
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;ClassSymbolApi.isPrimitive">isPrimitive</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent the definition of a numeric value class?
     *  Namely, is it one of [[scala.Double]], [[scala.Float]], [[scala.Long]], [[scala.Int]], [[scala.Char]],
     *  [[scala.Short]], [[scala.Byte]], [[scala.Unit]] or [[scala.Boolean]]?
     *
     *  @group Class
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;ClassSymbolApi.isNumeric">isNumeric</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent the definition of a custom value class?
     *  Namely, is AnyVal among its parent classes?
     *
     *  @group Class
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;ClassSymbolApi.isDerivedValueClass">isDerivedValueClass</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a trait?
     *
     *  @group Class
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;ClassSymbolApi.isTrait">isTrait</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent an abstract class?
     *
     *  @group Class
     */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use isAbstract instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;ClassSymbolApi.isAbstractClass">isAbstractClass</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a case class?
     *
     *  @group Class
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;ClassSymbolApi.isCaseClass">isCaseClass</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this symbol represent a sealed class?
     *
     *  @group Class
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Symbols;ClassSymbolApi.isSealed">isSealed</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** If this is a sealed class, its known direct subclasses.
     *  Otherwise, the empty set.
     *
     *  @group Class
     */</span>
    def <a title="=&gt; Set[Symbols.this.Symbol]" id="scala.reflect.api;Symbols;ClassSymbolApi.knownDirectSubclasses">knownDirectSubclasses</a>: <a href="../../collection/immutable/Set.scala.html#scala.collection.immutable;Set" title="Set[Symbols.this.Symbol]">Set</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    <span class="comment">/** The list of all base classes of this type (including its own typeSymbol)
     *  in linearization order, starting with the class itself and ending
     *  in class Any.
     *
     *  @group Class
     */</span>
    def <a title="=&gt; List[Symbols.this.Symbol]" id="scala.reflect.api;Symbols;ClassSymbolApi.baseClasses">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Symbols.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    <span class="comment">/** The module corresponding to this module class,
     *  or NoSymbol if this symbol is not a module class.
     *
     *  @group Class
     */</span>
    def <a title="=&gt; Symbols.this.Symbol" id="scala.reflect.api;Symbols;ClassSymbolApi.module">module</a>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a>

    <span class="comment">/** If this symbol is a class or trait, its self type, otherwise the type
     *  of the symbol itself.
     *
     *  @group Class
     */</span>
    def <a title="=&gt; Symbols.this.Type" id="scala.reflect.api;Symbols;ClassSymbolApi.selfType">selfType</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a>

    <span class="comment">/** The type `C.this`, where `C` is the current class
     *
     *  @group Class
     */</span>
    def <a title="=&gt; Symbols.this.Type" id="scala.reflect.api;Symbols;ClassSymbolApi.thisPrefix">thisPrefix</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a>

    <span class="comment">/** The type `C.super[M]`, where `C` is the current class and `M` is supertpe.
     *
     *  @group Class
     */</span>
    def <a title="(supertpe: Symbols.this.Type)Symbols.this.Type" id="scala.reflect.api;Symbols;ClassSymbolApi.superPrefix">superPrefix</a><span class="delimiter">(</span><a title="Symbols.this.Type" id="scala.reflect.api;Symbols;ClassSymbolApi.superPrefix.supertpe">supertpe</a>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a><span class="delimiter">)</span>: <a href="Types.scala.html#scala.reflect.api;Types;Type" title="Symbols.this.Type">Type</a>

    <span class="comment">/** For a polymorphic class/trait, its type parameters, the empty list for all other classes/trait
     *
     *  @group Class
     */</span>
    def <a title="=&gt; List[Symbols.this.Symbol]" id="scala.reflect.api;Symbols;ClassSymbolApi.typeParams">typeParams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Symbols.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    <span class="comment">/** For a Scala class or module class, the primary constructor of the class.
     *  For a Scala trait, its mixin constructor.
     *  For a Scala package class, NoSymbol.
     *  For a Java class, NoSymbol.
     *
     *  Known issues: Due to SI-8367, primaryConstructor may return unexpected results
     *  when called for Java classes (for some vague definition of a &quot;Java class&quot;, which apparently
     *  not only includes javac-produced classfiles, but also consists of classes defined in
     *  Scala programs under the java.lang package). What's even worse, for some Java classes
     *  we can't even guarantee stability of the return value - depending on your classloader configuration
     *  and/or JDK version you might get different primaryConstructor for the same ClassSymbol.
     *  We have logged these issues at SI-8193.
     *
     *  @group Class
     */</span>
    <span class="comment">// TODO: SI-8193 I think we should only return a non-empty symbol if called for Scala classes</span>
    <span class="comment">// returning something for traits and module classes is outright confusing</span>
    <span class="comment">// This, however, will require some refactoring in the compiler, so I'll leave it for later</span>
    <span class="comment">// as at the moment we don't have time or risk tolerance for that</span>
    def <a title="=&gt; Symbols.this.Symbol" id="scala.reflect.api;Symbols;ClassSymbolApi.primaryConstructor">primaryConstructor</a>: <a href="#scala.reflect.api;Symbols;Symbol" title="Symbols.this.Symbol">Symbol</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
