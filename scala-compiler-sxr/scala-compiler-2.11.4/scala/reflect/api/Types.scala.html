<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/reflect/api/Types.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scala
package reflect
package api

<span class="comment">/**
 *  &lt;span class=&quot;badge badge-red&quot; style=&quot;float: right;&quot;&gt;EXPERIMENTAL&lt;/span&gt;
 *
 *  A trait that defines types and operations on them.
 *
 *  Type instances represent information about the type of a corresponding symbol. This includes its members
 *  (methods, fields, type parameters, nested classes, traits, etc.) either declared directly or inherited, its base types,
 *  its erasure and so on. Types also provide operations to test for type conformance or equivalence or for widening.
 *
 *  To instantiate a type, most of the time, the [[scala.reflect.api.TypeTags#typeOf]] method can be used. It takes
 *  a type argument and produces a `Type` instance which represents that argument. For example:
 *
 *  {{{
 *    scala&gt; typeOf[List[Int]]
 *    res0: reflect.runtime.universe.Type = scala.List[Int]
 *  }}}
 *
 *  In this example, a [[scala.reflect.api.Types#TypeRef]] is returned, which corresponds to the type constructor `List`
 *  applied to the type argument `Int`.
 *
 *  ''Note:'' Method `typeOf` does not work for types with type parameters, such as `typeOf[List[A]]` where `A` is
 *  a type parameter. In this case, use [[scala.reflect.api.TypeTags#weakTypeOf]] instead.
 *
 *  For other ways to instantiate types, see the [[http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html corresponding section of the Reflection Guide]].
 *
 *  === Common Operations on Types ===
 *
 *  Types are typically used for type conformance tests or are queried for declarations of members or inner types.
 *
 *   - '''Subtyping Relationships''' can be tested using `&lt;:&lt;` and `weak_&lt;:&lt;`.
 *   - '''Type Equality''' can be checked with `=:=`. It's important to note that `==` should not be used to compare types for equality-- `==` can't check for type equality in the presence of type aliases, while `=:=` can.
 *
 *  Types can be queried for members and declarations by using the `members` and `declarations` methods (along with
 *  their singular counterparts `member` and `declaration`), which provide the list of definitions associated with that type.
 *  For example, to look up the `map` method of `List`, one can do:
 *
 *  {{{
 *     scala&gt; typeOf[List[_]].member(&quot;map&quot;: TermName)
 *     res1: reflect.runtime.universe.Symbol = method map
 *  }}}
 *
 * For more information about `Type`s, see the [[http://docs.scala-lang.org/overviews/reflection/symbols-trees-types.html Reflection Guide: Symbols, Trees, and Types]]
 *
 *  @groupname TypeCreators Types - Creation
 *  @groupname TypeOps      Types - Operations
 *  @group ReflectionAPI
 *
 *  @contentDiagram hideNodes &quot;*Api&quot;
 */</span>
trait <a title="trait Types extends AnyRef" id="scala.reflect.api;Types">Types</a> <a href="../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a>
  self: Universe =&gt;

  <span class="comment">/** The type of Scala types, and also Scala type signatures.
   *  (No difference is internally made between the two).
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.TypeApi" id="scala.reflect.api;Types;Type">Type</a> &gt;: Null &lt;: AnyRef with TypeApi

  <span class="comment">/** This constant is used as a special value that indicates that no meaningful type exists.
   *  @group Types
   */</span>
  val <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types.NoType">NoType</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

  <span class="comment">/** This constant is used as a special value denoting the empty prefix in a path dependent type.
   *  For instance `x.type` is represented as `SingleType(NoPrefix, &lt;x&gt;)`, where `&lt;x&gt;` stands for
   *  the symbol for `x`.
   *  @group Types
   */</span>
  val <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types.NoPrefix">NoPrefix</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

  <span class="comment">/** The API of types.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   *
   *  @define dealiasWidenWarning Note that type aliases can hide beneath
   *  singleton types and singleton types can hide inside type aliases.
   *  Moreover, aliases might lurk in the upper bounds of abstract types.
   *  Therefore careful thought has to be applied to identify and carry out
   *  unwrapping logic specific to your use case.
   */</span>
  abstract class <a title="class TypeApi extends AnyRef" id="scala.reflect.api;Types;TypeApi">TypeApi</a> <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi" class="delimiter">{</a>
    <span class="comment">/** The term symbol associated with the type, or `NoSymbol` for types
     *  that do not refer to a term symbol.
     */</span>
    def <a title="=&gt; Types.this.Symbol" id="scala.reflect.api;Types;TypeApi.termSymbol">termSymbol</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>

    <span class="comment">/** The type symbol associated with the type, or `NoSymbol` for types
     *  that do not refer to a type symbol.
     */</span>
    def <a title="=&gt; Types.this.Symbol" id="scala.reflect.api;Types;TypeApi.typeSymbol">typeSymbol</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>

    <span class="comment">/** @see [[decl]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `decl` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(name: Types.this.Name)Types.this.Symbol" id="scala.reflect.api;Types;TypeApi.declaration">declaration</a><span class="delimiter">(</span><a title="Types.this.Name" id="scala.reflect.api;Types;TypeApi.declaration.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>

    <span class="comment">/** The defined or declared members with name `name` in this type;
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     *  Alternatives of overloaded symbol appear in the order they are declared.
     */</span>
    def <a title="(name: Types.this.Name)Types.this.Symbol" id="scala.reflect.api;Types;TypeApi.decl">decl</a><span class="delimiter">(</span><a title="Types.this.Name" id="scala.reflect.api;Types;TypeApi.decl.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>

    <span class="comment">/** @see [[decls]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `decls` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="=&gt; Types.this.MemberScope" id="scala.reflect.api;Types;TypeApi.declarations">declarations</a>: <a href="Scopes.scala.html#scala.reflect.api;Scopes;MemberScope" title="Types.this.MemberScope">MemberScope</a>

    <span class="comment">/** A `Scope` containing directly declared members of this type.
     *  Unlike `members` this method doesn't returns inherited members.
     *
     *  Members in the returned scope might appear in arbitrary order.
     *  Use `declarations.sorted` to get an ordered list of members.
     */</span>
    def <a title="=&gt; Types.this.MemberScope" id="scala.reflect.api;Types;TypeApi.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.api;Scopes;MemberScope" title="Types.this.MemberScope">MemberScope</a>

    <span class="comment">/** The member with given name, either directly declared or inherited,
     *  an OverloadedSymbol if several exist, NoSymbol if none exist.
     */</span>
    def <a title="(name: Types.this.Name)Types.this.Symbol" id="scala.reflect.api;Types;TypeApi.member">member</a><span class="delimiter">(</span><a title="Types.this.Name" id="scala.reflect.api;Types;TypeApi.member.name">name</a>: <a href="Names.scala.html#scala.reflect.api;Names;Name" title="Types.this.Name">Name</a><span class="delimiter">)</span>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>

    <span class="comment">/** A `Scope` containing all members of this type (directly declared or inherited).
     *  Unlike `declarations` this method also returns inherited members.
     *
     *  Members in the returned scope might appear in arbitrary order.
     *  Use `declarations.sorted` to get an ordered list of members.
     */</span>
    def <a title="=&gt; Types.this.MemberScope" id="scala.reflect.api;Types;TypeApi.members">members</a>: <a href="Scopes.scala.html#scala.reflect.api;Scopes;MemberScope" title="Types.this.MemberScope">MemberScope</a>

    <span class="comment">/** Type signature of the companion of the underlying class symbol.
     *  NoType if the underlying symbol is not a class symbol, or if it doesn't have a companion.
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;TypeApi.companion">companion</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** Is this type a type constructor that is missing its type arguments?
     */</span>
    def <a title="=&gt; Boolean" id="scala.reflect.api;Types;TypeApi.takesTypeArgs">takesTypeArgs</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Returns the corresponding type constructor (e.g. List for List[T] or List[String])
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;TypeApi.typeConstructor">typeConstructor</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** Reduce to beta eta-long normal form.
     *  Expands type aliases and converts higher-kinded TypeRefs to PolyTypes.
     *  Functions on types are also implemented as PolyTypes.
     *
     *  Example: (in the below, &lt;List&gt; is the type constructor of List)
     *    TypeRef(pre, &lt;List&gt;, List()) is replaced by
     *    PolyType(X, TypeRef(pre, &lt;List&gt;, List(X)))
     */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `dealias` or `etaExpand` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;TypeApi.normalize">normalize</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** Converts higher-kinded TypeRefs to PolyTypes.
     *  Functions on types are also implemented as PolyTypes.
     *
     *  Example: (in the below, &lt;List&gt; is the type constructor of List)
     *    TypeRef(pre, &lt;List&gt;, List()) is replaced by
     *    PolyType(X, TypeRef(pre, &lt;List&gt;, List(X)))
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;TypeApi.etaExpand">etaExpand</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** Does this type conform to given type argument `that`? */</span>
    def <a title="(that: Types.this.Type)Boolean" id="scala.reflect.api;Types;TypeApi.<:<">&lt;:&lt;</a> <span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.api;Types;TypeApi.<:<.that">that</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this type weakly conform to given type argument `that`, i.e., either conforms in terms of `&lt;:&lt;` or both are primitive number types
     *  that conform according to Section &quot;Weak Conformance&quot; in the spec. For example, Int weak_&lt;:&lt; Long.
     */</span>
    def <a title="(that: Types.this.Type)Boolean" id="scala.reflect.api;Types;TypeApi.weak_<:<">weak_&lt;:&lt;</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.api;Types;TypeApi.weak_<:<.that">that</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Is this type equivalent to given type argument `that`? */</span>
    def <a title="(that: Types.this.Type)Boolean" id="scala.reflect.api;Types;TypeApi.=:=">=:=</a> <span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.api;Types;TypeApi.=:=.that">that</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** The list of all base classes of this type (including its own typeSymbol)
     *  in linearization order, starting with the class itself and ending
     *  in class Any.
     */</span>
    def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.api;Types;TypeApi.baseClasses">baseClasses</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    <span class="comment">/** The least type instance of given class which is a super-type
     *  of this type.  Example:
     *  {{{
     *    class D[T]
     *    class C extends p.D[Int]
     *    ThisType(C).baseType(D) = p.D[Int]
     * }}}
     */</span>
    def <a title="(clazz: Types.this.Symbol)Types.this.Type" id="scala.reflect.api;Types;TypeApi.baseType">baseType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.api;Types;TypeApi.baseType.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** This type as seen from prefix `pre` and class `clazz`. This means:
     *  Replace all `ThisType`s of `clazz` or one of its subclasses
     *  by `pre` and instantiate all parameters by arguments of `pre`.
     *  Proceed analogously for `ThisType`s referring to outer classes.
     *
     *  Example:
     *  {{{
     *    scala&gt; import scala.reflect.runtime.universe._
     *    import scala.reflect.runtime.universe._
     *
     *    scala&gt; class D[T] { def m: T = ??? }
     *    defined class D
     *
     *    scala&gt; class C extends D[Int]
     *    defined class C
     *
     *    scala&gt; val D = typeOf[D[_]].typeSymbol.asClass
     *    D: reflect.runtime.universe.ClassSymbol = class D
     *
     *    scala&gt; val C = typeOf[C].typeSymbol.asClass
     *    C: reflect.runtime.universe.ClassSymbol = class C
     *
     *    scala&gt; val T = D.typeParams(0).asType.toType
     *    T: reflect.runtime.universe.Type = T
     *
     *    scala&gt; T.asSeenFrom(ThisType(C), D)
     *    res0: reflect.runtime.universe.Type = scala.Int
     *  }}}
     */</span>
    def <a title="(pre: Types.this.Type, clazz: Types.this.Symbol)Types.this.Type" id="scala.reflect.api;Types;TypeApi.asSeenFrom">asSeenFrom</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.api;Types;TypeApi.asSeenFrom.pre">pre</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.api;Types;TypeApi.asSeenFrom.clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** The erased type corresponding to this type after
     *  all transformations from Scala to Java have been performed.
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;TypeApi.erasure">erasure</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** If this is a singleton type, widen it to its nearest underlying non-singleton
     *  base type by applying one or more `underlying` dereferences.
     *  If this is not a singleton type, returns this type itself.
     *
     *  Example:
     *
     *  class Outer { class C ; val x: C }
     *  val o: Outer
     *  &lt;o.x.type&gt;.widen = o.C
     *
     *  $dealiasWidenWarning
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;TypeApi.widen">widen</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** Expands type aliases arising from type members.
     *  $dealiasWidenWarning
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;TypeApi.dealias">dealias</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/******* popular methods from subclasses *******/</span>

    <span class="comment">/** List of type arguments ingrained in this type reference.
     *  Depending on your use case you might or might not want to call `dealias` first.
     *
     *  {{{
     *  scala&gt; type T = List[Int]
     *  defined type alias T
     *
     *  scala&gt; typeOf[T].typeArgs
     *  res0: List[reflect.runtime.universe.Type] = List()
     *
     *  scala&gt; typeOf[T].dealias.typeArgs
     *  res1: List[reflect.runtime.universe.Type] = List(scala.Int)
     *  }}}
     */</span>
    def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.api;Types;TypeApi.typeArgs">typeArgs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>

    <span class="comment">/** @see [[paramLists]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `paramLists` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="=&gt; List[List[Types.this.Symbol]]" id="scala.reflect.api;Types;TypeApi.paramss">paramss</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Types.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span>

    <span class="comment">/** For a method or poly type, a list of its value parameter sections,
     *  the empty list of lists for all other types.
     */</span>
    def <a title="=&gt; List[List[Types.this.Symbol]]" id="scala.reflect.api;Types;TypeApi.paramLists">paramLists</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[Types.this.Symbol]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">]</span>

    <span class="comment">/** For a poly type, its type parameters,
     *  the empty list for all other types.
     */</span>
    def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.api;Types;TypeApi.typeParams">typeParams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    <span class="comment">/** For a (nullary) method or poly type, its direct result type
     *  (can be a MethodType if the method has multiple argument lists),
     *  the type itself for all other types.
     *
     *  {{{
     *  scala&gt; class C { def foo[T](x: T)(y: T) = ??? }
     *  defined class C
     *
     *  scala&gt; typeOf[C].member(TermName(&quot;foo&quot;)).asMethod
     *  res0: reflect.runtime.universe.MethodSymbol = method foo
     *
     *  scala&gt; res0.info // PolyType wrapping a MethodType
     *  res1: reflect.runtime.universe.Type = [T](x: T)(y: T)scala.Nothing
     *
     *  scala&gt; res1.resultType // MethodType wrapping a MethodType
     *  res2: reflect.runtime.universe.Type = (x: T)(y: T)scala.Nothing
     *
     *  scala&gt; res1.resultType.resultType // vanilla MethodType
     *  res3: reflect.runtime.universe.Type = (y: T)scala.Nothing
     *
     *  scala&gt; res1.resultType.resultType.resultType
     *  res4: reflect.runtime.universe.Type = scala.Nothing
     *
     *  scala&gt; res1.finalResultType
     *  res5: reflect.runtime.universe.Type = scala.Nothing
     *  }}}
     *
     *  @see finalResultType
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;TypeApi.resultType">resultType</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** For a curried/nullary method or poly type its non-method result type,
     *  the type itself for all other types.
     *
     *  {{{
     *  scala&gt; class C {
     *       | def foo[T](x: T)(y: T) = ???
     *       | def bar: Int = ???
     *       | }
     *  defined class C
     *
     *  scala&gt; typeOf[C].member(TermName(&quot;foo&quot;)).asMethod
     *  res0: reflect.runtime.universe.MethodSymbol = method foo
     *
     *  scala&gt; res0.info // PolyType wrapping a MethodType
     *  res1: reflect.runtime.universe.Type = [T](x: T)(y: T)scala.Nothing
     *
     *  scala&gt; res1.resultType // MethodType wrapping a MethodType
     *  res2: reflect.runtime.universe.Type = (x: T)(y: T)scala.Nothing
     *
     *  scala&gt; res1.resultType.resultType // vanilla MethodType
     *  res3: reflect.runtime.universe.Type = (y: T)scala.Nothing
     *
     *  scala&gt; res1.resultType.resultType.resultType
     *  res4: reflect.runtime.universe.Type = scala.Nothing
     *
     *  scala&gt; res1.finalResultType
     *  res5: reflect.runtime.universe.Type = scala.Nothing
     *
     *  scala&gt; typeOf[C].member(TermName(&quot;bar&quot;)).asMethod
     *  res6: reflect.runtime.universe.MethodSymbol = method bar
     *
     *  scala&gt; res6.info
     *  res7: reflect.runtime.universe.Type = =&gt; scala.Int
     *
     *  scala&gt; res6.info.resultType
     *  res8: reflect.runtime.universe.Type = scala.Int
     *
     *  scala&gt; res6.info.finalResultType
     *  res9: reflect.runtime.universe.Type = scala.Int
     *  }}}
     *
     *  @see resultType
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;TypeApi.finalResultType">finalResultType</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/******************* helpers *******************/</span>

    <span class="comment">/** Provides an alternate if type is NoType.
     *
     *  @group Helpers
     */</span>
    def <a title="(alt: =&gt; Types.this.Type)Types.this.Type" id="scala.reflect.api;Types;TypeApi.orElse">orElse</a><span class="delimiter">(</span><a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;TypeApi.orElse.alt">alt</a>: =&gt; Type<span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** Substitute symbols in `to` for corresponding occurrences of references to
     *  symbols `from` in this type.
     */</span>
    def <a title="(from: List[Types.this.Symbol], to: List[Types.this.Symbol])Types.this.Type" id="scala.reflect.api;Types;TypeApi.substituteSymbols">substituteSymbols</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.api;Types;TypeApi.substituteSymbols.from">from</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Symbol]" id="scala.reflect.api;Types;TypeApi.substituteSymbols.to">to</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** Substitute types in `to` for corresponding occurrences of references to
     *  symbols `from` in this type.
     */</span>
    def <a title="(from: List[Types.this.Symbol], to: List[Types.this.Type])Types.this.Type" id="scala.reflect.api;Types;TypeApi.substituteTypes">substituteTypes</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.api;Types;TypeApi.substituteTypes.from">from</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="List[Types.this.Type]" id="scala.reflect.api;Types;TypeApi.substituteTypes.to">to</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

   <span class="comment">/** Apply `f` to each part of this type, returning
    *  a new type. children get mapped before their parents */</span>
    def <a title="(f: Types.this.Type =&gt; Types.this.Type)Types.this.Type" id="scala.reflect.api;Types;TypeApi.map">map</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Types.this.Type" id="scala.reflect.api;Types;TypeApi.map.f">f</a>: Type =&gt; Type<span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** Apply `f` to each part of this type, for side effects only */</span>
    def <a title="(f: Types.this.Type =&gt; Unit)Unit" id="scala.reflect.api;Types;TypeApi.foreach">foreach</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Unit" id="scala.reflect.api;Types;TypeApi.foreach.f">f</a>: Type =&gt; Unit<span class="delimiter">)</span>

    <span class="comment">/** Returns optionally first type (in a preorder traversal) which satisfies predicate `p`,
     *  or None if none exists.
     */</span>
    def <a title="(p: Types.this.Type =&gt; Boolean)Option[Types.this.Type]" id="scala.reflect.api;Types;TypeApi.find">find</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="scala.reflect.api;Types;TypeApi.find.p">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Types.this.Type]">Option</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>

    <span class="comment">/** Is there part of this type which satisfies predicate `p`? */</span>
    def <a title="(p: Types.this.Type =&gt; Boolean)Boolean" id="scala.reflect.api;Types;TypeApi.exists">exists</a><span class="delimiter">(</span><a title="Types.this.Type =&gt; Boolean" id="scala.reflect.api;Types;TypeApi.exists.p">p</a>: Type =&gt; Boolean<span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

    <span class="comment">/** Does this type contain a reference to given symbol? */</span>
    def <a title="(sym: Types.this.Symbol)Boolean" id="scala.reflect.api;Types;TypeApi.contains">contains</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.api;Types;TypeApi.contains.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The type of Scala singleton types, i.e., types that are inhabited
   *  by only one nun-null value. These include types of the forms
   *  {{{
   *    C.this.type
   *    C.super.type
   *    x.type
   *  }}}
   *  as well as [[ConstantType constant types]].
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.SingletonTypeApi with Types.this.Type" id="scala.reflect.api;Types;SingletonType">SingletonType</a> &gt;: Null &lt;: SingletonTypeApi with Type

  <span class="comment">/** Has no special methods. Is here to provides erased identity for `SingletonType`.
   *  @group API
   */</span>
  trait <a title="trait SingletonTypeApi extends AnyRef" id="scala.reflect.api;Types;SingletonTypeApi">SingletonTypeApi</a>

  <span class="comment">/** A singleton type that describes types of the form on the left with the
   *  corresponding `ThisType` representation to the right:
   *  {{{
   *     C.this.type             ThisType(C)
   *  }}}
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.ThisTypeApi with Types.this.SingletonType" id="scala.reflect.api;Types;ThisType">ThisType</a> &gt;: Null &lt;: ThisTypeApi with SingletonType

  <span class="comment">/** The constructor/extractor for `ThisType` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Types.this.ThisTypeExtractor" id="scala.reflect.api;Types.ThisType">ThisType</a>: <a href="#scala.reflect.api;Types;ThisTypeExtractor" title="Types.this.ThisTypeExtractor">ThisTypeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `ThisType(sym)`
   *  where `sym` is the class prefix of the this type.
   *  @group Extractors
   */</span>
  abstract class <a title="class ThisTypeExtractor extends AnyRef" id="scala.reflect.api;Types;ThisTypeExtractor">ThisTypeExtractor</a> <a href="#scala.reflect.api;Types;ThisTypeExtractor" title="Types.this.ThisTypeExtractor" class="delimiter">{</a>
    def <a title="(tpe: Types.this.ThisType)Option[Types.this.Symbol]" id="scala.reflect.api;Types;ThisTypeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.ThisType" id="scala.reflect.api;Types;ThisTypeExtractor.unapply.tpe">tpe</a>: <a href="#scala.reflect.api;Types;ThisType" title="Types.this.ThisType">ThisType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Types.this.Symbol]">Option</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.thisType]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.thisType` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(sym: Types.this.Symbol)(implicit token: Types.this.CompatToken)Types.this.Type" id="scala.reflect.api;Types;ThisTypeExtractor.apply">apply</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.api;Types;ThisTypeExtractor.apply.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;ThisTypeExtractor.apply.token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.thisType" title="(sym: Types.this.Symbol)Types.this.Type">thisType</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;ThisTypeExtractor.apply.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all this types support.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   */</span>
  trait <a title="trait ThisTypeApi extends Types.this.TypeApi" id="scala.reflect.api;Types;ThisTypeApi">ThisTypeApi</a> extends <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: ThisType =&gt;
    <span class="comment">/** The underlying class symbol. */</span>
    def <a title="=&gt; Types.this.Symbol" id="scala.reflect.api;Types;ThisTypeApi.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The `SingleType` type describes types of any of the forms on the left,
   *  with their TypeRef representations to the right.
   *  {{{
   *     (T # x).type             SingleType(T, x)
   *     p.x.type                 SingleType(p.type, x)
   *     x.type                   SingleType(NoPrefix, x)
   *  }}}
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.SingleTypeApi with Types.this.SingletonType" id="scala.reflect.api;Types;SingleType">SingleType</a> &gt;: Null &lt;: SingleTypeApi with SingletonType

  <span class="comment">/** The constructor/extractor for `SingleType` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Types.this.SingleTypeExtractor" id="scala.reflect.api;Types.SingleType">SingleType</a>: <a href="#scala.reflect.api;Types;SingleTypeExtractor" title="Types.this.SingleTypeExtractor">SingleTypeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `SingleType(pre, sym)`
   *  Here, `pre` is the prefix of the single-type, and `sym` is the stable value symbol
   *  referred to by the single-type.
   *  @group Extractors
   */</span>
  abstract class <a title="class SingleTypeExtractor extends AnyRef" id="scala.reflect.api;Types;SingleTypeExtractor">SingleTypeExtractor</a> <a href="#scala.reflect.api;Types;SingleTypeExtractor" title="Types.this.SingleTypeExtractor" class="delimiter">{</a>
    def <a title="(tpe: Types.this.SingleType)Option[(Types.this.Type, Types.this.Symbol)]" id="scala.reflect.api;Types;SingleTypeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.SingleType" id="scala.reflect.api;Types;SingleTypeExtractor.unapply.tpe">tpe</a>: <a href="#scala.reflect.api;Types;SingleType" title="Types.this.SingleType">SingleType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Types.this.Type, Types.this.Symbol)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.singleType]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `ClassSymbol.thisPrefix` or `internal.singleType` instead&quot;</span><span class="delimiter">)</span>
    def <a title="(pre: Types.this.Type, sym: Types.this.Symbol)(implicit token: Types.this.CompatToken)Types.this.Type" id="scala.reflect.api;Types;SingleTypeExtractor.apply">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.api;Types;SingleTypeExtractor.apply.pre">pre</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.api;Types;SingleTypeExtractor.apply.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;SingleTypeExtractor.apply.token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.singleType" title="(pre: Types.this.Type, sym: Types.this.Symbol)Types.this.Type">singleType</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;SingleTypeExtractor.apply.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.api;Types;SingleTypeExtractor.apply.sym" title="Types.this.Symbol">sym</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all single types support.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   */</span>
  trait <a title="trait SingleTypeApi extends Types.this.TypeApi" id="scala.reflect.api;Types;SingleTypeApi">SingleTypeApi</a> extends <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: SingleType =&gt;
    <span class="comment">/** The type of the qualifier. */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;SingleTypeApi.pre">pre</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** The underlying symbol. */</span>
    def <a title="=&gt; Types.this.Symbol" id="scala.reflect.api;Types;SingleTypeApi.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>
  <span class="delimiter">}</span>
  <span class="comment">/** The `SuperType` type is not directly written, but arises when `C.super` is used
   *  as a prefix in a `TypeRef` or `SingleType`. It's internal presentation is
   *  {{{
   *     SuperType(thistpe, supertpe)
   *  }}}
   *  Here, `thistpe` is the type of the corresponding this-type. For instance,
   *  in the type arising from C.super, the `thistpe` part would be `ThisType(C)`.
   *  `supertpe` is the type of the super class referred to by the `super`.
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.SuperTypeApi with Types.this.SingletonType" id="scala.reflect.api;Types;SuperType">SuperType</a> &gt;: Null &lt;: SuperTypeApi with SingletonType

  <span class="comment">/** The constructor/extractor for `SuperType` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Types.this.SuperTypeExtractor" id="scala.reflect.api;Types.SuperType">SuperType</a>: <a href="#scala.reflect.api;Types;SuperTypeExtractor" title="Types.this.SuperTypeExtractor">SuperTypeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `SingleType(thistpe, supertpe)`
   *  @group Extractors
   */</span>
  abstract class <a title="class SuperTypeExtractor extends AnyRef" id="scala.reflect.api;Types;SuperTypeExtractor">SuperTypeExtractor</a> <a href="#scala.reflect.api;Types;SuperTypeExtractor" title="Types.this.SuperTypeExtractor" class="delimiter">{</a>
    def <a title="(tpe: Types.this.SuperType)Option[(Types.this.Type, Types.this.Type)]" id="scala.reflect.api;Types;SuperTypeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.SuperType" id="scala.reflect.api;Types;SuperTypeExtractor.unapply.tpe">tpe</a>: <a href="#scala.reflect.api;Types;SuperType" title="Types.this.SuperType">SuperType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Types.this.Type, Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type, Type<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.superType]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `ClassSymbol.superPrefix` or `internal.superType` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(thistpe: Types.this.Type, supertpe: Types.this.Type)(implicit token: Types.this.CompatToken)Types.this.Type" id="scala.reflect.api;Types;SuperTypeExtractor.apply">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.api;Types;SuperTypeExtractor.apply.thistpe">thistpe</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.api;Types;SuperTypeExtractor.apply.supertpe">supertpe</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;SuperTypeExtractor.apply.token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.superType" title="(thistpe: Types.this.Type, supertpe: Types.this.Type)Types.this.Type">superType</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;SuperTypeExtractor.apply.thistpe" title="Types.this.Type">thistpe</a>, <a href="#scala.reflect.api;Types;SuperTypeExtractor.apply.supertpe" title="Types.this.Type">supertpe</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all super types support.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   */</span>
  trait <a title="trait SuperTypeApi extends Types.this.TypeApi" id="scala.reflect.api;Types;SuperTypeApi">SuperTypeApi</a> extends <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: SuperType =&gt;
    <span class="comment">/** The type of the qualifier.
     *  See the example for [[scala.reflect.api.Trees#SuperExtractor]].
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;SuperTypeApi.thistpe">thistpe</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** The type of the selector.
     *  See the example for [[scala.reflect.api.Trees#SuperExtractor]].
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;SuperTypeApi.supertpe">supertpe</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>
  <span class="delimiter">}</span>
  <span class="comment">/** The `ConstantType` type is not directly written in user programs, but arises as the type of a constant.
   *  The REPL expresses constant types like `Int(11)`. Here are some constants with their types:
   *  {{{
   *     1           ConstantType(Constant(1))
   *     &quot;abc&quot;       ConstantType(Constant(&quot;abc&quot;))
   *  }}}
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.ConstantTypeApi with Types.this.SingletonType" id="scala.reflect.api;Types;ConstantType">ConstantType</a> &gt;: Null &lt;: ConstantTypeApi with SingletonType

  <span class="comment">/** The constructor/extractor for `ConstantType` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Types.this.ConstantTypeExtractor" id="scala.reflect.api;Types.ConstantType">ConstantType</a>: <a href="#scala.reflect.api;Types;ConstantTypeExtractor" title="Types.this.ConstantTypeExtractor">ConstantTypeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `ConstantType(constant)`
   *  Here, `constant` is the constant value represented by the type.
   *  @group Extractors
   */</span>
  abstract class <a title="class ConstantTypeExtractor extends AnyRef" id="scala.reflect.api;Types;ConstantTypeExtractor">ConstantTypeExtractor</a> <a href="#scala.reflect.api;Types;ConstantTypeExtractor" title="Types.this.ConstantTypeExtractor" class="delimiter">{</a>
    def <a title="(tpe: Types.this.ConstantType)Option[Types.this.Constant]" id="scala.reflect.api;Types;ConstantTypeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.ConstantType" id="scala.reflect.api;Types;ConstantTypeExtractor.unapply.tpe">tpe</a>: <a href="#scala.reflect.api;Types;ConstantType" title="Types.this.ConstantType">ConstantType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Types.this.Constant]">Option</a><span class="delimiter">[</span>Constant<span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.constantType]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `value.tpe` or `internal.constantType` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(value: Types.this.Constant)(implicit token: Types.this.CompatToken)Types.this.ConstantType" id="scala.reflect.api;Types;ConstantTypeExtractor.apply">apply</a><span class="delimiter">(</span><a title="Types.this.Constant" id="scala.reflect.api;Types;ConstantTypeExtractor.apply.value">value</a>: <a href="Constants.scala.html#scala.reflect.api;Constants;Constant" title="Types.this.Constant">Constant</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;ConstantTypeExtractor.apply.token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;ConstantType" title="Types.this.ConstantType">ConstantType</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.constantType" title="(value: Types.this.Constant)Types.this.ConstantType">constantType</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;ConstantTypeExtractor.apply.value" title="Types.this.Constant">value</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all constant types support.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   */</span>
  trait <a title="trait ConstantTypeApi extends Types.this.TypeApi" id="scala.reflect.api;Types;ConstantTypeApi">ConstantTypeApi</a> extends <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: ConstantType =&gt;
    <span class="comment">/** The compile-time constant underlying this type. */</span>
    def <a title="=&gt; Types.this.Constant" id="scala.reflect.api;Types;ConstantTypeApi.value">value</a>: <a href="Constants.scala.html#scala.reflect.api;Constants;Constant" title="Types.this.Constant">Constant</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The `TypeRef` type describes types of any of the forms on the left,
   *  with their TypeRef representations to the right.
   *  {{{
   *     T # C[T_1, ..., T_n]      TypeRef(T, C, List(T_1, ..., T_n))
   *     p.C[T_1, ..., T_n]        TypeRef(p.type, C, List(T_1, ..., T_n))
   *     C[T_1, ..., T_n]          TypeRef(NoPrefix, C, List(T_1, ..., T_n))
   *     T # C                     TypeRef(T, C, Nil)
   *     p.C                       TypeRef(p.type, C, Nil)
   *     C                         TypeRef(NoPrefix, C, Nil)
   *  }}}
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.TypeRefApi with Types.this.Type" id="scala.reflect.api;Types;TypeRef">TypeRef</a> &gt;: Null &lt;: TypeRefApi with Type

  <span class="comment">/** The constructor/extractor for `TypeRef` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Types.this.TypeRefExtractor" id="scala.reflect.api;Types.TypeRef">TypeRef</a>: <a href="#scala.reflect.api;Types;TypeRefExtractor" title="Types.this.TypeRefExtractor">TypeRefExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `TypeRef(pre, sym, args)`
   *  Here, `pre` is the prefix of the type reference, `sym` is the symbol
   *  referred to by the type reference, and `args` is a possible empty list of
   *  type argumenrts.
   *  @group Extractors
   */</span>
  abstract class <a title="class TypeRefExtractor extends AnyRef" id="scala.reflect.api;Types;TypeRefExtractor">TypeRefExtractor</a> <a href="#scala.reflect.api;Types;TypeRefExtractor" title="Types.this.TypeRefExtractor" class="delimiter">{</a>
    def <a title="(tpe: Types.this.TypeRef)Option[(Types.this.Type, Types.this.Symbol, List[Types.this.Type])]" id="scala.reflect.api;Types;TypeRefExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.TypeRef" id="scala.reflect.api;Types;TypeRefExtractor.unapply.tpe">tpe</a>: <a href="#scala.reflect.api;Types;TypeRef" title="Types.this.TypeRef">TypeRef</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Types.this.Type, Types.this.Symbol, List[Types.this.Type])]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type, Symbol, List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.typeRef]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.typeRef` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])(implicit token: Types.this.CompatToken)Types.this.Type" id="scala.reflect.api;Types;TypeRefExtractor.apply">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.api;Types;TypeRefExtractor.apply.pre">pre</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Symbol" id="scala.reflect.api;Types;TypeRefExtractor.apply.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="scala.reflect.api;Types;TypeRefExtractor.apply.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;TypeRefExtractor.apply.token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.typeRef" title="(pre: Types.this.Type, sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type">typeRef</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;TypeRefExtractor.apply.pre" title="Types.this.Type">pre</a>, <a href="#scala.reflect.api;Types;TypeRefExtractor.apply.sym" title="Types.this.Symbol">sym</a>, <a href="#scala.reflect.api;Types;TypeRefExtractor.apply.args" title="List[Types.this.Type]">args</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all type refs support.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   */</span>
  trait <a title="trait TypeRefApi extends Types.this.TypeApi" id="scala.reflect.api;Types;TypeRefApi">TypeRefApi</a> extends <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: TypeRef =&gt;
    <span class="comment">/** The prefix of the type reference.
     *  Is equal to `NoPrefix` if the prefix is not applicable.
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;TypeRefApi.pre">pre</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** The underlying symbol of the type reference. */</span>
    def <a title="=&gt; Types.this.Symbol" id="scala.reflect.api;Types;TypeRefApi.sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>

    <span class="comment">/** The arguments of the type reference.
     *  Is equal to `Nil` if the arguments are not provided.
     */</span>
    def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.api;Types;TypeRefApi.args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/** A subtype of Type representing refined types as well as `ClassInfo` signatures.
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.CompoundTypeApi with Types.this.Type" id="scala.reflect.api;Types;CompoundType">CompoundType</a> &gt;: Null &lt;: CompoundTypeApi with Type

  <span class="comment">/** Has no special methods. Is here to provides erased identity for `CompoundType`.
   *  @group API
   */</span>
  trait <a title="trait CompoundTypeApi extends AnyRef" id="scala.reflect.api;Types;CompoundTypeApi">CompoundTypeApi</a>

  <span class="comment">/** The `RefinedType` type defines types of any of the forms on the left,
   *  with their RefinedType representations to the right.
   *  {{{
   *     P_1 with ... with P_m { D_1; ...; D_n}      RefinedType(List(P_1, ..., P_m), Scope(D_1, ..., D_n))
   *     P_1 with ... with P_m                       RefinedType(List(P_1, ..., P_m), Scope())
   *     { D_1; ...; D_n}                            RefinedType(List(AnyRef), Scope(D_1, ..., D_n))
   *  }}}
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.RefinedTypeApi with Types.this.CompoundType" id="scala.reflect.api;Types;RefinedType">RefinedType</a> &gt;: Null &lt;: RefinedTypeApi with CompoundType

  <span class="comment">/** The constructor/extractor for `RefinedType` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Types.this.RefinedTypeExtractor" id="scala.reflect.api;Types.RefinedType">RefinedType</a>: <a href="#scala.reflect.api;Types;RefinedTypeExtractor" title="Types.this.RefinedTypeExtractor">RefinedTypeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `RefinedType(parents, decls)`
   *  Here, `parents` is the list of parent types of the class, and `decls` is the scope
   *  containing all declarations in the class.
   *  @group Extractors
   */</span>
  abstract class <a title="class RefinedTypeExtractor extends AnyRef" id="scala.reflect.api;Types;RefinedTypeExtractor">RefinedTypeExtractor</a> <a href="#scala.reflect.api;Types;RefinedTypeExtractor" title="Types.this.RefinedTypeExtractor" class="delimiter">{</a>
    def <a title="(tpe: Types.this.RefinedType)Option[(List[Types.this.Type], Types.this.Scope)]" id="scala.reflect.api;Types;RefinedTypeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.RefinedType" id="scala.reflect.api;Types;RefinedTypeExtractor.unapply.tpe">tpe</a>: <a href="#scala.reflect.api;Types;RefinedType" title="Types.this.RefinedType">RefinedType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(List[Types.this.Type], Types.this.Scope)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span>, Scope<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.refinedType]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.refinedType` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(parents: List[Types.this.Type], decls: Types.this.Scope)(implicit token: Types.this.CompatToken)Types.this.RefinedType" id="scala.reflect.api;Types;RefinedTypeExtractor.apply(ff0e9558c3)">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.api;Types;RefinedTypeExtractor.apply(ff0e9558c3).parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="scala.reflect.api;Types;RefinedTypeExtractor.apply(ff0e9558c3).decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.api;Scopes;Scope" title="Types.this.Scope">Scope</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;RefinedTypeExtractor.apply(ff0e9558c3).token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;RefinedType" title="Types.this.RefinedType">RefinedType</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.refinedType(01afa8bd15)" title="(parents: List[Types.this.Type], decls: Types.this.Scope)Types.this.RefinedType">refinedType</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;RefinedTypeExtractor.apply(ff0e9558c3).parents" title="List[Types.this.Type]">parents</a>, <a href="#scala.reflect.api;Types;RefinedTypeExtractor.apply(ff0e9558c3).decls" title="Types.this.Scope">decls</a><span class="delimiter">)</span>

    <span class="comment">/** @see [[InternalApi.refinedType]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.refinedType` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)(implicit token: Types.this.CompatToken)Types.this.RefinedType" id="scala.reflect.api;Types;RefinedTypeExtractor.apply(e19622f440)">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.api;Types;RefinedTypeExtractor.apply(e19622f440).parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="scala.reflect.api;Types;RefinedTypeExtractor.apply(e19622f440).decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.api;Scopes;Scope" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="scala.reflect.api;Types;RefinedTypeExtractor.apply(e19622f440).clazz">clazz</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;RefinedTypeExtractor.apply(e19622f440).token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;RefinedType" title="Types.this.RefinedType">RefinedType</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.refinedType(a18cf241e1)" title="(parents: List[Types.this.Type], decls: Types.this.Scope, clazz: Types.this.Symbol)Types.this.RefinedType">refinedType</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;RefinedTypeExtractor.apply(e19622f440).parents" title="List[Types.this.Type]">parents</a>, <a href="#scala.reflect.api;Types;RefinedTypeExtractor.apply(e19622f440).decls" title="Types.this.Scope">decls</a>, <a href="#scala.reflect.api;Types;RefinedTypeExtractor.apply(e19622f440).clazz" title="Types.this.Symbol">clazz</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all refined types support.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   */</span>
  trait <a title="trait RefinedTypeApi extends Types.this.TypeApi" id="scala.reflect.api;Types;RefinedTypeApi">RefinedTypeApi</a> extends <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: RefinedType =&gt;
    <span class="comment">/** The superclasses of the type. */</span>
    def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.api;Types;RefinedTypeApi.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>

    <span class="comment">/** The scope that holds the definitions comprising the type. */</span>
    def <a title="=&gt; Types.this.MemberScope" id="scala.reflect.api;Types;RefinedTypeApi.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.api;Scopes;MemberScope" title="Types.this.MemberScope">MemberScope</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The `ClassInfo` type signature is used to define parents and declarations
   *  of classes, traits, and objects. If a class, trait, or object C is declared like this
   *  {{{
   *     C extends P_1 with ... with P_m { D_1; ...; D_n}
   *  }}}
   *  its `ClassInfo` type has the following form:
   *  {{{
   *     ClassInfo(List(P_1, ..., P_m), Scope(D_1, ..., D_n), C)
   *  }}}
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.ClassInfoTypeApi with Types.this.CompoundType" id="scala.reflect.api;Types;ClassInfoType">ClassInfoType</a> &gt;: Null &lt;: ClassInfoTypeApi with CompoundType

  <span class="comment">/** The constructor/extractor for `ClassInfoType` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Types.this.ClassInfoTypeExtractor" id="scala.reflect.api;Types.ClassInfoType">ClassInfoType</a>: <a href="#scala.reflect.api;Types;ClassInfoTypeExtractor" title="Types.this.ClassInfoTypeExtractor">ClassInfoTypeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `ClassInfo(parents, decls, clazz)`
   *  Here, `parents` is the list of parent types of the class, `decls` is the scope
   *  containing all declarations in the class, and `clazz` is the symbol of the class
   *  itself.
   *  @group Extractors
   */</span>
  abstract class <a title="class ClassInfoTypeExtractor extends AnyRef" id="scala.reflect.api;Types;ClassInfoTypeExtractor">ClassInfoTypeExtractor</a> <a href="#scala.reflect.api;Types;ClassInfoTypeExtractor" title="Types.this.ClassInfoTypeExtractor" class="delimiter">{</a>
    def <a title="(tpe: Types.this.ClassInfoType)Option[(List[Types.this.Type], Types.this.Scope, Types.this.Symbol)]" id="scala.reflect.api;Types;ClassInfoTypeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.ClassInfoType" id="scala.reflect.api;Types;ClassInfoTypeExtractor.unapply.tpe">tpe</a>: <a href="#scala.reflect.api;Types;ClassInfoType" title="Types.this.ClassInfoType">ClassInfoType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(List[Types.this.Type], Types.this.Scope, Types.this.Symbol)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span>, Scope, Symbol<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.classInfoType]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.classInfoType` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(parents: List[Types.this.Type], decls: Types.this.Scope, typeSymbol: Types.this.Symbol)(implicit token: Types.this.CompatToken)Types.this.ClassInfoType" id="scala.reflect.api;Types;ClassInfoTypeExtractor.apply">apply</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.api;Types;ClassInfoTypeExtractor.apply.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="Types.this.Scope" id="scala.reflect.api;Types;ClassInfoTypeExtractor.apply.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.api;Scopes;Scope" title="Types.this.Scope">Scope</a>, <a title="Types.this.Symbol" id="scala.reflect.api;Types;ClassInfoTypeExtractor.apply.typeSymbol">typeSymbol</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;ClassInfoTypeExtractor.apply.token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;ClassInfoType" title="Types.this.ClassInfoType">ClassInfoType</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.classInfoType" title="(parents: List[Types.this.Type], decls: Types.this.Scope, typeSymbol: Types.this.Symbol)Types.this.ClassInfoType">classInfoType</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;ClassInfoTypeExtractor.apply.parents" title="List[Types.this.Type]">parents</a>, <a href="#scala.reflect.api;Types;ClassInfoTypeExtractor.apply.decls" title="Types.this.Scope">decls</a>, <a href="#scala.reflect.api;Types;ClassInfoTypeExtractor.apply.typeSymbol" title="Types.this.Symbol">typeSymbol</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all class info types support.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   */</span>
  trait <a title="trait ClassInfoTypeApi extends Types.this.TypeApi" id="scala.reflect.api;Types;ClassInfoTypeApi">ClassInfoTypeApi</a> extends <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: ClassInfoType =&gt;
    <span class="comment">/** The superclasses of the class type. */</span>
    def <a title="=&gt; List[Types.this.Type]" id="scala.reflect.api;Types;ClassInfoTypeApi.parents">parents</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>

    <span class="comment">/** The scope that holds the definitions comprising the class type. */</span>
    def <a title="=&gt; Types.this.MemberScope" id="scala.reflect.api;Types;ClassInfoTypeApi.decls">decls</a>: <a href="Scopes.scala.html#scala.reflect.api;Scopes;MemberScope" title="Types.this.MemberScope">MemberScope</a>

    <span class="comment">/** The symbol underlying the class type. */</span>
    def <a title="=&gt; Types.this.Symbol" id="scala.reflect.api;Types;ClassInfoTypeApi.typeSymbol">typeSymbol</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The `MethodType` type signature is used to indicate parameters and result type of a method
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.MethodTypeApi with Types.this.Type" id="scala.reflect.api;Types;MethodType">MethodType</a> &gt;: Null &lt;: MethodTypeApi with Type

  <span class="comment">/** The constructor/extractor for `MethodType` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Types.this.MethodTypeExtractor" id="scala.reflect.api;Types.MethodType">MethodType</a>: <a href="#scala.reflect.api;Types;MethodTypeExtractor" title="Types.this.MethodTypeExtractor">MethodTypeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `MethodType(params, respte)`
   *  Here, `params` is a potentially empty list of parameter symbols of the method,
   *  and `restpe` is the result type of the method. If the method is curried, `restpe` would
   *  be another `MethodType`.
   *  Note: `MethodType(Nil, Int)` would be the type of a method defined with an empty parameter list.
   *  {{{
   *     def f(): Int
   *  }}}
   *  If the method is completely parameterless, as in
   *  {{{
   *     def f: Int
   *  }}}
   *  its type is a `NullaryMethodType`.
   *  @group Extractors
   */</span>
  abstract class <a title="class MethodTypeExtractor extends AnyRef" id="scala.reflect.api;Types;MethodTypeExtractor">MethodTypeExtractor</a> <a href="#scala.reflect.api;Types;MethodTypeExtractor" title="Types.this.MethodTypeExtractor" class="delimiter">{</a>
    def <a title="(tpe: Types.this.MethodType)Option[(List[Types.this.Symbol], Types.this.Type)]" id="scala.reflect.api;Types;MethodTypeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.MethodType" id="scala.reflect.api;Types;MethodTypeExtractor.unapply.tpe">tpe</a>: <a href="#scala.reflect.api;Types;MethodType" title="Types.this.MethodType">MethodType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(List[Types.this.Symbol], Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.methodType]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.methodType` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(params: List[Types.this.Symbol], resultType: Types.this.Type)(implicit token: Types.this.CompatToken)Types.this.MethodType" id="scala.reflect.api;Types;MethodTypeExtractor.apply">apply</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.api;Types;MethodTypeExtractor.apply.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.api;Types;MethodTypeExtractor.apply.resultType">resultType</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;MethodTypeExtractor.apply.token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;MethodType" title="Types.this.MethodType">MethodType</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.methodType" title="(params: List[Types.this.Symbol], resultType: Types.this.Type)Types.this.MethodType">methodType</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;MethodTypeExtractor.apply.params" title="List[Types.this.Symbol]">params</a>, <a href="#scala.reflect.api;Types;MethodTypeExtractor.apply.resultType" title="Types.this.Type">resultType</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all method types support.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   */</span>
  trait <a title="trait MethodTypeApi extends Types.this.TypeApi" id="scala.reflect.api;Types;MethodTypeApi">MethodTypeApi</a> extends <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: MethodType =&gt;
    <span class="comment">/** The symbols that correspond to the parameters of the method. */</span>
    def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.api;Types;MethodTypeApi.params">params</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    <span class="comment">/** The result type of the method. */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;MethodTypeApi.resultType">resultType</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The `NullaryMethodType` type signature is used for parameterless methods
   *  with declarations of the form `def foo: T`
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.NullaryMethodTypeApi with Types.this.Type" id="scala.reflect.api;Types;NullaryMethodType">NullaryMethodType</a> &gt;: Null &lt;: NullaryMethodTypeApi with Type

  <span class="comment">/** The constructor/extractor for `NullaryMethodType` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Types.this.NullaryMethodTypeExtractor" id="scala.reflect.api;Types.NullaryMethodType">NullaryMethodType</a>: <a href="#scala.reflect.api;Types;NullaryMethodTypeExtractor" title="Types.this.NullaryMethodTypeExtractor">NullaryMethodTypeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `NullaryMethodType(resultType)`.
   *  Here, `resultType` is the result type of the parameterless method.
   *  @group Extractors
   */</span>
  abstract class <a title="class NullaryMethodTypeExtractor extends AnyRef" id="scala.reflect.api;Types;NullaryMethodTypeExtractor">NullaryMethodTypeExtractor</a> <a href="#scala.reflect.api;Types;NullaryMethodTypeExtractor" title="Types.this.NullaryMethodTypeExtractor" class="delimiter">{</a>
    def <a title="(tpe: Types.this.NullaryMethodType)Option[Types.this.Type]" id="scala.reflect.api;Types;NullaryMethodTypeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.NullaryMethodType" id="scala.reflect.api;Types;NullaryMethodTypeExtractor.unapply.tpe">tpe</a>: <a href="#scala.reflect.api;Types;NullaryMethodType" title="Types.this.NullaryMethodType">NullaryMethodType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Types.this.Type]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.nullaryMethodType]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.nullaryMethodType` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(resultType: Types.this.Type)(implicit token: Types.this.CompatToken)Types.this.NullaryMethodType" id="scala.reflect.api;Types;NullaryMethodTypeExtractor.apply">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.api;Types;NullaryMethodTypeExtractor.apply.resultType">resultType</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;NullaryMethodTypeExtractor.apply.token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;NullaryMethodType" title="Types.this.NullaryMethodType">NullaryMethodType</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.nullaryMethodType" title="(resultType: Types.this.Type)Types.this.NullaryMethodType">nullaryMethodType</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;NullaryMethodTypeExtractor.apply.resultType" title="Types.this.Type">resultType</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all nullary method types support.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   */</span>
  trait <a title="trait NullaryMethodTypeApi extends Types.this.TypeApi" id="scala.reflect.api;Types;NullaryMethodTypeApi">NullaryMethodTypeApi</a> extends <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: NullaryMethodType =&gt;
    <span class="comment">/** The result type of the method. */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;NullaryMethodTypeApi.resultType">resultType</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The `PolyType` type signature is used for polymorphic methods
   *  that have at least one type parameter.
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.PolyTypeApi with Types.this.Type" id="scala.reflect.api;Types;PolyType">PolyType</a> &gt;: Null &lt;: PolyTypeApi with Type

  <span class="comment">/** The constructor/extractor for `PolyType` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Types.this.PolyTypeExtractor" id="scala.reflect.api;Types.PolyType">PolyType</a>: <a href="#scala.reflect.api;Types;PolyTypeExtractor" title="Types.this.PolyTypeExtractor">PolyTypeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `PolyType(typeParams, resultType)`.
   *  Here, `typeParams` are the type parameters of the method and `resultType`
   *  is the type signature following the type parameters.
   *  @group Extractors
   */</span>
  abstract class <a title="class PolyTypeExtractor extends AnyRef" id="scala.reflect.api;Types;PolyTypeExtractor">PolyTypeExtractor</a> <a href="#scala.reflect.api;Types;PolyTypeExtractor" title="Types.this.PolyTypeExtractor" class="delimiter">{</a>
    def <a title="(tpe: Types.this.PolyType)Option[(List[Types.this.Symbol], Types.this.Type)]" id="scala.reflect.api;Types;PolyTypeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.PolyType" id="scala.reflect.api;Types;PolyTypeExtractor.unapply.tpe">tpe</a>: <a href="#scala.reflect.api;Types;PolyType" title="Types.this.PolyType">PolyType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(List[Types.this.Symbol], Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.polyType]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.polyType` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(typeParams: List[Types.this.Symbol], resultType: Types.this.Type)(implicit token: Types.this.CompatToken)Types.this.PolyType" id="scala.reflect.api;Types;PolyTypeExtractor.apply">apply</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.api;Types;PolyTypeExtractor.apply.typeParams">typeParams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.api;Types;PolyTypeExtractor.apply.resultType">resultType</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;PolyTypeExtractor.apply.token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;PolyType" title="Types.this.PolyType">PolyType</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.polyType" title="(tparams: List[Types.this.Symbol], tpe: Types.this.Type)Types.this.PolyType">polyType</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;PolyTypeExtractor.apply.typeParams" title="List[Types.this.Symbol]">typeParams</a>, <a href="#scala.reflect.api;Types;PolyTypeExtractor.apply.resultType" title="Types.this.Type">resultType</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all polymorphic types support.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   */</span>
  trait <a title="trait PolyTypeApi extends Types.this.TypeApi" id="scala.reflect.api;Types;PolyTypeApi">PolyTypeApi</a> extends <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: PolyType =&gt;
    <span class="comment">/** The symbols corresponding to the type parameters. */</span>
    def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.api;Types;PolyTypeApi.typeParams">typeParams</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    <span class="comment">/** The underlying type. */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;PolyTypeApi.resultType">resultType</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The `ExistentialType` type signature is used for existential types and
   *  wildcard types.
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.ExistentialTypeApi with Types.this.Type" id="scala.reflect.api;Types;ExistentialType">ExistentialType</a> &gt;: Null &lt;: ExistentialTypeApi with Type

  <span class="comment">/** The constructor/extractor for `ExistentialType` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Types.this.ExistentialTypeExtractor" id="scala.reflect.api;Types.ExistentialType">ExistentialType</a>: <a href="#scala.reflect.api;Types;ExistentialTypeExtractor" title="Types.this.ExistentialTypeExtractor">ExistentialTypeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax
   *  `ExistentialType(quantified, underlying)`.
   *  Here, `quantified` are the type variables bound by the existential type and `underlying`
   *  is the type that's existentially quantified.
   *  @group Extractors
   */</span>
  abstract class <a title="class ExistentialTypeExtractor extends AnyRef" id="scala.reflect.api;Types;ExistentialTypeExtractor">ExistentialTypeExtractor</a> <a href="#scala.reflect.api;Types;ExistentialTypeExtractor" title="Types.this.ExistentialTypeExtractor" class="delimiter">{</a>
    def <a title="(tpe: Types.this.ExistentialType)Option[(List[Types.this.Symbol], Types.this.Type)]" id="scala.reflect.api;Types;ExistentialTypeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.ExistentialType" id="scala.reflect.api;Types;ExistentialTypeExtractor.unapply.tpe">tpe</a>: <a href="#scala.reflect.api;Types;ExistentialType" title="Types.this.ExistentialType">ExistentialType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(List[Types.this.Symbol], Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.existentialType]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.existentialType` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)(implicit token: Types.this.CompatToken)Types.this.ExistentialType" id="scala.reflect.api;Types;ExistentialTypeExtractor.apply">apply</a><span class="delimiter">(</span><a title="List[Types.this.Symbol]" id="scala.reflect.api;Types;ExistentialTypeExtractor.apply.quantified">quantified</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.api;Types;ExistentialTypeExtractor.apply.underlying">underlying</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;ExistentialTypeExtractor.apply.token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;ExistentialType" title="Types.this.ExistentialType">ExistentialType</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.existentialType" title="(quantified: List[Types.this.Symbol], underlying: Types.this.Type)Types.this.ExistentialType">existentialType</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;ExistentialTypeExtractor.apply.quantified" title="List[Types.this.Symbol]">quantified</a>, <a href="#scala.reflect.api;Types;ExistentialTypeExtractor.apply.underlying" title="Types.this.Type">underlying</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all existential types support.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   */</span>
  trait <a title="trait ExistentialTypeApi extends Types.this.TypeApi" id="scala.reflect.api;Types;ExistentialTypeApi">ExistentialTypeApi</a> extends <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: ExistentialType =&gt;
    <span class="comment">/** The symbols corresponding to the `forSome` clauses of the existential type. */</span>
    def <a title="=&gt; List[Types.this.Symbol]" id="scala.reflect.api;Types;ExistentialTypeApi.quantified">quantified</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>

    <span class="comment">/** The underlying type of the existential type. */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;ExistentialTypeApi.underlying">underlying</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The `AnnotatedType` type signature is used for annotated types of the
   *  for `&lt;type&gt; @&lt;annotation&gt;`.
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.AnnotatedTypeApi with Types.this.Type" id="scala.reflect.api;Types;AnnotatedType">AnnotatedType</a> &gt;: Null &lt;: AnnotatedTypeApi with Type

  <span class="comment">/** The constructor/extractor for `AnnotatedType` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Types.this.AnnotatedTypeExtractor" id="scala.reflect.api;Types.AnnotatedType">AnnotatedType</a>: <a href="#scala.reflect.api;Types;AnnotatedTypeExtractor" title="Types.this.AnnotatedTypeExtractor">AnnotatedTypeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax
   * `AnnotatedType(annotations, underlying)`.
   *  Here, `annotations` are the annotations decorating the underlying type `underlying`.
   *  `selfSym` is a symbol representing the annotated type itself.
   *  @group Extractors
   */</span>
  abstract class <a title="class AnnotatedTypeExtractor extends AnyRef" id="scala.reflect.api;Types;AnnotatedTypeExtractor">AnnotatedTypeExtractor</a> <a href="#scala.reflect.api;Types;AnnotatedTypeExtractor" title="Types.this.AnnotatedTypeExtractor" class="delimiter">{</a>
    def <a title="(tpe: Types.this.AnnotatedType)Option[(List[Types.this.Annotation], Types.this.Type)]" id="scala.reflect.api;Types;AnnotatedTypeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.AnnotatedType" id="scala.reflect.api;Types;AnnotatedTypeExtractor.unapply.tpe">tpe</a>: <a href="#scala.reflect.api;Types;AnnotatedType" title="Types.this.AnnotatedType">AnnotatedType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(List[Types.this.Annotation], Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Annotation<span class="delimiter">]</span>, Type<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.annotatedType]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.annotatedType` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(annotations: List[Types.this.Annotation], underlying: Types.this.Type)(implicit token: Types.this.CompatToken)Types.this.AnnotatedType" id="scala.reflect.api;Types;AnnotatedTypeExtractor.apply">apply</a><span class="delimiter">(</span><a title="List[Types.this.Annotation]" id="scala.reflect.api;Types;AnnotatedTypeExtractor.apply.annotations">annotations</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Annotation]">List</a><span class="delimiter">[</span>Annotation<span class="delimiter">]</span>, <a title="Types.this.Type" id="scala.reflect.api;Types;AnnotatedTypeExtractor.apply.underlying">underlying</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;AnnotatedTypeExtractor.apply.token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;AnnotatedType" title="Types.this.AnnotatedType">AnnotatedType</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.annotatedType" title="(annotations: List[Types.this.Annotation], underlying: Types.this.Type)Types.this.AnnotatedType">annotatedType</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;AnnotatedTypeExtractor.apply.annotations" title="List[Types.this.Annotation]">annotations</a>, <a href="#scala.reflect.api;Types;AnnotatedTypeExtractor.apply.underlying" title="Types.this.Type">underlying</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all annotated types support.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   */</span>
  trait <a title="trait AnnotatedTypeApi extends Types.this.TypeApi" id="scala.reflect.api;Types;AnnotatedTypeApi">AnnotatedTypeApi</a> extends <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: AnnotatedType =&gt;
    <span class="comment">/** The annotations. */</span>
    def <a title="=&gt; List[Types.this.Annotation]" id="scala.reflect.api;Types;AnnotatedTypeApi.annotations">annotations</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Annotation]">List</a><span class="delimiter">[</span>Annotation<span class="delimiter">]</span>

    <span class="comment">/** The annotee. */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;AnnotatedTypeApi.underlying">underlying</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The `TypeBounds` type signature is used to indicate lower and upper type bounds
   *  of type parameters and abstract types. It is not a first-class type.
   *  If an abstract type or type parameter is declared with any of the forms
   *  on the left, its type signature is the TypeBounds type on the right.
   *  {{{
   *     T &gt;: L &lt;: U               TypeBounds(L, U)
   *     T &gt;: L                    TypeBounds(L, Any)
   *     T &lt;: U                    TypeBounds(Nothing, U)
   *  }}}
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.TypeBoundsApi with Types.this.Type" id="scala.reflect.api;Types;TypeBounds">TypeBounds</a> &gt;: Null &lt;: TypeBoundsApi with Type

  <span class="comment">/** The constructor/extractor for `TypeBounds` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Types.this.TypeBoundsExtractor" id="scala.reflect.api;Types.TypeBounds">TypeBounds</a>: <a href="#scala.reflect.api;Types;TypeBoundsExtractor" title="Types.this.TypeBoundsExtractor">TypeBoundsExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `TypeBound(lower, upper)`
   *  Here, `lower` is the lower bound of the `TypeBounds` pair, and `upper` is
   *  the upper bound.
   *  @group Extractors
   */</span>
  abstract class <a title="class TypeBoundsExtractor extends AnyRef" id="scala.reflect.api;Types;TypeBoundsExtractor">TypeBoundsExtractor</a> <a href="#scala.reflect.api;Types;TypeBoundsExtractor" title="Types.this.TypeBoundsExtractor" class="delimiter">{</a>
    def <a title="(tpe: Types.this.TypeBounds)Option[(Types.this.Type, Types.this.Type)]" id="scala.reflect.api;Types;TypeBoundsExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="scala.reflect.api;Types;TypeBoundsExtractor.unapply.tpe">tpe</a>: <a href="#scala.reflect.api;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[(Types.this.Type, Types.this.Type)]">Option</a><span class="delimiter">[</span><span class="delimiter">(</span>Type, Type<span class="delimiter">)</span><span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.typeBounds]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.typeBounds` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(lo: Types.this.Type, hi: Types.this.Type)(implicit token: Types.this.CompatToken)Types.this.TypeBounds" id="scala.reflect.api;Types;TypeBoundsExtractor.apply">apply</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.api;Types;TypeBoundsExtractor.apply.lo">lo</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type" id="scala.reflect.api;Types;TypeBoundsExtractor.apply.hi">hi</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;TypeBoundsExtractor.apply.token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.typeBounds" title="(lo: Types.this.Type, hi: Types.this.Type)Types.this.TypeBounds">typeBounds</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;TypeBoundsExtractor.apply.lo" title="Types.this.Type">lo</a>, <a href="#scala.reflect.api;Types;TypeBoundsExtractor.apply.hi" title="Types.this.Type">hi</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all type bounds support.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   */</span>
  trait <a title="trait TypeBoundsApi extends Types.this.TypeApi" id="scala.reflect.api;Types;TypeBoundsApi">TypeBoundsApi</a> extends <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: TypeBounds =&gt;
    <span class="comment">/** The lower bound.
     *  Is equal to `definitions.NothingTpe` if not specified explicitly.
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;TypeBoundsApi.lo">lo</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

    <span class="comment">/** The upper bound.
     *  Is equal to `definitions.AnyTpe` if not specified explicitly.
     */</span>
    def <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types;TypeBoundsApi.hi">hi</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>
  <span class="delimiter">}</span>

  <span class="comment">/** An object representing an unknown type, used during type inference.
   *  If you see WildcardType outside of inference it is almost certainly a bug.
   *  @group Types
   */</span>
  val <a title="=&gt; Types.this.Type" id="scala.reflect.api;Types.WildcardType">WildcardType</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

  <span class="comment">/** BoundedWildcardTypes, used only during type inference, are created in
   *  two places:
   *
   *    1. If the expected type of an expression is an existential type,
   *       its hidden symbols are replaced with bounded wildcards.
   *    2. When an implicit conversion is being sought based in part on
   *       the name of a method in the converted type, a HasMethodMatching
   *       type is created: a MethodType with parameters typed as
   *       BoundedWildcardTypes.
   *  @template
   *  @group Types
   */</span>
  type <a title=" &gt;: Null &lt;: Types.this.BoundedWildcardTypeApi with Types.this.Type" id="scala.reflect.api;Types;BoundedWildcardType">BoundedWildcardType</a> &gt;: Null &lt;: BoundedWildcardTypeApi with Type

  <span class="comment">/** The constructor/extractor for `BoundedWildcardType` instances.
   *  @group Extractors
   */</span>
  val <a title="=&gt; Types.this.BoundedWildcardTypeExtractor" id="scala.reflect.api;Types.BoundedWildcardType">BoundedWildcardType</a>: <a href="#scala.reflect.api;Types;BoundedWildcardTypeExtractor" title="Types.this.BoundedWildcardTypeExtractor">BoundedWildcardTypeExtractor</a>

  <span class="comment">/** An extractor class to create and pattern match with syntax `BoundedWildcardTypeExtractor(bounds)`
   *  with `bounds` denoting the type bounds.
   *  @group Extractors
   */</span>
  abstract class <a title="class BoundedWildcardTypeExtractor extends AnyRef" id="scala.reflect.api;Types;BoundedWildcardTypeExtractor">BoundedWildcardTypeExtractor</a> <a href="#scala.reflect.api;Types;BoundedWildcardTypeExtractor" title="Types.this.BoundedWildcardTypeExtractor" class="delimiter">{</a>
    def <a title="(tpe: Types.this.BoundedWildcardType)Option[Types.this.TypeBounds]" id="scala.reflect.api;Types;BoundedWildcardTypeExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="Types.this.BoundedWildcardType" id="scala.reflect.api;Types;BoundedWildcardTypeExtractor.unapply.tpe">tpe</a>: <a href="#scala.reflect.api;Types;BoundedWildcardType" title="Types.this.BoundedWildcardType">BoundedWildcardType</a><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[Types.this.TypeBounds]">Option</a><span class="delimiter">[</span>TypeBounds<span class="delimiter">]</span>

    <span class="comment">/** @see [[InternalApi.boundedWildcardType]] */</span>
    @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `internal.boundedWildcardType` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
    def <a title="(bounds: Types.this.TypeBounds)(implicit token: Types.this.CompatToken)Types.this.BoundedWildcardType" id="scala.reflect.api;Types;BoundedWildcardTypeExtractor.apply">apply</a><span class="delimiter">(</span><a title="Types.this.TypeBounds" id="scala.reflect.api;Types;BoundedWildcardTypeExtractor.apply.bounds">bounds</a>: <a href="#scala.reflect.api;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Types.this.CompatToken" id="scala.reflect.api;Types;BoundedWildcardTypeExtractor.apply.token">token</a>: <a href="Internals.scala.html#scala.reflect.api;Internals;CompatToken" title="Types.this.CompatToken">CompatToken</a><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;BoundedWildcardType" title="Types.this.BoundedWildcardType">BoundedWildcardType</a> = <a href="Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; Types.this.Internal">internal</a>.<a href="Internals.scala.html#scala.reflect.api;Internals;InternalApi.boundedWildcardType" title="(bounds: Types.this.TypeBounds)Types.this.BoundedWildcardType">boundedWildcardType</a><span class="delimiter">(</span><a href="#scala.reflect.api;Types;BoundedWildcardTypeExtractor.apply.bounds" title="Types.this.TypeBounds">bounds</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** The API that all this types support.
   *  The main source of information about types is the [[scala.reflect.api.Types]] page.
   *  @group API
   */</span>
  trait <a title="trait BoundedWildcardTypeApi extends Types.this.TypeApi" id="scala.reflect.api;Types;BoundedWildcardTypeApi">BoundedWildcardTypeApi</a> extends <a href="#scala.reflect.api;Types;TypeApi" title="Types.this.TypeApi">TypeApi</a> <span class="delimiter">{</span> this: BoundedWildcardType =&gt;
    <span class="comment">/** Type bounds for the wildcard type. */</span>
    def <a title="=&gt; Types.this.TypeBounds" id="scala.reflect.api;Types;BoundedWildcardTypeApi.bounds">bounds</a>: <a href="#scala.reflect.api;Types;TypeBounds" title="Types.this.TypeBounds">TypeBounds</a>
  <span class="delimiter">}</span>

  <span class="comment">/** The least upper bound of a list of types, as determined by `&lt;:&lt;`.
   *  @group TypeOps
   */</span>
  def <a title="(xs: List[Types.this.Type])Types.this.Type" id="scala.reflect.api;Types.lub">lub</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.api;Types.lub.xs">xs</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

  <span class="comment">/** The greatest lower bound of a list of types, as determined by `&lt;:&lt;`.
   *  @group TypeOps
   */</span>
  def <a title="(ts: List[Types.this.Type])Types.this.Type" id="scala.reflect.api;Types.glb">glb</a><span class="delimiter">(</span><a title="List[Types.this.Type]" id="scala.reflect.api;Types.glb.ts">ts</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

  <span class="comment">/** A creator for type applications
   *  @group TypeOps
   */</span>
  def <a title="(tycon: Types.this.Type, args: List[Types.this.Type])Types.this.Type" id="scala.reflect.api;Types.appliedType(c7fb433f73)">appliedType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.api;Types.appliedType(c7fb433f73).tycon">tycon</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>, <a title="List[Types.this.Type]" id="scala.reflect.api;Types.appliedType(c7fb433f73).args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

  <span class="comment">/** @see [[appliedType]] */</span>
  def <a title="(tycon: Types.this.Type, args: Types.this.Type*)Types.this.Type" id="scala.reflect.api;Types.appliedType(aa8684a9c7)">appliedType</a><span class="delimiter">(</span><a title="Types.this.Type" id="scala.reflect.api;Types.appliedType(aa8684a9c7).tycon">tycon</a>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>, <a title="Types.this.Type*" id="scala.reflect.api;Types.appliedType(aa8684a9c7).args">args</a>: <span title="Types.this.Type*">Type</span>*<span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

  <span class="comment">/** @see [[appliedType]] */</span>
  def <a title="(sym: Types.this.Symbol, args: List[Types.this.Type])Types.this.Type" id="scala.reflect.api;Types.appliedType(acda4ecfb8)">appliedType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.api;Types.appliedType(acda4ecfb8).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="List[Types.this.Type]" id="scala.reflect.api;Types.appliedType(acda4ecfb8).args">args</a>: <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Types.this.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>

  <span class="comment">/** @see [[appliedType]] */</span>
  def <a title="(sym: Types.this.Symbol, args: Types.this.Type*)Types.this.Type" id="scala.reflect.api;Types.appliedType(86048f13f9)">appliedType</a><span class="delimiter">(</span><a title="Types.this.Symbol" id="scala.reflect.api;Types.appliedType(86048f13f9).sym">sym</a>: <a href="Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="Types.this.Symbol">Symbol</a>, <a title="Types.this.Type*" id="scala.reflect.api;Types.appliedType(86048f13f9).args">args</a>: <span title="Types.this.Type*">Type</span>*<span class="delimiter">)</span>: <a href="#scala.reflect.api;Types;Type" title="Types.this.Type">Type</a>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
