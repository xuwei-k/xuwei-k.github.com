<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/reflect/runtime/ReflectionUtils.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* NSC -- new Scala compiler
 * Copyright 2005-2013 LAMP/EPFL
 * @author  Paul Phillips
 */</span>

package scala
package reflect.runtime

import java.lang.<span class="delimiter">{</span>Class =&gt; jClass<span class="delimiter">}</span>
import java.lang.reflect.<span class="delimiter">{</span> Method, InvocationTargetException, UndeclaredThrowableException <span class="delimiter">}</span>
import scala.reflect.internal.util.AbstractFileClassLoader
import scala.reflect.io._
import java.io.<span class="delimiter">{</span>File =&gt; JFile<span class="delimiter">}</span>

<span class="comment">/** A few java-reflection oriented utility functions useful during reflection bootstrapping.
 */</span>
object <a title="scala.reflect.runtime.ReflectionUtils.type" id="scala.reflect.runtime.ReflectionUtils">ReflectionUtils</a> <a href="#scala.reflect.runtime.ReflectionUtils" title="scala.reflect.runtime.ReflectionUtils.type" class="delimiter">{</a>
  <span class="comment">// Unwraps some chained exceptions which arise during reflective calls.</span>
  def <a title="(x: Throwable)Throwable" id="scala.reflect.runtime.ReflectionUtils.unwrapThrowable">unwrapThrowable</a><span class="delimiter">(</span><a title="Throwable" id="scala.reflect.runtime.ReflectionUtils.unwrapThrowable.x">x</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span>: <span title="Throwable">Throwable</span> = <a href="#scala.reflect.runtime.ReflectionUtils.unwrapThrowable.x" title="Throwable">x</a> match <span class="delimiter">{</span>
    case  _: <span title="java.lang.reflect.InvocationTargetException">InvocationTargetException</span> |      <span class="comment">// thrown by reflectively invoked method or constructor</span>
          _: <span title="ExceptionInInitializerError">ExceptionInInitializerError</span> |    <span class="comment">// thrown when running a static initializer (e.g. a scala module constructor)</span>
          _: <span title="java.lang.reflect.UndeclaredThrowableException">UndeclaredThrowableException</span> |   <span class="comment">// invocation on a proxy instance if its invocation handler's `invoke` throws an exception</span>
          _: <span title="ClassNotFoundException">ClassNotFoundException</span> |         <span class="comment">// no definition for a class instantiated by name</span>
          _: <span title="NoClassDefFoundError">NoClassDefFoundError</span>             <span class="comment">// the definition existed when the executing class was compiled, but can no longer be found</span>
            if <a href="#scala.reflect.runtime.ReflectionUtils.unwrapThrowable.x" title="Throwable">x</a>.<span title="()Throwable">getCause</span> <span title="(x$1: Any)Boolean">!=</span> null =&gt;
              <a href="#scala.reflect.runtime.ReflectionUtils.unwrapThrowable" title="(x: Throwable)Throwable">unwrapThrowable</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.unwrapThrowable.x" title="Throwable">x</a>.<span title="()Throwable">getCause</span><span class="delimiter">)</span>
    case _ =&gt; <a href="#scala.reflect.runtime.ReflectionUtils.unwrapThrowable.x" title="Throwable">x</a>
  <span class="delimiter">}</span>
  <span class="comment">// Transforms an exception handler into one which will only receive the unwrapped</span>
  <span class="comment">// exceptions (for the values of wrap covered in unwrapThrowable.)</span>
  def <a title="[T](pf: PartialFunction[Throwable,T])PartialFunction[Throwable,T]" id="scala.reflect.runtime.ReflectionUtils.unwrapHandler">unwrapHandler</a><span class="delimiter">[</span><a title="" id="scala.reflect.runtime.ReflectionUtils.unwrapHandler;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[Throwable,T]" id="scala.reflect.runtime.ReflectionUtils.unwrapHandler.pf">pf</a>: <a href="../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[Throwable,T]">PartialFunction</a><span class="delimiter">[</span>Throwable, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../PartialFunction.scala.html#scala;PartialFunction" title="PartialFunction[Throwable,T]">PartialFunction</a><span class="delimiter">[</span>Throwable, T<span class="delimiter">]</span> = <a title="&lt;$anon: Throwable =&gt; T&gt; extends scala.runtime.AbstractPartialFunction[Throwable,T] with Serializable" id="scala.reflect.runtime.ReflectionUtils.unwrapHandler;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
    case <a title="Throwable" id="scala.reflect.runtime.ReflectionUtils.unwrapHandler;$anonfun.isDefinedAt.ex">ex</a> if <a href="#scala.reflect.runtime.ReflectionUtils.unwrapHandler.pf" title="PartialFunction[Throwable,T]">pf</a> <a href="../../PartialFunction.scala.html#scala;PartialFunction.isDefinedAt" title="(x: Throwable)Boolean">isDefinedAt</a> <a href="#scala.reflect.runtime.ReflectionUtils.unwrapThrowable" title="(x: Throwable)Throwable">unwrapThrowable</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.unwrapHandler;$anonfun.isDefinedAt.ex" title="Throwable">ex</a><span class="delimiter">)</span>   =&gt; <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Throwable)T">pf</a><span title="Boolean(true)" class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.unwrapThrowable" title="(x: Throwable)Throwable">unwrapThrowable</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.unwrapHandler;$anonfun.isDefinedAt.ex" title="Throwable">ex</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(cl: ClassLoader)String" id="scala.reflect.runtime.ReflectionUtils.show">show</a><span class="delimiter">(</span><span title="ClassLoader">cl</span>: <span title="ClassLoader">ClassLoader</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    import scala.<a href="../../language.scala.html#scala.language" title="language.type">language</a>.reflectiveCalls

    def <a title="(clazz: Class[_])Boolean" id="scala.reflect.runtime.ReflectionUtils.show.isAbstractFileClassLoader">isAbstractFileClassLoader</a><span class="delimiter">(</span><a title="Class[_]" id="scala.reflect.runtime.ReflectionUtils.show.isAbstractFileClassLoader.clazz">clazz</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.show.isAbstractFileClassLoader.clazz" title="Class[_]">clazz</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span> return false
      if <span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.show.isAbstractFileClassLoader.clazz" title="Class[_]">clazz</a> <span title="(x$1: Any)Boolean">==</span> classOf<span title="Class[scala.reflect.internal.util.AbstractFileClassLoader](classOf[scala.reflect.internal.util.AbstractFileClassLoader])" class="delimiter">[</span>AbstractFileClassLoader<span class="delimiter">]</span><span class="delimiter">)</span> return true
      <a href="#scala.reflect.runtime.ReflectionUtils.show.isAbstractFileClassLoader" title="(clazz: Class[_])Boolean">isAbstractFileClassLoader</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.show.isAbstractFileClassLoader.clazz" title="Class[_]">clazz</a>.<span title="()Class[_ &gt;: _$1]">getSuperclass</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    def <a title="(cl: ClassLoader)String" id="scala.reflect.runtime.ReflectionUtils.show.inferClasspath">inferClasspath</a><span class="delimiter">(</span><span title="ClassLoader">cl</span>: <span title="ClassLoader">ClassLoader</span><span class="delimiter">)</span>: <span title="String">String</span> = <span title="ClassLoader">cl</span> match <span class="delimiter">{</span>
      case <span title="java.net.URLClassLoader">cl</span>: java.net.<span title="java.net.URLClassLoader">URLClassLoader</span> =&gt;
        <span class="delimiter">(</span><span title="java.net.URLClassLoader">cl</span>.<a href="../../Predef.scala.html#scala.Predef.refArrayOps" title="(xs: Array[java.net.URL])scala.collection.mutable.ArrayOps[java.net.URL]">getURLs</a> <a href="../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a> <span title="String(&quot;,&quot;)" class="string">&quot;,&quot;</span><span class="delimiter">)</span>
      case <span title="ClassLoader">cl</span> if <span title="ClassLoader">cl</span> <span title="(x$1: Any)Boolean">!=</span> null <a href="../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.reflect.runtime.ReflectionUtils.show.isAbstractFileClassLoader" title="(clazz: Class[_])Boolean">isAbstractFileClassLoader</a><span class="delimiter">(</span><span title="ClassLoader">cl</span>.<span title="()Class[_]">getClass</span><span class="delimiter">)</span> =&gt;
        <span title="ClassLoader">cl</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="&lt;refinement of AnyRef&gt; extends AnyRef" class="delimiter">[</span><a href="#scala.reflect.runtime.ReflectionUtils;<refinement>" title="&lt;refinement of AnyRef&gt; extends AnyRef" class="delimiter">{</a>val root: scala.reflect.io.AbstractFile<span class="delimiter">}</span><span class="delimiter">]</span>.<a href="#scala.reflect.runtime.ReflectionUtils;<refinement>.root" title="=&gt; scala.reflect.io.AbstractFile">root</a>.<a href="../io/AbstractFile.scala.html#scala.reflect.io;AbstractFile.canonicalPath" title="=&gt; String">canonicalPath</a>
      case null =&gt;
        val <a title="String =&gt; Option[String]" id="scala.reflect.runtime.ReflectionUtils.show.inferClasspath.loadBootCp">loadBootCp</a> = <span class="delimiter">(</span>flavor: <span title="String">String</span><span class="delimiter">)</span> =&gt; scala.util.<a href="../../util/Properties.scala.html#scala.util.Properties" title="scala.util.Properties.type">Properties</a>.<a href="../../util/Properties.scala.html#scala.util;PropertiesTrait.propOrNone" title="(name: String)Option[String]">propOrNone</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.show.inferClasspath.loadBootCp.$anonfun.flavor" title="String">flavor</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.boot.class.path&quot;)" class="string">&quot;.boot.class.path&quot;</span><span class="delimiter">)</span>
        <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: String)Option[String]">loadBootCp</a><span class="delimiter">(</span><span title="String(&quot;sun&quot;)" class="string">&quot;sun&quot;</span><span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Option.orElse" title="(alternative: =&gt; Option[String])Option[String]">orElse</a> <a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: String)Option[String]">loadBootCp</a><span class="delimiter">(</span><span title="String(&quot;java&quot;)" class="string">&quot;java&quot;</span><span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Option.getOrElse" title="(default: =&gt; String)String">getOrElse</a> <span title="String(&quot;&lt;unknown&gt;&quot;)" class="string">&quot;&lt;unknown&gt;&quot;</span>
      case _ =&gt;
        <span title="String(&quot;&lt;unknown&gt;&quot;)" class="string">&quot;&lt;unknown&gt;&quot;</span>
    <span class="delimiter">}</span>
    <span title="ClassLoader">cl</span> match <span class="delimiter">{</span>
      case <span title="ClassLoader">cl</span> if <span title="ClassLoader">cl</span> <span title="(x$1: Any)Boolean">!=</span> null =&gt;
        <a href="../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%s of type %s with classpath [%s] and parent being %s&quot;</a>.<a href="../../collection/immutable/StringLike.scala.html#scala.collection.immutable;StringLike.format" title="(args: Any*)String">format</a><span class="delimiter">(</span><span title="ClassLoader">cl</span>, <span title="ClassLoader">cl</span>.<span title="()Class[_]">getClass</span>, <a href="#scala.reflect.runtime.ReflectionUtils.show.inferClasspath" title="(cl: ClassLoader)String">inferClasspath</a><span class="delimiter">(</span><span title="ClassLoader">cl</span><span class="delimiter">)</span>, <a href="#scala.reflect.runtime.ReflectionUtils.show" title="(cl: ClassLoader)String">show</a><span class="delimiter">(</span><span title="ClassLoader">cl</span>.<span title="()ClassLoader">getParent</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case null =&gt;
        <a href="../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;primordial classloader with boot classpath [%s]&quot;</a>.<a href="../../collection/immutable/StringLike.scala.html#scala.collection.immutable;StringLike.format" title="(args: Any*)String">format</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.show.inferClasspath" title="(cl: ClassLoader)String">inferClasspath</a><span class="delimiter">(</span><span title="ClassLoader">cl</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(cl: ClassLoader, className: String)AnyRef" id="scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(9c7cc61450)">staticSingletonInstance</a><span class="delimiter">(</span><a title="ClassLoader" id="scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(9c7cc61450).cl">cl</a>: <span title="ClassLoader">ClassLoader</span>, <a title="String" id="scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(9c7cc61450).className">className</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="AnyRef">AnyRef</span> = <span class="delimiter">{</span>
    val <a title="String" id="scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(9c7cc61450).name">name</a> = if <span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(9c7cc61450).className" title="String">className</a> <span title="(x$1: String)Boolean">endsWith</span> <span title="String(&quot;$&quot;)" class="string">&quot;$&quot;</span><span class="delimiter">)</span> <a href="#scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(9c7cc61450).className" title="String">className</a> else <a href="#scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(9c7cc61450).className" title="String">className</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;$&quot;)" class="string">&quot;$&quot;</span>
    val <a title="Class[_]" id="scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(9c7cc61450).clazz">clazz</a> = java.lang.<span title="Class.type">Class</span>.<span title="(x$1: String, x$2: Boolean, x$3: ClassLoader)Class[_]">forName</span><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(9c7cc61450).name" title="String">name</a>, true, <a href="#scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(9c7cc61450).cl" title="ClassLoader">cl</a><span class="delimiter">)</span>
    <a href="#scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(e247429358)" title="(clazz: Class[_])AnyRef">staticSingletonInstance</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(9c7cc61450).clazz" title="Class[_]">clazz</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(clazz: Class[_])AnyRef" id="scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(e247429358)">staticSingletonInstance</a><span class="delimiter">(</span><a title="Class[_]" id="scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(e247429358).clazz">clazz</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="AnyRef">AnyRef</span> = <a href="#scala.reflect.runtime.ReflectionUtils.staticSingletonInstance(e247429358).clazz" title="Class[_]">clazz</a> <span title="(x$1: String)java.lang.reflect.Field">getField</span> <span title="String(&quot;MODULE$&quot;)" class="string">&quot;MODULE$&quot;</span> <span title="(x$1: Any)Object">get</span> null

  def <a title="(outer: AnyRef, className: String)AnyRef" id="scala.reflect.runtime.ReflectionUtils.innerSingletonInstance">innerSingletonInstance</a><span class="delimiter">(</span><a title="AnyRef" id="scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.outer">outer</a>: <span title="AnyRef">AnyRef</span>, <a title="String" id="scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.className">className</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="AnyRef">AnyRef</span> = <span class="delimiter">{</span>
    val <a title="String" id="scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.accessorName">accessorName</a> = if <span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.className" title="String">className</a> <span title="(x$1: String)Boolean">endsWith</span> <span title="String(&quot;$&quot;)" class="string">&quot;$&quot;</span><span class="delimiter">)</span> <a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.className" title="String">className</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.className" title="String">className</a>.<span title="()Int">length</span> <a href="../../Int.scala.html#scala;Int.-(1409840560)" title="(x: Int)Int">-</a> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> else <a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.className" title="String">className</a>
    def <a title="(clazz: Class[_])Option[java.lang.reflect.Method]" id="scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.singletonAccessor">singletonAccessor</a><span class="delimiter">(</span><a title="Class[_]" id="scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.singletonAccessor.clazz">clazz</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[java.lang.reflect.Method]">Option</a><span class="delimiter">[</span>Method<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.singletonAccessor.clazz" title="Class[_]">clazz</a> <span title="(x$1: Any)Boolean">==</span> null<span class="delimiter">)</span> <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
      else <span class="delimiter">{</span>
        val <a title="Option[java.lang.reflect.Method]" id="scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.singletonAccessor.declaredAccessor">declaredAccessor</a> = <a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.singletonAccessor.clazz" title="Class[_]">clazz</a>.<a href="../../Predef.scala.html#scala.Predef.refArrayOps" title="(xs: Array[java.lang.reflect.Method])scala.collection.mutable.ArrayOps[java.lang.reflect.Method]">getDeclaredMethods</a>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filter" title="(p: java.lang.reflect.Method =&gt; Boolean)Array[java.lang.reflect.Method]">filter</a><a href="../../Predef.scala.html#scala.Predef.refArrayOps" title="(xs: Array[java.lang.reflect.Method])scala.collection.mutable.ArrayOps[java.lang.reflect.Method]" class="delimiter">(</a><a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.singletonAccessor.declaredAccessor.$anonfun.x$1" title="java.lang.reflect.Method">_</a>.<span title="()String">getName</span> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.accessorName" title="String">accessorName</a><span class="delimiter">)</span>.<a href="../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.headOption" title="=&gt; Option[java.lang.reflect.Method]">headOption</a>
        <a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.singletonAccessor.declaredAccessor" title="Option[java.lang.reflect.Method]">declaredAccessor</a> <a href="../../Option.scala.html#scala;Option.orElse" title="(alternative: =&gt; Option[java.lang.reflect.Method])Option[java.lang.reflect.Method]">orElse</a> <a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.singletonAccessor" title="(clazz: Class[_])Option[java.lang.reflect.Method]">singletonAccessor</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.singletonAccessor.clazz" title="Class[_]">clazz</a>.<span title="()Class[_ &gt;: _$3]">getSuperclass</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    val accessor = <a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.singletonAccessor" title="(clazz: Class[_])Option[java.lang.reflect.Method]">singletonAccessor</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.outer" title="AnyRef">outer</a>.<span title="()Class[_]">getClass</span><span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Option.getOrElse" title="java.lang.reflect.Method" id="scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.accessor">getOrElse</a> <span class="delimiter">{</span> throw new <span title="NoSuchMethodException">NoSuchMethodException</span><span class="delimiter">(</span><a href="../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span><span class="delimiter">{</span><a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.outer" title="AnyRef">outer</a>.<span title="()Class[_]">getClass</span>.<span title="()String">getName</span><span class="delimiter">}</span><span title="String(&quot;.&quot;)">.$</span><a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.accessorName" title="String">accessorName</a><span title="String(&quot;&quot;)" class="string">&quot;</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.accessor" title="java.lang.reflect.Method">accessor</a> <span title="(x$1: Boolean)Unit">setAccessible</span> true
    <a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.accessor" title="java.lang.reflect.Method">accessor</a> <span title="(x$1: Any, x$2: Object*)Object">invoke</span> <a href="#scala.reflect.runtime.ReflectionUtils.innerSingletonInstance.outer" title="AnyRef">outer</a>
  <span class="delimiter">}</span>

  def <a title="(fileName: String)Boolean" id="scala.reflect.runtime.ReflectionUtils.isTraitImplementation">isTraitImplementation</a><span class="delimiter">(</span><a title="String" id="scala.reflect.runtime.ReflectionUtils.isTraitImplementation.fileName">fileName</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#scala.reflect.runtime.ReflectionUtils.isTraitImplementation.fileName" title="String">fileName</a> <span title="(x$1: String)Boolean">endsWith</span> <span title="String(&quot;$class.class&quot;)" class="string">&quot;$class.class&quot;</span>

  def <a title="(fileName: String)Boolean" id="scala.reflect.runtime.ReflectionUtils.scalacShouldntLoadClassfile">scalacShouldntLoadClassfile</a><span class="delimiter">(</span><a title="String" id="scala.reflect.runtime.ReflectionUtils.scalacShouldntLoadClassfile.fileName">fileName</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#scala.reflect.runtime.ReflectionUtils.isTraitImplementation" title="(fileName: String)Boolean">isTraitImplementation</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils.scalacShouldntLoadClassfile.fileName" title="String">fileName</a><span class="delimiter">)</span>

  def <a title="(name: scala.reflect.internal.SymbolTable#Name)Boolean" id="scala.reflect.runtime.ReflectionUtils.scalacShouldntLoadClass">scalacShouldntLoadClass</a><span class="delimiter">(</span><a title="scala.reflect.internal.SymbolTable#Name" id="scala.reflect.runtime.ReflectionUtils.scalacShouldntLoadClass.name">name</a>: scala.reflect.internal.SymbolTable#<a href="../internal/Names.scala.html#scala.reflect.internal;Names;Name" title="scala.reflect.internal.SymbolTable#Name">Name</a><span class="delimiter">)</span> = <a href="#scala.reflect.runtime.ReflectionUtils.scalacShouldntLoadClassfile" title="(fileName: String)Boolean">scalacShouldntLoadClassfile</a><span class="delimiter">(</span><a href="../../Predef.scala.html#scala.Predef.any2stringadd(6b32434ac5)" title="(self: scala.reflect.internal.SymbolTable#Name)any2stringadd[scala.reflect.internal.SymbolTable#Name]">name</a> <a href="../../Predef.scala.html#scala.Predef;any2stringadd.+" title="(other: String)String">+</a> <span title="String(&quot;.class&quot;)" class="string">&quot;.class&quot;</span><span class="delimiter">)</span>

  object <a title="scala.reflect.runtime.ReflectionUtils.PrimitiveOrArray.type" id="scala.reflect.runtime.ReflectionUtils.PrimitiveOrArray">PrimitiveOrArray</a> <a href="#scala.reflect.runtime.ReflectionUtils.PrimitiveOrArray" title="scala.reflect.runtime.ReflectionUtils.PrimitiveOrArray.type" class="delimiter">{</a>
    def <a title="(jclazz: Class[_])Boolean" id="scala.reflect.runtime.ReflectionUtils.PrimitiveOrArray.unapply">unapply</a><span class="delimiter">(</span><a title="Class[_]" id="scala.reflect.runtime.ReflectionUtils.PrimitiveOrArray.unapply.jclazz">jclazz</a>: <span title="Class[_]">jClass</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#scala.reflect.runtime.ReflectionUtils.PrimitiveOrArray.unapply.jclazz" title="Class[_]">jclazz</a>.<span title="()Boolean">isPrimitive</span> <a href="../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.reflect.runtime.ReflectionUtils.PrimitiveOrArray.unapply.jclazz" title="Class[_]">jclazz</a>.<span title="()Boolean">isArray</span>
  <span class="delimiter">}</span>

  class <a title="class EnclosedIn[T] extends AnyRef" id="scala.reflect.runtime.ReflectionUtils;EnclosedIn">EnclosedIn</a><span class="delimiter">[</span><a title="" id="scala.reflect.runtime.ReflectionUtils;EnclosedIn;T">T</a><span class="delimiter">]</span><a href="#scala.reflect.runtime.ReflectionUtils;EnclosedIn" title="scala.reflect.runtime.ReflectionUtils.EnclosedIn[T]" class="delimiter">(</a><a title="Class[_] =&gt; T" id="scala.reflect.runtime.ReflectionUtils;EnclosedIn.enclosure">enclosure</a>: jClass<span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; T<span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="(jclazz: Class[_])Option[T]" id="scala.reflect.runtime.ReflectionUtils;EnclosedIn.unapply">unapply</a><span class="delimiter">(</span><a title="Class[_]" id="scala.reflect.runtime.ReflectionUtils;EnclosedIn.unapply.jclazz">jclazz</a>: <span title="Class[_]">jClass</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../Option.scala.html#scala;Option" title="Option[T]">Option</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = if <span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Class[_])T">enclosure</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils;EnclosedIn.unapply.jclazz" title="Class[_]">jclazz</a><span class="delimiter">)</span> <span title="(x$1: Any)Boolean">!=</span> null<span class="delimiter">)</span> <a href="../../Option.scala.html#scala;Some" title="(x: T)Some[T]">Some</a><span class="delimiter">(</span><a href="../../Function1.scala.html#scala;Function1.apply" title="(v1: Class[_])T">enclosure</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils;EnclosedIn.unapply.jclazz" title="Class[_]">jclazz</a><span class="delimiter">)</span><span class="delimiter">)</span> else <a href="../../Option.scala.html#scala.None" title="None.type">None</a>
  <span class="delimiter">}</span>

  object <a title="scala.reflect.runtime.ReflectionUtils.EnclosedInMethod.type" id="scala.reflect.runtime.ReflectionUtils.EnclosedInMethod">EnclosedInMethod</a> extends <a href="#scala.reflect.runtime.ReflectionUtils;EnclosedIn" title="scala.reflect.runtime.ReflectionUtils.EnclosedIn[java.lang.reflect.Method]">EnclosedIn</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils;EnclosedInMethod.$anonfun.x$2" title="Class[_]">_</a>.<span title="()java.lang.reflect.Method">getEnclosingMethod</span><span class="delimiter">)</span>
  object <a title="scala.reflect.runtime.ReflectionUtils.EnclosedInConstructor.type" id="scala.reflect.runtime.ReflectionUtils.EnclosedInConstructor">EnclosedInConstructor</a> extends <a href="#scala.reflect.runtime.ReflectionUtils;EnclosedIn" title="scala.reflect.runtime.ReflectionUtils.EnclosedIn[java.lang.reflect.Constructor[_]]">EnclosedIn</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils;EnclosedInConstructor.$anonfun.x$3" title="Class[_]">_</a>.<span title="()java.lang.reflect.Constructor[_]">getEnclosingConstructor</span><span class="delimiter">)</span>
  object <a title="scala.reflect.runtime.ReflectionUtils.EnclosedInClass.type" id="scala.reflect.runtime.ReflectionUtils.EnclosedInClass">EnclosedInClass</a> extends <a href="#scala.reflect.runtime.ReflectionUtils;EnclosedIn" title="scala.reflect.runtime.ReflectionUtils.EnclosedIn[Class[_]]">EnclosedIn</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils;EnclosedInClass.$anonfun.x$4" title="Class[_]">_</a>.<span title="()Class[_]">getEnclosingClass</span><span class="delimiter">)</span>
  object <a title="scala.reflect.runtime.ReflectionUtils.EnclosedInPackage.type" id="scala.reflect.runtime.ReflectionUtils.EnclosedInPackage">EnclosedInPackage</a> extends <a href="#scala.reflect.runtime.ReflectionUtils;EnclosedIn" title="scala.reflect.runtime.ReflectionUtils.EnclosedIn[Package]">EnclosedIn</a><span class="delimiter">(</span><a href="#scala.reflect.runtime.ReflectionUtils;EnclosedInPackage.$anonfun.x$5" title="Class[_]">_</a>.<span title="()Package">getPackage</span><span class="delimiter">)</span>

  def <a title="(clazz: Class[_])scala.reflect.io.AbstractFile" id="scala.reflect.runtime.ReflectionUtils.associatedFile">associatedFile</a><span class="delimiter">(</span><a title="Class[_]" id="scala.reflect.runtime.ReflectionUtils.associatedFile.clazz">clazz</a>: <span title="Class[_]">Class</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../io/AbstractFile.scala.html#scala.reflect.io;AbstractFile" title="scala.reflect.io.AbstractFile">AbstractFile</a> = <span class="delimiter">{</span>
    <span class="comment">// TODO: I agree with Jason - this implementation isn't something that we'd like to support</span>
    <span class="comment">// therefore I'm having it commented out and this function will now return NoAbstractFile</span>
    <span class="comment">// I think we can keep the source code though, because it can be useful to the others</span>
    <span class="comment">//</span>
    <span class="comment">// def inferAssociatedFile(clazz: Class[_]): AbstractFile = {</span>
    <span class="comment">//   // http://stackoverflow.com/questions/227486/find-where-java-class-is-loaded-from</span>
    <span class="comment">//   try {</span>
    <span class="comment">//     var cl = clazz.getClassLoader()</span>
    <span class="comment">//     if (cl == null) {</span>
    <span class="comment">//       cl = ClassLoader.getSystemClassLoader()</span>
    <span class="comment">//       while (cl != null &amp;&amp; cl.getParent != null) cl = cl.getParent</span>
    <span class="comment">//     }</span>
    <span class="comment">//     var result: AbstractFile = null</span>
    <span class="comment">//     if (cl != null) {</span>
    <span class="comment">//       val name = clazz.getCanonicalName()</span>
    <span class="comment">//       val resource = cl.getResource(name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;)</span>
    <span class="comment">//       if (resource != null) {</span>
    <span class="comment">//         def fromFile(file: String) = AbstractFile.getFile(file)</span>
    <span class="comment">//         def fromJarEntry(jarfile: String, entrypath: String) = {</span>
    <span class="comment">//           val jar = fromFile(jarfile)</span>
    <span class="comment">//           new VirtualFile(clazz.getName, entrypath) {</span>
    <span class="comment">//             lazy val impl: AbstractFile = {</span>
    <span class="comment">//               def loop(root: AbstractFile, path: List[String]): AbstractFile = {</span>
    <span class="comment">//                 def find(name: String) = root.iterator.find(_.name == name).getOrElse(NoAbstractFile)</span>
    <span class="comment">//                 path match {</span>
    <span class="comment">//                   case step :: Nil =&gt; find(step)</span>
    <span class="comment">//                   case step :: rest =&gt; loop(find(step), rest)</span>
    <span class="comment">//                   case Nil =&gt; NoAbstractFile</span>
    <span class="comment">//                 }</span>
    <span class="comment">//               }</span>
    <span class="comment">//               loop(ZipArchive.fromFile(new JFile(jarfile)), entrypath.split(&quot;/&quot;).toList)</span>
    <span class="comment">//             }</span>
    <span class="comment">//             override def container        = impl.container</span>
    <span class="comment">//             override def lastModified     = impl.lastModified</span>
    <span class="comment">//             override def input            = impl.input</span>
    <span class="comment">//             override def sizeOption       = impl.sizeOption</span>
    <span class="comment">//             override def underlyingSource = Some(jar)</span>
    <span class="comment">//             override def toString         = jarfile + &quot;(&quot; + entrypath + &quot;)&quot;</span>
    <span class="comment">//           }</span>
    <span class="comment">//         }</span>
    <span class="comment">//         def fallback() = new VirtualFile(clazz.getName, resource.toString)</span>
    <span class="comment">//         result = resource.getProtocol match {</span>
    <span class="comment">//           case &quot;file&quot; =&gt;</span>
    <span class="comment">//             fromFile(resource.getFile)</span>
    <span class="comment">//           case &quot;jar&quot; =&gt;</span>
    <span class="comment">//             val intrajarUrl = new java.net.URL(resource.getFile)</span>
    <span class="comment">//             intrajarUrl.getProtocol match {</span>
    <span class="comment">//               case &quot;file&quot; =&gt;</span>
    <span class="comment">//                 val file = intrajarUrl.getFile()</span>
    <span class="comment">//                 val expectedSuffix = &quot;!/&quot; + name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;</span>
    <span class="comment">//                 if (file.endsWith(expectedSuffix)) fromJarEntry(file.stripSuffix(expectedSuffix), expectedSuffix.substring(2))</span>
    <span class="comment">//                 else fallback()</span>
    <span class="comment">//               case _ =&gt; fallback()</span>
    <span class="comment">//             }</span>
    <span class="comment">//           case _ =&gt;</span>
    <span class="comment">//             fallback()</span>
    <span class="comment">//         }</span>
    <span class="comment">//       }</span>
    <span class="comment">//     }</span>
    <span class="comment">//     if (result != null) result else NoAbstractFile</span>
    <span class="comment">//   } catch {</span>
    <span class="comment">//     case _: Exception =&gt; NoAbstractFile</span>
    <span class="comment">//   }</span>
    <span class="comment">// }</span>
    <span class="comment">// inferAssociatedFile(clazz)</span>
    <a href="../io/NoAbstractFile.scala.html#scala.reflect.io.NoAbstractFile" title="scala.reflect.io.NoAbstractFile.type">NoAbstractFile</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>
