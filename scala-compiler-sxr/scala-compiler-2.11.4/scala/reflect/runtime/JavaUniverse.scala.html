<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/reflect/runtime/JavaUniverse.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scala
package reflect
package runtime

import scala.reflect.internal.<span class="delimiter">{</span>TreeInfo, SomePhase<span class="delimiter">}</span>
import scala.reflect.internal.<span class="delimiter">{</span>SymbolTable =&gt; InternalSymbolTable<span class="delimiter">}</span>
import scala.reflect.runtime.<span class="delimiter">{</span>SymbolTable =&gt; RuntimeSymbolTable<span class="delimiter">}</span>
import scala.reflect.api.<span class="delimiter">{</span>TreeCreator, TypeCreator, Universe<span class="delimiter">}</span>

<span class="comment">/** An implementation of [[scala.reflect.api.Universe]] for runtime reflection using JVM classloaders.
 *
 *  Should not be instantiated directly, use [[scala.reflect.runtime.universe]] instead.
 *
 *  @contentDiagram hideNodes &quot;*Api&quot; &quot;*Extractor&quot;
 */</span>
class <a title="class JavaUniverse extends scala.reflect.internal.SymbolTable with scala.reflect.runtime.JavaUniverseForce with scala.reflect.runtime.ReflectSetup with scala.reflect.runtime.SymbolTable" id="scala.reflect.runtime;JavaUniverse">JavaUniverse</a> extends <a href="../internal/SymbolTable.scala.html#scala.reflect.internal;SymbolTable" title="scala.reflect.internal.SymbolTable">InternalSymbolTable</a> with <a href="JavaUniverseForce.scala.html#scala.reflect.runtime;JavaUniverseForce" title="scala.reflect.runtime.JavaUniverseForce">JavaUniverseForce</a> with <a href="ReflectSetup.scala.html#scala.reflect.runtime;ReflectSetup" title="scala.reflect.runtime.ReflectSetup">ReflectSetup</a> with <a href="SymbolTable.scala.html#scala.reflect.runtime;SymbolTable" title="scala.reflect.runtime.SymbolTable">RuntimeSymbolTable</a> <span class="delimiter">{</span> self =&gt;
  def <a title="=&gt; scala.reflect.internal.SomePhase.type" id="scala.reflect.runtime;JavaUniverse.picklerPhase">picklerPhase</a> = <a href="../internal/Phase.scala.html#scala.reflect.internal.SomePhase" title="scala.reflect.internal.SomePhase.type">SomePhase</a>
  def <a title="=&gt; scala.reflect.internal.SomePhase.type" id="scala.reflect.runtime;JavaUniverse.erasurePhase">erasurePhase</a> = <a href="../internal/Phase.scala.html#scala.reflect.internal.SomePhase" title="scala.reflect.internal.SomePhase.type">SomePhase</a>
  lazy val <a title="scala.reflect.runtime.Settings" id="scala.reflect.runtime;JavaUniverse.settings">settings</a> = new <a href="Settings.scala.html#scala.reflect.runtime;Settings" title="scala.reflect.runtime.Settings">Settings</a>

  private val isLogging = sys.<a href="../../sys/package.scala.html#scala.sys.package.props" title="=&gt; scala.sys.SystemProperties">props</a> <a href="../../sys/SystemProperties.scala.html#scala.sys;SystemProperties.contains" title="Boolean" id="scala.reflect.runtime;JavaUniverse.isLogging">contains</a> <span title="String(&quot;scala.debug.reflect&quot;)" class="string">&quot;scala.debug.reflect&quot;</span>
  def <a title="(msg: =&gt; AnyRef)Unit" id="scala.reflect.runtime;JavaUniverse.log">log</a><span class="delimiter">(</span><a title="=&gt; AnyRef" id="scala.reflect.runtime;JavaUniverse.log.msg">msg</a>: =&gt; AnyRef<span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = if <span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse.isLogging" title="=&gt; Boolean">isLogging</a><span class="delimiter">)</span> <a href="../../Console.scala.html#scala.Console" title="Console.type">Console</a>.<a href="../../Console.scala.html#scala.Console.err" title="=&gt; java.io.PrintStream">err</a>.<span title="(x$1: String)Unit">println</span><span class="delimiter">(</span><span title="String(&quot;[reflect] &quot;)" class="string">&quot;[reflect] &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.reflect.runtime;JavaUniverse.log.msg" title="=&gt; AnyRef">msg</a><span class="delimiter">)</span>

  <span class="comment">// TODO: why put output under isLogging? Calls to inform are already conditional on debug/verbose/...</span>
  import scala.reflect.internal.<span class="delimiter">{</span>Reporter, ReporterImpl<span class="delimiter">}</span>
  override def <a title="=&gt; scala.reflect.internal.Reporter" id="scala.reflect.runtime;JavaUniverse.reporter">reporter</a>: <a href="../internal/Reporting.scala.html#scala.reflect.internal;Reporter" title="scala.reflect.internal.Reporter">Reporter</a> = new <a href="../internal/Reporting.scala.html#scala.reflect.internal;ReporterImpl" title="&lt;$anon: scala.reflect.internal.ReporterImpl&gt; extends scala.reflect.internal.ReporterImpl" id="scala.reflect.runtime;JavaUniverse.reporter;$anon">ReporterImpl</a> <span class="delimiter">{</span>
    protected def <a title="(pos: JavaUniverse.this.Position, msg: String, severity: this.Severity, force: Boolean)Unit" id="scala.reflect.runtime;JavaUniverse.reporter;$anon.info0">info0</a><span class="delimiter">(</span><a title="JavaUniverse.this.Position" id="scala.reflect.runtime;JavaUniverse.reporter;$anon.info0.pos">pos</a>: <a href="../internal/util/Position.scala.html#scala.reflect.internal.util;Position" title="JavaUniverse.this.Position">Position</a>, <a title="String" id="scala.reflect.runtime;JavaUniverse.reporter;$anon.info0.msg">msg</a>: <span title="String">String</span>, <a title="this.Severity" id="scala.reflect.runtime;JavaUniverse.reporter;$anon.info0.severity">severity</a>: <a href="../internal/Reporting.scala.html#scala.reflect.internal;ReporterImpl;Severity" title="this.Severity">Severity</a>, <a title="Boolean" id="scala.reflect.runtime;JavaUniverse.reporter;$anon.info0.force">force</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <a href="#scala.reflect.runtime;JavaUniverse.log" title="(msg: =&gt; AnyRef)Unit">log</a><span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse.reporter;$anon.info0.msg" title="String">msg</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// minimal Run to get Reporting wired</span>
  def <a title="=&gt; JavaUniverse.this.RunReporting" id="scala.reflect.runtime;JavaUniverse.currentRun">currentRun</a> = new <a title="&lt;$anon: JavaUniverse.this.RunReporting&gt; extends AnyRef with JavaUniverse.this.RunReporting" id="scala.reflect.runtime;JavaUniverse.currentRun;$anon">RunReporting</a> <span class="delimiter">{</span><span class="delimiter">}</span>
  class <a title="class PerRunReporting extends JavaUniverse.this.PerRunReportingBase" id="scala.reflect.runtime;JavaUniverse;PerRunReporting">PerRunReporting</a> extends <a href="../internal/Reporting.scala.html#scala.reflect.internal;Reporting;PerRunReportingBase" title="JavaUniverse.this.PerRunReportingBase">PerRunReportingBase</a> <span class="delimiter">{</span>
    def <a title="(pos: JavaUniverse.this.Position, msg: String)Unit" id="scala.reflect.runtime;JavaUniverse;PerRunReporting.deprecationWarning">deprecationWarning</a><span class="delimiter">(</span><a title="JavaUniverse.this.Position" id="scala.reflect.runtime;JavaUniverse;PerRunReporting.deprecationWarning.pos">pos</a>: <a href="../internal/util/Position.scala.html#scala.reflect.internal.util;Position" title="JavaUniverse.this.Position">Position</a>, <a title="String" id="scala.reflect.runtime;JavaUniverse;PerRunReporting.deprecationWarning.msg">msg</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <a href="#scala.reflect.runtime;JavaUniverse.reporter" title="=&gt; scala.reflect.internal.Reporter">reporter</a>.<a href="../internal/Reporting.scala.html#scala.reflect.internal;Reporter.warning" title="(pos: scala.reflect.internal.util.Position, msg: String)Unit">warning</a><span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse;PerRunReporting.deprecationWarning.pos" title="JavaUniverse.this.Position">pos</a>, <a href="#scala.reflect.runtime;JavaUniverse;PerRunReporting.deprecationWarning.msg" title="String">msg</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  protected def <a title="=&gt; JavaUniverse.this.PerRunReporting" id="scala.reflect.runtime;JavaUniverse.PerRunReporting">PerRunReporting</a> = new <a href="#scala.reflect.runtime;JavaUniverse;PerRunReporting" title="JavaUniverse.this.PerRunReporting">PerRunReporting</a>


  type <a title="JavaUniverse.this.InternalTreeCopierOps" id="scala.reflect.runtime;JavaUniverse;TreeCopier">TreeCopier</a> = <a href="../internal/Trees.scala.html#scala.reflect.internal;Trees;InternalTreeCopierOps" title="JavaUniverse.this.InternalTreeCopierOps">InternalTreeCopierOps</a>
  implicit val <a title="scala.reflect.ClassTag[JavaUniverse.this.TreeCopier]" id="scala.reflect.runtime;JavaUniverse.TreeCopierTag">TreeCopierTag</a>: <a href="../ClassTag.scala.html#scala.reflect;ClassTag" title="scala.reflect.ClassTag[JavaUniverse.this.TreeCopier]">ClassTag</a><span class="delimiter">[</span>TreeCopier<span class="delimiter">]</span> = <a href="../ClassTag.scala.html#scala.reflect.ClassTag.apply" title="[T](runtimeClass1: Class[_])scala.reflect.ClassTag[T]">ClassTag</a><span title="(runtimeClass1: Class[_])scala.reflect.ClassTag[JavaUniverse.this.TreeCopier]" class="delimiter">[</span><a href="../internal/Trees.scala.html#scala.reflect.internal;Trees;InternalTreeCopierOps" title="JavaUniverse.this.TreeCopier">TreeCopier</a><span class="delimiter">]</span><span class="delimiter">(</span>classOf<span title="Class[JavaUniverse.this.TreeCopier](classOf[scala.reflect.internal.Trees$InternalTreeCopierOps])" class="delimiter">[</span>TreeCopier<span class="delimiter">]</span><span class="delimiter">)</span>
  def <a title="=&gt; JavaUniverse.this.TreeCopier" id="scala.reflect.runtime;JavaUniverse.newStrictTreeCopier">newStrictTreeCopier</a>: <a href="../internal/Trees.scala.html#scala.reflect.internal;Trees;InternalTreeCopierOps" title="JavaUniverse.this.TreeCopier">TreeCopier</a> = new <a href="../internal/Trees.scala.html#scala.reflect.internal;Trees;StrictTreeCopier" title="JavaUniverse.this.StrictTreeCopier">StrictTreeCopier</a>
  def <a title="=&gt; JavaUniverse.this.TreeCopier" id="scala.reflect.runtime;JavaUniverse.newLazyTreeCopier">newLazyTreeCopier</a>: <a href="../internal/Trees.scala.html#scala.reflect.internal;Trees;InternalTreeCopierOps" title="JavaUniverse.this.TreeCopier">TreeCopier</a> = new <a href="../internal/Trees.scala.html#scala.reflect.internal;Trees;LazyTreeCopier" title="JavaUniverse.this.LazyTreeCopier">LazyTreeCopier</a>

  def <a title="=&gt; scala.reflect.internal.util.FreshNameCreator" id="scala.reflect.runtime;JavaUniverse.currentFreshNameCreator">currentFreshNameCreator</a> = <a href="../internal/FreshNames.scala.html#scala.reflect.internal;FreshNames.globalFreshNameCreator" title="=&gt; scala.reflect.internal.util.FreshNameCreator">globalFreshNameCreator</a>

  override lazy val <a title="JavaUniverse.this.Internal" id="scala.reflect.runtime;JavaUniverse.internal">internal</a>: <a href="../macros/Universe.scala.html#scala.reflect.macros;Universe;MacroInternalApi" title="JavaUniverse.this.Internal">Internal</a> = new <a title="&lt;$anon: JavaUniverse.this.SymbolTableInternal&gt; extends AnyRef with JavaUniverse.this.SymbolTableInternal" id="scala.reflect.runtime;JavaUniverse.internal;$anon">SymbolTableInternal</a> <span class="delimiter">{</span>
    override def <a title="[T](mirror0: Any, tag: scala.reflect.api.Universe#TypeTag[T])(implicit evidence$1: scala.reflect.ClassTag[T])scala.reflect.Manifest[T]" id="scala.reflect.runtime;JavaUniverse.internal;$anon.typeTagToManifest">typeTagToManifest</a><span class="delimiter">[</span><a title="" id="scala.reflect.runtime;JavaUniverse.internal;$anon.typeTagToManifest;T">T</a>: ClassTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="Any" id="scala.reflect.runtime;JavaUniverse.internal;$anon.typeTagToManifest.mirror0">mirror0</a>: <span title="Any">Any</span>, <a title="scala.reflect.api.Universe#TypeTag[T]" id="scala.reflect.runtime;JavaUniverse.internal;$anon.typeTagToManifest.tag">tag</a>: Universe # <a href="../api/TypeTags.scala.html#scala.reflect.api;TypeTags;TypeTag" title="scala.reflect.api.Universe#TypeTag[T]">TypeTag</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Manifest.scala.html#scala.reflect;Manifest" title="scala.reflect.Manifest[T]">Manifest</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="comment">// SI-6239: make this conversion more precise</span>
      val <a title="JavaUniverse.this.Mirror" id="scala.reflect.runtime;JavaUniverse.internal;$anon.typeTagToManifest.mirror">mirror</a> = <a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.typeTagToManifest.mirror0" title="Any">mirror0</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="JavaUniverse.this.Mirror" class="delimiter">[</span><a href="JavaMirrors.scala.html#scala.reflect.runtime;JavaMirrors;JavaMirror" title="JavaUniverse.this.Mirror">Mirror</a><span class="delimiter">]</span>
      val <a title="Class[_]" id="scala.reflect.runtime;JavaUniverse.internal;$anon.typeTagToManifest.runtimeClass">runtimeClass</a> = <a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.typeTagToManifest.mirror" title="JavaUniverse.this.Mirror">mirror</a>.<a href="JavaMirrors.scala.html#scala.reflect.runtime;JavaMirrors;JavaMirror.runtimeClass(33ce1982b0)" title="(tpe: JavaUniverse.this.Type)JavaUniverse.this.RuntimeClass">runtimeClass</a><span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.typeTagToManifest.tag" title="scala.reflect.api.Universe#TypeTag[T]">tag</a>.<a href="../api/TypeTags.scala.html#scala.reflect.api;TypeTags;TypeTag.in" title="(otherMirror: scala.reflect.api.Mirror[JavaUniverse.this.type])JavaUniverse.this.TypeTag[T]">in</a><span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.typeTagToManifest.mirror" title="JavaUniverse.this.Mirror">mirror</a><span class="delimiter">)</span>.<a href="../api/TypeTags.scala.html#scala.reflect.api;TypeTags;WeakTypeTag.tpe" title="=&gt; JavaUniverse.this.Type">tpe</a><span class="delimiter">)</span>
      <a href="../package.scala.html#scala.reflect.package.Manifest" title="=&gt; scala.reflect.ManifestFactory.type">Manifest</a>.<a href="../Manifest.scala.html#scala.reflect.ManifestFactory.classType(c5d5ecdf5c)" title="(clazz: Class[_])scala.reflect.Manifest[Nothing]">classType</a><span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.typeTagToManifest.runtimeClass" title="Class[_]">runtimeClass</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="scala.reflect.Manifest[T]" class="delimiter">[</span><a href="../Manifest.scala.html#scala.reflect;Manifest" title="scala.reflect.Manifest[T]">Manifest</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="delimiter">}</span>
    override def <a title="[T](mirror0: Any, manifest: scala.reflect.Manifest[T])scala.reflect.api.Universe#TypeTag[T]" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag">manifestToTypeTag</a><span class="delimiter">[</span><a title="" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Any" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag.mirror0">mirror0</a>: <span title="Any">Any</span>, <a title="scala.reflect.Manifest[T]" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag.manifest">manifest</a>: <a href="../Manifest.scala.html#scala.reflect;Manifest" title="scala.reflect.Manifest[T]">Manifest</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: Universe # <a href="../api/TypeTags.scala.html#scala.reflect.api;TypeTags;TypeTag" title="scala.reflect.api.Universe#TypeTag[T]">TypeTag</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
      <a href="../api/TypeTags.scala.html#scala.reflect.api;TypeTags.TypeTag.apply" title="(mirror1: scala.reflect.api.Mirror[JavaUniverse.this.type], tpec1: scala.reflect.api.TypeCreator)JavaUniverse.this.TypeTag[T]">TypeTag</a><span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag.mirror0" title="Any">mirror0</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="JavaUniverse.this.Mirror" class="delimiter">[</span><a href="JavaMirrors.scala.html#scala.reflect.runtime;JavaMirrors;JavaMirror" title="JavaUniverse.this.Mirror">Mirror</a><span class="delimiter">]</span>, new <a href="../api/TypeCreator.scala.html#scala.reflect.api;TypeCreator" title="&lt;$anon: scala.reflect.api.TypeCreator&gt; extends scala.reflect.api.TypeCreator" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon">TypeCreator</a> <span class="delimiter">{</span>
        def <a title="[U &lt;: scala.reflect.api.Universe with Singleton](mirror: scala.reflect.api.Mirror[U])U#Type" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply">apply</a><span class="delimiter">[</span><a title=" &lt;: scala.reflect.api.Universe with Singleton" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply;U">U</a> &lt;: Universe with Singleton<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.api.Mirror[U]" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.mirror">mirror</a>: scala.reflect.api.<a href="../api/Mirror.scala.html#scala.reflect.api;Mirror" title="scala.reflect.api.Mirror[U]">Mirror</a><span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: U # <a href="../api/Types.scala.html#scala.reflect.api;Types;Type" title="U#Type">Type</a> = <span class="delimiter">{</span>
          <a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.mirror" title="scala.reflect.api.Mirror[U]">mirror</a>.<a href="../api/Mirror.scala.html#scala.reflect.api;Mirror.universe" title="=&gt; U">universe</a> match <span class="delimiter">{</span>
            case <a title="&lt;refinement of scala.reflect.api.Universe with Singleton with scala.reflect.runtime.JavaUniverse&gt; extends scala.reflect.api.Universe with Singleton with scala.reflect.runtime.JavaUniverse" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.ju">ju</a>: <a href="#scala.reflect.runtime;JavaUniverse" title="scala.reflect.runtime.JavaUniverse">JavaUniverse</a> =&gt;
              val <a title="ju.Mirror" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.jm">jm</a> = <a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.mirror" title="scala.reflect.api.Mirror[U]">mirror</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="ju.Mirror" class="delimiter">[</span>ju.<a href="JavaMirrors.scala.html#scala.reflect.runtime;JavaMirrors;JavaMirror" title="ju.Mirror">Mirror</a><span class="delimiter">]</span>
              val <a title="ju.ClassSymbol" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.sym">sym</a> = <a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.jm" title="ju.Mirror">jm</a>.<a href="JavaMirrors.scala.html#scala.reflect.runtime;JavaMirrors;JavaMirror.classSymbol" title="(rtcls: ju.RuntimeClass)ju.ClassSymbol">classSymbol</a><span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag.manifest" title="scala.reflect.Manifest[T]">manifest</a>.<a href="../ClassTag.scala.html#scala.reflect;ClassTag.runtimeClass" title="=&gt; Class[_]">runtimeClass</a><span class="delimiter">)</span>
              val <a title="ju.Type" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.tpe">tpe</a> =
                if <span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag.manifest" title="scala.reflect.Manifest[T]">manifest</a>.<a href="../Manifest.scala.html#scala.reflect;Manifest.typeArguments" title="=&gt; List[scala.reflect.Manifest[_]]">typeArguments</a>.<a href="../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.sym" title="ju.ClassSymbol">sym</a>.<a href="../internal/Symbols.scala.html#scala.reflect.internal;Symbols;SymbolContextApiImpl.toType" title="=&gt; ju.Type">toType</a>
                else <span class="delimiter">{</span>
                  val tags = <a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag.manifest" title="scala.reflect.Manifest[T]">manifest</a>.<a href="../Manifest.scala.html#scala.reflect;Manifest.typeArguments" title="=&gt; List[scala.reflect.Manifest[_]]">typeArguments</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="List[scala.reflect.api.Universe#TypeTag[_]]" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.tpe.tags">map</a> <span class="delimiter">(</span><a title="scala.reflect.Manifest[_]" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.tpe.tags.$anonfun.targ">targ</a> =&gt; <a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.ju" title="&lt;refinement of scala.reflect.api.Universe with Singleton with scala.reflect.runtime.JavaUniverse&gt; extends scala.reflect.api.Universe with Singleton with scala.reflect.runtime.JavaUniverse">ju</a>.<a href="#scala.reflect.runtime;JavaUniverse.internal" title="=&gt; ju.Internal">internal</a>.<a href="../api/Internals.scala.html#scala.reflect.api;Internals;InternalApi.manifestToTypeTag" title="(mirror: Any, manifest: scala.reflect.Manifest[_$1])scala.reflect.api.Universe#TypeTag[_$1]">manifestToTypeTag</a><span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.jm" title="ju.Mirror">jm</a>, <a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.tpe.tags.$anonfun.targ" title="scala.reflect.Manifest[_]">targ</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  <a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.ju" title="&lt;refinement of scala.reflect.api.Universe with Singleton with scala.reflect.runtime.JavaUniverse&gt; extends scala.reflect.api.Universe with Singleton with scala.reflect.runtime.JavaUniverse">ju</a>.<a href="../internal/Types.scala.html#scala.reflect.internal;Types.appliedType(c7fb433f73)" title="(tycon: ju.Type, args: List[ju.Type])ju.Type">appliedType</a><span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.sym" title="ju.ClassSymbol">sym</a>.<a href="../internal/Symbols.scala.html#scala.reflect.internal;Symbols;SymbolContextApiImpl.toTypeConstructor" title="=&gt; ju.Type">toTypeConstructor</a>, <a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.tpe.tags" title="List[scala.reflect.api.Universe#TypeTag[_]]">tags</a> <a href="../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: scala.reflect.api.Universe#TypeTag[_] =&gt; ju.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[scala.reflect.api.Universe#TypeTag[_]],ju.Type,List[ju.Type]])List[ju.Type]">map</a> <span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.tpe.$anonfun.x$1" title="scala.reflect.api.Universe#TypeTag[_]">_</a>.<a href="../api/TypeTags.scala.html#scala.reflect.api;TypeTags;TypeTag.in" title="(otherMirror: scala.reflect.api.Mirror[scala.&lt;refinement&gt;.type])ju.TypeTag[_$1]">in</a><span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.jm" title="ju.Mirror">jm</a><span class="delimiter">)</span>.<a href="../api/TypeTags.scala.html#scala.reflect.api;TypeTags;WeakTypeTag.tpe" title="=&gt; ju.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="delimiter">}</span>
              <a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.tpe" title="ju.Type">tpe</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="U#Type" class="delimiter">[</span>U # <a href="../api/Types.scala.html#scala.reflect.api;Types;Type" title="U#Type">Type</a><span class="delimiter">]</span>
            case <a title="U" id="scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.u">u</a> =&gt;
              <a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.u" title="U">u</a>.<a href="../api/Internals.scala.html#scala.reflect.api;Internals.internal" title="=&gt; u.Internal">internal</a>.<a href="../api/Internals.scala.html#scala.reflect.api;Internals;InternalApi.manifestToTypeTag" title="(mirror: Any, manifest: scala.reflect.Manifest[T])scala.reflect.api.Universe#TypeTag[T]">manifestToTypeTag</a><span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.mirror" title="scala.reflect.api.Mirror[U]">mirror</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="u.Mirror" class="delimiter">[</span>u.<a href="../api/Mirrors.scala.html#scala.reflect.api;Mirrors;Mirror" title="u.Mirror">Mirror</a><span class="delimiter">]</span>, <a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag.manifest" title="scala.reflect.Manifest[T]">manifest</a><span class="delimiter">)</span>.<a href="../api/TypeTags.scala.html#scala.reflect.api;TypeTags;TypeTag.in" title="(otherMirror: scala.reflect.api.Mirror[U])U#TypeTag[T]">in</a><span class="delimiter">(</span><a href="#scala.reflect.runtime;JavaUniverse.internal;$anon.manifestToTypeTag;$anon.apply.mirror" title="scala.reflect.api.Mirror[U]">mirror</a><span class="delimiter">)</span>.<a href="../api/TypeTags.scala.html#scala.reflect.api;TypeTags;WeakTypeTag.tpe" title="=&gt; U#Type">tpe</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// can't put this in runtime.Trees since that's mixed with Global in ReflectGlobal, which has the definition from internal.Trees</span>
  object <a title="JavaUniverse.this.treeInfo.type" id="scala.reflect.runtime;JavaUniverse.treeInfo">treeInfo</a> extends <span class="delimiter">{</span>
    val <a title="JavaUniverse.this.type" id="scala.reflect.runtime;JavaUniverse;treeInfo.global">global</a>: JavaUniverse.this.type = <a href="#scala.reflect.runtime;JavaUniverse" title="JavaUniverse.this.type">JavaUniverse</a>.this
  <span class="delimiter">}</span> with <a href="../internal/TreeInfo.scala.html#scala.reflect.internal;TreeInfo" title="scala.reflect.internal.TreeInfo">TreeInfo</a>

  <a href="#scala.reflect.runtime;JavaUniverse.init" title="()Unit">init</a><span class="delimiter">(</span><span class="delimiter">)</span>

  <span class="comment">// ======= Initialization of runtime reflection =======</span>
  <span class="comment">//</span>
  <span class="comment">// This doc describes the carefully laid out sequence of actions used to initialize reflective universes.</span>
  <span class="comment">//</span>
  <span class="comment">// Before reading the text below, read up the section Mirrors in the reflection pre-SIP</span>
  <span class="comment">// https://docs.google.com/document/d/1nAwSw4TmMplsIlzh2shYLUJ5mVh3wndDa1Zm1H6an9A/edit.</span>
  <span class="comment">// Take an especially good look at Figure 2, because it illustrates fundamental principles underlying runtime reflection:</span>
  <span class="comment">//   1) For each universe we have one mirror per classloader</span>
  <span class="comment">//   2) Package symbols are per-mirror</span>
  <span class="comment">//   3) Other symbols are per-universe, which means that a symbol (e.g. Seq on the picture) might be shared between multiple owners</span>
  <span class="comment">//</span>
  <span class="comment">// Main challenges that runtime reflection presents wrt initialization are:</span>
  <span class="comment">//   1) Extravagant completion scheme that enters package members on-demand rather than a result of scanning a directory with class files.</span>
  <span class="comment">//      (That's a direct consequence of the fact that in general case we can't enumerate all classes in a classloader.</span>
  <span class="comment">//      As Paul rightfully mentioned, we could specialcase classloaders that point to filesystems, but that is left for future work).</span>
  <span class="comment">//   2) Presence of synthetic symbols that aren't loaded by normal means (from classfiles) but are synthesized on-the-fly,</span>
  <span class="comment">//      and the necessity to propagate these synthetic symbols from rootMirror to other mirrors,</span>
  <span class="comment">//      complicated by the fact that such symbols depend on normal symbols (e.g. AnyRef depends on Object).</span>
  <span class="comment">//   3) Necessity to remain thread-safe, which limits our options related to lazy initialization</span>
  <span class="comment">//      (E.g. we cannot use missingHook to enter synthetic symbols, because that's thread-unsafe).</span>
  <span class="comment">//</span>
  <span class="comment">// Directly addressing the challenge #3, we create all synthetic symbols fully in advance during init().</span>
  <span class="comment">// However, it's not that simple as just calling definitions.symbolsNotPresentInBytecode.</span>
  <span class="comment">// Before doing that, we need to first initialize ObjectClass, then ScalaPackageClass, and only then deal with synthetics.</span>
  <span class="comment">// Below you can find a detailed explanation for that.</span>
  <span class="comment">//</span>
  <span class="comment">// ### Why ScalaPackageClass? ###</span>
  <span class="comment">//</span>
  <span class="comment">// Forcing ScalaPackageClass first thing during startup is important, because syntheticCoreClasses such as AnyRefClass</span>
  <span class="comment">// need to be entered into ScalaPackageClass, which entails calling ScalaPackageClass.info.decls.enter.</span>
  <span class="comment">// If ScalaPackageClass isn't initialized by that moment, the following will happen for runtime reflection:</span>
  <span class="comment">//   1) Initialization of ScalaPackageClass will trigger unpickling.</span>
  <span class="comment">//   2) Unpickling will need to load some auxiliary types such as, for example, String.</span>
  <span class="comment">//   3) To load String, runtime reflection will call mirrorDefining(classOf[String]).</span>
  <span class="comment">//   4) This, in turn, will call runtimeMirror(classOf[String].getClassLoader).</span>
  <span class="comment">//   5) For some classloader configurations, the resulting mirror will be different from rootMirror.</span>
  <span class="comment">//   6) In that case, initialization of the resulting mirror will try to import definitions.syntheticCoreClasses into the mirror.</span>
  <span class="comment">//   7) This will force all the lazy vals corresponding to syntheticCoreClasses.</span>
  <span class="comment">//   8) By that time, the completer of ScalaPackageClass will have already called setInfo on ScalaPackageClass, so there won't be any stack overflow.</span>
  <span class="comment">//</span>
  <span class="comment">// So far so good, no crashes, no problems, right? Not quite.</span>
  <span class="comment">// If forcing of ScalaPackageClass was called by a syntheticCoreClasses lazy val,</span>
  <span class="comment">// then this lazy val will be entered twice: once during step 7 and once when returning from the original call.</span>
  <span class="comment">// To avoid this we need to initialize ScalaPackageClass prior to other synthetics.</span>
  <span class="comment">//</span>
  <span class="comment">// ### Why ObjectClass? ###</span>
  <span class="comment">//</span>
  <span class="comment">// 1) As explained in JavaMirrors.missingHook, initialization of ScalaPackageClass critically depends on AnyRefClass.</span>
  <span class="comment">// 2) AnyRefClass is defined as &quot;lazy val AnyRefClass = newAlias(ScalaPackageClass, tpnme.AnyRef, ObjectTpe)&quot;,</span>
  <span class="comment">//    which means that initialization of AnyRefClass depends on ObjectClass.</span>
  <span class="comment">// 3) ObjectClass is defined as &quot;lazy val ObjectClass = getRequiredClass(sn.Object.toString)&quot;,</span>
  <span class="comment">//    which means that under some classloader configurations (see JavaMirrors.missingHook for more details)</span>
  <span class="comment">//    dereferencing ObjectClass might trigger an avalanche of initializations calling back into AnyRefClass</span>
  <span class="comment">//    while another AnyRefClass initializer is still on stack.</span>
  <span class="comment">// 4) That will lead to AnyRefClass being entered two times (once when the recursive call returns and once when the original one returns)</span>
  <span class="comment">// 5) That will crash PackageScope.enter that helpfully detects double-enters.</span>
  <span class="comment">//</span>
  <span class="comment">// Therefore, before initializing ScalaPackageClass, we must pre-initialize ObjectClass</span>
  def <a title="()Unit" id="scala.reflect.runtime;JavaUniverse.init">init</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../internal/Definitions.scala.html#scala.reflect.internal;Definitions.definitions" title="JavaUniverse.this.definitions.type">definitions</a>.<a href="../internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.init" title="()Unit">init</a><span class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">// workaround for http://groups.google.com/group/scala-internals/browse_thread/thread/97840ba4fd37b52e</span>
    <span class="comment">// constructors are by definition single-threaded, so we initialize all lazy vals (and local object) in advance</span>
    <span class="comment">// in order to avoid deadlocks later (e.g. one thread holds a global reflection lock and waits for definitions.Something to initialize,</span>
    <span class="comment">// whereas another thread holds a definitions.Something initialization lock and needs a global reflection lock to complete the initialization)</span>

    <span class="comment">// TODO Convert this into a macro</span>
    <a href="JavaUniverseForce.scala.html#scala.reflect.runtime;JavaUniverseForce.force" title="()Unit">force</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
