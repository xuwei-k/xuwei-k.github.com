<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/tools/reflect/ToolBox.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scala.tools
package reflect

trait <a title="trait ToolBox[U &lt;: scala.reflect.api.Universe] extends AnyRef" id="scala.tools.reflect;ToolBox">ToolBox</a><span class="delimiter">[</span><a title=" &lt;: scala.reflect.api.Universe" id="scala.tools.reflect;ToolBox;U">U</a> &lt;: scala.reflect.api.Universe<span class="delimiter">]</span> <a href="../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a>

  <span class="comment">/** Underlying universe of a ToolBox
   */</span>
  val <a title="=&gt; U" id="scala.tools.reflect;ToolBox.u">u</a>: <a href="#scala.tools.reflect;ToolBox;U" title="U">U</a>

  <span class="comment">/** Underlying mirror of a ToolBox
   */</span>
  val <a title="=&gt; ToolBox.this.u.Mirror" id="scala.tools.reflect;ToolBox.mirror">mirror</a>: u.<a href="../../reflect/api/Mirrors.scala.html#scala.reflect.api;Mirrors;Mirror" title="ToolBox.this.u.Mirror">Mirror</a>

  <span class="comment">/** Front end of the toolbox.
   *
   *  Accumulates and displays warnings and errors, can drop to interactive mode (if supported).
   *  The latter can be useful to study the typechecker or to debug complex macros.
   *
   *  [[scala.tools.reflect]] provides two predefined front ends that can be created using
   *  [[scala.tools.reflect.mkSilentFrontEnd]] and [[scala.tools.reflect.mkConsoleFrontEnd]].
   */</span>
  def <a title="=&gt; scala.tools.reflect.FrontEnd" id="scala.tools.reflect;ToolBox.frontEnd">frontEnd</a>: <a href="FrontEnd.scala.html#scala.tools.reflect;FrontEnd" title="scala.tools.reflect.FrontEnd">FrontEnd</a>

  <span class="comment">/** Represents mode of operations of the typechecker underlying `c.typecheck` calls.
   *  Is necessary since the shape of the typechecked tree alone is not enough to guess how it should be typechecked.
   *  Can be EXPRmode (typecheck as a term), TYPEmode (typecheck as a type) or PATTERNmode (typecheck as a pattern).
   */</span>
  type <a title="" id="scala.tools.reflect;ToolBox;TypecheckMode">TypecheckMode</a>

  <span class="comment">/** Indicates that an argument to `c.typecheck` should be typechecked as a term.
   *  This is the default typechecking mode in Scala 2.11 and the only one supported in Scala 2.10.
   */</span>
  val <a title="=&gt; ToolBox.this.TypecheckMode" id="scala.tools.reflect;ToolBox.TERMmode">TERMmode</a>: <a href="#scala.tools.reflect;ToolBox;TypecheckMode" title="ToolBox.this.TypecheckMode">TypecheckMode</a>

  <span class="comment">/** Indicates that an argument to `c.typecheck` should be typechecked as a type.
   */</span>
  val <a title="=&gt; ToolBox.this.TypecheckMode" id="scala.tools.reflect;ToolBox.TYPEmode">TYPEmode</a>: <a href="#scala.tools.reflect;ToolBox;TypecheckMode" title="ToolBox.this.TypecheckMode">TypecheckMode</a>

  <span class="comment">/** Indicates that an argument to `c.typecheck` should be typechecked as a pattern.
   */</span>
  val <a title="=&gt; ToolBox.this.TypecheckMode" id="scala.tools.reflect;ToolBox.PATTERNmode">PATTERNmode</a>: <a href="#scala.tools.reflect;ToolBox;TypecheckMode" title="ToolBox.this.TypecheckMode">TypecheckMode</a>

  <span class="comment">/** @see `Typers.typecheck`
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `tb.typecheck` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
  def <a title="(tree: ToolBox.this.u.Tree, pt: ToolBox.this.u.Type, silent: Boolean, withImplicitViewsDisabled: Boolean, withMacrosDisabled: Boolean)ToolBox.this.u.Tree" id="scala.tools.reflect;ToolBox.typeCheck">typeCheck</a><span class="delimiter">(</span><a title="ToolBox.this.u.Tree" id="scala.tools.reflect;ToolBox.typeCheck.tree">tree</a>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;Tree" title="ToolBox.this.u.Tree">Tree</a>, <a title="ToolBox.this.u.Type" id="scala.tools.reflect;ToolBox.typeCheck$default$2">pt</a>: u.<a href="../../reflect/api/Types.scala.html#scala.reflect.api;Types;Type" title="ToolBox.this.u.Type">Type</a> = <a href="#scala.tools.reflect;ToolBox.u" title="=&gt; U">u</a>.<a href="../../reflect/api/Types.scala.html#scala.reflect.api;Types.WildcardType" title="=&gt; ToolBox.this.u.Type">WildcardType</a>, <a title="Boolean" id="scala.tools.reflect;ToolBox.typeCheck$default$3">silent</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false, <a title="Boolean" id="scala.tools.reflect;ToolBox.typeCheck$default$4">withImplicitViewsDisabled</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false, <a title="Boolean" id="scala.tools.reflect;ToolBox.typeCheck$default$5">withMacrosDisabled</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false<span class="delimiter">)</span>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;Tree" title="ToolBox.this.u.Tree">Tree</a> =
    <a href="#scala.tools.reflect;ToolBox.typecheck" title="(tree: ToolBox.this.u.Tree, mode: ToolBox.this.TypecheckMode, pt: ToolBox.this.u.Type, silent: Boolean, withImplicitViewsDisabled: Boolean, withMacrosDisabled: Boolean)ToolBox.this.u.Tree">typecheck</a><span class="delimiter">(</span><a href="#scala.tools.reflect;ToolBox.typeCheck.tree" title="ToolBox.this.u.Tree">tree</a>, <a href="#scala.tools.reflect;ToolBox.TERMmode" title="=&gt; ToolBox.this.TypecheckMode">TERMmode</a>, <a href="#scala.tools.reflect;ToolBox.typeCheck$default$2" title="ToolBox.this.u.Type">pt</a>, <a href="#scala.tools.reflect;ToolBox.typeCheck$default$3" title="Boolean">silent</a>, <a href="#scala.tools.reflect;ToolBox.typeCheck$default$4" title="Boolean">withImplicitViewsDisabled</a>, <a href="#scala.tools.reflect;ToolBox.typeCheck$default$5" title="Boolean">withMacrosDisabled</a><span class="delimiter">)</span>

  <span class="comment">/** Typechecks a tree against the expected type `pt`
   *  under typechecking mode specified in `mode` with [[EXPRmode]] being default.
   *  This populates symbols and types of the tree and possibly transforms it to reflect certain desugarings.
   *
   *  If the tree has unresolved type variables (represented as instances of `FreeTypeSymbol` symbols),
   *  then they all have to be resolved first using `Tree.substituteTypes`, or an error occurs.
   *
   *  If `silent` is false, `ToolBoxError` will be thrown in case of a typecheck error.
   *  If `silent` is true, the typecheck is silent and will return `EmptyTree` if an error occurs.
   *  Such errors don't vanish and can be inspected by turning on -Ydebug.
   *
   *  Typechecking can be steered with the following optional parameters:
   *    `withImplicitViewsDisabled` recursively prohibits implicit views (though, implicit vals will still be looked up and filled in), default value is false
   *    `withMacrosDisabled` recursively prohibits macro expansions and macro-based implicits, default value is false
   */</span>
  def <a title="(tree: ToolBox.this.u.Tree, mode: ToolBox.this.TypecheckMode, pt: ToolBox.this.u.Type, silent: Boolean, withImplicitViewsDisabled: Boolean, withMacrosDisabled: Boolean)ToolBox.this.u.Tree" id="scala.tools.reflect;ToolBox.typecheck">typecheck</a><span class="delimiter">(</span><a title="ToolBox.this.u.Tree" id="scala.tools.reflect;ToolBox.typecheck.tree">tree</a>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;Tree" title="ToolBox.this.u.Tree">Tree</a>, <a title="ToolBox.this.TypecheckMode" id="scala.tools.reflect;ToolBox.typecheck$default$2">mode</a>: <a href="#scala.tools.reflect;ToolBox;TypecheckMode" title="ToolBox.this.TypecheckMode">TypecheckMode</a> = <a href="#scala.tools.reflect;ToolBox.TERMmode" title="=&gt; ToolBox.this.TypecheckMode">TERMmode</a>, <a title="ToolBox.this.u.Type" id="scala.tools.reflect;ToolBox.typecheck$default$3">pt</a>: u.<a href="../../reflect/api/Types.scala.html#scala.reflect.api;Types;Type" title="ToolBox.this.u.Type">Type</a> = <a href="#scala.tools.reflect;ToolBox.u" title="=&gt; U">u</a>.<a href="../../reflect/api/Types.scala.html#scala.reflect.api;Types.WildcardType" title="=&gt; ToolBox.this.u.Type">WildcardType</a>, <a title="Boolean" id="scala.tools.reflect;ToolBox.typecheck$default$4">silent</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false, <a title="Boolean" id="scala.tools.reflect;ToolBox.typecheck$default$5">withImplicitViewsDisabled</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false, <a title="Boolean" id="scala.tools.reflect;ToolBox.typecheck$default$6">withMacrosDisabled</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false<span class="delimiter">)</span>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;Tree" title="ToolBox.this.u.Tree">Tree</a>

  <span class="comment">/** Infers an implicit value of the expected type `pt` in top-level context.
   *  Optional `pos` parameter provides a position that will be associated with the implicit search.
   *
   *  As mentioned in https://groups.google.com/forum/#!topic/scala-internals/ta-vbUT6JE8
   *  this API won't take into account the lexical context of the callsite, because
   *  currently it's impossible to reify it.
   *
   *  If `silent` is false, `ToolBoxError` will be thrown in case of an inference error.
   *  If `silent` is true, the typecheck is silent and will return `EmptyTree` if an error occurs.
   *  Such errors don't vanish and can be inspected by turning on -Xlog-implicits.
   *  Unlike in `typecheck`, `silent` is true by default.
   */</span>
  def <a title="(pt: ToolBox.this.u.Type, silent: Boolean, withMacrosDisabled: Boolean, pos: ToolBox.this.u.Position)ToolBox.this.u.Tree" id="scala.tools.reflect;ToolBox.inferImplicitValue">inferImplicitValue</a><span class="delimiter">(</span><a title="ToolBox.this.u.Type" id="scala.tools.reflect;ToolBox.inferImplicitValue.pt">pt</a>: u.<a href="../../reflect/api/Types.scala.html#scala.reflect.api;Types;Type" title="ToolBox.this.u.Type">Type</a>, <a title="Boolean" id="scala.tools.reflect;ToolBox.inferImplicitValue$default$2">silent</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = true, <a title="Boolean" id="scala.tools.reflect;ToolBox.inferImplicitValue$default$3">withMacrosDisabled</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false, <a title="ToolBox.this.u.Position" id="scala.tools.reflect;ToolBox.inferImplicitValue$default$4">pos</a>: u.<a href="../../reflect/api/Positions.scala.html#scala.reflect.api;Positions;Position" title="ToolBox.this.u.Position">Position</a> = <a href="#scala.tools.reflect;ToolBox.u" title="=&gt; U">u</a>.<a href="../../reflect/api/Positions.scala.html#scala.reflect.api;Positions.NoPosition" title="=&gt; ToolBox.this.u.Position">NoPosition</a><span class="delimiter">)</span>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;Tree" title="ToolBox.this.u.Tree">Tree</a>

  <span class="comment">/** Infers an implicit view from the provided tree `tree` from the type `from` to the type `to` in the toplevel context.
   *  Optional `pos` parameter provides a position that will be associated with the implicit search.
   *
   *  As mentioned in https://groups.google.com/forum/#!topic/scala-internals/ta-vbUT6JE8
   *  this API won't take into account the lexical context of the callsite, because
   *  currently it's impossible to reify it.
   *
   *  If `silent` is false, `ToolBoxError` will be thrown in case of an inference error.
   *  If `silent` is true, the typecheck is silent and will return `EmptyTree` if an error occurs.
   *  Such errors don't vanish and can be inspected by turning on -Xlog-implicits.
   *  Unlike in `typecheck`, `silent` is true by default.
   */</span>
  def <a title="(tree: ToolBox.this.u.Tree, from: ToolBox.this.u.Type, to: ToolBox.this.u.Type, silent: Boolean, withMacrosDisabled: Boolean, pos: ToolBox.this.u.Position)ToolBox.this.u.Tree" id="scala.tools.reflect;ToolBox.inferImplicitView">inferImplicitView</a><span class="delimiter">(</span><a title="ToolBox.this.u.Tree" id="scala.tools.reflect;ToolBox.inferImplicitView.tree">tree</a>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;Tree" title="ToolBox.this.u.Tree">Tree</a>, <a title="ToolBox.this.u.Type" id="scala.tools.reflect;ToolBox.inferImplicitView.from">from</a>: u.<a href="../../reflect/api/Types.scala.html#scala.reflect.api;Types;Type" title="ToolBox.this.u.Type">Type</a>, <a title="ToolBox.this.u.Type" id="scala.tools.reflect;ToolBox.inferImplicitView.to">to</a>: u.<a href="../../reflect/api/Types.scala.html#scala.reflect.api;Types;Type" title="ToolBox.this.u.Type">Type</a>, <a title="Boolean" id="scala.tools.reflect;ToolBox.inferImplicitView$default$4">silent</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = true, <a title="Boolean" id="scala.tools.reflect;ToolBox.inferImplicitView$default$5">withMacrosDisabled</a>: <a href="../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false, <a title="ToolBox.this.u.Position" id="scala.tools.reflect;ToolBox.inferImplicitView$default$6">pos</a>: u.<a href="../../reflect/api/Positions.scala.html#scala.reflect.api;Positions;Position" title="ToolBox.this.u.Position">Position</a> = <a href="#scala.tools.reflect;ToolBox.u" title="=&gt; U">u</a>.<a href="../../reflect/api/Positions.scala.html#scala.reflect.api;Positions.NoPosition" title="=&gt; ToolBox.this.u.Position">NoPosition</a><span class="delimiter">)</span>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;Tree" title="ToolBox.this.u.Tree">Tree</a>

  <span class="comment">/** Recursively resets locally defined symbols and types in a given tree.
   *  WARNING: Don't use this API, go for [[untypecheck]] instead.
   */</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use `tb.untypecheck` instead&quot;</span>, <span class="string">&quot;2.11.0&quot;</span><span class="delimiter">)</span>
  def <a title="(tree: ToolBox.this.u.Tree)ToolBox.this.u.Tree" id="scala.tools.reflect;ToolBox.resetLocalAttrs">resetLocalAttrs</a><span class="delimiter">(</span><a title="ToolBox.this.u.Tree" id="scala.tools.reflect;ToolBox.resetLocalAttrs.tree">tree</a>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;Tree" title="ToolBox.this.u.Tree">Tree</a><span class="delimiter">)</span>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;Tree" title="ToolBox.this.u.Tree">Tree</a>

  <span class="comment">/**
   *  @see [[scala.reflect.macros.Typers.untypecheck]]
   */</span>
  def <a title="(tree: ToolBox.this.u.Tree)ToolBox.this.u.Tree" id="scala.tools.reflect;ToolBox.untypecheck">untypecheck</a><span class="delimiter">(</span><a title="ToolBox.this.u.Tree" id="scala.tools.reflect;ToolBox.untypecheck.tree">tree</a>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;Tree" title="ToolBox.this.u.Tree">Tree</a><span class="delimiter">)</span>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;Tree" title="ToolBox.this.u.Tree">Tree</a>

  <span class="comment">/** .. */</span>
  def <a title="(code: String)ToolBox.this.u.Tree" id="scala.tools.reflect;ToolBox.parse">parse</a><span class="delimiter">(</span><a title="String" id="scala.tools.reflect;ToolBox.parse.code">code</a>: <span title="String">String</span><span class="delimiter">)</span>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;Tree" title="ToolBox.this.u.Tree">Tree</a>

  <span class="comment">/** Compiles a tree using this ToolBox.
   *
   *  If the tree has unresolved type variables (represented as instances of `FreeTypeSymbol` symbols),
   *  then they all have to be resolved first using `Tree.substituteTypes`, or an error occurs.
   *
   *  This spawns the compiler at the Namer phase, and pipelines the tree through that compiler.
   *  Currently `compile` does not accept trees that already typechecked, because typechecking isn't idempotent.
   *  For more info, take a look at https://issues.scala-lang.org/browse/SI-5464.
   */</span>
  def <a title="(tree: ToolBox.this.u.Tree)() =&gt; Any" id="scala.tools.reflect;ToolBox.compile">compile</a><span class="delimiter">(</span><a title="ToolBox.this.u.Tree" id="scala.tools.reflect;ToolBox.compile.tree">tree</a>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;Tree" title="ToolBox.this.u.Tree">Tree</a><span class="delimiter">)</span>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Any

  <span class="comment">/** Defines a top-level class, trait or module in this ToolBox,
   *  putting it into a uniquely-named package and returning a symbol that references the defined entity.
   *  For a ClassDef, a ClassSymbol is returned, and for a ModuleDef, a ModuleSymbol is returned (not a module class, but a module itself).
   *
   *  This method can be used to generate definitions that will later be re-used by subsequent calls to
   *  `compile`, `define` or `eval`. To refer to the generated definition in a tree, use q&quot;$sym&quot;.
   */</span>
  def <a title="(tree: ToolBox.this.u.ImplDef)ToolBox.this.u.Symbol" id="scala.tools.reflect;ToolBox.define">define</a><span class="delimiter">(</span><a title="ToolBox.this.u.ImplDef" id="scala.tools.reflect;ToolBox.define.tree">tree</a>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;ImplDef" title="ToolBox.this.u.ImplDef">ImplDef</a><span class="delimiter">)</span>: u.<a href="../../reflect/api/Symbols.scala.html#scala.reflect.api;Symbols;Symbol" title="ToolBox.this.u.Symbol">Symbol</a>

  <span class="comment">/** Compiles and runs a tree using this ToolBox.
   *  Is equivalent to `compile(tree)()`.
   */</span>
  def <a title="(tree: ToolBox.this.u.Tree)Any" id="scala.tools.reflect;ToolBox.eval">eval</a><span class="delimiter">(</span><a title="ToolBox.this.u.Tree" id="scala.tools.reflect;ToolBox.eval.tree">tree</a>: u.<a href="../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;Tree" title="ToolBox.this.u.Tree">Tree</a><span class="delimiter">)</span>: <span title="Any">Any</span>
<span class="delimiter">}</span>

<span class="comment">/** Represents an error during toolboxing
 */</span>
case class <a title="class ToolBoxError extends Throwable with Product with Serializable" id="scala.tools.reflect.ToolBoxError.readResolve">ToolBoxError</a><a href="../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="String" id="scala.tools.reflect;ToolBoxError.message">message</a>: <span title="String">String</span>, <a title="Throwable" id="scala.tools.reflect.ToolBoxError.apply$default$2">cause</a>: <span title="Throwable">Throwable</span> = null<span class="delimiter">)</span> extends <a href="../../package.scala.html#scala.package;Throwable" title="Throwable">Throwable</a><span class="delimiter">(</span><a href="#scala.tools.reflect;ToolBoxError.message" title="String">message</a>, <a href="#scala.tools.reflect.ToolBoxError.apply$default$2" title="Throwable">cause</a><span class="delimiter">)</span>

        </pre>
    </body>
</html>
