<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/tools/nsc/typechecker/NamesDefaults.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* NSC -- new Scala compiler
 * Copyright 2005-2013 LAMP/EPFL
 * @author  Martin Odersky
 */</span>

package scala.tools.nsc
package typechecker

import symtab.<a href="../symtab/package.scala.html#scala.tools.nsc.symtab.package.Flags" title="=&gt; reflect.internal.Flags.type">Flags</a>._
import scala.collection.mutable
import scala.reflect.ClassTag

<span class="comment">/**
 *  @author Lukas Rytz
 *  @version 1.0
 */</span>
trait <a title="trait NamesDefaults extends AnyRef" id="scala.tools.nsc.typechecker;NamesDefaults">NamesDefaults</a> <a href="../../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a> self: Analyzer =&gt;

  import <a href="Analyzer.scala.html#scala.tools.nsc.typechecker;Analyzer.global" title="=&gt; scala.tools.nsc.Global">global</a>._
  import <a href="../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions.definitions" title="NamesDefaults.this.global.definitions.type">definitions</a>._
  import <a href="ContextErrors.scala.html#scala.tools.nsc.typechecker;ContextErrors.NamesDefaultsErrorsGen" title="NamesDefaults.this.NamesDefaultsErrorsGen.type">NamesDefaultsErrorsGen</a>._
  import <a href="../ast/Trees.scala.html#scala.tools.nsc.ast;Trees.treeInfo" title="NamesDefaults.this.global.treeInfo.type">treeInfo</a>.WildcardStarArg

  <span class="comment">// Default getters of constructors are added to the companion object in the</span>
  <span class="comment">// typeCompleter of the constructor (methodSig). To compute the signature,</span>
  <span class="comment">// we need the ClassDef. To create and enter the symbols into the companion</span>
  <span class="comment">// object, we need the templateNamer of that module class. These two are stored</span>
  <span class="comment">// as an attachment in the companion module symbol</span>
  class <a title="class ConstructorDefaultsAttachment extends AnyRef" id="scala.tools.nsc.typechecker;NamesDefaults;ConstructorDefaultsAttachment">ConstructorDefaultsAttachment</a><a href="#scala.tools.nsc.typechecker;NamesDefaults;ConstructorDefaultsAttachment" title="NamesDefaults.this.ConstructorDefaultsAttachment" class="delimiter">(</a>val <a title="NamesDefaults.this.global.ClassDef" id="scala.tools.nsc.typechecker;NamesDefaults;ConstructorDefaultsAttachment.classWithDefault">classWithDefault</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;ClassDef" title="NamesDefaults.this.global.ClassDef">ClassDef</a>, var <a title="NamesDefaults.this.Namer" id="scala.tools.nsc.typechecker;NamesDefaults;ConstructorDefaultsAttachment.companionModuleClassNamer">companionModuleClassNamer</a>: <a href="Namers.scala.html#scala.tools.nsc.typechecker;Namers;Namer" title="NamesDefaults.this.Namer">Namer</a><span class="delimiter">)</span>

  <span class="comment">// To attach the default getters of local (term-owned) methods to the method symbol.</span>
  <span class="comment">// Used in Namer.enterExistingSym: it needs to re-enter the method symbol and also</span>
  <span class="comment">// default getters, which could not be found otherwise.</span>
  class <a title="class DefaultsOfLocalMethodAttachment extends AnyRef" id="scala.tools.nsc.typechecker;NamesDefaults;DefaultsOfLocalMethodAttachment">DefaultsOfLocalMethodAttachment</a><a href="#scala.tools.nsc.typechecker;NamesDefaults;DefaultsOfLocalMethodAttachment" title="NamesDefaults.this.DefaultsOfLocalMethodAttachment" class="delimiter">(</a>val <a title="scala.collection.mutable.Set[NamesDefaults.this.global.Symbol]" id="scala.tools.nsc.typechecker;NamesDefaults;DefaultsOfLocalMethodAttachment.defaultGetters">defaultGetters</a>: mutable.<a href="../../../collection/mutable/Set.scala.html#scala.collection.mutable;Set" title="scala.collection.mutable.Set[NamesDefaults.this.global.Symbol]">Set</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    def this<span class="delimiter">(</span><a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults;DefaultsOfLocalMethodAttachment.<init>(7522038d37).default">default</a>: <a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="NamesDefaults.this.global.Symbol">Symbol</a><span class="delimiter">)</span> = this<span class="delimiter">(</span>mutable.<a href="../../../collection/generic/GenericCompanion.scala.html#scala.collection.generic;GenericCompanion.apply" title="(elems: NamesDefaults.this.global.Symbol*)scala.collection.mutable.Set[NamesDefaults.this.global.Symbol]">Set</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults;DefaultsOfLocalMethodAttachment.<init>(7522038d37).default" title="NamesDefaults.this.global.Symbol">default</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  case class <a title="class NamedApplyInfo extends AnyRef with Product with Serializable" id="scala.tools.nsc.typechecker;NamesDefaults.NamedApplyInfo.readResolve">NamedApplyInfo</a><a href="../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a>
    <a title="Option[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults;NamedApplyInfo.qual">qual</a>:       <a href="../../../Option.scala.html#scala;Option" title="Option[NamesDefaults.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>,
    <a title="List[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults;NamedApplyInfo.targs">targs</a>:      <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[NamesDefaults.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>,
    <a title="List[List[NamesDefaults.this.global.Tree]]" id="scala.tools.nsc.typechecker;NamesDefaults;NamedApplyInfo.vargss">vargss</a>:     <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[NamesDefaults.this.global.Tree]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">]</span>,
    <a title="NamesDefaults.this.Typer" id="scala.tools.nsc.typechecker;NamesDefaults;NamedApplyInfo.blockTyper">blockTyper</a>: <a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer" title="NamesDefaults.this.Typer">Typer</a>
  <span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">}</span>

  private def <a title="(arg: NamesDefaults.this.global.Tree)Option[NamesDefaults.this.global.Name]" id="scala.tools.nsc.typechecker;NamesDefaults.nameOfNamedArg">nameOfNamedArg</a><span class="delimiter">(</span><a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.nameOfNamedArg.arg">arg</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="NamesDefaults.this.global.Tree">Tree</a><span class="delimiter">)</span> = <a href="../../../Option.scala.html#scala;Some" title="(x: NamesDefaults.this.global.Tree)Some[NamesDefaults.this.global.Tree]">Some</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.nameOfNamedArg.arg" title="NamesDefaults.this.global.Tree">arg</a><span class="delimiter">)</span> <a href="../../../Option.scala.html#scala;Option.collect" title="(pf: PartialFunction[NamesDefaults.this.global.Tree,NamesDefaults.this.global.Name])Option[NamesDefaults.this.global.Name]">collect</a> <a title="&lt;$anon: NamesDefaults.this.global.Tree =&gt; NamesDefaults.this.global.Name&gt; extends scala.runtime.AbstractPartialFunction[NamesDefaults.this.global.Tree,NamesDefaults.this.global.Name] with Serializable" id="scala.tools.nsc.typechecker;NamesDefaults.nameOfNamedArg;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> case AssignOrNamedArg<span class="delimiter">(</span>Ident<span class="delimiter">(</span><a title="NamesDefaults.this.global.Name" id="scala.tools.nsc.typechecker;NamesDefaults.nameOfNamedArg;$anonfun.isDefinedAt.name">name</a><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.nameOfNamedArg;$anonfun.isDefinedAt.name" title="NamesDefaults.this.global.Name">name</a> <span class="delimiter">}</span>
  def <a title="(arg: NamesDefaults.this.global.Tree)Boolean" id="scala.tools.nsc.typechecker;NamesDefaults.isNamedArg">isNamedArg</a><span class="delimiter">(</span><a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.isNamedArg.arg">arg</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="NamesDefaults.this.global.Tree">Tree</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.isNamedArg.arg" title="NamesDefaults.this.global.Tree">arg</a> match <span class="delimiter">{</span>
    case AssignOrNamedArg<span class="delimiter">(</span>Ident<span class="delimiter">(</span>_<span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; true
    case _                             =&gt; false
  <span class="delimiter">}</span>

  <span class="comment">/** @param pos maps indices from old to new */</span>
  def <a title="[T](args: List[T], pos: Int =&gt; Int)(implicit evidence$1: scala.reflect.ClassTag[T])List[T]" id="scala.tools.nsc.typechecker;NamesDefaults.reorderArgs">reorderArgs</a><span class="delimiter">[</span><a title="" id="scala.tools.nsc.typechecker;NamesDefaults.reorderArgs;T">T</a>: ClassTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="List[T]" id="scala.tools.nsc.typechecker;NamesDefaults.reorderArgs.args">args</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Int =&gt; Int" id="scala.tools.nsc.typechecker;NamesDefaults.reorderArgs.pos">pos</a>: Int =&gt; Int<span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[T]" id="scala.tools.nsc.typechecker;NamesDefaults.reorderArgs.res">res</a> = new Array<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.reorderArgs.args" title="List[T]">args</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.length" title="=&gt; Int">length</a><span class="delimiter">)</span>
    <a href="../../../reflect/internal/util/Collections.scala.html#scala.reflect.internal.util;Collections.foreachWithIndex" title="(xs: List[T])(f: (T, Int) =&gt; Unit)Unit">foreachWithIndex</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.reorderArgs.args" title="List[T]">args</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="T" id="scala.tools.nsc.typechecker;NamesDefaults.reorderArgs.$anonfun.arg">arg</a>, <a title="Int" id="scala.tools.nsc.typechecker;NamesDefaults.reorderArgs.$anonfun.index">index</a><span class="delimiter">)</span> =&gt; <a href="../../../Array.scala.html#scala;Array.update" title="(i: Int, x: T)Unit">res</a><span class="delimiter">(</span><a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: Int)Int">pos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.reorderArgs.$anonfun.index" title="Int">index</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.reorderArgs.$anonfun.arg" title="T">arg</a><span class="delimiter">)</span>
    <a href="../../../Predef.scala.html#scala.Predef.genericArrayOps" title="(xs: Array[T])scala.collection.mutable.ArrayOps[T]">res</a>.<a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[T]">toList</a>
  <span class="delimiter">}</span>

  <span class="comment">/** @param pos maps indices from new to old (!) */</span>
  private def <a title="[T](args: List[T], pos: Int =&gt; Int)(implicit evidence$2: scala.reflect.ClassTag[T])List[T]" id="scala.tools.nsc.typechecker;NamesDefaults.reorderArgsInv">reorderArgsInv</a><span class="delimiter">[</span><a title="" id="scala.tools.nsc.typechecker;NamesDefaults.reorderArgsInv;T">T</a>: ClassTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="List[T]" id="scala.tools.nsc.typechecker;NamesDefaults.reorderArgsInv.args">args</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Int =&gt; Int" id="scala.tools.nsc.typechecker;NamesDefaults.reorderArgsInv.pos">pos</a>: Int =&gt; Int<span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Array[T]" id="scala.tools.nsc.typechecker;NamesDefaults.reorderArgsInv.argsArray">argsArray</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.reorderArgsInv.args" title="List[T]">args</a>.<a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toArray" title="(implicit evidence$1: scala.reflect.ClassTag[T])Array[T]">toArray</a>
    <span class="delimiter">(</span><a href="../../../Predef.scala.html#scala.Predef.genericArrayOps" title="(xs: Array[T])scala.collection.mutable.ArrayOps[T]">argsArray</a>.<a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.indices" title="=&gt; scala.collection.immutable.Range">indices</a> <a href="../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.map" title="(f: Int =&gt; T)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[Int],T,scala.collection.immutable.IndexedSeq[T]])scala.collection.immutable.IndexedSeq[T]">map</a> <span class="delimiter">(</span><a title="Int" id="scala.tools.nsc.typechecker;NamesDefaults.reorderArgsInv.$anonfun.i">i</a> =&gt; <a href="../../../Array.scala.html#scala;Array.apply" title="(i: Int)T">argsArray</a><span class="delimiter">(</span><a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: Int)Int">pos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.reorderArgsInv.$anonfun.i" title="Int">i</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[T]">toList</a>
  <span class="delimiter">}</span>

  <span class="comment">/** returns `true` if every element is equal to its index */</span>
  def <a title="(a: Array[Int])Boolean" id="scala.tools.nsc.typechecker;NamesDefaults.allArgsArePositional">allArgsArePositional</a><span class="delimiter">(</span><a title="Array[Int]" id="scala.tools.nsc.typechecker;NamesDefaults.allArgsArePositional.a">a</a>: <a href="../../../Array.scala.html#scala;Array" title="Array[Int]">Array</a><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="../../../Predef.scala.html#scala;LowPriorityImplicits.intWrapper" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt" class="int">0</a> <a href="../../../runtime/RichInt.scala.html#scala.runtime;RichInt.until(7457d0ec05)" title="(end: Int)scala.collection.immutable.Range">until</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.allArgsArePositional.a" title="Array[Int]">a</a>.<a href="../../../Array.scala.html#scala;Array.length" title="=&gt; Int">length</a><span class="delimiter">)</span>.<a href="../../../collection/IterableLike.scala.html#scala.collection;IterableLike.forall" title="(p: Int =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a title="Int" id="scala.tools.nsc.typechecker;NamesDefaults.allArgsArePositional.$anonfun.i">i</a> =&gt; <a href="../../../Array.scala.html#scala;Array.apply" title="(i: Int)Int">a</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.allArgsArePositional.$anonfun.i" title="Int">i</a><span class="delimiter">)</span> <a href="../../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.allArgsArePositional.$anonfun.i" title="Int">i</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Transform a function application into a Block, and assigns typer.context
   * .namedApplyBlockInfo to the new block as side-effect. If tree has the form
   *    Apply(fun, args)
   * first the function &quot;fun&quot; (which might be an application itself!) is transformed into a
   * block of the form
   *   {
   *     val qual$1 = qualifier_of_fun
   *     val x$1 = arg_1_of_fun
   *     ...
   *     val x$n = arg_n_of_fun
   *     qual$1.fun[targs](x$1, ...)...(..., x$n)
   *   }
   * then for each argument in args, a value is created and entered into the block. finally
   * the application expression of the block is updated.
   *   {
   *     val qual$1 = ..
   *     ...
   *     val x$n = ...
   *  &gt;  val qual$n+1 = arg(1)
   *  &gt;  ...
   *  &gt;  val qual$n+m = arg(m)
   *  &gt;  qual$1.fun[targs](x$1, ...)...(..., x$n)(x$n+1, ..., x$n+m)
   *   }
   *
   * @param typer the typer calling this method; this method calls
   *    typer.doTypedApply
   * @param mode the mode to use for calling typer.doTypedApply
   * @param pt the expected type for calling typer.doTypedApply
   *
   * @param tree: the function application tree
   * @argPos: a function mapping arguments from their current position to the
   *   position specified by the method type. example:
   *    def foo(a: Int, b: String)
   *    foo(b = &quot;1&quot;, a = 2)
   *  calls
   *    transformNamedApplication(Apply(foo, List(&quot;1&quot;, 2), { 0 =&gt; 1, 1 =&gt; 0 })
   *
   *  @return the transformed application (a Block) together with the NamedApplyInfo.
   *     if isNamedApplyBlock(tree), returns the existing context.namedApplyBlockInfo
   */</span>
  def <a title="(typer: NamesDefaults.this.Typer, mode: scala.tools.nsc.Mode, pt: NamesDefaults.this.global.Type)(tree: NamesDefaults.this.global.Tree, argPos: Int =&gt; Int)NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication">transformNamedApplication</a><span class="delimiter">(</span><a title="NamesDefaults.this.Typer" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.typer">typer</a>: <a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer" title="NamesDefaults.this.Typer">Typer</a>, <a title="scala.tools.nsc.Mode" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.mode">mode</a>: <a href="../../../reflect/internal/Mode.scala.html#scala.reflect.internal;Mode" title="scala.tools.nsc.Mode">Mode</a>, <a title="NamesDefaults.this.global.Type" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.pt">pt</a>: <a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="NamesDefaults.this.global.Type">Type</a><span class="delimiter">)</span>
                               <span class="delimiter">(</span><a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="NamesDefaults.this.global.Tree">Tree</a>, <a title="Int =&gt; Int" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argPos">argPos</a>: Int =&gt; Int<span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="NamesDefaults.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
    import <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.typer" title="NamesDefaults.this.Typer">typer</a>._
    import <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.typer" title="NamesDefaults.this.Typer">typer</a>.<a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.infer" title="=&gt; NamesDefaults.this.Inferencer">infer</a>._
    val <a title="NamesDefaults.this.Context" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.context">context</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.typer" title="NamesDefaults.this.Typer">typer</a>.<a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.context" title="=&gt; NamesDefaults.this.Context">context</a>
    import <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.context" title="NamesDefaults.this.Context">context</a>.unit

    <span class="comment">/*
     * Transform a function into a block, and passing context.namedApplyBlockInfo to
     * the new block as side-effect.
     *
     * `baseFun` is typed, the resulting block must be typed as well.
     *
     * Fun is transformed in the following way:
     *  - Ident(f)                                    ==&gt;  Block(Nil, Ident(f))
     *  - Select(qual, f) if (qual is stable)         ==&gt;  Block(Nil, Select(qual, f))
     *  - Select(qual, f) otherwise                   ==&gt;  Block(ValDef(qual$1, qual), Select(qual$1, f))
     *  - TypeApply(fun, targs)                       ==&gt;  Block(Nil or qual$1, TypeApply(fun, targs))
     *  - Select(New(TypeTree()), &lt;init&gt;)             ==&gt;  Block(Nil, Select(New(TypeTree()), &lt;init&gt;))
     *  - Select(New(Select(qual, typeName)), &lt;init&gt;) ==&gt;  Block(Nil, Select(...))     NOTE: qual must be stable in a `new`
     */</span>
    def <a title="(baseFun: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock">baseFunBlock</a><span class="delimiter">(</span><a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun">baseFun</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="NamesDefaults.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="NamesDefaults.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
      val <a title="Boolean" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.isConstr">isConstr</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun" title="NamesDefaults.this.global.Tree">baseFun</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; NamesDefaults.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isConstructor" title="=&gt; Boolean">isConstructor</a>
      val <a title="NamesDefaults.this.Typer" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockTyper">blockTyper</a> = <a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers.newTyper" title="(context: NamesDefaults.this.Context)NamesDefaults.this.Typer">newTyper</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.makeNewScope" title="(tree: NamesDefaults.this.global.Tree, owner: NamesDefaults.this.global.Symbol, reporter: NamesDefaults.this.ContextReporter)NamesDefaults.this.Context">makeNewScope</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.tree" title="NamesDefaults.this.global.Tree">tree</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="comment">// baseFun1: extract the function from a potential TypeApply</span>
      <span class="comment">// funTargs: type arguments on baseFun, used to reconstruct TypeApply in blockWith(Out)Qualifier</span>
      <span class="comment">// defaultTargs: type arguments to be used for calling defaultGetters. If the type arguments are given</span>
      <span class="comment">//   in the source code, re-use them for default getter. Otherwise infer the default getter's t-args.</span>
      val <a href="../../../Tuple3.scala.html#scala;Tuple3" title="(NamesDefaults.this.global.Tree, List[NamesDefaults.this.global.Tree], List[NamesDefaults.this.global.Tree])" class="delimiter">(</a><a href="../../../Tuple3.scala.html#scala;Tuple3._1" title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun1">baseFun1</a>, <a href="../../../Tuple3.scala.html#scala;Tuple3._2" title="List[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.funTargs">funTargs</a>, <a href="../../../Tuple3.scala.html#scala;Tuple3._3" title="List[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.defaultTargs">defaultTargs</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun" title="NamesDefaults.this.global.Tree">baseFun</a> match <span class="delimiter">{</span>
        case TypeApply<span class="delimiter">(</span><a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.x$2.fun">fun</a>, <span title="List[NamesDefaults.this.global.Tree]">targs</span><span class="delimiter">)</span> =&gt;
          val <span title="List[NamesDefaults.this.global.Tree]">targsInSource</span> =
            if <span class="delimiter">(</span><span title="List[NamesDefaults.this.global.Tree]">targs</span>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: NamesDefaults.this.global.Tree =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">a</span> =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.undetparams" title="=&gt; List[NamesDefaults.this.global.Symbol]">undetparams</a> <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: NamesDefaults.this.global.Symbol)Boolean">contains</a> <span title="NamesDefaults.this.global.Tree">a</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; NamesDefaults.this.global.Symbol">symbol</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
            else <span title="List[NamesDefaults.this.global.Tree]">targs</span>
          <a href="../../../Tuple3.scala.html#scala;Tuple3" title="(_1: NamesDefaults.this.global.Tree, _2: List[NamesDefaults.this.global.Tree], _3: List[NamesDefaults.this.global.Tree])(NamesDefaults.this.global.Tree, List[NamesDefaults.this.global.Tree], List[NamesDefaults.this.global.Tree])" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.x$2.fun" title="NamesDefaults.this.global.Tree">fun</a>, <span title="List[NamesDefaults.this.global.Tree]">targs</span>, <span title="List[NamesDefaults.this.global.Tree]">targsInSource</span><span class="delimiter">)</span>

        case Select<span class="delimiter">(</span>New<span class="delimiter">(</span><a title="NamesDefaults.this.global.TypeTree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.x$2.tpt">tpt</a> @ TypeTree<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> if <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.isConstr" title="Boolean">isConstr</a> =&gt;
          val <span title="List[NamesDefaults.this.global.TypeTree]">targsInSource</span> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.x$2.tpt" title="NamesDefaults.this.global.TypeTree">tpt</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a> match <span class="delimiter">{</span>
            case TypeRef<span class="delimiter">(</span><a title="NamesDefaults.this.global.Type" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.x$2.targsInSource.pre">pre</a>, <a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.x$2.targsInSource.sym">sym</a>, <a title="List[NamesDefaults.this.global.Type]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.x$2.targsInSource.args">args</a><span class="delimiter">)</span>
            if <span class="delimiter">(</span><a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.x$2.targsInSource.args" title="List[NamesDefaults.this.global.Type]">args</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: NamesDefaults.this.global.Type =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Type">a</span> =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.undetparams" title="=&gt; List[NamesDefaults.this.global.Symbol]">undetparams</a> <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: NamesDefaults.this.global.Symbol)Boolean">contains</a> <span title="NamesDefaults.this.global.Type">a</span>.<a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; NamesDefaults.this.global.Symbol">typeSymbol</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
              <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.x$2.targsInSource.args" title="List[NamesDefaults.this.global.Type]">args</a>.<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: NamesDefaults.this.global.Type =&gt; NamesDefaults.this.global.TypeTree)(implicit bf: scala.collection.generic.CanBuildFrom[List[NamesDefaults.this.global.Type],NamesDefaults.this.global.TypeTree,List[NamesDefaults.this.global.TypeTree]])List[NamesDefaults.this.global.TypeTree]">map</a><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.List.canBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,NamesDefaults.this.global.TypeTree,List[NamesDefaults.this.global.TypeTree]]" class="delimiter">(</a><a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees.TypeTree(559e7d9959)" title="(tp: NamesDefaults.this.global.Type)NamesDefaults.this.global.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.x$2.targsInSource.$anonfun.x$1" title="NamesDefaults.this.global.Type">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
            case _ =&gt;
              <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
          <span class="delimiter">}</span>
          <a href="../../../Tuple3.scala.html#scala;Tuple3" title="(_1: NamesDefaults.this.global.Tree, _2: scala.collection.immutable.Nil.type, _3: List[NamesDefaults.this.global.TypeTree])(NamesDefaults.this.global.Tree, scala.collection.immutable.Nil.type, List[NamesDefaults.this.global.TypeTree])" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun" title="NamesDefaults.this.global.Tree">baseFun</a>, <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <span title="List[NamesDefaults.this.global.TypeTree]">targsInSource</span><span class="delimiter">)</span>

        case Select<span class="delimiter">(</span>TypeApply<span class="delimiter">(</span>New<span class="delimiter">(</span>TypeTree<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="List[NamesDefaults.this.global.Tree]">targs</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> if <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.isConstr" title="Boolean">isConstr</a> =&gt;
          val <span title="List[NamesDefaults.this.global.Tree]">targsInSource</span> =
            if <span class="delimiter">(</span><span title="List[NamesDefaults.this.global.Tree]">targs</span>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: NamesDefaults.this.global.Tree =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">a</span> =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.undetparams" title="=&gt; List[NamesDefaults.this.global.Symbol]">undetparams</a> <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: NamesDefaults.this.global.Symbol)Boolean">contains</a> <span title="NamesDefaults.this.global.Tree">a</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; NamesDefaults.this.global.Symbol">symbol</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
            else <span title="List[NamesDefaults.this.global.Tree]">targs</span>
          <a href="../../../Tuple3.scala.html#scala;Tuple3" title="(_1: NamesDefaults.this.global.Tree, _2: scala.collection.immutable.Nil.type, _3: List[NamesDefaults.this.global.Tree])(NamesDefaults.this.global.Tree, scala.collection.immutable.Nil.type, List[NamesDefaults.this.global.Tree])" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun" title="NamesDefaults.this.global.Tree">baseFun</a>, <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <span title="List[NamesDefaults.this.global.Tree]">targsInSource</span><span class="delimiter">)</span>

        case _ =&gt; <a href="../../../Tuple3.scala.html#scala;Tuple3" title="(_1: NamesDefaults.this.global.Tree, _2: scala.collection.immutable.Nil.type, _3: scala.collection.immutable.Nil.type)(NamesDefaults.this.global.Tree, scala.collection.immutable.Nil.type, scala.collection.immutable.Nil.type)" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun" title="NamesDefaults.this.global.Tree">baseFun</a>, <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="comment">// never used for constructor calls, they always have a stable qualifier</span>
      def <a title="(qual: NamesDefaults.this.global.Tree, selected: NamesDefaults.this.global.Name)NamesDefaults.this.global.Block" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier">blockWithQualifier</a><span class="delimiter">(</span><a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.qual">qual</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="NamesDefaults.this.global.Tree">Tree</a>, <a title="NamesDefaults.this.global.Name" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.selected">selected</a>: <a href="../../../reflect/internal/Names.scala.html#scala.reflect.internal;Names;Name" title="NamesDefaults.this.global.Name">Name</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        val sym = <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockTyper" title="NamesDefaults.this.Typer">blockTyper</a>.<a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.context" title="=&gt; NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.owner" title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.sym.qual$1">owner</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.newValue$default$2" title="NamesDefaults.this.global.Position" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.sym.x$21">newValue</a><span class="delimiter">(</span><a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.unit" title="=&gt; NamesDefaults.this.global.CompilationUnit">unit</a>.<a href="../CompilationUnits.scala.html#scala.tools.nsc;CompilationUnits;CompilationUnit.freshTermName" title="(prefix: String)NamesDefaults.this.global.TermName">freshTermName</a><a title="NamesDefaults.this.global.TermName" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.sym.x$19" class="delimiter">(</a><a href="../../../reflect/internal/StdNames.scala.html#scala.reflect.internal;StdNames.nme" title="NamesDefaults.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/StdNames.scala.html#scala.reflect.internal;StdNames;TermNames.QUAL_PREFIX" title="=&gt; String">QUAL_PREFIX</a><span class="delimiter">)</span>, newFlags = <a title="Long" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.sym.x$20">ARTIFACT</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="(info: NamesDefaults.this.global.Type)NamesDefaults.this.global.TermSymbol">setInfo</a> <a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types.uncheckedBounds" title="(tp: NamesDefaults.this.global.Type)NamesDefaults.this.global.Type">uncheckedBounds</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.qual" title="NamesDefaults.this.global.Tree">qual</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a><span class="delimiter">)</span> <a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.setPos" title="NamesDefaults.this.global.TermSymbol" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.sym">setPos</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.qual" title="NamesDefaults.this.global.Tree">qual</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;InternalPositionImpl.makeTransparent" title="=&gt; scala.reflect.internal.util.Position">makeTransparent</a><span class="delimiter">)</span>
        <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockTyper" title="NamesDefaults.this.Typer">blockTyper</a>.<a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.context" title="=&gt; NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.scope" title="=&gt; NamesDefaults.this.global.Scope">scope</a> <a href="../../../reflect/internal/Scopes.scala.html#scala.reflect.internal;Scopes;Scope.enter" title="(sym: NamesDefaults.this.global.TermSymbol)NamesDefaults.this.global.TermSymbol">enter</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.sym" title="NamesDefaults.this.global.TermSymbol">sym</a>
        val <a title="NamesDefaults.this.global.ValDef" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.vd">vd</a> = <a href="../../../reflect/internal/Positions.scala.html#scala.reflect.internal;Positions.atPos" title="(pos: NamesDefaults.this.global.Position)(tree: NamesDefaults.this.global.ValDef)NamesDefaults.this.global.ValDef">atPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.sym" title="NamesDefaults.this.global.TermSymbol">sym</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees.ValDef.apply(9493665b33)" title="(sym: NamesDefaults.this.global.Symbol, rhs: NamesDefaults.this.global.Tree)NamesDefaults.this.global.ValDef">ValDef</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.sym" title="NamesDefaults.this.global.TermSymbol">sym</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.qual" title="NamesDefaults.this.global.Tree">qual</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.setType" title="(tp: NamesDefaults.this.global.Type)NamesDefaults.this.global.ValDef">setType</a> <a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types.NoType" title="NamesDefaults.this.global.NoType.type">NoType</a><span class="delimiter">)</span>
        <span class="comment">// it stays in Vegas: SI-5720, SI-5727</span>
        <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.qual" title="NamesDefaults.this.global.Tree">qual</a> <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;TreeContextApiImpl.changeOwner" title="(pairs: (NamesDefaults.this.global.Symbol, NamesDefaults.this.global.Symbol)*)NamesDefaults.this.global.Tree">changeOwner</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockTyper" title="NamesDefaults.this.Typer">blockTyper</a>.<a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.context" title="=&gt; NamesDefaults.this.Context">context</a>.<a href="../../../Predef.scala.html#scala.Predef.ArrowAssoc(fefc64a42a)" title="(self: NamesDefaults.this.global.Symbol)ArrowAssoc[NamesDefaults.this.global.Symbol]">owner</a> <a href="../../../Predef.scala.html#scala.Predef;ArrowAssoc.->" title="(y: NamesDefaults.this.global.TermSymbol)(NamesDefaults.this.global.Symbol, NamesDefaults.this.global.TermSymbol)">-&gt;</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.sym" title="NamesDefaults.this.global.TermSymbol">sym</a><span class="delimiter">)</span>

        val <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.newQual">newQual</a> = <a href="../../../reflect/internal/Positions.scala.html#scala.reflect.internal;Positions.atPos" title="(pos: NamesDefaults.this.global.Position)(tree: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Tree">atPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.qual" title="NamesDefaults.this.global.Tree">qual</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;InternalPositionImpl.focus" title="=&gt; scala.reflect.internal.util.Position">focus</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockTyper" title="NamesDefaults.this.Typer">blockTyper</a>.<a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.typedQualifier(60ebfc8632)" title="(tree: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Tree">typedQualifier</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Ident" title="(name: NamesDefaults.this.global.Name)NamesDefaults.this.global.Ident">Ident</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.sym" title="NamesDefaults.this.global.TermSymbol">sym</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;TermSymbol.name" title="=&gt; NamesDefaults.this.global.TermName">name</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        val <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.baseFunTransformed">baseFunTransformed</a> = <a href="../../../reflect/internal/Positions.scala.html#scala.reflect.internal;Positions.atPos" title="(pos: NamesDefaults.this.global.Position)(tree: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Tree">atPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun" title="NamesDefaults.this.global.Tree">baseFun</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;InternalPositionImpl.makeTransparent" title="=&gt; scala.reflect.internal.util.Position">makeTransparent</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="comment">// setSymbol below is important because the 'selected' function might be overloaded. by</span>
          <span class="comment">// assigning the correct method symbol, typedSelect will just assign the type. the reason</span>
          <span class="comment">// to still call 'typed' is to correctly infer singleton types, SI-5259.</span>
          val <a title="scala.reflect.internal.util.Position" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.baseFunTransformed.selectPos">selectPos</a> =
            if<span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.qual" title="NamesDefaults.this.global.Tree">qual</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;Position.isRange" title="=&gt; Boolean">isRange</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun1" title="NamesDefaults.this.global.Tree">baseFun1</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;Position.isRange" title="=&gt; Boolean">isRange</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.qual" title="NamesDefaults.this.global.Tree">qual</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;InternalPositionImpl.union" title="(pos: scala.reflect.internal.util.Position)scala.reflect.internal.util.Position">union</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun1" title="NamesDefaults.this.global.Tree">baseFun1</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;InternalPositionImpl.withStart" title="(start: Int)scala.reflect.internal.util.Position">withStart</a><span class="delimiter">(</span><span title="Math.type">Math</span>.<span title="(x$1: Int, x$2: Int)Int">min</span><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.qual" title="NamesDefaults.this.global.Tree">qual</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;Position.end" title="=&gt; Int">end</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun1" title="NamesDefaults.this.global.Tree">baseFun1</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;Position.end" title="=&gt; Int">end</a><span class="delimiter">)</span><span class="delimiter">)</span>
            else <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun1" title="NamesDefaults.this.global.Tree">baseFun1</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>
          val <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.baseFunTransformed.f">f</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockTyper" title="NamesDefaults.this.Typer">blockTyper</a>.<a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.typedOperator" title="(tree: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Tree">typedOperator</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Select" title="(qualifier: NamesDefaults.this.global.Tree, name: NamesDefaults.this.global.Name)NamesDefaults.this.global.Select">Select</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.newQual" title="NamesDefaults.this.global.Tree">newQual</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.selected" title="NamesDefaults.this.global.Name">selected</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.setSymbol" title="(sym: NamesDefaults.this.global.Symbol)NamesDefaults.this.global.Select">setSymbol</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun1" title="NamesDefaults.this.global.Tree">baseFun1</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; NamesDefaults.this.global.Symbol">symbol</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.setPos" title="(newpos: scala.reflect.internal.util.Position)NamesDefaults.this.global.Select">setPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.baseFunTransformed.selectPos" title="scala.reflect.internal.util.Position">selectPos</a><span class="delimiter">)</span><span class="delimiter">)</span>
          if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.funTargs" title="List[NamesDefaults.this.global.Tree]">funTargs</a>.<a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.baseFunTransformed.f" title="NamesDefaults.this.global.Tree">f</a>
          else <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;TypeApply" title="(fun: NamesDefaults.this.global.Tree, args: List[NamesDefaults.this.global.Tree])NamesDefaults.this.global.TypeApply">TypeApply</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.baseFunTransformed.f" title="NamesDefaults.this.global.Tree">f</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.funTargs" title="List[NamesDefaults.this.global.Tree]">funTargs</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.setType" title="(tp: NamesDefaults.this.global.Type)NamesDefaults.this.global.TypeApply">setType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun" title="NamesDefaults.this.global.Tree">baseFun</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        val <a title="NamesDefaults.this.global.Block" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.b">b</a> = <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Block" title="(stats: List[NamesDefaults.this.global.Tree], expr: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Block">Block</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.List.apply" title="(xs: NamesDefaults.this.global.ValDef*)List[NamesDefaults.this.global.ValDef]">List</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.vd" title="NamesDefaults.this.global.ValDef">vd</a><span class="delimiter">)</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.baseFunTransformed" title="NamesDefaults.this.global.Tree">baseFunTransformed</a><span class="delimiter">)</span>
                  .<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.setType" title="(tp: NamesDefaults.this.global.Type)NamesDefaults.this.global.Block">setType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.baseFunTransformed" title="NamesDefaults.this.global.Tree">baseFunTransformed</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.setPos" title="(newpos: scala.reflect.internal.util.Position)NamesDefaults.this.global.Block">setPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun" title="NamesDefaults.this.global.Tree">baseFun</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;InternalPositionImpl.makeTransparent" title="=&gt; scala.reflect.internal.util.Position">makeTransparent</a><span class="delimiter">)</span>
        <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.namedApplyBlockInfo_=" title="(x$1: Option[(NamesDefaults.this.global.Tree, NamesDefaults.this.NamedApplyInfo)])Unit">namedApplyBlockInfo</a> =
          <a href="../../../Option.scala.html#scala;Some" title="(x: (NamesDefaults.this.global.Block, NamesDefaults.this.NamedApplyInfo))Some[(NamesDefaults.this.global.Block, NamesDefaults.this.NamedApplyInfo)]">Some</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#scala;Tuple2" title="(_1: NamesDefaults.this.global.Block, _2: NamesDefaults.this.NamedApplyInfo)(NamesDefaults.this.global.Block, NamesDefaults.this.NamedApplyInfo)" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.b" title="NamesDefaults.this.global.Block">b</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.NamedApplyInfo.readResolve" title="(qual: Option[NamesDefaults.this.global.Tree], targs: List[NamesDefaults.this.global.Tree], vargss: List[List[NamesDefaults.this.global.Tree]], blockTyper: NamesDefaults.this.Typer)NamesDefaults.this.NamedApplyInfo">NamedApplyInfo</a><span class="delimiter">(</span><a href="../../../Option.scala.html#scala;Some" title="(x: NamesDefaults.this.global.Tree)Some[NamesDefaults.this.global.Tree]">Some</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.newQual" title="NamesDefaults.this.global.Tree">newQual</a><span class="delimiter">)</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.defaultTargs" title="List[NamesDefaults.this.global.Tree]">defaultTargs</a>, <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockTyper" title="NamesDefaults.this.Typer">blockTyper</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier.b" title="NamesDefaults.this.global.Block">b</a>
      <span class="delimiter">}</span>

      def <a title="(defaultQual: Option[NamesDefaults.this.global.Tree])NamesDefaults.this.global.Block" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier">blockWithoutQualifier</a><span class="delimiter">(</span><a title="Option[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier.defaultQual">defaultQual</a>: <a href="../../../Option.scala.html#scala;Option" title="Option[NamesDefaults.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
        val <a title="NamesDefaults.this.global.Block" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier.b">b</a> = <a href="../../../reflect/internal/Positions.scala.html#scala.reflect.internal;Positions.atPos" title="(pos: NamesDefaults.this.global.Position)(tree: NamesDefaults.this.global.Block)NamesDefaults.this.global.Block">atPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun" title="NamesDefaults.this.global.Tree">baseFun</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Block" title="(stats: List[NamesDefaults.this.global.Tree], expr: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Block">Block</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun" title="NamesDefaults.this.global.Tree">baseFun</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.setType" title="(tp: NamesDefaults.this.global.Type)NamesDefaults.this.global.Block">setType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun" title="NamesDefaults.this.global.Tree">baseFun</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.namedApplyBlockInfo_=" title="(x$1: Option[(NamesDefaults.this.global.Tree, NamesDefaults.this.NamedApplyInfo)])Unit">namedApplyBlockInfo</a> =
          <a href="../../../Option.scala.html#scala;Some" title="(x: (NamesDefaults.this.global.Block, NamesDefaults.this.NamedApplyInfo))Some[(NamesDefaults.this.global.Block, NamesDefaults.this.NamedApplyInfo)]">Some</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#scala;Tuple2" title="(_1: NamesDefaults.this.global.Block, _2: NamesDefaults.this.NamedApplyInfo)(NamesDefaults.this.global.Block, NamesDefaults.this.NamedApplyInfo)" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier.b" title="NamesDefaults.this.global.Block">b</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.NamedApplyInfo.readResolve" title="(qual: Option[NamesDefaults.this.global.Tree], targs: List[NamesDefaults.this.global.Tree], vargss: List[List[NamesDefaults.this.global.Tree]], blockTyper: NamesDefaults.this.Typer)NamesDefaults.this.NamedApplyInfo">NamedApplyInfo</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier.defaultQual" title="Option[NamesDefaults.this.global.Tree]">defaultQual</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.defaultTargs" title="List[NamesDefaults.this.global.Tree]">defaultTargs</a>, <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockTyper" title="NamesDefaults.this.Typer">blockTyper</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier.b" title="NamesDefaults.this.global.Block">b</a>
      <span class="delimiter">}</span>

      def <a title="(pos: NamesDefaults.this.global.Position, classType: NamesDefaults.this.global.Type)Option[NamesDefaults.this.global.gen.global.RefTree]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual">moduleQual</a><span class="delimiter">(</span><a title="NamesDefaults.this.global.Position" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.pos">pos</a>: <a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;Position" title="NamesDefaults.this.global.Position">Position</a>, <a title="NamesDefaults.this.global.Type" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.classType">classType</a>: <a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="NamesDefaults.this.global.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="comment">// prefix does 'normalize', which fixes #3384</span>
        val <a title="NamesDefaults.this.global.Type" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.pre">pre</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.classType" title="NamesDefaults.this.global.Type">classType</a>.<a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.prefix" title="=&gt; NamesDefaults.this.global.Type">prefix</a>
        if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.pre" title="NamesDefaults.this.global.Type">pre</a> <span title="(x$1: Any)Boolean">==</span> <a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types.NoType" title="NamesDefaults.this.global.NoType.type">NoType</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="../../../Option.scala.html#scala.None" title="None.type">None</a>
        <span class="delimiter">}</span> else <span class="delimiter">{</span>
          val <a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.module">module</a> = <a href="Namers.scala.html#scala.tools.nsc.typechecker;Namers.companionSymbolOf" title="(original: NamesDefaults.this.global.Symbol, ctx: NamesDefaults.this.Context)NamesDefaults.this.global.Symbol">companionSymbolOf</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun" title="NamesDefaults.this.global.Tree">baseFun</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; NamesDefaults.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.context" title="NamesDefaults.this.Context">context</a><span class="delimiter">)</span>
          if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.module" title="NamesDefaults.this.global.Symbol">module</a> <span title="(x$1: Any)Boolean">==</span> <a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; NamesDefaults.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../../../Option.scala.html#scala.None" title="None.type">None</a>
          else <span class="delimiter">{</span>
            val <a title="NamesDefaults.this.global.gen.global.RefTree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.ref">ref</a> = <a href="../../../reflect/internal/Positions.scala.html#scala.reflect.internal;Positions.atPos" title="(pos: NamesDefaults.this.global.Position)(tree: NamesDefaults.this.global.gen.global.RefTree)NamesDefaults.this.global.gen.global.RefTree">atPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.pos" title="NamesDefaults.this.global.Position">pos</a>.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;InternalPositionImpl.focus" title="=&gt; scala.reflect.internal.util.Position">focus</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../Global.scala.html#scala.tools.nsc;Global.gen" title="NamesDefaults.this.global.gen.type">gen</a>.<a href="../../../reflect/internal/TreeGen.scala.html#scala.reflect.internal;TreeGen.mkAttributedRef(a17da71aaa)" title="(pre: NamesDefaults.this.global.gen.global.Type, sym: NamesDefaults.this.global.gen.global.Symbol)NamesDefaults.this.global.gen.global.RefTree">mkAttributedRef</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.pre" title="NamesDefaults.this.global.Type">pre</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.module" title="NamesDefaults.this.global.Symbol">module</a><span class="delimiter">)</span><span class="delimiter">)</span>
            if <span class="delimiter">(</span><a href="../ast/Trees.scala.html#scala.tools.nsc.ast;Trees.treeInfo" title="NamesDefaults.this.global.treeInfo.type">treeInfo</a>.<a href="../../../reflect/internal/TreeInfo.scala.html#scala.reflect.internal;TreeInfo.admitsTypeSelection" title="(tree: NamesDefaults.this.global.treeInfo.global.Tree)Boolean">admitsTypeSelection</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.ref" title="NamesDefaults.this.global.gen.global.RefTree">ref</a><span class="delimiter">)</span><span class="delimiter">)</span>  <span class="comment">// fixes #4524. the type checker does the same for</span>
              <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.ref" title="NamesDefaults.this.global.gen.global.RefTree">ref</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.setType" title="(tp: NamesDefaults.this.global.gen.global.Type)ref.type">setType</a><span class="delimiter">(</span><a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types.singleType" title="(pre: NamesDefaults.this.global.Type, sym: NamesDefaults.this.global.Symbol)NamesDefaults.this.global.Type">singleType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.pre" title="NamesDefaults.this.global.Type">pre</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.module" title="NamesDefaults.this.global.Symbol">module</a><span class="delimiter">)</span><span class="delimiter">)</span>  <span class="comment">// typedSelect, it calls &quot;stabilize&quot; on the result.</span>
            <a href="../../../Option.scala.html#scala;Some" title="(x: NamesDefaults.this.global.gen.global.RefTree)Some[NamesDefaults.this.global.gen.global.RefTree]">Some</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual.ref" title="NamesDefaults.this.global.gen.global.RefTree">ref</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun1" title="NamesDefaults.this.global.Tree">baseFun1</a> match <span class="delimiter">{</span>
        <span class="comment">// constructor calls</span>

        case Select<span class="delimiter">(</span>New<span class="delimiter">(</span><span title="NamesDefaults.this.global.TypeTree">tp</span> @ TypeTree<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> if <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.isConstr" title="Boolean">isConstr</a> =&gt;
          <span class="comment">// 'moduleQual' fixes #3338. Same qualifier for selecting the companion object as for the class.</span>
          <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier" title="(defaultQual: Option[NamesDefaults.this.global.Tree])NamesDefaults.this.global.Block">blockWithoutQualifier</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual" title="(pos: NamesDefaults.this.global.Position, classType: NamesDefaults.this.global.Type)Option[NamesDefaults.this.global.gen.global.RefTree]">moduleQual</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.TypeTree">tp</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>, <span title="NamesDefaults.this.global.TypeTree">tp</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case Select<span class="delimiter">(</span>TypeApply<span class="delimiter">(</span>New<span class="delimiter">(</span><span title="NamesDefaults.this.global.TypeTree">tp</span> @ TypeTree<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, _<span class="delimiter">)</span>, _<span class="delimiter">)</span> if <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.isConstr" title="Boolean">isConstr</a> =&gt;
          <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier" title="(defaultQual: Option[NamesDefaults.this.global.Tree])NamesDefaults.this.global.Block">blockWithoutQualifier</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual" title="(pos: NamesDefaults.this.global.Position, classType: NamesDefaults.this.global.Type)Option[NamesDefaults.this.global.gen.global.RefTree]">moduleQual</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.TypeTree">tp</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>, <span title="NamesDefaults.this.global.TypeTree">tp</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>

        case Select<span class="delimiter">(</span>New<span class="delimiter">(</span><span title="NamesDefaults.this.global.Ident">tp</span> @ Ident<span class="delimiter">(</span>_<span class="delimiter">)</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> if <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.isConstr" title="Boolean">isConstr</a> =&gt;
          <span class="comment">// 'moduleQual' fixes #3344</span>
          <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier" title="(defaultQual: Option[NamesDefaults.this.global.Tree])NamesDefaults.this.global.Block">blockWithoutQualifier</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual" title="(pos: NamesDefaults.this.global.Position, classType: NamesDefaults.this.global.Type)Option[NamesDefaults.this.global.gen.global.RefTree]">moduleQual</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Ident">tp</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>, <span title="NamesDefaults.this.global.Ident">tp</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case Select<span class="delimiter">(</span>TypeApply<span class="delimiter">(</span>New<span class="delimiter">(</span><span title="NamesDefaults.this.global.Ident">tp</span> @ Ident<span class="delimiter">(</span>_<span class="delimiter">)</span><span class="delimiter">)</span>, _<span class="delimiter">)</span>, _<span class="delimiter">)</span> if <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.isConstr" title="Boolean">isConstr</a> =&gt;
          <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier" title="(defaultQual: Option[NamesDefaults.this.global.Tree])NamesDefaults.this.global.Block">blockWithoutQualifier</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual" title="(pos: NamesDefaults.this.global.Position, classType: NamesDefaults.this.global.Type)Option[NamesDefaults.this.global.gen.global.RefTree]">moduleQual</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Ident">tp</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>, <span title="NamesDefaults.this.global.Ident">tp</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>

        case Select<span class="delimiter">(</span>New<span class="delimiter">(</span><span title="NamesDefaults.this.global.Select">tp</span> @ Select<span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">qual</span>, _<span class="delimiter">)</span><span class="delimiter">)</span>, _<span class="delimiter">)</span> if <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.isConstr" title="Boolean">isConstr</a> =&gt;
          <span class="comment">// in `new q.C()', q is always stable</span>
          <a href="../Global.scala.html#scala.tools.nsc;Global.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="../ast/Trees.scala.html#scala.tools.nsc.ast;Trees.treeInfo" title="NamesDefaults.this.global.treeInfo.type">treeInfo</a>.<a href="../../../reflect/internal/TreeInfo.scala.html#scala.reflect.internal;TreeInfo.isExprSafeToInline" title="(tree: NamesDefaults.this.global.treeInfo.global.Tree)Boolean">isExprSafeToInline</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">qual</span><span class="delimiter">)</span>, <span title="NamesDefaults.this.global.Tree">qual</span><span class="delimiter">)</span>
          <span class="comment">// 'moduleQual' fixes #2057</span>
          <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier" title="(defaultQual: Option[NamesDefaults.this.global.Tree])NamesDefaults.this.global.Block">blockWithoutQualifier</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual" title="(pos: NamesDefaults.this.global.Position, classType: NamesDefaults.this.global.Type)Option[NamesDefaults.this.global.gen.global.RefTree]">moduleQual</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Select">tp</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>, <span title="NamesDefaults.this.global.Select">tp</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case Select<span class="delimiter">(</span>TypeApply<span class="delimiter">(</span>New<span class="delimiter">(</span><span title="NamesDefaults.this.global.Select">tp</span> @ Select<span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">qual</span>, _<span class="delimiter">)</span><span class="delimiter">)</span>, _<span class="delimiter">)</span>, _<span class="delimiter">)</span> if <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.isConstr" title="Boolean">isConstr</a> =&gt;
          <a href="../Global.scala.html#scala.tools.nsc;Global.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="../ast/Trees.scala.html#scala.tools.nsc.ast;Trees.treeInfo" title="NamesDefaults.this.global.treeInfo.type">treeInfo</a>.<a href="../../../reflect/internal/TreeInfo.scala.html#scala.reflect.internal;TreeInfo.isExprSafeToInline" title="(tree: NamesDefaults.this.global.treeInfo.global.Tree)Boolean">isExprSafeToInline</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">qual</span><span class="delimiter">)</span>, <span title="NamesDefaults.this.global.Tree">qual</span><span class="delimiter">)</span>
          <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier" title="(defaultQual: Option[NamesDefaults.this.global.Tree])NamesDefaults.this.global.Block">blockWithoutQualifier</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual" title="(pos: NamesDefaults.this.global.Position, classType: NamesDefaults.this.global.Type)Option[NamesDefaults.this.global.gen.global.RefTree]">moduleQual</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Select">tp</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>, <span title="NamesDefaults.this.global.Select">tp</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>

        <span class="comment">// super constructor calls</span>
        case Select<span class="delimiter">(</span><a title="NamesDefaults.this.global.Super" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.sp">sp</a> @ Super<span class="delimiter">(</span>_, _<span class="delimiter">)</span>, _<span class="delimiter">)</span> if <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.isConstr" title="Boolean">isConstr</a> =&gt;
          <span class="comment">// 'moduleQual' fixes #3207. selection of the companion module of the</span>
          <span class="comment">// superclass needs to have the same prefix as the superclass.</span>
          <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier" title="(defaultQual: Option[NamesDefaults.this.global.Tree])NamesDefaults.this.global.Block">blockWithoutQualifier</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual" title="(pos: NamesDefaults.this.global.Position, classType: NamesDefaults.this.global.Type)Option[NamesDefaults.this.global.gen.global.RefTree]">moduleQual</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.baseFun" title="NamesDefaults.this.global.Tree">baseFun</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.sp" title="NamesDefaults.this.global.Super">sp</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Super.symbol" title="=&gt; NamesDefaults.this.global.Symbol">symbol</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.firstParent" title="=&gt; NamesDefaults.this.global.Type">firstParent</a><span class="delimiter">)</span><span class="delimiter">)</span>

        <span class="comment">// self constructor calls (in secondary constructors)</span>
        case Select<span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">tp</span>, <span title="NamesDefaults.this.global.Name">name</span><span class="delimiter">)</span> if <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.isConstr" title="Boolean">isConstr</a> =&gt;
          <a href="../Global.scala.html#scala.tools.nsc;Global.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="../ast/Trees.scala.html#scala.tools.nsc.ast;Trees.treeInfo" title="NamesDefaults.this.global.treeInfo.type">treeInfo</a>.<a href="../../../reflect/internal/TreeInfo.scala.html#scala.reflect.internal;TreeInfo.isExprSafeToInline" title="(tree: NamesDefaults.this.global.treeInfo.global.Tree)Boolean">isExprSafeToInline</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">tp</span><span class="delimiter">)</span>, <span title="NamesDefaults.this.global.Tree">tp</span><span class="delimiter">)</span>
          <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier" title="(defaultQual: Option[NamesDefaults.this.global.Tree])NamesDefaults.this.global.Block">blockWithoutQualifier</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.moduleQual" title="(pos: NamesDefaults.this.global.Position, classType: NamesDefaults.this.global.Type)Option[NamesDefaults.this.global.gen.global.RefTree]">moduleQual</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">tp</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>, <span title="NamesDefaults.this.global.Tree">tp</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>

        <span class="comment">// other method calls</span>

        case Ident<span class="delimiter">(</span>_<span class="delimiter">)</span> =&gt;
          <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier" title="(defaultQual: Option[NamesDefaults.this.global.Tree])NamesDefaults.this.global.Block">blockWithoutQualifier</a><span class="delimiter">(</span><a href="../../../Option.scala.html#scala.None" title="None.type">None</a><span class="delimiter">)</span>

        case Select<span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">qual</span>, <span title="NamesDefaults.this.global.Name">name</span><span class="delimiter">)</span> =&gt;
          if <span class="delimiter">(</span><a href="../ast/Trees.scala.html#scala.tools.nsc.ast;Trees.treeInfo" title="NamesDefaults.this.global.treeInfo.type">treeInfo</a>.<a href="../../../reflect/internal/TreeInfo.scala.html#scala.reflect.internal;TreeInfo.isExprSafeToInline" title="(tree: NamesDefaults.this.global.treeInfo.global.Tree)Boolean">isExprSafeToInline</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">qual</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithoutQualifier" title="(defaultQual: Option[NamesDefaults.this.global.Tree])NamesDefaults.this.global.Block">blockWithoutQualifier</a><span class="delimiter">(</span><a href="../../../Option.scala.html#scala;Some" title="(x: NamesDefaults.this.global.Tree)Some[NamesDefaults.this.global.Tree]">Some</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">qual</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.duplicate" title="=&gt; qual.type">duplicate</a><span class="delimiter">)</span><span class="delimiter">)</span>
          else
            <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock.blockWithQualifier" title="(qual: NamesDefaults.this.global.Tree, selected: NamesDefaults.this.global.Name)NamesDefaults.this.global.Block">blockWithQualifier</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">qual</span>, <span title="NamesDefaults.this.global.Name">name</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/*
     * For each argument (arg: T), create a local value
     *  x$n: T = arg
     *
     * assumes &quot;args&quot; are typed. owner of the definitions in the block is the owner of
     * the block (see typedBlock), but the symbols have to be entered into the block's scope.
     *
     * For by-name parameters, create a value
     *  x$n: () =&gt; T = () =&gt; arg
     *
     * For Ident(&lt;unapply-selector&gt;) arguments, no ValDef is created (SI-3353).
     */</span>
    def <a title="(args: List[NamesDefaults.this.global.Tree], paramTypes: List[NamesDefaults.this.global.Type], blockTyper: NamesDefaults.this.Typer)List[Option[NamesDefaults.this.global.ValDef]]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs">argValDefs</a><span class="delimiter">(</span><a title="List[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.args">args</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[NamesDefaults.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="List[NamesDefaults.this.global.Type]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.paramTypes">paramTypes</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[NamesDefaults.this.global.Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="NamesDefaults.this.Typer" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.blockTyper">blockTyper</a>: <a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer" title="NamesDefaults.this.Typer">Typer</a><span class="delimiter">)</span>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Option[NamesDefaults.this.global.ValDef]]">List</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      val <a title="NamesDefaults.this.Context" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.context">context</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.blockTyper" title="NamesDefaults.this.Typer">blockTyper</a>.<a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.context" title="=&gt; NamesDefaults.this.Context">context</a>
      val <a title="List[Option[(NamesDefaults.this.global.TermSymbol, Boolean, Boolean)]]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs">symPs</a> = <a href="../../../reflect/internal/util/Collections.scala.html#scala.reflect.internal.util;Collections.map2" title="(xs1: List[NamesDefaults.this.global.Tree], xs2: List[NamesDefaults.this.global.Type])(f: (NamesDefaults.this.global.Tree, NamesDefaults.this.global.Type) =&gt; Option[(NamesDefaults.this.global.TermSymbol, Boolean, Boolean)])List[Option[(NamesDefaults.this.global.TermSymbol, Boolean, Boolean)]]">map2</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.args" title="List[NamesDefaults.this.global.Tree]">args</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.paramTypes" title="List[NamesDefaults.this.global.Type]">paramTypes</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.arg">arg</a>, <a title="NamesDefaults.this.global.Type" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.paramTpe">paramTpe</a><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.arg" title="NamesDefaults.this.global.Tree">arg</a> match <span class="delimiter">{</span>
        case Ident<span class="delimiter">(</span><a href="../../../reflect/internal/StdNames.scala.html#scala.reflect.internal;StdNames.nme" title="NamesDefaults.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/StdNames.scala.html#scala.reflect.internal;StdNames;TermNames.SELECTOR_DUMMY" title="=&gt; NamesDefaults.this.global.nme.NameType">SELECTOR_DUMMY</a><span class="delimiter">)</span> =&gt;
          <a href="../../../Option.scala.html#scala.None" title="None.type">None</a> <span class="comment">// don't create a local ValDef if the argument is &lt;unapply-selector&gt;</span>
        case _ =&gt;
          val <a title="Boolean" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.byName">byName</a>   = <a href="../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isByNameParamType" title="(tp: NamesDefaults.this.global.Type)Boolean">isByNameParamType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.paramTpe" title="NamesDefaults.this.global.Type">paramTpe</a><span class="delimiter">)</span>
          val <a title="Boolean" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.repeated">repeated</a> = <a href="../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.isScalaRepeatedParamType" title="(tp: NamesDefaults.this.global.Type)Boolean">isScalaRepeatedParamType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.paramTpe" title="NamesDefaults.this.global.Type">paramTpe</a><span class="delimiter">)</span>
          val <a title="NamesDefaults.this.global.treeInfo.global.Type" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.argTpe">argTpe</a> = <span class="delimiter">(</span>
            if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.repeated" title="Boolean">repeated</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.arg" title="NamesDefaults.this.global.Tree">arg</a> match <span class="delimiter">{</span>
              case <a href="../../../reflect/internal/TreeInfo.scala.html#scala.reflect.internal;TreeInfo.WildcardStarArg.unapply" title="(tree: NamesDefaults.this.global.treeInfo.global.Tree)Option[NamesDefaults.this.global.treeInfo.global.Tree]">WildcardStarArg</a><span class="delimiter">(</span><a title="NamesDefaults.this.global.treeInfo.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.argTpe.expr">expr</a><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.argTpe.expr" title="NamesDefaults.this.global.treeInfo.global.Tree">expr</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.treeInfo.global.Type">tpe</a>
              case _                     =&gt; <a href="../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.seqType" title="(arg: NamesDefaults.this.global.Type)NamesDefaults.this.global.Type">seqType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.arg" title="NamesDefaults.this.global.Tree">arg</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
            else <span class="delimiter">{</span>
              <span class="comment">// TODO In 83c9c764b, we tried to a stable type here to fix SI-7234. But the resulting TypeTree over a</span>
              <span class="comment">//      singleton type without an original TypeTree fails to retypecheck after a resetAttrs (SI-7516),</span>
              <span class="comment">//      which is important for (at least) macros.</span>
              <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.arg" title="NamesDefaults.this.global.Tree">arg</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a>
            <span class="delimiter">}</span>
          <span class="delimiter">)</span>.<a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.widen" title="=&gt; NamesDefaults.this.global.treeInfo.global.Type">widen</a> <span class="comment">// have to widen or types inferred from literal defaults will be singletons</span>
          val s = <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.newValue" title="(name: NamesDefaults.this.global.TermName, pos: NamesDefaults.this.global.Position, newFlags: Long)NamesDefaults.this.global.TermSymbol">newValue</a><span class="delimiter">(</span><a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.unit" title="=&gt; NamesDefaults.this.global.CompilationUnit">unit</a>.<a href="../CompilationUnits.scala.html#scala.tools.nsc;CompilationUnits;CompilationUnit.freshTermName" title="(prefix: String)NamesDefaults.this.global.TermName">freshTermName</a><span class="delimiter">(</span><a href="../../../reflect/internal/StdNames.scala.html#scala.reflect.internal;StdNames.nme" title="NamesDefaults.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/StdNames.scala.html#scala.reflect.internal;StdNames;TermNames.NAMEDARG_PREFIX" title="=&gt; String">NAMEDARG_PREFIX</a><span class="delimiter">)</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.arg" title="NamesDefaults.this.global.Tree">arg</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>, newFlags = <span title="Long(70368744177664L)">ARTIFACT</span><span class="delimiter">)</span> <a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="NamesDefaults.this.global.TermSymbol" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.s">setInfo</a> <span class="delimiter">{</span>
            val <a title="NamesDefaults.this.global.Type" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.s.tp">tp</a> = if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.byName" title="Boolean">byName</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.functionType" title="(formals: List[NamesDefaults.this.global.Type], restpe: NamesDefaults.this.global.Type)NamesDefaults.this.global.Type">functionType</a><span class="delimiter">(</span><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.argTpe" title="NamesDefaults.this.global.treeInfo.global.Type">argTpe</a><span class="delimiter">)</span> else <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.argTpe" title="NamesDefaults.this.global.treeInfo.global.Type">argTpe</a>
            <a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types.uncheckedBounds" title="(tp: NamesDefaults.this.global.Type)NamesDefaults.this.global.Type">uncheckedBounds</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.s.tp" title="NamesDefaults.this.global.Type">tp</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <a href="../../../Option.scala.html#scala;Some" title="(x: (NamesDefaults.this.global.TermSymbol, Boolean, Boolean))Some[(NamesDefaults.this.global.TermSymbol, Boolean, Boolean)]">Some</a><span class="delimiter">(</span><a href="../../../Tuple3.scala.html#scala;Tuple3" title="(_1: NamesDefaults.this.global.TermSymbol, _2: Boolean, _3: Boolean)(NamesDefaults.this.global.TermSymbol, Boolean, Boolean)" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.scope" title="=&gt; NamesDefaults.this.global.Scope">scope</a>.<a href="../../../reflect/internal/Scopes.scala.html#scala.reflect.internal;Scopes;Scope.enter" title="(sym: NamesDefaults.this.global.TermSymbol)NamesDefaults.this.global.TermSymbol">enter</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.s" title="NamesDefaults.this.global.TermSymbol">s</a><span class="delimiter">)</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.byName" title="Boolean">byName</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs.$anonfun.repeated" title="Boolean">repeated</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span><span class="delimiter">)</span>
      <a href="../../../reflect/internal/util/Collections.scala.html#scala.reflect.internal.util;Collections.map2" title="(xs1: List[Option[(NamesDefaults.this.global.TermSymbol, Boolean, Boolean)]], xs2: List[NamesDefaults.this.global.Tree])(f: (Option[(NamesDefaults.this.global.TermSymbol, Boolean, Boolean)], NamesDefaults.this.global.Tree) =&gt; Option[NamesDefaults.this.global.ValDef])List[Option[NamesDefaults.this.global.ValDef]]">map2</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.symPs" title="List[Option[(NamesDefaults.this.global.TermSymbol, Boolean, Boolean)]]">symPs</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.args" title="List[NamesDefaults.this.global.Tree]">args</a><span class="delimiter">)</span> <a href="../../../Tuple2.scala.html#scala;Tuple2" title="Option[NamesDefaults.this.global.ValDef]" class="delimiter">{</a>
        case <span class="delimiter">(</span><a href="../../../Option.scala.html#scala.None" title="None.type">None</a>, _<span class="delimiter">)</span> =&gt; <a href="../../../Option.scala.html#scala.None" title="None.type">None</a>
        case <span class="delimiter">(</span>Some<span class="delimiter">(</span><span class="delimiter">(</span><a title="NamesDefaults.this.global.TermSymbol" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.sym">sym</a>, <a title="Boolean" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.byName">byName</a>, <a title="Boolean" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.repeated">repeated</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.arg">arg</a><span class="delimiter">)</span> =&gt;
          val <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.body">body</a> =
            if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.byName" title="Boolean">byName</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              val <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.body.res">res</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.blockTyper" title="NamesDefaults.this.Typer">blockTyper</a>.<a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.typed(60ebfc8632)" title="(tree: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Tree">typed</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Function" title="(vparams: List[NamesDefaults.this.global.ValDef], body: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Function">Function</a><span class="delimiter">(</span>List<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type" class="delimiter">(</a><span class="delimiter">)</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.arg" title="NamesDefaults.this.global.Tree">arg</a><span class="delimiter">)</span><span class="delimiter">)</span>
              new <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;ChangeOwnerTraverser" title="NamesDefaults.this.global.ChangeOwnerTraverser">ChangeOwnerTraverser</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.body.res" title="NamesDefaults.this.global.Tree">res</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; NamesDefaults.this.global.Symbol">symbol</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;ChangeOwnerTraverser.traverse" title="(tree: NamesDefaults.this.global.Tree)Unit">traverse</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.arg" title="NamesDefaults.this.global.Tree">arg</a> <span class="comment">// fixes #2290</span>
              <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.body.res" title="NamesDefaults.this.global.Tree">res</a>
            <span class="delimiter">}</span> else <span class="delimiter">{</span>
              new <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;ChangeOwnerTraverser" title="NamesDefaults.this.global.ChangeOwnerTraverser">ChangeOwnerTraverser</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.sym" title="NamesDefaults.this.global.TermSymbol">sym</a><span class="delimiter">)</span> <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;ChangeOwnerTraverser.traverse" title="(tree: NamesDefaults.this.global.Tree)Unit">traverse</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.arg" title="NamesDefaults.this.global.Tree">arg</a> <span class="comment">// fixes #4502</span>
              if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.repeated" title="Boolean">repeated</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.arg" title="NamesDefaults.this.global.Tree">arg</a> match <span class="delimiter">{</span>
                case <a href="../../../reflect/internal/TreeInfo.scala.html#scala.reflect.internal;TreeInfo.WildcardStarArg.unapply" title="(tree: NamesDefaults.this.global.treeInfo.global.Tree)Option[NamesDefaults.this.global.treeInfo.global.Tree]">WildcardStarArg</a><span class="delimiter">(</span><a title="NamesDefaults.this.global.treeInfo.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.body.expr">expr</a><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.body.expr" title="NamesDefaults.this.global.treeInfo.global.Tree">expr</a>
                case _                     =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.blockTyper" title="NamesDefaults.this.Typer">blockTyper</a> <a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.typed(60ebfc8632)" title="(tree: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Tree">typed</a> <a href="../Global.scala.html#scala.tools.nsc;Global.gen" title="NamesDefaults.this.global.gen.type">gen</a>.<a href="../../../reflect/internal/TreeGen.scala.html#scala.reflect.internal;TreeGen.mkSeqApply" title="(arg: NamesDefaults.this.global.gen.global.Tree)NamesDefaults.this.global.gen.global.Apply">mkSeqApply</a><span class="delimiter">(</span><a href="../ast/Trees.scala.html#scala.tools.nsc.ast;Trees.resetAttrs" title="(x: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Tree">resetAttrs</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.arg" title="NamesDefaults.this.global.Tree">arg</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="delimiter">}</span> else <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.arg" title="NamesDefaults.this.global.Tree">arg</a>
            <span class="delimiter">}</span>
          <a href="../../../Option.scala.html#scala;Some" title="(x: NamesDefaults.this.global.ValDef)Some[NamesDefaults.this.global.ValDef]">Some</a><span class="delimiter">(</span><a href="../../../reflect/internal/Positions.scala.html#scala.reflect.internal;Positions.atPos" title="(pos: NamesDefaults.this.global.Position)(tree: NamesDefaults.this.global.ValDef)NamesDefaults.this.global.ValDef">atPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.body" title="NamesDefaults.this.global.Tree">body</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees.ValDef.apply(9493665b33)" title="(sym: NamesDefaults.this.global.Symbol, rhs: NamesDefaults.this.global.Tree)NamesDefaults.this.global.ValDef">ValDef</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.sym" title="NamesDefaults.this.global.TermSymbol">sym</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs.$anonfun.body" title="NamesDefaults.this.global.Tree">body</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.setType" title="(tp: NamesDefaults.this.global.Type)NamesDefaults.this.global.ValDef">setType</a><span class="delimiter">(</span><a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types.NoType" title="NamesDefaults.this.global.NoType.type">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">// begin transform</span>
    if <span class="delimiter">(</span><a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.isNamedApplyBlock" title="(tree: NamesDefaults.this.global.Tree)Boolean">isNamedApplyBlock</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.tree" title="NamesDefaults.this.global.Tree">tree</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.namedApplyBlockInfo" title="=&gt; Option[(NamesDefaults.this.global.Tree, NamesDefaults.this.NamedApplyInfo)]">namedApplyBlockInfo</a>.<a href="../../../Option.scala.html#scala;Option.get" title="=&gt; (NamesDefaults.this.global.Tree, NamesDefaults.this.NamedApplyInfo)">get</a>.<a href="../../../Tuple2.scala.html#scala;Tuple2._1" title="=&gt; NamesDefaults.this.global.Tree">_1</a>
    <span class="delimiter">}</span> else <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.tree" title="NamesDefaults.this.global.Tree">tree</a> match <span class="delimiter">{</span>
      <span class="comment">// `fun` is typed. `namelessArgs` might be typed or not, if they are types are kept.</span>
      case Apply<span class="delimiter">(</span><a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.fun">fun</a>, <a title="List[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.namelessArgs">namelessArgs</a><span class="delimiter">)</span> =&gt;
        val <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.transformedFun">transformedFun</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication" title="(typer: NamesDefaults.this.Typer, mode: scala.tools.nsc.Mode, pt: NamesDefaults.this.global.Type)(tree: NamesDefaults.this.global.Tree, argPos: Int =&gt; Int)NamesDefaults.this.global.Tree">transformNamedApplication</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.typer" title="NamesDefaults.this.Typer">typer</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.mode" title="scala.tools.nsc.Mode">mode</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.pt" title="NamesDefaults.this.global.Type">pt</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.fun" title="NamesDefaults.this.global.Tree">fun</a>, <a title="Int" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.transformedFun.$anonfun.x">x</a> =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.transformedFun.$anonfun.x" title="Int">x</a><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.transformedFun" title="NamesDefaults.this.global.Tree">transformedFun</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;TreeContextApiImpl.isErroneous" title="=&gt; Boolean">isErroneous</a><span class="delimiter">)</span> <a href="Infer.scala.html#scala.tools.nsc.typechecker;Infer;Inferencer.setError" title="(tree: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Tree">setError</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.tree" title="NamesDefaults.this.global.Tree">tree</a><span class="delimiter">)</span>
        else <span class="delimiter">{</span>
          <a href="../Global.scala.html#scala.tools.nsc;Global.assert(0f40bc559c)" title="(assertion: Boolean, message: =&gt; Any)Unit">assert</a><span class="delimiter">(</span><a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.isNamedApplyBlock" title="(tree: NamesDefaults.this.global.Tree)Boolean">isNamedApplyBlock</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.transformedFun" title="NamesDefaults.this.global.Tree">transformedFun</a><span class="delimiter">)</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.transformedFun" title="NamesDefaults.this.global.Tree">transformedFun</a><span class="delimiter">)</span>
          val NamedApplyInfo<a href="../../../Tuple4.scala.html#scala;Tuple4" title="(Option[NamesDefaults.this.global.Tree], List[NamesDefaults.this.global.Tree], List[List[NamesDefaults.this.global.Tree]], NamesDefaults.this.Typer)" class="delimiter">(</a><a href="../../../Tuple4.scala.html#scala;Tuple4._1" title="Option[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.qual">qual</a>, <a href="../../../Tuple4.scala.html#scala;Tuple4._2" title="List[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.targs">targs</a>, <a href="../../../Tuple4.scala.html#scala;Tuple4._3" title="List[List[NamesDefaults.this.global.Tree]]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.vargss">vargss</a>, <a href="../../../Tuple4.scala.html#scala;Tuple4._4" title="NamesDefaults.this.Typer" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.blockTyper">blockTyper</a><span class="delimiter">)</span> =
            <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.namedApplyBlockInfo" title="=&gt; Option[(NamesDefaults.this.global.Tree, NamesDefaults.this.NamedApplyInfo)]">namedApplyBlockInfo</a>.<a href="../../../Option.scala.html#scala;Option.get" title="=&gt; (NamesDefaults.this.global.Tree, NamesDefaults.this.NamedApplyInfo)">get</a>.<a href="../../../Tuple2.scala.html#scala;Tuple2._2" title="=&gt; NamesDefaults.this.NamedApplyInfo">_2</a>
          val Block<a href="../../../Tuple2.scala.html#scala;Tuple2" title="(List[NamesDefaults.this.global.Tree], NamesDefaults.this.global.Tree)" class="delimiter">(</a><a href="../../../Tuple2.scala.html#scala;Tuple2._1" title="List[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.stats">stats</a>, <a href="../../../Tuple2.scala.html#scala;Tuple2._2" title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.funOnly">funOnly</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.transformedFun" title="NamesDefaults.this.global.Tree">transformedFun</a>

          <span class="comment">// type the application without names; put the arguments in definition-site order</span>
          val <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.typedApp">typedApp</a> = <a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.doTypedApply" title="(tree: NamesDefaults.this.global.Tree, fun0: NamesDefaults.this.global.Tree, args: List[NamesDefaults.this.global.Tree], mode: scala.tools.nsc.Mode, pt: NamesDefaults.this.global.Type)NamesDefaults.this.global.Tree">doTypedApply</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.tree" title="NamesDefaults.this.global.Tree">tree</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.funOnly" title="NamesDefaults.this.global.Tree">funOnly</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.reorderArgs" title="(args: List[NamesDefaults.this.global.Tree], pos: Int =&gt; Int)(implicit evidence$1: scala.reflect.ClassTag[NamesDefaults.this.global.Tree])List[NamesDefaults.this.global.Tree]">reorderArgs</a><a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees.TreeTag" title="=&gt; scala.reflect.ClassTag[NamesDefaults.this.global.Tree]" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.namelessArgs" title="List[NamesDefaults.this.global.Tree]">namelessArgs</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argPos" title="Int =&gt; Int">argPos</a><span class="delimiter">)</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.mode" title="scala.tools.nsc.Mode">mode</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.pt" title="NamesDefaults.this.global.Type">pt</a><span class="delimiter">)</span>
          <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.typedApp" title="NamesDefaults.this.global.Tree">typedApp</a> match <span class="delimiter">{</span>
            case Apply<span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">expr</span>, <span title="List[NamesDefaults.this.global.Tree]">typedArgs</span><span class="delimiter">)</span> if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.typedApp" title="NamesDefaults.this.global.Tree">typedApp</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: NamesDefaults.this.global.Tree)List[NamesDefaults.this.global.Tree]">::</a> <span title="List[NamesDefaults.this.global.Tree]">typedArgs</span><span class="delimiter">)</span>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.exists" title="(p: NamesDefaults.this.global.Tree =&gt; Boolean)Boolean">exists</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.$anonfun.x$6" title="NamesDefaults.this.global.Tree">_</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;TreeContextApiImpl.isErrorTyped" title="=&gt; Boolean">isErrorTyped</a><span class="delimiter">)</span> =&gt;
              <a href="Infer.scala.html#scala.tools.nsc.typechecker;Infer;Inferencer.setError" title="(tree: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Tree">setError</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.tree" title="NamesDefaults.this.global.Tree">tree</a><span class="delimiter">)</span> <span class="comment">// bail out with and erroneous Apply *or* erroneous arguments, see SI-7238, SI-7509</span>
            case Apply<span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">expr</span>, <span title="List[NamesDefaults.this.global.Tree]">typedArgs</span><span class="delimiter">)</span> =&gt;
              <span class="comment">// Extract the typed arguments, restore the call-site evaluation order (using</span>
              <span class="comment">// ValDef's in the block), change the arguments to these local values.</span>

              <span class="comment">// typedArgs: definition-site order</span>
              val <a title="List[NamesDefaults.this.global.Type]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.formals">formals</a> = <a href="Infer.scala.html#scala.tools.nsc.typechecker;Infer.formalTypes" title="(formals: List[NamesDefaults.this.global.Type], numArgs: Int, removeByName: Boolean, removeRepeated: Boolean)List[NamesDefaults.this.global.Type]">formalTypes</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">expr</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.paramTypes" title="=&gt; List[NamesDefaults.this.global.Type]">paramTypes</a>, <span title="List[NamesDefaults.this.global.Tree]">typedArgs</span>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.length" title="=&gt; Int">length</a>, removeByName = false, removeRepeated = false<span class="delimiter">)</span>
              <span class="comment">// valDefs: call-site order</span>
              val <a title="List[Option[NamesDefaults.this.global.ValDef]]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.valDefs">valDefs</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argValDefs" title="(args: List[NamesDefaults.this.global.Tree], paramTypes: List[NamesDefaults.this.global.Type], blockTyper: NamesDefaults.this.Typer)List[Option[NamesDefaults.this.global.ValDef]]">argValDefs</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.reorderArgsInv" title="(args: List[NamesDefaults.this.global.Tree], pos: Int =&gt; Int)(implicit evidence$2: scala.reflect.ClassTag[NamesDefaults.this.global.Tree])List[NamesDefaults.this.global.Tree]">reorderArgsInv</a><a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees.TreeTag" title="=&gt; scala.reflect.ClassTag[NamesDefaults.this.global.Tree]" class="delimiter">(</a><span title="List[NamesDefaults.this.global.Tree]">typedArgs</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argPos" title="Int =&gt; Int">argPos</a><span class="delimiter">)</span>,
                                       <a href="#scala.tools.nsc.typechecker;NamesDefaults.reorderArgsInv" title="(args: List[NamesDefaults.this.global.Type], pos: Int =&gt; Int)(implicit evidence$2: scala.reflect.ClassTag[NamesDefaults.this.global.Type])List[NamesDefaults.this.global.Type]">reorderArgsInv</a><a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types.TypeTagg" title="=&gt; scala.reflect.ClassTag[NamesDefaults.this.global.Type]" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.formals" title="List[NamesDefaults.this.global.Type]">formals</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argPos" title="Int =&gt; Int">argPos</a><span class="delimiter">)</span>,
                                       <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.blockTyper" title="NamesDefaults.this.Typer">blockTyper</a><span class="delimiter">)</span>
              <span class="comment">// refArgs: definition-site order again</span>
              val <a title="List[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs">refArgs</a> = <a href="../../../reflect/internal/util/Collections.scala.html#scala.reflect.internal.util;Collections.map3" title="(xs1: List[Option[NamesDefaults.this.global.ValDef]], xs2: List[NamesDefaults.this.global.Type], xs3: List[NamesDefaults.this.global.Tree])(f: (Option[NamesDefaults.this.global.ValDef], NamesDefaults.this.global.Type, NamesDefaults.this.global.Tree) =&gt; NamesDefaults.this.global.Tree)List[NamesDefaults.this.global.Tree]">map3</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.reorderArgs" title="(args: List[Option[NamesDefaults.this.global.ValDef]], pos: Int =&gt; Int)(implicit evidence$1: scala.reflect.ClassTag[Option[NamesDefaults.this.global.ValDef]])List[Option[NamesDefaults.this.global.ValDef]]">reorderArgs</a><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(runtimeClass1: Class[_])scala.reflect.ClassTag[Option[NamesDefaults.this.global.ValDef]]" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.valDefs" title="List[Option[NamesDefaults.this.global.ValDef]]">valDefs</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.argPos" title="Int =&gt; Int">argPos</a><span class="delimiter">)</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.formals" title="List[NamesDefaults.this.global.Type]">formals</a>, <span title="List[NamesDefaults.this.global.Tree]">typedArgs</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Option[NamesDefaults.this.global.ValDef]" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs.$anonfun.vDefOpt">vDefOpt</a>, <a title="NamesDefaults.this.global.Type" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs.$anonfun.tpe">tpe</a>, <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs.$anonfun.origArg">origArg</a><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs.$anonfun.vDefOpt" title="Option[NamesDefaults.this.global.ValDef]">vDefOpt</a> match <span class="delimiter">{</span>
                case <a href="../../../Option.scala.html#scala.None" title="None.type">None</a> =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs.$anonfun.origArg" title="NamesDefaults.this.global.Tree">origArg</a>
                case Some<span class="delimiter">(</span><a title="NamesDefaults.this.global.ValDef" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs.$anonfun.vDef">vDef</a><span class="delimiter">)</span> =&gt;
                  val <a title="NamesDefaults.this.global.gen.global.RefTree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs.$anonfun.ref">ref</a> = <a href="../Global.scala.html#scala.tools.nsc;Global.gen" title="NamesDefaults.this.global.gen.type">gen</a>.<a href="../../../reflect/internal/TreeGen.scala.html#scala.reflect.internal;TreeGen.mkAttributedRef(23ce0e46ac)" title="(sym: NamesDefaults.this.global.gen.global.Symbol)NamesDefaults.this.global.gen.global.RefTree">mkAttributedRef</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs.$anonfun.vDef" title="NamesDefaults.this.global.ValDef">vDef</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;SymTree.symbol" title="=&gt; NamesDefaults.this.global.Symbol">symbol</a><span class="delimiter">)</span>
                  <a href="../../../reflect/internal/Positions.scala.html#scala.reflect.internal;Positions.atPos" title="(pos: NamesDefaults.this.global.Position)(tree: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Tree">atPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs.$anonfun.vDef" title="NamesDefaults.this.global.ValDef">vDef</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;InternalPositionImpl.focus" title="=&gt; scala.reflect.internal.util.Position">focus</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="comment">// for by-name parameters, the local value is a nullary function returning the argument</span>
                    <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs.$anonfun.tpe" title="NamesDefaults.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; NamesDefaults.this.global.Symbol">typeSymbol</a> match <span class="delimiter">{</span>
                      case <a href="../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ByNameParamClass" title="=&gt; NamesDefaults.this.global.ClassSymbol">ByNameParamClass</a>   =&gt; <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Apply" title="(fun: NamesDefaults.this.global.Tree, args: List[NamesDefaults.this.global.Tree])NamesDefaults.this.global.Apply">Apply</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs.$anonfun.ref" title="NamesDefaults.this.global.gen.global.RefTree">ref</a>, <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
                      case <a href="../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.RepeatedParamClass" title="=&gt; NamesDefaults.this.global.ClassSymbol">RepeatedParamClass</a> =&gt; <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Typed" title="(expr: NamesDefaults.this.global.Tree, tpt: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Typed">Typed</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs.$anonfun.ref" title="NamesDefaults.this.global.gen.global.RefTree">ref</a>, <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Ident" title="(name: NamesDefaults.this.global.Name)NamesDefaults.this.global.Ident">Ident</a><span class="delimiter">(</span><a href="../../../reflect/internal/StdNames.scala.html#scala.reflect.internal;StdNames.tpnme" title="NamesDefaults.this.global.tpnme.type">tpnme</a>.<a href="../../../reflect/internal/StdNames.scala.html#scala.reflect.internal;StdNames;TypeNames.WILDCARD_STAR" title="=&gt; NamesDefaults.this.global.tpnme.NameType">WILDCARD_STAR</a><span class="delimiter">)</span><span class="delimiter">)</span>
                      case _                  =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs.$anonfun.ref" title="NamesDefaults.this.global.gen.global.RefTree">ref</a>
                    <span class="delimiter">}</span>
                  <span class="delimiter">}</span>
              <span class="delimiter">}</span><span class="delimiter">)</span>
              <span class="comment">// cannot call blockTyper.typedBlock here, because the method expr might be partially applied only</span>
              val <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.res">res</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.blockTyper" title="NamesDefaults.this.Typer">blockTyper</a>.<a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.doTypedApply" title="(tree: NamesDefaults.this.global.Tree, fun0: NamesDefaults.this.global.Tree, args: List[NamesDefaults.this.global.Tree], mode: scala.tools.nsc.Mode, pt: NamesDefaults.this.global.Type)NamesDefaults.this.global.Tree">doTypedApply</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.tree" title="NamesDefaults.this.global.Tree">tree</a>, <span title="NamesDefaults.this.global.Tree">expr</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs" title="List[NamesDefaults.this.global.Tree]">refArgs</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.mode" title="scala.tools.nsc.Mode">mode</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.pt" title="NamesDefaults.this.global.Type">pt</a><span class="delimiter">)</span>
              <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.res" title="NamesDefaults.this.global.Tree">res</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.setPos" title="(newpos: NamesDefaults.this.global.Position)res.type">setPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.res" title="NamesDefaults.this.global.Tree">res</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;InternalPositionImpl.makeTransparent" title="=&gt; scala.reflect.internal.util.Position">makeTransparent</a><span class="delimiter">)</span>
              val <a title="NamesDefaults.this.global.Block" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.block">block</a> = <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Block" title="(stats: List[NamesDefaults.this.global.Tree], expr: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Block">Block</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.stats" title="List[NamesDefaults.this.global.Tree]">stats</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.:::" title="(prefix: List[NamesDefaults.this.global.Tree])List[NamesDefaults.this.global.Tree]">:::</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.valDefs" title="List[Option[NamesDefaults.this.global.ValDef]]">valDefs</a>.<a href="../../../collection/generic/GenericTraversableTemplate.scala.html#scala.collection.generic;GenericTraversableTemplate.flatten" title="(implicit asTraversable: Option[NamesDefaults.this.global.ValDef] =&gt; scala.collection.GenTraversableOnce[NamesDefaults.this.global.ValDef])List[NamesDefaults.this.global.ValDef]">flatten</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.res" title="NamesDefaults.this.global.Tree">res</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.setType" title="(tp: NamesDefaults.this.global.Type)NamesDefaults.this.global.Block">setType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.res" title="NamesDefaults.this.global.Tree">res</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a><span class="delimiter">)</span>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.setPos" title="(newpos: scala.reflect.internal.util.Position)NamesDefaults.this.global.Block">setPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.tree" title="NamesDefaults.this.global.Tree">tree</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;InternalPositionImpl.makeTransparent" title="=&gt; scala.reflect.internal.util.Position">makeTransparent</a><span class="delimiter">)</span>
              <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.namedApplyBlockInfo_=" title="(x$1: Option[(NamesDefaults.this.global.Tree, NamesDefaults.this.NamedApplyInfo)])Unit">namedApplyBlockInfo</a> =
                <a href="../../../Option.scala.html#scala;Some" title="(x: (NamesDefaults.this.global.Block, NamesDefaults.this.NamedApplyInfo))Some[(NamesDefaults.this.global.Block, NamesDefaults.this.NamedApplyInfo)]">Some</a><span class="delimiter">(</span><a href="../../../Tuple2.scala.html#scala;Tuple2" title="(_1: NamesDefaults.this.global.Block, _2: NamesDefaults.this.NamedApplyInfo)(NamesDefaults.this.global.Block, NamesDefaults.this.NamedApplyInfo)" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.block" title="NamesDefaults.this.global.Block">block</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.NamedApplyInfo.readResolve" title="(qual: Option[NamesDefaults.this.global.Tree], targs: List[NamesDefaults.this.global.Tree], vargss: List[List[NamesDefaults.this.global.Tree]], blockTyper: NamesDefaults.this.Typer)NamesDefaults.this.NamedApplyInfo">NamedApplyInfo</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.qual" title="Option[NamesDefaults.this.global.Tree]">qual</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.targs" title="List[NamesDefaults.this.global.Tree]">targs</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.vargss" title="List[List[NamesDefaults.this.global.Tree]]">vargss</a> <a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.:+" title="(elem: List[NamesDefaults.this.global.Tree])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[NamesDefaults.this.global.Tree]],List[NamesDefaults.this.global.Tree],List[List[NamesDefaults.this.global.Tree]]])List[List[NamesDefaults.this.global.Tree]]">:+</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.refArgs" title="List[NamesDefaults.this.global.Tree]">refArgs</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.blockTyper" title="NamesDefaults.this.Typer">blockTyper</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.block" title="NamesDefaults.this.global.Block">block</a>
            case _ =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.tree" title="NamesDefaults.this.global.Tree">tree</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>

      case <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFun">baseFun</a> =&gt; <span class="comment">// also treats &quot;case TypeApply(fun, targs)&quot; and &quot;case Select(New(..), &lt;init&gt;)&quot;</span>
        <a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFunBlock" title="(baseFun: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Tree">baseFunBlock</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.transformNamedApplication.baseFun" title="NamesDefaults.this.global.Tree">baseFun</a><span class="delimiter">)</span>

    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(syms: List[NamesDefaults.this.global.Symbol])List[NamesDefaults.this.global.NamedType]" id="scala.tools.nsc.typechecker;NamesDefaults.makeNamedTypes">makeNamedTypes</a><span class="delimiter">(</span><a title="List[NamesDefaults.this.global.Symbol]" id="scala.tools.nsc.typechecker;NamesDefaults.makeNamedTypes.syms">syms</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[NamesDefaults.this.global.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.makeNamedTypes.syms" title="List[NamesDefaults.this.global.Symbol]">syms</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: NamesDefaults.this.global.Symbol =&gt; NamesDefaults.this.global.NamedType)(implicit bf: scala.collection.generic.CanBuildFrom[List[NamesDefaults.this.global.Symbol],NamesDefaults.this.global.NamedType,List[NamesDefaults.this.global.NamedType]])List[NamesDefaults.this.global.NamedType]">map</a> <span class="delimiter">(</span><a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.makeNamedTypes.$anonfun.sym">sym</a> =&gt; <a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;NamedType" title="(name: NamesDefaults.this.global.Name, tp: NamesDefaults.this.global.Type)NamesDefaults.this.global.NamedType">NamedType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.makeNamedTypes.$anonfun.sym" title="NamesDefaults.this.global.Symbol">sym</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym.NameType">name</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.makeNamedTypes.$anonfun.sym" title="NamesDefaults.this.global.Symbol">sym</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the parameter symbols of an invocation expression that are not defined by the list
   * of arguments.
   *
   * @param args    The list of arguments
   * @param params  The list of parameter sybols of the invoked method
   * @param argName A function that extracts the name of an argument expression, if it is a named argument.
   */</span>
  def <a title="[T](args: List[T], params: List[NamesDefaults.this.global.Symbol], argName: T =&gt; Option[NamesDefaults.this.global.Name])(List[NamesDefaults.this.global.Symbol], Boolean)" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams">missingParams</a><span class="delimiter">[</span><a title="" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[T]" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams.args">args</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[T]">List</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="List[NamesDefaults.this.global.Symbol]" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams.params">params</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[NamesDefaults.this.global.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, <a title="T =&gt; Option[NamesDefaults.this.global.Name]" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams.argName">argName</a>: T =&gt; Option<span class="delimiter">[</span>Name<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Tuple2.scala.html#scala;Tuple2" title="(List[NamesDefaults.this.global.Symbol], Boolean)" class="delimiter">(</a>List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span>, Boolean<span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="comment">// The argument list contains first a mix of positional args and named args that are on the</span>
    <span class="comment">// right parameter position, and then a number or named args on different positions.</span>

    <span class="comment">// collect all named arguments whose position does not match the parameter they define</span>
    val namedArgsOnChangedPosition = <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.args" title="List[T]">args</a>.<a href="../../../collection/IterableLike.scala.html#scala.collection;IterableLike.zip" title="(that: scala.collection.GenIterable[NamesDefaults.this.global.Symbol])(implicit bf: scala.collection.generic.CanBuildFrom[List[T],(T, NamesDefaults.this.global.Symbol),List[(T, NamesDefaults.this.global.Symbol)]])List[(T, NamesDefaults.this.global.Symbol)]">zip</a><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.List.canBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,(T, NamesDefaults.this.global.Symbol),List[(T, NamesDefaults.this.global.Symbol)]]" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.params" title="List[NamesDefaults.this.global.Symbol]">params</a><span class="delimiter">)</span> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.dropWhile" title="(p: ((T, NamesDefaults.this.global.Symbol)) =&gt; Boolean)List[(T, NamesDefaults.this.global.Symbol)]">dropWhile</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.namedArgsOnChangedPosition.$anonfun.x0$2" title="Boolean" class="delimiter">{</a>
      case <span class="delimiter">(</span><a title="T" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams.namedArgsOnChangedPosition.$anonfun.arg">arg</a>, <a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams.namedArgsOnChangedPosition.$anonfun.param">param</a><span class="delimiter">)</span> =&gt;
        val <a title="Option[NamesDefaults.this.global.Name]" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams.namedArgsOnChangedPosition.$anonfun.n">n</a> = <a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: T)Option[NamesDefaults.this.global.Name]">argName</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.namedArgsOnChangedPosition.$anonfun.arg" title="T">arg</a><span class="delimiter">)</span>
        <span class="comment">// drop the argument if</span>
        <span class="comment">//  - it's not named, or</span>
        <span class="comment">//  - it's named, but defines the parameter on its current position, or</span>
        <span class="comment">//  - it's named, but none of the parameter names matches (treated as a positional argument, an assignment expression)</span>
        <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.namedArgsOnChangedPosition.$anonfun.n" title="Option[NamesDefaults.this.global.Name]">n</a>.<a href="../../../Option.scala.html#scala;Option.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.namedArgsOnChangedPosition.$anonfun.n" title="Option[NamesDefaults.this.global.Name]">n</a>.<a href="../../../Option.scala.html#scala;Option.get" title="=&gt; NamesDefaults.this.global.Name">get</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.namedArgsOnChangedPosition.$anonfun.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; param.NameType">name</a> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.params" title="List[NamesDefaults.this.global.Symbol]">params</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: NamesDefaults.this.global.Symbol =&gt; Boolean)Boolean">forall</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.namedArgsOnChangedPosition.$anonfun.$anonfun.x$8" title="NamesDefaults.this.global.Symbol">_</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; x$8.NameType">name</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.namedArgsOnChangedPosition.$anonfun.n" title="Option[NamesDefaults.this.global.Name]">n</a>.<a href="../../../Option.scala.html#scala;Option.get" title="=&gt; NamesDefaults.this.global.Name">get</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="List[T]" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams.namedArgsOnChangedPosition">map</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.namedArgsOnChangedPosition.$anonfun.x$9" title="(T, NamesDefaults.this.global.Symbol)">_</a>.<a href="../../../Tuple2.scala.html#scala;Tuple2._1" title="=&gt; T">_1</a><span class="delimiter">)</span>

    val <a title="List[NamesDefaults.this.global.Symbol]" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams.paramsWithoutPositionalArg">paramsWithoutPositionalArg</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.params" title="List[NamesDefaults.this.global.Symbol]">params</a>.<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.drop" title="(n: Int)List[NamesDefaults.this.global.Symbol]">drop</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.args" title="List[T]">args</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.length" title="=&gt; Int">length</a> <a href="../../../Int.scala.html#scala;Int.-(1409840560)" title="(x: Int)Int">-</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.namedArgsOnChangedPosition" title="List[T]">namedArgsOnChangedPosition</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.length" title="=&gt; Int">length</a><span class="delimiter">)</span>

    <span class="comment">// missing parameters: those with a name which is not specified in one of the namedArgsOnChangedPosition</span>
    val <a title="List[NamesDefaults.this.global.Symbol]" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams.missingParams">missingParams</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.paramsWithoutPositionalArg" title="List[NamesDefaults.this.global.Symbol]">paramsWithoutPositionalArg</a>.<a href="../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filter" title="(p: NamesDefaults.this.global.Symbol =&gt; Boolean)List[NamesDefaults.this.global.Symbol]">filter</a><span class="delimiter">(</span><a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams.missingParams.$anonfun.p">p</a> =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.namedArgsOnChangedPosition" title="List[T]">namedArgsOnChangedPosition</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: T =&gt; Boolean)Boolean">forall</a> <span class="delimiter">{</span> <a title="T" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams.missingParams.$anonfun.$anonfun.arg">arg</a> =&gt;
      val <a title="Option[NamesDefaults.this.global.Name]" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams.missingParams.$anonfun.$anonfun.n">n</a> = <a href="../../../Function1.scala.html#scala;Function1.apply" title="(v1: T)Option[NamesDefaults.this.global.Name]">argName</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.missingParams.$anonfun.$anonfun.arg" title="T">arg</a><span class="delimiter">)</span>
      <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.missingParams.$anonfun.$anonfun.n" title="Option[NamesDefaults.this.global.Name]">n</a>.<a href="../../../Option.scala.html#scala;Option.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.missingParams.$anonfun.$anonfun.n" title="Option[NamesDefaults.this.global.Name]">n</a>.<a href="../../../Option.scala.html#scala;Option.get" title="=&gt; NamesDefaults.this.global.Name">get</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.missingParams.$anonfun.p" title="NamesDefaults.this.global.Symbol">p</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; p.NameType">name</a>
    <span class="delimiter">}</span><span class="delimiter">)</span>
    val allPositional = <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.missingParams" title="List[NamesDefaults.this.global.Symbol]">missingParams</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.length" title="=&gt; Int">length</a> <a href="../../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="Boolean" id="scala.tools.nsc.typechecker;NamesDefaults.missingParams.allPositional">==</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.paramsWithoutPositionalArg" title="List[NamesDefaults.this.global.Symbol]">paramsWithoutPositionalArg</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.length" title="=&gt; Int">length</a>
    <a href="../../../Tuple2.scala.html#scala;Tuple2" title="(_1: List[NamesDefaults.this.global.Symbol], _2: Boolean)(List[NamesDefaults.this.global.Symbol], Boolean)" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.missingParams" title="List[NamesDefaults.this.global.Symbol]">missingParams</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams.allPositional" title="Boolean">allPositional</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Extend the argument list `givenArgs` with default arguments. Defaults are added
   * as named arguments calling the corresponding default getter.
   *
   * Example: given
   *   def foo(x: Int = 2, y: String = &quot;def&quot;)
   *   foo(y = &quot;lt&quot;)
   * the argument list (y = &quot;lt&quot;) is transformed to (y = &quot;lt&quot;, x = foo$default$1())
   */</span>
  def <a title="(givenArgs: List[NamesDefaults.this.global.Tree], qual: Option[NamesDefaults.this.global.Tree], targs: List[NamesDefaults.this.global.Tree], previousArgss: List[List[NamesDefaults.this.global.Tree]], params: List[NamesDefaults.this.global.Symbol], pos: scala.reflect.internal.util.Position, context: NamesDefaults.this.Context)(List[NamesDefaults.this.global.Tree], List[NamesDefaults.this.global.Symbol])" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults">addDefaults</a><span class="delimiter">(</span><a title="List[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.givenArgs">givenArgs</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[NamesDefaults.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="Option[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.qual">qual</a>: <a href="../../../Option.scala.html#scala;Option" title="Option[NamesDefaults.this.global.Tree]">Option</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="List[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.targs">targs</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[NamesDefaults.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>,
                  <a title="List[List[NamesDefaults.this.global.Tree]]" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.previousArgss">previousArgss</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[NamesDefaults.this.global.Tree]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="List[NamesDefaults.this.global.Symbol]" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.params">params</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[NamesDefaults.this.global.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span>,
                  <a title="scala.reflect.internal.util.Position" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.pos">pos</a>: scala.reflect.internal.util.<a href="../../../reflect/internal/util/Position.scala.html#scala.reflect.internal.util;Position" title="scala.reflect.internal.util.Position">Position</a>, <a title="NamesDefaults.this.Context" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.context">context</a>: <a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context" title="NamesDefaults.this.Context">Context</a><span class="delimiter">)</span>: <a href="../../../Tuple2.scala.html#scala;Tuple2" title="(List[NamesDefaults.this.global.Tree], List[NamesDefaults.this.global.Symbol])" class="delimiter">(</a>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span>, List<span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.givenArgs" title="List[NamesDefaults.this.global.Tree]">givenArgs</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.length" title="=&gt; Int">length</a> <a href="../../../Int.scala.html#scala;Int.<(5f58a84eb3)" title="(x: Int)Boolean">&lt;</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.params" title="List[NamesDefaults.this.global.Symbol]">params</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.length" title="=&gt; Int">length</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a href="../../../Tuple2.scala.html#scala;Tuple2" title="(List[NamesDefaults.this.global.Symbol], Boolean)" class="delimiter">(</a><a href="../../../Tuple2.scala.html#scala;Tuple2._1" title="List[NamesDefaults.this.global.Symbol]" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.missing">missing</a>, <a href="../../../Tuple2.scala.html#scala;Tuple2._2" title="Boolean" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.positional">positional</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.missingParams" title="(args: List[NamesDefaults.this.global.Tree], params: List[NamesDefaults.this.global.Symbol], argName: NamesDefaults.this.global.Tree =&gt; Option[NamesDefaults.this.global.Name])(List[NamesDefaults.this.global.Symbol], Boolean)">missingParams</a><a href="../../../Tuple2.scala.html#scala;Tuple2" title="(List[NamesDefaults.this.global.Symbol], Boolean) @unchecked" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.givenArgs" title="List[NamesDefaults.this.global.Tree]">givenArgs</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.params" title="List[NamesDefaults.this.global.Symbol]">params</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.nameOfNamedArg" title="(arg: NamesDefaults.this.global.Tree)Option[NamesDefaults.this.global.Name]">nameOfNamedArg</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.missing" title="List[NamesDefaults.this.global.Symbol]">missing</a> <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.forall" title="(p: NamesDefaults.this.global.Symbol =&gt; Boolean)Boolean">forall</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.$anonfun.x$11" title="NamesDefaults.this.global.Symbol">_</a>.<a href="../../../reflect/internal/HasFlags.scala.html#scala.reflect.internal;HasFlags.hasDefault" title="=&gt; Boolean">hasDefault</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val defaultArgs = <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.missing" title="List[NamesDefaults.this.global.Symbol]">missing</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.flatMap" title="List[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs">flatMap</a> <span class="delimiter">(</span><a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.p">p</a> =&gt; <span class="delimiter">{</span>
          val <a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.defGetter">defGetter</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter" title="(param: NamesDefaults.this.global.Symbol, context: NamesDefaults.this.Context)NamesDefaults.this.global.Symbol">defaultGetter</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.p" title="NamesDefaults.this.global.Symbol">p</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.context" title="NamesDefaults.this.Context">context</a><span class="delimiter">)</span>
          <span class="comment">// TODO #3649 can create spurious errors when companion object is gone (because it becomes unlinked from scope)</span>
          if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.defGetter" title="NamesDefaults.this.global.Symbol">defGetter</a> <span title="(x$1: Any)Boolean">==</span> <a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; NamesDefaults.this.global.NoSymbol">NoSymbol</a><span class="delimiter">)</span> <a href="../../../Option.scala.html#scala.Option.option2Iterable" title="(xo: Option[Nothing])Iterable[Nothing]">None</a> <span class="comment">// prevent crash in erroneous trees, #3649</span>
          else <span class="delimiter">{</span>
            var <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default1">default1</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="NamesDefaults.this.global.Tree">Tree</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.qual" title="Option[NamesDefaults.this.global.Tree]">qual</a> match <span class="delimiter">{</span>
              case Some<span class="delimiter">(</span><a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default1.q">q</a><span class="delimiter">)</span> =&gt; <a href="../Global.scala.html#scala.tools.nsc;Global.gen" title="NamesDefaults.this.global.gen.type">gen</a>.<a href="../../../reflect/internal/TreeGen.scala.html#scala.reflect.internal;TreeGen.mkAttributedSelect" title="(qual: NamesDefaults.this.global.gen.global.Tree, sym: NamesDefaults.this.global.gen.global.Symbol)NamesDefaults.this.global.gen.global.RefTree">mkAttributedSelect</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default1.q" title="NamesDefaults.this.global.Tree">q</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.duplicate" title="=&gt; q.type">duplicate</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.defGetter" title="NamesDefaults.this.global.Symbol">defGetter</a><span class="delimiter">)</span>
              case <a href="../../../Option.scala.html#scala.None" title="None.type">None</a>    =&gt; <a href="../Global.scala.html#scala.tools.nsc;Global.gen" title="NamesDefaults.this.global.gen.type">gen</a>.<a href="../../../reflect/internal/TreeGen.scala.html#scala.reflect.internal;TreeGen.mkAttributedRef(23ce0e46ac)" title="(sym: NamesDefaults.this.global.gen.global.Symbol)NamesDefaults.this.global.gen.global.RefTree">mkAttributedRef</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.defGetter" title="NamesDefaults.this.global.Symbol">defGetter</a><span class="delimiter">)</span>

            <span class="delimiter">}</span>
            <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default1" title="NamesDefaults.this.global.Tree">default1</a> = if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.targs" title="List[NamesDefaults.this.global.Tree]">targs</a>.<a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default1" title="NamesDefaults.this.global.Tree">default1</a>
                       else <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;TypeApply" title="(fun: NamesDefaults.this.global.Tree, args: List[NamesDefaults.this.global.Tree])NamesDefaults.this.global.TypeApply">TypeApply</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default1" title="NamesDefaults.this.global.Tree">default1</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.targs" title="List[NamesDefaults.this.global.Tree]">targs</a>.<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: NamesDefaults.this.global.Tree =&gt; NamesDefaults.this.global.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[NamesDefaults.this.global.Tree],NamesDefaults.this.global.Tree,List[NamesDefaults.this.global.Tree]])List[NamesDefaults.this.global.Tree]">map</a><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.List.canBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,NamesDefaults.this.global.Tree,List[NamesDefaults.this.global.Tree]]" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.$anonfun.x$12" title="NamesDefaults.this.global.Tree">_</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.duplicate" title="=&gt; x$12.type">duplicate</a><span class="delimiter">)</span><span class="delimiter">)</span>
            val <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default2">default2</a> = <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default1" title="NamesDefaults.this.global.Tree">default1</a> <a href="../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce./:" title="(z: NamesDefaults.this.global.Tree)(op: (NamesDefaults.this.global.Tree, List[NamesDefaults.this.global.Tree]) =&gt; NamesDefaults.this.global.Tree)NamesDefaults.this.global.Tree">/:</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.previousArgss" title="List[List[NamesDefaults.this.global.Tree]]">previousArgss</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default2.$anonfun.tree">tree</a>, <a title="List[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default2.$anonfun.args">args</a><span class="delimiter">)</span> =&gt;
              <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Apply" title="(fun: NamesDefaults.this.global.Tree, args: List[NamesDefaults.this.global.Tree])NamesDefaults.this.global.Apply">Apply</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default2.$anonfun.tree" title="NamesDefaults.this.global.Tree">tree</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default2.$anonfun.args" title="List[NamesDefaults.this.global.Tree]">args</a>.<a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: NamesDefaults.this.global.Tree =&gt; NamesDefaults.this.global.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[NamesDefaults.this.global.Tree],NamesDefaults.this.global.Tree,List[NamesDefaults.this.global.Tree]])List[NamesDefaults.this.global.Tree]">map</a><a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.List.canBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,NamesDefaults.this.global.Tree,List[NamesDefaults.this.global.Tree]]" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default2.$anonfun.$anonfun.x$14" title="NamesDefaults.this.global.Tree">_</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.duplicate" title="=&gt; x$14.type">duplicate</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="../../../Option.scala.html#scala;Some" title="(x: NamesDefaults.this.global.Tree)Some[NamesDefaults.this.global.Tree]">Some</a><a href="../../../Option.scala.html#scala.Option.option2Iterable" title="(xo: Option[NamesDefaults.this.global.Tree])Iterable[NamesDefaults.this.global.Tree]" class="delimiter">(</a><a href="../../../reflect/internal/Positions.scala.html#scala.reflect.internal;Positions.atPos" title="(pos: NamesDefaults.this.global.Position)(tree: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Tree">atPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.pos" title="scala.reflect.internal.util.Position">pos</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.positional" title="Boolean">positional</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default2" title="NamesDefaults.this.global.Tree">default2</a>
              else <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;AssignOrNamedArg" title="(lhs: NamesDefaults.this.global.Tree, rhs: NamesDefaults.this.global.Tree)NamesDefaults.this.global.AssignOrNamedArg">AssignOrNamedArg</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Ident" title="(name: NamesDefaults.this.global.Name)NamesDefaults.this.global.Ident">Ident</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.p" title="NamesDefaults.this.global.Symbol">p</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; p.NameType">name</a><span class="delimiter">)</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs.$anonfun.default2" title="NamesDefaults.this.global.Tree">default2</a><span class="delimiter">)</span>
            <span class="delimiter">}</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>
        <a href="../../../Tuple2.scala.html#scala;Tuple2" title="(_1: List[NamesDefaults.this.global.Tree], _2: scala.collection.immutable.Nil.type)(List[NamesDefaults.this.global.Tree], scala.collection.immutable.Nil.type)" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.givenArgs" title="List[NamesDefaults.this.global.Tree]">givenArgs</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.:::" title="(prefix: List[NamesDefaults.this.global.Tree])List[NamesDefaults.this.global.Tree]">:::</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.defaultArgs" title="List[NamesDefaults.this.global.Tree]">defaultArgs</a>, <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <a href="../../../Tuple2.scala.html#scala;Tuple2" title="(_1: List[NamesDefaults.this.global.Tree], _2: List[NamesDefaults.this.global.Symbol])(List[NamesDefaults.this.global.Tree], List[NamesDefaults.this.global.Symbol])" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.givenArgs" title="List[NamesDefaults.this.global.Tree]">givenArgs</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.missing" title="List[NamesDefaults.this.global.Symbol]">missing</a> <a href="../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filterNot" title="(p: NamesDefaults.this.global.Symbol =&gt; Boolean)List[NamesDefaults.this.global.Symbol]">filterNot</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.$anonfun.x$16" title="NamesDefaults.this.global.Symbol">_</a>.<a href="../../../reflect/internal/HasFlags.scala.html#scala.reflect.internal;HasFlags.hasDefault" title="=&gt; Boolean">hasDefault</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <a href="../../../Tuple2.scala.html#scala;Tuple2" title="(_1: List[NamesDefaults.this.global.Tree], _2: scala.collection.immutable.Nil.type)(List[NamesDefaults.this.global.Tree], scala.collection.immutable.Nil.type)" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.addDefaults.givenArgs" title="List[NamesDefaults.this.global.Tree]">givenArgs</a>, <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * For a parameter with default argument, find the method symbol of
   * the default getter.
   */</span>
  def <a title="(param: NamesDefaults.this.global.Symbol, context: NamesDefaults.this.Context)NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.defaultGetter">defaultGetter</a><span class="delimiter">(</span><a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.param">param</a>: <a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="NamesDefaults.this.global.Symbol">Symbol</a>, <a title="NamesDefaults.this.Context" id="scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.context">context</a>: <a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context" title="NamesDefaults.this.Context">Context</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="NamesDefaults.this.global.Symbol">Symbol</a> = <span class="delimiter">{</span>
    val i = <a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.paramss" title="=&gt; List[List[NamesDefaults.this.global.Symbol]]">paramss</a>.<a href="../../../collection/generic/GenericTraversableTemplate.scala.html#scala.collection.generic;GenericTraversableTemplate.flatten" title="(implicit asTraversable: List[NamesDefaults.this.global.Symbol] =&gt; scala.collection.GenTraversableOnce[NamesDefaults.this.global.Symbol])List[NamesDefaults.this.global.Symbol]">flatten</a>.<a href="../../../collection/GenSeqLike.scala.html#scala.collection;GenSeqLike.indexWhere(654a5f82d5)" title="(p: NamesDefaults.this.global.Symbol =&gt; Boolean)Int">indexWhere</a><span class="delimiter">(</span><a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.i.$anonfun.p">p</a> =&gt; <a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.i.$anonfun.p" title="NamesDefaults.this.global.Symbol">p</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; p.NameType">name</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; param.NameType">name</a><span class="delimiter">)</span> <a href="../../../Int.scala.html#scala;Int.+(1409840560)" title="Int" id="scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.i">+</a> <span title="Int(1)" class="int">1</span>
    if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.i" title="Int">i</a> <a href="../../../Int.scala.html#scala;Int.>(5f58a84eb3)" title="(x: Int)Boolean">&gt;</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="NamesDefaults.this.global.TermName" id="scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.defGetterName">defGetterName</a> = <a href="../../../reflect/internal/StdNames.scala.html#scala.reflect.internal;StdNames.nme" title="NamesDefaults.this.global.nme.type">nme</a>.<a href="../../../reflect/internal/StdNames.scala.html#scala.reflect.internal;StdNames;TermNames.defaultGetterName" title="(name: NamesDefaults.this.global.Name, pos: Int)NamesDefaults.this.global.TermName">defaultGetterName</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; NamesDefaults.this.global.Symbol#NameType">name</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.i" title="Int">i</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isConstructor" title="=&gt; Boolean">isConstructor</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.mod">mod</a> = <a href="Namers.scala.html#scala.tools.nsc.typechecker;Namers.companionSymbolOf" title="(original: NamesDefaults.this.global.Symbol, ctx: NamesDefaults.this.Context)NamesDefaults.this.global.Symbol">companionSymbolOf</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.context" title="NamesDefaults.this.Context">context</a><span class="delimiter">)</span>
        <a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.mod" title="NamesDefaults.this.global.Symbol">mod</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; NamesDefaults.this.global.Type">info</a>.<a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.member" title="(name: NamesDefaults.this.global.Name)NamesDefaults.this.global.Symbol">member</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.defGetterName" title="NamesDefaults.this.global.TermName">defGetterName</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      else <span class="delimiter">{</span>
        <span class="comment">// isClass also works for methods in objects, owner is the ModuleClassSymbol</span>
        if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a>.<a href="../../../reflect/api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isClass" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="comment">// .toInterface: otherwise we get the method symbol of the impl class</span>
          <a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.toInterface" title="=&gt; NamesDefaults.this.global.Symbol">toInterface</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.info" title="=&gt; NamesDefaults.this.global.Type">info</a>.<a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.member" title="(name: NamesDefaults.this.global.Name)NamesDefaults.this.global.Symbol">member</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.defGetterName" title="NamesDefaults.this.global.TermName">defGetterName</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> else <span class="delimiter">{</span>
          <span class="comment">// the owner of the method is another method. find the default</span>
          <span class="comment">// getter in the context.</span>
          <a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.context" title="NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.lookup" title="(name: NamesDefaults.this.global.Name, expectedOwner: NamesDefaults.this.global.Symbol)NamesDefaults.this.global.Symbol">lookup</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.defGetterName" title="NamesDefaults.this.global.TermName">defGetterName</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.defaultGetter.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.owner" title="=&gt; NamesDefaults.this.global.Symbol">owner</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> else <a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; NamesDefaults.this.global.NoSymbol">NoSymbol</a>
  <span class="delimiter">}</span>

  <span class="comment">/** A full type check is very expensive; let's make sure there's a name
   *  somewhere which could potentially be ambiguous before we go that route.
   */</span>
  private def <a title="(typer: NamesDefaults.this.Typer, param: NamesDefaults.this.global.Symbol, arg: NamesDefaults.this.global.Tree)Boolean" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment">isAmbiguousAssignment</a><span class="delimiter">(</span><a title="NamesDefaults.this.Typer" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.typer">typer</a>: <a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer" title="NamesDefaults.this.Typer">Typer</a>, <a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.param">param</a>: <a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="NamesDefaults.this.global.Symbol">Symbol</a>, <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.arg">arg</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="NamesDefaults.this.global.Tree">Tree</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    import <a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.typer" title="NamesDefaults.this.Typer">typer</a>.context
    <span class="delimiter">(</span><a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.context" title="=&gt; NamesDefaults.this.Context">context</a> <a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.isNameInScope" title="(name: NamesDefaults.this.global.Name)Boolean">isNameInScope</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; param.NameType">name</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
      <span class="comment">// for named arguments, check whether the assignment expression would</span>
      <span class="comment">// typecheck. if it does, report an ambiguous error.</span>
      val <a title="NamesDefaults.this.global.Type" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.paramtpe">paramtpe</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; NamesDefaults.this.global.Type">tpe</a>.<a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.cloneInfo" title="(owner: NamesDefaults.this.global.Symbol)NamesDefaults.this.global.Type">cloneInfo</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.param" title="NamesDefaults.this.global.Symbol">param</a><span class="delimiter">)</span>
      <span class="comment">// replace type parameters by wildcard. in the below example we need to</span>
      <span class="comment">// typecheck (x = 1) with wildcard (not T) so that it succeeds.</span>
      <span class="comment">//   def f[T](x: T) = x</span>
      <span class="comment">//   var x = 0</span>
      <span class="comment">//   f(x = 1)   &lt;&lt;  &quot;x = 1&quot; typechecks with expected type WildcardType</span>
      val <a title="List[NamesDefaults.this.global.Symbol]" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.udp">udp</a> = <a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.context" title="=&gt; NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.undetparams" title="=&gt; List[NamesDefaults.this.global.Symbol]">undetparams</a>
      <a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.context" title="=&gt; NamesDefaults.this.Context">context</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.savingUndeterminedTypeParams" title="(reportAmbiguous: Boolean)(body: =&gt; Boolean)Boolean">savingUndeterminedTypeParams</a><span class="delimiter">(</span>reportAmbiguous = false<span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="NamesDefaults.this.global.SubstTypeMap" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.subst">subst</a> = new <a href="../../../reflect/internal/tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstTypeMap" title="&lt;$anon: NamesDefaults.this.global.Type =&gt; NamesDefaults.this.global.Type&gt; extends NamesDefaults.this.global.SubstTypeMap" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.subst;$anon">SubstTypeMap</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.udp" title="List[NamesDefaults.this.global.Symbol]">udp</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.udp" title="List[NamesDefaults.this.global.Symbol]">udp</a> <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: NamesDefaults.this.global.Symbol =&gt; NamesDefaults.this.global.WildcardType.type)(implicit bf: scala.collection.generic.CanBuildFrom[List[NamesDefaults.this.global.Symbol],NamesDefaults.this.global.WildcardType.type,List[NamesDefaults.this.global.Type]])List[NamesDefaults.this.global.Type]">map</a> <span class="delimiter">(</span><a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.subst;$anon.$anonfun.x$17">_</a> =&gt; <a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types.WildcardType" title="NamesDefaults.this.global.WildcardType.type">WildcardType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          override def <a title="(tp: NamesDefaults.this.global.Type)NamesDefaults.this.global.Type" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.subst;$anon.apply">apply</a><span class="delimiter">(</span><a title="NamesDefaults.this.global.Type" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.subst;$anon.apply.tp">tp</a>: <a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="NamesDefaults.this.global.Type">Type</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="NamesDefaults.this.global.Type">Type</a> = super.<a href="../../../reflect/internal/tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply" title="(tp0: NamesDefaults.this.global.Type)NamesDefaults.this.global.Type">apply</a><span class="delimiter">(</span><a href="../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.dropByName" title="(tp: NamesDefaults.this.global.Type)NamesDefaults.this.global.Type">dropByName</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.subst;$anon.apply.tp" title="NamesDefaults.this.global.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <span class="comment">// This throws an exception which is caught in `tryTypedApply` (as it</span>
        <span class="comment">// uses `silent`) - unfortunately, tryTypedApply recovers from the</span>
        <span class="comment">// exception if you use errorTree(arg, ...) and conforms is allowed as</span>
        <span class="comment">// a view (see tryImplicit in Implicits) because it tries to produce a</span>
        <span class="comment">// new qualifier (if the old one was P, the new one will be</span>
        <span class="comment">// conforms.apply(P)), and if that works, it pretends nothing happened.</span>
        <span class="comment">//</span>
        <span class="comment">// To make sure tryTypedApply fails, we would like to pass EmptyTree</span>
        <span class="comment">// instead of arg, but can't do that because eventually setType(ErrorType)</span>
        <span class="comment">// is called, and EmptyTree can only be typed NoType.  Thus we need to</span>
        <span class="comment">// disable conforms as a view...</span>
        val <a title="Int" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.errsBefore">errsBefore</a> = <a href="../Global.scala.html#scala.tools.nsc;Global.reporter" title="=&gt; scala.tools.nsc.reporters.Reporter">reporter</a>.<a href="../reporters/Reporter.scala.html#scala.tools.nsc.reporters;Reporter.ERROR" title="=&gt; scala.tools.nsc.reporters.Reporter#Severity">ERROR</a>.<a href="../reporters/Reporter.scala.html#scala.tools.nsc.reporters;Reporter;Severity.count" title="=&gt; Int">count</a>
        try <a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.typer" title="NamesDefaults.this.Typer">typer</a>.<a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.silent" title="(op: NamesDefaults.this.Typer =&gt; NamesDefaults.this.global.Tree, reportAmbiguousErrors: Boolean, newtree: NamesDefaults.this.global.Tree)NamesDefaults.this.SilentResult[NamesDefaults.this.global.Tree]">silent</a> <span class="delimiter">{</span> <a title="NamesDefaults.this.Typer" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.$anonfun.tpr">tpr</a> =&gt;
          val <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.$anonfun.res">res</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.$anonfun.tpr" title="NamesDefaults.this.Typer">tpr</a>.<a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.typed(05ba2f698f)" title="(tree: NamesDefaults.this.global.Tree, pt: NamesDefaults.this.global.Type)NamesDefaults.this.global.Tree">typed</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.arg" title="NamesDefaults.this.global.Tree">arg</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.duplicate" title="=&gt; arg.type">duplicate</a>, <a href="../../../reflect/internal/tpe/TypeMaps.scala.html#scala.reflect.internal.tpe;TypeMaps;SubstMap.apply" title="(tp0: NamesDefaults.this.global.Type)NamesDefaults.this.global.Type">subst</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.paramtpe" title="NamesDefaults.this.global.Type">paramtpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="comment">// better warning for SI-5044: if `silent` was not actually silent give a hint to the user</span>
          <span class="comment">// [H]: the reason why `silent` is not silent is because the cyclic reference exception is</span>
          <span class="comment">// thrown in a context completely different from `context` here. The exception happens while</span>
          <span class="comment">// completing the type, and TypeCompleter is created/run with a non-silent Namer `context`</span>
          <span class="comment">// and there is at the moment no way to connect the two unless we go through some global state.</span>
          if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.errsBefore" title="Int">errsBefore</a> <a href="../../../Int.scala.html#scala;Int.<(5f58a84eb3)" title="(x: Int)Boolean">&lt;</a> <a href="../Global.scala.html#scala.tools.nsc;Global.reporter" title="=&gt; scala.tools.nsc.reporters.Reporter">reporter</a>.<a href="../reporters/Reporter.scala.html#scala.tools.nsc.reporters;Reporter.ERROR" title="=&gt; scala.tools.nsc.reporters.Reporter#Severity">ERROR</a>.<a href="../reporters/Reporter.scala.html#scala.tools.nsc.reporters;Reporter;Severity.count" title="=&gt; Int">count</a><span class="delimiter">)</span>
            <a href="ContextErrors.scala.html#scala.tools.nsc.typechecker;ContextErrors.NamesDefaultsErrorsGen.WarnAfterNonSilentRecursiveInference" title="(param: NamesDefaults.this.global.Symbol, arg: NamesDefaults.this.global.Tree)(implicit context: NamesDefaults.this.Context)Unit">WarnAfterNonSilentRecursiveInference</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.param" title="NamesDefaults.this.global.Symbol">param</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.arg" title="NamesDefaults.this.global.Tree">arg</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.context" title="=&gt; NamesDefaults.this.Context">context</a><span class="delimiter">)</span>
          <a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.$anonfun.res" title="NamesDefaults.this.global.Tree">res</a>
        <span class="delimiter">}</span> match <span class="delimiter">{</span>
          case SilentResultValue<span class="delimiter">(</span><a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.t">t</a><span class="delimiter">)</span>  =&gt; <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.t" title="NamesDefaults.this.global.Tree">t</a>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;TreeContextApiImpl.isErroneous" title="=&gt; Boolean">isErroneous</a> <span class="comment">// #4041</span>
          case _        =&gt; false
        <span class="delimiter">}</span>
        catch <span class="delimiter">{</span>
          <span class="comment">// `silent` only catches and returns TypeErrors which are not</span>
          <span class="comment">// CyclicReferences.  Fix for #3685</span>
          case <a title="NamesDefaults.this.global.CyclicReference" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.cr">cr</a> @ CyclicReference<span class="delimiter">(</span><a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.sym">sym</a>, _<span class="delimiter">)</span> =&gt;
            <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.sym" title="NamesDefaults.this.global.Symbol">sym</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; sym.NameType">name</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; param.NameType">name</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.sym" title="NamesDefaults.this.global.Symbol">sym</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.accessedOrSelf" title="=&gt; NamesDefaults.this.global.Symbol">accessedOrSelf</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isVariable" title="=&gt; Boolean">isVariable</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">{</span>
              <a href="ContextErrors.scala.html#scala.tools.nsc.typechecker;ContextErrors.NamesDefaultsErrorsGen.NameClashError" title="(sym: NamesDefaults.this.global.Symbol, arg: NamesDefaults.this.global.Tree)(implicit context: NamesDefaults.this.Context)Unit">NameClashError</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.sym" title="NamesDefaults.this.global.Symbol">sym</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment.arg" title="NamesDefaults.this.global.Tree">arg</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.context" title="=&gt; NamesDefaults.this.Context">context</a><span class="delimiter">)</span>
              true
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Removes name assignments from args. Additionally, returns an array mapping
   * argument indices from call-site-order to definition-site-order.
   *
   * Verifies that names are not specified twice, positional args don't appear
   * after named ones.
   */</span>
  def <a title="(typer: NamesDefaults.this.Typer)(args: List[NamesDefaults.this.global.Tree], params: List[NamesDefaults.this.global.Symbol])(List[NamesDefaults.this.global.Tree], Array[Int])" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames">removeNames</a><span class="delimiter">(</span><a title="NamesDefaults.this.Typer" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.typer">typer</a>: <a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer" title="NamesDefaults.this.Typer">Typer</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="List[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.args">args</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[NamesDefaults.this.global.Tree]">List</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>, <a title="List[NamesDefaults.this.global.Symbol]" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.params">params</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[NamesDefaults.this.global.Symbol]">List</a><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../Tuple2.scala.html#scala;Tuple2" title="(List[NamesDefaults.this.global.Tree], Array[Int])" class="delimiter">(</a>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span>, Array<span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    implicit val <a title="NamesDefaults.this.Context" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.context0">context0</a> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.typer" title="NamesDefaults.this.Typer">typer</a>.<a href="Typers.scala.html#scala.tools.nsc.typechecker;Typers;Typer.context" title="=&gt; NamesDefaults.this.Context">context</a>
    <span class="comment">// maps indices from (order written by user) to (order of definition)</span>
    val <a title="Array[Int]" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.argPos">argPos</a>            = <a href="../../../Array.scala.html#scala.Array" title="Array.type">Array</a>.<a href="../../../Array.scala.html#scala.Array.fill(fc99a6c219)" title="(n: Int)(elem: =&gt; Int)(implicit evidence$9: scala.reflect.ClassTag[Int])Array[Int]">fill</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.args" title="List[NamesDefaults.this.global.Tree]">args</a>.<a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.length" title="=&gt; Int">length</a><span class="delimiter">)</span><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.Int" title="=&gt; scala.reflect.ClassTag[Int]" class="delimiter">(</a>-<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span>
    var <a title="Boolean" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.positionalAllowed">positionalAllowed</a> = true
    val <a title="List[NamesDefaults.this.global.Tree]" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs">namelessArgs</a> = <a href="../../../reflect/internal/util/Collections.scala.html#scala.reflect.internal.util;Collections.mapWithIndex" title="(xs: List[NamesDefaults.this.global.Tree])(f: (NamesDefaults.this.global.Tree, Int) =&gt; NamesDefaults.this.global.Tree)List[NamesDefaults.this.global.Tree]">mapWithIndex</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.args" title="List[NamesDefaults.this.global.Tree]">args</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><span title="NamesDefaults.this.global.Tree">arg</span>, <a title="Int" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.argIndex">argIndex</a><span class="delimiter">)</span> =&gt;
      <span title="NamesDefaults.this.global.Tree">arg</span> match <span class="delimiter">{</span>
        case <span title="NamesDefaults.this.global.AssignOrNamedArg">arg</span> @ AssignOrNamedArg<span class="delimiter">(</span>Ident<span class="delimiter">(</span><a title="NamesDefaults.this.global.Name" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.name">name</a><span class="delimiter">)</span>, <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.rhs">rhs</a><span class="delimiter">)</span> =&gt;
          def <a title="(param: NamesDefaults.this.global.Symbol)Boolean" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.matchesName">matchesName</a><span class="delimiter">(</span><a title="NamesDefaults.this.global.Symbol" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.matchesName.param">param</a>: <a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol" title="NamesDefaults.this.global.Symbol">Symbol</a><span class="delimiter">)</span> = <a href="../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.matchesName.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/HasFlags.scala.html#scala.reflect.internal;HasFlags.isSynthetic" title="=&gt; Boolean">isSynthetic</a> <a href="../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span>
            <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.matchesName.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; param.NameType">name</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.name" title="NamesDefaults.this.global.Name">name</a><span class="delimiter">)</span> <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.matchesName.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.deprecatedParamName" title="=&gt; Option[NamesDefaults.this.global.TermName]">deprecatedParamName</a> match <span class="delimiter">{</span>
              case Some<span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.name" title="NamesDefaults.this.global.Name">`name`</a><span class="delimiter">)</span> =&gt;
                <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.context0" title="NamesDefaults.this.Context">context0</a>.<a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context.deprecationWarning(0aa03020ce)" title="(pos: NamesDefaults.this.global.Position, sym: NamesDefaults.this.global.Symbol, msg: String)Unit">deprecationWarning</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.AssignOrNamedArg">arg</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.matchesName.param" title="NamesDefaults.this.global.Symbol">param</a>,
                  <a href="../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;the parameter name &quot;)">the parameter name $</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.name" title="NamesDefaults.this.global.Name">name</a><span title="String(&quot; has been deprecated. Use &quot;)"> has been deprecated. Use $</span><span class="delimiter">{</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.matchesName.param" title="NamesDefaults.this.global.Symbol">param</a>.<a href="../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; param.NameType">name</a><span class="delimiter">}</span><span title="String(&quot; instead.&quot;)" class="string"> instead.&quot;</span><span class="delimiter">)</span>
                true
              case _ =&gt; false
            <span class="delimiter">}</span><span class="delimiter">)</span>
          <span class="delimiter">)</span>
          val paramPos = <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.params" title="List[NamesDefaults.this.global.Symbol]">params</a> <a href="../../../collection/GenSeqLike.scala.html#scala.collection;GenSeqLike.indexWhere(654a5f82d5)" title="Int" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.paramPos">indexWhere</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.matchesName" title="(param: NamesDefaults.this.global.Symbol)Boolean">matchesName</a>
          if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.paramPos" title="Int">paramPos</a> <a href="../../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.positionalAllowed" title="Boolean">positionalAllowed</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <a href="../../../Array.scala.html#scala;Array.update" title="(i: Int, x: Int)Unit">argPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.argIndex" title="Int">argIndex</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.argIndex" title="Int">argIndex</a>
              <span class="comment">// prevent isNamed from being true when calling doTypedApply recursively,</span>
              <span class="comment">// treat the arg as an assignment of type Unit</span>
              <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Assign" title="(lhs: NamesDefaults.this.global.Tree, rhs: NamesDefaults.this.global.Tree)NamesDefaults.this.global.Assign">Assign</a><span class="delimiter">(</span><span title="NamesDefaults.this.global.AssignOrNamedArg">arg</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;AssignOrNamedArg.lhs" title="=&gt; NamesDefaults.this.global.Tree">lhs</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.rhs" title="NamesDefaults.this.global.Tree">rhs</a><span class="delimiter">)</span> <a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.setPos" title="(newpos: scala.reflect.internal.util.Position)NamesDefaults.this.global.Assign">setPos</a> <span title="NamesDefaults.this.global.AssignOrNamedArg">arg</span>.<a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.pos" title="=&gt; NamesDefaults.this.global.Position">pos</a>
            <span class="delimiter">}</span>
            else <a href="ContextErrors.scala.html#scala.tools.nsc.typechecker;ContextErrors.NamesDefaultsErrorsGen.UnknownParameterNameNamesDefaultError" title="(arg: NamesDefaults.this.global.Tree, name: NamesDefaults.this.global.Name)(implicit context: NamesDefaults.this.Context)NamesDefaults.this.global.Tree">UnknownParameterNameNamesDefaultError</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.context0" title="NamesDefaults.this.Context" class="delimiter">(</a><span title="NamesDefaults.this.global.AssignOrNamedArg">arg</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.name" title="NamesDefaults.this.global.Name">name</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          else if <span class="delimiter">(</span><a href="../../../Predef.scala.html#scala.Predef.intArrayOps" title="implicit scala.Predef.intArrayOps : (xs: Array[Int])scala.collection.mutable.ArrayOps[Int]">argPos</a> <a href="../../../collection/SeqLike.scala.html#scala.collection;SeqLike.contains" title="(elem: Int)Boolean">contains</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.paramPos" title="Int">paramPos</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            val <a title="Int" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.existingArgIndex">existingArgIndex</a> = <a href="../../../Predef.scala.html#scala.Predef.intArrayOps" title="implicit scala.Predef.intArrayOps : (xs: Array[Int])scala.collection.mutable.ArrayOps[Int]">argPos</a>.<a href="../../../collection/GenSeqLike.scala.html#scala.collection;GenSeqLike.indexWhere(654a5f82d5)" title="(p: Int =&gt; Boolean)Int">indexWhere</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.existingArgIndex.$anonfun.x$18" title="Int">_</a> <a href="../../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.paramPos" title="Int">paramPos</a><span class="delimiter">)</span>
            val <a title="Option[NamesDefaults.this.global.Name]" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.otherName">otherName</a> = <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.apply" title="(n: Int)NamesDefaults.this.global.Tree">args</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.paramPos" title="Int">paramPos</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
              case AssignOrNamedArg<span class="delimiter">(</span>Ident<span class="delimiter">(</span><a title="NamesDefaults.this.global.Name" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.otherName.oName">oName</a><span class="delimiter">)</span>, <a title="NamesDefaults.this.global.Tree" id="scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.otherName.rhs">rhs</a><span class="delimiter">)</span> if <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.otherName.oName" title="NamesDefaults.this.global.Name">oName</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.name" title="NamesDefaults.this.global.Name">name</a> =&gt; <a href="../../../Option.scala.html#scala;Some" title="(x: NamesDefaults.this.global.Name)Some[NamesDefaults.this.global.Name]">Some</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.otherName.oName" title="NamesDefaults.this.global.Name">oName</a><span class="delimiter">)</span>
              case _ =&gt; <a href="../../../Option.scala.html#scala.None" title="None.type">None</a>
            <span class="delimiter">}</span>
            <a href="ContextErrors.scala.html#scala.tools.nsc.typechecker;ContextErrors.NamesDefaultsErrorsGen.DoubleParamNamesDefaultError" title="(arg: NamesDefaults.this.global.Tree, name: NamesDefaults.this.global.Name, pos: Int, otherName: Option[NamesDefaults.this.global.Name])(implicit context: NamesDefaults.this.Context)NamesDefaults.this.global.Tree">DoubleParamNamesDefaultError</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.context0" title="NamesDefaults.this.Context" class="delimiter">(</a><span title="NamesDefaults.this.global.AssignOrNamedArg">arg</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.name" title="NamesDefaults.this.global.Name">name</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.existingArgIndex" title="Int">existingArgIndex</a><a href="../../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+</a><span title="Int(1)" class="int">1</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.otherName" title="Option[NamesDefaults.this.global.Name]">otherName</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.isAmbiguousAssignment" title="(typer: NamesDefaults.this.Typer, param: NamesDefaults.this.global.Symbol, arg: NamesDefaults.this.global.Tree)Boolean">isAmbiguousAssignment</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.typer" title="NamesDefaults.this.Typer">typer</a>, <a href="../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.apply" title="(n: Int)NamesDefaults.this.global.Symbol">params</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.paramPos" title="Int">paramPos</a><span class="delimiter">)</span>, <span title="NamesDefaults.this.global.AssignOrNamedArg">arg</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="ContextErrors.scala.html#scala.tools.nsc.typechecker;ContextErrors.NamesDefaultsErrorsGen.AmbiguousReferenceInNamesDefaultError" title="(arg: NamesDefaults.this.global.Tree, name: NamesDefaults.this.global.Name)(implicit context: NamesDefaults.this.Context)NamesDefaults.this.global.Tree">AmbiguousReferenceInNamesDefaultError</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.context0" title="NamesDefaults.this.Context" class="delimiter">(</a><span title="NamesDefaults.this.global.AssignOrNamedArg">arg</span>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.name" title="NamesDefaults.this.global.Name">name</a><span class="delimiter">)</span>
          else <span class="delimiter">{</span>
            <span class="comment">// if the named argument is on the original parameter</span>
            <span class="comment">// position, positional after named is allowed.</span>
            if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.argIndex" title="Int">argIndex</a> <a href="../../../Int.scala.html#scala;Int.!=(5f58a84eb3)" title="(x: Int)Boolean">!=</a> <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.paramPos" title="Int">paramPos</a><span class="delimiter">)</span>
              <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.positionalAllowed" title="Boolean">positionalAllowed</a> = false
            <a href="../../../Array.scala.html#scala;Array.update" title="(i: Int, x: Int)Unit">argPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.argIndex" title="Int">argIndex</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.paramPos" title="Int">paramPos</a>
            <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.rhs" title="NamesDefaults.this.global.Tree">rhs</a>
          <span class="delimiter">}</span>
        case _ =&gt;
          <a href="../../../Array.scala.html#scala;Array.update" title="(i: Int, x: Int)Unit">argPos</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.argIndex" title="Int">argIndex</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs.$anonfun.argIndex" title="Int">argIndex</a>
          if <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.positionalAllowed" title="Boolean">positionalAllowed</a><span class="delimiter">)</span> <span title="NamesDefaults.this.global.Tree">arg</span>
          else <a href="ContextErrors.scala.html#scala.tools.nsc.typechecker;ContextErrors.NamesDefaultsErrorsGen.PositionalAfterNamedNamesDefaultError" title="(arg: NamesDefaults.this.global.Tree)(implicit context: NamesDefaults.this.Context)NamesDefaults.this.global.Tree">PositionalAfterNamedNamesDefaultError</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.context0" title="NamesDefaults.this.Context" class="delimiter">(</a><span title="NamesDefaults.this.global.Tree">arg</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <a href="../../../Tuple2.scala.html#scala;Tuple2" title="(_1: List[NamesDefaults.this.global.Tree], _2: Array[Int])(List[NamesDefaults.this.global.Tree], Array[Int])" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.namelessArgs" title="List[NamesDefaults.this.global.Tree]">namelessArgs</a>, <a href="#scala.tools.nsc.typechecker;NamesDefaults.removeNames.argPos" title="Array[Int]">argPos</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
