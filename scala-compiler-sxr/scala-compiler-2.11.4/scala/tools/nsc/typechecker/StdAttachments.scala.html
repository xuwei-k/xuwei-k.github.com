<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/tools/nsc/typechecker/StdAttachments.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package scala.tools.nsc
package typechecker

trait <a title="trait StdAttachments extends AnyRef" id="scala.tools.nsc.typechecker;StdAttachments">StdAttachments</a> <a href="../../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a>
  self: Analyzer =&gt;

  import <a href="Analyzer.scala.html#scala.tools.nsc.typechecker;Analyzer.global" title="=&gt; scala.tools.nsc.Global">global</a>._

  <span class="comment">/** Carries information necessary to expand the host tree.
   *  At times we need to store this info, because macro expansion can be delayed until its targs are inferred.
   *  After a macro application has been successfully expanded, this attachment is destroyed.
   */</span>
  type <a title="scala.reflect.macros.contexts.Context" id="scala.tools.nsc.typechecker;StdAttachments;UnaffiliatedMacroContext">UnaffiliatedMacroContext</a> = scala.reflect.macros.contexts.<a href="../../../reflect/macros/contexts/Context.scala.html#scala.reflect.macros.contexts;Context" title="scala.reflect.macros.contexts.Context">Context</a>
  type <a title="&lt;refinement of StdAttachments.this.UnaffiliatedMacroContext&gt; extends StdAttachments.this.UnaffiliatedMacroContext" id="scala.tools.nsc.typechecker;StdAttachments;MacroContext">MacroContext</a> = <a href="#scala.tools.nsc.typechecker;StdAttachments;<refinement>" title="&lt;refinement of StdAttachments.this.UnaffiliatedMacroContext&gt; extends StdAttachments.this.UnaffiliatedMacroContext">UnaffiliatedMacroContext</a> <span class="delimiter">{</span> val universe: self.global.type <span class="delimiter">}</span>
  case class <a title="class MacroRuntimeAttachment extends AnyRef with Product with Serializable" id="scala.tools.nsc.typechecker;StdAttachments.MacroRuntimeAttachment.readResolve">MacroRuntimeAttachment</a><a href="../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Boolean" id="scala.tools.nsc.typechecker;StdAttachments;MacroRuntimeAttachment.delayed">delayed</a>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>, <a title="StdAttachments.this.Context" id="scala.tools.nsc.typechecker;StdAttachments;MacroRuntimeAttachment.typerContext">typerContext</a>: <a href="Contexts.scala.html#scala.tools.nsc.typechecker;Contexts;Context" title="StdAttachments.this.Context">Context</a>, <a title="Option[StdAttachments.this.MacroContext]" id="scala.tools.nsc.typechecker;StdAttachments;MacroRuntimeAttachment.macroContext">macroContext</a>: <a href="../../../Option.scala.html#scala;Option" title="Option[StdAttachments.this.MacroContext]">Option</a><span class="delimiter">[</span>MacroContext<span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">/** Scratchpad for the macro expander, which is used to store all intermediate data except the details about the runtime.
   */</span>
  case class <a title="class MacroExpanderAttachment extends AnyRef with Product with Serializable" id="scala.tools.nsc.typechecker;StdAttachments.MacroExpanderAttachment.readResolve">MacroExpanderAttachment</a><a href="../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments;MacroExpanderAttachment.original">original</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a>, <a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments;MacroExpanderAttachment.desugared">desugared</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span>

  <span class="comment">/** Loads underlying MacroExpanderAttachment from a macro expandee or returns a default value for that attachment.
   */</span>
 def <a title="(tree: StdAttachments.this.global.Tree)StdAttachments.this.MacroExpanderAttachment" id="scala.tools.nsc.typechecker;StdAttachments.macroExpanderAttachment">macroExpanderAttachment</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.macroExpanderAttachment.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.tools.nsc.typechecker;StdAttachments.MacroExpanderAttachment.readResolve" title="StdAttachments.this.MacroExpanderAttachment">MacroExpanderAttachment</a> =
    <a href="#scala.tools.nsc.typechecker;StdAttachments.macroExpanderAttachment.tree" title="StdAttachments.this.global.Tree">tree</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.attachments" title="=&gt; scala.reflect.macros.Attachments{type Pos = StdAttachments.this.global.Position}">attachments</a>.<a href="../../../reflect/macros/Attachments.scala.html#scala.reflect.macros;Attachments.get" title="[T](implicit evidence$2: scala.reflect.ClassTag[T])Option[T]">get</a><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(implicit evidence$2: scala.reflect.ClassTag[StdAttachments.this.MacroExpanderAttachment])Option[StdAttachments.this.MacroExpanderAttachment]" class="delimiter">[</a><a href="#scala.tools.nsc.typechecker;StdAttachments.MacroExpanderAttachment.readResolve" title="StdAttachments.this.MacroExpanderAttachment">MacroExpanderAttachment</a><span class="delimiter">]</span> <a href="../../../Option.scala.html#scala;Option.getOrElse" title="(default: =&gt; StdAttachments.this.MacroExpanderAttachment)StdAttachments.this.MacroExpanderAttachment">getOrElse</a> <span class="delimiter">{</span>
      <a href="#scala.tools.nsc.typechecker;StdAttachments.macroExpanderAttachment.tree" title="StdAttachments.this.global.Tree">tree</a> match <span class="delimiter">{</span>
        case Apply<span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.macroExpanderAttachment.fn">fn</a>, _<span class="delimiter">)</span> if <a href="#scala.tools.nsc.typechecker;StdAttachments.macroExpanderAttachment.tree" title="StdAttachments.this.global.Tree">tree</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;ApplyToImplicitArgs" title="StdAttachments.this.global.ApplyToImplicitArgs">ApplyToImplicitArgs</a><span class="delimiter">]</span> =&gt; <a href="#scala.tools.nsc.typechecker;StdAttachments.macroExpanderAttachment" title="(tree: StdAttachments.this.global.Tree)StdAttachments.this.MacroExpanderAttachment">macroExpanderAttachment</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;StdAttachments.macroExpanderAttachment.fn" title="StdAttachments.this.global.Tree">fn</a><span class="delimiter">)</span>
        case _ =&gt; <a href="#scala.tools.nsc.typechecker;StdAttachments.MacroExpanderAttachment.readResolve" title="(original: StdAttachments.this.global.Tree, desugared: StdAttachments.this.global.Tree)StdAttachments.this.MacroExpanderAttachment">MacroExpanderAttachment</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;StdAttachments.macroExpanderAttachment.tree" title="StdAttachments.this.global.Tree">tree</a>, <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees.EmptyTree" title="StdAttachments.this.global.EmptyTree.type">EmptyTree</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="comment">/** After macro expansion is completed, links the expandee and the expansion result
   *  by annotating them both with a `MacroExpansionAttachment`.
   */</span>
  def <a title="(expandee: StdAttachments.this.global.Tree, desugared: StdAttachments.this.global.Tree)Unit" id="scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndDesugared">linkExpandeeAndDesugared</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndDesugared.expandee">expandee</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a>, <a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndDesugared.desugared">desugared</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <span class="delimiter">{</span>
    val <a title="StdAttachments.this.MacroExpanderAttachment" id="scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndDesugared.metadata">metadata</a> = <a href="#scala.tools.nsc.typechecker;StdAttachments.MacroExpanderAttachment.readResolve" title="(original: StdAttachments.this.global.Tree, desugared: StdAttachments.this.global.Tree)StdAttachments.this.MacroExpanderAttachment">MacroExpanderAttachment</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndDesugared.expandee" title="StdAttachments.this.global.Tree">expandee</a>, <a href="#scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndDesugared.desugared" title="StdAttachments.this.global.Tree">desugared</a><span class="delimiter">)</span>
    <a href="#scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndDesugared.expandee" title="StdAttachments.this.global.Tree">expandee</a> <a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.updateAttachment" title="(attachment: StdAttachments.this.MacroExpanderAttachment)(implicit evidence$1: scala.reflect.ClassTag[StdAttachments.this.MacroExpanderAttachment])expandee.type">updateAttachment</a> <a href="#scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndDesugared.metadata" title="StdAttachments.this.MacroExpanderAttachment">metadata</a>
    <a href="#scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndDesugared.desugared" title="StdAttachments.this.global.Tree">desugared</a> <a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.updateAttachment" title="(attachment: StdAttachments.this.MacroExpanderAttachment)(implicit evidence$1: scala.reflect.ClassTag[StdAttachments.this.MacroExpanderAttachment])desugared.type">updateAttachment</a> <a href="#scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndDesugared.metadata" title="StdAttachments.this.MacroExpanderAttachment">metadata</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Is added by the macro engine to originals and results of macro expansions.
   *  Stores the original expandee as it entered the `macroExpand` function.
   */</span>
  case class <a title="class MacroExpansionAttachment extends AnyRef with Product with Serializable" id="scala.tools.nsc.typechecker;StdAttachments.MacroExpansionAttachment.readResolve">MacroExpansionAttachment</a><a href="../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments;MacroExpansionAttachment.expandee">expandee</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a>, <a title="Any" id="scala.tools.nsc.typechecker;StdAttachments;MacroExpansionAttachment.expanded">expanded</a>: <span title="Any">Any</span><span class="delimiter">)</span>

  <span class="comment">/** Determines whether the target is either an original or a result of a macro expansion.
   *  The parameter is of type `Any`, because macros can expand both into trees and into annotations.
   */</span>
  def <a title="(any: Any)Boolean" id="scala.tools.nsc.typechecker;StdAttachments.hasMacroExpansionAttachment">hasMacroExpansionAttachment</a><span class="delimiter">(</span><a title="Any" id="scala.tools.nsc.typechecker;StdAttachments.hasMacroExpansionAttachment.any">any</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.tools.nsc.typechecker;StdAttachments.hasMacroExpansionAttachment.any" title="Any">any</a> match <span class="delimiter">{</span>
    case <a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.hasMacroExpansionAttachment.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a> =&gt; <a href="#scala.tools.nsc.typechecker;StdAttachments.hasMacroExpansionAttachment.tree" title="StdAttachments.this.global.Tree">tree</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.hasAttachment" title="[T](implicit evidence$3: scala.reflect.ClassTag[T])Boolean">hasAttachment</a><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(implicit evidence$3: scala.reflect.ClassTag[StdAttachments.this.MacroExpansionAttachment])Boolean" class="delimiter">[</a><a href="#scala.tools.nsc.typechecker;StdAttachments.MacroExpansionAttachment.readResolve" title="StdAttachments.this.MacroExpansionAttachment">MacroExpansionAttachment</a><span class="delimiter">]</span>
    case _ =&gt; false
  <span class="delimiter">}</span>

  <span class="comment">/** Returns the original tree of the macro expansion if the argument is a macro expansion or EmptyTree otherwise.
   */</span>
  def <a title="(tree: StdAttachments.this.global.Tree)StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.macroExpandee">macroExpandee</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.macroExpandee.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a> = <a href="#scala.tools.nsc.typechecker;StdAttachments.macroExpandee.tree" title="StdAttachments.this.global.Tree">tree</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.attachments" title="=&gt; scala.reflect.macros.Attachments{type Pos = StdAttachments.this.global.Position}">attachments</a>.<a href="../../../reflect/macros/Attachments.scala.html#scala.reflect.macros;Attachments.get" title="[T](implicit evidence$2: scala.reflect.ClassTag[T])Option[T]">get</a><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(implicit evidence$2: scala.reflect.ClassTag[StdAttachments.this.MacroExpansionAttachment])Option[StdAttachments.this.MacroExpansionAttachment]" class="delimiter">[</a><a href="#scala.tools.nsc.typechecker;StdAttachments.MacroExpansionAttachment.readResolve" title="StdAttachments.this.MacroExpansionAttachment">MacroExpansionAttachment</a><span class="delimiter">]</span>.<a href="../../../Option.scala.html#scala;Option.map" title="(f: StdAttachments.this.MacroExpansionAttachment =&gt; StdAttachments.this.global.Tree)Option[StdAttachments.this.global.Tree]">map</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;StdAttachments.macroExpandee.$anonfun.x$1" title="StdAttachments.this.MacroExpansionAttachment">_</a>.<a href="#scala.tools.nsc.typechecker;StdAttachments;MacroExpansionAttachment.expandee" title="=&gt; StdAttachments.this.global.Tree">expandee</a><span class="delimiter">)</span>.<a href="../../../Option.scala.html#scala;Option.getOrElse" title="(default: =&gt; StdAttachments.this.global.Tree)StdAttachments.this.global.Tree">getOrElse</a><span class="delimiter">(</span><a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees.EmptyTree" title="StdAttachments.this.global.EmptyTree.type">EmptyTree</a><span class="delimiter">)</span>

  <span class="comment">/** After macro expansion is completed, links the expandee and the expansion result by annotating them both with a `MacroExpansionAttachment`.
   *  The `expanded` parameter is of type `Any`, because macros can expand both into trees and into annotations.
   */</span>
  def <a title="(expandee: StdAttachments.this.global.Tree, expanded: Any)Unit" id="scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndExpanded">linkExpandeeAndExpanded</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndExpanded.expandee">expandee</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a>, <span title="Any">expanded</span>: <span title="Any">Any</span><span class="delimiter">)</span>: <a href="../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <span class="delimiter">{</span>
    val <a title="StdAttachments.this.MacroExpansionAttachment" id="scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndExpanded.metadata">metadata</a> = <a href="#scala.tools.nsc.typechecker;StdAttachments.MacroExpansionAttachment.readResolve" title="(expandee: StdAttachments.this.global.Tree, expanded: Any)StdAttachments.this.MacroExpansionAttachment">MacroExpansionAttachment</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndExpanded.expandee" title="StdAttachments.this.global.Tree">expandee</a>, <span title="Any">expanded</span><span class="delimiter">)</span>
    <a href="#scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndExpanded.expandee" title="StdAttachments.this.global.Tree">expandee</a> <a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.updateAttachment" title="(attachment: StdAttachments.this.MacroExpansionAttachment)(implicit evidence$1: scala.reflect.ClassTag[StdAttachments.this.MacroExpansionAttachment])expandee.type">updateAttachment</a> <a href="#scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndExpanded.metadata" title="StdAttachments.this.MacroExpansionAttachment">metadata</a>
    <span title="Any">expanded</span> match <span class="delimiter">{</span>
      case <span title="StdAttachments.this.global.Tree">expanded</span>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a> =&gt; <span title="StdAttachments.this.global.Tree">expanded</span> <a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.updateAttachment" title="(attachment: StdAttachments.this.MacroExpansionAttachment)(implicit evidence$1: scala.reflect.ClassTag[StdAttachments.this.MacroExpansionAttachment])expanded.type">updateAttachment</a> <a href="#scala.tools.nsc.typechecker;StdAttachments.linkExpandeeAndExpanded.metadata" title="StdAttachments.this.MacroExpansionAttachment">metadata</a>
      case _ =&gt; <span class="comment">// do nothing</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** When present, suppresses macro expansion for the host.
   *  This is occasionally necessary, e.g. to prohibit eta-expansion of macros.
   *
   *  Does not affect expandability of child nodes, there's context.withMacrosDisabled for that
   *  (but think thrice before using that API - see the discussion at https://github.com/scala/scala/pull/1639).
   */</span>
  case object <a href="#scala.tools.nsc.typechecker;StdAttachments.SuppressMacroExpansionAttachment.productElement.x$1" title="StdAttachments.this.SuppressMacroExpansionAttachment.type" id="scala.tools.nsc.typechecker;StdAttachments.SuppressMacroExpansionAttachment.readResolve">SuppressMacroExpansionAttachment</a>

  <span class="comment">/** Suppresses macro expansion of the tree by putting SuppressMacroExpansionAttachment on it.
   */</span>
  def <a title="(tree: StdAttachments.this.global.Tree)StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.suppressMacroExpansion">suppressMacroExpansion</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.suppressMacroExpansion.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.typechecker;StdAttachments.suppressMacroExpansion.tree" title="StdAttachments.this.global.Tree">tree</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.updateAttachment" title="(attachment: StdAttachments.this.SuppressMacroExpansionAttachment.type)(implicit evidence$1: scala.reflect.ClassTag[StdAttachments.this.SuppressMacroExpansionAttachment.type])tree.type">updateAttachment</a><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(runtimeClass1: Class[_])scala.reflect.ClassTag[StdAttachments.this.SuppressMacroExpansionAttachment.type]" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;StdAttachments.SuppressMacroExpansionAttachment.readResolve" title="StdAttachments.this.SuppressMacroExpansionAttachment.type">SuppressMacroExpansionAttachment</a><span class="delimiter">)</span>

  <span class="comment">/** Unsuppresses macro expansion of the tree by removing SuppressMacroExpansionAttachment from it and its children.
   */</span>
  def <a title="(tree: StdAttachments.this.global.Tree)StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.unsuppressMacroExpansion">unsuppressMacroExpansion</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.unsuppressMacroExpansion.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a> = <span class="delimiter">{</span>
    <a href="#scala.tools.nsc.typechecker;StdAttachments.unsuppressMacroExpansion.tree" title="StdAttachments.this.global.Tree">tree</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.removeAttachment" title="[T](implicit evidence$2: scala.reflect.ClassTag[T])tree.type">removeAttachment</a><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(implicit evidence$2: scala.reflect.ClassTag[StdAttachments.this.SuppressMacroExpansionAttachment.type])tree.type" class="delimiter">[</a>SuppressMacroExpansionAttachment.type<span class="delimiter">]</span>
    <a href="#scala.tools.nsc.typechecker;StdAttachments.unsuppressMacroExpansion.tree" title="StdAttachments.this.global.Tree">tree</a> match <span class="delimiter">{</span>
      <span class="comment">// see the comment to `isMacroExpansionSuppressed` to learn why we need</span>
      <span class="comment">// a special traversal strategy here</span>
      case Apply<span class="delimiter">(</span><span title="StdAttachments.this.global.Tree">fn</span>, _<span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.typechecker;StdAttachments.unsuppressMacroExpansion" title="(tree: StdAttachments.this.global.Tree)StdAttachments.this.global.Tree">unsuppressMacroExpansion</a><span class="delimiter">(</span><span title="StdAttachments.this.global.Tree">fn</span><span class="delimiter">)</span>
      case TypeApply<span class="delimiter">(</span><span title="StdAttachments.this.global.Tree">fn</span>, _<span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.typechecker;StdAttachments.unsuppressMacroExpansion" title="(tree: StdAttachments.this.global.Tree)StdAttachments.this.global.Tree">unsuppressMacroExpansion</a><span class="delimiter">(</span><span title="StdAttachments.this.global.Tree">fn</span><span class="delimiter">)</span>
      case _ =&gt; <span class="comment">// do nothing</span>
    <span class="delimiter">}</span>
    <a href="#scala.tools.nsc.typechecker;StdAttachments.unsuppressMacroExpansion.tree" title="StdAttachments.this.global.Tree">tree</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Determines whether a tree should not be expanded, because someone has put SuppressMacroExpansionAttachment on it or one of its children.
   */</span>
  def <a title="(tree: StdAttachments.this.global.Tree)Boolean" id="scala.tools.nsc.typechecker;StdAttachments.isMacroExpansionSuppressed">isMacroExpansionSuppressed</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.isMacroExpansionSuppressed.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> =
    <span class="delimiter">(</span>  <a href="../Global.scala.html#scala.tools.nsc;Global.settings" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#scala.tools.nsc.settings;ScalaSettings.Ymacroexpand" title="=&gt; scala.tools.nsc.Settings#ChoiceSetting">Ymacroexpand</a>.<a href="../../../reflect/internal/settings/MutableSettings.scala.html#scala.reflect.internal.settings;MutableSettings;SettingValue.value" title="=&gt; String">value</a> <span title="(x$1: Any)Boolean">==</span> <a href="../Global.scala.html#scala.tools.nsc;Global.settings" title="=&gt; scala.tools.nsc.Settings">settings</a>.<a href="../settings/ScalaSettings.scala.html#scala.tools.nsc.settings;ScalaSettings.MacroExpand" title="scala.tools.nsc.Settings#MacroExpand.type">MacroExpand</a>.<a href="../settings/ScalaSettings.scala.html#scala.tools.nsc.settings;ScalaSettings.MacroExpand.None" title="=&gt; String">None</a> <span class="comment">// SI-6812</span>
    <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.tools.nsc.typechecker;StdAttachments.isMacroExpansionSuppressed.tree" title="StdAttachments.this.global.Tree">tree</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.hasAttachment" title="[T](implicit evidence$3: scala.reflect.ClassTag[T])Boolean">hasAttachment</a><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(implicit evidence$3: scala.reflect.ClassTag[StdAttachments.this.SuppressMacroExpansionAttachment.type])Boolean" class="delimiter">[</a>SuppressMacroExpansionAttachment.type<span class="delimiter">]</span>
    <a href="../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;StdAttachments.isMacroExpansionSuppressed.tree" title="StdAttachments.this.global.Tree">tree</a> match <span class="delimiter">{</span>
        <span class="comment">// we have to account for the fact that during typechecking an expandee might become wrapped,</span>
        <span class="comment">// i.e. surrounded by an inferred implicit argument application or by an inferred type argument application.</span>
        <span class="comment">// in that case the expandee itself will no longer be suppressed and we need to look at the core</span>
        case Apply<span class="delimiter">(</span><span title="StdAttachments.this.global.Tree">fn</span>, _<span class="delimiter">)</span>     =&gt; <a href="#scala.tools.nsc.typechecker;StdAttachments.isMacroExpansionSuppressed" title="(tree: StdAttachments.this.global.Tree)Boolean">isMacroExpansionSuppressed</a><span class="delimiter">(</span><span title="StdAttachments.this.global.Tree">fn</span><span class="delimiter">)</span>
        case TypeApply<span class="delimiter">(</span><span title="StdAttachments.this.global.Tree">fn</span>, _<span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.typechecker;StdAttachments.isMacroExpansionSuppressed" title="(tree: StdAttachments.this.global.Tree)Boolean">isMacroExpansionSuppressed</a><span class="delimiter">(</span><span title="StdAttachments.this.global.Tree">fn</span><span class="delimiter">)</span>
        case _                =&gt; false
      <span class="delimiter">}</span><span class="delimiter">)</span>
    <span class="delimiter">)</span>

  <span class="comment">/** After being synthesized by the parser, primary constructors aren't fully baked yet.
   *  A call to super in such constructors is just a fill-me-in-later dummy resolved later
   *  by `parentTypes`. This attachment coordinates `parentTypes` and `typedTemplate` and
   *  allows them to complete the synthesis.
   */</span>
  case class <a title="class SuperArgsAttachment extends AnyRef with Product with Serializable" id="scala.tools.nsc.typechecker;StdAttachments.SuperArgsAttachment.readResolve">SuperArgsAttachment</a><a href="../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="List[List[StdAttachments.this.global.Tree]]" id="scala.tools.nsc.typechecker;StdAttachments;SuperArgsAttachment.argss">argss</a>: <a href="../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[StdAttachments.this.global.Tree]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">/** Convenience method for `SuperArgsAttachment`.
   *  Compared with `MacroRuntimeAttachment` this attachment has different a usage pattern,
   *  so it really benefits from a dedicated extractor.
   */</span>
  def <a title="(tree: StdAttachments.this.global.Tree)Option[List[List[StdAttachments.this.global.Tree]]]" id="scala.tools.nsc.typechecker;StdAttachments.superArgs">superArgs</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.superArgs.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../Option.scala.html#scala;Option" title="Option[List[List[StdAttachments.this.global.Tree]]]">Option</a><span class="delimiter">[</span>List<span class="delimiter">[</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#scala.tools.nsc.typechecker;StdAttachments.superArgs.tree" title="StdAttachments.this.global.Tree">tree</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.attachments" title="=&gt; scala.reflect.macros.Attachments{type Pos = StdAttachments.this.global.Position}">attachments</a>.<a href="../../../reflect/macros/Attachments.scala.html#scala.reflect.macros;Attachments.get" title="[T](implicit evidence$2: scala.reflect.ClassTag[T])Option[T]">get</a><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(implicit evidence$2: scala.reflect.ClassTag[StdAttachments.this.SuperArgsAttachment])Option[StdAttachments.this.SuperArgsAttachment]" class="delimiter">[</a><a href="#scala.tools.nsc.typechecker;StdAttachments.SuperArgsAttachment.readResolve" title="StdAttachments.this.SuperArgsAttachment">SuperArgsAttachment</a><span class="delimiter">]</span> <a href="../../../Option.scala.html#scala;Option.collect" title="(pf: PartialFunction[StdAttachments.this.SuperArgsAttachment,List[List[StdAttachments.this.global.Tree]]])Option[List[List[StdAttachments.this.global.Tree]]]">collect</a> <a title="&lt;$anon: StdAttachments.this.SuperArgsAttachment =&gt; List[List[StdAttachments.this.global.Tree]]&gt; extends scala.runtime.AbstractPartialFunction[StdAttachments.this.SuperArgsAttachment,List[List[StdAttachments.this.global.Tree]]] with Serializable" id="scala.tools.nsc.typechecker;StdAttachments.superArgs;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> case SuperArgsAttachment<span class="delimiter">(</span><a title="List[List[StdAttachments.this.global.Tree]]" id="scala.tools.nsc.typechecker;StdAttachments.superArgs;$anonfun.isDefinedAt.argss">argss</a><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.typechecker;StdAttachments.superArgs;$anonfun.isDefinedAt.argss" title="List[List[StdAttachments.this.global.Tree]]">argss</a> <span class="delimiter">}</span>

  <span class="comment">/** Determines whether the given tree has an associated SuperArgsAttachment.
   */</span>
  def <a title="(tree: StdAttachments.this.global.Tree)Boolean" id="scala.tools.nsc.typechecker;StdAttachments.hasSuperArgs">hasSuperArgs</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.hasSuperArgs.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.tools.nsc.typechecker;StdAttachments.superArgs" title="(tree: StdAttachments.this.global.Tree)Option[List[List[StdAttachments.this.global.Tree]]]">superArgs</a><span class="delimiter">(</span><a href="#scala.tools.nsc.typechecker;StdAttachments.hasSuperArgs.tree" title="StdAttachments.this.global.Tree">tree</a><span class="delimiter">)</span>.<a href="../../../Option.scala.html#scala;Option.nonEmpty" title="=&gt; Boolean">nonEmpty</a>

  <span class="comment">/** @see markMacroImplRef
   */</span>
  case object <a href="#scala.tools.nsc.typechecker;StdAttachments.MacroImplRefAttachment.productElement.x$1" title="StdAttachments.this.MacroImplRefAttachment.type" id="scala.tools.nsc.typechecker;StdAttachments.MacroImplRefAttachment.readResolve">MacroImplRefAttachment</a>

  <span class="comment">/** Marks the tree as a macro impl reference, which is a naked reference to a method.
   *
   *  This is necessary for typechecking macro impl references (see `DefaultMacroCompiler.defaultResolveMacroImpl`),
   *  because otherwise typing a naked reference will result in the &quot;follow this method with `_' if you want to
   *  treat it as a partially applied function&quot; errors.
   *
   *  This mark suppresses adapt except for when the annottee is a macro application.
   */</span>
  def <a title="(tree: StdAttachments.this.global.Tree)StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.markMacroImplRef">markMacroImplRef</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.markMacroImplRef.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a> = <a href="#scala.tools.nsc.typechecker;StdAttachments.markMacroImplRef.tree" title="StdAttachments.this.global.Tree">tree</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.updateAttachment" title="(attachment: StdAttachments.this.MacroImplRefAttachment.type)(implicit evidence$1: scala.reflect.ClassTag[StdAttachments.this.MacroImplRefAttachment.type])tree.type">updateAttachment</a><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(runtimeClass1: Class[_])scala.reflect.ClassTag[StdAttachments.this.MacroImplRefAttachment.type]" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;StdAttachments.MacroImplRefAttachment.readResolve" title="StdAttachments.this.MacroImplRefAttachment.type">MacroImplRefAttachment</a><span class="delimiter">)</span>

  <span class="comment">/** Unmarks the tree as a macro impl reference (see `markMacroImplRef` for more information).
   *
   *  This is necessary when a tree that was previously deemed to be a macro impl reference,
   *  typechecks to be a macro application. Then we need to unmark it, expand it and try to treat
   *  its expansion as a macro impl reference.
   */</span>
  def <a title="(tree: StdAttachments.this.global.Tree)StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.unmarkMacroImplRef">unmarkMacroImplRef</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.unmarkMacroImplRef.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a> = <a href="#scala.tools.nsc.typechecker;StdAttachments.unmarkMacroImplRef.tree" title="StdAttachments.this.global.Tree">tree</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.removeAttachment" title="[T](implicit evidence$2: scala.reflect.ClassTag[T])tree.type">removeAttachment</a><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(implicit evidence$2: scala.reflect.ClassTag[StdAttachments.this.MacroImplRefAttachment.type])tree.type" class="delimiter">[</a>MacroImplRefAttachment.type<span class="delimiter">]</span>

  <span class="comment">/** Determines whether a tree should or should not be adapted,
   *  because someone has put MacroImplRefAttachment on it.
   */</span>
  def <a title="(tree: StdAttachments.this.global.Tree)Boolean" id="scala.tools.nsc.typechecker;StdAttachments.isMacroImplRef">isMacroImplRef</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.isMacroImplRef.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.tools.nsc.typechecker;StdAttachments.isMacroImplRef.tree" title="StdAttachments.this.global.Tree">tree</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.hasAttachment" title="[T](implicit evidence$3: scala.reflect.ClassTag[T])Boolean">hasAttachment</a><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(implicit evidence$3: scala.reflect.ClassTag[StdAttachments.this.MacroImplRefAttachment.type])Boolean" class="delimiter">[</a>MacroImplRefAttachment.type<span class="delimiter">]</span>

  <span class="comment">/** Since mkInvoke, the applyDynamic/selectDynamic/etc desugarer, is disconnected
   *  from typedNamedApply, the applyDynamicNamed argument rewriter, the latter
   *  doesn’t know whether it needs to apply the rewriting because the application
   *  has just been desugared or it needs to hold on because it’s already performed
   *  a desugaring on this tree. This has led to SI-8006.
   *
   *  This attachment solves the problem by providing a means of communication
   *  between the two Dynamic desugarers, which solves the aforementioned issue.
   */</span>
  case object <a href="#scala.tools.nsc.typechecker;StdAttachments.DynamicRewriteAttachment.productElement.x$1" title="StdAttachments.this.DynamicRewriteAttachment.type" id="scala.tools.nsc.typechecker;StdAttachments.DynamicRewriteAttachment.readResolve">DynamicRewriteAttachment</a>
  def <a title="(tree: StdAttachments.this.global.Tree)StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.markDynamicRewrite">markDynamicRewrite</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.markDynamicRewrite.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a> = <a href="#scala.tools.nsc.typechecker;StdAttachments.markDynamicRewrite.tree" title="StdAttachments.this.global.Tree">tree</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.updateAttachment" title="(attachment: StdAttachments.this.DynamicRewriteAttachment.type)(implicit evidence$1: scala.reflect.ClassTag[StdAttachments.this.DynamicRewriteAttachment.type])tree.type">updateAttachment</a><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(runtimeClass1: Class[_])scala.reflect.ClassTag[StdAttachments.this.DynamicRewriteAttachment.type]" class="delimiter">(</a><a href="#scala.tools.nsc.typechecker;StdAttachments.DynamicRewriteAttachment.readResolve" title="StdAttachments.this.DynamicRewriteAttachment.type">DynamicRewriteAttachment</a><span class="delimiter">)</span>
  def <a title="(tree: StdAttachments.this.global.Tree)StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.unmarkDynamicRewrite">unmarkDynamicRewrite</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.unmarkDynamicRewrite.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a> = <a href="#scala.tools.nsc.typechecker;StdAttachments.unmarkDynamicRewrite.tree" title="StdAttachments.this.global.Tree">tree</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.removeAttachment" title="[T](implicit evidence$2: scala.reflect.ClassTag[T])tree.type">removeAttachment</a><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(implicit evidence$2: scala.reflect.ClassTag[StdAttachments.this.DynamicRewriteAttachment.type])tree.type" class="delimiter">[</a>DynamicRewriteAttachment.type<span class="delimiter">]</span>
  def <a title="(tree: StdAttachments.this.global.Tree)Boolean" id="scala.tools.nsc.typechecker;StdAttachments.isDynamicRewrite">isDynamicRewrite</a><span class="delimiter">(</span><a title="StdAttachments.this.global.Tree" id="scala.tools.nsc.typechecker;StdAttachments.isDynamicRewrite.tree">tree</a>: <a href="../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="StdAttachments.this.global.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.tools.nsc.typechecker;StdAttachments.isDynamicRewrite.tree" title="StdAttachments.this.global.Tree">tree</a>.<a href="../../../reflect/internal/StdAttachments.scala.html#scala.reflect.internal;StdAttachments;Attachable.attachments" title="=&gt; scala.reflect.macros.Attachments{type Pos = StdAttachments.this.global.Position}">attachments</a>.<a href="../../../reflect/macros/Attachments.scala.html#scala.reflect.macros;Attachments.get" title="[T](implicit evidence$2: scala.reflect.ClassTag[T])Option[T]">get</a><a href="../../../reflect/ClassTag.scala.html#scala.reflect.ClassTag.apply" title="(implicit evidence$2: scala.reflect.ClassTag[StdAttachments.this.DynamicRewriteAttachment.type])Option[StdAttachments.this.DynamicRewriteAttachment.type]" class="delimiter">[</a>DynamicRewriteAttachment.type<span class="delimiter">]</span>.<a href="../../../Option.scala.html#scala;Option.isDefined" title="=&gt; Boolean">isDefined</a>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
