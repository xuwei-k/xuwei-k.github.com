<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/tools/nsc/transform/patmat/Logic.scala</title>
        <script type="text/javascript" src="../../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* NSC -- new Scala compiler
 *
 * Copyright 2011-2013 LAMP/EPFL
 * @author Adriaan Moors
 */</span>

package scala
package tools.nsc.transform.patmat

import scala.<a href="../../../../language.scala.html#scala.language" title="language.type">language</a>.postfixOps
import scala.collection.mutable
import scala.reflect.internal.util.Statistics
import scala.reflect.internal.util.HashSet

trait <a title="trait Logic extends AnyRef with scala.tools.nsc.transform.patmat.Debugging" id="scala.tools.nsc.transform.patmat;Logic">Logic</a> extends <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging" title="scala.tools.nsc.transform.patmat.Debugging">Debugging</a>  <span class="delimiter">{</span>
  import <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat.PatternMatchingStats" title="scala.tools.nsc.transform.patmat.PatternMatchingStats.type">PatternMatchingStats</a>._

  private def <a title="(xs: Seq[Int])Int" id="scala.tools.nsc.transform.patmat;Logic.max">max</a><span class="delimiter">(</span><a title="Seq[Int]" id="scala.tools.nsc.transform.patmat;Logic.max.xs">xs</a>: <a href="../../../../collection/Seq.scala.html#scala.collection;Seq" title="Seq[Int]">Seq</a><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">)</span> = if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.max.xs" title="Seq[Int]">xs</a> <a href="../../../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> else <a href="#scala.tools.nsc.transform.patmat;Logic.max.xs" title="Seq[Int]">xs</a> <a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.max" title="(implicit cmp: Ordering[Int])Int">max</a>
  private def <a title="(cols: Seq[AnyRef])Seq[String]" id="scala.tools.nsc.transform.patmat;Logic.alignedColumns">alignedColumns</a><span class="delimiter">(</span><a title="Seq[AnyRef]" id="scala.tools.nsc.transform.patmat;Logic.alignedColumns.cols">cols</a>: <a href="../../../../collection/Seq.scala.html#scala.collection;Seq" title="Seq[AnyRef]">Seq</a><span class="delimiter">[</span>AnyRef<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../../collection/Seq.scala.html#scala.collection;Seq" title="Seq[String]">Seq</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    def <a title="(x: AnyRef)String" id="scala.tools.nsc.transform.patmat;Logic.alignedColumns.toString">toString</a><span class="delimiter">(</span><a title="AnyRef" id="scala.tools.nsc.transform.patmat;Logic.alignedColumns.toString.x">x</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span> = if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.toString.x" title="AnyRef">x</a> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> else <a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.toString.x" title="AnyRef">x</a>.<span title="()String">toString</span>
    if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.cols" title="Seq[AnyRef]">cols</a>.<a href="../../../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a> <a href="../../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.cols" title="Seq[AnyRef]">cols</a>.<a href="../../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.tails" title="=&gt; Iterator[Seq[AnyRef]]">tails</a>.<a href="../../../../collection/Iterator.scala.html#scala.collection;Iterator.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.cols" title="Seq[AnyRef]">cols</a> <a href="../../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.map" title="(f: AnyRef =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[AnyRef],String,Seq[String]])Seq[String]">map</a> <a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.toString" title="(x: AnyRef)String">toString</a>
    else <span class="delimiter">{</span>
      val colLens = <a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.cols" title="Seq[AnyRef]">cols</a> <a href="../../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.map" title="Seq[Int]" id="scala.tools.nsc.transform.patmat;Logic.alignedColumns.colLens">map</a> <span class="delimiter">(</span><a title="AnyRef" id="scala.tools.nsc.transform.patmat;Logic.alignedColumns.colLens.$anonfun.c">c</a> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.toString" title="(x: AnyRef)String">toString</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.colLens.$anonfun.c" title="AnyRef">c</a><span class="delimiter">)</span>.<span title="()Int">length</span><span class="delimiter">)</span>
      val <a title="Int" id="scala.tools.nsc.transform.patmat;Logic.alignedColumns.maxLen">maxLen</a> = <a href="#scala.tools.nsc.transform.patmat;Logic.max" title="(xs: Seq[Int])Int">max</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.colLens" title="Seq[Int]">colLens</a><span class="delimiter">)</span>
      val avgLen = <a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.colLens" title="Seq[Int]">colLens</a>.<a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.sum" title="(implicit num: Numeric[Int])Int">sum</a><a href="../../../../Int.scala.html#scala;Int./(1409840560)" title="Int" id="scala.tools.nsc.transform.patmat;Logic.alignedColumns.avgLen">/</a><a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.colLens" title="Seq[Int]">colLens</a>.<a href="../../../../collection/SeqLike.scala.html#scala.collection;SeqLike.length" title="=&gt; Int">length</a>
      val goalLen = <a href="../../../../Predef.scala.html#scala;LowPriorityImplicits.intWrapper" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">maxLen</a> <a href="../../../../runtime/RichInt.scala.html#scala.runtime;RichInt.min" title="Int" id="scala.tools.nsc.transform.patmat;Logic.alignedColumns.goalLen">min</a> <a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.avgLen" title="Int">avgLen</a><a href="../../../../Int.scala.html#scala;Int.*(1409840560)" title="(x: Int)Int">*</a><span title="Int(2)" class="int">2</span>
      def <a title="(s: String)String" id="scala.tools.nsc.transform.patmat;Logic.alignedColumns.pad">pad</a><span class="delimiter">(</span><a title="String" id="scala.tools.nsc.transform.patmat;Logic.alignedColumns.pad.s">s</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
        val toAdd = <span class="delimiter">(</span><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.goalLen" title="Int">goalLen</a> <a href="../../../../Predef.scala.html#scala;LowPriorityImplicits.intWrapper" title="implicit scala.LowPriorityImplicits.intWrapper : (x: Int)scala.runtime.RichInt">-</a> <a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.pad.s" title="String">s</a>.<span title="()Int">length</span><span class="delimiter">)</span> <a href="../../../../runtime/RichInt.scala.html#scala.runtime;RichInt.max" title="(that: Int)Int">max</a> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="../../../../Int.scala.html#scala;Int.+(1409840560)" title="Int" id="scala.tools.nsc.transform.patmat;Logic.alignedColumns.pad.toAdd">+</a> <span title="Int(2)" class="int">2</span>
        <span class="delimiter">(</span><a href="../../../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot; &quot;</a> <a href="../../../../collection/immutable/StringLike.scala.html#scala.collection.immutable;StringLike.*" title="(n: Int)String">*</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.pad.toAdd" title="Int">toAdd</a><a href="../../../../Int.scala.html#scala;Int./(1409840560)" title="(x: Int)Int">/</a><span title="Int(2)" class="int">2</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.pad.s" title="String">s</a> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="../../../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot; &quot;</a> <a href="../../../../collection/immutable/StringLike.scala.html#scala.collection.immutable;StringLike.*" title="(n: Int)String">*</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.pad.toAdd" title="Int">toAdd</a><a href="../../../../Int.scala.html#scala;Int./(1409840560)" title="(x: Int)Int">/</a><span title="Int(2)" class="int">2</span> <a href="../../../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.pad.toAdd" title="Int">toAdd</a><a href="../../../../Int.scala.html#scala;Int.%(1409840560)" title="(x: Int)Int">%</a><span title="Int(2)" class="int">2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.cols" title="Seq[AnyRef]">cols</a> <a href="../../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.map" title="(f: AnyRef =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[AnyRef],String,Seq[String]])Seq[String]">map</a> <span class="delimiter">(</span><a title="AnyRef" id="scala.tools.nsc.transform.patmat;Logic.alignedColumns.$anonfun.x">x</a> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.pad" title="(s: String)String">pad</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.toString" title="(x: AnyRef)String">toString</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns.$anonfun.x" title="AnyRef">x</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="(xss: List[List[AnyRef]], sep: String, lineSep: String)String" id="scala.tools.nsc.transform.patmat;Logic.alignAcrossRows">alignAcrossRows</a><span class="delimiter">(</span><a title="List[List[AnyRef]]" id="scala.tools.nsc.transform.patmat;Logic.alignAcrossRows.xss">xss</a>: <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[List[AnyRef]]">List</a><span class="delimiter">[</span>List<span class="delimiter">[</span>AnyRef<span class="delimiter">]</span><span class="delimiter">]</span>, <a title="String" id="scala.tools.nsc.transform.patmat;Logic.alignAcrossRows.sep">sep</a>: <span title="String">String</span>, <a title="String" id="scala.tools.nsc.transform.patmat;Logic.alignAcrossRows$default$3">lineSep</a>: <span title="String">String</span> = <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    val <a title="Int" id="scala.tools.nsc.transform.patmat;Logic.alignAcrossRows.maxLen">maxLen</a> = <a href="#scala.tools.nsc.transform.patmat;Logic.max" title="(xs: Seq[Int])Int">max</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignAcrossRows.xss" title="List[List[AnyRef]]">xss</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: List[AnyRef] =&gt; Int)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[AnyRef]],Int,Seq[Int]])Seq[Int]">map</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignAcrossRows.maxLen.$anonfun.x$1" title="List[AnyRef]">_</a>.<a href="../../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.length" title="=&gt; Int">length</a><span class="delimiter">)</span><span class="delimiter">)</span>
    val padded = <a href="#scala.tools.nsc.transform.patmat;Logic.alignAcrossRows.xss" title="List[List[AnyRef]]">xss</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="List[List[AnyRef]]" id="scala.tools.nsc.transform.patmat;Logic.alignAcrossRows.padded">map</a> <span class="delimiter">(</span><a title="List[AnyRef]" id="scala.tools.nsc.transform.patmat;Logic.alignAcrossRows.padded.$anonfun.xs">xs</a> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic.alignAcrossRows.padded.$anonfun.xs" title="List[AnyRef]">xs</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.++" title="(that: scala.collection.GenTraversableOnce[AnyRef])(implicit bf: scala.collection.generic.CanBuildFrom[List[AnyRef],AnyRef,List[AnyRef]])List[AnyRef]">++</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.List" title="scala.collection.immutable.List.type">List</a>.<a href="../../../../collection/generic/GenTraversableFactory.scala.html#scala.collection.generic;GenTraversableFactory.fill(7c98e57083)" title="(n: Int)(elem: =&gt; Null)List[Null]">fill</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignAcrossRows.maxLen" title="Int">maxLen</a> <a href="../../../../Int.scala.html#scala;Int.-(1409840560)" title="(x: Int)Int">-</a> <a href="#scala.tools.nsc.transform.patmat;Logic.alignAcrossRows.padded.$anonfun.xs" title="List[AnyRef]">xs</a>.<a href="../../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.length" title="=&gt; Int">length</a><span class="delimiter">)</span><span class="delimiter">(</span>null<span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#scala.tools.nsc.transform.patmat;Logic.alignAcrossRows.padded" title="List[List[AnyRef]]">padded</a>.<a href="../../../../collection/generic/GenericTraversableTemplate.scala.html#scala.collection.generic;GenericTraversableTemplate.transpose" title="(implicit asTraversable: List[AnyRef] =&gt; scala.collection.GenTraversableOnce[AnyRef])List[List[AnyRef]]">transpose</a>.<a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: List[AnyRef] =&gt; Seq[String])(implicit bf: scala.collection.generic.CanBuildFrom[List[List[AnyRef]],Seq[String],List[Seq[String]]])List[Seq[String]]">map</a><a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.List.canBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Seq[String],List[Seq[String]]]" class="delimiter">(</a><a href="#scala.tools.nsc.transform.patmat;Logic.alignedColumns" title="(cols: Seq[AnyRef])Seq[String]">alignedColumns</a><span class="delimiter">)</span>.<a href="../../../../collection/generic/GenericTraversableTemplate.scala.html#scala.collection.generic;GenericTraversableTemplate.transpose" title="(implicit asTraversable: Seq[String] =&gt; scala.collection.GenTraversableOnce[String])List[List[String]]">transpose</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: List[String] =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[List[String]],String,List[String]])List[String]">map</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignAcrossRows.$anonfun.x$2" title="List[String]">_</a>.<a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignAcrossRows.sep" title="String">sep</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic.alignAcrossRows$default$3" title="String">lineSep</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// http://www.cis.upenn.edu/~cis510/tcl/chap3.pdf</span>
  <span class="comment">// http://users.encs.concordia.ca/~ta_ahmed/ms_thesis.pdf</span>
  <span class="comment">// propositional logic with constants and equality</span>
  trait <a title="trait PropositionalLogic extends AnyRef" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic">PropositionalLogic</a> <a href="../../../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a>
    type <a title="" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Type">Type</a>
    type <a title="" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Tree">Tree</a>

    class <a title="class Prop extends AnyRef" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop">Prop</a>
    case class <a title="class Eq extends PropositionalLogic.this.Prop with Product with Serializable" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Eq.readResolve">Eq</a><a href="../../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="PropositionalLogic.this.Var" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Eq.p">p</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Var" title="PropositionalLogic.this.Var">Var</a>, <a title="PropositionalLogic.this.Const" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Eq.q">q</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Const" title="PropositionalLogic.this.Const">Const</a><span class="delimiter">)</span> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a>

    type <a title="" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Const">Const</a>

    type <a title=" &lt;: PropositionalLogic.this.Const" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;TypeConst">TypeConst</a> &lt;: Const
    def <a title="=&gt; PropositionalLogic.this.TypeConstExtractor" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.TypeConst">TypeConst</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;TypeConstExtractor" title="PropositionalLogic.this.TypeConstExtractor">TypeConstExtractor</a>
    trait <a title="trait TypeConstExtractor extends AnyRef" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;TypeConstExtractor">TypeConstExtractor</a> <span class="delimiter">{</span>
      def <a title="(tp: PropositionalLogic.this.Type)PropositionalLogic.this.Const" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;TypeConstExtractor.apply">apply</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Type" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;TypeConstExtractor.apply.tp">tp</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Type" title="PropositionalLogic.this.Type">Type</a><span class="delimiter">)</span>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Const" title="PropositionalLogic.this.Const">Const</a>
    <span class="delimiter">}</span>

    type <a title=" &lt;: PropositionalLogic.this.Const" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;ValueConst">ValueConst</a> &lt;: Const
    def <a title="=&gt; PropositionalLogic.this.ValueConstExtractor" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.ValueConst">ValueConst</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;ValueConstExtractor" title="PropositionalLogic.this.ValueConstExtractor">ValueConstExtractor</a>
    trait <a title="trait ValueConstExtractor extends AnyRef" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;ValueConstExtractor">ValueConstExtractor</a> <span class="delimiter">{</span>
      def <a title="(p: PropositionalLogic.this.Tree)PropositionalLogic.this.Const" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;ValueConstExtractor.apply">apply</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Tree" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;ValueConstExtractor.apply.p">p</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Tree" title="PropositionalLogic.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Const" title="PropositionalLogic.this.Const">Const</a>
    <span class="delimiter">}</span>

    val <a title="=&gt; PropositionalLogic.this.Const" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.NullConst">NullConst</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Const" title="PropositionalLogic.this.Const">Const</a>

    type <a title=" &lt;: PropositionalLogic.this.AbsVar" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Var">Var</a> &lt;: AbsVar
    val <a title="=&gt; PropositionalLogic.this.VarExtractor" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Var">Var</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;VarExtractor" title="PropositionalLogic.this.VarExtractor">VarExtractor</a>
    trait <a title="trait VarExtractor extends AnyRef" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;VarExtractor">VarExtractor</a> <span class="delimiter">{</span>
      def <a title="(x: PropositionalLogic.this.Tree)PropositionalLogic.this.Var" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;VarExtractor.apply">apply</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Tree" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;VarExtractor.apply.x">x</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Tree" title="PropositionalLogic.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Var" title="PropositionalLogic.this.Var">Var</a>
      def <a title="(v: PropositionalLogic.this.Var)Some[PropositionalLogic.this.Tree]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;VarExtractor.unapply">unapply</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Var" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;VarExtractor.unapply.v">v</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Var" title="PropositionalLogic.this.Var">Var</a><span class="delimiter">)</span>: <a href="../../../../Option.scala.html#scala;Some" title="Some[PropositionalLogic.this.Tree]">Some</a><span class="delimiter">[</span>Tree<span class="delimiter">]</span>
    <span class="delimiter">}</span>

    def <a title="(message: String)Unit" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.reportWarning">reportWarning</a><span class="delimiter">(</span><a title="String" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.reportWarning.message">message</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="../../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>

    <span class="comment">// resets hash consing -- only supposed to be called by TreeMakersToProps</span>
    def <a title="()Unit" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.prepareNewAnalysis">prepareNewAnalysis</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>

    trait <a title="trait AbsVar extends AnyRef" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar">AbsVar</a> <span class="delimiter">{</span>
      <span class="comment">// indicate we may later require a prop for V = C</span>
      def <a title="(c: PropositionalLogic.this.Const)Unit" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.registerEquality">registerEquality</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Const" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.registerEquality.c">c</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Const" title="PropositionalLogic.this.Const">Const</a><span class="delimiter">)</span>: <a href="../../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>

      <span class="comment">// call this to indicate null is part of the domain</span>
      def <a title="()Unit" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.registerNull">registerNull</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>

      <span class="comment">// can this variable be null?</span>
      def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.mayBeNull">mayBeNull</a>: <a href="../../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a>

      <span class="comment">// compute the domain and return it (call registerNull first!)</span>
      def <a title="=&gt; Option[Set[PropositionalLogic.this.Sym]]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.domainSyms">domainSyms</a>: <a href="../../../../Option.scala.html#scala;Option" title="Option[Set[PropositionalLogic.this.Sym]]">Option</a><span class="delimiter">[</span>Set<span class="delimiter">[</span>Sym<span class="delimiter">]</span><span class="delimiter">]</span>

      <span class="comment">// the symbol for this variable being equal to its statically known type</span>
      <span class="comment">// (only available if registerEquality has been called for that type before)</span>
      def <a title="=&gt; Option[PropositionalLogic.this.Sym]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.symForStaticTp">symForStaticTp</a>: <a href="../../../../Option.scala.html#scala;Option" title="Option[PropositionalLogic.this.Sym]">Option</a><span class="delimiter">[</span>Sym<span class="delimiter">]</span>

      <span class="comment">// for this var, call it V, turn V = C into the equivalent proposition in boolean logic</span>
      <span class="comment">// registerEquality(c) must have been called prior to this call</span>
      <span class="comment">// in fact, all equalities relevant to this variable must have been registered</span>
      def <a title="(c: PropositionalLogic.this.Const)PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.propForEqualsTo">propForEqualsTo</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Const" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.propForEqualsTo.c">c</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Const" title="PropositionalLogic.this.Const">Const</a><span class="delimiter">)</span>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a>

      <span class="comment">// populated by registerEquality</span>
      <span class="comment">// once implications has been called, must not call registerEquality anymore</span>
      def <a title="=&gt; List[(PropositionalLogic.this.Sym, List[PropositionalLogic.this.Sym], List[PropositionalLogic.this.Sym])]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.implications">implications</a>: <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[(PropositionalLogic.this.Sym, List[PropositionalLogic.this.Sym], List[PropositionalLogic.this.Sym])]">List</a><span class="delimiter">[</span><span class="delimiter">(</span>Sym, List<span class="delimiter">[</span>Sym<span class="delimiter">]</span>, List<span class="delimiter">[</span>Sym<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>
    <span class="delimiter">}</span>

    <span class="comment">// would be nice to statically check whether a prop is equational or pure,</span>
    <span class="comment">// but that requires typing relations like And(x: Tx, y: Ty) : (if(Tx == PureProp &amp;&amp; Ty == PureProp) PureProp else Prop)</span>
    case class <a title="class And extends PropositionalLogic.this.Prop with Product with Serializable" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.And.readResolve">And</a><a href="../../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;And.a">a</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a>, <a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;And.b">b</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a><span class="delimiter">)</span> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a>
    case class <a title="class Or extends PropositionalLogic.this.Prop with Product with Serializable" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Or.readResolve">Or</a><a href="../../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Or.a">a</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a>, <a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Or.b">b</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a><span class="delimiter">)</span> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a>
    case class <a title="class Not extends PropositionalLogic.this.Prop with Product with Serializable" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Not.readResolve">Not</a><a href="../../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Not.a">a</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a><span class="delimiter">)</span> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a>

    case object <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.True.productElement.x$1" title="PropositionalLogic.this.True.type" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.True.readResolve">True</a> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a>
    case object <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.False.productElement.x$1" title="PropositionalLogic.this.False.type" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.False.readResolve">False</a> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a>

    <span class="comment">// symbols are propositions</span>
    abstract case class <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.productElement.x$1" title="class Sym extends PropositionalLogic.this.Prop with Product with Serializable" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym">Sym</a><a href="../../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="PropositionalLogic.this.Var" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.variable">variable</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Var" title="PropositionalLogic.this.Var">Var</a>, <a title="PropositionalLogic.this.Const" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.const">const</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Const" title="PropositionalLogic.this.Const">Const</a><span class="delimiter">)</span> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a> <span class="delimiter">{</span>
      private val <a title="Int" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.id">id</a>: <a href="../../../../Int.scala.html#scala;Int" title="Int">Int</a> = <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.readResolve" title="PropositionalLogic.this.Sym.type">Sym</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.nextSymId" title="=&gt; Int">nextSymId</a>

      override def <a title="()String" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.toString">toString</a> = <a href="../../../../Predef.scala.html#scala.Predef.any2stringadd(6b32434ac5)" title="(self: PropositionalLogic.this.Var)any2stringadd[PropositionalLogic.this.Var]">variable</a> <a href="../../../../Predef.scala.html#scala.Predef;any2stringadd.+" title="(other: String)String">+</a><span title="String(&quot;=&quot;)" class="string">&quot;=&quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.const" title="=&gt; PropositionalLogic.this.Const">const</a> <span title="(x$1: Any)String">+</span><span title="String(&quot;#&quot;)" class="string">&quot;#&quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.id" title="=&gt; Int">id</a>
    <span class="delimiter">}</span>
    class <a title="class UniqueSym extends PropositionalLogic.this.Sym" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;UniqueSym">UniqueSym</a><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;UniqueSym" title="PropositionalLogic.this.UniqueSym" class="delimiter">(</a><a title="PropositionalLogic.this.Var" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;UniqueSym.variable">variable</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Var" title="PropositionalLogic.this.Var">Var</a>, <a title="PropositionalLogic.this.Const" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;UniqueSym.const">const</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Const" title="PropositionalLogic.this.Const">Const</a><span class="delimiter">)</span> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym" title="PropositionalLogic.this.Sym">Sym</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;UniqueSym.variable" title="PropositionalLogic.this.Var">variable</a>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;UniqueSym.const" title="PropositionalLogic.this.Const">const</a><span class="delimiter">)</span>
    object <a title="PropositionalLogic.this.Sym.type" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.readResolve">Sym</a> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.readResolve" title="PropositionalLogic.this.Sym.type" class="delimiter">{</a>
      private val <a title="scala.reflect.internal.util.HashSet[PropositionalLogic.this.Sym]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.uniques">uniques</a>: <a href="../../../../reflect/internal/util/HashSet.scala.html#scala.reflect.internal.util;HashSet" title="scala.reflect.internal.util.HashSet[PropositionalLogic.this.Sym]">HashSet</a><span class="delimiter">[</span>Sym<span class="delimiter">]</span> = new <a href="../../../../reflect/internal/util/HashSet.scala.html#scala.reflect.internal.util;HashSet" title="scala.reflect.internal.util.HashSet[PropositionalLogic.this.Sym]">HashSet</a><span class="delimiter">(</span><span title="String(&quot;uniques&quot;)" class="string">&quot;uniques&quot;</span>, <span title="Int(512)" class="int">512</span><span class="delimiter">)</span>
      def <a title="(variable: PropositionalLogic.this.Var, const: PropositionalLogic.this.Const)PropositionalLogic.this.Sym" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.apply">apply</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Var" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.apply.variable">variable</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Var" title="PropositionalLogic.this.Var">Var</a>, <a title="PropositionalLogic.this.Const" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.apply.const">const</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Const" title="PropositionalLogic.this.Const">Const</a><span class="delimiter">)</span>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym" title="PropositionalLogic.this.Sym">Sym</a> = <span class="delimiter">{</span>
        val <a title="PropositionalLogic.this.UniqueSym" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.apply.newSym">newSym</a> = new <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;UniqueSym" title="PropositionalLogic.this.UniqueSym">UniqueSym</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.apply.variable" title="PropositionalLogic.this.Var">variable</a>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.apply.const" title="PropositionalLogic.this.Const">const</a><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.uniques" title="=&gt; scala.reflect.internal.util.HashSet[PropositionalLogic.this.Sym]">uniques</a> <a href="../../../../reflect/internal/util/HashSet.scala.html#scala.reflect.internal.util;HashSet.findEntryOrUpdate" title="(x: PropositionalLogic.this.Sym)PropositionalLogic.this.Sym">findEntryOrUpdate</a> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.apply.newSym" title="PropositionalLogic.this.UniqueSym">newSym</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      private def <a title="=&gt; Int" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.nextSymId">nextSymId</a> = <span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym._symId_=" title="(x$1: Int)Unit">_symId</a> <a href="../../../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym._symId_=" title="=&gt; Int">_symId</a><span class="delimiter">}</span>; private var <a title="Int" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym._symId_=">_symId</a> = <span title="Int(0)" class="int">0</span>
      implicit val <a title="Ordering[PropositionalLogic.this.Sym]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.SymOrdering">SymOrdering</a>: <a href="../../../../math/Ordering.scala.html#scala.math;Ordering" title="Ordering[PropositionalLogic.this.Sym]">Ordering</a><span class="delimiter">[</span>Sym<span class="delimiter">]</span> = <a href="../../../../package.scala.html#scala.package.Ordering" title="=&gt; math.Ordering.type">Ordering</a>.<a href="../../../../math/Ordering.scala.html#scala.math.Ordering.by" title="(f: PropositionalLogic.this.Sym =&gt; Int)(implicit ord: scala.math.Ordering[Int])scala.math.Ordering[PropositionalLogic.this.Sym]">by</a><a href="../../../../math/Ordering.scala.html#scala.math.Ordering.Int" title="scala.math.Ordering.Int.type" class="delimiter">(</a><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.SymOrdering.$anonfun.x$3" title="PropositionalLogic.this.Sym">_</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.id" title="=&gt; Int">id</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    def <a title="(props: Iterable[PropositionalLogic.this.Prop])PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic./\">/\</a><span class="delimiter">(</span><a title="Iterable[PropositionalLogic.this.Prop]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic./\.props">props</a>: <a href="../../../../collection/Iterable.scala.html#scala.collection;Iterable" title="Iterable[PropositionalLogic.this.Prop]">Iterable</a><span class="delimiter">[</span>Prop<span class="delimiter">]</span><span class="delimiter">)</span> = if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic./\.props" title="Iterable[PropositionalLogic.this.Prop]">props</a>.<a href="../../../../collection/IterableLike.scala.html#scala.collection;IterableLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.True.readResolve" title="PropositionalLogic.this.True.type">True</a> else <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic./\.props" title="Iterable[PropositionalLogic.this.Prop]">props</a>.<a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.reduceLeft" title="(op: (PropositionalLogic.this.Prop, PropositionalLogic.this.Prop) =&gt; PropositionalLogic.this.Prop)PropositionalLogic.this.Prop">reduceLeft</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.And.readResolve" title="(a: PropositionalLogic.this.Prop, b: PropositionalLogic.this.Prop)PropositionalLogic.this.And">And</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic./\.$anonfun.x$4" title="PropositionalLogic.this.Prop">_</a>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic./\.$anonfun.x$5" title="PropositionalLogic.this.Prop">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    def <a title="(props: Iterable[PropositionalLogic.this.Prop])PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.\/">\/</a><span class="delimiter">(</span><a title="Iterable[PropositionalLogic.this.Prop]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.\/.props">props</a>: <a href="../../../../collection/Iterable.scala.html#scala.collection;Iterable" title="Iterable[PropositionalLogic.this.Prop]">Iterable</a><span class="delimiter">[</span>Prop<span class="delimiter">]</span><span class="delimiter">)</span> = if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.\/.props" title="Iterable[PropositionalLogic.this.Prop]">props</a>.<a href="../../../../collection/IterableLike.scala.html#scala.collection;IterableLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.False.readResolve" title="PropositionalLogic.this.False.type">False</a> else <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.\/.props" title="Iterable[PropositionalLogic.this.Prop]">props</a>.<a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.reduceLeft" title="(op: (PropositionalLogic.this.Prop, PropositionalLogic.this.Prop) =&gt; PropositionalLogic.this.Prop)PropositionalLogic.this.Prop">reduceLeft</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Or.readResolve" title="(a: PropositionalLogic.this.Prop, b: PropositionalLogic.this.Prop)PropositionalLogic.this.Or">Or</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.\/.$anonfun.x$6" title="PropositionalLogic.this.Prop">_</a>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.\/.$anonfun.x$7" title="PropositionalLogic.this.Prop">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

    trait <a title="trait PropTraverser extends AnyRef" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser">PropTraverser</a> <a href="../../../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a>
      def <a title="(x: PropositionalLogic.this.Prop)Unit" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.apply">apply</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.apply.x">x</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a><span class="delimiter">)</span>: <a href="../../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.apply.x" title="PropositionalLogic.this.Prop">x</a> match <span class="delimiter">{</span>
        case And<span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">a</span>, <span title="PropositionalLogic.this.Prop">b</span><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.apply" title="(x: PropositionalLogic.this.Prop)Unit">apply</a><span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">a</span><span class="delimiter">)</span>; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.apply" title="(x: PropositionalLogic.this.Prop)Unit">apply</a><span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">b</span><span class="delimiter">)</span>
        case Or<span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">a</span>, <span title="PropositionalLogic.this.Prop">b</span><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.apply" title="(x: PropositionalLogic.this.Prop)Unit">apply</a><span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">a</span><span class="delimiter">)</span>; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.apply" title="(x: PropositionalLogic.this.Prop)Unit">apply</a><span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">b</span><span class="delimiter">)</span>
        case Not<span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">a</span><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.apply" title="(x: PropositionalLogic.this.Prop)Unit">apply</a><span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">a</span><span class="delimiter">)</span>
        case Eq<span class="delimiter">(</span><span title="PropositionalLogic.this.Var">a</span>, <span title="PropositionalLogic.this.Const">b</span><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.applyVar" title="(x: PropositionalLogic.this.Var)Unit">applyVar</a><span class="delimiter">(</span><span title="PropositionalLogic.this.Var">a</span><span class="delimiter">)</span>; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.applyConst" title="(x: PropositionalLogic.this.Const)Unit">applyConst</a><span class="delimiter">(</span><span title="PropositionalLogic.this.Const">b</span><span class="delimiter">)</span>
        case _ =&gt;
      <span class="delimiter">}</span>
      def <a title="(x: PropositionalLogic.this.Var)Unit" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.applyVar">applyVar</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Var" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.applyVar.x">x</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Var" title="PropositionalLogic.this.Var">Var</a><span class="delimiter">)</span>: <a href="../../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>
      def <a title="(x: PropositionalLogic.this.Const)Unit" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.applyConst">applyConst</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Const" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.applyConst.x">x</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Const" title="PropositionalLogic.this.Const">Const</a><span class="delimiter">)</span>: <a href="../../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span>
    <span class="delimiter">}</span>

    def <a title="(p: PropositionalLogic.this.Prop)Set[PropositionalLogic.this.Var]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.gatherVariables">gatherVariables</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.gatherVariables.p">p</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a><span class="delimiter">)</span>: <a href="../../../../collection/immutable/Set.scala.html#scala.collection.immutable;Set" title="Set[PropositionalLogic.this.Var]">Set</a><span class="delimiter">[</span>Var<span class="delimiter">]</span> = <span class="delimiter">{</span>
      val <a title="scala.collection.mutable.HashSet[PropositionalLogic.this.Var]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.gatherVariables.vars">vars</a> = new mutable.<a href="../../../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet" title="scala.collection.mutable.HashSet[PropositionalLogic.this.Var]">HashSet</a><span class="delimiter">[</span>Var<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">(</span>new <a title="&lt;$anon: PropositionalLogic.this.PropTraverser&gt; extends AnyRef with PropositionalLogic.this.PropTraverser" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.gatherVariables;$anon">PropTraverser</a> <span class="delimiter">{</span>
        override def <a title="(v: PropositionalLogic.this.Var)Unit" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.gatherVariables;$anon.applyVar">applyVar</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Var" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.gatherVariables;$anon.applyVar.v">v</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Var" title="PropositionalLogic.this.Var">Var</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.gatherVariables.vars" title="scala.collection.mutable.HashSet[PropositionalLogic.this.Var]">vars</a> <a href="../../../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet.+=(53f2a8289f)" title="(elem: PropositionalLogic.this.Var)vars.type">+=</a> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.gatherVariables;$anon.applyVar.v" title="PropositionalLogic.this.Var">v</a>
      <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.gatherVariables.p" title="PropositionalLogic.this.Prop">p</a><span class="delimiter">)</span>
      <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.gatherVariables.vars" title="scala.collection.mutable.HashSet[PropositionalLogic.this.Var]">vars</a>.<a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toSet" title="scala.collection.immutable.Set[PropositionalLogic.this.Var]">toSet</a>
    <span class="delimiter">}</span>

    trait <a title="trait PropMap extends AnyRef" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropMap">PropMap</a> <a href="../../../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a>
      def <a title="(x: PropositionalLogic.this.Prop)PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropMap.apply">apply</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropMap.apply.x">x</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a><span class="delimiter">)</span>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a> = <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropMap.apply.x" title="PropositionalLogic.this.Prop">x</a> match <span class="delimiter">{</span> <span class="comment">// TODO: mapConserve</span>
        case And<span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">a</span>, <span title="PropositionalLogic.this.Prop">b</span><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.And.readResolve" title="(a: PropositionalLogic.this.Prop, b: PropositionalLogic.this.Prop)PropositionalLogic.this.And">And</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropMap.apply" title="(x: PropositionalLogic.this.Prop)PropositionalLogic.this.Prop">apply</a><span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">a</span><span class="delimiter">)</span>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropMap.apply" title="(x: PropositionalLogic.this.Prop)PropositionalLogic.this.Prop">apply</a><span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">b</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case Or<span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">a</span>, <span title="PropositionalLogic.this.Prop">b</span><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Or.readResolve" title="(a: PropositionalLogic.this.Prop, b: PropositionalLogic.this.Prop)PropositionalLogic.this.Or">Or</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropMap.apply" title="(x: PropositionalLogic.this.Prop)PropositionalLogic.this.Prop">apply</a><span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">a</span><span class="delimiter">)</span>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropMap.apply" title="(x: PropositionalLogic.this.Prop)PropositionalLogic.this.Prop">apply</a><span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">b</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case Not<span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">a</span><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Not.readResolve" title="(a: PropositionalLogic.this.Prop)PropositionalLogic.this.Not">Not</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropMap.apply" title="(x: PropositionalLogic.this.Prop)PropositionalLogic.this.Prop">apply</a><span class="delimiter">(</span><span title="PropositionalLogic.this.Prop">a</span><span class="delimiter">)</span><span class="delimiter">)</span>
        case <a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropMap.apply.p">p</a> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropMap.apply.p" title="PropositionalLogic.this.Prop">p</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">// to govern how much time we spend analyzing matches for unreachability/exhaustivity</span>
    object <a title="PropositionalLogic.this.AnalysisBudget.type" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget">AnalysisBudget</a> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget" title="PropositionalLogic.this.AnalysisBudget.type" class="delimiter">{</a>
      private val <a title="scala.sys.Prop[String]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget.budgetProp">budgetProp</a> = scala.sys.<a href="../../../../sys/Prop.scala.html#scala.sys.Prop.apply" title="[T](key: String)(implicit evidence$1: sys.Prop.Creator[T])scala.sys.Prop[T]">Prop</a><span title="(key: String)(implicit evidence$1: sys.Prop.Creator[String])scala.sys.Prop[String]" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span><a href="../../../../sys/Prop.scala.html#scala.sys.Prop.StringProp" title="scala.sys.Prop.StringProp.type" class="delimiter">(</a><span title="String(&quot;scalac.patmat.analysisBudget&quot;)" class="string">&quot;scalac.patmat.analysisBudget&quot;</span><span class="delimiter">)</span>
      private val <a title="String" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget.budgetOff">budgetOff</a> = <span title="String(&quot;off&quot;)" class="string">&quot;off&quot;</span>
      val <a title="Int" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget.max">max</a>: <a href="../../../../Int.scala.html#scala;Int" title="Int">Int</a> = <span class="delimiter">{</span>
        val <a title="Int" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget.max.DefaultBudget">DefaultBudget</a> = <span title="Int(256)" class="int">256</span>
        <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget.budgetProp" title="=&gt; scala.sys.Prop[String]">budgetProp</a>.<a href="../../../../sys/Prop.scala.html#scala.sys;Prop.option" title="=&gt; Option[String]">option</a> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget.budgetOff" title="=&gt; String">`budgetOff`</a><span class="delimiter">)</span> =&gt;
            Integer.<span title="Int(2147483647)">MAX_VALUE</span>
          case Some<span class="delimiter">(</span><a title="String" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget.max.x">x</a><span class="delimiter">)</span> =&gt;
            <a href="../../../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">x</a>.<a href="../../../../collection/immutable/StringLike.scala.html#scala.collection.immutable;StringLike.toInt" title="=&gt; Int">toInt</a>
          case <a href="../../../../Option.scala.html#scala.None" title="None.type">None</a> =&gt;
            <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget.max.DefaultBudget" title="Int">DefaultBudget</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      abstract class <a title="class Exception extends RuntimeException" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget;Exception">Exception</a><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget;Exception" title="scala.tools.nsc.transform.patmat.Logic.PropositionalLogic.AnalysisBudget.Exception" class="delimiter">(</a>val <a title="String" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget;Exception.advice">advice</a>: <span title="String">String</span><span class="delimiter">)</span> extends <a href="../../../../package.scala.html#scala.package;RuntimeException" title="RuntimeException">RuntimeException</a><span class="delimiter">(</span><span title="String(&quot;CNF budget exceeded&quot;)" class="string">&quot;CNF budget exceeded&quot;</span><span class="delimiter">)</span>

      object <a title="scala.tools.nsc.transform.patmat.Logic.PropositionalLogic.AnalysisBudget.exceeded.type" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget.exceeded.readResolve">exceeded</a> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget;Exception" title="scala.tools.nsc.transform.patmat.Logic.PropositionalLogic.AnalysisBudget.Exception">Exception</a><span class="delimiter">(</span>
          <a href="../../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;(The analysis required more space than allowed. Please try with scalac -D&quot;)">(The analysis required more space than allowed. Please try with scalac -D$</span><span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget.budgetProp" title="=&gt; scala.sys.Prop[String]">budgetProp</a>.<a href="../../../../sys/Prop.scala.html#scala.sys;Prop.key" title="=&gt; String">key</a><span class="delimiter">}</span><span title="String(&quot;=&quot;)">=$</span><span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget" title="PropositionalLogic.this.AnalysisBudget.type">AnalysisBudget</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget.max" title="=&gt; Int">max</a><a href="../../../../Int.scala.html#scala;Int.*(1409840560)" title="(x: Int)Int">*</a><span title="Int(2)" class="int">2</span><span class="delimiter">}</span><span title="String(&quot; or -D&quot;)"> or -D$</span><span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget.budgetProp" title="=&gt; scala.sys.Prop[String]">budgetProp</a>.<a href="../../../../sys/Prop.scala.html#scala.sys;Prop.key" title="=&gt; String">key</a><span class="delimiter">}</span><span title="String(&quot;=&quot;)">=$</span><span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.AnalysisBudget.budgetOff" title="=&gt; String">budgetOff</a><span class="delimiter">}</span><span title="String(&quot;.)&quot;)" class="string">.)&quot;</span><span class="delimiter">)</span>

    <span class="delimiter">}</span>

    <span class="comment">// convert finite domain propositional logic with subtyping to pure boolean propositional logic</span>
    <span class="comment">// a type test or a value equality test are modelled as a variable being equal to some constant</span>
    <span class="comment">// a variable V may be assigned multiple constants, as long as they do not contradict each other</span>
    <span class="comment">// according to subtyping, e.g., V = ConstantType(1) and V = Int are valid assignments</span>
    <span class="comment">// we rewrite V = C to a fresh boolean symbol, and model what we know about the variable's domain</span>
    <span class="comment">// in a prelude (the equality axioms)</span>
    <span class="comment">//   1. a variable with a closed domain (of a sealed type) must be assigned one of the instantiatable types in its domain</span>
    <span class="comment">//   2. for each variable V in props, and each constant C it is compared to,</span>
    <span class="comment">//      compute which assignments imply each other (as in the example above: V = 1 implies V = Int)</span>
    <span class="comment">//      and which assignments are mutually exclusive (V = String implies -(V = Int))</span>
    <span class="comment">//</span>
    <span class="comment">// note that this is a conservative approximation: V = Constant(A) and V = Constant(B)</span>
    <span class="comment">// are considered mutually exclusive (and thus both cases are considered reachable in {case A =&gt; case B =&gt;}),</span>
    <span class="comment">// even though A may be equal to B   (and thus the second case is not &quot;dynamically reachable&quot;)</span>
    <span class="comment">//</span>
    <span class="comment">// TODO: for V1 representing x1 and V2 standing for x1.head, encode that</span>
    <span class="comment">//       V1 = Nil implies -(V2 = Ci) for all Ci in V2's domain (i.e., it is unassignable)</span>
    <span class="comment">// may throw an AnalysisBudget.Exception</span>
    def <a title="(props: List[PropositionalLogic.this.Prop], modelNull: Boolean)(PropositionalLogic.this.Formula, List[PropositionalLogic.this.Formula])" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq">removeVarEq</a><span class="delimiter">(</span><a title="List[PropositionalLogic.this.Prop]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.props">props</a>: <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[PropositionalLogic.this.Prop]">List</a><span class="delimiter">[</span>Prop<span class="delimiter">]</span>, <a title="Boolean" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq$default$2">modelNull</a>: <a href="../../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = false<span class="delimiter">)</span>: <a href="../../../../Tuple2.scala.html#scala;Tuple2" title="(PropositionalLogic.this.Formula, List[PropositionalLogic.this.Formula])" class="delimiter">(</a>Formula, List<span class="delimiter">[</span>Formula<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      val <a title="scala.reflect.internal.util.Statistics.TimerSnapshot" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.start">start</a> = if <span class="delimiter">(</span><a href="../../../../reflect/internal/util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../../reflect/internal/util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../../reflect/internal/util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../../reflect/internal/util/Statistics.scala.html#scala.reflect.internal.util.Statistics.startTimer" title="(tm: scala.reflect.internal.util.Statistics.Timer)scala.reflect.internal.util.Statistics.TimerSnapshot">startTimer</a><span class="delimiter">(</span><a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat.PatternMatchingStats.patmatAnaVarEq" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatAnaVarEq</a><span class="delimiter">)</span> else null

      val <a title="scala.collection.mutable.HashSet[PropositionalLogic.this.Var]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.vars">vars</a> = new mutable.<a href="../../../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet" title="scala.collection.mutable.HashSet[PropositionalLogic.this.Var]">HashSet</a><span class="delimiter">[</span>Var<span class="delimiter">]</span>

      object <a title="gatherEqualities.type" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.gatherEqualities">gatherEqualities</a> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser" title="PropositionalLogic.this.PropTraverser">PropTraverser</a> <span class="delimiter">{</span>
        override def <a title="(p: PropositionalLogic.this.Prop)Unit" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;gatherEqualities.apply">apply</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;gatherEqualities.apply.p">p</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;gatherEqualities.apply.p" title="PropositionalLogic.this.Prop">p</a> match <span class="delimiter">{</span>
          case Eq<span class="delimiter">(</span><a title="PropositionalLogic.this.Var" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;gatherEqualities.apply.v">v</a>, <a title="PropositionalLogic.this.Const" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;gatherEqualities.apply.c">c</a><span class="delimiter">)</span> =&gt;
            <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.vars" title="scala.collection.mutable.HashSet[PropositionalLogic.this.Var]">vars</a> <a href="../../../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet.+=(53f2a8289f)" title="(elem: PropositionalLogic.this.Var)vars.type">+=</a> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;gatherEqualities.apply.v" title="PropositionalLogic.this.Var">v</a>
            <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;gatherEqualities.apply.v" title="PropositionalLogic.this.Var">v</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.registerEquality" title="(c: PropositionalLogic.this.Const)Unit">registerEquality</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;gatherEqualities.apply.c" title="PropositionalLogic.this.Const">c</a><span class="delimiter">)</span>
          case _ =&gt; super.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropTraverser.apply" title="(x: PropositionalLogic.this.Prop)Unit">apply</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;gatherEqualities.apply.p" title="PropositionalLogic.this.Prop">p</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      object <a title="rewriteEqualsToProp.type" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.rewriteEqualsToProp">rewriteEqualsToProp</a> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropMap" title="PropositionalLogic.this.PropMap">PropMap</a> <span class="delimiter">{</span>
        override def <a title="(p: PropositionalLogic.this.Prop)PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;rewriteEqualsToProp.apply">apply</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;rewriteEqualsToProp.apply.p">p</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;rewriteEqualsToProp.apply.p" title="PropositionalLogic.this.Prop">p</a> match <span class="delimiter">{</span>
          case Eq<span class="delimiter">(</span><a title="PropositionalLogic.this.Var" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;rewriteEqualsToProp.apply.v">v</a>, <a title="PropositionalLogic.this.Const" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;rewriteEqualsToProp.apply.c">c</a><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;rewriteEqualsToProp.apply.v" title="PropositionalLogic.this.Var">v</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.propForEqualsTo" title="(c: PropositionalLogic.this.Const)PropositionalLogic.this.Prop">propForEqualsTo</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;rewriteEqualsToProp.apply.c" title="PropositionalLogic.this.Const">c</a><span class="delimiter">)</span>
          case _ =&gt; super.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;PropMap.apply" title="(x: PropositionalLogic.this.Prop)PropositionalLogic.this.Prop">apply</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;rewriteEqualsToProp.apply.p" title="PropositionalLogic.this.Prop">p</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.props" title="List[PropositionalLogic.this.Prop]">props</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: PropositionalLogic.this.Prop =&gt; Unit)Unit">foreach</a> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.gatherEqualities" title="gatherEqualities.type">gatherEqualities</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;gatherEqualities.apply" title="(p: PropositionalLogic.this.Prop)Unit">apply</a>
      if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq$default$2" title="Boolean">modelNull</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.vars" title="scala.collection.mutable.HashSet[PropositionalLogic.this.Var]">vars</a> <a href="../../../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet.foreach" title="(f: PropositionalLogic.this.Var =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.x$8" title="PropositionalLogic.this.Var">_</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.registerNull" title="()Unit">registerNull</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

      val pure = <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.props" title="List[PropositionalLogic.this.Prop]">props</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="List[PropositionalLogic.this.Formula]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.pure">map</a> <span class="delimiter">(</span><a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.pure.$anonfun.p">p</a> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.eqFreePropToSolvable" title="(p: PropositionalLogic.this.Prop)PropositionalLogic.this.Formula">eqFreePropToSolvable</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq;rewriteEqualsToProp.apply" title="(p: PropositionalLogic.this.Prop)PropositionalLogic.this.Prop">rewriteEqualsToProp</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.pure.$anonfun.p" title="PropositionalLogic.this.Prop">p</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

      val <a title="PropositionalLogic.this.FormulaBuilder" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.eqAxioms">eqAxioms</a> = <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.formulaBuilder" title="=&gt; PropositionalLogic.this.FormulaBuilder">formulaBuilder</a>
      @inline def <a title="(p: PropositionalLogic.this.Prop)Unit" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.addAxiom">addAxiom</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.addAxiom.p">p</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.addFormula" title="(buff: PropositionalLogic.this.FormulaBuilder, f: PropositionalLogic.this.Formula)Unit">addFormula</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.eqAxioms" title="PropositionalLogic.this.FormulaBuilder">eqAxioms</a>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.eqFreePropToSolvable" title="(p: PropositionalLogic.this.Prop)PropositionalLogic.this.Formula">eqFreePropToSolvable</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.addAxiom.p" title="PropositionalLogic.this.Prop">p</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug" title="Logic.this.debug.type">debug</a>.<a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug.patmat" title="(s: =&gt; String)Unit">patmat</a><span class="delimiter">(</span><span title="String(&quot;removeVarEq vars: &quot;)" class="string">&quot;removeVarEq vars: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.vars" title="scala.collection.mutable.HashSet[PropositionalLogic.this.Var]">vars</a><span class="delimiter">)</span>
      <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.vars" title="scala.collection.mutable.HashSet[PropositionalLogic.this.Var]">vars</a>.<a href="../../../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet.foreach" title="(f: PropositionalLogic.this.Var =&gt; Unit)Unit">foreach</a> <span class="delimiter">{</span> <a title="PropositionalLogic.this.Var" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.v">v</a> =&gt;
        <span class="comment">// if v.domainSyms.isEmpty, we must consider the domain to be infinite</span>
        <span class="comment">// otherwise, since the domain fully partitions the type of the value,</span>
        <span class="comment">// exactly one of the types (and whatever it implies, imposed separately) must be chosen</span>
        <span class="comment">// consider X ::= A | B | C, and A =&gt; B</span>
        <span class="comment">// coverage is formulated as: A \/ B \/ C and the implications are</span>
        <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.v" title="PropositionalLogic.this.Var">v</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.domainSyms" title="=&gt; Option[Set[PropositionalLogic.this.Sym]]">domainSyms</a> <a href="../../../../Option.scala.html#scala;Option.foreach" title="(f: Set[PropositionalLogic.this.Sym] =&gt; Unit)Unit">foreach</a> <span class="delimiter">{</span> <a title="Set[PropositionalLogic.this.Sym]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.dsyms">dsyms</a> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.addAxiom" title="(p: PropositionalLogic.this.Prop)Unit">addAxiom</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.\/" title="(props: Iterable[PropositionalLogic.this.Prop])PropositionalLogic.this.Prop">\/</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.dsyms" title="Set[PropositionalLogic.this.Sym]">dsyms</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>

        <span class="comment">// when this variable cannot be null the equality corresponding to the type test `(x: T)`, where T is x's static type,</span>
        <span class="comment">// is always true; when the variable may be null we use the implication `(x != null) =&gt; (x: T)` for the axiom</span>
        <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.v" title="PropositionalLogic.this.Var">v</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.symForStaticTp" title="=&gt; Option[PropositionalLogic.this.Sym]">symForStaticTp</a> <a href="../../../../Option.scala.html#scala;Option.foreach" title="(f: PropositionalLogic.this.Sym =&gt; Unit)Unit">foreach</a> <span class="delimiter">{</span> <a title="PropositionalLogic.this.Sym" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.symForStaticTp">symForStaticTp</a> =&gt;
          if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.v" title="PropositionalLogic.this.Var">v</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.mayBeNull" title="=&gt; Boolean">mayBeNull</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.addAxiom" title="(p: PropositionalLogic.this.Prop)Unit">addAxiom</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Or.readResolve" title="(a: PropositionalLogic.this.Prop, b: PropositionalLogic.this.Prop)PropositionalLogic.this.Or">Or</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.v" title="PropositionalLogic.this.Var">v</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.propForEqualsTo" title="(c: PropositionalLogic.this.Const)PropositionalLogic.this.Prop">propForEqualsTo</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.NullConst" title="=&gt; PropositionalLogic.this.Const">NullConst</a><span class="delimiter">)</span>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.symForStaticTp" title="PropositionalLogic.this.Sym">symForStaticTp</a><span class="delimiter">)</span><span class="delimiter">)</span>
          else <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.addAxiom" title="(p: PropositionalLogic.this.Prop)Unit">addAxiom</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.symForStaticTp" title="PropositionalLogic.this.Sym">symForStaticTp</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.v" title="PropositionalLogic.this.Var">v</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar.implications" title="=&gt; List[(PropositionalLogic.this.Sym, List[PropositionalLogic.this.Sym], List[PropositionalLogic.this.Sym])]">implications</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: ((PropositionalLogic.this.Sym, List[PropositionalLogic.this.Sym], List[PropositionalLogic.this.Sym])) =&gt; Unit)Unit">foreach</a> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.x0$1" title="Unit" class="delimiter">{</a> case <span class="delimiter">(</span><a title="PropositionalLogic.this.Sym" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.sym">sym</a>, <a title="List[PropositionalLogic.this.Sym]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.implied">implied</a>, <a title="List[PropositionalLogic.this.Sym]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.excluded">excluded</a><span class="delimiter">)</span> =&gt;
          <span class="comment">// when sym is true, what must hold...</span>
          <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.implied" title="List[PropositionalLogic.this.Sym]">implied</a>  <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: PropositionalLogic.this.Sym =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a title="PropositionalLogic.this.Sym" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.$anonfun.impliedSym">impliedSym</a>  =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.addAxiom" title="(p: PropositionalLogic.this.Prop)Unit">addAxiom</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Or.readResolve" title="(a: PropositionalLogic.this.Prop, b: PropositionalLogic.this.Prop)PropositionalLogic.this.Or">Or</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Not.readResolve" title="(a: PropositionalLogic.this.Prop)PropositionalLogic.this.Not">Not</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.sym" title="PropositionalLogic.this.Sym">sym</a><span class="delimiter">)</span>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.$anonfun.impliedSym" title="PropositionalLogic.this.Sym">impliedSym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="comment">// ... and what must not?</span>
          <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.excluded" title="List[PropositionalLogic.this.Sym]">excluded</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: PropositionalLogic.this.Sym =&gt; Unit)Unit">foreach</a> <span class="delimiter">(</span><a title="PropositionalLogic.this.Sym" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.$anonfun.excludedSym">excludedSym</a> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.addAxiom" title="(p: PropositionalLogic.this.Prop)Unit">addAxiom</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Or.readResolve" title="(a: PropositionalLogic.this.Prop, b: PropositionalLogic.this.Prop)PropositionalLogic.this.Or">Or</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Not.readResolve" title="(a: PropositionalLogic.this.Prop)PropositionalLogic.this.Not">Not</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.sym" title="PropositionalLogic.this.Sym">sym</a><span class="delimiter">)</span>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Not.readResolve" title="(a: PropositionalLogic.this.Prop)PropositionalLogic.this.Not">Not</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.$anonfun.$anonfun.excludedSym" title="PropositionalLogic.this.Sym">excludedSym</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug" title="Logic.this.debug.type">debug</a>.<a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug.patmat" title="(s: =&gt; String)Unit">patmat</a><span class="delimiter">(</span><span title="String(&quot;eqAxioms:\n&quot;)" class="string">&quot;eqAxioms:\n&quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.cnfString" title="(f: PropositionalLogic.this.Formula)String">cnfString</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.toFormula" title="(buff: PropositionalLogic.this.FormulaBuilder)PropositionalLogic.this.Formula">toFormula</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.eqAxioms" title="PropositionalLogic.this.FormulaBuilder">eqAxioms</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug" title="Logic.this.debug.type">debug</a>.<a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug.patmat" title="(s: =&gt; String)Unit">patmat</a><span class="delimiter">(</span><span title="String(&quot;pure:&quot;)" class="string">&quot;pure:&quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.pure" title="List[PropositionalLogic.this.Formula]">pure</a>.<a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: PropositionalLogic.this.Formula =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[PropositionalLogic.this.Formula],String,List[String]])List[String]">map</a><a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.List.canBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</a><a title="PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.p">p</a> =&gt; <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.cnfString" title="(f: PropositionalLogic.this.Formula)String">cnfString</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.$anonfun.p" title="PropositionalLogic.this.Formula">p</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

      if <span class="delimiter">(</span><a href="../../../../reflect/internal/util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../../reflect/internal/util/Statistics.scala.html#scala.reflect.internal.util.Statistics.canEnable" title="=&gt; Boolean">canEnable</a><span class="delimiter">)</span> <a href="../../../../reflect/internal/util/Statistics.scala.html#scala.reflect.internal.util.Statistics" title="scala.reflect.internal.util.Statistics.type">Statistics</a>.<a href="../../../../reflect/internal/util/Statistics.scala.html#scala.reflect.internal.util.Statistics.stopTimer" title="(tm: scala.reflect.internal.util.Statistics.Timer, start: scala.reflect.internal.util.Statistics.TimerSnapshot)Unit">stopTimer</a><span class="delimiter">(</span><a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat.PatternMatchingStats.patmatAnaVarEq" title="=&gt; scala.reflect.internal.util.Statistics.Timer">patmatAnaVarEq</a>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.start" title="scala.reflect.internal.util.Statistics.TimerSnapshot">start</a><span class="delimiter">)</span>

      <a href="../../../../Tuple2.scala.html#scala;Tuple2" title="(_1: PropositionalLogic.this.Formula, _2: List[PropositionalLogic.this.Formula])(PropositionalLogic.this.Formula, List[PropositionalLogic.this.Formula])" class="delimiter">(</a><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.toFormula" title="(buff: PropositionalLogic.this.FormulaBuilder)PropositionalLogic.this.Formula">toFormula</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.eqAxioms" title="PropositionalLogic.this.FormulaBuilder">eqAxioms</a><span class="delimiter">)</span>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq.pure" title="List[PropositionalLogic.this.Formula]">pure</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>


    <span class="comment">// an interface that should be suitable for feeding a SAT solver when the time comes</span>
    type <a title="" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Formula">Formula</a>
    type <a title="" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;FormulaBuilder">FormulaBuilder</a>

    <span class="comment">// creates an empty formula builder to which more formulae can be added</span>
    def <a title="=&gt; PropositionalLogic.this.FormulaBuilder" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.formulaBuilder">formulaBuilder</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;FormulaBuilder" title="PropositionalLogic.this.FormulaBuilder">FormulaBuilder</a>

    <span class="comment">// val f = formulaBuilder; addFormula(f, f1); ... addFormula(f, fN)</span>
    <span class="comment">// toFormula(f) == andFormula(f1, andFormula(..., fN))</span>
    def <a title="(buff: PropositionalLogic.this.FormulaBuilder, f: PropositionalLogic.this.Formula)Unit" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.addFormula">addFormula</a><span class="delimiter">(</span><a title="PropositionalLogic.this.FormulaBuilder" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.addFormula.buff">buff</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;FormulaBuilder" title="PropositionalLogic.this.FormulaBuilder">FormulaBuilder</a>, <a title="PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.addFormula.f">f</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Formula" title="PropositionalLogic.this.Formula">Formula</a><span class="delimiter">)</span>: <a href="../../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a>
    def <a title="(buff: PropositionalLogic.this.FormulaBuilder)PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.toFormula">toFormula</a><span class="delimiter">(</span><a title="PropositionalLogic.this.FormulaBuilder" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.toFormula.buff">buff</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;FormulaBuilder" title="PropositionalLogic.this.FormulaBuilder">FormulaBuilder</a><span class="delimiter">)</span>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Formula" title="PropositionalLogic.this.Formula">Formula</a>

    <span class="comment">// the conjunction of formulae `a` and `b`</span>
    def <a title="(a: PropositionalLogic.this.Formula, b: PropositionalLogic.this.Formula)PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.andFormula">andFormula</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.andFormula.a">a</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Formula" title="PropositionalLogic.this.Formula">Formula</a>, <a title="PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.andFormula.b">b</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Formula" title="PropositionalLogic.this.Formula">Formula</a><span class="delimiter">)</span>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Formula" title="PropositionalLogic.this.Formula">Formula</a>

    <span class="comment">// equivalent formula to `a`, but simplified in a lightweight way (drop duplicate clauses)</span>
    def <a title="(a: PropositionalLogic.this.Formula)PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.simplifyFormula">simplifyFormula</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.simplifyFormula.a">a</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Formula" title="PropositionalLogic.this.Formula">Formula</a><span class="delimiter">)</span>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Formula" title="PropositionalLogic.this.Formula">Formula</a>

    <span class="comment">// may throw an AnalysisBudget.Exception</span>
    def <a title="(p: PropositionalLogic.this.Prop)PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.propToSolvable">propToSolvable</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.propToSolvable.p">p</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a><span class="delimiter">)</span>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Formula" title="PropositionalLogic.this.Formula">Formula</a> = <span class="delimiter">{</span>
      val <a href="../../../../Tuple2.scala.html#scala;Tuple2" title="(PropositionalLogic.this.Formula, PropositionalLogic.this.Formula)" class="delimiter">(</a><a href="../../../../Tuple2.scala.html#scala;Tuple2._1" title="PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.propToSolvable.eqAxioms">eqAxioms</a>, <a href="../../../../Tuple2.scala.html#scala;Tuple2._2" title="PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.propToSolvable.pure">pure</a> :: <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.removeVarEq" title="(props: List[PropositionalLogic.this.Prop], modelNull: Boolean)(PropositionalLogic.this.Formula, List[PropositionalLogic.this.Formula])">removeVarEq</a><a href="../../../../Tuple2.scala.html#scala;Tuple2" title="(PropositionalLogic.this.Formula, List[PropositionalLogic.this.Formula]) @unchecked" class="delimiter">(</a><a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.List.apply" title="(xs: PropositionalLogic.this.Prop*)List[PropositionalLogic.this.Prop]">List</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.propToSolvable.p" title="PropositionalLogic.this.Prop">p</a><span class="delimiter">)</span>, modelNull = false<span class="delimiter">)</span>
      <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.andFormula" title="(a: PropositionalLogic.this.Formula, b: PropositionalLogic.this.Formula)PropositionalLogic.this.Formula">andFormula</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.propToSolvable.eqAxioms" title="PropositionalLogic.this.Formula">eqAxioms</a>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.propToSolvable.pure" title="PropositionalLogic.this.Formula">pure</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// may throw an AnalysisBudget.Exception</span>
    def <a title="(p: PropositionalLogic.this.Prop)PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.eqFreePropToSolvable">eqFreePropToSolvable</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Prop" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.eqFreePropToSolvable.p">p</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="PropositionalLogic.this.Prop">Prop</a><span class="delimiter">)</span>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Formula" title="PropositionalLogic.this.Formula">Formula</a>
    def <a title="(f: PropositionalLogic.this.Formula)String" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.cnfString">cnfString</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.cnfString.f">f</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Formula" title="PropositionalLogic.this.Formula">Formula</a><span class="delimiter">)</span>: <span title="String">String</span>

    type <a title="Map[PropositionalLogic.this.Sym,Boolean]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Model">Model</a> = <a href="../../../../collection/immutable/Map.scala.html#scala.collection.immutable;Map" title="Map[PropositionalLogic.this.Sym,Boolean]">Map</a><span class="delimiter">[</span>Sym, Boolean<span class="delimiter">]</span>
    val <a title="=&gt; PropositionalLogic.this.Model" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.EmptyModel">EmptyModel</a>: <a href="../../../../collection/immutable/Map.scala.html#scala.collection.immutable;Map" title="PropositionalLogic.this.Model">Model</a>
    val <a title="=&gt; PropositionalLogic.this.Model" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.NoModel">NoModel</a>: <a href="../../../../collection/immutable/Map.scala.html#scala.collection.immutable;Map" title="PropositionalLogic.this.Model">Model</a>

    def <a title="(f: PropositionalLogic.this.Formula)PropositionalLogic.this.Model" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.findModelFor">findModelFor</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.findModelFor.f">f</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Formula" title="PropositionalLogic.this.Formula">Formula</a><span class="delimiter">)</span>: <a href="../../../../collection/immutable/Map.scala.html#scala.collection.immutable;Map" title="PropositionalLogic.this.Model">Model</a>
    def <a title="(f: PropositionalLogic.this.Formula)List[PropositionalLogic.this.Model]" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.findAllModelsFor">findAllModelsFor</a><span class="delimiter">(</span><a title="PropositionalLogic.this.Formula" id="scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.findAllModelsFor.f">f</a>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Formula" title="PropositionalLogic.this.Formula">Formula</a><span class="delimiter">)</span>: <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[PropositionalLogic.this.Model]">List</a><span class="delimiter">[</span>Model<span class="delimiter">]</span>
  <span class="delimiter">}</span>
<span title="AnyRef" class="delimiter">}</span>

trait <a title="trait ScalaLogic extends AnyRef with scala.tools.nsc.transform.patmat.Interface with scala.tools.nsc.transform.patmat.Logic with scala.tools.nsc.transform.patmat.TreeAndTypeAnalysis" id="scala.tools.nsc.transform.patmat;ScalaLogic">ScalaLogic</a> extends <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Interface" title="scala.tools.nsc.transform.patmat.Interface">Interface</a> with <a href="#scala.tools.nsc.transform.patmat;Logic" title="scala.tools.nsc.transform.patmat.Logic">Logic</a> with <a href="MatchAnalysis.scala.html#scala.tools.nsc.transform.patmat;TreeAndTypeAnalysis" title="scala.tools.nsc.transform.patmat.TreeAndTypeAnalysis">TreeAndTypeAnalysis</a> <span class="delimiter">{</span>
  trait <a title="trait TreesAndTypesDomain extends AnyRef with ScalaLogic.this.PropositionalLogic with ScalaLogic.this.CheckableTreeAndTypeAnalysis" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain">TreesAndTypesDomain</a> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic" title="ScalaLogic.this.PropositionalLogic">PropositionalLogic</a> with <a href="MatchAnalysis.scala.html#scala.tools.nsc.transform.patmat;TreeAndTypeAnalysis;CheckableTreeAndTypeAnalysis" title="ScalaLogic.this.CheckableTreeAndTypeAnalysis">CheckableTreeAndTypeAnalysis</a> <span class="delimiter">{</span>
    type <a title="ScalaLogic.this.global.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Type">Type</a> = global.<a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="ScalaLogic.this.global.Type">Type</a>
    type <a title="ScalaLogic.this.global.Tree" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Tree">Tree</a> = global.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="ScalaLogic.this.global.Tree">Tree</a>
    import <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.global" title="=&gt; scala.tools.nsc.Global">global</a>.<a href="../../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions.definitions" title="ScalaLogic.this.global.definitions.type">definitions</a>.ConstantNull

    <span class="comment">// resets hash consing -- only supposed to be called by TreeMakersToProps</span>
    def <a title="()Unit" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.prepareNewAnalysis">prepareNewAnalysis</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <span class="delimiter">{</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var" title="TreesAndTypesDomain.this.Var.type">Var</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.resetUniques" title="()Unit">resetUniques</a><span class="delimiter">(</span><span class="delimiter">)</span>; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const" title="TreesAndTypesDomain.this.Const.type">Const</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.resetUniques" title="()Unit">resetUniques</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>

    object <a title="TreesAndTypesDomain.this.Var.type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var">Var</a> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;VarExtractor" title="TreesAndTypesDomain.this.VarExtractor">VarExtractor</a> <span class="delimiter">{</span>
      private var <a title="Int" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var._nextId_=">_nextId</a> = <span title="Int(0)" class="int">0</span>
      def <a title="=&gt; Int" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.nextId">nextId</a> = <span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var._nextId_=" title="(x$1: Int)Unit">_nextId</a> <a href="../../../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var._nextId_=" title="=&gt; Int">_nextId</a><span class="delimiter">}</span>

      def <a title="()Unit" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.resetUniques">resetUniques</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var._nextId_=" title="(x$1: Int)Unit">_nextId</a> = <span title="Int(0)" class="int">0</span>; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.uniques" title="=&gt; scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Tree,TreesAndTypesDomain.this.Var]">uniques</a>.<a href="../../../../collection/mutable/HashMap.scala.html#scala.collection.mutable;HashMap.clear" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">}</span>
      private val <a title="scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Tree,TreesAndTypesDomain.this.Var]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.uniques">uniques</a> = new mutable.<a href="../../../../collection/mutable/HashMap.scala.html#scala.collection.mutable;HashMap" title="scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Tree,TreesAndTypesDomain.this.Var]">HashMap</a><span class="delimiter">[</span>Tree, Var<span class="delimiter">]</span>
      def <a title="(x: TreesAndTypesDomain.this.Tree)TreesAndTypesDomain.this.Var" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.apply">apply</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Tree" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.apply.x">x</a>: <a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TreesAndTypesDomain.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var" title="TreesAndTypesDomain.this.Var">Var</a> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.uniques" title="=&gt; scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Tree,TreesAndTypesDomain.this.Var]">uniques</a> <a href="../../../../collection/mutable/MapLike.scala.html#scala.collection.mutable;MapLike.getOrElseUpdate" title="(key: TreesAndTypesDomain.this.Tree, op: =&gt; TreesAndTypesDomain.this.Var)TreesAndTypesDomain.this.Var">getOrElseUpdate</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.apply.x" title="TreesAndTypesDomain.this.Tree">x</a>, new <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var" title="TreesAndTypesDomain.this.Var">Var</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.apply.x" title="TreesAndTypesDomain.this.Tree">x</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.apply.x" title="TreesAndTypesDomain.this.Tree">x</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; ScalaLogic.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
      def <a title="(v: TreesAndTypesDomain.this.Var)Some[TreesAndTypesDomain.this.Tree]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.unapply">unapply</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Var" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.unapply.v">v</a>: <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var" title="TreesAndTypesDomain.this.Var">Var</a><span class="delimiter">)</span> = <a href="../../../../Option.scala.html#scala;Some" title="(x: TreesAndTypesDomain.this.Tree)Some[TreesAndTypesDomain.this.Tree]">Some</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.unapply.v" title="TreesAndTypesDomain.this.Var">v</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.path" title="=&gt; TreesAndTypesDomain.this.Tree">path</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    class <a title="class Var extends AnyRef with TreesAndTypesDomain.this.AbsVar" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var">Var</a><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var" title="TreesAndTypesDomain.this.Var" class="delimiter">(</a>val <a title="TreesAndTypesDomain.this.Tree" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.path">path</a>: <a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TreesAndTypesDomain.this.Tree">Tree</a>, <a title="TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.staticTp">staticTp</a>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;AbsVar" title="TreesAndTypesDomain.this.AbsVar">AbsVar</a> <span class="delimiter">{</span>
      private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="Int" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.id">id</a>: <a href="../../../../Int.scala.html#scala;Int" title="Int">Int</a> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var" title="TreesAndTypesDomain.this.Var.type">Var</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Var.nextId" title="=&gt; Int">nextId</a>

      <span class="comment">// private[this] var canModify: Option[Array[StackTraceElement]] = None</span>
      private<span class="delimiter">[</span>this<span class="delimiter">]</span> def <a title="()Unit" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.ensureCanModify">ensureCanModify</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span> <span class="comment">//if (canModify.nonEmpty) debug.patmat(&quot;BUG!&quot;+ this +&quot; modified after having been observed: &quot;+ canModify.get.mkString(&quot;\n&quot;))</span>

      private<span class="delimiter">[</span>this<span class="delimiter">]</span> def <a title="()Unit" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.observed">observed</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span title="Unit" class="delimiter">{</span><span class="delimiter">}</span> <span class="comment">//canModify = Some(Thread.currentThread.getStackTrace)</span>

      <span class="comment">// don't access until all potential equalities have been registered using registerEquality</span>
      private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Const,TreesAndTypesDomain.this.Sym]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.symForEqualsTo">symForEqualsTo</a> = new mutable.<a href="../../../../collection/mutable/HashMap.scala.html#scala.collection.mutable;HashMap" title="scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Const,TreesAndTypesDomain.this.Sym]">HashMap</a><span class="delimiter">[</span>Const, Sym<span class="delimiter">]</span>

      <span class="comment">// when looking at the domain, we only care about types we can check at run time</span>
      val <a title="TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.staticTpCheckable">staticTpCheckable</a>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a> = <a href="MatchAnalysis.scala.html#scala.tools.nsc.transform.patmat;TreeAndTypeAnalysis;CheckableTreeAndTypeAnalysis.checkableType" title="(tp: ScalaLogic.this.global.Type)ScalaLogic.this.global.Type">checkableType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.staticTp" title="TreesAndTypesDomain.this.Type">staticTp</a><span class="delimiter">)</span>

      private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="Boolean" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var._mayBeNull">_mayBeNull</a> = false
      def <a title="()Unit" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.registerNull">registerNull</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="../../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <span class="delimiter">{</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.ensureCanModify" title="()Unit">ensureCanModify</a><span class="delimiter">(</span><span class="delimiter">)</span>; if <span class="delimiter">(</span><a href="../../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ConstantNull" title="=&gt; ScalaLogic.this.global.UniqueConstantType">ConstantNull</a> <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.<:<" title="(that: ScalaLogic.this.global.Type)Boolean">&lt;:&lt;</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.staticTpCheckable" title="=&gt; TreesAndTypesDomain.this.Type">staticTpCheckable</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var._mayBeNull" title="Boolean">_mayBeNull</a> = true <span class="delimiter">}</span>
      def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.mayBeNull">mayBeNull</a>: <a href="../../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var._mayBeNull" title="Boolean">_mayBeNull</a>

      <span class="comment">// case None =&gt; domain is unknown,</span>
      <span class="comment">// case Some(List(tps: _*)) =&gt; domain is exactly tps</span>
      <span class="comment">// we enumerate the subtypes of the full type, as that allows us to filter out more types statically,</span>
      <span class="comment">// once we go to run-time checks (on Const's), convert them to checkable types</span>
      <span class="comment">// TODO: there seems to be bug for singleton domains (variable does not show up in model)</span>
      lazy val <a title="Option[Set[TreesAndTypesDomain.this.Const]]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain">domain</a>: <a href="../../../../Option.scala.html#scala;Option" title="Option[Set[TreesAndTypesDomain.this.Const]]">Option</a><span class="delimiter">[</span>Set<span class="delimiter">[</span>Const<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
        val <a title="Option[scala.collection.immutable.Set[TreesAndTypesDomain.this.Const]]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain.subConsts">subConsts</a> = <a href="MatchAnalysis.scala.html#scala.tools.nsc.transform.patmat;TreeAndTypeAnalysis;CheckableTreeAndTypeAnalysis.enumerateSubtypes" title="(tp: ScalaLogic.this.global.Type)Option[List[ScalaLogic.this.global.Type]]">enumerateSubtypes</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.staticTp" title="TreesAndTypesDomain.this.Type">staticTp</a><span class="delimiter">)</span>.<a href="../../../../Option.scala.html#scala;Option.map" title="(f: List[ScalaLogic.this.global.Type] =&gt; scala.collection.immutable.Set[TreesAndTypesDomain.this.Const])Option[scala.collection.immutable.Set[TreesAndTypesDomain.this.Const]]">map</a><span class="delimiter">{</span> <a title="List[ScalaLogic.this.global.Type]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain.subConsts.$anonfun.tps">tps</a> =&gt;
          <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain.subConsts.$anonfun.tps" title="List[ScalaLogic.this.global.Type]">tps</a>.<a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toSet" title="[B &gt;: ScalaLogic.this.global.Type]=&gt; scala.collection.immutable.Set[B]">toSet</a><span title="scala.collection.immutable.Set[TreesAndTypesDomain.this.Type]" class="delimiter">[</span><a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a><span class="delimiter">]</span>.<a href="../../../../collection/SetLike.scala.html#scala.collection;SetLike.map" title="(f: TreesAndTypesDomain.this.Type =&gt; TreesAndTypesDomain.this.Const)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[TreesAndTypesDomain.this.Type],TreesAndTypesDomain.this.Const,scala.collection.immutable.Set[TreesAndTypesDomain.this.Const]])scala.collection.immutable.Set[TreesAndTypesDomain.this.Const]">map</a><a href="../../../../collection/immutable/Set.scala.html#scala.collection.immutable.Set.canBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,TreesAndTypesDomain.this.Const,scala.collection.immutable.Set[TreesAndTypesDomain.this.Const]]" class="delimiter">{</a> <a title="TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain.subConsts.$anonfun.$anonfun.tp">tp</a> =&gt;
            val <a title="TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain.subConsts.$anonfun.$anonfun.domainC">domainC</a> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.TypeConst.apply" title="(tp: TreesAndTypesDomain.this.Type)TreesAndTypesDomain.this.Const">TypeConst</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain.subConsts.$anonfun.$anonfun.tp" title="TreesAndTypesDomain.this.Type">tp</a><span class="delimiter">)</span>
            <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.registerEquality" title="(c: TreesAndTypesDomain.this.Const)Unit">registerEquality</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain.subConsts.$anonfun.$anonfun.domainC" title="TreesAndTypesDomain.this.Const">domainC</a><span class="delimiter">)</span>
            <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain.subConsts.$anonfun.$anonfun.domainC" title="TreesAndTypesDomain.this.Const">domainC</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        val <a title="Option[scala.collection.immutable.Set[TreesAndTypesDomain.this.Const]]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain.allConsts">allConsts</a> =
          if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.mayBeNull" title="=&gt; Boolean">mayBeNull</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.registerEquality" title="(c: TreesAndTypesDomain.this.Const)Unit">registerEquality</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.NullConst.readResolve" title="TreesAndTypesDomain.this.NullConst.type">NullConst</a><span class="delimiter">)</span>
            <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain.subConsts" title="Option[scala.collection.immutable.Set[TreesAndTypesDomain.this.Const]]">subConsts</a> <a href="../../../../Option.scala.html#scala;Option.map" title="(f: scala.collection.immutable.Set[TreesAndTypesDomain.this.Const] =&gt; scala.collection.immutable.Set[TreesAndTypesDomain.this.Const])Option[scala.collection.immutable.Set[TreesAndTypesDomain.this.Const]]">map</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain.allConsts.$anonfun.x$10" title="scala.collection.immutable.Set[TreesAndTypesDomain.this.Const]">_</a> <a href="../../../../collection/SetLike.scala.html#scala.collection;SetLike.+(daf7108c0f)" title="(elem: TreesAndTypesDomain.this.Const)scala.collection.immutable.Set[TreesAndTypesDomain.this.Const]">+</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.NullConst.readResolve" title="TreesAndTypesDomain.this.NullConst.type">NullConst</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> else
            <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain.subConsts" title="Option[scala.collection.immutable.Set[TreesAndTypesDomain.this.Const]]">subConsts</a>

        <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.observed" title="()Unit">observed</a><span class="delimiter">(</span><span class="delimiter">)</span>; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain.allConsts" title="Option[scala.collection.immutable.Set[TreesAndTypesDomain.this.Const]]">allConsts</a>
      <span class="delimiter">}</span>

      <span class="comment">// populate equalitySyms</span>
      <span class="comment">// don't care about the result, but want only one fresh symbol per distinct constant c</span>
      def <a title="(c: TreesAndTypesDomain.this.Const)Unit" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.registerEquality">registerEquality</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.registerEquality.c">c</a>: <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const" title="TreesAndTypesDomain.this.Const">Const</a><span class="delimiter">)</span>: <a href="../../../../Unit.scala.html#scala;Unit" title="Unit">Unit</a> = <span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.ensureCanModify" title="()Unit">ensureCanModify</a><span class="delimiter">(</span><span class="delimiter">)</span>; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.symForEqualsTo" title="scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Const,TreesAndTypesDomain.this.Sym]">symForEqualsTo</a> <a href="../../../../collection/mutable/MapLike.scala.html#scala.collection.mutable;MapLike.getOrElseUpdate" title="(key: TreesAndTypesDomain.this.Const, op: =&gt; TreesAndTypesDomain.this.Sym)TreesAndTypesDomain.this.Sym">getOrElseUpdate</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.registerEquality.c" title="TreesAndTypesDomain.this.Const">c</a>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.Sym.apply" title="(variable: TreesAndTypesDomain.this.Var, const: TreesAndTypesDomain.this.Const)TreesAndTypesDomain.this.Sym">Sym</a><span class="delimiter">(</span>this, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.registerEquality.c" title="TreesAndTypesDomain.this.Const">c</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">}</span>

      <span class="comment">// return the symbol that represents this variable being equal to the constant `c`, if it exists, otherwise False (for robustness)</span>
      <span class="comment">// (registerEquality(c) must have been called prior, either when constructing the domain or from outside)</span>
      def <a title="(c: TreesAndTypesDomain.this.Const)TreesAndTypesDomain.this.Prop" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.propForEqualsTo">propForEqualsTo</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.propForEqualsTo.c">c</a>: <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const" title="TreesAndTypesDomain.this.Const">Const</a><span class="delimiter">)</span>: <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Prop" title="TreesAndTypesDomain.this.Prop">Prop</a> = <span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.observed" title="()Unit">observed</a><span class="delimiter">(</span><span class="delimiter">)</span>; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.symForEqualsTo" title="scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Const,TreesAndTypesDomain.this.Sym]">symForEqualsTo</a>.<a href="../../../../collection/MapLike.scala.html#scala.collection;MapLike.getOrElse" title="(key: TreesAndTypesDomain.this.Const, default: =&gt; Product with Serializable with TreesAndTypesDomain.this.Prop)Product with Serializable with TreesAndTypesDomain.this.Prop">getOrElse</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.propForEqualsTo.c" title="TreesAndTypesDomain.this.Const">c</a>, <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic.False.readResolve" title="TreesAndTypesDomain.this.False.type">False</a><span class="delimiter">)</span><span class="delimiter">}</span>

      <span class="comment">// [implementation NOTE: don't access until all potential equalities have been registered using registerEquality]p</span>
      <span class="comment">/** the information needed to construct the boolean proposition that encods the equality proposition (V = C)
       *
       * that models a type test pattern `_: C` or constant pattern `C`, where the type test gives rise to a TypeConst C,
       * and the constant pattern yields a ValueConst C
       *
       * for exhaustivity, we really only need implication (e.g., V = 1 implies that V = 1 /\ V = Int, if both tests occur in the match,
       * and thus in this variable's equality symbols), but reachability also requires us to model things like V = 1 precluding V = &quot;1&quot;
       */</span>
      lazy val <a title="List[(TreesAndTypesDomain.this.Sym, List[TreesAndTypesDomain.this.Sym], List[TreesAndTypesDomain.this.Sym])]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications">implications</a> = <span class="delimiter">{</span>
        <span class="comment">/* when we know V = C, which other equalities must hold
         *
         * in general, equality to some type implies equality to its supertypes
         * (this multi-valued kind of equality is necessary for unreachability)
         * note that we use subtyping as a model for implication between instanceof tests
         * i.e., when S &lt;:&lt; T we assume x.isInstanceOf[S] implies x.isInstanceOf[T]
         * unfortunately this is not true in general (see e.g. SI-6022)
         */</span>
        def <a title="(lower: TreesAndTypesDomain.this.Const, upper: TreesAndTypesDomain.this.Const)Boolean" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.implies">implies</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.implies.lower">lower</a>: <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const" title="TreesAndTypesDomain.this.Const">Const</a>, <a title="TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.implies.upper">upper</a>: <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const" title="TreesAndTypesDomain.this.Const">Const</a><span class="delimiter">)</span>: <a href="../../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> =
          <span class="comment">// values and null</span>
            <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.implies.lower" title="TreesAndTypesDomain.this.Const">lower</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.implies.upper" title="TreesAndTypesDomain.this.Const">upper</a> <a href="../../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a>
          <span class="comment">// type implication</span>
            <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.implies.lower" title="TreesAndTypesDomain.this.Const">lower</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.NullConst.readResolve" title="TreesAndTypesDomain.this.NullConst.type">NullConst</a> <a href="../../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.implies.upper" title="TreesAndTypesDomain.this.Const">upper</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const.isValue" title="=&gt; Boolean">isValue</a> <a href="../../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a>
             <a href="MatchAnalysis.scala.html#scala.tools.nsc.transform.patmat;TreeAndTypeAnalysis.instanceOfTpImplies" title="(tp: ScalaLogic.this.global.Type, tpImplied: ScalaLogic.this.global.Type)Boolean">instanceOfTpImplies</a><span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.implies.lower" title="TreesAndTypesDomain.this.Const">lower</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const.isValue" title="=&gt; Boolean">isValue</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.implies.lower" title="TreesAndTypesDomain.this.Const">lower</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const.wideTp" title="=&gt; TreesAndTypesDomain.this.Type">wideTp</a> else <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.implies.lower" title="TreesAndTypesDomain.this.Const">lower</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const.tp" title="=&gt; TreesAndTypesDomain.this.Type">tp</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.implies.upper" title="TreesAndTypesDomain.this.Const">upper</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const.tp" title="=&gt; TreesAndTypesDomain.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>

          <span class="comment">// if(r) debug.patmat(&quot;implies    : &quot;+(lower, lower.tp, upper, upper.tp))</span>
          <span class="comment">// else  debug.patmat(&quot;NOT implies: &quot;+(lower, upper))</span>


        <span class="comment">/** Does V=A preclude V=B?
         *
         * (0) A or B must be in the domain to draw any conclusions.
         *
         *     For example, knowing the the scrutinee is *not* true does not
         *     statically exclude it from being `X`, because that is an opaque
         *     Boolean.
         *
         *     val X = true
         *     (true: Boolean) match { case true =&gt; case X &lt;reachable&gt; }
         *
         * (1) V = null excludes assignment to any other constant (modulo point #0). This includes
         *     both values and type tests (which are both modelled here as `Const`)
         * (2) V = A and V = B, for A and B domain constants, are mutually exclusive unless A == B
         *
         * (3) We only reason about test tests as being excluded by null assignments, otherwise we
         *     only consider value assignments.
         *     TODO: refine this, a == 0 excludes a: String, or `a: Int` excludes `a: String`
         *     (since no value can be of both types. See also SI-7211)
         *
         *  NOTE: V = 1 does not preclude V = Int, or V = Any, it could be said to preclude
         *        V = String, but we don't model that.
         */</span>
        def <a title="(a: TreesAndTypesDomain.this.Const, b: TreesAndTypesDomain.this.Const)Boolean" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes">excludes</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.a">a</a>: <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const" title="TreesAndTypesDomain.this.Const">Const</a>, <a title="TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.b">b</a>: <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const" title="TreesAndTypesDomain.this.Const">Const</a><span class="delimiter">)</span>: <a href="../../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> = <span class="delimiter">{</span>
          val bothInDomain  = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain" title="=&gt; Option[Set[TreesAndTypesDomain.this.Const]]">domain</a> <a href="../../../../Option.scala.html#scala;Option.exists" title="Boolean" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.bothInDomain">exists</a> <span class="delimiter">(</span><a title="Set[TreesAndTypesDomain.this.Const]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.bothInDomain.$anonfun.d">d</a> =&gt; <a href="../../../../collection/GenSetLike.scala.html#scala.collection;GenSetLike.apply" title="(elem: TreesAndTypesDomain.this.Const)Boolean">d</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.a" title="TreesAndTypesDomain.this.Const">a</a><span class="delimiter">)</span> <a href="../../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="../../../../collection/GenSetLike.scala.html#scala.collection;GenSetLike.apply" title="(elem: TreesAndTypesDomain.this.Const)Boolean">d</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.b" title="TreesAndTypesDomain.this.Const">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
          val eitherIsNull  = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.a" title="TreesAndTypesDomain.this.Const">a</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.NullConst.readResolve" title="TreesAndTypesDomain.this.NullConst.type">NullConst</a> <a href="../../../../Boolean.scala.html#scala;Boolean.||" title="Boolean" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.eitherIsNull">||</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.b" title="TreesAndTypesDomain.this.Const">b</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.NullConst.readResolve" title="TreesAndTypesDomain.this.NullConst.type">NullConst</a>
          val bothAreValues = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.a" title="TreesAndTypesDomain.this.Const">a</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const.isValue" title="=&gt; Boolean">isValue</a> <a href="../../../../Boolean.scala.html#scala;Boolean.&&" title="Boolean" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.bothAreValues">&amp;&amp;</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.b" title="TreesAndTypesDomain.this.Const">b</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const.isValue" title="=&gt; Boolean">isValue</a>
          <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.bothInDomain" title="Boolean">bothInDomain</a> <a href="../../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.eitherIsNull" title="Boolean">eitherIsNull</a> <a href="../../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.bothAreValues" title="Boolean">bothAreValues</a><span class="delimiter">)</span> <a href="../../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.a" title="TreesAndTypesDomain.this.Const">a</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes.b" title="TreesAndTypesDomain.this.Const">b</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

          <span class="comment">// if(r) debug.patmat(&quot;excludes    : &quot;+(a, a.tp, b, b.tp))</span>
          <span class="comment">// else  debug.patmat(&quot;NOT excludes: &quot;+(a, b))</span>

<span class="comment">/*
[ HALF BAKED FANCINESS: //!equalitySyms.exists(common =&gt; implies(common.const, a) &amp;&amp; implies(common.const, b)))
 when type tests are involved, we reason (conservatively) under a closed world assumption,
 since we are really only trying to counter the effects of the symbols that we introduce to model type tests
 we don't aim to model the whole subtyping hierarchy, simply to encode enough about subtyping to do unreachability properly

 consider the following hierarchy:

    trait A
    trait B
    trait C
    trait AB extends B with A

  // two types are mutually exclusive if there is no equality symbol whose constant implies both
  object Test extends App {
    def foo(x: Any) = x match {
      case _ : C  =&gt; println(&quot;C&quot;)
      case _ : AB =&gt; println(&quot;AB&quot;)
      case _ : (A with B) =&gt; println(&quot;AB'&quot;)
      case _ : B  =&gt; println(&quot;B&quot;)
      case _ : A  =&gt; println(&quot;A&quot;)
    }

 of course this kind of reasoning is not true in general,
 but we can safely pretend types are mutually exclusive as long as there are no counter-examples in the match we're analyzing}
*/</span>

        val <a title="scala.collection.mutable.HashSet[ExcludedPair]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludedPair">excludedPair</a> = new mutable.<a href="../../../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet" title="scala.collection.mutable.HashSet[ExcludedPair]">HashSet</a><span class="delimiter">[</span>ExcludedPair<span class="delimiter">]</span>

        case class <a title="class ExcludedPair extends AnyRef with Product with Serializable" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.readResolve">ExcludedPair</a><a href="../../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.a">a</a>: <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const" title="TreesAndTypesDomain.this.Const">Const</a>, <a title="TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.b">b</a>: <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const" title="TreesAndTypesDomain.this.Const">Const</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          override def <a title="(o: Any)Boolean" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.equals">equals</a><span class="delimiter">(</span><a title="Any" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.equals.o">o</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.equals.o" title="Any">o</a> match <span class="delimiter">{</span>
            case <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.readResolve" title="(x$0: ExcludedPair)Option[(TreesAndTypesDomain.this.Const, TreesAndTypesDomain.this.Const)]">ExcludedPair</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.equals.aa">aa</a>, <a title="TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.equals.bb">bb</a><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.a" title="=&gt; TreesAndTypesDomain.this.Const">a</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.equals.aa" title="TreesAndTypesDomain.this.Const">aa</a> <a href="../../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.b" title="=&gt; TreesAndTypesDomain.this.Const">b</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.equals.bb" title="TreesAndTypesDomain.this.Const">bb</a><span class="delimiter">)</span> <a href="../../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.a" title="=&gt; TreesAndTypesDomain.this.Const">a</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.equals.bb" title="TreesAndTypesDomain.this.Const">bb</a> <a href="../../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.b" title="=&gt; TreesAndTypesDomain.this.Const">b</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.equals.aa" title="TreesAndTypesDomain.this.Const">aa</a><span class="delimiter">)</span>
            case _ =&gt; false
          <span class="delimiter">}</span>
          <span class="comment">// make ExcludedPair(a, b).hashCode == ExcludedPair(b, a).hashCode</span>
          override def <a title="()Int" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.hashCode">hashCode</a> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.a" title="=&gt; TreesAndTypesDomain.this.Const">a</a>.<span title="()Int">hashCode</span> <a href="../../../../Int.scala.html#scala;Int.^(1409840560)" title="(x: Int)Int">^</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.b" title="=&gt; TreesAndTypesDomain.this.Const">b</a>.<span title="()Int">hashCode</span>
        <span class="delimiter">}</span>

        <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.equalitySyms" title="=&gt; List[TreesAndTypesDomain.this.Sym]">equalitySyms</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: TreesAndTypesDomain.this.Sym =&gt; (TreesAndTypesDomain.this.Sym, List[TreesAndTypesDomain.this.Sym], List[TreesAndTypesDomain.this.Sym]))(implicit bf: scala.collection.generic.CanBuildFrom[List[TreesAndTypesDomain.this.Sym],(TreesAndTypesDomain.this.Sym, List[TreesAndTypesDomain.this.Sym], List[TreesAndTypesDomain.this.Sym]),List[(TreesAndTypesDomain.this.Sym, List[TreesAndTypesDomain.this.Sym], List[TreesAndTypesDomain.this.Sym])]])List[(TreesAndTypesDomain.this.Sym, List[TreesAndTypesDomain.this.Sym], List[TreesAndTypesDomain.this.Sym])]">map</a> <span class="delimiter">{</span> <a title="TreesAndTypesDomain.this.Sym" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.sym">sym</a> =&gt;
          <span class="comment">// if we've already excluded the pair at some point (-A \/ -B), then don't exclude the symmetric one (-B \/ -A)</span>
          <span class="comment">// (nor the positive implications -B \/ A, or -A \/ B, which would entail the equality axioms falsifying the whole formula)</span>
          val todo = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.equalitySyms" title="=&gt; List[TreesAndTypesDomain.this.Sym]">equalitySyms</a> <a href="../../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filterNot" title="List[TreesAndTypesDomain.this.Sym]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.todo">filterNot</a> <span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Sym" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.todo.$anonfun.b">b</a> =&gt; <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.todo.$anonfun.b" title="TreesAndTypesDomain.this.Sym">b</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.const" title="=&gt; TreesAndTypesDomain.this.Const">const</a> <span title="(x$1: Any)Boolean">==</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.sym" title="TreesAndTypesDomain.this.Sym">sym</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.const" title="=&gt; TreesAndTypesDomain.this.Const">const</a><span class="delimiter">)</span> <a href="../../../../Boolean.scala.html#scala;Boolean.||" title="(x: Boolean)Boolean">||</a> <a href="../../../../collection/GenSetLike.scala.html#scala.collection;GenSetLike.apply" title="(elem: ExcludedPair)Boolean">excludedPair</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.readResolve" title="(a: TreesAndTypesDomain.this.Const, b: TreesAndTypesDomain.this.Const)ExcludedPair">ExcludedPair</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.todo.$anonfun.b" title="TreesAndTypesDomain.this.Sym">b</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.const" title="=&gt; TreesAndTypesDomain.this.Const">const</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.sym" title="TreesAndTypesDomain.this.Sym">sym</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.const" title="=&gt; TreesAndTypesDomain.this.Const">const</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          val <a href="../../../../Tuple2.scala.html#scala;Tuple2" title="(_1: List[TreesAndTypesDomain.this.Sym], _2: List[TreesAndTypesDomain.this.Sym])(List[TreesAndTypesDomain.this.Sym], List[TreesAndTypesDomain.this.Sym])" class="delimiter">(</a><a href="../../../../Tuple2.scala.html#scala;Tuple2._1" title="List[TreesAndTypesDomain.this.Sym]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.excluded">excluded</a>, <a href="../../../../Tuple2.scala.html#scala;Tuple2._2" title="List[TreesAndTypesDomain.this.Sym]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.notExcluded">notExcluded</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.todo" title="List[TreesAndTypesDomain.this.Sym]">todo</a> <a href="../../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.partition" title="(List[TreesAndTypesDomain.this.Sym], List[TreesAndTypesDomain.this.Sym])">partition</a> <span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Sym" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.x$11.$anonfun.b">b</a> =&gt; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludes" title="(a: TreesAndTypesDomain.this.Const, b: TreesAndTypesDomain.this.Const)Boolean">excludes</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.sym" title="TreesAndTypesDomain.this.Sym">sym</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.const" title="=&gt; TreesAndTypesDomain.this.Const">const</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.x$11.$anonfun.b" title="TreesAndTypesDomain.this.Sym">b</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.const" title="=&gt; TreesAndTypesDomain.this.Const">const</a><span class="delimiter">)</span><span class="delimiter">)</span>
          val implied = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.notExcluded" title="List[TreesAndTypesDomain.this.Sym]">notExcluded</a> <a href="../../../../collection/TraversableLike.scala.html#scala.collection;TraversableLike.filter" title="List[TreesAndTypesDomain.this.Sym]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.implied">filter</a> <span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Sym" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.implied.$anonfun.b">b</a> =&gt; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.implies" title="(lower: TreesAndTypesDomain.this.Const, upper: TreesAndTypesDomain.this.Const)Boolean">implies</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.sym" title="TreesAndTypesDomain.this.Sym">sym</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.const" title="=&gt; TreesAndTypesDomain.this.Const">const</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.implied.$anonfun.b" title="TreesAndTypesDomain.this.Sym">b</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.const" title="=&gt; TreesAndTypesDomain.this.Const">const</a><span class="delimiter">)</span><span class="delimiter">)</span>

          <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug" title="ScalaLogic.this.debug.type">debug</a>.<a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug.patmat" title="(s: =&gt; String)Unit">patmat</a><span class="delimiter">(</span><span title="String(&quot;eq axioms for: &quot;)" class="string">&quot;eq axioms for: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.sym" title="TreesAndTypesDomain.this.Sym">sym</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.const" title="=&gt; TreesAndTypesDomain.this.Const">const</a><span class="delimiter">)</span>
          <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug" title="ScalaLogic.this.debug.type">debug</a>.<a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug.patmat" title="(s: =&gt; String)Unit">patmat</a><span class="delimiter">(</span><span title="String(&quot;excluded: &quot;)" class="string">&quot;excluded: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.excluded" title="List[TreesAndTypesDomain.this.Sym]">excluded</a><span class="delimiter">)</span>
          <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug" title="ScalaLogic.this.debug.type">debug</a>.<a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug.patmat" title="(s: =&gt; String)Unit">patmat</a><span class="delimiter">(</span><span title="String(&quot;implied: &quot;)" class="string">&quot;implied: &quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.implied" title="List[TreesAndTypesDomain.this.Sym]">implied</a><span class="delimiter">)</span>

          <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.excluded" title="List[TreesAndTypesDomain.this.Sym]">excluded</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.foreach" title="(f: TreesAndTypesDomain.this.Sym =&gt; scala.collection.mutable.HashSet[ExcludedPair])Unit">foreach</a> <span class="delimiter">{</span> <a title="TreesAndTypesDomain.this.Sym" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.$anonfun.excludedSym">excludedSym</a> =&gt; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.excludedPair" title="scala.collection.mutable.HashSet[ExcludedPair]">excludedPair</a> <a href="../../../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet.+=(53f2a8289f)" title="(elem: ExcludedPair)excludedPair.type">+=</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications;ExcludedPair.readResolve" title="(a: TreesAndTypesDomain.this.Const, b: TreesAndTypesDomain.this.Const)ExcludedPair">ExcludedPair</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.sym" title="TreesAndTypesDomain.this.Sym">sym</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.const" title="=&gt; TreesAndTypesDomain.this.Const">const</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.$anonfun.excludedSym" title="TreesAndTypesDomain.this.Sym">excludedSym</a>.<a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;Sym.const" title="=&gt; TreesAndTypesDomain.this.Const">const</a><span class="delimiter">)</span><span class="delimiter">}</span>

          <a href="../../../../Tuple3.scala.html#scala;Tuple3" title="(_1: TreesAndTypesDomain.this.Sym, _2: List[TreesAndTypesDomain.this.Sym], _3: List[TreesAndTypesDomain.this.Sym])(TreesAndTypesDomain.this.Sym, List[TreesAndTypesDomain.this.Sym], List[TreesAndTypesDomain.this.Sym])" class="delimiter">(</a><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.sym" title="TreesAndTypesDomain.this.Sym">sym</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.implied" title="List[TreesAndTypesDomain.this.Sym]">implied</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.implications.$anonfun.excluded" title="List[TreesAndTypesDomain.this.Sym]">excluded</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span class="comment">// accessing after calling registerNull will result in inconsistencies</span>
      lazy val domainSyms: <a href="../../../../Option.scala.html#scala;Option" title="Option[Set[TreesAndTypesDomain.this.Sym]]">Option</a><span class="delimiter">[</span>Set<span class="delimiter">[</span>Sym<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain" title="=&gt; Option[Set[TreesAndTypesDomain.this.Const]]">domain</a> <a title="Option[Set[TreesAndTypesDomain.this.Sym]]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domainSyms">map</a> <span class="delimiter">{</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domainSyms.$anonfun.x$12" title="Set[TreesAndTypesDomain.this.Const]">_</a> <a href="../../../../collection/SetLike.scala.html#scala.collection;SetLike.map" title="(f: TreesAndTypesDomain.this.Const =&gt; TreesAndTypesDomain.this.Sym)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[TreesAndTypesDomain.this.Const],TreesAndTypesDomain.this.Sym,Set[TreesAndTypesDomain.this.Sym]])Set[TreesAndTypesDomain.this.Sym]">map</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.symForEqualsTo" title="scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Const,TreesAndTypesDomain.this.Sym]">symForEqualsTo</a> <span class="delimiter">}</span>

      lazy val <a title="Option[TreesAndTypesDomain.this.Sym]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.symForStaticTp">symForStaticTp</a>: <a href="../../../../Option.scala.html#scala;Option" title="Option[TreesAndTypesDomain.this.Sym]">Option</a><span class="delimiter">[</span>Sym<span class="delimiter">]</span>  = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.symForEqualsTo" title="scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Const,TreesAndTypesDomain.this.Sym]">symForEqualsTo</a>.<a href="../../../../collection/mutable/HashMap.scala.html#scala.collection.mutable;HashMap.get" title="(key: TreesAndTypesDomain.this.Const)Option[TreesAndTypesDomain.this.Sym]">get</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.TypeConst.apply" title="(tp: TreesAndTypesDomain.this.Type)TreesAndTypesDomain.this.Const">TypeConst</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.staticTpCheckable" title="=&gt; TreesAndTypesDomain.this.Type">staticTpCheckable</a><span class="delimiter">)</span><span class="delimiter">)</span>

      <span class="comment">// don't access until all potential equalities have been registered using registerEquality</span>
      private lazy val <a title="List[TreesAndTypesDomain.this.Sym]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.equalitySyms">equalitySyms</a> = <span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.observed" title="()Unit">observed</a><span class="delimiter">(</span><span class="delimiter">)</span>; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.symForEqualsTo" title="scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Const,TreesAndTypesDomain.this.Sym]">symForEqualsTo</a>.<a href="../../../../collection/mutable/HashMap.scala.html#scala.collection.mutable;HashMap.values" title="=&gt; Iterable[TreesAndTypesDomain.this.Sym]">values</a>.<a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.toList" title="=&gt; List[TreesAndTypesDomain.this.Sym]">toList</a><span class="delimiter">}</span>

      <span class="comment">// don't call until all equalities have been registered and registerNull has been called (if needed)</span>
      def <a title="=&gt; String" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.describe">describe</a> = <span class="delimiter">{</span>
        def <a title="=&gt; String" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.describe.domain_s">domain_s</a> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.domain" title="=&gt; Option[Set[TreesAndTypesDomain.this.Const]]">domain</a> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><a title="Set[TreesAndTypesDomain.this.Const]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.describe.domain_s.d">d</a><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.describe.domain_s.d" title="Set[TreesAndTypesDomain.this.Const]">d</a> <a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a> <span class="delimiter">(</span><span title="String(&quot; ::= &quot;)" class="string">&quot; ::= &quot;</span>, <span title="String(&quot; | &quot;)" class="string">&quot; | &quot;</span>, <span title="String(&quot;// &quot;)" class="string">&quot;// &quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.symForEqualsTo" title="scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Const,TreesAndTypesDomain.this.Sym]">symForEqualsTo</a>.<a href="../../../../collection/MapLike.scala.html#scala.collection;MapLike.keys" title="=&gt; Iterable[TreesAndTypesDomain.this.Const]">keys</a><span class="delimiter">)</span>
          case _       =&gt; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.symForEqualsTo" title="scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Const,TreesAndTypesDomain.this.Sym]">symForEqualsTo</a>.<a href="../../../../collection/MapLike.scala.html#scala.collection;MapLike.keys" title="=&gt; Iterable[TreesAndTypesDomain.this.Const]">keys</a> <a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a> <span class="delimiter">(</span><span title="String(&quot; ::= &quot;)" class="string">&quot; ::= &quot;</span>, <span title="String(&quot; | &quot;)" class="string">&quot; | &quot;</span>, <span title="String(&quot; | ...&quot;)" class="string">&quot; | ...&quot;</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        <a href="../../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span>this<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var" title="String(&quot;: &quot;)">: $</a><span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.staticTp" title="TreesAndTypesDomain.this.Type">staticTp</a><span class="delimiter">}</span><span title="String(&quot;&quot;)">$</span><span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.describe.domain_s" title="=&gt; String">domain_s</a><span class="delimiter">}</span><span title="String(&quot; // = &quot;)"> // = $</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.path" title="=&gt; TreesAndTypesDomain.this.Tree">path</a><span title="String(&quot;&quot;)" class="string">&quot;</span>
      <span class="delimiter">}</span>
      override def <a title="()String" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.toString">toString</a> = <span title="String(&quot;V&quot;)" class="string">&quot;V&quot;</span><span title="(x$1: Any)String">+</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Var.id" title="Int">id</a>
    <span class="delimiter">}</span>


    import <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.global" title="=&gt; scala.tools.nsc.Global">global</a>.<span class="delimiter">{</span>ConstantType, Constant, EmptyScope, SingletonType, Literal, Ident, refinedType, singleType, TypeBounds, NoSymbol<span class="delimiter">}</span>
    import <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.global" title="=&gt; scala.tools.nsc.Global">global</a>.<a href="../../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions.definitions" title="ScalaLogic.this.global.definitions.type">definitions</a>._


    <span class="comment">// all our variables range over types</span>
    <span class="comment">// a literal constant becomes ConstantType(Constant(v)) when the type allows it (roughly, anyval + string + null)</span>
    <span class="comment">// equality between variables: SingleType(x) (note that pattern variables cannot relate to each other -- it's always patternVar == nonPatternVar)</span>
    object <a title="TreesAndTypesDomain.this.Const.type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const">Const</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const" title="TreesAndTypesDomain.this.Const.type" class="delimiter">{</a>
      def <a title="()Unit" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.resetUniques">resetUniques</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const._nextTypeId_=" title="(x$1: Int)Unit">_nextTypeId</a> = <span title="Int(0)" class="int">0</span>; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const._nextValueId_=" title="(x$1: Int)Unit">_nextValueId</a> = <span title="Int(0)" class="int">0</span>; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniques" title="=&gt; scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Type,TreesAndTypesDomain.this.Const]">uniques</a>.<a href="../../../../collection/mutable/HashMap.scala.html#scala.collection.mutable;HashMap.clear" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span> ; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.trees" title="=&gt; scala.collection.mutable.HashSet[TreesAndTypesDomain.this.Tree]">trees</a>.<a href="../../../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet.clear" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">}</span>

      private var <a title="Int" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const._nextTypeId_=">_nextTypeId</a> = <span title="Int(0)" class="int">0</span>
      def <a title="=&gt; Int" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.nextTypeId">nextTypeId</a> = <span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const._nextTypeId_=" title="(x$1: Int)Unit">_nextTypeId</a> <a href="../../../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const._nextTypeId_=" title="=&gt; Int">_nextTypeId</a><span class="delimiter">}</span>

      private var <a title="Int" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const._nextValueId_=">_nextValueId</a> = <span title="Int(0)" class="int">0</span>
      def <a title="=&gt; Int" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.nextValueId">nextValueId</a> = <span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const._nextValueId_=" title="(x$1: Int)Unit">_nextValueId</a> <a href="../../../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+=</a> <span title="Int(1)" class="int">1</span>; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const._nextValueId_=" title="=&gt; Int">_nextValueId</a><span class="delimiter">}</span>

      private val <a title="scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Type,TreesAndTypesDomain.this.Const]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniques">uniques</a> = new mutable.<a href="../../../../collection/mutable/HashMap.scala.html#scala.collection.mutable;HashMap" title="scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Type,TreesAndTypesDomain.this.Const]">HashMap</a><span class="delimiter">[</span>Type, Const<span class="delimiter">]</span>
      private<span class="delimiter">[</span>TreesAndTypesDomain<span class="delimiter">]</span> def <a title="(tp: TreesAndTypesDomain.this.Type, mkFresh: =&gt; TreesAndTypesDomain.this.Const)TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique">unique</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.tp">tp</a>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a>, <a title="=&gt; TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.mkFresh">mkFresh</a>: =&gt; Const<span class="delimiter">)</span>: <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const" title="TreesAndTypesDomain.this.Const">Const</a> =
        <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniques" title="=&gt; scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Type,TreesAndTypesDomain.this.Const]">uniques</a>.<a href="../../../../collection/mutable/HashMap.scala.html#scala.collection.mutable;HashMap.get" title="(key: TreesAndTypesDomain.this.Type)Option[TreesAndTypesDomain.this.Const]">get</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.tp" title="TreesAndTypesDomain.this.Type">tp</a><span class="delimiter">)</span>.<a href="../../../../Option.scala.html#scala;Option.getOrElse" title="(default: =&gt; TreesAndTypesDomain.this.Const)TreesAndTypesDomain.this.Const">getOrElse</a><span class="delimiter">(</span>
          <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniques" title="=&gt; scala.collection.mutable.HashMap[TreesAndTypesDomain.this.Type,TreesAndTypesDomain.this.Const]">uniques</a>.<a href="../../../../collection/IterableLike.scala.html#scala.collection;IterableLike.find" title="(p: ((TreesAndTypesDomain.this.Type, TreesAndTypesDomain.this.Const)) =&gt; Boolean)Option[(TreesAndTypesDomain.this.Type, TreesAndTypesDomain.this.Const)]">find</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.$anonfun.x0$2" title="Boolean" class="delimiter">{</a>case <span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.$anonfun.oldTp">oldTp</a>, <a title="TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.$anonfun.oldC">oldC</a><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.$anonfun.oldTp" title="TreesAndTypesDomain.this.Type">oldTp</a> <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.=:=" title="(that: ScalaLogic.this.global.Type)Boolean">=:=</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.tp" title="TreesAndTypesDomain.this.Type">tp</a><span class="delimiter">}</span> match <span class="delimiter">{</span>
            case Some<span class="delimiter">(</span><span class="delimiter">(</span>_, <a title="TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.c">c</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
              <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug" title="ScalaLogic.this.debug.type">debug</a>.<a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug.patmat" title="(s: =&gt; String)Unit">patmat</a><span class="delimiter">(</span><span title="String(&quot;unique const: &quot;)" class="string">&quot;unique const: &quot;</span><span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="../../../../Tuple2.scala.html#scala;Tuple2" title="(_1: TreesAndTypesDomain.this.Type, _2: TreesAndTypesDomain.this.Const)(TreesAndTypesDomain.this.Type, TreesAndTypesDomain.this.Const)" class="delimiter">(</a><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.tp" title="TreesAndTypesDomain.this.Type">tp</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.c" title="TreesAndTypesDomain.this.Const">c</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.c" title="TreesAndTypesDomain.this.Const">c</a>
            case _ =&gt;
              val <a title="TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.fresh">fresh</a> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.mkFresh" title="=&gt; TreesAndTypesDomain.this.Const">mkFresh</a>
              <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug" title="ScalaLogic.this.debug.type">debug</a>.<a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug.patmat" title="(s: =&gt; String)Unit">patmat</a><span class="delimiter">(</span><span title="String(&quot;uniqued const: &quot;)" class="string">&quot;uniqued const: &quot;</span><span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="../../../../Tuple2.scala.html#scala;Tuple2" title="(_1: TreesAndTypesDomain.this.Type, _2: TreesAndTypesDomain.this.Const)(TreesAndTypesDomain.this.Type, TreesAndTypesDomain.this.Const)" class="delimiter">(</a><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.tp" title="TreesAndTypesDomain.this.Type">tp</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.fresh" title="TreesAndTypesDomain.this.Const">fresh</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="../../../../collection/mutable/HashMap.scala.html#scala.collection.mutable;HashMap.update" title="(key: TreesAndTypesDomain.this.Type, value: TreesAndTypesDomain.this.Const)Unit">uniques</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.tp" title="TreesAndTypesDomain.this.Type">tp</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.fresh" title="TreesAndTypesDomain.this.Const">fresh</a>
              <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique.fresh" title="TreesAndTypesDomain.this.Const">fresh</a>
          <span class="delimiter">}</span><span class="delimiter">)</span>

      private val <a title="scala.collection.mutable.HashSet[TreesAndTypesDomain.this.Tree]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.trees">trees</a> = mutable.<a href="../../../../collection/mutable/HashSet.scala.html#scala.collection.mutable.HashSet" title="scala.collection.mutable.HashSet.type">HashSet</a>.<a href="../../../../collection/mutable/HashSet.scala.html#scala.collection.mutable.HashSet.empty" title="[A]=&gt; scala.collection.mutable.HashSet[A]">empty</a><span title="scala.collection.mutable.HashSet[TreesAndTypesDomain.this.Tree]" class="delimiter">[</span><a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TreesAndTypesDomain.this.Tree">Tree</a><span class="delimiter">]</span>

      <span class="comment">// hashconsing trees (modulo value-equality)</span>
      private<span class="delimiter">[</span>TreesAndTypesDomain<span class="delimiter">]</span> def <a title="(t: TreesAndTypesDomain.this.Tree)TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree">uniqueTpForTree</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Tree" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.t">t</a>: <a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TreesAndTypesDomain.this.Tree">Tree</a><span class="delimiter">)</span>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a> = <span class="delimiter">{</span>
        def <a title="(tp: TreesAndTypesDomain.this.Type)TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.freshExistentialSubtype">freshExistentialSubtype</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.freshExistentialSubtype.tp">tp</a>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a> = <span class="delimiter">{</span>
          <span class="comment">// SI-8611 tp.narrow is tempting, but unsuitable. See `testRefinedTypeSI8611` for an explanation.</span>
          <a href="../../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols.NoSymbol" title="=&gt; ScalaLogic.this.global.NoSymbol">NoSymbol</a>.<a href="../../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.freshExistential" title="(suffix: String)ScalaLogic.this.global.TypeSymbol">freshExistential</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>.<a href="../../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.setInfo" title="(info: ScalaLogic.this.global.Type)ScalaLogic.this.global.TypeSymbol">setInfo</a><span class="delimiter">(</span><a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types.TypeBounds" title="ScalaLogic.this.global.TypeBounds.type">TypeBounds</a>.<a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types.TypeBounds.upper" title="(hi: ScalaLogic.this.global.Type)ScalaLogic.this.global.TypeBounds">upper</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.freshExistentialSubtype.tp" title="TreesAndTypesDomain.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.tpe" title="=&gt; ScalaLogic.this.global.Type">tpe</a>
        <span class="delimiter">}</span>

        if <span class="delimiter">(</span><a href="../../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.t" title="TreesAndTypesDomain.this.Tree">t</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; ScalaLogic.this.global.Symbol">symbol</a>.<a href="../../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isStable" title="=&gt; Boolean">isStable</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="comment">// Create a fresh type for each unstable value, since we can never correlate it to another value.</span>
          <span class="comment">// For example `case X =&gt; case X =&gt;` should not complaing about the second case being unreachable,</span>
          <span class="comment">// if X is mutable.</span>
          <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.freshExistentialSubtype" title="(tp: TreesAndTypesDomain.this.Type)TreesAndTypesDomain.this.Type">freshExistentialSubtype</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.t" title="TreesAndTypesDomain.this.Tree">t</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; ScalaLogic.this.global.Type">tpe</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
        else <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.trees" title="=&gt; scala.collection.mutable.HashSet[TreesAndTypesDomain.this.Tree]">trees</a> <a href="../../../../collection/IterableLike.scala.html#scala.collection;IterableLike.find" title="(p: TreesAndTypesDomain.this.Tree =&gt; Boolean)Option[TreesAndTypesDomain.this.Tree]">find</a> <span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Tree" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.$anonfun.a">a</a> =&gt; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.$anonfun.a" title="TreesAndTypesDomain.this.Tree">a</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;TreeContextApiImpl.correspondsStructure" title="(that: ScalaLogic.this.global.Tree)(f: (ScalaLogic.this.global.Tree, ScalaLogic.this.global.Tree) =&gt; Boolean)Boolean">correspondsStructure</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.t" title="TreesAndTypesDomain.this.Tree">t</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="MatchAnalysis.scala.html#scala.tools.nsc.transform.patmat;TreeAndTypeAnalysis.sameValue" title="(a: ScalaLogic.this.global.Tree, b: ScalaLogic.this.global.Tree)Boolean">sameValue</a><span class="delimiter">)</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Tree" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.orig">orig</a><span class="delimiter">)</span> =&gt;
            <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug" title="ScalaLogic.this.debug.type">debug</a>.<a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug.patmat" title="(s: =&gt; String)Unit">patmat</a><span class="delimiter">(</span><span title="String(&quot;unique tp for tree: &quot;)" class="string">&quot;unique tp for tree: &quot;</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="../../../../Tuple2.scala.html#scala;Tuple2" title="(_1: TreesAndTypesDomain.this.Tree, _2: ScalaLogic.this.global.Type)(TreesAndTypesDomain.this.Tree, ScalaLogic.this.global.Type)" class="delimiter">(</a><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.orig" title="TreesAndTypesDomain.this.Tree">orig</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.orig" title="TreesAndTypesDomain.this.Tree">orig</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; ScalaLogic.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.orig" title="TreesAndTypesDomain.this.Tree">orig</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; ScalaLogic.this.global.Type">tpe</a>
          case _ =&gt;
            <span class="comment">// duplicate, don't mutate old tree (TODO: use a map tree -&gt; type instead?)</span>
            val treeWithNarrowedType = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.t" title="TreesAndTypesDomain.this.Tree">t</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.duplicate" title="=&gt; t.type">duplicate</a> <a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.setType" title="t.type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.treeWithNarrowedType">setType</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.freshExistentialSubtype" title="(tp: TreesAndTypesDomain.this.Type)TreesAndTypesDomain.this.Type">freshExistentialSubtype</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.t" title="TreesAndTypesDomain.this.Tree">t</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; ScalaLogic.this.global.Type">tpe</a><span class="delimiter">)</span>
            <a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug" title="ScalaLogic.this.debug.type">debug</a>.<a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Debugging.debug.patmat" title="(s: =&gt; String)Unit">patmat</a><span class="delimiter">(</span><span title="String(&quot;uniqued: &quot;)" class="string">&quot;uniqued: &quot;</span><span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><a href="../../../../Tuple3.scala.html#scala;Tuple3" title="(_1: TreesAndTypesDomain.this.Tree, _2: ScalaLogic.this.global.Type, _3: ScalaLogic.this.global.Type)(TreesAndTypesDomain.this.Tree, ScalaLogic.this.global.Type, ScalaLogic.this.global.Type)" class="delimiter">(</a><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.t" title="TreesAndTypesDomain.this.Tree">t</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.t" title="TreesAndTypesDomain.this.Tree">t</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; ScalaLogic.this.global.Type">tpe</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.treeWithNarrowedType" title="t.type">treeWithNarrowedType</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; ScalaLogic.this.global.Type">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.trees" title="=&gt; scala.collection.mutable.HashSet[TreesAndTypesDomain.this.Tree]">trees</a> <a href="../../../../collection/mutable/HashSet.scala.html#scala.collection.mutable;HashSet.+=(53f2a8289f)" title="(elem: TreesAndTypesDomain.this.Tree)scala.tools.nsc.transform.patmat.ScalaLogic.TreesAndTypesDomain.Const.trees.type">+=</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.treeWithNarrowedType" title="t.type">treeWithNarrowedType</a>
            <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree.treeWithNarrowedType" title="t.type">treeWithNarrowedType</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; ScalaLogic.this.global.Type">tpe</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    sealed abstract class <a title="class Const extends AnyRef" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const">Const</a> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const" title="TreesAndTypesDomain.this.Const" class="delimiter">{</a>
      def <a title="=&gt; TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const.tp">tp</a>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a>
      def <a title="=&gt; TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const.wideTp">wideTp</a>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a>

      def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const.isAny">isAny</a> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const.wideTp" title="=&gt; TreesAndTypesDomain.this.Type">wideTp</a> <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.=:=" title="(that: ScalaLogic.this.global.Type)Boolean">=:=</a> <a href="../../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.AnyTpe" title="=&gt; ScalaLogic.this.global.Type">AnyTpe</a>
      def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const.isValue">isValue</a>: <a href="../../../../Boolean.scala.html#scala;Boolean" title="Boolean">Boolean</a> <span class="comment">//= tp.isStable</span>

      <span class="comment">// note: use reference equality on Const since they're hash-consed (doing type equality all the time is too expensive)</span>
      <span class="comment">// the equals inherited from AnyRef does just this</span>
    <span class="delimiter">}</span>

    <span class="comment">// find most precise super-type of tp that is a class</span>
    <span class="comment">// we skip non-class types (singleton types, abstract types) so that we can</span>
    <span class="comment">// correctly compute how types relate in terms of the values they rule out</span>
    <span class="comment">// e.g., when we know some value must be of type T, can it still be of type S? (this is the positive formulation of what `excludes` on Const computes)</span>
    <span class="comment">// since we're talking values, there must have been a class involved in creating it, so rephrase our types in terms of classes</span>
    <span class="comment">// (At least conceptually: `true` is an instance of class `Boolean`)</span>
    private def <a title="(tp: TreesAndTypesDomain.this.Type)TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.widenToClass">widenToClass</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.widenToClass.tp">tp</a>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a><span class="delimiter">)</span>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a> =
      if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.widenToClass.tp" title="TreesAndTypesDomain.this.Type">tp</a>.<a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; ScalaLogic.this.global.Symbol">typeSymbol</a>.<a href="../../../../reflect/api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isClass" title="=&gt; Boolean">isClass</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.widenToClass.tp" title="TreesAndTypesDomain.this.Type">tp</a>
      else if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.widenToClass.tp" title="TreesAndTypesDomain.this.Type">tp</a>.<a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.baseClasses" title="=&gt; List[ScalaLogic.this.global.Symbol]">baseClasses</a>.<a href="../../../../collection/SeqLike.scala.html#scala.collection;SeqLike.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> sys.<a href="../../../../sys/package.scala.html#scala.sys.package.error" title="(message: String)Nothing">error</a><span class="delimiter">(</span><span title="String(&quot;Bad type: &quot;)" class="string">&quot;Bad type: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.widenToClass.tp" title="TreesAndTypesDomain.this.Type">tp</a><span class="delimiter">)</span>
      else <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.widenToClass.tp" title="TreesAndTypesDomain.this.Type">tp</a>.<a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.baseType" title="(clazz: ScalaLogic.this.global.Symbol)ScalaLogic.this.global.Type">baseType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.widenToClass.tp" title="TreesAndTypesDomain.this.Type">tp</a>.<a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.baseClasses" title="=&gt; List[ScalaLogic.this.global.Symbol]">baseClasses</a>.<a href="../../../../collection/IterableLike.scala.html#scala.collection;IterableLike.head" title="=&gt; ScalaLogic.this.global.Symbol">head</a><span class="delimiter">)</span>

    object <a title="TreesAndTypesDomain.this.TypeConst.type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.TypeConst">TypeConst</a> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;TypeConstExtractor" title="TreesAndTypesDomain.this.TypeConstExtractor">TypeConstExtractor</a> <span class="delimiter">{</span>
      def <a title="(tp: TreesAndTypesDomain.this.Type)TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.TypeConst.apply">apply</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.TypeConst.apply.tp">tp</a>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.TypeConst.apply.tp" title="TreesAndTypesDomain.this.Type">tp</a> <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.=:=" title="(that: ScalaLogic.this.global.Type)Boolean">=:=</a> <a href="../../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ConstantNull" title="=&gt; ScalaLogic.this.global.UniqueConstantType">ConstantNull</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.NullConst.readResolve" title="TreesAndTypesDomain.this.NullConst.type">NullConst</a>
        else if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.TypeConst.apply.tp" title="TreesAndTypesDomain.this.Type">tp</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;SingletonType" title="ScalaLogic.this.global.SingletonType">SingletonType</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst" title="TreesAndTypesDomain.this.ValueConst.type">ValueConst</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType" title="(tp: TreesAndTypesDomain.this.Type)TreesAndTypesDomain.this.Const">fromType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.TypeConst.apply.tp" title="TreesAndTypesDomain.this.Type">tp</a><span class="delimiter">)</span>
        else <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const" title="TreesAndTypesDomain.this.Const.type">Const</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique" title="(tp: TreesAndTypesDomain.this.Type, mkFresh: =&gt; TreesAndTypesDomain.this.Const)TreesAndTypesDomain.this.Const">unique</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.TypeConst.apply.tp" title="TreesAndTypesDomain.this.Type">tp</a>, new <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;TypeConst" title="TreesAndTypesDomain.this.TypeConst">TypeConst</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.TypeConst.apply.tp" title="TreesAndTypesDomain.this.Type">tp</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      def <a title="(c: TreesAndTypesDomain.this.TypeConst)Some[TreesAndTypesDomain.this.Type]" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.TypeConst.unapply">unapply</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.TypeConst" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.TypeConst.unapply.c">c</a>: <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;TypeConst" title="TreesAndTypesDomain.this.TypeConst">TypeConst</a><span class="delimiter">)</span>: <a href="../../../../Option.scala.html#scala;Some" title="Some[TreesAndTypesDomain.this.Type]">Some</a><span class="delimiter">[</span>Type<span class="delimiter">]</span> = <a href="../../../../Option.scala.html#scala;Some" title="(x: TreesAndTypesDomain.this.Type)Some[TreesAndTypesDomain.this.Type]">Some</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.TypeConst.unapply.c" title="TreesAndTypesDomain.this.TypeConst">c</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;TypeConst.tp" title="=&gt; TreesAndTypesDomain.this.Type">tp</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// corresponds to a type test that does not imply any value-equality (well, except for outer checks, which we don't model yet)</span>
    sealed class <a title="class TypeConst extends TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;TypeConst">TypeConst</a><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;TypeConst" title="TreesAndTypesDomain.this.TypeConst" class="delimiter">(</a>val <a title="TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;TypeConst.tp">tp</a>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a><span class="delimiter">)</span> extends <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const" title="TreesAndTypesDomain.this.Const">Const</a> <span class="delimiter">{</span>
      <a href="../../../../Predef.scala.html#scala.Predef.assert(65d7b4917f)" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="../../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;TypeConst.tp" title="=&gt; TreesAndTypesDomain.this.Type">tp</a> <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.=:=" title="(that: ScalaLogic.this.global.Type)Boolean">=:=</a> <a href="../../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ConstantNull" title="=&gt; ScalaLogic.this.global.UniqueConstantType">ConstantNull</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="comment">/*private[this] val id: Int = */</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const" title="TreesAndTypesDomain.this.Const.type">Const</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.nextTypeId" title="=&gt; Int">nextTypeId</a>

      val <a title="TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;TypeConst.wideTp">wideTp</a> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.widenToClass" title="(tp: TreesAndTypesDomain.this.Type)TreesAndTypesDomain.this.Type">widenToClass</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;TypeConst.tp" title="=&gt; TreesAndTypesDomain.this.Type">tp</a><span class="delimiter">)</span>
      def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;TypeConst.isValue">isValue</a> = false
      override def <a title="()String" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;TypeConst.toString">toString</a> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;TypeConst.tp" title="=&gt; TreesAndTypesDomain.this.Type">tp</a>.<a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.toString" title="()String">toString</a> <span class="comment">//+&quot;#&quot;+ id</span>
    <span class="delimiter">}</span>

    <span class="comment">// p is a unique type or a constant value</span>
    object <a title="TreesAndTypesDomain.this.ValueConst.type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst">ValueConst</a> extends <a href="#scala.tools.nsc.transform.patmat;Logic;PropositionalLogic;ValueConstExtractor" title="TreesAndTypesDomain.this.ValueConstExtractor">ValueConstExtractor</a> <span class="delimiter">{</span>
      def <a title="(tp: TreesAndTypesDomain.this.Type)TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType">fromType</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType.tp">tp</a>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <a href="../../../../Predef.scala.html#scala.Predef.assert(65d7b4917f)" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType.tp" title="TreesAndTypesDomain.this.Type">tp</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;SingletonType" title="ScalaLogic.this.global.SingletonType">SingletonType</a><span class="delimiter">]</span><span class="delimiter">)</span>
        val <a title="String" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType.toString">toString</a> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType.tp" title="TreesAndTypesDomain.this.Type">tp</a> match <span class="delimiter">{</span>
          case ConstantType<span class="delimiter">(</span><a title="ScalaLogic.this.global.Constant" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType.toString.c">c</a><span class="delimiter">)</span> =&gt; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType.toString.c" title="ScalaLogic.this.global.Constant">c</a>.<a href="../../../../reflect/internal/Constants.scala.html#scala.reflect.internal;Constants;Constant.escapedStringValue" title="=&gt; String">escapedStringValue</a>
          case _ if <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType.tp" title="TreesAndTypesDomain.this.Type">tp</a>.<a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; ScalaLogic.this.global.Symbol">typeSymbol</a>.<a href="../../../../reflect/api/Symbols.scala.html#scala.reflect.api;Symbols;SymbolApi.isModuleClass" title="=&gt; Boolean">isModuleClass</a> =&gt; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType.tp" title="TreesAndTypesDomain.this.Type">tp</a>.<a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.typeSymbol" title="=&gt; ScalaLogic.this.global.Symbol">typeSymbol</a>.<a href="../../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; ScalaLogic.this.global.Symbol#NameType">name</a>.<span title="()String">toString</span>
          case _ =&gt; <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType.tp" title="TreesAndTypesDomain.this.Type">tp</a>.<a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.toString" title="()String">toString</a>
        <span class="delimiter">}</span>
        <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const" title="TreesAndTypesDomain.this.Const.type">Const</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique" title="(tp: TreesAndTypesDomain.this.Type, mkFresh: =&gt; TreesAndTypesDomain.this.Const)TreesAndTypesDomain.this.Const">unique</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType.tp" title="TreesAndTypesDomain.this.Type">tp</a>, new <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;ValueConst" title="TreesAndTypesDomain.this.ValueConst">ValueConst</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType.tp" title="TreesAndTypesDomain.this.Type">tp</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType.tp" title="TreesAndTypesDomain.this.Type">tp</a>.<a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.widen" title="=&gt; ScalaLogic.this.global.Type">widen</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.fromType.toString" title="String">toString</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      def <a title="(p: TreesAndTypesDomain.this.Tree)TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply">apply</a><span class="delimiter">(</span><a title="TreesAndTypesDomain.this.Tree" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.p">p</a>: <a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree" title="TreesAndTypesDomain.this.Tree">Tree</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        val <a title="ScalaLogic.this.global.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.tp">tp</a> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.p" title="TreesAndTypesDomain.this.Tree">p</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.tpe" title="=&gt; ScalaLogic.this.global.Type">tpe</a>.<a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.normalize" title="=&gt; ScalaLogic.this.global.Type">normalize</a>
        if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.tp" title="ScalaLogic.this.global.Type">tp</a> <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.=:=" title="(that: ScalaLogic.this.global.Type)Boolean">=:=</a> <a href="../../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ConstantNull" title="=&gt; ScalaLogic.this.global.UniqueConstantType">ConstantNull</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.NullConst.readResolve" title="TreesAndTypesDomain.this.NullConst.type">NullConst</a>
        else <span class="delimiter">{</span>
          val <a title="TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.wideTp">wideTp</a> = <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.widenToClass" title="(tp: TreesAndTypesDomain.this.Type)TreesAndTypesDomain.this.Type">widenToClass</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.tp" title="ScalaLogic.this.global.Type">tp</a><span class="delimiter">)</span>

          val <a title="ScalaLogic.this.global.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.narrowTp">narrowTp</a> =
            if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.tp" title="ScalaLogic.this.global.Type">tp</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;SingletonType" title="ScalaLogic.this.global.SingletonType">SingletonType</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.tp" title="ScalaLogic.this.global.Type">tp</a>
            else <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.p" title="TreesAndTypesDomain.this.Tree">p</a> match <span class="delimiter">{</span>
              case Literal<span class="delimiter">(</span><a title="ScalaLogic.this.global.Constant" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.narrowTp.c">c</a><span class="delimiter">)</span> =&gt;
                if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.narrowTp.c" title="ScalaLogic.this.global.Constant">c</a>.<a href="../../../../reflect/internal/Constants.scala.html#scala.reflect.internal;Constants;Constant.tpe" title="=&gt; ScalaLogic.this.global.Type">tpe</a> <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.=:=" title="(that: ScalaLogic.this.global.Type)Boolean">=:=</a> <a href="../../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;ValueClassDefinitions.UnitTpe" title="=&gt; ScalaLogic.this.global.Type">UnitTpe</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.narrowTp.c" title="ScalaLogic.this.global.Constant">c</a>.<a href="../../../../reflect/internal/Constants.scala.html#scala.reflect.internal;Constants;Constant.tpe" title="=&gt; ScalaLogic.this.global.Type">tpe</a>
                else <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types.ConstantType.apply(682e31eef0)" title="(value: ScalaLogic.this.global.Constant)ScalaLogic.this.global.UniqueConstantType">ConstantType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.narrowTp.c" title="ScalaLogic.this.global.Constant">c</a><span class="delimiter">)</span>
              case Ident<span class="delimiter">(</span>_<span class="delimiter">)</span> if <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.p" title="TreesAndTypesDomain.this.Tree">p</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; ScalaLogic.this.global.Symbol">symbol</a>.<a href="../../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.isStable" title="=&gt; Boolean">isStable</a> =&gt;
                <span class="comment">// for Idents, can encode uniqueness of symbol as uniqueness of the corresponding singleton type</span>
                <span class="comment">// for Selects, which are handled by the next case, the prefix of the select varies independently of the symbol (see pos/virtpatmat_unreach_select.scala)</span>
                <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types.singleType" title="(pre: ScalaLogic.this.global.Type, sym: ScalaLogic.this.global.Symbol)ScalaLogic.this.global.Type">singleType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.tp" title="ScalaLogic.this.global.Type">tp</a>.<a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.prefix" title="=&gt; ScalaLogic.this.global.Type">prefix</a>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.p" title="TreesAndTypesDomain.this.Tree">p</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; ScalaLogic.this.global.Symbol">symbol</a><span class="delimiter">)</span>
              case _ =&gt;
                <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const" title="TreesAndTypesDomain.this.Const.type">Const</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.uniqueTpForTree" title="(t: TreesAndTypesDomain.this.Tree)TreesAndTypesDomain.this.Type">uniqueTpForTree</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.p" title="TreesAndTypesDomain.this.Tree">p</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>

          val <a title="String" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.toString">toString</a> =
            if <span class="delimiter">(</span><a href="PatternMatching.scala.html#scala.tools.nsc.transform.patmat;Interface.hasStableSymbol" title="(p: ScalaLogic.this.global.Tree)Boolean">hasStableSymbol</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.p" title="TreesAndTypesDomain.this.Tree">p</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.p" title="TreesAndTypesDomain.this.Tree">p</a>.<a href="../../../../reflect/internal/Trees.scala.html#scala.reflect.internal;Trees;Tree.symbol" title="=&gt; ScalaLogic.this.global.Symbol">symbol</a>.<a href="../../../../reflect/internal/Symbols.scala.html#scala.reflect.internal;Symbols;Symbol.name" title="=&gt; ScalaLogic.this.global.Symbol#NameType">name</a>.<span title="()String">toString</span> <span class="comment">// tp.toString</span>
            else <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.p" title="TreesAndTypesDomain.this.Tree">p</a>.<a href="../../../../reflect/api/Trees.scala.html#scala.reflect.api;Trees;TreeApi.toString" title="()String">toString</a> <span class="comment">//+&quot;#&quot;+ id</span>

          <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const" title="TreesAndTypesDomain.this.Const.type">Const</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.unique" title="(tp: TreesAndTypesDomain.this.Type, mkFresh: =&gt; TreesAndTypesDomain.this.Const)TreesAndTypesDomain.this.Const">unique</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.narrowTp" title="ScalaLogic.this.global.Type">narrowTp</a>, new <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;ValueConst" title="TreesAndTypesDomain.this.ValueConst">ValueConst</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.narrowTp" title="ScalaLogic.this.global.Type">narrowTp</a>, <a href="MatchAnalysis.scala.html#scala.tools.nsc.transform.patmat;TreeAndTypeAnalysis;CheckableTreeAndTypeAnalysis.checkableType" title="(tp: ScalaLogic.this.global.Type)ScalaLogic.this.global.Type">checkableType</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.wideTp" title="TreesAndTypesDomain.this.Type">wideTp</a><span class="delimiter">)</span>, <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.ValueConst.apply.toString" title="String">toString</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// must make wide type checkable so that it is comparable to types from TypeConst</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    sealed class <a title="class ValueConst extends TreesAndTypesDomain.this.Const" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;ValueConst">ValueConst</a><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;ValueConst" title="TreesAndTypesDomain.this.ValueConst" class="delimiter">(</a>val <a title="TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;ValueConst.tp">tp</a>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a>, val <a title="TreesAndTypesDomain.this.Type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;ValueConst.wideTp">wideTp</a>: <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type" title="TreesAndTypesDomain.this.Type">Type</a>, override val <a title="String" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;ValueConst.toString">toString</a>: <span title="String">String</span><span class="delimiter">)</span> extends <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const" title="TreesAndTypesDomain.this.Const">Const</a> <span class="delimiter">{</span>
      <span class="comment">// debug.patmat(&quot;VC&quot;+(tp, wideTp, toString))</span>
      <a href="../../../../Predef.scala.html#scala.Predef.assert(65d7b4917f)" title="(assertion: Boolean)Unit">assert</a><span class="delimiter">(</span><a href="../../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;ValueConst.tp" title="=&gt; TreesAndTypesDomain.this.Type">tp</a> <a href="../../../../reflect/internal/Types.scala.html#scala.reflect.internal;Types;Type.=:=" title="(that: ScalaLogic.this.global.Type)Boolean">=:=</a> <a href="../../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ConstantNull" title="=&gt; ScalaLogic.this.global.UniqueConstantType">ConstantNull</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// TODO: assert(!tp.isStable)</span>
      <span class="comment">/*private[this] val id: Int = */</span><a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const" title="TreesAndTypesDomain.this.Const.type">Const</a>.<a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.Const.nextValueId" title="=&gt; Int">nextValueId</a>
      def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;ValueConst.isValue">isValue</a> = true
    <span class="delimiter">}</span>

    case object <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.NullConst.productElement.x$1" title="TreesAndTypesDomain.this.NullConst.type" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.NullConst.readResolve">NullConst</a> extends <a href="#scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain;Const" title="TreesAndTypesDomain.this.Const">Const</a> <span class="delimiter">{</span>
      def <a title="=&gt; ScalaLogic.this.global.UniqueConstantType" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.NullConst.tp">tp</a>     = <a href="../../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ConstantNull" title="=&gt; ScalaLogic.this.global.UniqueConstantType">ConstantNull</a>
      def <a title="=&gt; ScalaLogic.this.global.UniqueConstantType" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.NullConst.wideTp">wideTp</a> = <a href="../../../../reflect/internal/Definitions.scala.html#scala.reflect.internal;Definitions;DefinitionsClass.ConstantNull" title="=&gt; ScalaLogic.this.global.UniqueConstantType">ConstantNull</a>

      def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.NullConst.isValue">isValue</a> = true
      override def <a title="()String" id="scala.tools.nsc.transform.patmat;ScalaLogic;TreesAndTypesDomain.NullConst.toString">toString</a> = <span title="String(&quot;null&quot;)" class="string">&quot;null&quot;</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
