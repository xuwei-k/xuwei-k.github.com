<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>scala/tools/nsc/transform/patmat/PatternExpander.scala</title>
        <script type="text/javascript" src="../../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/* NSC -- new Scala compiler
 * Copyright 2005-2013 LAMP/EPFL
 * @author  Paul Phillips
 */</span>

package scala
package tools
package nsc
package transform
package patmat

<span class="comment">/** An extractor returns: F1, F2, ..., Fi, opt[Seq[E] or E*]
 *        A case matches: P1, P2, ..., Pj, opt[Seq[E]]
 *          Put together: P1/F1, P2/F2, ... Pi/Fi, Pi+1/E, Pi+2/E, ... Pj/E, opt[Seq[E]]
 *
 *  Here Pm/Fi is the last pattern to match the fixed arity section.
 *
 *    productArity: the value of i, i.e. the number of non-sequence types in the extractor
 *    nonStarArity: the value of j, i.e. the number of non-star patterns in the case definition
 *    elementArity: j - i, i.e. the number of non-star patterns which must match sequence elements
 *       starArity: 1 or 0 based on whether there is a star (sequence-absorbing) pattern
 *      totalArity: nonStarArity + starArity, i.e. the number of patterns in the case definition
 *
 *  Note that productArity is a function only of the extractor, and
 *  nonStar/star/totalArity are all functions of the patterns. The key
 *  value for aligning and typing the patterns is elementArity, as it
 *  is derived from both sets of information.
 */</span>
trait <a title="trait PatternExpander[Pattern, Type] extends AnyRef" id="scala.tools.nsc.transform.patmat;PatternExpander">PatternExpander</a><span class="delimiter">[</span><a title="" id="scala.tools.nsc.transform.patmat;PatternExpander;Pattern">Pattern</a>, <a title="" id="scala.tools.nsc.transform.patmat;PatternExpander;Type">Type</a><span class="delimiter">]</span> <a href="../../../../Unit.scala.html#scala;Unit" title="Unit" class="delimiter">{</a>
  <span class="comment">/** You'll note we're not inside the cake. &quot;Pattern&quot; and &quot;Type&quot; are
   *  arbitrary types here, and NoPattern and NoType arbitrary values.
   */</span>
  def <a title="=&gt; Pattern" id="scala.tools.nsc.transform.patmat;PatternExpander.NoPattern">NoPattern</a>: <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Pattern" title="Pattern">Pattern</a>
  def <a title="=&gt; Type" id="scala.tools.nsc.transform.patmat;PatternExpander.NoType">NoType</a>: <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Type" title="Type">Type</a>

  <span class="comment">/** It's not optimal that we're carrying both sequence and repeated
   *  type here, but the implementation requires more unraveling before
   *  it can be avoided.
   *
   *  sequenceType is Seq[T], elementType is T, repeatedType is T*.
   */</span>
  sealed case class <a title="class Repeated extends AnyRef with Product with Serializable" id="scala.tools.nsc.transform.patmat;PatternExpander.Repeated.readResolve">Repeated</a><a href="../../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Type" id="scala.tools.nsc.transform.patmat;PatternExpander;Repeated.sequenceType">sequenceType</a>: <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Type" title="Type">Type</a>, <a title="Type" id="scala.tools.nsc.transform.patmat;PatternExpander;Repeated.elementType">elementType</a>: <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Type" title="Type">Type</a>, <a title="Type" id="scala.tools.nsc.transform.patmat;PatternExpander;Repeated.repeatedType">repeatedType</a>: <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Type" title="Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;PatternExpander;Repeated.exists">exists</a> = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Repeated.elementType" title="=&gt; Type">elementType</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.tools.nsc.transform.patmat;PatternExpander.NoType" title="=&gt; Type">NoType</a>

    def <a title="=&gt; List[Type]" id="scala.tools.nsc.transform.patmat;PatternExpander;Repeated.elementList">elementList</a>  = if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Repeated.exists" title="=&gt; Boolean">exists</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Repeated.elementType" title="=&gt; Type">elementType</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Type)List[Type]">::</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> else <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
    def <a title="=&gt; List[Type]" id="scala.tools.nsc.transform.patmat;PatternExpander;Repeated.sequenceList">sequenceList</a> = if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Repeated.exists" title="=&gt; Boolean">exists</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Repeated.sequenceType" title="=&gt; Type">sequenceType</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Type)List[Type]">::</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> else <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
    def <a title="=&gt; List[Type]" id="scala.tools.nsc.transform.patmat;PatternExpander;Repeated.repeatedList">repeatedList</a> = if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Repeated.exists" title="=&gt; Boolean">exists</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Repeated.repeatedType" title="=&gt; Type">repeatedType</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Type)List[Type]">::</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> else <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>

    override def <a title="()String" id="scala.tools.nsc.transform.patmat;PatternExpander;Repeated.toString">toString</a> = <a href="../../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span><span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Repeated.elementType" title="=&gt; Type">elementType</a><span class="delimiter">}</span><span title="String(&quot;*&quot;)" class="string">*&quot;</span>
  <span class="delimiter">}</span>
  object <a title="PatternExpander.this.NoRepeated.type" id="scala.tools.nsc.transform.patmat;PatternExpander.NoRepeated.readResolve">NoRepeated</a> extends <a href="#scala.tools.nsc.transform.patmat;PatternExpander.Repeated.readResolve" title="PatternExpander.this.Repeated">Repeated</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander.NoType" title="=&gt; Type">NoType</a>, <a href="#scala.tools.nsc.transform.patmat;PatternExpander.NoType" title="=&gt; Type">NoType</a>, <a href="#scala.tools.nsc.transform.patmat;PatternExpander.NoType" title="=&gt; Type">NoType</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    override def <a title="()String" id="scala.tools.nsc.transform.patmat;PatternExpander.NoRepeated.toString">toString</a> = <span title="String(&quot;&lt;none&gt;&quot;)" class="string">&quot;&lt;none&gt;&quot;</span>
  <span class="delimiter">}</span>

  final case class <a title="class Patterns extends AnyRef with Product with Serializable" id="scala.tools.nsc.transform.patmat;PatternExpander.Patterns.readResolve">Patterns</a><a href="../../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="List[Pattern]" id="scala.tools.nsc.transform.patmat;PatternExpander;Patterns.fixed">fixed</a>: <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Pattern]">List</a><span class="delimiter">[</span>Pattern<span class="delimiter">]</span>, <a title="Pattern" id="scala.tools.nsc.transform.patmat;PatternExpander;Patterns.star">star</a>: <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Pattern" title="Pattern">Pattern</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;PatternExpander;Patterns.hasStar">hasStar</a>      = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.star" title="=&gt; Pattern">star</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.tools.nsc.transform.patmat;PatternExpander.NoPattern" title="=&gt; Pattern">NoPattern</a>
    def <a title="=&gt; Int" id="scala.tools.nsc.transform.patmat;PatternExpander;Patterns.starArity">starArity</a>    = if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.hasStar" title="=&gt; Boolean">hasStar</a><span class="delimiter">)</span> <span title="Int(1)" class="int">1</span> else <span title="Int(0)" class="int">0</span>
    def <a title="=&gt; Int" id="scala.tools.nsc.transform.patmat;PatternExpander;Patterns.nonStarArity">nonStarArity</a> = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.fixed" title="=&gt; List[Pattern]">fixed</a>.<a href="../../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.length" title="=&gt; Int">length</a>
    def <a title="=&gt; Int" id="scala.tools.nsc.transform.patmat;PatternExpander;Patterns.totalArity">totalArity</a>   = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.nonStarArity" title="=&gt; Int">nonStarArity</a> <a href="../../../../Int.scala.html#scala;Int.+(1409840560)" title="(x: Int)Int">+</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.starArity" title="=&gt; Int">starArity</a>
    def <a title="=&gt; List[Pattern]" id="scala.tools.nsc.transform.patmat;PatternExpander;Patterns.starPatterns">starPatterns</a> = if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.hasStar" title="=&gt; Boolean">hasStar</a><span class="delimiter">)</span> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.star" title="=&gt; Pattern">star</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.::" title="(x: Pattern)List[Pattern]">::</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> else <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>
    def <a title="=&gt; List[Pattern]" id="scala.tools.nsc.transform.patmat;PatternExpander;Patterns.all">all</a>          = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.fixed" title="=&gt; List[Pattern]">fixed</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.:::" title="(prefix: List[Pattern])List[Pattern]">:::</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.starPatterns" title="=&gt; List[Pattern]">starPatterns</a>

    override def <a title="()String" id="scala.tools.nsc.transform.patmat;PatternExpander;Patterns.toString">toString</a> = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.all" title="=&gt; List[Pattern]">all</a> <a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** An 'extractor' can be a case class or an unapply or unapplySeq method.
   *  Decoding what it is that they extract takes place before we arrive here,
   *  so that this class can concentrate only on the relationship between
   *  patterns and types.
   *
   *  In a case class, the class is the unextracted type and the fixed and
   *  repeated types are derived from its constructor parameters.
   *
   *  In an unapply, this is reversed: the parameter to the unapply is the
   *  unextracted type, and the other types are derived based on the return
   *  type of the unapply method.
   *
   *  In other words, this case class and unapply are encoded the same:
   *
   *    case class Foo(x: Int, y: Int, zs: Char*)
   *    def unapplySeq(x: Foo): Option[(Int, Int, Seq[Char])]
   *
   *  Both are Extractor(Foo, Int :: Int :: Nil, Repeated(Seq[Char], Char, Char*))
   *
   *  @param  whole     The type in its unextracted form
   *  @param  fixed     The non-sequence types which are extracted
   *  @param  repeated  The sequence type which is extracted
   */</span>
  final case class <a title="class Extractor extends AnyRef with Product with Serializable" id="scala.tools.nsc.transform.patmat;PatternExpander.Extractor.readResolve">Extractor</a><a href="../../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Type" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.whole">whole</a>: <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Type" title="Type">Type</a>, <a title="List[Type]" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.fixed">fixed</a>: <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List" title="List[Type]">List</a><span class="delimiter">[</span>Type<span class="delimiter">]</span>, <a title="PatternExpander.this.Repeated" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.repeated">repeated</a>: <a href="#scala.tools.nsc.transform.patmat;PatternExpander.Repeated.readResolve" title="PatternExpander.this.Repeated">Repeated</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <a href="../../../../Predef.scala.html#scala.Predef.require(a2f0e4a061)" title="(requirement: Boolean, message: =&gt; Any)Unit">require</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.whole" title="=&gt; Type">whole</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#scala.tools.nsc.transform.patmat;PatternExpander.NoType" title="=&gt; Type">NoType</a>, <a href="../../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;expandTypes(&quot;)">expandTypes($</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.whole" title="=&gt; Type">whole</a><span title="String(&quot;, &quot;)">, $</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.fixed" title="=&gt; List[Type]">fixed</a><span title="String(&quot;, &quot;)">, $</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.repeated" title="=&gt; PatternExpander.this.Repeated">repeated</a><span title="String(&quot;)&quot;)" class="string">)&quot;</span><span class="delimiter">)</span>

    def <a title="=&gt; Int" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.productArity">productArity</a> = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.fixed" title="=&gt; List[Type]">fixed</a>.<a href="../../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.length" title="=&gt; Int">length</a>
    def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.hasSeq">hasSeq</a>       = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.repeated" title="=&gt; PatternExpander.this.Repeated">repeated</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Repeated.exists" title="=&gt; Boolean">exists</a>
    def <a title="=&gt; Type" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.elementType">elementType</a>  = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.repeated" title="=&gt; PatternExpander.this.Repeated">repeated</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Repeated.elementType" title="=&gt; Type">elementType</a>
    def <a title="=&gt; Type" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.sequenceType">sequenceType</a> = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.repeated" title="=&gt; PatternExpander.this.Repeated">repeated</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Repeated.sequenceType" title="=&gt; Type">sequenceType</a>
    def <a title="=&gt; List[Type]" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.allTypes">allTypes</a>     = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.fixed" title="=&gt; List[Type]">fixed</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.:::" title="(prefix: List[Type])List[Type]">:::</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.repeated" title="=&gt; PatternExpander.this.Repeated">repeated</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Repeated.sequenceList" title="=&gt; List[Type]">sequenceList</a>
    def <a title="=&gt; List[Type]" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.varargsTypes">varargsTypes</a> = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.fixed" title="=&gt; List[Type]">fixed</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.:::" title="(prefix: List[Type])List[Type]">:::</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.repeated" title="=&gt; PatternExpander.this.Repeated">repeated</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Repeated.repeatedList" title="=&gt; List[Type]">repeatedList</a>
    def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.isErroneous">isErroneous</a>  = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.allTypes" title="=&gt; List[Type]">allTypes</a> <a href="../../../../collection/LinearSeqOptimized.scala.html#scala.collection;LinearSeqOptimized.contains" title="(elem: Type)Boolean">contains</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander.NoType" title="=&gt; Type">NoType</a>

    private def <a title="=&gt; List[String]" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.typeStrings">typeStrings</a> = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.fixed" title="=&gt; List[Type]">fixed</a>.<a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Type =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[List[Type],String,List[String]])List[String]">map</a><a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.List.canBuildFrom" title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,String,List[String]]" class="delimiter">(</a><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.typeStrings.x$9.$anonfun.x$8" title="Type">_</a><span class="delimiter">)</span> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.:::" title="(prefix: List[String])List[String]">:::</a> <span class="delimiter">(</span> if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.hasSeq" title="=&gt; Boolean">hasSeq</a><span class="delimiter">)</span> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.List.apply" title="(xs: String*)List[String]">List</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.repeated" title="=&gt; PatternExpander.this.Repeated">repeated</a><span class="delimiter">)</span> else <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> <span class="delimiter">)</span>

    def <a title="=&gt; String" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.offeringString">offeringString</a> = if <span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.isErroneous" title="=&gt; Boolean">isErroneous</a><span class="delimiter">)</span> <span title="String(&quot;&lt;error&gt;&quot;)" class="string">&quot;&lt;error&gt;&quot;</span> else <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.typeStrings" title="=&gt; List[String]">typeStrings</a> match <span class="delimiter">{</span>
      case <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a>       =&gt; <span title="String(&quot;Boolean&quot;)" class="string">&quot;Boolean&quot;</span>
      case <a title="String" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.offeringString.tp">tp</a> :: <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable.Nil" title="scala.collection.immutable.Nil.type">Nil</a> =&gt; <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.offeringString.tp" title="String">tp</a>
      case <a title="List[String]" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.offeringString.tps">tps</a>       =&gt; <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.offeringString.tps" title="List[String]">tps</a>.<a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(581ef61a02)" title="(start: String, sep: String, end: String)String">mkString</a><span class="delimiter">(</span><span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    override def <a title="()String" id="scala.tools.nsc.transform.patmat;PatternExpander;Extractor.toString">toString</a> = <a href="../../../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%s =&gt; %s&quot;</a>.<a href="../../../../collection/immutable/StringLike.scala.html#scala.collection.immutable;StringLike.format" title="(args: Any*)String">format</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.whole" title="=&gt; Type">whole</a>, <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.offeringString" title="=&gt; String">offeringString</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  final case class <a title="class TypedPat extends AnyRef with Product with Serializable" id="scala.tools.nsc.transform.patmat;PatternExpander.TypedPat.readResolve">TypedPat</a><a href="../../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="Pattern" id="scala.tools.nsc.transform.patmat;PatternExpander;TypedPat.pat">pat</a>: <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Pattern" title="Pattern">Pattern</a>, <a title="Type" id="scala.tools.nsc.transform.patmat;PatternExpander;TypedPat.tpe">tpe</a>: <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Type" title="Type">Type</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    override def <a title="()String" id="scala.tools.nsc.transform.patmat;PatternExpander;TypedPat.toString">toString</a> = <a href="../../../../StringContext.scala.html#scala;StringContext.s" title="(args: Any*)String">s</a>&quot;<span title="String(&quot;&quot;)">$</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;TypedPat.pat" title="=&gt; Pattern">pat</a><span title="String(&quot;: &quot;)">: $</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;TypedPat.tpe" title="=&gt; Type">tpe</a><span title="String(&quot;&quot;)" class="string">&quot;</span>
  <span class="delimiter">}</span>

  <span class="comment">/** If elementArity is...
   *    0: A perfect match between extractor and the fixed patterns.
   *       If there is a star pattern it will match any sequence.
   *  &gt; 0: There are more patterns than products. There will have to be a
   *       sequence which can populate at least &lt;elementArity&gt; patterns.
   *  &lt; 0: There are more products than patterns: compile time error.
   */</span>
  final case class <a title="class Aligned extends AnyRef with Product with Serializable" id="scala.tools.nsc.transform.patmat;PatternExpander.Aligned.readResolve">Aligned</a><a href="../../../../Product.scala.html#scala;Product" title="Product" class="delimiter">(</a><a title="PatternExpander.this.Patterns" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.patterns">patterns</a>: <a href="#scala.tools.nsc.transform.patmat;PatternExpander.Patterns.readResolve" title="PatternExpander.this.Patterns">Patterns</a>, <a title="PatternExpander.this.Extractor" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.extractor">extractor</a>: <a href="#scala.tools.nsc.transform.patmat;PatternExpander.Extractor.readResolve" title="PatternExpander.this.Extractor">Extractor</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="=&gt; Int" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.elementArity">elementArity</a> = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.patterns" title="=&gt; PatternExpander.this.Patterns">patterns</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.nonStarArity" title="=&gt; Int">nonStarArity</a> <a href="../../../../Int.scala.html#scala;Int.-(1409840560)" title="(x: Int)Int">-</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.productArity" title="=&gt; Int">productArity</a>
    def <a title="=&gt; Int" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.productArity">productArity</a> = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.extractor" title="=&gt; PatternExpander.this.Extractor">extractor</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.productArity" title="=&gt; Int">productArity</a>
    def <a title="=&gt; Int" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.starArity">starArity</a>    = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.patterns" title="=&gt; PatternExpander.this.Patterns">patterns</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.starArity" title="=&gt; Int">starArity</a>
    def <a title="=&gt; Int" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.totalArity">totalArity</a>   = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.patterns" title="=&gt; PatternExpander.this.Patterns">patterns</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.totalArity" title="=&gt; Int">totalArity</a>

    def <a title="=&gt; Type" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.wholeType">wholeType</a>            = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.extractor" title="=&gt; PatternExpander.this.Extractor">extractor</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.whole" title="=&gt; Type">whole</a>
    def <a title="=&gt; Type" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.sequenceType">sequenceType</a>         = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.extractor" title="=&gt; PatternExpander.this.Extractor">extractor</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.sequenceType" title="=&gt; Type">sequenceType</a>
    def <a title="=&gt; List[Type]" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.productTypes">productTypes</a>         = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.extractor" title="=&gt; PatternExpander.this.Extractor">extractor</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.fixed" title="=&gt; List[Type]">fixed</a>
    def <a title="=&gt; List[Type]" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.extractedTypes">extractedTypes</a>       = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.extractor" title="=&gt; PatternExpander.this.Extractor">extractor</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.allTypes" title="=&gt; List[Type]">allTypes</a>
    def <a title="=&gt; List[PatternExpander.this.TypedPat]" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.typedNonStarPatterns">typedNonStarPatterns</a> = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.products" title="=&gt; List[PatternExpander.this.TypedPat]">products</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.:::" title="(prefix: List[PatternExpander.this.TypedPat])List[PatternExpander.this.TypedPat]">:::</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.elements" title="=&gt; List[PatternExpander.this.TypedPat]">elements</a>
    def <a title="=&gt; List[PatternExpander.this.TypedPat]" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.typedPatterns">typedPatterns</a>        = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.typedNonStarPatterns" title="=&gt; List[PatternExpander.this.TypedPat]">typedNonStarPatterns</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.:::" title="(prefix: List[PatternExpander.this.TypedPat])List[PatternExpander.this.TypedPat]">:::</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.stars" title="=&gt; List[PatternExpander.this.TypedPat]">stars</a>

    def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.isBool">isBool</a>   = <a href="../../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.isSeq" title="=&gt; Boolean">isSeq</a> <a href="../../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.productArity" title="=&gt; Int">productArity</a> <a href="../../../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(0)" class="int">0</span>
    def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.isSingle">isSingle</a> = <a href="../../../../Boolean.scala.html#scala;Boolean.unary_!" title="=&gt; Boolean">!</a><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.isSeq" title="=&gt; Boolean">isSeq</a> <a href="../../../../Boolean.scala.html#scala;Boolean.&&" title="(x: Boolean)Boolean">&amp;&amp;</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.totalArity" title="=&gt; Int">totalArity</a> <a href="../../../../Int.scala.html#scala;Int.==(5f58a84eb3)" title="(x: Int)Boolean">==</a> <span title="Int(1)" class="int">1</span>
    def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.isStar">isStar</a>   = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.patterns" title="=&gt; PatternExpander.this.Patterns">patterns</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.hasStar" title="=&gt; Boolean">hasStar</a>
    def <a title="=&gt; Boolean" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.isSeq">isSeq</a>    = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.extractor" title="=&gt; PatternExpander.this.Extractor">extractor</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.hasSeq" title="=&gt; Boolean">hasSeq</a>

    private def <a title="(pat: Pattern)PatternExpander.this.TypedPat" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.typedAsElement">typedAsElement</a><span class="delimiter">(</span><a title="Pattern" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.typedAsElement.pat">pat</a>: <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Pattern" title="Pattern">Pattern</a><span class="delimiter">)</span>  = <a href="#scala.tools.nsc.transform.patmat;PatternExpander.TypedPat.readResolve" title="(pat: Pattern, tpe: Type)PatternExpander.this.TypedPat">TypedPat</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.typedAsElement.pat" title="Pattern">pat</a>, <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.extractor" title="=&gt; PatternExpander.this.Extractor">extractor</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.elementType" title="=&gt; Type">elementType</a><span class="delimiter">)</span>
    private def <a title="(pat: Pattern)PatternExpander.this.TypedPat" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.typedAsSequence">typedAsSequence</a><span class="delimiter">(</span><a title="Pattern" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.typedAsSequence.pat">pat</a>: <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Pattern" title="Pattern">Pattern</a><span class="delimiter">)</span> = <a href="#scala.tools.nsc.transform.patmat;PatternExpander.TypedPat.readResolve" title="(pat: Pattern, tpe: Type)PatternExpander.this.TypedPat">TypedPat</a><span class="delimiter">(</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.typedAsSequence.pat" title="Pattern">pat</a>, <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.extractor" title="=&gt; PatternExpander.this.Extractor">extractor</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Extractor.sequenceType" title="=&gt; Type">sequenceType</a><span class="delimiter">)</span>
    private def <a title="=&gt; List[Pattern]" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.productPats">productPats</a> = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.patterns" title="=&gt; PatternExpander.this.Patterns">patterns</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.fixed" title="=&gt; List[Pattern]">fixed</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.take" title="(n: Int)List[Pattern]">take</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.productArity" title="=&gt; Int">productArity</a>
    private def <a title="=&gt; List[Pattern]" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.elementPats">elementPats</a> = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.patterns" title="=&gt; PatternExpander.this.Patterns">patterns</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.fixed" title="=&gt; List[Pattern]">fixed</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.drop" title="(n: Int)List[Pattern]">drop</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.productArity" title="=&gt; Int">productArity</a>
    private def <a title="=&gt; List[PatternExpander.this.TypedPat]" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.products">products</a>    = <a href="../../../../Predef.scala.html#scala.Predef.tuple2ToZippedOps" title="(x: (List[Pattern], List[Type]))runtime.Tuple2Zipped.Ops[List[Pattern],List[Type]]" class="delimiter">(</a><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.productPats" title="=&gt; List[Pattern]">productPats</a>, <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.productTypes" title="=&gt; List[Type]">productTypes</a><span class="delimiter">)</span>.<a href="../../../../runtime/Tuple2Zipped.scala.html#scala.runtime.Tuple2Zipped;Ops.zipped" title="(implicit w1: List[Pattern] =&gt; scala.collection.TraversableLike[Pattern,List[Pattern]], implicit w2: List[Type] =&gt; scala.collection.IterableLike[Type,List[Type]])scala.runtime.Tuple2Zipped[Pattern,List[Pattern],Type,List[Type]]">zipped</a> <a href="../../../../runtime/Tuple2Zipped.scala.html#scala.runtime;Tuple2Zipped.map" title="(f: (Pattern, Type) =&gt; PatternExpander.this.TypedPat)(implicit cbf: scala.collection.generic.CanBuildFrom[List[Pattern],PatternExpander.this.TypedPat,List[PatternExpander.this.TypedPat]])List[PatternExpander.this.TypedPat]">map</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander.TypedPat.readResolve" title="PatternExpander.this.TypedPat.type">TypedPat</a>
    private def <a title="=&gt; List[PatternExpander.this.TypedPat]" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.elements">elements</a>    = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.elementPats" title="=&gt; List[Pattern]">elementPats</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Pattern =&gt; PatternExpander.this.TypedPat)(implicit bf: scala.collection.generic.CanBuildFrom[List[Pattern],PatternExpander.this.TypedPat,List[PatternExpander.this.TypedPat]])List[PatternExpander.this.TypedPat]">map</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.typedAsElement" title="(pat: Pattern)PatternExpander.this.TypedPat">typedAsElement</a>
    private def <a title="=&gt; List[PatternExpander.this.TypedPat]" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.stars">stars</a>       = <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.patterns" title="=&gt; PatternExpander.this.Patterns">patterns</a>.<a href="#scala.tools.nsc.transform.patmat;PatternExpander;Patterns.starPatterns" title="=&gt; List[Pattern]">starPatterns</a> <a href="../../../../collection/immutable/List.scala.html#scala.collection.immutable;List.map" title="(f: Pattern =&gt; PatternExpander.this.TypedPat)(implicit bf: scala.collection.generic.CanBuildFrom[List[Pattern],PatternExpander.this.TypedPat,List[PatternExpander.this.TypedPat]])List[PatternExpander.this.TypedPat]">map</a> <a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.typedAsSequence" title="(pat: Pattern)PatternExpander.this.TypedPat">typedAsSequence</a>

    override def <a title="()String" id="scala.tools.nsc.transform.patmat;PatternExpander;Aligned.toString">toString</a> = <a href="../../../../Predef.scala.html#scala.Predef.augmentString" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">s</a>&quot;&quot;&quot;<span title="String(&quot;\n      |Aligned {\n      |   patterns  &quot;)">
      |Aligned {
      |   patterns  $</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.patterns" title="=&gt; PatternExpander.this.Patterns">patterns</a><span title="String(&quot;\n      |  extractor  &quot;)">
      |  extractor  $</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.extractor" title="=&gt; PatternExpander.this.Extractor">extractor</a><span title="String(&quot;\n      |    arities  &quot;)">
      |    arities  $</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.productArity" title="=&gt; Int">productArity</a><span title="String(&quot;/&quot;)">/$</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.elementArity" title="=&gt; Int">elementArity</a><span title="String(&quot;/&quot;)">/$</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.starArity" title="=&gt; Int">starArity</a><span title="String(&quot;  // product/element/star\n      |      typed  &quot;)">  // product/element/star
      |      typed  $</span><span class="delimiter">{</span><a href="#scala.tools.nsc.transform.patmat;PatternExpander;Aligned.typedPatterns" title="=&gt; List[PatternExpander.this.TypedPat]">typedPatterns</a> <a href="../../../../collection/TraversableOnce.scala.html#scala.collection;TraversableOnce.mkString(f5d728d244)" title="(sep: String)String">mkString</a> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">}</span><span title="String(&quot;\n      |}&quot;)" class="string">
      |}&quot;&quot;&quot;</span>.<a href="../../../../collection/immutable/StringLike.scala.html#scala.collection.immutable;StringLike.stripMargin(3bf7c90be7)" title="=&gt; String">stripMargin</a>.<span title="()String">trim</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
