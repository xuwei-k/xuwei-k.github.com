<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>core/monocle/std/IMap.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> monocle.std

<span class="keyword">import</span> monocle.function._
<span class="keyword">import</span> monocle.<span class="delimiter">{</span>Lens, Prism, Traversal<span class="delimiter">}</span>

<span class="keyword">import</span> scalaz.std.<span title="scalaz.std.list.type">list</span>._
<span class="keyword">import</span> scalaz.syntax.std.<span title="scalaz.syntax.std.option.type">option</span>._
<span class="keyword">import</span> scalaz.syntax.<span title="scalaz.syntax.traverse.type">traverse</span>._
<span class="keyword">import</span> scalaz.<span class="delimiter">{</span>Applicative, Maybe, Order, ==&gt;&gt;<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="monocle.std.imap.type" id="monocle.std.imap">imap</a> <a href="#monocle.std.imap" title="monocle.std.imap.type" class="keyword">extends</a> <a href="#monocle.std;IMapInstances" title="monocle.std.IMapInstances">IMapInstances</a>

<span class="keyword">trait</span> <a title="trait IMapInstances extends AnyRef" id="monocle.std;IMapInstances">IMapInstances</a> <span title="Unit" class="delimiter">{</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V]=&gt; monocle.function.Empty[scalaz.==&gt;&gt;[K,V]]" id="monocle.std;IMapInstances.iMapEmpty">iMapEmpty</a><span class="delimiter">[</span><a title="" id="monocle.std;IMapInstances.iMapEmpty;K">K</a>, <a title="" id="monocle.std;IMapInstances.iMapEmpty;V">V</a><span class="delimiter">]</span>: <a href="../function/Empty.scala.html#monocle.function;Empty" title="monocle.function.Empty[scalaz.==&gt;&gt;[K,V]]">Empty</a><span class="delimiter">[</span>K ==&gt;&gt; V<span class="delimiter">]</span> = <a href="#monocle.std;IMapInstances.iMapEmpty;$anon" title="monocle.function.Empty[scalaz.==&gt;&gt;[K,V]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with monocle.function.Empty[scalaz.==&gt;&gt;[K,V]]" id="monocle.std;IMapInstances.iMapEmpty;$anon">Empty</a><span class="delimiter">[</span>K ==&gt;&gt; V<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; monocle.Prism[scalaz.==&gt;&gt;[K,V],Unit]" id="monocle.std;IMapInstances.iMapEmpty;$anon.empty">empty</a> = <a href="../Prism.scala.html#monocle.Prism.apply" title="[S, A](_getMaybe: S =&gt; scalaz.Maybe[A])(_reverseGet: A =&gt; S)monocle.Prism[S,A]">Prism</a><span title="(_getMaybe: scalaz.==&gt;&gt;[K,V] =&gt; scalaz.Maybe[Unit])(_reverseGet: Unit =&gt; scalaz.==&gt;&gt;[K,V])monocle.Prism[scalaz.==&gt;&gt;[K,V],Unit]" class="delimiter">[</span>K <span title="scalaz.==&gt;&gt;[K,V]">==&gt;&gt;</span> V, <span title="Unit">Unit</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.==&gt;&gt;[K,V]" id="monocle.std;IMapInstances.iMapEmpty;$anon.empty.$anonfun.m">m</a> =&gt; <span title="scalaz.Maybe[Unit]" class="keyword">if</span><span class="delimiter">(</span><a href="#monocle.std;IMapInstances.iMapEmpty;$anon.empty.$anonfun.m" title="scalaz.==&gt;&gt;[K,V]">m</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="scalaz.Maybe.type">Maybe</span>.<span title="(a: Unit)scalaz.Maybe[Unit]">just</span><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="scalaz.Maybe.type">Maybe</span>.<span title="scalaz.Maybe[Unit]">empty</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Unit" id="monocle.std;IMapInstances.iMapEmpty;$anon.empty.$anonfun.x$1">_</a> =&gt; <span title="scalaz.==&gt;&gt;.type">==&gt;&gt;</span>.<span title="scalaz.==&gt;&gt;[K,V]">empty</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V](implicit evidence$1: scalaz.Order[K])monocle.function.At[scalaz.==&gt;&gt;[K,V],K,V]" id="monocle.std;IMapInstances.atIMap">atIMap</a><span class="delimiter">[</span><a title="" id="monocle.std;IMapInstances.atIMap;K">K</a>: Order, <a title="" id="monocle.std;IMapInstances.atIMap;V">V</a><span class="delimiter">]</span>: <a href="../function/At.scala.html#monocle.function;At" title="monocle.function.At[scalaz.==&gt;&gt;[K,V],K,V]">At</a><span class="delimiter">[</span>K ==&gt;&gt; V, K, V<span class="delimiter">]</span> = <a href="#monocle.std;IMapInstances.atIMap;$anon" title="monocle.function.At[scalaz.==&gt;&gt;[K,V],K,V]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with monocle.function.At[scalaz.==&gt;&gt;[K,V],K,V]" id="monocle.std;IMapInstances.atIMap;$anon">At</a><span class="delimiter">[</span>K ==&gt;&gt; V, K, V<span class="delimiter">]</span><span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(i: K)monocle.Lens[scalaz.==&gt;&gt;[K,V],scalaz.Maybe[V]]" id="monocle.std;IMapInstances.atIMap;$anon.at">at</a><span class="delimiter">(</span><a title="K" id="monocle.std;IMapInstances.atIMap;$anon.at.i">i</a>: <a href="#monocle.std;IMapInstances.atIMap;K" title="K">K</a><span class="delimiter">)</span> = <a href="../Lens.scala.html#monocle.Lens.apply" title="(get: scalaz.==&gt;&gt;[K,V] =&gt; scalaz.Maybe[V])(set: scalaz.Maybe[V] =&gt; (scalaz.==&gt;&gt;[K,V] =&gt; scalaz.==&gt;&gt;[K,V]))monocle.Lens[scalaz.==&gt;&gt;[K,V],scalaz.Maybe[V]]">Lens</a><span class="delimiter">{</span>m: <span title="scalaz.==&gt;&gt;[K,V]">==&gt;&gt;</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> =&gt; <a href="#monocle.std;IMapInstances.atIMap;$anon.at.$anonfun.m" title="scalaz.==&gt;&gt;[K,V]">m</a>.<span title="(k: K)(implicit n: scalaz.Order[K])Option[V]">lookup</span><a href="#monocle.std;IMapInstances.atIMap.evidence$1" title="(a: Option[V])scalaz.syntax.std.OptionOps[V]" class="delimiter">(</a><a href="#monocle.std;IMapInstances.atIMap;$anon.at.i" title="K">i</a><span class="delimiter">)</span>.<span title="=&gt; scalaz.Maybe[V]">toMaybe</span><span class="delimiter">}</span><span class="delimiter">(</span><a title="scalaz.Maybe[V]" id="monocle.std;IMapInstances.atIMap;$anon.at.$anonfun.maybeV">maybeV</a> =&gt; <a title="scalaz.==&gt;&gt;[K,V]" id="monocle.std;IMapInstances.atIMap;$anon.at.$anonfun.$anonfun.map">map</a> =&gt; <a href="#monocle.std;IMapInstances.atIMap;$anon.at.$anonfun.maybeV" title="scalaz.Maybe[V]">maybeV</a>.<span title="(f: V =&gt; scalaz.==&gt;&gt;[K,V], b: =&gt; scalaz.==&gt;&gt;[K,V])scalaz.==&gt;&gt;[K,V]">cata</span><span class="delimiter">(</span><a title="V" id="monocle.std;IMapInstances.atIMap;$anon.at.$anonfun.$anonfun.$anonfun.v">v</a> =&gt; <a href="#monocle.std;IMapInstances.atIMap;$anon.at.$anonfun.$anonfun.map" title="scalaz.==&gt;&gt;[K,V]">map</a> <a href="#monocle.std;IMapInstances.atIMap.evidence$1" title="(a: (K, V))(implicit o: scalaz.Order[K])scalaz.==&gt;&gt;[K,V]">+</a> <span class="delimiter">(</span><a href="#monocle.std;IMapInstances.atIMap;$anon.at.i" title="(x: K)ArrowAssoc[K]">i</a> <span title="(y: V)(K, V)">-&gt;</span> <a href="#monocle.std;IMapInstances.atIMap;$anon.at.$anonfun.$anonfun.$anonfun.v" title="V">v</a><span class="delimiter">)</span>, <a href="#monocle.std;IMapInstances.atIMap;$anon.at.$anonfun.$anonfun.map" title="scalaz.==&gt;&gt;[K,V]">map</a> <a href="#monocle.std;IMapInstances.atIMap.evidence$1" title="(k: K)(implicit o: scalaz.Order[K])scalaz.==&gt;&gt;[K,V]">-</a> <a href="#monocle.std;IMapInstances.atIMap;$anon.at.i" title="K">i</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V]=&gt; monocle.function.Each[scalaz.==&gt;&gt;[K,V],V]" id="monocle.std;IMapInstances.iMapEach">iMapEach</a><span class="delimiter">[</span><a title="" id="monocle.std;IMapInstances.iMapEach;K">K</a>, <a title="" id="monocle.std;IMapInstances.iMapEach;V">V</a><span class="delimiter">]</span>: <a href="../function/Each.scala.html#monocle.function;Each" title="monocle.function.Each[scalaz.==&gt;&gt;[K,V],V]">Each</a><span class="delimiter">[</span>K ==&gt;&gt; V, V<span class="delimiter">]</span> = <a href="../function/Each.scala.html#monocle.function.Each" title="monocle.function.Each.type">Each</a>.<a href="../function/Each.scala.html#monocle.function;EachFunctions.traverseEach" title="[S[_], A](implicit evidence$1: scalaz.Traverse[S])monocle.function.Each[S[A],A]">traverseEach</a><span title="(implicit evidence$1: scalaz.Traverse[[X_kp1]scalaz.==&gt;&gt;[K,X_kp1]])monocle.function.Each[scalaz.==&gt;&gt;[K,V],V]" class="delimiter">[</span>==&gt;&gt;<span class="delimiter">[</span>K, ?<span class="delimiter">]</span>, <a href="#monocle.std;IMapInstances.iMapEach;V" title="V">V</a><span class="delimiter">]</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V](implicit evidence$2: scalaz.Order[K])monocle.function.Index[scalaz.==&gt;&gt;[K,V],K,V]" id="monocle.std;IMapInstances.iMapIndex">iMapIndex</a><span class="delimiter">[</span><a title="" id="monocle.std;IMapInstances.iMapIndex;K">K</a>: Order, <a title="" id="monocle.std;IMapInstances.iMapIndex;V">V</a><span class="delimiter">]</span>: <a href="../function/Index.scala.html#monocle.function;Index" title="monocle.function.Index[scalaz.==&gt;&gt;[K,V],K,V]">Index</a><span class="delimiter">[</span>K ==&gt;&gt; V, K, V<span class="delimiter">]</span> = <a href="../function/Index.scala.html#monocle.function.Index" title="monocle.function.Index.type">Index</a>.<a href="../function/Index.scala.html#monocle.function;IndexFunctions.atIndex" title="(implicit ev: monocle.function.At[scalaz.==&gt;&gt;[K,V],K,V])monocle.function.Index[scalaz.==&gt;&gt;[K,V],K,V]">atIndex</a>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V](implicit evidence$3: scalaz.Order[K])monocle.function.FilterIndex[scalaz.==&gt;&gt;[K,V],K,V]" id="monocle.std;IMapInstances.iMapFilterIndex">iMapFilterIndex</a><span class="delimiter">[</span><a title="" id="monocle.std;IMapInstances.iMapFilterIndex;K">K</a>: Order, <a title="" id="monocle.std;IMapInstances.iMapFilterIndex;V">V</a><span class="delimiter">]</span>: <a href="../function/FilterIndex.scala.html#monocle.function;FilterIndex" title="monocle.function.FilterIndex[scalaz.==&gt;&gt;[K,V],K,V]">FilterIndex</a><span class="delimiter">[</span>K ==&gt;&gt; V, K, V<span class="delimiter">]</span> = <a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon" title="monocle.function.FilterIndex[scalaz.==&gt;&gt;[K,V],K,V]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with monocle.function.FilterIndex[scalaz.==&gt;&gt;[K,V],K,V]" id="monocle.std;IMapInstances.iMapFilterIndex;$anon">FilterIndex</a><span class="delimiter">[</span>K ==&gt;&gt; V, K, V<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">import</span> scalaz.syntax.<span title="scalaz.syntax.applicative.type">applicative</span>._
    <span class="keyword">def</span> <a title="(predicate: K =&gt; Boolean)monocle.Traversal[scalaz.==&gt;&gt;[K,V],V]" id="monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex">filterIndex</a><span class="delimiter">(</span><a title="K =&gt; Boolean" id="monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex.predicate">predicate</a>: K =&gt; Boolean<span class="delimiter">)</span> = <a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon" title="monocle.Traversal[scalaz.==&gt;&gt;[K,V],V]" class="keyword">new</a> <a title="anonymous class $anon extends monocle.Traversal[scalaz.==&gt;&gt;[K,V],V]" id="monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon">Traversal</a><span class="delimiter">[</span>K ==&gt;&gt; V, V<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[F[_]](f: V =&gt; F[V])(s: scalaz.==&gt;&gt;[K,V])(implicit evidence$4: scalaz.Applicative[F])F[scalaz.==&gt;&gt;[K,V]]" id="monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF">modifyF</a><span class="delimiter">[</span><a title="[_]" id="monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF;F">F</a><span class="delimiter">[</span><a title="" id="monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF;F;_">_</a><span class="delimiter">]</span>: Applicative<span class="delimiter">]</span><span class="delimiter">(</span><a title="V =&gt; F[V]" id="monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF.f">f</a>: V =&gt; F<span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.==&gt;&gt;[K,V]" id="monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF.s">s</a>: K <span title="scalaz.==&gt;&gt;[K,V]">==&gt;&gt;</span> V<span class="delimiter">)</span>: <a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF;F" title="F[scalaz.==&gt;&gt;[K,V]]">F</a><span class="delimiter">[</span>K ==&gt;&gt; V<span class="delimiter">]</span> =
        <a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF.s" title="scalaz.==&gt;&gt;[K,V]">s</a>.<span title="(v: List[(K, V)])(implicit F0: scalaz.Traverse[List])scalaz.syntax.TraverseOps[List,(K, V)]">toList</span>.<span title="(f: ((K, V)) =&gt; F[(K, V)])(implicit G: scalaz.Applicative[F])F[List[(K, V)]]">traverse</span><a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.x0$1" title="(v: F[List[(K, V)]])(implicit F0: scalaz.Functor[F])scalaz.syntax.FunctorOps[F,List[(K, V)]]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="K" id="monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.k">k</a>, <a title="V" id="monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.v">v</a><span class="delimiter">)</span> =&gt;
          <span class="delimiter">(</span><a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF.evidence$4" title="(v: F[V])(implicit F0: scalaz.Functor[F])scalaz.syntax.FunctorOps[F,V]" class="keyword">if</a><span class="delimiter">(</span><a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex.predicate" title="(v1: K)Boolean">predicate</a><span class="delimiter">(</span><a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.k" title="K">k</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF.f" title="(v1: V)F[V]">f</a><span class="delimiter">(</span><a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.v" title="V">v</a><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.v" title="(v: =&gt; V)scalaz.syntax.applicative.ApplicativeIdV[V]{lazy val self: V}">v</a>.<span title="[F[_]](implicit evidence$1: scalaz.Applicative[F])F[V]">point</span><a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF.evidence$4" title="(implicit evidence$1: scalaz.Applicative[F])F[V]" class="delimiter">[</a><a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF;F" title="F">F</a><span class="delimiter">]</span><span class="delimiter">)</span>.<span title="(b: K)F[(K, V)]">strengthL</span><span class="delimiter">(</span><a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.k" title="K">k</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>.<span title="(f: List[(K, V)] =&gt; scalaz.==&gt;&gt;[K,V])F[scalaz.==&gt;&gt;[K,V]]">map</span><span class="delimiter">(</span><span title="scalaz.==&gt;&gt;.type">==&gt;&gt;</span>.<span title="(l: List[(K, V)])(implicit evidence$9: scalaz.Order[K])scalaz.==&gt;&gt;[K,V]">fromList</span><a href="#monocle.std;IMapInstances.iMapFilterIndex.evidence$3" title="scalaz.Order[K]" class="delimiter">(</a><a href="#monocle.std;IMapInstances.iMapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.x$2" title="List[(K, V)]">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
