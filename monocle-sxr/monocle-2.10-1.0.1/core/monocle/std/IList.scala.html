<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>core/monocle/std/IList.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> monocle.std

<span class="keyword">import</span> monocle.function._
<span class="keyword">import</span> monocle.<span class="delimiter">{</span>PIso, Optional, Prism<span class="delimiter">}</span>

<span class="keyword">import</span> scalaz.<span title="scalaz.Id.type">Id</span>.Id
<span class="keyword">import</span> scalaz.syntax.std.<span title="scalaz.syntax.std.option.type">option</span>._
<span class="keyword">import</span> scalaz.syntax.<span title="scalaz.syntax.traverse.type">traverse</span>._
<span class="keyword">import</span> scalaz.<span class="delimiter">{</span>Applicative, ICons, IList, INil, Maybe<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="monocle.std.ilist.type" id="monocle.std.ilist">ilist</a> <a href="#monocle.std.ilist" title="monocle.std.ilist.type" class="keyword">extends</a> <a href="#monocle.std;IListInstances" title="monocle.std.IListInstances">IListInstances</a>

<span class="keyword">trait</span> <a title="trait IListInstances extends AnyRef" id="monocle.std;IListInstances">IListInstances</a> <span title="Unit" class="delimiter">{</span>

  <span class="keyword">def</span> <a title="[A, B]=&gt; monocle.PIso[scalaz.IList[A],scalaz.IList[B],List[A],List[B]]" id="monocle.std;IListInstances.iListToList">iListToList</a><span class="delimiter">[</span><a title="" id="monocle.std;IListInstances.iListToList;A">A</a>, <a title="" id="monocle.std;IListInstances.iListToList;B">B</a><span class="delimiter">]</span>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[scalaz.IList[A],scalaz.IList[B],List[A],List[B]]">PIso</a><span class="delimiter">[</span>IList<span class="delimiter">[</span>A<span class="delimiter">]</span>, IList<span class="delimiter">[</span>B<span class="delimiter">]</span>, List<span class="delimiter">[</span>A<span class="delimiter">]</span>, List<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="../Iso.scala.html#monocle.PIso.apply" title="[S, T, A, B](get: S =&gt; A)(reverseGet: B =&gt; T)monocle.PIso[S,T,A,B]">PIso</a><span title="(get: scalaz.IList[A] =&gt; List[A])(reverseGet: List[B] =&gt; scalaz.IList[B])monocle.PIso[scalaz.IList[A],scalaz.IList[B],List[A],List[B]]" class="delimiter">[</span><span title="scalaz.IList[A]">IList</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <span title="scalaz.IList[B]">IList</span><span class="delimiter">[</span>B<span class="delimiter">]</span>, <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <span title="List[B]">List</span><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.std;IListInstances.iListToList.$anonfun.x$1" title="scalaz.IList[A]">_</a>.<span title="=&gt; List[A]">toList</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="scalaz.IList.type">IList</span>.<a href="#monocle.std;IListInstances.iListToList.$anonfun.as" title="(as: List[B])scalaz.IList[B]">fromList</a><span class="delimiter">)</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[A]=&gt; monocle.function.Empty[scalaz.IList[A]]" id="monocle.std;IListInstances.iListEmpty">iListEmpty</a><span class="delimiter">[</span><a title="" id="monocle.std;IListInstances.iListEmpty;A">A</a><span class="delimiter">]</span>: <a href="../function/Empty.scala.html#monocle.function;Empty" title="monocle.function.Empty[scalaz.IList[A]]">Empty</a><span class="delimiter">[</span>IList<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#monocle.std;IListInstances.iListEmpty;$anon" title="monocle.function.Empty[scalaz.IList[A]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with monocle.function.Empty[scalaz.IList[A]]" id="monocle.std;IListInstances.iListEmpty;$anon">Empty</a><span class="delimiter">[</span>IList<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; monocle.Prism[scalaz.IList[A],Unit]" id="monocle.std;IListInstances.iListEmpty;$anon.empty">empty</a> = <a href="../Prism.scala.html#monocle.Prism.apply" title="[S, A](_getMaybe: S =&gt; scalaz.Maybe[A])(_reverseGet: A =&gt; S)monocle.Prism[S,A]">Prism</a><span title="(_getMaybe: scalaz.IList[A] =&gt; scalaz.Maybe[Unit])(_reverseGet: Unit =&gt; scalaz.IList[A])monocle.Prism[scalaz.IList[A],Unit]" class="delimiter">[</span><span title="scalaz.IList[A]">IList</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <span title="Unit">Unit</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.IList[A]" id="monocle.std;IListInstances.iListEmpty;$anon.empty.$anonfun.l">l</a> =&gt; <span title="scalaz.Maybe[Unit]" class="keyword">if</span><span class="delimiter">(</span><a href="#monocle.std;IListInstances.iListEmpty;$anon.empty.$anonfun.l" title="scalaz.IList[A]">l</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="scalaz.Maybe.type">Maybe</span>.<span title="(a: Unit)scalaz.Maybe[Unit]">just</span><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="scalaz.Maybe.type">Maybe</span>.<span title="scalaz.Maybe[Unit]">empty</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Unit" id="monocle.std;IListInstances.iListEmpty;$anon.empty.$anonfun.x$2">_</a> =&gt; <span title="scalaz.IList.type">IList</span>.<span title="scalaz.IList[A]">empty</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[A]=&gt; monocle.function.Empty[scalaz.INil[A]]" id="monocle.std;IListInstances.iNilEmpty">iNilEmpty</a><span class="delimiter">[</span><a title="" id="monocle.std;IListInstances.iNilEmpty;A">A</a><span class="delimiter">]</span>: <a href="../function/Empty.scala.html#monocle.function;Empty" title="monocle.function.Empty[scalaz.INil[A]]">Empty</a><span class="delimiter">[</span>INil<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#monocle.std;IListInstances.iNilEmpty;$anon" title="monocle.function.Empty[scalaz.INil[A]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with monocle.function.Empty[scalaz.INil[A]]" id="monocle.std;IListInstances.iNilEmpty;$anon">Empty</a><span class="delimiter">[</span>INil<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; monocle.Prism[scalaz.INil[A],Unit]" id="monocle.std;IListInstances.iNilEmpty;$anon.empty">empty</a> = <a href="../Prism.scala.html#monocle.Prism.apply" title="[S, A](_getMaybe: S =&gt; scalaz.Maybe[A])(_reverseGet: A =&gt; S)monocle.Prism[S,A]">Prism</a><span title="(_getMaybe: scalaz.INil[A] =&gt; scalaz.Maybe[Unit])(_reverseGet: Unit =&gt; scalaz.INil[A])monocle.Prism[scalaz.INil[A],Unit]" class="delimiter">[</span><span title="scalaz.INil[A]">INil</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <span title="Unit">Unit</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.INil[A]" id="monocle.std;IListInstances.iNilEmpty;$anon.empty.$anonfun.x$3">_</a> =&gt; <span title="scalaz.Maybe.type">Maybe</span>.<span title="(a: Unit)scalaz.Maybe[Unit]">just</span><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Unit" id="monocle.std;IListInstances.iNilEmpty;$anon.empty.$anonfun.x$4">_</a> =&gt; <span title="()scalaz.INil[A]">INil</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[A]=&gt; monocle.function.Each[scalaz.IList[A],A]" id="monocle.std;IListInstances.iListEach">iListEach</a><span class="delimiter">[</span><a title="" id="monocle.std;IListInstances.iListEach;A">A</a><span class="delimiter">]</span>: <a href="../function/Each.scala.html#monocle.function;Each" title="monocle.function.Each[scalaz.IList[A],A]">Each</a><span class="delimiter">[</span>IList<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> = <a href="../function/Each.scala.html#monocle.function.Each" title="monocle.function.Each.type">Each</a>.<a href="../function/Each.scala.html#monocle.function;EachFunctions.traverseEach" title="[S[_], A](implicit evidence$1: scalaz.Traverse[S])monocle.function.Each[S[A],A]">traverseEach</a><span title="(implicit evidence$1: scalaz.Traverse[scalaz.IList])monocle.function.Each[scalaz.IList[A],A]" class="delimiter">[</span><span title="scalaz.IList">IList</span>, <a href="#monocle.std;IListInstances.iListEach;A" title="A">A</a><span class="delimiter">]</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[A]=&gt; monocle.function.Index[scalaz.IList[A],Int,A]" id="monocle.std;IListInstances.iListIndex">iListIndex</a><span class="delimiter">[</span><a title="" id="monocle.std;IListInstances.iListIndex;A">A</a><span class="delimiter">]</span>: <a href="../function/Index.scala.html#monocle.function;Index" title="monocle.function.Index[scalaz.IList[A],Int,A]">Index</a><span class="delimiter">[</span>IList<span class="delimiter">[</span>A<span class="delimiter">]</span>, Int, A<span class="delimiter">]</span> = <a href="#monocle.std;IListInstances.iListIndex;$anon" title="monocle.function.Index[scalaz.IList[A],Int,A]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with monocle.function.Index[scalaz.IList[A],Int,A]" id="monocle.std;IListInstances.iListIndex;$anon">Index</a><span class="delimiter">[</span>IList<span class="delimiter">[</span>A<span class="delimiter">]</span>, Int, A<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(i: Int)monocle.Optional[scalaz.IList[A],A]" id="monocle.std;IListInstances.iListIndex;$anon.index">index</a><span class="delimiter">(</span><a title="Int" id="monocle.std;IListInstances.iListIndex;$anon.index.i">i</a>: <span title="Int">Int</span><span class="delimiter">)</span> = <a href="../Optional.scala.html#monocle.Optional.apply" title="[S, A](_getMaybe: S =&gt; scalaz.Maybe[A])(_set: A =&gt; (S =&gt; S))monocle.Optional[S,A]">Optional</a><span title="(_getMaybe: scalaz.IList[A] =&gt; scalaz.Maybe[A])(_set: A =&gt; (scalaz.IList[A] =&gt; scalaz.IList[A]))monocle.Optional[scalaz.IList[A],A]" class="delimiter">[</span><span title="scalaz.IList[A]">IList</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#monocle.std;IListInstances.iListIndex;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span>
      <a title="scalaz.IList[A]" id="monocle.std;IListInstances.iListIndex;$anon.index.$anonfun.il">il</a>      =&gt; <span title="scalaz.Maybe[A]" class="keyword">if</span><span class="delimiter">(</span><a href="#monocle.std;IListInstances.iListIndex;$anon.index.i" title="Int">i</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="scalaz.Maybe.type">Maybe</span>.<span title="scalaz.Maybe[A]">empty</span> <span class="keyword">else</span> <a href="#monocle.std;IListInstances.iListIndex;$anon.index.$anonfun.il" title="scalaz.IList[A]">il</a>.<span title="(n: Int)scalaz.IList[A]">drop</span><span class="delimiter">(</span><a href="#monocle.std;IListInstances.iListIndex;$anon.index.i" title="Int">i</a><span class="delimiter">)</span>.<span title="(a: Option[A])scalaz.syntax.std.OptionOps[A]">headOption</span>.<span title="=&gt; scalaz.Maybe[A]">toMaybe</span><span class="delimiter">)</span><span class="delimiter">(</span>
      <a title="A" id="monocle.std;IListInstances.iListIndex;$anon.index.$anonfun.a">a</a> =&gt; <a title="scalaz.IList[A]" id="monocle.std;IListInstances.iListIndex;$anon.index.$anonfun.$anonfun.il">il</a> =&gt; <a href="#monocle.std;IListInstances.iListIndex;$anon.index.$anonfun.$anonfun.il" title="scalaz.IList[A]">il</a>.<span title="(v: scalaz.IList[(A, Int)])(implicit F0: scalaz.Traverse[scalaz.IList])scalaz.syntax.TraverseOps[scalaz.IList,(A, Int)]">zipWithIndex</span>.<span title="[G[_], B](f: ((A, Int)) =&gt; G[B])(implicit G: scalaz.Applicative[G])G[scalaz.IList[B]]">traverse</span><span title="(f: ((A, Int)) =&gt; scalaz.Id.Id[A])(implicit G: scalaz.Applicative[scalaz.Id.Id])scalaz.Id.Id[scalaz.IList[A]]" class="delimiter">[</span><span title="scalaz.Id.Id">Id</span>, <a href="#monocle.std;IListInstances.iListIndex;A" title="A">A</a><span class="delimiter">]</span><a href="#monocle.std;IListInstances.iListIndex;$anon.index.$anonfun.$anonfun.$anonfun.x0$1" title="scalaz.Id.Id[A]" class="delimiter">{</a>
        <span class="keyword">case</span> <span class="delimiter">(</span>_    , <span title="Int">index</span><span class="delimiter">)</span> <span class="keyword">if</span> <span title="Int">index</span> <span title="(x: Int)Boolean">==</span> <a href="#monocle.std;IListInstances.iListIndex;$anon.index.i" title="Int">i</a> =&gt; <a href="#monocle.std;IListInstances.iListIndex;$anon.index.$anonfun.a" title="A">a</a>
        <span class="keyword">case</span> <span class="delimiter">(</span><a title="A" id="monocle.std;IListInstances.iListIndex;$anon.index.$anonfun.$anonfun.$anonfun.value">value</a>, <span title="Int">index</span><span class="delimiter">)</span>               =&gt; <a href="#monocle.std;IListInstances.iListIndex;$anon.index.$anonfun.$anonfun.$anonfun.value" title="A">value</a>
      <span class="delimiter">}</span>
    <span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[A]=&gt; monocle.function.FilterIndex[scalaz.IList[A],Int,A]" id="monocle.std;IListInstances.iListFilterIndex">iListFilterIndex</a><span class="delimiter">[</span><a title="" id="monocle.std;IListInstances.iListFilterIndex;A">A</a><span class="delimiter">]</span>: <a href="../function/FilterIndex.scala.html#monocle.function;FilterIndex" title="monocle.function.FilterIndex[scalaz.IList[A],Int,A]">FilterIndex</a><span class="delimiter">[</span>IList<span class="delimiter">[</span>A<span class="delimiter">]</span>, Int, A<span class="delimiter">]</span> =
    <a href="../function/FilterIndex.scala.html#monocle.function.FilterIndex" title="monocle.function.FilterIndex.type">FilterIndex</a>.<a href="../function/FilterIndex.scala.html#monocle.function;FilterIndexFunctions.traverseFilterIndex" title="[S[_], A](zipWithIndex: S[A] =&gt; S[(A, Int)])(implicit evidence$1: scalaz.Traverse[S])monocle.function.FilterIndex[S[A],Int,A]">traverseFilterIndex</a><span title="(zipWithIndex: scalaz.IList[A] =&gt; scalaz.IList[(A, Int)])(implicit evidence$1: scalaz.Traverse[scalaz.IList])monocle.function.FilterIndex[scalaz.IList[A],Int,A]" class="delimiter">[</span><span title="scalaz.IList">IList</span>, <a href="#monocle.std;IListInstances.iListFilterIndex;A" title="A">A</a><span class="delimiter">]</span><span title="=&gt; scalaz.Traverse[scalaz.IList] with scalaz.MonadPlus[scalaz.IList] with scalaz.Zip[scalaz.IList] with scalaz.Unzip[scalaz.IList] with scalaz.Align[scalaz.IList] with scalaz.IsEmpty[scalaz.IList] with scalaz.Cobind[scalaz.IList]" class="delimiter">(</span><a href="#monocle.std;IListInstances.iListFilterIndex.$anonfun.x$5" title="scalaz.IList[A]">_</a>.<span title="=&gt; scalaz.IList[(A, Int)]">zipWithIndex</span><span class="delimiter">)</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[A]=&gt; monocle.function.Cons[scalaz.IList[A],A]" id="monocle.std;IListInstances.iListCons">iListCons</a><span class="delimiter">[</span><a title="" id="monocle.std;IListInstances.iListCons;A">A</a><span class="delimiter">]</span>: <a href="../function/Cons.scala.html#monocle.function;Cons" title="monocle.function.Cons[scalaz.IList[A],A]">Cons</a><span class="delimiter">[</span>IList<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> = <a href="#monocle.std;IListInstances.iListCons;$anon" title="monocle.function.Cons[scalaz.IList[A],A]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with monocle.function.Cons[scalaz.IList[A],A]" id="monocle.std;IListInstances.iListCons;$anon">Cons</a><span class="delimiter">[</span>IList<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span><span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; monocle.Prism[scalaz.IList[A],(A, scalaz.IList[A])]" id="monocle.std;IListInstances.iListCons;$anon.cons">cons</a> = <a href="../Prism.scala.html#monocle.Prism.apply" title="[S, A](_getMaybe: S =&gt; scalaz.Maybe[A])(_reverseGet: A =&gt; S)monocle.Prism[S,A]">Prism</a><span title="(_getMaybe: scalaz.IList[A] =&gt; scalaz.Maybe[(A, scalaz.IList[A])])(_reverseGet: ((A, scalaz.IList[A])) =&gt; scalaz.IList[A])monocle.Prism[scalaz.IList[A],(A, scalaz.IList[A])]" class="delimiter">[</span><span title="scalaz.IList[A]">IList</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <span title="(A, scalaz.IList[A])" class="delimiter">(</span>A, IList<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><a href="#monocle.std;IListInstances.iListCons;$anon.cons.$anonfun.x0$2" title="scalaz.Maybe[(A, scalaz.IList[A])]" class="delimiter">{</a>
      <span class="keyword">case</span> INil<span class="delimiter">(</span><span class="delimiter">)</span>       =&gt; <span title="scalaz.Maybe.type">Maybe</span>.<span title="scalaz.Maybe[(A, scalaz.IList[A])]">empty</span>
      <span class="keyword">case</span> ICons<span class="delimiter">(</span><a title="A" id="monocle.std;IListInstances.iListCons;$anon.cons.$anonfun.x">x</a>, <a title="scalaz.IList[A]" id="monocle.std;IListInstances.iListCons;$anon.cons.$anonfun.xs">xs</a><span class="delimiter">)</span> =&gt; <span title="scalaz.Maybe.type">Maybe</span>.<span title="(a: (A, scalaz.IList[A]))scalaz.Maybe[(A, scalaz.IList[A])]">just</span><span class="delimiter">(</span><span title="(_1: A, _2: scalaz.IList[A])(A, scalaz.IList[A])" class="delimiter">(</span><a href="#monocle.std;IListInstances.iListCons;$anon.cons.$anonfun.x" title="A">x</a>, <a href="#monocle.std;IListInstances.iListCons;$anon.cons.$anonfun.xs" title="scalaz.IList[A]">xs</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span><a href="#monocle.std;IListInstances.iListCons;$anon.cons.$anonfun.x0$3" title="scalaz.IList[A]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="A" id="monocle.std;IListInstances.iListCons;$anon.cons.$anonfun.a">a</a>, <a title="scalaz.IList[A]" id="monocle.std;IListInstances.iListCons;$anon.cons.$anonfun.s">s</a><span class="delimiter">)</span> =&gt; <span title="(head: A, tail: scalaz.IList[A])scalaz.ICons[A]">ICons</span><span class="delimiter">(</span><a href="#monocle.std;IListInstances.iListCons;$anon.cons.$anonfun.a" title="A">a</a>, <a href="#monocle.std;IListInstances.iListCons;$anon.cons.$anonfun.s" title="scalaz.IList[A]">s</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[A]=&gt; monocle.function.Snoc[scalaz.IList[A],A]" id="monocle.std;IListInstances.iListSnoc">iListSnoc</a><span class="delimiter">[</span><a title="" id="monocle.std;IListInstances.iListSnoc;A">A</a><span class="delimiter">]</span>: <a href="../function/Snoc.scala.html#monocle.function;Snoc" title="monocle.function.Snoc[scalaz.IList[A],A]">Snoc</a><span class="delimiter">[</span>IList<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> = <a href="#monocle.std;IListInstances.iListSnoc;$anon" title="monocle.function.Snoc[scalaz.IList[A],A]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with monocle.function.Snoc[scalaz.IList[A],A]" id="monocle.std;IListInstances.iListSnoc;$anon">Snoc</a><span class="delimiter">[</span>IList<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span><span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; monocle.Prism[scalaz.IList[A],(scalaz.IList[A], A)]" id="monocle.std;IListInstances.iListSnoc;$anon.snoc">snoc</a> = <a href="../Prism.scala.html#monocle.Prism.apply" title="[S, A](_getMaybe: S =&gt; scalaz.Maybe[A])(_reverseGet: A =&gt; S)monocle.Prism[S,A]">Prism</a><span title="(_getMaybe: scalaz.IList[A] =&gt; scalaz.Maybe[(scalaz.IList[A], A)])(_reverseGet: ((scalaz.IList[A], A)) =&gt; scalaz.IList[A])monocle.Prism[scalaz.IList[A],(scalaz.IList[A], A)]" class="delimiter">[</span><span title="scalaz.IList[A]">IList</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <span title="(scalaz.IList[A], A)" class="delimiter">(</span>IList<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">(</span>
      <a title="scalaz.IList[A]" id="monocle.std;IListInstances.iListSnoc;$anon.snoc.$anonfun.il">il</a> =&gt; <span title="[F[_]](implicit F: scalaz.Applicative[F])scalaz.Applicative[F]">Applicative</span><span title="(implicit F: scalaz.Applicative[scalaz.Maybe])scalaz.Applicative[scalaz.Maybe]" class="delimiter">[</span><span title="scalaz.Maybe">Maybe</span><span class="delimiter">]</span>.<span title="(fa: =&gt; scalaz.Maybe[scalaz.IList[A]], fb: =&gt; scalaz.Maybe[A])(f: (scalaz.IList[A], A) =&gt; (scalaz.IList[A], A))scalaz.Maybe[(scalaz.IList[A], A)]">apply2</span><span class="delimiter">(</span><a href="#monocle.std;IListInstances.iListSnoc;$anon.snoc.$anonfun.il" title="scalaz.IList[A]">il</a>.<span title="(a: Option[scalaz.IList[A]])scalaz.syntax.std.OptionOps[scalaz.IList[A]]">initOption</span>.<span title="=&gt; scalaz.Maybe[scalaz.IList[A]]">toMaybe</span>, <a href="#monocle.std;IListInstances.iListSnoc;$anon.snoc.$anonfun.il" title="scalaz.IList[A]">il</a>.<span title="(a: Option[A])scalaz.syntax.std.OptionOps[A]">lastOption</span>.<span title="=&gt; scalaz.Maybe[A]">toMaybe</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="(_1: scalaz.IList[A], _2: A)(scalaz.IList[A], A)" class="delimiter">(</span><a href="#monocle.std;IListInstances.iListSnoc;$anon.snoc.$anonfun.$anonfun.x$6" title="scalaz.IList[A]">_</a>,<a href="#monocle.std;IListInstances.iListSnoc;$anon.snoc.$anonfun.$anonfun.x$7" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><a href="#monocle.std;IListInstances.iListSnoc;$anon.snoc.$anonfun.x0$4" title="scalaz.IList[A]" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><a title="scalaz.IList[A]" id="monocle.std;IListInstances.iListSnoc;$anon.snoc.$anonfun.init">init</a>, <a title="A" id="monocle.std;IListInstances.iListSnoc;$anon.snoc.$anonfun.last">last</a><span class="delimiter">)</span> =&gt; <a href="#monocle.std;IListInstances.iListSnoc;$anon.snoc.$anonfun.init" title="scalaz.IList[A]">init</a> <span title="(a: A)scalaz.IList[A]">:+</span> <a href="#monocle.std;IListInstances.iListSnoc;$anon.snoc.$anonfun.last" title="A">last</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[A]=&gt; monocle.function.Reverse[scalaz.IList[A],scalaz.IList[A]]" id="monocle.std;IListInstances.iListReverse">iListReverse</a><span class="delimiter">[</span><a title="" id="monocle.std;IListInstances.iListReverse;A">A</a><span class="delimiter">]</span>: <a href="../function/Reverse.scala.html#monocle.function;Reverse" title="monocle.function.Reverse[scalaz.IList[A],scalaz.IList[A]]">Reverse</a><span class="delimiter">[</span>IList<span class="delimiter">[</span>A<span class="delimiter">]</span>, IList<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="../function/Reverse.scala.html#monocle.function;ReverseFunctions.reverseFromReverseFunction" title="[S](_reverse: S =&gt; S)monocle.function.Reverse[S,S]">reverseFromReverseFunction</a><span title="(_reverse: scalaz.IList[A] =&gt; scalaz.IList[A])monocle.function.Reverse[scalaz.IList[A],scalaz.IList[A]]" class="delimiter">[</span><span title="scalaz.IList[A]">IList</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.std;IListInstances.iListReverse.$anonfun.x$8" title="scalaz.IList[A]">_</a>.<span title="=&gt; scalaz.IList[A]">reverse</span><span class="delimiter">)</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
