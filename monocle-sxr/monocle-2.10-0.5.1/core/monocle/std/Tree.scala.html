<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>core/monocle/std/Tree.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> monocle.std

<span class="keyword">import</span> monocle.function._
<span class="keyword">import</span> monocle.syntax._
<span class="keyword">import</span> monocle.<span class="delimiter">{</span>SimpleIso, SimpleLens<span class="delimiter">}</span>

<span class="keyword">import</span> scalaz.Tree
<span class="keyword">import</span> scala.annotation.tailrec
<span class="keyword">import</span> scala.collection.immutable.<span title="scala.collection.immutable.Stream.type">Stream</span>.Empty


<span class="keyword">object</span> <a title="monocle.std.tree.type" id="monocle.std.tree">tree</a> <a href="#monocle.std.tree" title="monocle.std.tree.type" class="keyword">extends</a> <a href="#monocle.std;TreeFunctions" title="monocle.std.TreeFunctions">TreeFunctions</a> <span class="keyword">with</span> <a href="#monocle.std;TreeInstances" title="monocle.std.TreeInstances">TreeInstances</a>

<span class="keyword">trait</span> <a title="trait TreeFunctions extends AnyRef" id="monocle.std;TreeFunctions">TreeFunctions</a> <span title="Unit" class="delimiter">{</span>

  <span class="keyword">def</span> <a title="[A]=&gt; monocle.SimpleLens[scalaz.Tree[A],A]" id="monocle.std;TreeFunctions.rootLabel">rootLabel</a><span class="delimiter">[</span><a title="" id="monocle.std;TreeFunctions.rootLabel;A">A</a><span class="delimiter">]</span>: <a href="../Lens.scala.html#monocle;Lens" title="monocle.SimpleLens[scalaz.Tree[A],A]">SimpleLens</a><span class="delimiter">[</span>Tree<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> =
    <a href="../package.scala.html#monocle.package.SimpleLens.apply(cee1f45334)" title="[S, A](_get: S =&gt; A, _set: (S, A) =&gt; S)monocle.SimpleLens[S,A]">SimpleLens</a><span title="(_get: scalaz.Tree[A] =&gt; A, _set: (scalaz.Tree[A], A) =&gt; scalaz.Tree[A])monocle.SimpleLens[scalaz.Tree[A],A]" class="delimiter">[</span><span title="scalaz.Tree[A]">Tree</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#monocle.std;TreeFunctions.rootLabel;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.rootLabel.$anonfun.x$1" title="scalaz.Tree[A]">_</a>.<span title="=&gt; A">rootLabel</span>, <span class="delimiter">(</span><a title="scalaz.Tree[A]" id="monocle.std;TreeFunctions.rootLabel.$anonfun.tree">tree</a>, <a title="A" id="monocle.std;TreeFunctions.rootLabel.$anonfun.l">l</a><span class="delimiter">)</span> =&gt; <span title="scalaz.Tree.type">Tree</span>.<span title="(root: =&gt; A, forest: =&gt; Stream[scalaz.Tree[A]])scalaz.Tree[A]">node</span><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.rootLabel.$anonfun.l" title="A">l</a>, <a href="#monocle.std;TreeFunctions.rootLabel.$anonfun.tree" title="scalaz.Tree[A]">tree</a>.<span title="=&gt; Stream[scalaz.Tree[A]]">subForest</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[A]=&gt; monocle.SimpleLens[scalaz.Tree[A],Stream[scalaz.Tree[A]]]" id="monocle.std;TreeFunctions.subForest">subForest</a><span class="delimiter">[</span><a title="" id="monocle.std;TreeFunctions.subForest;A">A</a><span class="delimiter">]</span>: <a href="../Lens.scala.html#monocle;Lens" title="monocle.SimpleLens[scalaz.Tree[A],Stream[scalaz.Tree[A]]]">SimpleLens</a><span class="delimiter">[</span>Tree<span class="delimiter">[</span>A<span class="delimiter">]</span>, Stream<span class="delimiter">[</span>Tree<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="../package.scala.html#monocle.package.SimpleLens.apply(cee1f45334)" title="[S, A](_get: S =&gt; A, _set: (S, A) =&gt; S)monocle.SimpleLens[S,A]">SimpleLens</a><span title="(_get: scalaz.Tree[A] =&gt; Stream[scalaz.Tree[A]], _set: (scalaz.Tree[A], Stream[scalaz.Tree[A]]) =&gt; scalaz.Tree[A])monocle.SimpleLens[scalaz.Tree[A],Stream[scalaz.Tree[A]]]" class="delimiter">[</span><span title="scalaz.Tree[A]">Tree</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <span title="Stream[scalaz.Tree[A]]">Stream</span><span class="delimiter">[</span>Tree<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.subForest.$anonfun.x$2" title="scalaz.Tree[A]">_</a>.<span title="=&gt; Stream[scalaz.Tree[A]]">subForest</span>, <span class="delimiter">(</span><a title="scalaz.Tree[A]" id="monocle.std;TreeFunctions.subForest.$anonfun.tree">tree</a>, <a title="Stream[scalaz.Tree[A]]" id="monocle.std;TreeFunctions.subForest.$anonfun.children">children</a><span class="delimiter">)</span> =&gt; <span title="scalaz.Tree.type">Tree</span>.<span title="(root: =&gt; A, forest: =&gt; Stream[scalaz.Tree[A]])scalaz.Tree[A]">node</span><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.subForest.$anonfun.tree" title="scalaz.Tree[A]">tree</a>.<span title="=&gt; A">rootLabel</span>, <a href="#monocle.std;TreeFunctions.subForest.$anonfun.children" title="Stream[scalaz.Tree[A]]">children</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[A]=&gt; monocle.SimpleLens[scalaz.Tree[A],A]" id="monocle.std;TreeFunctions.leftMostLabel">leftMostLabel</a><span class="delimiter">[</span><a title="" id="monocle.std;TreeFunctions.leftMostLabel;A">A</a><span class="delimiter">]</span>: <a href="../Lens.scala.html#monocle;Lens" title="monocle.SimpleLens[scalaz.Tree[A],A]">SimpleLens</a><span class="delimiter">[</span>Tree<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> = <span class="delimiter">{</span>

    @tailrec
    <span class="keyword">def</span> <a title="(tree: scalaz.Tree[A])A" id="monocle.std;TreeFunctions.leftMostLabel._get">_get</a><span class="delimiter">(</span><a title="scalaz.Tree[A]" id="monocle.std;TreeFunctions.leftMostLabel._get.tree">tree</a>: <span title="scalaz.Tree[A]">Tree</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.std;TreeFunctions.leftMostLabel;A" title="A">A</a> = <a href="#monocle.std;TreeFunctions.leftMostLabel._get.tree" title="scalaz.Tree[A]">tree</a>.<span title="=&gt; Stream[scalaz.Tree[A]]">subForest</span> <span title="A" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="collection.immutable.Stream.Empty.type">Empty</span>    =&gt; <a href="#monocle.std;TreeFunctions.leftMostLabel._get.tree" title="scalaz.Tree[A]">tree</a>.<span title="=&gt; A">rootLabel</span>
      <span class="keyword">case</span> <a title="scalaz.Tree[A]" id="monocle.std;TreeFunctions.leftMostLabel._get.x">x</a> <a href="#monocle.std;TreeFunctions.leftMostLabel._get.<unapply-selector>" title="(xs: scala.collection.immutable.Stream[scalaz.Tree[A]])Option[(scalaz.Tree[A], scala.collection.immutable.Stream[scalaz.Tree[A]])]">#::</a> <a title="scala.collection.immutable.Stream[scalaz.Tree[A]]" id="monocle.std;TreeFunctions.leftMostLabel._get.xs">xs</a> =&gt; <a href="#monocle.std;TreeFunctions.leftMostLabel._get" title="(tree: scalaz.Tree[A])A">_get</a><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.leftMostLabel._get.x" title="scalaz.Tree[A]">x</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tree: scalaz.Tree[A], newLeaf: A)scalaz.Tree[A]" id="monocle.std;TreeFunctions.leftMostLabel._set">_set</a><span class="delimiter">(</span><a title="scalaz.Tree[A]" id="monocle.std;TreeFunctions.leftMostLabel._set.tree">tree</a>: <span title="scalaz.Tree[A]">Tree</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A" id="monocle.std;TreeFunctions.leftMostLabel._set.newLeaf">newLeaf</a>: <a href="#monocle.std;TreeFunctions.leftMostLabel;A" title="A">A</a><span class="delimiter">)</span>: <span title="scalaz.Tree[A]">Tree</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#monocle.std;TreeFunctions.leftMostLabel._set.tree" title="scalaz.Tree[A]">tree</a>.<span title="=&gt; Stream[scalaz.Tree[A]]">subForest</span> <span title="scalaz.Tree[A]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="collection.immutable.Stream.Empty.type">Empty</span> =&gt; <span title="scalaz.Tree.type">Tree</span>.<span title="(root: =&gt; A)scalaz.Tree[A]">leaf</span><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.leftMostLabel._set.newLeaf" title="A">newLeaf</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Stream[scalaz.Tree[A]]" id="monocle.std;TreeFunctions.leftMostLabel._set.xs">xs</a>    =&gt; <span title="scalaz.Tree.type">Tree</span>.<span title="(root: =&gt; A, forest: =&gt; Stream[scalaz.Tree[A]])scalaz.Tree[A]">node</span><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.leftMostLabel._set.tree" title="scalaz.Tree[A]">tree</a>.<span title="=&gt; A">rootLabel</span>, <a href="../syntax/Optional.scala.html#monocle.syntax;OptionalSyntax.tolApplyOptionalOps" title="(value: Stream[scalaz.Tree[A]])monocle.syntax.lyApplyOptionalOps[Stream[scalaz.Tree[A]]]">xs</a> <a href="../syntax/Optional.scala.html#monocle.syntax;lyApplyOptionalOps.applyOptional" title="(Optional: monocle.Optional[Stream[scalaz.Tree[A]],Stream[scalaz.Tree[A]],scalaz.Tree[A],scalaz.Tree[A]])monocle.syntax.ApplyOptional[Stream[scalaz.Tree[A]],Stream[scalaz.Tree[A]],scalaz.Tree[A],scalaz.Tree[A]]">applyOptional</a> <a href="../function/HeadOption.scala.html#monocle.function;HeadOptionFunctions.headOption" title="(implicit ev: monocle.function.HeadOption[Stream[scalaz.Tree[A]],scalaz.Tree[A]])monocle.SimpleOptional[Stream[scalaz.Tree[A]],scalaz.Tree[A]]">headOption</a> <a href="../syntax/Setter.scala.html#monocle.syntax;ApplySetter.modify" title="(f: scalaz.Tree[A] =&gt; scalaz.Tree[A])Stream[scalaz.Tree[A]]">modify</a><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.leftMostLabel._set" title="(tree: scalaz.Tree[A], newLeaf: A)scalaz.Tree[A]">_set</a><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.leftMostLabel._set.$anonfun.x$3" title="scalaz.Tree[A]">_</a>, <a href="#monocle.std;TreeFunctions.leftMostLabel._set.newLeaf" title="A">newLeaf</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="../package.scala.html#monocle.package.SimpleLens.apply(cee1f45334)" title="[S, A](_get: S =&gt; A, _set: (S, A) =&gt; S)monocle.SimpleLens[S,A]">SimpleLens</a><span title="(_get: scalaz.Tree[A] =&gt; A, _set: (scalaz.Tree[A], A) =&gt; scalaz.Tree[A])monocle.SimpleLens[scalaz.Tree[A],A]" class="delimiter">[</span><span title="scalaz.Tree[A]">Tree</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#monocle.std;TreeFunctions.leftMostLabel;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.leftMostLabel._get" title="(tree: scalaz.Tree[A])A">_get</a>, <a href="#monocle.std;TreeFunctions.leftMostLabel._set" title="(tree: scalaz.Tree[A], newLeaf: A)scalaz.Tree[A]">_set</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[A]=&gt; monocle.SimpleLens[scalaz.Tree[A],A]" id="monocle.std;TreeFunctions.rightMostLabel">rightMostLabel</a><span class="delimiter">[</span><a title="" id="monocle.std;TreeFunctions.rightMostLabel;A">A</a><span class="delimiter">]</span>: <a href="../Lens.scala.html#monocle;Lens" title="monocle.SimpleLens[scalaz.Tree[A],A]">SimpleLens</a><span class="delimiter">[</span>Tree<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> = <span class="delimiter">{</span>

    @tailrec
    <span class="keyword">def</span> <a title="(tree: scalaz.Tree[A])A" id="monocle.std;TreeFunctions.rightMostLabel._get">_get</a><span class="delimiter">(</span><a title="scalaz.Tree[A]" id="monocle.std;TreeFunctions.rightMostLabel._get.tree">tree</a>: <span title="scalaz.Tree[A]">Tree</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.std;TreeFunctions.rightMostLabel;A" title="A">A</a> = <a href="#monocle.std;TreeFunctions.rightMostLabel._get.tree" title="scalaz.Tree[A]">tree</a>.<span title="=&gt; Stream[scalaz.Tree[A]]">subForest</span> <span title="A" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="collection.immutable.Stream.Empty.type">Empty</span> =&gt; <a href="#monocle.std;TreeFunctions.rightMostLabel._get.tree" title="scalaz.Tree[A]">tree</a>.<span title="=&gt; A">rootLabel</span>
      <span class="keyword">case</span> <a title="Stream[scalaz.Tree[A]]" id="monocle.std;TreeFunctions.rightMostLabel._get.xs">xs</a>    =&gt; <a href="#monocle.std;TreeFunctions.rightMostLabel._get" title="(tree: scalaz.Tree[A])A">_get</a><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.rightMostLabel._get.xs" title="Stream[scalaz.Tree[A]]">xs</a>.<span title="=&gt; scalaz.Tree[A]">last</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tree: scalaz.Tree[A], newLeaf: A)scalaz.Tree[A]" id="monocle.std;TreeFunctions.rightMostLabel._set">_set</a><span class="delimiter">(</span><a title="scalaz.Tree[A]" id="monocle.std;TreeFunctions.rightMostLabel._set.tree">tree</a>: <span title="scalaz.Tree[A]">Tree</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A" id="monocle.std;TreeFunctions.rightMostLabel._set.newLeaf">newLeaf</a>: <a href="#monocle.std;TreeFunctions.rightMostLabel;A" title="A">A</a><span class="delimiter">)</span>: <span title="scalaz.Tree[A]">Tree</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#monocle.std;TreeFunctions.rightMostLabel._set.tree" title="scalaz.Tree[A]">tree</a>.<span title="=&gt; Stream[scalaz.Tree[A]]">subForest</span> <span title="scalaz.Tree[A]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="collection.immutable.Stream.Empty.type">Empty</span> =&gt; <span title="scalaz.Tree.type">Tree</span>.<span title="(root: =&gt; A)scalaz.Tree[A]">leaf</span><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.rightMostLabel._set.newLeaf" title="A">newLeaf</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Stream[scalaz.Tree[A]]" id="monocle.std;TreeFunctions.rightMostLabel._set.xs">xs</a>    =&gt; <span title="scalaz.Tree.type">Tree</span>.<span title="(root: =&gt; A, forest: =&gt; Stream[scalaz.Tree[A]])scalaz.Tree[A]">node</span><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.rightMostLabel._set.tree" title="scalaz.Tree[A]">tree</a>.<span title="=&gt; A">rootLabel</span>,  <a href="../syntax/Optional.scala.html#monocle.syntax;OptionalSyntax.tolApplyOptionalOps" title="(value: Stream[scalaz.Tree[A]])monocle.syntax.lyApplyOptionalOps[Stream[scalaz.Tree[A]]]">xs</a> <a href="../syntax/Optional.scala.html#monocle.syntax;lyApplyOptionalOps.applyOptional" title="(Optional: monocle.Optional[Stream[scalaz.Tree[A]],Stream[scalaz.Tree[A]],scalaz.Tree[A],scalaz.Tree[A]])monocle.syntax.ApplyOptional[Stream[scalaz.Tree[A]],Stream[scalaz.Tree[A]],scalaz.Tree[A],scalaz.Tree[A]]">applyOptional</a> <a href="../function/LastOption.scala.html#monocle.function;LastOptionFunctions.lastOption" title="(implicit ev: monocle.function.LastOption[Stream[scalaz.Tree[A]],scalaz.Tree[A]])monocle.SimpleOptional[Stream[scalaz.Tree[A]],scalaz.Tree[A]]">lastOption</a> <a href="../syntax/Setter.scala.html#monocle.syntax;ApplySetter.modify" title="(f: scalaz.Tree[A] =&gt; scalaz.Tree[A])Stream[scalaz.Tree[A]]">modify</a><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.rightMostLabel._set" title="(tree: scalaz.Tree[A], newLeaf: A)scalaz.Tree[A]">_set</a><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.rightMostLabel._set.$anonfun.x$4" title="scalaz.Tree[A]">_</a>, <a href="#monocle.std;TreeFunctions.rightMostLabel._set.newLeaf" title="A">newLeaf</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="../package.scala.html#monocle.package.SimpleLens.apply(cee1f45334)" title="[S, A](_get: S =&gt; A, _set: (S, A) =&gt; S)monocle.SimpleLens[S,A]">SimpleLens</a><span title="(_get: scalaz.Tree[A] =&gt; A, _set: (scalaz.Tree[A], A) =&gt; scalaz.Tree[A])monocle.SimpleLens[scalaz.Tree[A],A]" class="delimiter">[</span><span title="scalaz.Tree[A]">Tree</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#monocle.std;TreeFunctions.rightMostLabel;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.std;TreeFunctions.rightMostLabel._get" title="(tree: scalaz.Tree[A])A">_get</a>, <a href="#monocle.std;TreeFunctions.rightMostLabel._set" title="(tree: scalaz.Tree[A], newLeaf: A)scalaz.Tree[A]">_set</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait TreeInstances extends AnyRef" id="monocle.std;TreeInstances">TreeInstances</a> <span title="Unit" class="delimiter">{</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[A]=&gt; monocle.function.Each[scalaz.Tree[A],A]" id="monocle.std;TreeInstances.treeEach">treeEach</a><span class="delimiter">[</span><a title="" id="monocle.std;TreeInstances.treeEach;A">A</a><span class="delimiter">]</span>: <a href="../function/Each.scala.html#monocle.function;Each" title="monocle.function.Each[scalaz.Tree[A],A]">Each</a><span class="delimiter">[</span>Tree<span class="delimiter">[</span>A<span class="delimiter">]</span>, A<span class="delimiter">]</span> = <a href="../function/Each.scala.html#monocle.function.Each" title="monocle.function.Each.type">Each</a>.<a href="../function/Each.scala.html#monocle.function;EachFunctions.traverseEach" title="[S[_], A](implicit evidence$1: scalaz.Traverse[S])monocle.function.Each[S[A],A]">traverseEach</a><span title="(implicit evidence$1: scalaz.Traverse[scalaz.Tree])monocle.function.Each[scalaz.Tree[A],A]" class="delimiter">[</span><span title="scalaz.Tree">Tree</span>, <a href="#monocle.std;TreeInstances.treeEach;A" title="A">A</a><span class="delimiter">]</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[A]=&gt; monocle.function.Reverse[scalaz.Tree[A],scalaz.Tree[A]]" id="monocle.std;TreeInstances.treeReverse">treeReverse</a><span class="delimiter">[</span><a title="" id="monocle.std;TreeInstances.treeReverse;A">A</a><span class="delimiter">]</span>: <a href="../function/Reverse.scala.html#monocle.function;Reverse" title="monocle.function.Reverse[scalaz.Tree[A],scalaz.Tree[A]]">Reverse</a><span class="delimiter">[</span>Tree<span class="delimiter">[</span>A<span class="delimiter">]</span>, Tree<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#monocle.std;TreeInstances.treeReverse;$anon" title="monocle.function.Reverse[scalaz.Tree[A],scalaz.Tree[A]]{}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with monocle.function.Reverse[scalaz.Tree[A],scalaz.Tree[A]]" id="monocle.std;TreeInstances.treeReverse;$anon">Reverse</a><span class="delimiter">[</span>Tree<span class="delimiter">[</span>A<span class="delimiter">]</span>, Tree<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; monocle.SimpleIso[scalaz.Tree[A],scalaz.Tree[A]]" id="monocle.std;TreeInstances.treeReverse;$anon.reverse">reverse</a> = <a href="../package.scala.html#monocle.package.SimpleIso.apply(e2f1535e3e)" title="[S, A](_get: S =&gt; A, _reverseGet: A =&gt; S)monocle.SimpleIso[S,A]">SimpleIso</a><span title="(_get: scalaz.Tree[A] =&gt; scalaz.Tree[A], _reverseGet: scalaz.Tree[A] =&gt; scalaz.Tree[A])monocle.SimpleIso[scalaz.Tree[A],scalaz.Tree[A]]" class="delimiter">[</span><span title="scalaz.Tree[A]">Tree</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <span title="scalaz.Tree[A]">Tree</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.std;TreeInstances.treeReverse;$anon.reverseTree" title="(tree: scalaz.Tree[A])scalaz.Tree[A]">reverseTree</a>, <a href="#monocle.std;TreeInstances.treeReverse;$anon.reverseTree" title="(tree: scalaz.Tree[A])scalaz.Tree[A]">reverseTree</a><span class="delimiter">)</span>
    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(tree: scalaz.Tree[A])scalaz.Tree[A]" id="monocle.std;TreeInstances.treeReverse;$anon.reverseTree">reverseTree</a><span class="delimiter">(</span><a title="scalaz.Tree[A]" id="monocle.std;TreeInstances.treeReverse;$anon.reverseTree.tree">tree</a>: <span title="scalaz.Tree[A]">Tree</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scalaz.Tree[A]">Tree</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span title="scalaz.Tree.type">Tree</span>.<span title="(root: =&gt; A, forest: =&gt; Stream[scalaz.Tree[A]])scalaz.Tree[A]">node</span><span class="delimiter">(</span><a href="#monocle.std;TreeInstances.treeReverse;$anon.reverseTree.tree" title="scalaz.Tree[A]">tree</a>.<span title="=&gt; A">rootLabel</span>, <a href="#monocle.std;TreeInstances.treeReverse;$anon.reverseTree.tree" title="scalaz.Tree[A]">tree</a>.<span title="=&gt; Stream[scalaz.Tree[A]]">subForest</span>.<span title="=&gt; scala.collection.immutable.Stream[scalaz.Tree[A]]">reverse</span>.<span title="(f: scalaz.Tree[A] =&gt; scalaz.Tree[A])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream[scalaz.Tree[A]],scalaz.Tree[A],Stream[scalaz.Tree[A]]])Stream[scalaz.Tree[A]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Stream.Coll,scalaz.Tree[A],scala.collection.immutable.Stream[scalaz.Tree[A]]]" class="delimiter">(</span><a href="#monocle.std;TreeInstances.treeReverse;$anon.reverseTree" title="(tree: scalaz.Tree[A])scalaz.Tree[A]">reverseTree</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
