<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>core/monocle/std/Map.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> monocle.std

<span class="keyword">import</span> monocle.function._
<span class="keyword">import</span> monocle.<span class="delimiter">{</span>Traversal, SimpleLens<span class="delimiter">}</span>
<span class="keyword">import</span> scalaz.Applicative
<span class="keyword">import</span> scalaz.std.<span title="scalaz.std.list.type">list</span>._
<span class="keyword">import</span> scalaz.std.<span title="scalaz.std.map.type">map</span>._
<span class="keyword">import</span> scalaz.syntax.<span title="scalaz.syntax.traverse.type">traverse</span>._

<span class="keyword">object</span> <a title="monocle.std.map.type" id="monocle.std.map">map</a> <a href="#monocle.std.map" title="monocle.std.map.type" class="keyword">extends</a> <a href="#monocle.std;MapInstances" title="monocle.std.MapInstances">MapInstances</a>

<span class="keyword">trait</span> <a title="trait MapInstances extends AnyRef" id="monocle.std;MapInstances">MapInstances</a> <span title="Unit" class="delimiter">{</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V]=&gt; monocle.function.At[Map[K,V],K,V]" id="monocle.std;MapInstances.atMap">atMap</a><span class="delimiter">[</span><a title="" id="monocle.std;MapInstances.atMap;K">K</a>, <a title="" id="monocle.std;MapInstances.atMap;V">V</a><span class="delimiter">]</span>: <a href="../function/At.scala.html#monocle.function;At" title="monocle.function.At[Map[K,V],K,V]">At</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, K, V<span class="delimiter">]</span> = <a href="#monocle.std;MapInstances.atMap;$anon" title="monocle.function.At[Map[K,V],K,V]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with monocle.function.At[Map[K,V],K,V]" id="monocle.std;MapInstances.atMap;$anon">At</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, K, V<span class="delimiter">]</span><span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(i: K)monocle.SimpleLens[Map[K,V],Option[V]]" id="monocle.std;MapInstances.atMap;$anon.at">at</a><span class="delimiter">(</span><a title="K" id="monocle.std;MapInstances.atMap;$anon.at.i">i</a>: <a href="#monocle.std;MapInstances.atMap;K" title="K">K</a><span class="delimiter">)</span> = <a href="../package.scala.html#monocle.package.SimpleLens.apply(cee1f45334)" title="[S, A](_get: S =&gt; A, _set: (S, A) =&gt; S)monocle.SimpleLens[S,A]">SimpleLens</a><span title="(_get: Map[K,V] =&gt; Option[V], _set: (Map[K,V], Option[V]) =&gt; Map[K,V])monocle.SimpleLens[Map[K,V],Option[V]]" class="delimiter">[</span><span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <span title="Option[V]">Option</span><span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>
      <a href="#monocle.std;MapInstances.atMap;$anon.at.$anonfun.x$1" title="Map[K,V]">_</a>.<span title="(key: K)Option[V]">get</span><span class="delimiter">(</span><a href="#monocle.std;MapInstances.atMap;$anon.at.i" title="K">i</a><span class="delimiter">)</span>,
      <span class="delimiter">(</span><a title="Map[K,V]" id="monocle.std;MapInstances.atMap;$anon.at.$anonfun.map">map</a>, <a title="Option[V]" id="monocle.std;MapInstances.atMap;$anon.at.$anonfun.optValue">optValue</a><span class="delimiter">)</span> =&gt; <a href="#monocle.std;MapInstances.atMap;$anon.at.$anonfun.optValue" title="Option[V]">optValue</a> <span title="Map[K,V]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="V" id="monocle.std;MapInstances.atMap;$anon.at.$anonfun.value">value</a><span class="delimiter">)</span> =&gt; <a href="#monocle.std;MapInstances.atMap;$anon.at.$anonfun.map" title="Map[K,V]">map</a> <span title="(kv: (K, V))scala.collection.immutable.Map[K,V]">+</span> <span class="delimiter">(</span><a href="#monocle.std;MapInstances.atMap;$anon.at.i" title="(x: K)ArrowAssoc[K]">i</a> <span title="(y: V)(K, V)">-&gt;</span> <a href="#monocle.std;MapInstances.atMap;$anon.at.$anonfun.value" title="V">value</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="None.type">None</span>        =&gt; <a href="#monocle.std;MapInstances.atMap;$anon.at.$anonfun.map" title="Map[K,V]">map</a> <span title="(key: K)scala.collection.immutable.Map[K,V]">-</span> <a href="#monocle.std;MapInstances.atMap;$anon.at.i" title="K">i</a>
      <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V]=&gt; monocle.function.Each[Map[K,V],V]" id="monocle.std;MapInstances.mapEach">mapEach</a><span class="delimiter">[</span><a title="" id="monocle.std;MapInstances.mapEach;K">K</a>, <a title="" id="monocle.std;MapInstances.mapEach;V">V</a><span class="delimiter">]</span>: <a href="../function/Each.scala.html#monocle.function;Each" title="monocle.function.Each[Map[K,V],V]">Each</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, V<span class="delimiter">]</span> = <a href="../function/Each.scala.html#monocle.function.Each" title="monocle.function.Each.type">Each</a>.<a href="../function/Each.scala.html#monocle.function;EachFunctions.traverseEach" title="[S[_], A](implicit evidence$1: scalaz.Traverse[S])monocle.function.Each[S[A],A]">traverseEach</a><span title="(implicit evidence$1: scalaz.Traverse[[α]scala.collection.immutable.Map[K,α]])monocle.function.Each[scala.collection.immutable.Map[K,V],V]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = Map<span class="delimiter">[</span>K,α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[α]scala.collection.immutable.Map[K,α]">λ</span>, <a href="#monocle.std;MapInstances.mapEach;V" title="V">V</a><span class="delimiter">]</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V]=&gt; monocle.function.Index[Map[K,V],K,V]" id="monocle.std;MapInstances.mapIndex">mapIndex</a><span class="delimiter">[</span><a title="" id="monocle.std;MapInstances.mapIndex;K">K</a>, <a title="" id="monocle.std;MapInstances.mapIndex;V">V</a><span class="delimiter">]</span>: <a href="../function/Index.scala.html#monocle.function;Index" title="monocle.function.Index[Map[K,V],K,V]">Index</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, K  , V<span class="delimiter">]</span> = <a href="../function/Index.scala.html#monocle.function.Index" title="monocle.function.Index.type">Index</a>.<a href="../function/Index.scala.html#monocle.function;IndexFunctions.atIndex" title="(implicit ev: monocle.function.At[Map[K,V],K,V])monocle.function.Index[Map[K,V],K,V]">atIndex</a>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V]=&gt; monocle.function.FilterIndex[Map[K,V],K,V]" id="monocle.std;MapInstances.mapFilterIndex">mapFilterIndex</a><span class="delimiter">[</span><a title="" id="monocle.std;MapInstances.mapFilterIndex;K">K</a>, <a title="" id="monocle.std;MapInstances.mapFilterIndex;V">V</a><span class="delimiter">]</span>: <a href="../function/FilterIndex.scala.html#monocle.function;FilterIndex" title="monocle.function.FilterIndex[Map[K,V],K,V]">FilterIndex</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K,V<span class="delimiter">]</span>, K, V<span class="delimiter">]</span> = <a href="#monocle.std;MapInstances.mapFilterIndex;$anon" title="monocle.function.FilterIndex[Map[K,V],K,V]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with monocle.function.FilterIndex[Map[K,V],K,V]" id="monocle.std;MapInstances.mapFilterIndex;$anon">FilterIndex</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, K, V<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(predicate: K =&gt; Boolean)monocle.Traversal[Map[K,V],Map[K,V],V,V]" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex">filterIndex</a><span class="delimiter">(</span><a title="K =&gt; Boolean" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex.predicate">predicate</a>: K =&gt; Boolean<span class="delimiter">)</span> = <a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon" title="monocle.Traversal[Map[K,V],Map[K,V],V,V]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with monocle.Traversal[Map[K,V],Map[K,V],V,V]" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon">Traversal</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, V, V<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[F[_]](from: Map[K,V], f: V =&gt; F[V])(implicit evidence$1: scalaz.Applicative[F])F[Map[K,V]]" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift">multiLift</a><span class="delimiter">[</span><a title="[_]" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift;F">F</a><span class="delimiter">[</span><a title="" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift;F;_">_</a><span class="delimiter">]</span> : Applicative<span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,V]" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.from">from</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="V =&gt; F[V]" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.f">f</a>: <span class="delimiter">(</span>V<span class="delimiter">)</span> =&gt; F<span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift;F" title="F[Map[K,V]]">F</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> =
        <span title="[F[_]](implicit F: scalaz.Applicative[F])scalaz.Applicative[F]">Applicative</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.evidence$1" title="(implicit F: scalaz.Applicative[F])scalaz.Applicative[F]" class="delimiter">[</a><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift;F" title="F">F</a><span class="delimiter">]</span>.<span title="(fa: F[List[(K, V)]])(f: List[(K, V)] =&gt; scala.collection.immutable.Map[K,V])F[scala.collection.immutable.Map[K,V]]">map</span><span class="delimiter">(</span>
          <a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.from" title="Map[K,V]">from</a>.<span title="(v: List[(K, V)])(implicit F0: scalaz.Traverse[List])scalaz.syntax.TraverseOps[List,(K, V)]">toList</span>.<span title="(f: ((K, V)) =&gt; F[(K, V)])(implicit G: scalaz.Applicative[F])F[List[(K, V)]]">traverse</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.$anonfun.x0$1" title="F[(K, V)]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="K" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.$anonfun.k">k</a>, <a title="V" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.$anonfun.v">v</a><span class="delimiter">)</span> =&gt;
            <span title="[F[_]](implicit F: scalaz.Applicative[F])scalaz.Applicative[F]">Applicative</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.evidence$1" title="(implicit F: scalaz.Applicative[F])scalaz.Applicative[F]" class="delimiter">[</a><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift;F" title="F">F</a><span class="delimiter">]</span>.<span title="(fa: F[V])(f: V =&gt; (K, V))F[(K, V)]">map</span><span class="delimiter">(</span><span title="F[V]" class="keyword">if</span><span class="delimiter">(</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex.predicate" title="(v1: K)Boolean">predicate</a><span class="delimiter">(</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.$anonfun.k" title="K">k</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.f" title="(v1: V)F[V]">f</a><span class="delimiter">(</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.$anonfun.v" title="V">v</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="[F[_]](implicit F: scalaz.Applicative[F])scalaz.Applicative[F]">Applicative</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.evidence$1" title="(implicit F: scalaz.Applicative[F])scalaz.Applicative[F]" class="delimiter">[</a><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift;F" title="F">F</a><span class="delimiter">]</span>.<span title="(a: =&gt; V)F[V]">point</span><span class="delimiter">(</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.$anonfun.v" title="V">v</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.$anonfun.k" title="(x: K)ArrowAssoc[K]">k</a> <span title="(y: V)(K, V)">-&gt;</span> <a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.$anonfun.$anonfun.x$2" title="V">_</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.multiLift.$anonfun.x$3" title="List[(K, V)]">_</a>.<span title="(implicit ev: &lt;:&lt;[(K, V),(K, V)])scala.collection.immutable.Map[K,V]">toMap</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
