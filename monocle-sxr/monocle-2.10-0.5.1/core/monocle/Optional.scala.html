<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>core/monocle/Optional.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> monocle

<span class="keyword">import</span> scalaz.<span class="delimiter">{</span>Functor, Applicative<span class="delimiter">}</span>

<span class="comment">/**
 * Optional can be seen as a partial Lens - Lens toward an Option - or
 * a 0-1 Traversal. The latter constraint is not enforce at compile time
 * but by OptionalLaws
 */</span>
<span class="keyword">trait</span> <a title="trait Optional[S, T, A, B] extends AnyRef with monocle.Traversal[S,T,A,B]" id="monocle;Optional">Optional</a><span class="delimiter">[</span><a title="" id="monocle;Optional;S">S</a>, <a title="" id="monocle;Optional;T">T</a>, <a title="" id="monocle;Optional;A">A</a>, <a title="" id="monocle;Optional;B">B</a><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="Traversal.scala.html#monocle;Traversal" title="monocle.Traversal[S,T,A,B]">Traversal</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> <span class="delimiter">{</span> self =&gt;

  <span class="keyword">def</span> <a title="(from: S)Option[A]" id="monocle;Optional.getOption">getOption</a><span class="delimiter">(</span><a title="S" id="monocle;Optional.getOption.from">from</a>: <a href="#monocle;Optional;S" title="S">S</a><span class="delimiter">)</span>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="Fold.scala.html#monocle;Fold.headOption" title="(from: S)Option[A]">headOption</a><span class="delimiter">(</span><a href="#monocle;Optional.getOption.from" title="S">from</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(from: S, f: A =&gt; B)Option[T]" id="monocle;Optional.modifyOption">modifyOption</a><span class="delimiter">(</span><a title="S" id="monocle;Optional.modifyOption.from">from</a>: <a href="#monocle;Optional;S" title="S">S</a>, <a title="A =&gt; B" id="monocle;Optional.modifyOption.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#monocle;Optional.getOption" title="(from: S)Option[A]">getOption</a><span class="delimiter">(</span><a href="#monocle;Optional.modifyOption.from" title="S">from</a><span class="delimiter">)</span>.<span title="(f: A =&gt; T)Option[T]">map</span><span class="delimiter">(</span><a title="A" id="monocle;Optional.modifyOption.$anonfun.a">a</a> =&gt; <a href="Setter.scala.html#monocle;Setter.set" title="(from: S, newValue: B)T">set</a><span class="delimiter">(</span><a href="#monocle;Optional.modifyOption.from" title="S">from</a>, <a href="#monocle;Optional.modifyOption.f" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#monocle;Optional.modifyOption.$anonfun.a" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(f: A =&gt; B)S =&gt; Option[T]" id="monocle;Optional.modifyOptionF">modifyOptionF</a><span class="delimiter">(</span><a title="A =&gt; B" id="monocle;Optional.modifyOptionF.f">f</a>: A =&gt; B<span class="delimiter">)</span>: S =&gt; Option<span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#monocle;Optional.modifyOption" title="(from: S, f: A =&gt; B)Option[T]">modifyOption</a><span class="delimiter">(</span><a href="#monocle;Optional.modifyOptionF.$anonfun.x$1" title="S">_</a>, <a href="#monocle;Optional.modifyOptionF.f" title="A =&gt; B">f</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(from: S, newValue: B)Option[T]" id="monocle;Optional.setOption">setOption</a><span class="delimiter">(</span><a title="S" id="monocle;Optional.setOption.from">from</a>: <a href="#monocle;Optional;S" title="S">S</a>, <a title="B" id="monocle;Optional.setOption.newValue">newValue</a>: <a href="#monocle;Optional;B" title="B">B</a><span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#monocle;Optional.modifyOption" title="(from: S, f: A =&gt; B)Option[T]">modifyOption</a><span class="delimiter">(</span><a href="#monocle;Optional.setOption.from" title="S">from</a>, <a title="A" id="monocle;Optional.setOption.$anonfun.x$2">_</a> =&gt; <a href="#monocle;Optional.setOption.newValue" title="B">newValue</a><span class="delimiter">)</span>

  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(newValue: B)S =&gt; Option[T]" id="monocle;Optional.setOptionF">setOptionF</a><span class="delimiter">(</span><a title="B" id="monocle;Optional.setOptionF.newValue">newValue</a>: <a href="#monocle;Optional;B" title="B">B</a><span class="delimiter">)</span>: S =&gt; Option<span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#monocle;Optional.setOption" title="(from: S, newValue: B)Option[T]">setOption</a><span class="delimiter">(</span><a href="#monocle;Optional.setOptionF.$anonfun.x$3" title="S">_</a>, <a href="#monocle;Optional.setOptionF.newValue" title="B">newValue</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="=&gt; monocle.Optional[S,T,A,B]" id="monocle;Optional.asOptional">asOptional</a>: <a href="#monocle;Optional" title="monocle.Optional[S,T,A,B]">Optional</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> = <a href="#monocle;Optional" title="monocle.Optional[S,T,A,B]">self</a>

  <span class="comment">/** non overloaded compose function */</span>
  <span class="keyword">def</span> <a title="[C, D](other: monocle.Optional[A,B,C,D])monocle.Optional[S,T,C,D]" id="monocle;Optional.composeOptional">composeOptional</a><span class="delimiter">[</span><a title="" id="monocle;Optional.composeOptional;C">C</a>, <a title="" id="monocle;Optional.composeOptional;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Optional[A,B,C,D]" id="monocle;Optional.composeOptional.other">other</a>: <a href="#monocle;Optional" title="monocle.Optional[A,B,C,D]">Optional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle;Optional" title="monocle.Optional[S,T,C,D]">Optional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle;Optional.composeOptional;$anon" title="monocle.Optional[S,T,C,D]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with monocle.Optional[S,T,C,D]" id="monocle;Optional.composeOptional;$anon">Optional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[F[_]](from: S, f: C =&gt; F[D])(implicit evidence$1: scalaz.Applicative[F])F[T]" id="monocle;Optional.composeOptional;$anon.multiLift">multiLift</a><span class="delimiter">[</span><a title="[_]" id="monocle;Optional.composeOptional;$anon.multiLift;F">F</a><span class="delimiter">[</span><a title="" id="monocle;Optional.composeOptional;$anon.multiLift;F;_">_</a><span class="delimiter">]</span> : Applicative<span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="monocle;Optional.composeOptional;$anon.multiLift.from">from</a>: <a href="#monocle;Optional;S" title="S">S</a>, <a title="C =&gt; F[D]" id="monocle;Optional.composeOptional;$anon.multiLift.f">f</a>: C =&gt; F<span class="delimiter">[</span>D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle;Optional.composeOptional;$anon.multiLift;F" title="F[T]">F</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#monocle;Optional" title="Optional.this.type">self</a>.<a href="Traversal.scala.html#monocle;Traversal.multiLift" title="(from: S, f: A =&gt; F[B])(implicit evidence$1: scalaz.Applicative[F])F[T]">multiLift</a><a href="#monocle;Optional.composeOptional;$anon.multiLift.evidence$1" title="scalaz.Applicative[F]" class="delimiter">(</a><a href="#monocle;Optional.composeOptional;$anon.multiLift.from" title="S">from</a>, <a href="#monocle;Optional.composeOptional.other" title="monocle.Optional[A,B,C,D]">other</a>.<a href="Traversal.scala.html#monocle;Traversal.multiLift" title="(from: A, f: C =&gt; F[D])(implicit evidence$1: scalaz.Applicative[F])F[B]">multiLift</a><a href="#monocle;Optional.composeOptional;$anon.multiLift.evidence$1" title="scalaz.Applicative[F]" class="delimiter">(</a><a href="#monocle;Optional.composeOptional;$anon.multiLift.$anonfun.x$4" title="A">_</a>, <a href="#monocle;Optional.composeOptional;$anon.multiLift.f" title="C =&gt; F[D]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use composeOptional&quot;</span>, since = <span class="string">&quot;0.5&quot;</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[C, D](other: monocle.Optional[A,B,C,D])monocle.Optional[S,T,C,D]" id="monocle;Optional.compose(9812f5ed16)">compose</a><span class="delimiter">[</span><a title="" id="monocle;Optional.compose(9812f5ed16);C">C</a>, <a title="" id="monocle;Optional.compose(9812f5ed16);D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Optional[A,B,C,D]" id="monocle;Optional.compose(9812f5ed16).other">other</a>: <a href="#monocle;Optional" title="monocle.Optional[A,B,C,D]">Optional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle;Optional" title="monocle.Optional[S,T,C,D]">Optional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle;Optional.composeOptional" title="(other: monocle.Optional[A,B,C,D])monocle.Optional[S,T,C,D]">composeOptional</a><span class="delimiter">(</span><a href="#monocle;Optional.compose(9812f5ed16).other" title="monocle.Optional[A,B,C,D]">other</a><span class="delimiter">)</span>

<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="monocle.Optional.type" id="monocle.Optional">Optional</a> <a href="#monocle.Optional" title="monocle.Optional.type" class="delimiter">{</a>

  <span class="keyword">def</span> <a title="[S, T, A, B](_getOption: S =&gt; Option[A], _set: (S, Option[B]) =&gt; T)monocle.Optional[S,T,A,B]" id="monocle.Optional.apply">apply</a><span class="delimiter">[</span><a title="" id="monocle.Optional.apply;S">S</a>, <a title="" id="monocle.Optional.apply;T">T</a>, <a title="" id="monocle.Optional.apply;A">A</a>, <a title="" id="monocle.Optional.apply;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; Option[A]" id="monocle.Optional.apply._getOption">_getOption</a>: S =&gt; Option<span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="(S, Option[B]) =&gt; T" id="monocle.Optional.apply._set">_set</a>: <span class="delimiter">(</span>S, Option<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; T<span class="delimiter">)</span>: <a href="#monocle;Optional" title="monocle.Optional[S,T,A,B]">Optional</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> = <a href="#monocle.Optional.apply;$anon" title="monocle.Optional[S,T,A,B]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with monocle.Optional[S,T,A,B]" id="monocle.Optional.apply;$anon">Optional</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">import</span> scalaz.syntax.<span title="scalaz.syntax.traverse.type">traverse</span>._
    <span class="keyword">import</span> scalaz.std.<span title="scalaz.std.option.type">option</span>._
    <span class="keyword">def</span> <a title="[F[_]](from: S, f: A =&gt; F[B])(implicit evidence$2: scalaz.Applicative[F])F[T]" id="monocle.Optional.apply;$anon.multiLift">multiLift</a><span class="delimiter">[</span><a title="[_]" id="monocle.Optional.apply;$anon.multiLift;F">F</a><span class="delimiter">[</span><a title="" id="monocle.Optional.apply;$anon.multiLift;F;_">_</a><span class="delimiter">]</span> : Applicative<span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="monocle.Optional.apply;$anon.multiLift.from">from</a>: <a href="#monocle.Optional.apply;S" title="S">S</a>, <a title="A =&gt; F[B]" id="monocle.Optional.apply;$anon.multiLift.f">f</a>: A =&gt; F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.Optional.apply;$anon.multiLift;F" title="F[T]">F</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
     <span title="[F[_]](implicit F: scalaz.Functor[F])scalaz.Functor[F]">Functor</span><a href="#monocle.Optional.apply;$anon.multiLift.evidence$2" title="(implicit F: scalaz.Functor[F])scalaz.Functor[F]" class="delimiter">[</a><a href="#monocle.Optional.apply;$anon.multiLift;F" title="F">F</a><span class="delimiter">]</span>.<span title="(fa: F[Option[B]])(f: Option[B] =&gt; T)F[T]">map</span><span class="delimiter">(</span><a href="#monocle.Optional.apply._getOption" title="(v1: S)Option[A]">_getOption</a><span class="delimiter">(</span><a href="#monocle.Optional.apply;$anon.multiLift.from" title="S">from</a><span class="delimiter">)</span>.<span title="(f: A =&gt; F[B])Option[F[B]]">map</span><span title="(v: Option[F[B]])(implicit F0: scalaz.Traverse[Option])scalaz.syntax.TraverseOps[Option,F[B]]" class="delimiter">(</span><a href="#monocle.Optional.apply;$anon.multiLift.f" title="A =&gt; F[B]">f</a><span class="delimiter">)</span>.<a href="#monocle.Optional.apply;$anon.multiLift.evidence$2" title="(implicit ev: scalaz.Leibniz.===[F[B],F[B]], implicit G: scalaz.Applicative[F])F[Option[B]]">sequence</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.Optional.apply._set" title="(v1: S, v2: Option[B])T">_set</a><span class="delimiter">(</span><a href="#monocle.Optional.apply;$anon.multiLift.from" title="S">from</a>, <a href="#monocle.Optional.apply;$anon.multiLift.$anonfun.x$5" title="Option[B]">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
