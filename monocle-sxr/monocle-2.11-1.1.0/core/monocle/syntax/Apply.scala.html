<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>core/monocle/syntax/Apply.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package monocle.syntax

import monocle._

import scalaz.<span class="delimiter">{</span>Maybe, IList, Monoid<span class="delimiter">}</span>
import scalaz.syntax.std.<span title="scalaz.syntax.std.option.type">option</span>._

object <a title="monocle.syntax.apply.type" id="monocle.syntax.apply">apply</a> extends <a href="#monocle.syntax;ApplySyntax" title="monocle.syntax.ApplySyntax">ApplySyntax</a>

trait <a title="trait ApplySyntax extends AnyRef" id="monocle.syntax;ApplySyntax">ApplySyntax</a> <span title="Unit" class="delimiter">{</span>
  implicit def <a title="[S](value: S)monocle.syntax.ApplyFoldOps[S]" id="monocle.syntax;ApplySyntax.toApplyFoldOps">toApplyFoldOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySyntax.toApplyFoldOps;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="monocle.syntax;ApplySyntax.toApplyFoldOps.value">value</a>: <a href="#monocle.syntax;ApplySyntax.toApplyFoldOps;S" title="S">S</a><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFoldOps.readResolve" title="monocle.syntax.ApplyFoldOps[S]">ApplyFoldOps</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = new <a href="#monocle.syntax.ApplyFoldOps.readResolve" title="monocle.syntax.ApplyFoldOps[S]">ApplyFoldOps</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySyntax.toApplyFoldOps.value" title="S">value</a><span class="delimiter">)</span>
  implicit def <a title="[S](value: S)monocle.syntax.ApplyGetterOps[S]" id="monocle.syntax;ApplySyntax.toApplyGetterOps">toApplyGetterOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySyntax.toApplyGetterOps;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="monocle.syntax;ApplySyntax.toApplyGetterOps.value">value</a>: <a href="#monocle.syntax;ApplySyntax.toApplyGetterOps;S" title="S">S</a><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyGetterOps.readResolve" title="monocle.syntax.ApplyGetterOps[S]">ApplyGetterOps</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = new <a href="#monocle.syntax.ApplyGetterOps.readResolve" title="monocle.syntax.ApplyGetterOps[S]">ApplyGetterOps</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySyntax.toApplyGetterOps.value" title="S">value</a><span class="delimiter">)</span>
  implicit def <a title="[S](value: S)monocle.syntax.ApplyIsoOps[S]" id="monocle.syntax;ApplySyntax.toApplyIsoOps">toApplyIsoOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySyntax.toApplyIsoOps;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="monocle.syntax;ApplySyntax.toApplyIsoOps.value">value</a>: <a href="#monocle.syntax;ApplySyntax.toApplyIsoOps;S" title="S">S</a><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyIsoOps.readResolve" title="monocle.syntax.ApplyIsoOps[S]">ApplyIsoOps</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = new <a href="#monocle.syntax.ApplyIsoOps.readResolve" title="monocle.syntax.ApplyIsoOps[S]">ApplyIsoOps</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySyntax.toApplyIsoOps.value" title="S">value</a><span class="delimiter">)</span>
  implicit def <a title="[S](value: S)monocle.syntax.ApplyLensOps[S]" id="monocle.syntax;ApplySyntax.toApplyLensOps">toApplyLensOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySyntax.toApplyLensOps;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="monocle.syntax;ApplySyntax.toApplyLensOps.value">value</a>: <a href="#monocle.syntax;ApplySyntax.toApplyLensOps;S" title="S">S</a><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyLensOps.readResolve" title="monocle.syntax.ApplyLensOps[S]">ApplyLensOps</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = new <a href="#monocle.syntax.ApplyLensOps.readResolve" title="monocle.syntax.ApplyLensOps[S]">ApplyLensOps</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySyntax.toApplyLensOps.value" title="S">value</a><span class="delimiter">)</span>
  implicit def <a title="[S](value: S)monocle.syntax.ApplyOptionalOps[S]" id="monocle.syntax;ApplySyntax.toApplyOptionalOps">toApplyOptionalOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySyntax.toApplyOptionalOps;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="monocle.syntax;ApplySyntax.toApplyOptionalOps.value">value</a>: <a href="#monocle.syntax;ApplySyntax.toApplyOptionalOps;S" title="S">S</a><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptionalOps.readResolve" title="monocle.syntax.ApplyOptionalOps[S]">ApplyOptionalOps</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = new <a href="#monocle.syntax.ApplyOptionalOps.readResolve" title="monocle.syntax.ApplyOptionalOps[S]">ApplyOptionalOps</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySyntax.toApplyOptionalOps.value" title="S">value</a><span class="delimiter">)</span>
  implicit def <a title="[S](value: S)monocle.syntax.ApplyPrismOps[S]" id="monocle.syntax;ApplySyntax.toApplyPrismOps">toApplyPrismOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySyntax.toApplyPrismOps;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="monocle.syntax;ApplySyntax.toApplyPrismOps.value">value</a>: <a href="#monocle.syntax;ApplySyntax.toApplyPrismOps;S" title="S">S</a><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyPrismOps.readResolve" title="monocle.syntax.ApplyPrismOps[S]">ApplyPrismOps</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = new <a href="#monocle.syntax.ApplyPrismOps.readResolve" title="monocle.syntax.ApplyPrismOps[S]">ApplyPrismOps</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySyntax.toApplyPrismOps.value" title="S">value</a><span class="delimiter">)</span>
  implicit def <a title="[S](value: S)monocle.syntax.ApplySetterOps[S]" id="monocle.syntax;ApplySyntax.toApplySetterOps">toApplySetterOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySyntax.toApplySetterOps;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="monocle.syntax;ApplySyntax.toApplySetterOps.value">value</a>: <a href="#monocle.syntax;ApplySyntax.toApplySetterOps;S" title="S">S</a><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetterOps.readResolve" title="monocle.syntax.ApplySetterOps[S]">ApplySetterOps</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = new <a href="#monocle.syntax.ApplySetterOps.readResolve" title="monocle.syntax.ApplySetterOps[S]">ApplySetterOps</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySyntax.toApplySetterOps.value" title="S">value</a><span class="delimiter">)</span>
  implicit def <a title="[S](value: S)monocle.syntax.ApplyTraversalOps[S]" id="monocle.syntax;ApplySyntax.toApplyTraversalOps">toApplyTraversalOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySyntax.toApplyTraversalOps;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="monocle.syntax;ApplySyntax.toApplyTraversalOps.value">value</a>: <a href="#monocle.syntax;ApplySyntax.toApplyTraversalOps;S" title="S">S</a><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversalOps.readResolve" title="monocle.syntax.ApplyTraversalOps[S]">ApplyTraversalOps</a><span class="delimiter">[</span>S<span class="delimiter">]</span> = new <a href="#monocle.syntax.ApplyTraversalOps.readResolve" title="monocle.syntax.ApplyTraversalOps[S]">ApplyTraversalOps</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySyntax.toApplyTraversalOps.value" title="S">value</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final case class <a href="#monocle.syntax;ApplyFoldOps.productElement.x$1" title="class ApplyFoldOps[S] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplyFoldOps.readResolve">ApplyFoldOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFoldOps;S">S</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplyFoldOps.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplyFoldOps.s">s</a>: <a href="#monocle.syntax;ApplyFoldOps;S" title="S">S</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[A](fold: monocle.Fold[S,A])monocle.syntax.ApplyFold[S,A]" id="monocle.syntax;ApplyFoldOps.applyFold">applyFold</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFoldOps.applyFold;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Fold[S,A]" id="monocle.syntax;ApplyFoldOps.applyFold.fold">fold</a>: <a href="../Fold.scala.html#monocle;Fold" title="monocle.Fold[S,A]">Fold</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,A]">ApplyFold</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> = new <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,A]">ApplyFold</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFoldOps.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyFoldOps.applyFold.fold" title="monocle.Fold[S,A]">fold</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final case class <a href="#monocle.syntax;ApplyGetterOps.productElement.x$1" title="class ApplyGetterOps[S] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplyGetterOps.readResolve">ApplyGetterOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyGetterOps;S">S</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplyGetterOps.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplyGetterOps.s">s</a>: <a href="#monocle.syntax;ApplyGetterOps;S" title="S">S</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[A](getter: monocle.Getter[S,A])monocle.syntax.ApplyGetter[S,A]" id="monocle.syntax;ApplyGetterOps.applyGetter">applyGetter</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyGetterOps.applyGetter;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Getter[S,A]" id="monocle.syntax;ApplyGetterOps.applyGetter.getter">getter</a>: <a href="../Getter.scala.html#monocle;Getter" title="monocle.Getter[S,A]">Getter</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyGetter.readResolve" title="monocle.syntax.ApplyGetter[S,A]">ApplyGetter</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> = new <a href="#monocle.syntax.ApplyGetter.readResolve" title="monocle.syntax.ApplyGetter[S,A]">ApplyGetter</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyGetterOps.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyGetterOps.applyGetter.getter" title="monocle.Getter[S,A]">getter</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final case class <a href="#monocle.syntax;ApplyIsoOps.productElement.x$1" title="class ApplyIsoOps[S] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplyIsoOps.readResolve">ApplyIsoOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIsoOps;S">S</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplyIsoOps.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplyIsoOps.s">s</a>: <a href="#monocle.syntax;ApplyIsoOps;S" title="S">S</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  @inline def <a title="[T, A, B](iso: monocle.PIso[S,T,A,B])monocle.syntax.ApplyIso[S,T,A,B]" id="monocle.syntax;ApplyIsoOps.applyIso">applyIso</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIsoOps.applyIso;T">T</a>, <a title="" id="monocle.syntax;ApplyIsoOps.applyIso;A">A</a>, <a title="" id="monocle.syntax;ApplyIsoOps.applyIso;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[S,T,A,B]" id="monocle.syntax;ApplyIsoOps.applyIso.iso">iso</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[S,T,A,B]">PIso</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyIso.readResolve" title="monocle.syntax.ApplyIso[S,T,A,B]">ApplyIso</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyIso.readResolve" title="[S, T, A, B](s: S, iso: monocle.PIso[S,T,A,B])monocle.syntax.ApplyIso[S,T,A,B]">ApplyIso</a><span title="(s: S, iso: monocle.PIso[S,T,A,B])monocle.syntax.ApplyIso[S,T,A,B]" class="delimiter">[</span><a href="#monocle.syntax;ApplyIsoOps;S" title="S">S</a>, <a href="#monocle.syntax;ApplyIsoOps.applyIso;T" title="T">T</a>, <a href="#monocle.syntax;ApplyIsoOps.applyIso;A" title="A">A</a>, <a href="#monocle.syntax;ApplyIsoOps.applyIso;B" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIsoOps.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyIsoOps.applyIso.iso" title="monocle.PIso[S,T,A,B]">iso</a><span class="delimiter">)</span>
  <span class="comment">/** alias to applyIso */</span>
  @inline def <a title="[T, A, B](iso: monocle.PIso[S,T,A,B])monocle.syntax.ApplyIso[S,T,A,B]" id="monocle.syntax;ApplyIsoOps.&<->">&amp;&lt;-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIsoOps.&<->;T">T</a>, <a title="" id="monocle.syntax;ApplyIsoOps.&<->;A">A</a>, <a title="" id="monocle.syntax;ApplyIsoOps.&<->;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[S,T,A,B]" id="monocle.syntax;ApplyIsoOps.&<->.iso">iso</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[S,T,A,B]">PIso</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyIso.readResolve" title="monocle.syntax.ApplyIso[S,T,A,B]">ApplyIso</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyIsoOps.applyIso" title="(iso: monocle.PIso[S,T,A,B])monocle.syntax.ApplyIso[S,T,A,B]">applyIso</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIsoOps.&<->.iso" title="monocle.PIso[S,T,A,B]">iso</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final case class <a href="#monocle.syntax;ApplyLensOps.productElement.x$1" title="class ApplyLensOps[S] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplyLensOps.readResolve">ApplyLensOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLensOps;S">S</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplyLensOps.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplyLensOps.s">s</a>: <a href="#monocle.syntax;ApplyLensOps;S" title="S">S</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[T, A, B](lens: monocle.PLens[S,T,A,B])monocle.syntax.ApplyLens[S,T,A,B]" id="monocle.syntax;ApplyLensOps.applyLens">applyLens</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLensOps.applyLens;T">T</a>, <a title="" id="monocle.syntax;ApplyLensOps.applyLens;A">A</a>, <a title="" id="monocle.syntax;ApplyLensOps.applyLens;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[S,T,A,B]" id="monocle.syntax;ApplyLensOps.applyLens.lens">lens</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[S,T,A,B]">PLens</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyLens.readResolve" title="monocle.syntax.ApplyLens[S,T,A,B]">ApplyLens</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyLens.readResolve" title="[S, T, A, B](s: S, lens: monocle.PLens[S,T,A,B])monocle.syntax.ApplyLens[S,T,A,B]">ApplyLens</a><span title="(s: S, lens: monocle.PLens[S,T,A,B])monocle.syntax.ApplyLens[S,T,A,B]" class="delimiter">[</span><a href="#monocle.syntax;ApplyLensOps;S" title="S">S</a>, <a href="#monocle.syntax;ApplyLensOps.applyLens;T" title="T">T</a>, <a href="#monocle.syntax;ApplyLensOps.applyLens;A" title="A">A</a>, <a href="#monocle.syntax;ApplyLensOps.applyLens;B" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLensOps.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyLensOps.applyLens.lens" title="monocle.PLens[S,T,A,B]">lens</a><span class="delimiter">)</span>
  <span class="comment">/** alias to applyLens */</span>
  def <a title="[T, A, B](lens: monocle.PLens[S,T,A,B])monocle.syntax.ApplyLens[S,T,A,B]" id="monocle.syntax;ApplyLensOps.&|->">&amp;|-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLensOps.&|->;T">T</a>, <a title="" id="monocle.syntax;ApplyLensOps.&|->;A">A</a>, <a title="" id="monocle.syntax;ApplyLensOps.&|->;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[S,T,A,B]" id="monocle.syntax;ApplyLensOps.&|->.lens">lens</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[S,T,A,B]">PLens</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyLens.readResolve" title="monocle.syntax.ApplyLens[S,T,A,B]">ApplyLens</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyLensOps.applyLens" title="(lens: monocle.PLens[S,T,A,B])monocle.syntax.ApplyLens[S,T,A,B]">applyLens</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLensOps.&|->.lens" title="monocle.PLens[S,T,A,B]">lens</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final case class <a href="#monocle.syntax;ApplyOptionalOps.productElement.x$1" title="class ApplyOptionalOps[S] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplyOptionalOps.readResolve">ApplyOptionalOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptionalOps;S">S</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplyOptionalOps.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplyOptionalOps.s">s</a>: <a href="#monocle.syntax;ApplyOptionalOps;S" title="S">S</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[T, A, B](optional: monocle.POptional[S,T,A,B])monocle.syntax.ApplyOptional[S,T,A,B]" id="monocle.syntax;ApplyOptionalOps.applyOptional">applyOptional</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptionalOps.applyOptional;T">T</a>, <a title="" id="monocle.syntax;ApplyOptionalOps.applyOptional;A">A</a>, <a title="" id="monocle.syntax;ApplyOptionalOps.applyOptional;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[S,T,A,B]" id="monocle.syntax;ApplyOptionalOps.applyOptional.optional">optional</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[S,T,A,B]">POptional</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,A,B]">ApplyOptional</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyOptional.readResolve" title="[S, T, A, B](s: S, optional: monocle.POptional[S,T,A,B])monocle.syntax.ApplyOptional[S,T,A,B]">ApplyOptional</a><span title="(s: S, optional: monocle.POptional[S,T,A,B])monocle.syntax.ApplyOptional[S,T,A,B]" class="delimiter">[</span><a href="#monocle.syntax;ApplyOptionalOps;S" title="S">S</a>, <a href="#monocle.syntax;ApplyOptionalOps.applyOptional;T" title="T">T</a>, <a href="#monocle.syntax;ApplyOptionalOps.applyOptional;A" title="A">A</a>, <a href="#monocle.syntax;ApplyOptionalOps.applyOptional;B" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptionalOps.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyOptionalOps.applyOptional.optional" title="monocle.POptional[S,T,A,B]">optional</a><span class="delimiter">)</span>
  <span class="comment">/** alias to applyOptional */</span>
  def <a title="[T, A, B](optional: monocle.POptional[S,T,A,B])monocle.syntax.ApplyOptional[S,T,A,B]" id="monocle.syntax;ApplyOptionalOps.&|-?">&amp;|-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptionalOps.&|-?;T">T</a>, <a title="" id="monocle.syntax;ApplyOptionalOps.&|-?;A">A</a>, <a title="" id="monocle.syntax;ApplyOptionalOps.&|-?;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[S,T,A,B]" id="monocle.syntax;ApplyOptionalOps.&|-?.optional">optional</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[S,T,A,B]">POptional</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,A,B]">ApplyOptional</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyOptionalOps.applyOptional" title="(optional: monocle.POptional[S,T,A,B])monocle.syntax.ApplyOptional[S,T,A,B]">applyOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptionalOps.&|-?.optional" title="monocle.POptional[S,T,A,B]">optional</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final case class <a href="#monocle.syntax;ApplyPrismOps.productElement.x$1" title="class ApplyPrismOps[S] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplyPrismOps.readResolve">ApplyPrismOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrismOps;S">S</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplyPrismOps.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplyPrismOps.s">s</a>: <a href="#monocle.syntax;ApplyPrismOps;S" title="S">S</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[T, A, B](prism: monocle.PPrism[S,T,A,B])monocle.syntax.ApplyPrism[S,T,A,B]" id="monocle.syntax;ApplyPrismOps.applyPrism">applyPrism</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrismOps.applyPrism;T">T</a>, <a title="" id="monocle.syntax;ApplyPrismOps.applyPrism;A">A</a>, <a title="" id="monocle.syntax;ApplyPrismOps.applyPrism;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[S,T,A,B]" id="monocle.syntax;ApplyPrismOps.applyPrism.prism">prism</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[S,T,A,B]">PPrism</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyPrism.readResolve" title="monocle.syntax.ApplyPrism[S,T,A,B]">ApplyPrism</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyPrism.readResolve" title="[S, T, A, B](s: S, prism: monocle.PPrism[S,T,A,B])monocle.syntax.ApplyPrism[S,T,A,B]">ApplyPrism</a><span title="(s: S, prism: monocle.PPrism[S,T,A,B])monocle.syntax.ApplyPrism[S,T,A,B]" class="delimiter">[</span><a href="#monocle.syntax;ApplyPrismOps;S" title="S">S</a>, <a href="#monocle.syntax;ApplyPrismOps.applyPrism;T" title="T">T</a>, <a href="#monocle.syntax;ApplyPrismOps.applyPrism;A" title="A">A</a>, <a href="#monocle.syntax;ApplyPrismOps.applyPrism;B" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrismOps.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyPrismOps.applyPrism.prism" title="monocle.PPrism[S,T,A,B]">prism</a><span class="delimiter">)</span>
  <span class="comment">/** alias to applyPrism */</span>
  def <a title="[T, A, B](prism: monocle.PPrism[S,T,A,B])monocle.syntax.ApplyPrism[S,T,A,B]" id="monocle.syntax;ApplyPrismOps.&<-?">&amp;&lt;-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrismOps.&<-?;T">T</a>, <a title="" id="monocle.syntax;ApplyPrismOps.&<-?;A">A</a>, <a title="" id="monocle.syntax;ApplyPrismOps.&<-?;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[S,T,A,B]" id="monocle.syntax;ApplyPrismOps.&<-?.prism">prism</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[S,T,A,B]">PPrism</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyPrism.readResolve" title="monocle.syntax.ApplyPrism[S,T,A,B]">ApplyPrism</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyPrismOps.applyPrism" title="(prism: monocle.PPrism[S,T,A,B])monocle.syntax.ApplyPrism[S,T,A,B]">applyPrism</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrismOps.&<-?.prism" title="monocle.PPrism[S,T,A,B]">prism</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final case class <a href="#monocle.syntax;ApplySetterOps.productElement.x$1" title="class ApplySetterOps[S] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplySetterOps.readResolve">ApplySetterOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySetterOps;S">S</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplySetterOps.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplySetterOps.s">s</a>: <a href="#monocle.syntax;ApplySetterOps;S" title="S">S</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[T, A, B](setter: monocle.PSetter[S,T,A,B])monocle.syntax.ApplySetter[S,T,A,B]" id="monocle.syntax;ApplySetterOps.applySetter">applySetter</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySetterOps.applySetter;T">T</a>, <a title="" id="monocle.syntax;ApplySetterOps.applySetter;A">A</a>, <a title="" id="monocle.syntax;ApplySetterOps.applySetter;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PSetter[S,T,A,B]" id="monocle.syntax;ApplySetterOps.applySetter.setter">setter</a>: <a href="../Setter.scala.html#monocle;PSetter" title="monocle.PSetter[S,T,A,B]">PSetter</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,A,B]">ApplySetter</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> = new <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,A,B]">ApplySetter</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplySetterOps.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplySetterOps.applySetter.setter" title="monocle.PSetter[S,T,A,B]">setter</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final case class <a href="#monocle.syntax;ApplyTraversalOps.productElement.x$1" title="class ApplyTraversalOps[S] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplyTraversalOps.readResolve">ApplyTraversalOps</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversalOps;S">S</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplyTraversalOps.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplyTraversalOps.s">s</a>: <a href="#monocle.syntax;ApplyTraversalOps;S" title="S">S</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="[T, A, B](traversal: monocle.PTraversal[S,T,A,B])monocle.syntax.ApplyTraversal[S,T,A,B]" id="monocle.syntax;ApplyTraversalOps.applyTraversal">applyTraversal</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversalOps.applyTraversal;T">T</a>, <a title="" id="monocle.syntax;ApplyTraversalOps.applyTraversal;A">A</a>, <a title="" id="monocle.syntax;ApplyTraversalOps.applyTraversal;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[S,T,A,B]" id="monocle.syntax;ApplyTraversalOps.applyTraversal.traversal">traversal</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[S,T,A,B]">PTraversal</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,A,B]">ApplyTraversal</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyTraversal.readResolve" title="[S, T, A, B](s: S, traversal: monocle.PTraversal[S,T,A,B])monocle.syntax.ApplyTraversal[S,T,A,B]">ApplyTraversal</a><span title="(s: S, traversal: monocle.PTraversal[S,T,A,B])monocle.syntax.ApplyTraversal[S,T,A,B]" class="delimiter">[</span><a href="#monocle.syntax;ApplyTraversalOps;S" title="S">S</a>, <a href="#monocle.syntax;ApplyTraversalOps.applyTraversal;T" title="T">T</a>, <a href="#monocle.syntax;ApplyTraversalOps.applyTraversal;A" title="A">A</a>, <a href="#monocle.syntax;ApplyTraversalOps.applyTraversal;B" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversalOps.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyTraversalOps.applyTraversal.traversal" title="monocle.PTraversal[S,T,A,B]">traversal</a><span class="delimiter">)</span>
  <span class="comment">/** alias to applyTraversal */</span>
  def <a title="[T, A, B](traversal: monocle.PTraversal[S,T,A,B])monocle.syntax.ApplyTraversal[S,T,A,B]" id="monocle.syntax;ApplyTraversalOps.&|->>">&amp;|-&gt;&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversalOps.&|->>;T">T</a>, <a title="" id="monocle.syntax;ApplyTraversalOps.&|->>;A">A</a>, <a title="" id="monocle.syntax;ApplyTraversalOps.&|->>;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[S,T,A,B]" id="monocle.syntax;ApplyTraversalOps.&|->>.traversal">traversal</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[S,T,A,B]">PTraversal</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,A,B]">ApplyTraversal</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyTraversalOps.applyTraversal" title="(traversal: monocle.PTraversal[S,T,A,B])monocle.syntax.ApplyTraversal[S,T,A,B]">applyTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversalOps.&|->>.traversal" title="monocle.PTraversal[S,T,A,B]">traversal</a><span class="delimiter">)</span>
<span class="delimiter">}</span>


case class <a href="#monocle.syntax;ApplyFold.productElement.x$1" title="class ApplyFold[S, A] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplyFold.readResolve">ApplyFold</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFold;S">S</a>, <a title="" id="monocle.syntax;ApplyFold;A">A</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplyFold.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplyFold.s">s</a>: <a href="#monocle.syntax;ApplyFold;S" title="S">S</a>, <a title="monocle.Fold[S,A]" id="monocle.syntax;ApplyFold._fold">_fold</a>: <a href="../Fold.scala.html#monocle;Fold" title="monocle.Fold[S,A]">Fold</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  @inline def <a title="[M](f: A =&gt; M)(implicit evidence$1: scalaz.Monoid[M])M" id="monocle.syntax;ApplyFold.foldMap">foldMap</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFold.foldMap;M">M</a>: Monoid<span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; M" id="monocle.syntax;ApplyFold.foldMap.f">f</a>: A =&gt; M<span class="delimiter">)</span>: <a href="#monocle.syntax;ApplyFold.foldMap;M" title="M">M</a> = <a href="#monocle.syntax;ApplyFold._fold" title="=&gt; monocle.Fold[S,A]">_fold</a>.<a href="../Fold.scala.html#monocle;Fold.foldMap" title="(f: A =&gt; M)(s: S)(implicit evidence$1: scalaz.Monoid[M])M">foldMap</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.foldMap.f" title="A =&gt; M">f</a><span class="delimiter">)</span><a href="#monocle.syntax;ApplyFold.foldMap.evidence$1" title="scalaz.Monoid[M]" class="delimiter">(</a><a href="#monocle.syntax;ApplyFold.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @inline def <a title="=&gt; List[A]" id="monocle.syntax;ApplyFold.getAll">getAll</a>: <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyFold._fold" title="=&gt; monocle.Fold[S,A]">_fold</a>.<a href="../Fold.scala.html#monocle;Fold.getAll" title="(s: S)List[A]">getAll</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.s" title="=&gt; S">s</a><span class="delimiter">)</span>
  @inline def <a title="=&gt; Option[A]" id="monocle.syntax;ApplyFold.headOption">headOption</a>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyFold._fold" title="=&gt; monocle.Fold[S,A]">_fold</a>.<a href="../Fold.scala.html#monocle;Fold.headOption" title="(s: S)Option[A]">headOption</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @inline def <a title="(p: A =&gt; Boolean)Boolean" id="monocle.syntax;ApplyFold.exist">exist</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="monocle.syntax;ApplyFold.exist.p">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#monocle.syntax;ApplyFold._fold" title="=&gt; monocle.Fold[S,A]">_fold</a>.<a href="../Fold.scala.html#monocle;Fold.exist" title="(p: A =&gt; Boolean)(s: S)Boolean">exist</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.exist.p" title="A =&gt; Boolean">p</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.s" title="=&gt; S">s</a><span class="delimiter">)</span>
  @inline def <a title="(p: A =&gt; Boolean)Boolean" id="monocle.syntax;ApplyFold.all">all</a><span class="delimiter">(</span><a title="A =&gt; Boolean" id="monocle.syntax;ApplyFold.all.p">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#monocle.syntax;ApplyFold._fold" title="=&gt; monocle.Fold[S,A]">_fold</a>.<a href="../Fold.scala.html#monocle;Fold.all" title="(p: A =&gt; Boolean)(s: S)Boolean">all</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.all.p" title="A =&gt; Boolean">p</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;use headOption&quot;</span>, since = <span class="string">&quot;1.1.0&quot;</span><span class="delimiter">)</span>
  @inline def <a title="=&gt; scalaz.Maybe[A]" id="monocle.syntax;ApplyFold.headMaybe">headMaybe</a>: <span title="scalaz.Maybe[A]">Maybe</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyFold._fold" title="=&gt; monocle.Fold[S,A]">_fold</a>.<a href="../Fold.scala.html#monocle;Fold.headOption" title="(s: S)Option[A]">headOption</a><span title="(a: Option[A])scalaz.syntax.std.OptionOps[A]" class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.s" title="=&gt; S">s</a><span class="delimiter">)</span>.<span title="=&gt; scalaz.Maybe[A]">toMaybe</span>

  @inline def <a title="[B](other: monocle.Fold[A,B])monocle.syntax.ApplyFold[S,B]" id="monocle.syntax;ApplyFold.composeFold">composeFold</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFold.composeFold;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Fold[A,B]" id="monocle.syntax;ApplyFold.composeFold.other">other</a>: <a href="../Fold.scala.html#monocle;Fold" title="monocle.Fold[A,B]">Fold</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,B]">ApplyFold</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyFold.readResolve" title="(s: S, _fold: monocle.Fold[S,B])monocle.syntax.ApplyFold[S,B]">ApplyFold</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyFold._fold" title="=&gt; monocle.Fold[S,A]">_fold</a> <a href="../Fold.scala.html#monocle;Fold.composeFold" title="(other: monocle.Fold[A,B])monocle.Fold[S,B]">composeFold</a> <a href="#monocle.syntax;ApplyFold.composeFold.other" title="monocle.Fold[A,B]">other</a><span class="delimiter">)</span>
  @inline def <a title="[B](other: monocle.Getter[A,B])monocle.syntax.ApplyFold[S,B]" id="monocle.syntax;ApplyFold.composeGetter">composeGetter</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFold.composeGetter;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Getter[A,B]" id="monocle.syntax;ApplyFold.composeGetter.other">other</a>: <a href="../Getter.scala.html#monocle;Getter" title="monocle.Getter[A,B]">Getter</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,B]">ApplyFold</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyFold.readResolve" title="(s: S, _fold: monocle.Fold[S,B])monocle.syntax.ApplyFold[S,B]">ApplyFold</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyFold._fold" title="=&gt; monocle.Fold[S,A]">_fold</a> <a href="../Fold.scala.html#monocle;Fold.composeGetter" title="(other: monocle.Getter[A,B])monocle.Fold[S,B]">composeGetter</a> <a href="#monocle.syntax;ApplyFold.composeGetter.other" title="monocle.Getter[A,B]">other</a><span class="delimiter">)</span>
  @inline def <a title="[B, C, D](other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyFold.composeTraversal">composeTraversal</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFold.composeTraversal;B">B</a>, <a title="" id="monocle.syntax;ApplyFold.composeTraversal;C">C</a>, <a title="" id="monocle.syntax;ApplyFold.composeTraversal;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[A,B,C,D]" id="monocle.syntax;ApplyFold.composeTraversal.other">other</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[A,B,C,D]">PTraversal</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyFold.readResolve" title="(s: S, _fold: monocle.Fold[S,C])monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyFold._fold" title="=&gt; monocle.Fold[S,A]">_fold</a> <a href="../Fold.scala.html#monocle;Fold.composeTraversal" title="(other: monocle.PTraversal[A,B,C,D])monocle.Fold[S,C]">composeTraversal</a> <a href="#monocle.syntax;ApplyFold.composeTraversal.other" title="monocle.PTraversal[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[B, C, D](other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyFold.composeOptional">composeOptional</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFold.composeOptional;B">B</a>, <a title="" id="monocle.syntax;ApplyFold.composeOptional;C">C</a>, <a title="" id="monocle.syntax;ApplyFold.composeOptional;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[A,B,C,D]" id="monocle.syntax;ApplyFold.composeOptional.other">other</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[A,B,C,D]">POptional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyFold.readResolve" title="(s: S, _fold: monocle.Fold[S,C])monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyFold._fold" title="=&gt; monocle.Fold[S,A]">_fold</a> <a href="../Fold.scala.html#monocle;Fold.composeOptional" title="(other: monocle.POptional[A,B,C,D])monocle.Fold[S,C]">composeOptional</a> <a href="#monocle.syntax;ApplyFold.composeOptional.other" title="monocle.POptional[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[B, C, D](other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyFold.composePrism">composePrism</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFold.composePrism;B">B</a>, <a title="" id="monocle.syntax;ApplyFold.composePrism;C">C</a>, <a title="" id="monocle.syntax;ApplyFold.composePrism;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[A,B,C,D]" id="monocle.syntax;ApplyFold.composePrism.other">other</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[A,B,C,D]">PPrism</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyFold.readResolve" title="(s: S, _fold: monocle.Fold[S,C])monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyFold._fold" title="=&gt; monocle.Fold[S,A]">_fold</a> <a href="../Fold.scala.html#monocle;Fold.composePrism" title="(other: monocle.PPrism[A,B,C,D])monocle.Fold[S,C]">composePrism</a> <a href="#monocle.syntax;ApplyFold.composePrism.other" title="monocle.PPrism[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[B, C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyFold.composeLens">composeLens</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFold.composeLens;B">B</a>, <a title="" id="monocle.syntax;ApplyFold.composeLens;C">C</a>, <a title="" id="monocle.syntax;ApplyFold.composeLens;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplyFold.composeLens.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyFold.readResolve" title="(s: S, _fold: monocle.Fold[S,C])monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyFold._fold" title="=&gt; monocle.Fold[S,A]">_fold</a> <a href="../Fold.scala.html#monocle;Fold.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.Fold[S,C]">composeLens</a> <a href="#monocle.syntax;ApplyFold.composeLens.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[B, C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyFold.composeIso">composeIso</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFold.composeIso;B">B</a>, <a title="" id="monocle.syntax;ApplyFold.composeIso;C">C</a>, <a title="" id="monocle.syntax;ApplyFold.composeIso;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplyFold.composeIso.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyFold.readResolve" title="(s: S, _fold: monocle.Fold[S,C])monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyFold._fold" title="=&gt; monocle.Fold[S,A]">_fold</a> <a href="../Fold.scala.html#monocle;Fold.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.Fold[S,C]">composeIso</a> <a href="#monocle.syntax;ApplyFold.composeIso.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>

  <span class="comment">/** alias to composeTraversal */</span>
  @inline def <a title="[B, C, D](other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyFold.^|->>">^|-&gt;&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFold.^|->>;B">B</a>, <a title="" id="monocle.syntax;ApplyFold.^|->>;C">C</a>, <a title="" id="monocle.syntax;ApplyFold.^|->>;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[A,B,C,D]" id="monocle.syntax;ApplyFold.^|->>.other">other</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[A,B,C,D]">PTraversal</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyFold.composeTraversal" title="(other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyFold[S,C]">composeTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.^|->>.other" title="monocle.PTraversal[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeOptional */</span>
  @inline def <a title="[B, C, D](other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyFold.^|-?">^|-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFold.^|-?;B">B</a>, <a title="" id="monocle.syntax;ApplyFold.^|-?;C">C</a>, <a title="" id="monocle.syntax;ApplyFold.^|-?;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[A,B,C,D]" id="monocle.syntax;ApplyFold.^|-?.other">other</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[A,B,C,D]">POptional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyFold.composeOptional" title="(other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyFold[S,C]">composeOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.^|-?.other" title="monocle.POptional[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composePrism */</span>
  @inline def <a title="[B, C, D](other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyFold.^<-?">^&lt;-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFold.^<-?;B">B</a>, <a title="" id="monocle.syntax;ApplyFold.^<-?;C">C</a>, <a title="" id="monocle.syntax;ApplyFold.^<-?;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[A,B,C,D]" id="monocle.syntax;ApplyFold.^<-?.other">other</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[A,B,C,D]">PPrism</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyFold.composePrism" title="(other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyFold[S,C]">composePrism</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.^<-?.other" title="monocle.PPrism[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeLens */</span>
  @inline def <a title="[B, C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyFold.^|->">^|-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFold.^|->;B">B</a>, <a title="" id="monocle.syntax;ApplyFold.^|->;C">C</a>, <a title="" id="monocle.syntax;ApplyFold.^|->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplyFold.^|->.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyFold.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyFold[S,C]">composeLens</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.^|->.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeIso */</span>
  @inline def <a title="[B, C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyFold.^<->">^&lt;-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyFold.^<->;B">B</a>, <a title="" id="monocle.syntax;ApplyFold.^<->;C">C</a>, <a title="" id="monocle.syntax;ApplyFold.^<->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplyFold.^<->.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyFold.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyFold[S,C]">composeIso</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyFold.^<->.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final case class <a href="#monocle.syntax;ApplyGetter.productElement.x$1" title="class ApplyGetter[S, A] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplyGetter.readResolve">ApplyGetter</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyGetter;S">S</a>, <a title="" id="monocle.syntax;ApplyGetter;A">A</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplyGetter.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplyGetter.s">s</a>: <a href="#monocle.syntax;ApplyGetter;S" title="S">S</a>, <a title="monocle.Getter[S,A]" id="monocle.syntax;ApplyGetter.getter">getter</a>: <a href="../Getter.scala.html#monocle;Getter" title="monocle.Getter[S,A]">Getter</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">{</span>
  @inline def <a title="=&gt; A" id="monocle.syntax;ApplyGetter.get">get</a>: <a href="#monocle.syntax;ApplyGetter;A" title="A">A</a> = <a href="#monocle.syntax;ApplyGetter.getter" title="=&gt; monocle.Getter[S,A]">getter</a>.<a href="../Getter.scala.html#monocle;Getter.get" title="(s: S)A">get</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyGetter.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @inline def <a title="[B](other: monocle.Fold[A,B])monocle.syntax.ApplyFold[S,B]" id="monocle.syntax;ApplyGetter.composeFold">composeFold</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyGetter.composeFold;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Fold[A,B]" id="monocle.syntax;ApplyGetter.composeFold.other">other</a>: <a href="../Fold.scala.html#monocle;Fold" title="monocle.Fold[A,B]">Fold</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,B]">ApplyFold</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyFold.readResolve" title="(s: S, _fold: monocle.Fold[S,B])monocle.syntax.ApplyFold[S,B]">ApplyFold</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyGetter.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyGetter.getter" title="=&gt; monocle.Getter[S,A]">getter</a> <a href="../Getter.scala.html#monocle;Getter.composeFold" title="(other: monocle.Fold[A,B])monocle.Fold[S,B]">composeFold</a> <a href="#monocle.syntax;ApplyGetter.composeFold.other" title="monocle.Fold[A,B]">other</a><span class="delimiter">)</span>
  @inline def <a title="[B](other: monocle.Getter[A,B])monocle.syntax.ApplyGetter[S,B]" id="monocle.syntax;ApplyGetter.composeGetter">composeGetter</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyGetter.composeGetter;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Getter[A,B]" id="monocle.syntax;ApplyGetter.composeGetter.other">other</a>: <a href="../Getter.scala.html#monocle;Getter" title="monocle.Getter[A,B]">Getter</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyGetter.readResolve" title="monocle.syntax.ApplyGetter[S,B]">ApplyGetter</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyGetter.readResolve" title="(s: S, getter: monocle.Getter[S,B])monocle.syntax.ApplyGetter[S,B]">ApplyGetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyGetter.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyGetter.getter" title="=&gt; monocle.Getter[S,A]">getter</a> <a href="../Getter.scala.html#monocle;Getter.composeGetter" title="(other: monocle.Getter[A,B])monocle.Getter[S,B]">composeGetter</a> <a href="#monocle.syntax;ApplyGetter.composeGetter.other" title="monocle.Getter[A,B]">other</a><span class="delimiter">)</span>
  @inline def <a title="[B, C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyGetter[S,C]" id="monocle.syntax;ApplyGetter.composeLens">composeLens</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyGetter.composeLens;B">B</a>, <a title="" id="monocle.syntax;ApplyGetter.composeLens;C">C</a>, <a title="" id="monocle.syntax;ApplyGetter.composeLens;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplyGetter.composeLens.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyGetter.readResolve" title="monocle.syntax.ApplyGetter[S,C]">ApplyGetter</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyGetter.readResolve" title="(s: S, getter: monocle.Getter[S,C])monocle.syntax.ApplyGetter[S,C]">ApplyGetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyGetter.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyGetter.getter" title="=&gt; monocle.Getter[S,A]">getter</a> <a href="../Getter.scala.html#monocle;Getter.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.Getter[S,C]">composeLens</a> <a href="#monocle.syntax;ApplyGetter.composeLens.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[B, C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyGetter[S,C]" id="monocle.syntax;ApplyGetter.composeIso">composeIso</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyGetter.composeIso;B">B</a>, <a title="" id="monocle.syntax;ApplyGetter.composeIso;C">C</a>, <a title="" id="monocle.syntax;ApplyGetter.composeIso;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplyGetter.composeIso.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyGetter.readResolve" title="monocle.syntax.ApplyGetter[S,C]">ApplyGetter</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyGetter.readResolve" title="(s: S, getter: monocle.Getter[S,C])monocle.syntax.ApplyGetter[S,C]">ApplyGetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyGetter.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyGetter.getter" title="=&gt; monocle.Getter[S,A]">getter</a> <a href="../Getter.scala.html#monocle;Getter.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.Getter[S,C]">composeIso</a> <a href="#monocle.syntax;ApplyGetter.composeIso.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>

  <span class="comment">/** alias to composeLens */</span>
  @inline def <a title="[B, C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyGetter[S,C]" id="monocle.syntax;ApplyGetter.^|->">^|-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyGetter.^|->;B">B</a>, <a title="" id="monocle.syntax;ApplyGetter.^|->;C">C</a>, <a title="" id="monocle.syntax;ApplyGetter.^|->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplyGetter.^|->.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyGetter.readResolve" title="monocle.syntax.ApplyGetter[S,C]">ApplyGetter</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyGetter.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyGetter[S,C]">composeLens</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyGetter.^|->.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeIso */</span>
  @inline def <a title="[B, C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyGetter[S,C]" id="monocle.syntax;ApplyGetter.^<->">^&lt;-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyGetter.^<->;B">B</a>, <a title="" id="monocle.syntax;ApplyGetter.^<->;C">C</a>, <a title="" id="monocle.syntax;ApplyGetter.^<->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplyGetter.^<->.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyGetter.readResolve" title="monocle.syntax.ApplyGetter[S,C]">ApplyGetter</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyGetter.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyGetter[S,C]">composeIso</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyGetter.^<->.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final case class <a href="#monocle.syntax;ApplyIso.productElement.x$1" title="class ApplyIso[S, T, A, B] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplyIso.readResolve">ApplyIso</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIso;S">S</a>, <a title="" id="monocle.syntax;ApplyIso;T">T</a>, <a title="" id="monocle.syntax;ApplyIso;A">A</a>, <a title="" id="monocle.syntax;ApplyIso;B">B</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplyIso.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplyIso.s">s</a>: <a href="#monocle.syntax;ApplyIso;S" title="S">S</a>, <a title="monocle.PIso[S,T,A,B]" id="monocle.syntax;ApplyIso.iso">iso</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[S,T,A,B]">PIso</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  @inline def <a title="=&gt; A" id="monocle.syntax;ApplyIso.get">get</a>: <a href="#monocle.syntax;ApplyIso;A" title="A">A</a> = <a href="#monocle.syntax;ApplyIso.iso" title="=&gt; monocle.PIso[S,T,A,B]">iso</a>.<a href="../Iso.scala.html#monocle;PIso.get" title="(s: S)A">get</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.s" title="=&gt; S">s</a><span class="delimiter">)</span>
  @inline def <a title="(b: B)T" id="monocle.syntax;ApplyIso.set">set</a><span class="delimiter">(</span><a title="B" id="monocle.syntax;ApplyIso.set.b">b</a>: <a href="#monocle.syntax;ApplyIso;B" title="B">B</a><span class="delimiter">)</span>: <a href="#monocle.syntax;ApplyIso;T" title="T">T</a> = <a href="#monocle.syntax;ApplyIso.iso" title="=&gt; monocle.PIso[S,T,A,B]">iso</a>.<a href="../Iso.scala.html#monocle;PIso.set" title="(b: B)S =&gt; T">set</a><span title="(v1: S)T" class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.set.b" title="B">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.s" title="=&gt; S">s</a><span class="delimiter">)</span>
  @inline def <a title="(f: A =&gt; B)T" id="monocle.syntax;ApplyIso.modify">modify</a><span class="delimiter">(</span><a title="A =&gt; B" id="monocle.syntax;ApplyIso.modify.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#monocle.syntax;ApplyIso;T" title="T">T</a> = <a href="#monocle.syntax;ApplyIso.iso" title="=&gt; monocle.PIso[S,T,A,B]">iso</a>.<a href="../Iso.scala.html#monocle;PIso.modify" title="(f: A =&gt; B)S =&gt; T">modify</a><span title="(v1: S)T" class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.modify.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @inline def <a title="[C, D](other: monocle.PSetter[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplyIso.composeSetter">composeSetter</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIso.composeSetter;C">C</a>, <a title="" id="monocle.syntax;ApplyIso.composeSetter;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PSetter[A,B,C,D]" id="monocle.syntax;ApplyIso.composeSetter.other">other</a>: <a href="../Setter.scala.html#monocle;PSetter" title="monocle.PSetter[A,B,C,D]">PSetter</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplySetter.readResolve" title="(s: S, setter: monocle.PSetter[S,T,C,D])monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyIso.iso" title="=&gt; monocle.PIso[S,T,A,B]">iso</a> <a href="../Iso.scala.html#monocle;PIso.composeSetter" title="(other: monocle.PSetter[A,B,C,D])monocle.PSetter[S,T,C,D]">composeSetter</a> <a href="#monocle.syntax;ApplyIso.composeSetter.other" title="monocle.PSetter[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C](other: monocle.Fold[A,C])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyIso.composeFold">composeFold</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIso.composeFold;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Fold[A,C]" id="monocle.syntax;ApplyIso.composeFold.other">other</a>: <a href="../Fold.scala.html#monocle;Fold" title="monocle.Fold[A,C]">Fold</a><span class="delimiter">[</span>A, C<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyFold.readResolve" title="(s: S, _fold: monocle.Fold[S,C])monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyIso.iso" title="=&gt; monocle.PIso[S,T,A,B]">iso</a> <a href="../Iso.scala.html#monocle;PIso.composeFold" title="(other: monocle.Fold[A,C])monocle.Fold[S,C]">composeFold</a> <a href="#monocle.syntax;ApplyIso.composeFold.other" title="monocle.Fold[A,C]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C](other: monocle.Getter[A,C])monocle.syntax.ApplyGetter[S,C]" id="monocle.syntax;ApplyIso.composeGetter">composeGetter</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIso.composeGetter;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Getter[A,C]" id="monocle.syntax;ApplyIso.composeGetter.other">other</a>: <a href="../Getter.scala.html#monocle;Getter" title="monocle.Getter[A,C]">Getter</a><span class="delimiter">[</span>A, C<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyGetter.readResolve" title="monocle.syntax.ApplyGetter[S,C]">ApplyGetter</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyGetter.readResolve" title="(s: S, getter: monocle.Getter[S,C])monocle.syntax.ApplyGetter[S,C]">ApplyGetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyIso.iso" title="=&gt; monocle.PIso[S,T,A,B]">iso</a> <a href="../Iso.scala.html#monocle;PIso.composeGetter" title="(other: monocle.Getter[A,C])monocle.Getter[S,C]">composeGetter</a> <a href="#monocle.syntax;ApplyIso.composeGetter.other" title="monocle.Getter[A,C]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyIso.composeTraversal">composeTraversal</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIso.composeTraversal;C">C</a>, <a title="" id="monocle.syntax;ApplyIso.composeTraversal;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[A,B,C,D]" id="monocle.syntax;ApplyIso.composeTraversal.other">other</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[A,B,C,D]">PTraversal</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyTraversal.readResolve" title="(s: S, traversal: monocle.PTraversal[S,T,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyIso.iso" title="=&gt; monocle.PIso[S,T,A,B]">iso</a> <a href="../Iso.scala.html#monocle;PIso.composeTraversal" title="(other: monocle.PTraversal[A,B,C,D])monocle.PTraversal[S,T,C,D]">composeTraversal</a> <a href="#monocle.syntax;ApplyIso.composeTraversal.other" title="monocle.PTraversal[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyIso.composeOptional">composeOptional</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIso.composeOptional;C">C</a>, <a title="" id="monocle.syntax;ApplyIso.composeOptional;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[A,B,C,D]" id="monocle.syntax;ApplyIso.composeOptional.other">other</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[A,B,C,D]">POptional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyOptional.readResolve" title="(s: S, optional: monocle.POptional[S,T,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyIso.iso" title="=&gt; monocle.PIso[S,T,A,B]">iso</a> <a href="../Iso.scala.html#monocle;PIso.composeOptional" title="(other: monocle.POptional[A,B,C,D])monocle.POptional[S,T,C,D]">composeOptional</a>  <a href="#monocle.syntax;ApplyIso.composeOptional.other" title="monocle.POptional[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyPrism[S,T,C,D]" id="monocle.syntax;ApplyIso.composePrism">composePrism</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIso.composePrism;C">C</a>, <a title="" id="monocle.syntax;ApplyIso.composePrism;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[A,B,C,D]" id="monocle.syntax;ApplyIso.composePrism.other">other</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[A,B,C,D]">PPrism</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyPrism.readResolve" title="monocle.syntax.ApplyPrism[S,T,C,D]">ApplyPrism</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyPrism.readResolve" title="(s: S, prism: monocle.PPrism[S,T,C,D])monocle.syntax.ApplyPrism[S,T,C,D]">ApplyPrism</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyIso.iso" title="=&gt; monocle.PIso[S,T,A,B]">iso</a> <a href="../Iso.scala.html#monocle;PIso.composePrism" title="(other: monocle.PPrism[A,B,C,D])monocle.PPrism[S,T,C,D]">composePrism</a>  <a href="#monocle.syntax;ApplyIso.composePrism.other" title="monocle.PPrism[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyLens[S,T,C,D]" id="monocle.syntax;ApplyIso.composeLens">composeLens</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIso.composeLens;C">C</a>, <a title="" id="monocle.syntax;ApplyIso.composeLens;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplyIso.composeLens.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyLens.readResolve" title="monocle.syntax.ApplyLens[S,T,C,D]">ApplyLens</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyLens.readResolve" title="(s: S, lens: monocle.PLens[S,T,C,D])monocle.syntax.ApplyLens[S,T,C,D]">ApplyLens</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyIso.iso" title="=&gt; monocle.PIso[S,T,A,B]">iso</a> <a href="../Iso.scala.html#monocle;PIso.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.PLens[S,T,C,D]">composeLens</a> <a href="#monocle.syntax;ApplyIso.composeLens.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyIso[S,T,C,D]" id="monocle.syntax;ApplyIso.composeIso">composeIso</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIso.composeIso;C">C</a>, <a title="" id="monocle.syntax;ApplyIso.composeIso;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplyIso.composeIso.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyIso.readResolve" title="monocle.syntax.ApplyIso[S,T,C,D]">ApplyIso</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyIso.readResolve" title="(s: S, iso: monocle.PIso[S,T,C,D])monocle.syntax.ApplyIso[S,T,C,D]">ApplyIso</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyIso.iso" title="=&gt; monocle.PIso[S,T,A,B]">iso</a> <a href="../Iso.scala.html#monocle;PIso.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.PIso[S,T,C,D]">composeIso</a> <a href="#monocle.syntax;ApplyIso.composeIso.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>

  <span class="comment">/** alias to composeTraversal */</span>
  @inline def <a title="[C, D](other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyIso.^|->>">^|-&gt;&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIso.^|->>;C">C</a>, <a title="" id="monocle.syntax;ApplyIso.^|->>;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[A,B,C,D]" id="monocle.syntax;ApplyIso.^|->>.other">other</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[A,B,C,D]">PTraversal</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyIso.composeTraversal" title="(other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">composeTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.^|->>.other" title="monocle.PTraversal[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeOptional */</span>
  @inline def <a title="[C, D](other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyIso.^|-?">^|-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIso.^|-?;C">C</a>, <a title="" id="monocle.syntax;ApplyIso.^|-?;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[A,B,C,D]" id="monocle.syntax;ApplyIso.^|-?.other">other</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[A,B,C,D]">POptional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyIso.composeOptional" title="(other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">composeOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.^|-?.other" title="monocle.POptional[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composePrism */</span>
  @inline def <a title="[C, D](other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyPrism[S,T,C,D]" id="monocle.syntax;ApplyIso.^<-?">^&lt;-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIso.^<-?;C">C</a>, <a title="" id="monocle.syntax;ApplyIso.^<-?;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[A,B,C,D]" id="monocle.syntax;ApplyIso.^<-?.other">other</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[A,B,C,D]">PPrism</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyPrism.readResolve" title="monocle.syntax.ApplyPrism[S,T,C,D]">ApplyPrism</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyIso.composePrism" title="(other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyPrism[S,T,C,D]">composePrism</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.^<-?.other" title="monocle.PPrism[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeLens */</span>
  @inline def <a title="[C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyLens[S,T,C,D]" id="monocle.syntax;ApplyIso.^|->">^|-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIso.^|->;C">C</a>, <a title="" id="monocle.syntax;ApplyIso.^|->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplyIso.^|->.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyLens.readResolve" title="monocle.syntax.ApplyLens[S,T,C,D]">ApplyLens</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyIso.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyLens[S,T,C,D]">composeLens</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.^|->.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeIso */</span>
  @inline def <a title="[C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyIso[S,T,C,D]" id="monocle.syntax;ApplyIso.^<->">^&lt;-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyIso.^<->;C">C</a>, <a title="" id="monocle.syntax;ApplyIso.^<->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplyIso.^<->.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyIso.readResolve" title="monocle.syntax.ApplyIso[S,T,C,D]">ApplyIso</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyIso.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyIso[S,T,C,D]">composeIso</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyIso.^<->.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final case class <a href="#monocle.syntax;ApplyLens.productElement.x$1" title="class ApplyLens[S, T, A, B] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplyLens.readResolve">ApplyLens</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLens;S">S</a>, <a title="" id="monocle.syntax;ApplyLens;T">T</a>, <a title="" id="monocle.syntax;ApplyLens;A">A</a>, <a title="" id="monocle.syntax;ApplyLens;B">B</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplyLens.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplyLens.s">s</a>: <a href="#monocle.syntax;ApplyLens;S" title="S">S</a>, <a title="monocle.PLens[S,T,A,B]" id="monocle.syntax;ApplyLens.lens">lens</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[S,T,A,B]">PLens</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">{</span>
  @inline def <a title="=&gt; A" id="monocle.syntax;ApplyLens.get">get</a>: <a href="#monocle.syntax;ApplyLens;A" title="A">A</a> = <a href="#monocle.syntax;ApplyLens.lens" title="=&gt; monocle.PLens[S,T,A,B]">lens</a>.<a href="../Lens.scala.html#monocle;PLens.get" title="(s: S)A">get</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.s" title="=&gt; S">s</a><span class="delimiter">)</span>
  @inline def <a title="(b: B)T" id="monocle.syntax;ApplyLens.set">set</a><span class="delimiter">(</span><a title="B" id="monocle.syntax;ApplyLens.set.b">b</a>: <a href="#monocle.syntax;ApplyLens;B" title="B">B</a><span class="delimiter">)</span>: <a href="#monocle.syntax;ApplyLens;T" title="T">T</a> = <a href="#monocle.syntax;ApplyLens.lens" title="=&gt; monocle.PLens[S,T,A,B]">lens</a>.<a href="../Lens.scala.html#monocle;PLens.set" title="(b: B)S =&gt; T">set</a><span title="(v1: S)T" class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.set.b" title="B">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.s" title="=&gt; S">s</a><span class="delimiter">)</span>
  @inline def <a title="(f: A =&gt; B)T" id="monocle.syntax;ApplyLens.modify">modify</a><span class="delimiter">(</span><a title="A =&gt; B" id="monocle.syntax;ApplyLens.modify.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#monocle.syntax;ApplyLens;T" title="T">T</a> = <a href="#monocle.syntax;ApplyLens.lens" title="=&gt; monocle.PLens[S,T,A,B]">lens</a>.<a href="../Lens.scala.html#monocle;PLens.modify" title="(f: A =&gt; B)S =&gt; T">modify</a><span title="(v1: S)T" class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.modify.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @inline def <a title="[C, D](other: monocle.PSetter[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplyLens.composeSetter">composeSetter</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLens.composeSetter;C">C</a>, <a title="" id="monocle.syntax;ApplyLens.composeSetter;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PSetter[A,B,C,D]" id="monocle.syntax;ApplyLens.composeSetter.other">other</a>: <a href="../Setter.scala.html#monocle;PSetter" title="monocle.PSetter[A,B,C,D]">PSetter</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplySetter.readResolve" title="(s: S, setter: monocle.PSetter[S,T,C,D])monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyLens.lens" title="=&gt; monocle.PLens[S,T,A,B]">lens</a> <a href="../Lens.scala.html#monocle;PLens.composeSetter" title="(other: monocle.PSetter[A,B,C,D])monocle.PSetter[S,T,C,D]">composeSetter</a> <a href="#monocle.syntax;ApplyLens.composeSetter.other" title="monocle.PSetter[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C](other: monocle.Fold[A,C])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyLens.composeFold">composeFold</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLens.composeFold;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Fold[A,C]" id="monocle.syntax;ApplyLens.composeFold.other">other</a>: <a href="../Fold.scala.html#monocle;Fold" title="monocle.Fold[A,C]">Fold</a><span class="delimiter">[</span>A, C<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyFold.readResolve" title="(s: S, _fold: monocle.Fold[S,C])monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyLens.lens" title="=&gt; monocle.PLens[S,T,A,B]">lens</a> <a href="../Lens.scala.html#monocle;PLens.composeFold" title="(other: monocle.Fold[A,C])monocle.Fold[S,C]">composeFold</a> <a href="#monocle.syntax;ApplyLens.composeFold.other" title="monocle.Fold[A,C]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C](other: monocle.Getter[A,C])monocle.syntax.ApplyGetter[S,C]" id="monocle.syntax;ApplyLens.composeGetter">composeGetter</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLens.composeGetter;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Getter[A,C]" id="monocle.syntax;ApplyLens.composeGetter.other">other</a>: <a href="../Getter.scala.html#monocle;Getter" title="monocle.Getter[A,C]">Getter</a><span class="delimiter">[</span>A, C<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyGetter.readResolve" title="monocle.syntax.ApplyGetter[S,C]">ApplyGetter</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyGetter.readResolve" title="(s: S, getter: monocle.Getter[S,C])monocle.syntax.ApplyGetter[S,C]">ApplyGetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyLens.lens" title="=&gt; monocle.PLens[S,T,A,B]">lens</a> <a href="../Lens.scala.html#monocle;PLens.composeGetter" title="(other: monocle.Getter[A,C])monocle.Getter[S,C]">composeGetter</a> <a href="#monocle.syntax;ApplyLens.composeGetter.other" title="monocle.Getter[A,C]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyLens.composeTraversal">composeTraversal</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLens.composeTraversal;C">C</a>, <a title="" id="monocle.syntax;ApplyLens.composeTraversal;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[A,B,C,D]" id="monocle.syntax;ApplyLens.composeTraversal.other">other</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[A,B,C,D]">PTraversal</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyTraversal.readResolve" title="(s: S, traversal: monocle.PTraversal[S,T,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyLens.lens" title="=&gt; monocle.PLens[S,T,A,B]">lens</a> <a href="../Lens.scala.html#monocle;PLens.composeTraversal" title="(other: monocle.PTraversal[A,B,C,D])monocle.PTraversal[S,T,C,D]">composeTraversal</a> <a href="#monocle.syntax;ApplyLens.composeTraversal.other" title="monocle.PTraversal[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyLens.composeOptional">composeOptional</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLens.composeOptional;C">C</a>, <a title="" id="monocle.syntax;ApplyLens.composeOptional;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[A,B,C,D]" id="monocle.syntax;ApplyLens.composeOptional.other">other</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[A,B,C,D]">POptional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyOptional.readResolve" title="(s: S, optional: monocle.POptional[S,T,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyLens.lens" title="=&gt; monocle.PLens[S,T,A,B]">lens</a> <a href="../Lens.scala.html#monocle;PLens.composeOptional" title="(other: monocle.POptional[A,B,C,D])monocle.POptional[S,T,C,D]">composeOptional</a>  <a href="#monocle.syntax;ApplyLens.composeOptional.other" title="monocle.POptional[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyLens.composePrism">composePrism</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLens.composePrism;C">C</a>, <a title="" id="monocle.syntax;ApplyLens.composePrism;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[A,B,C,D]" id="monocle.syntax;ApplyLens.composePrism.other">other</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[A,B,C,D]">PPrism</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyOptional.readResolve" title="(s: S, optional: monocle.POptional[S,T,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyLens.lens" title="=&gt; monocle.PLens[S,T,A,B]">lens</a> <a href="../Lens.scala.html#monocle;PLens.composePrism" title="(other: monocle.PPrism[A,B,C,D])monocle.POptional[S,T,C,D]">composePrism</a>  <a href="#monocle.syntax;ApplyLens.composePrism.other" title="monocle.PPrism[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyLens[S,T,C,D]" id="monocle.syntax;ApplyLens.composeLens">composeLens</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLens.composeLens;C">C</a>, <a title="" id="monocle.syntax;ApplyLens.composeLens;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplyLens.composeLens.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyLens.readResolve" title="monocle.syntax.ApplyLens[S,T,C,D]">ApplyLens</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyLens.readResolve" title="(s: S, lens: monocle.PLens[S,T,C,D])monocle.syntax.ApplyLens[S,T,C,D]">ApplyLens</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyLens.lens" title="=&gt; monocle.PLens[S,T,A,B]">lens</a> <a href="../Lens.scala.html#monocle;PLens.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.PLens[S,T,C,D]">composeLens</a> <a href="#monocle.syntax;ApplyLens.composeLens.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyLens[S,T,C,D]" id="monocle.syntax;ApplyLens.composeIso">composeIso</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLens.composeIso;C">C</a>, <a title="" id="monocle.syntax;ApplyLens.composeIso;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplyLens.composeIso.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyLens.readResolve" title="monocle.syntax.ApplyLens[S,T,C,D]">ApplyLens</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyLens.readResolve" title="(s: S, lens: monocle.PLens[S,T,C,D])monocle.syntax.ApplyLens[S,T,C,D]">ApplyLens</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyLens.lens" title="=&gt; monocle.PLens[S,T,A,B]">lens</a> <a href="../Lens.scala.html#monocle;PLens.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.PLens[S,T,C,D]">composeIso</a> <a href="#monocle.syntax;ApplyLens.composeIso.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>

  <span class="comment">/** alias to composeTraversal */</span>
  @inline def <a title="[C, D](other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyLens.^|->>">^|-&gt;&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLens.^|->>;C">C</a>, <a title="" id="monocle.syntax;ApplyLens.^|->>;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[A,B,C,D]" id="monocle.syntax;ApplyLens.^|->>.other">other</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[A,B,C,D]">PTraversal</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyLens.composeTraversal" title="(other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">composeTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.^|->>.other" title="monocle.PTraversal[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeOptional */</span>
  @inline def <a title="[C, D](other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyLens.^|-?">^|-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLens.^|-?;C">C</a>, <a title="" id="monocle.syntax;ApplyLens.^|-?;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[A,B,C,D]" id="monocle.syntax;ApplyLens.^|-?.other">other</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[A,B,C,D]">POptional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyLens.composeOptional" title="(other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">composeOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.^|-?.other" title="monocle.POptional[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composePrism */</span>
  @inline def <a title="[C, D](other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyLens.^<-?">^&lt;-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLens.^<-?;C">C</a>, <a title="" id="monocle.syntax;ApplyLens.^<-?;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[A,B,C,D]" id="monocle.syntax;ApplyLens.^<-?.other">other</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[A,B,C,D]">PPrism</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyLens.composePrism" title="(other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">composePrism</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.^<-?.other" title="monocle.PPrism[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeLens */</span>
  @inline def <a title="[C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyLens[S,T,C,D]" id="monocle.syntax;ApplyLens.^|->">^|-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLens.^|->;C">C</a>, <a title="" id="monocle.syntax;ApplyLens.^|->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplyLens.^|->.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyLens.readResolve" title="monocle.syntax.ApplyLens[S,T,C,D]">ApplyLens</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyLens.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyLens[S,T,C,D]">composeLens</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.^|->.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeIso */</span>
  @inline def <a title="[C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyLens[S,T,C,D]" id="monocle.syntax;ApplyLens.^<->">^&lt;-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyLens.^<->;C">C</a>, <a title="" id="monocle.syntax;ApplyLens.^<->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplyLens.^<->.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyLens.readResolve" title="monocle.syntax.ApplyLens[S,T,C,D]">ApplyLens</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyLens.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyLens[S,T,C,D]">composeIso</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyLens.^<->.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final case class <a href="#monocle.syntax;ApplyOptional.productElement.x$1" title="class ApplyOptional[S, T, A, B] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplyOptional.readResolve">ApplyOptional</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptional;S">S</a>, <a title="" id="monocle.syntax;ApplyOptional;T">T</a>, <a title="" id="monocle.syntax;ApplyOptional;A">A</a>, <a title="" id="monocle.syntax;ApplyOptional;B">B</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplyOptional.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplyOptional.s">s</a>: <a href="#monocle.syntax;ApplyOptional;S" title="S">S</a>, <a title="monocle.POptional[S,T,A,B]" id="monocle.syntax;ApplyOptional.optional">optional</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[S,T,A,B]">POptional</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">{</span>
  @inline def <a title="=&gt; Option[A]" id="monocle.syntax;ApplyOptional.getOption">getOption</a>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a>.<a href="../Optional.scala.html#monocle;POptional.getOption" title="(s: S)Option[A]">getOption</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @inline def <a title="(f: A =&gt; B)T" id="monocle.syntax;ApplyOptional.modify">modify</a><span class="delimiter">(</span><a title="A =&gt; B" id="monocle.syntax;ApplyOptional.modify.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#monocle.syntax;ApplyOptional;T" title="T">T</a> = <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a>.<a href="../Optional.scala.html#monocle;POptional.modify" title="(f: A =&gt; B)S =&gt; T">modify</a><span title="(v1: S)T" class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.modify.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a><span class="delimiter">)</span>
  @inline def <a title="(f: A =&gt; B)Option[T]" id="monocle.syntax;ApplyOptional.modifyOption">modifyOption</a><span class="delimiter">(</span><a title="A =&gt; B" id="monocle.syntax;ApplyOptional.modifyOption.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a>.<a href="../Optional.scala.html#monocle;POptional.modifyOption" title="(f: A =&gt; B)S =&gt; Option[T]">modifyOption</a><span title="(v1: S)Option[T]" class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.modifyOption.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @inline def <a title="(b: B)T" id="monocle.syntax;ApplyOptional.set">set</a><span class="delimiter">(</span><a title="B" id="monocle.syntax;ApplyOptional.set.b">b</a>: <a href="#monocle.syntax;ApplyOptional;B" title="B">B</a><span class="delimiter">)</span>: <a href="#monocle.syntax;ApplyOptional;T" title="T">T</a> = <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a>.<a href="../Optional.scala.html#monocle;POptional.set" title="(b: B)S =&gt; T">set</a><span title="(v1: S)T" class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.set.b" title="B">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a><span class="delimiter">)</span>
  @inline def <a title="(b: B)Option[T]" id="monocle.syntax;ApplyOptional.setOption">setOption</a><span class="delimiter">(</span><a title="B" id="monocle.syntax;ApplyOptional.setOption.b">b</a>: <a href="#monocle.syntax;ApplyOptional;B" title="B">B</a><span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a>.<a href="../Optional.scala.html#monocle;POptional.setOption" title="(b: B)S =&gt; Option[T]">setOption</a><span title="(v1: S)Option[T]" class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.setOption.b" title="B">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;use getOption&quot;</span>, since = <span class="string">&quot;1.1.0&quot;</span><span class="delimiter">)</span>
  @inline def <a title="=&gt; scalaz.Maybe[A]" id="monocle.syntax;ApplyOptional.getMaybe">getMaybe</a>: <span title="scalaz.Maybe[A]">Maybe</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a>.<a href="../Optional.scala.html#monocle;POptional.getOption" title="(s: S)Option[A]">getOption</a><span title="(a: Option[A])scalaz.syntax.std.OptionOps[A]" class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a><span class="delimiter">)</span>.<span title="=&gt; scalaz.Maybe[A]">toMaybe</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;use modifyOption&quot;</span>, since = <span class="string">&quot;1.1.0&quot;</span><span class="delimiter">)</span>
  @inline def <a title="(f: A =&gt; B)scalaz.Maybe[T]" id="monocle.syntax;ApplyOptional.modifyMaybe">modifyMaybe</a><span class="delimiter">(</span><a title="A =&gt; B" id="monocle.syntax;ApplyOptional.modifyMaybe.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <span title="scalaz.Maybe[T]">Maybe</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a>.<a href="../Optional.scala.html#monocle;POptional.modifyOption" title="(f: A =&gt; B)S =&gt; Option[T]">modifyOption</a><span title="(v1: S)Option[T]" class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.modifyMaybe.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span title="(a: Option[T])scalaz.syntax.std.OptionOps[T]" class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a><span class="delimiter">)</span>.<span title="=&gt; scalaz.Maybe[T]">toMaybe</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;use setOption&quot;</span>, since = <span class="string">&quot;1.1.0&quot;</span><span class="delimiter">)</span>
  @inline def <a title="(b: B)scalaz.Maybe[T]" id="monocle.syntax;ApplyOptional.setMaybe">setMaybe</a><span class="delimiter">(</span><a title="B" id="monocle.syntax;ApplyOptional.setMaybe.b">b</a>: <a href="#monocle.syntax;ApplyOptional;B" title="B">B</a><span class="delimiter">)</span>: <span title="scalaz.Maybe[T]">Maybe</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a>.<a href="../Optional.scala.html#monocle;POptional.setOption" title="(b: B)S =&gt; Option[T]">setOption</a><span title="(v1: S)Option[T]" class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.setMaybe.b" title="B">b</a><span class="delimiter">)</span><span title="(a: Option[T])scalaz.syntax.std.OptionOps[T]" class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a><span class="delimiter">)</span>.<span title="=&gt; scalaz.Maybe[T]">toMaybe</span>

  @inline def <a title="[C, D](other: monocle.PSetter[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplyOptional.composeSetter">composeSetter</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptional.composeSetter;C">C</a>, <a title="" id="monocle.syntax;ApplyOptional.composeSetter;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PSetter[A,B,C,D]" id="monocle.syntax;ApplyOptional.composeSetter.other">other</a>: <a href="../Setter.scala.html#monocle;PSetter" title="monocle.PSetter[A,B,C,D]">PSetter</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplySetter.readResolve" title="(s: S, setter: monocle.PSetter[S,T,C,D])monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a> <a href="../Optional.scala.html#monocle;POptional.composeSetter" title="(other: monocle.PSetter[A,B,C,D])monocle.PSetter[S,T,C,D]">composeSetter</a> <a href="#monocle.syntax;ApplyOptional.composeSetter.other" title="monocle.PSetter[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C](other: monocle.Fold[A,C])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyOptional.composeFold">composeFold</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptional.composeFold;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Fold[A,C]" id="monocle.syntax;ApplyOptional.composeFold.other">other</a>: <a href="../Fold.scala.html#monocle;Fold" title="monocle.Fold[A,C]">Fold</a><span class="delimiter">[</span>A, C<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyFold.readResolve" title="(s: S, _fold: monocle.Fold[S,C])monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a> <a href="../Optional.scala.html#monocle;POptional.composeFold" title="(other: monocle.Fold[A,C])monocle.Fold[S,C]">composeFold</a> <a href="#monocle.syntax;ApplyOptional.composeFold.other" title="monocle.Fold[A,C]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyOptional.composeTraversal">composeTraversal</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptional.composeTraversal;C">C</a>, <a title="" id="monocle.syntax;ApplyOptional.composeTraversal;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[A,B,C,D]" id="monocle.syntax;ApplyOptional.composeTraversal.other">other</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[A,B,C,D]">PTraversal</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyTraversal.readResolve" title="(s: S, traversal: monocle.PTraversal[S,T,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a> <a href="../Optional.scala.html#monocle;POptional.composeTraversal" title="(other: monocle.PTraversal[A,B,C,D])monocle.PTraversal[S,T,C,D]">composeTraversal</a> <a href="#monocle.syntax;ApplyOptional.composeTraversal.other" title="monocle.PTraversal[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyOptional.composeOptional">composeOptional</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptional.composeOptional;C">C</a>, <a title="" id="monocle.syntax;ApplyOptional.composeOptional;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[A,B,C,D]" id="monocle.syntax;ApplyOptional.composeOptional.other">other</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[A,B,C,D]">POptional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyOptional.readResolve" title="(s: S, optional: monocle.POptional[S,T,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a> <a href="../Optional.scala.html#monocle;POptional.composeOptional" title="(other: monocle.POptional[A,B,C,D])monocle.POptional[S,T,C,D]">composeOptional</a>  <a href="#monocle.syntax;ApplyOptional.composeOptional.other" title="monocle.POptional[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyOptional.composePrism">composePrism</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptional.composePrism;C">C</a>, <a title="" id="monocle.syntax;ApplyOptional.composePrism;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[A,B,C,D]" id="monocle.syntax;ApplyOptional.composePrism.other">other</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[A,B,C,D]">PPrism</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyOptional.readResolve" title="(s: S, optional: monocle.POptional[S,T,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a> <a href="../Optional.scala.html#monocle;POptional.composePrism" title="(other: monocle.PPrism[A,B,C,D])monocle.POptional[S,T,C,D]">composePrism</a>  <a href="#monocle.syntax;ApplyOptional.composePrism.other" title="monocle.PPrism[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyOptional.composeLens">composeLens</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptional.composeLens;C">C</a>, <a title="" id="monocle.syntax;ApplyOptional.composeLens;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplyOptional.composeLens.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyOptional.readResolve" title="(s: S, optional: monocle.POptional[S,T,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a> <a href="../Optional.scala.html#monocle;POptional.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.POptional[S,T,C,D]">composeLens</a> <a href="#monocle.syntax;ApplyOptional.composeLens.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyOptional.composeIso">composeIso</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptional.composeIso;C">C</a>, <a title="" id="monocle.syntax;ApplyOptional.composeIso;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplyOptional.composeIso.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyOptional.readResolve" title="(s: S, optional: monocle.POptional[S,T,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyOptional.optional" title="=&gt; monocle.POptional[S,T,A,B]">optional</a> <a href="../Optional.scala.html#monocle;POptional.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.POptional[S,T,C,D]">composeIso</a> <a href="#monocle.syntax;ApplyOptional.composeIso.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>

  <span class="comment">/** alias to composeTraversal */</span>
  @inline def <a title="[C, D](other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyOptional.^|->>">^|-&gt;&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptional.^|->>;C">C</a>, <a title="" id="monocle.syntax;ApplyOptional.^|->>;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[A,B,C,D]" id="monocle.syntax;ApplyOptional.^|->>.other">other</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[A,B,C,D]">PTraversal</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyOptional.composeTraversal" title="(other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">composeTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.^|->>.other" title="monocle.PTraversal[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeOptional */</span>
  @inline def <a title="[C, D](other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyOptional.^|-?">^|-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptional.^|-?;C">C</a>, <a title="" id="monocle.syntax;ApplyOptional.^|-?;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[A,B,C,D]" id="monocle.syntax;ApplyOptional.^|-?.other">other</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[A,B,C,D]">POptional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyOptional.composeOptional" title="(other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">composeOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.^|-?.other" title="monocle.POptional[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composePrism */</span>
  @inline def <a title="[C, D](other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyOptional.^<-?">^&lt;-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptional.^<-?;C">C</a>, <a title="" id="monocle.syntax;ApplyOptional.^<-?;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[A,B,C,D]" id="monocle.syntax;ApplyOptional.^<-?.other">other</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[A,B,C,D]">PPrism</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyOptional.composePrism" title="(other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">composePrism</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.^<-?.other" title="monocle.PPrism[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeLens */</span>
  @inline def <a title="[C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyOptional.^|->">^|-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptional.^|->;C">C</a>, <a title="" id="monocle.syntax;ApplyOptional.^|->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplyOptional.^|->.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyOptional.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">composeLens</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.^|->.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeIso */</span>
  @inline def <a title="[C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyOptional.^<->">^&lt;-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyOptional.^<->;C">C</a>, <a title="" id="monocle.syntax;ApplyOptional.^<->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplyOptional.^<->.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyOptional.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">composeIso</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyOptional.^<->.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final case class <a href="#monocle.syntax;ApplyPrism.productElement.x$1" title="class ApplyPrism[S, T, A, B] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplyPrism.readResolve">ApplyPrism</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrism;S">S</a>, <a title="" id="monocle.syntax;ApplyPrism;T">T</a>, <a title="" id="monocle.syntax;ApplyPrism;A">A</a>, <a title="" id="monocle.syntax;ApplyPrism;B">B</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplyPrism.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplyPrism.s">s</a>: <a href="#monocle.syntax;ApplyPrism;S" title="S">S</a>, <a title="monocle.PPrism[S,T,A,B]" id="monocle.syntax;ApplyPrism.prism">prism</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[S,T,A,B]">PPrism</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">{</span>
  @inline def <a title="=&gt; Option[A]" id="monocle.syntax;ApplyPrism.getOption">getOption</a>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a>.<a href="../Prism.scala.html#monocle;PPrism.getOption" title="(s: S)Option[A]">getOption</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @inline def <a title="(f: A =&gt; B)T" id="monocle.syntax;ApplyPrism.modify">modify</a><span class="delimiter">(</span><a title="A =&gt; B" id="monocle.syntax;ApplyPrism.modify.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#monocle.syntax;ApplyPrism;T" title="T">T</a> = <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a>.<a href="../Prism.scala.html#monocle;PPrism.modify" title="(f: A =&gt; B)S =&gt; T">modify</a><span title="(v1: S)T" class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.modify.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a><span class="delimiter">)</span>
  @inline def <a title="(f: A =&gt; B)Option[T]" id="monocle.syntax;ApplyPrism.modifyOption">modifyOption</a><span class="delimiter">(</span><a title="A =&gt; B" id="monocle.syntax;ApplyPrism.modifyOption.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a>.<a href="../Prism.scala.html#monocle;PPrism.modifyOption" title="(f: A =&gt; B)S =&gt; Option[T]">modifyOption</a><span title="(v1: S)Option[T]" class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.modifyOption.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @inline def <a title="(b: B)T" id="monocle.syntax;ApplyPrism.set">set</a><span class="delimiter">(</span><a title="B" id="monocle.syntax;ApplyPrism.set.b">b</a>: <a href="#monocle.syntax;ApplyPrism;B" title="B">B</a><span class="delimiter">)</span>: <a href="#monocle.syntax;ApplyPrism;T" title="T">T</a> = <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a>.<a href="../Prism.scala.html#monocle;PPrism.set" title="(b: B)S =&gt; T">set</a><span title="(v1: S)T" class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.set.b" title="B">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a><span class="delimiter">)</span>
  @inline def <a title="(b: B)Option[T]" id="monocle.syntax;ApplyPrism.setOption">setOption</a><span class="delimiter">(</span><a title="B" id="monocle.syntax;ApplyPrism.setOption.b">b</a>: <a href="#monocle.syntax;ApplyPrism;B" title="B">B</a><span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a>.<a href="../Prism.scala.html#monocle;PPrism.setOption" title="(b: B)S =&gt; Option[T]">setOption</a><span title="(v1: S)Option[T]" class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.setOption.b" title="B">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @inline def <a title="[C, D](other: monocle.PSetter[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplyPrism.composeSetter">composeSetter</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrism.composeSetter;C">C</a>, <a title="" id="monocle.syntax;ApplyPrism.composeSetter;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PSetter[A,B,C,D]" id="monocle.syntax;ApplyPrism.composeSetter.other">other</a>: <a href="../Setter.scala.html#monocle;PSetter" title="monocle.PSetter[A,B,C,D]">PSetter</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplySetter.readResolve" title="(s: S, setter: monocle.PSetter[S,T,C,D])monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a> <a href="../Prism.scala.html#monocle;PPrism.composeSetter" title="(other: monocle.PSetter[A,B,C,D])monocle.PSetter[S,T,C,D]">composeSetter</a> <a href="#monocle.syntax;ApplyPrism.composeSetter.other" title="monocle.PSetter[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C](other: monocle.Fold[A,C])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyPrism.composeFold">composeFold</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrism.composeFold;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Fold[A,C]" id="monocle.syntax;ApplyPrism.composeFold.other">other</a>: <a href="../Fold.scala.html#monocle;Fold" title="monocle.Fold[A,C]">Fold</a><span class="delimiter">[</span>A, C<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyFold.readResolve" title="(s: S, _fold: monocle.Fold[S,C])monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a> <a href="../Prism.scala.html#monocle;PPrism.composeFold" title="(other: monocle.Fold[A,C])monocle.Fold[S,C]">composeFold</a> <a href="#monocle.syntax;ApplyPrism.composeFold.other" title="monocle.Fold[A,C]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyPrism.composeTraversal">composeTraversal</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrism.composeTraversal;C">C</a>, <a title="" id="monocle.syntax;ApplyPrism.composeTraversal;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[A,B,C,D]" id="monocle.syntax;ApplyPrism.composeTraversal.other">other</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[A,B,C,D]">PTraversal</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyTraversal.readResolve" title="(s: S, traversal: monocle.PTraversal[S,T,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a> <a href="../Prism.scala.html#monocle;PPrism.composeTraversal" title="(other: monocle.PTraversal[A,B,C,D])monocle.PTraversal[S,T,C,D]">composeTraversal</a> <a href="#monocle.syntax;ApplyPrism.composeTraversal.other" title="monocle.PTraversal[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyPrism.composeOptional">composeOptional</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrism.composeOptional;C">C</a>, <a title="" id="monocle.syntax;ApplyPrism.composeOptional;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[A,B,C,D]" id="monocle.syntax;ApplyPrism.composeOptional.other">other</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[A,B,C,D]">POptional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyOptional.readResolve" title="(s: S, optional: monocle.POptional[S,T,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a> <a href="../Prism.scala.html#monocle;PPrism.composeOptional" title="(other: monocle.POptional[A,B,C,D])monocle.POptional[S,T,C,D]">composeOptional</a>  <a href="#monocle.syntax;ApplyPrism.composeOptional.other" title="monocle.POptional[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyPrism.composeLens">composeLens</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrism.composeLens;C">C</a>, <a title="" id="monocle.syntax;ApplyPrism.composeLens;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplyPrism.composeLens.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyOptional.readResolve" title="(s: S, optional: monocle.POptional[S,T,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a> <a href="../Prism.scala.html#monocle;PPrism.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.POptional[S,T,C,D]">composeLens</a> <a href="#monocle.syntax;ApplyPrism.composeLens.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyPrism[S,T,C,D]" id="monocle.syntax;ApplyPrism.composePrism">composePrism</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrism.composePrism;C">C</a>, <a title="" id="monocle.syntax;ApplyPrism.composePrism;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[A,B,C,D]" id="monocle.syntax;ApplyPrism.composePrism.other">other</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[A,B,C,D]">PPrism</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyPrism.readResolve" title="monocle.syntax.ApplyPrism[S,T,C,D]">ApplyPrism</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyPrism.readResolve" title="(s: S, prism: monocle.PPrism[S,T,C,D])monocle.syntax.ApplyPrism[S,T,C,D]">ApplyPrism</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a> <a href="../Prism.scala.html#monocle;PPrism.composePrism" title="(other: monocle.PPrism[A,B,C,D])monocle.PPrism[S,T,C,D]">composePrism</a>  <a href="#monocle.syntax;ApplyPrism.composePrism.other" title="monocle.PPrism[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyPrism[S,T,C,D]" id="monocle.syntax;ApplyPrism.composeIso">composeIso</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrism.composeIso;C">C</a>, <a title="" id="monocle.syntax;ApplyPrism.composeIso;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplyPrism.composeIso.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyPrism.readResolve" title="monocle.syntax.ApplyPrism[S,T,C,D]">ApplyPrism</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyPrism.readResolve" title="(s: S, prism: monocle.PPrism[S,T,C,D])monocle.syntax.ApplyPrism[S,T,C,D]">ApplyPrism</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a> <a href="../Prism.scala.html#monocle;PPrism.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.PPrism[S,T,C,D]">composeIso</a> <a href="#monocle.syntax;ApplyPrism.composeIso.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;use getOption&quot;</span>, since = <span class="string">&quot;1.1.0&quot;</span><span class="delimiter">)</span>
  @inline def <a title="=&gt; scalaz.Maybe[A]" id="monocle.syntax;ApplyPrism.getMaybe">getMaybe</a>: <span title="scalaz.Maybe[A]">Maybe</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a>.<a href="../Prism.scala.html#monocle;PPrism.getOption" title="(s: S)Option[A]">getOption</a><span title="(a: Option[A])scalaz.syntax.std.OptionOps[A]" class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a><span class="delimiter">)</span>.<span title="=&gt; scalaz.Maybe[A]">toMaybe</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;use modifyOption&quot;</span>, since = <span class="string">&quot;1.1.0&quot;</span><span class="delimiter">)</span>
  @inline def <a title="(f: A =&gt; B)scalaz.Maybe[T]" id="monocle.syntax;ApplyPrism.modifyMaybe">modifyMaybe</a><span class="delimiter">(</span><a title="A =&gt; B" id="monocle.syntax;ApplyPrism.modifyMaybe.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <span title="scalaz.Maybe[T]">Maybe</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a>.<a href="../Prism.scala.html#monocle;PPrism.modifyOption" title="(f: A =&gt; B)S =&gt; Option[T]">modifyOption</a><span title="(v1: S)Option[T]" class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.modifyMaybe.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span title="(a: Option[T])scalaz.syntax.std.OptionOps[T]" class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a><span class="delimiter">)</span>.<span title="=&gt; scalaz.Maybe[T]">toMaybe</span>
  @deprecated<span class="delimiter">(</span><span class="string">&quot;use setOption&quot;</span>, since = <span class="string">&quot;1.1.0&quot;</span><span class="delimiter">)</span>
  @inline def <a title="(b: B)scalaz.Maybe[T]" id="monocle.syntax;ApplyPrism.setMaybe">setMaybe</a><span class="delimiter">(</span><a title="B" id="monocle.syntax;ApplyPrism.setMaybe.b">b</a>: <a href="#monocle.syntax;ApplyPrism;B" title="B">B</a><span class="delimiter">)</span>: <span title="scalaz.Maybe[T]">Maybe</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyPrism.prism" title="=&gt; monocle.PPrism[S,T,A,B]">prism</a>.<a href="../Prism.scala.html#monocle;PPrism.setOption" title="(b: B)S =&gt; Option[T]">setOption</a><span title="(v1: S)Option[T]" class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.setMaybe.b" title="B">b</a><span class="delimiter">)</span><span title="(a: Option[T])scalaz.syntax.std.OptionOps[T]" class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.s" title="=&gt; S">s</a><span class="delimiter">)</span>.<span title="=&gt; scalaz.Maybe[T]">toMaybe</span>

  <span class="comment">/** alias to composeTraversal */</span>
  @inline def <a title="[C, D](other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyPrism.^|->>">^|-&gt;&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrism.^|->>;C">C</a>, <a title="" id="monocle.syntax;ApplyPrism.^|->>;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[A,B,C,D]" id="monocle.syntax;ApplyPrism.^|->>.other">other</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[A,B,C,D]">PTraversal</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyPrism.composeTraversal" title="(other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">composeTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.^|->>.other" title="monocle.PTraversal[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeOptional */</span>
  @inline def <a title="[C, D](other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyPrism.^|-?">^|-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrism.^|-?;C">C</a>, <a title="" id="monocle.syntax;ApplyPrism.^|-?;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[A,B,C,D]" id="monocle.syntax;ApplyPrism.^|-?.other">other</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[A,B,C,D]">POptional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyPrism.composeOptional" title="(other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">composeOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.^|-?.other" title="monocle.POptional[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composePrism */</span>
  @inline def <a title="[C, D](other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyPrism[S,T,C,D]" id="monocle.syntax;ApplyPrism.^<-?">^&lt;-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrism.^<-?;C">C</a>, <a title="" id="monocle.syntax;ApplyPrism.^<-?;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[A,B,C,D]" id="monocle.syntax;ApplyPrism.^<-?.other">other</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[A,B,C,D]">PPrism</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyPrism.readResolve" title="monocle.syntax.ApplyPrism[S,T,C,D]">ApplyPrism</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyPrism.composePrism" title="(other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyPrism[S,T,C,D]">composePrism</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.^<-?.other" title="monocle.PPrism[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeLens */</span>
  @inline def <a title="[C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]" id="monocle.syntax;ApplyPrism.^|->">^|-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrism.^|->;C">C</a>, <a title="" id="monocle.syntax;ApplyPrism.^|->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplyPrism.^|->.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyOptional.readResolve" title="monocle.syntax.ApplyOptional[S,T,C,D]">ApplyOptional</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyPrism.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyOptional[S,T,C,D]">composeLens</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.^|->.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeIso */</span>
  @inline def <a title="[C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyPrism[S,T,C,D]" id="monocle.syntax;ApplyPrism.^<->">^&lt;-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyPrism.^<->;C">C</a>, <a title="" id="monocle.syntax;ApplyPrism.^<->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplyPrism.^<->.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyPrism.readResolve" title="monocle.syntax.ApplyPrism[S,T,C,D]">ApplyPrism</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyPrism.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyPrism[S,T,C,D]">composeIso</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyPrism.^<->.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

final case class <a href="#monocle.syntax;ApplySetter.productElement.x$1" title="class ApplySetter[S, T, A, B] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplySetter.readResolve">ApplySetter</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySetter;S">S</a>, <a title="" id="monocle.syntax;ApplySetter;T">T</a>, <a title="" id="monocle.syntax;ApplySetter;A">A</a>, <a title="" id="monocle.syntax;ApplySetter;B">B</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplySetter.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplySetter.s">s</a>: <a href="#monocle.syntax;ApplySetter;S" title="S">S</a>, <a title="monocle.PSetter[S,T,A,B]" id="monocle.syntax;ApplySetter.setter">setter</a>: <a href="../Setter.scala.html#monocle;PSetter" title="monocle.PSetter[S,T,A,B]">PSetter</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  @inline def <a title="(b: B)T" id="monocle.syntax;ApplySetter.set">set</a><span class="delimiter">(</span><a title="B" id="monocle.syntax;ApplySetter.set.b">b</a>: <a href="#monocle.syntax;ApplySetter;B" title="B">B</a><span class="delimiter">)</span>: <a href="#monocle.syntax;ApplySetter;T" title="T">T</a> = <a href="#monocle.syntax;ApplySetter.setter" title="=&gt; monocle.PSetter[S,T,A,B]">setter</a>.<a href="../Setter.scala.html#monocle;PSetter.set" title="(b: B)S =&gt; T">set</a><span title="(v1: S)T" class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.set.b" title="B">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.s" title="=&gt; S">s</a><span class="delimiter">)</span>
  @inline def <a title="(f: A =&gt; B)T" id="monocle.syntax;ApplySetter.modify">modify</a><span class="delimiter">(</span><a title="A =&gt; B" id="monocle.syntax;ApplySetter.modify.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#monocle.syntax;ApplySetter;T" title="T">T</a> = <a href="#monocle.syntax;ApplySetter.setter" title="=&gt; monocle.PSetter[S,T,A,B]">setter</a>.<a href="../Setter.scala.html#monocle;PSetter.modify" title="(f: A =&gt; B)S =&gt; T">modify</a><span title="(v1: S)T" class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.modify.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @inline def <a title="[C, D](other: monocle.PSetter[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplySetter.composeSetter">composeSetter</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySetter.composeSetter;C">C</a>, <a title="" id="monocle.syntax;ApplySetter.composeSetter;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PSetter[A,B,C,D]" id="monocle.syntax;ApplySetter.composeSetter.other">other</a>: <a href="../Setter.scala.html#monocle;PSetter" title="monocle.PSetter[A,B,C,D]">PSetter</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplySetter.readResolve" title="(s: S, setter: monocle.PSetter[S,T,C,D])monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplySetter.setter" title="=&gt; monocle.PSetter[S,T,A,B]">setter</a> <a href="../Setter.scala.html#monocle;PSetter.composeSetter" title="(other: monocle.PSetter[A,B,C,D])monocle.PSetter[S,T,C,D]">composeSetter</a> <a href="#monocle.syntax;ApplySetter.composeSetter.other" title="monocle.PSetter[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplySetter.composeTraversal">composeTraversal</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySetter.composeTraversal;C">C</a>, <a title="" id="monocle.syntax;ApplySetter.composeTraversal;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[A,B,C,D]" id="monocle.syntax;ApplySetter.composeTraversal.other">other</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[A,B,C,D]">PTraversal</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplySetter.readResolve" title="(s: S, setter: monocle.PSetter[S,T,C,D])monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplySetter.setter" title="=&gt; monocle.PSetter[S,T,A,B]">setter</a> <a href="../Setter.scala.html#monocle;PSetter.composeTraversal" title="(other: monocle.PTraversal[A,B,C,D])monocle.PSetter[S,T,C,D]">composeTraversal</a> <a href="#monocle.syntax;ApplySetter.composeTraversal.other" title="monocle.PTraversal[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.POptional[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplySetter.composeOptional">composeOptional</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySetter.composeOptional;C">C</a>, <a title="" id="monocle.syntax;ApplySetter.composeOptional;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[A,B,C,D]" id="monocle.syntax;ApplySetter.composeOptional.other">other</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[A,B,C,D]">POptional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplySetter.readResolve" title="(s: S, setter: monocle.PSetter[S,T,C,D])monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplySetter.setter" title="=&gt; monocle.PSetter[S,T,A,B]">setter</a> <a href="../Setter.scala.html#monocle;PSetter.composeOptional" title="(other: monocle.POptional[A,B,C,D])monocle.PSetter[S,T,C,D]">composeOptional</a> <a href="#monocle.syntax;ApplySetter.composeOptional.other" title="monocle.POptional[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplySetter.composePrism">composePrism</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySetter.composePrism;C">C</a>, <a title="" id="monocle.syntax;ApplySetter.composePrism;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[A,B,C,D]" id="monocle.syntax;ApplySetter.composePrism.other">other</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[A,B,C,D]">PPrism</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplySetter.readResolve" title="(s: S, setter: monocle.PSetter[S,T,C,D])monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplySetter.setter" title="=&gt; monocle.PSetter[S,T,A,B]">setter</a> <a href="../Setter.scala.html#monocle;PSetter.composePrism" title="(other: monocle.PPrism[A,B,C,D])monocle.PSetter[S,T,C,D]">composePrism</a>  <a href="#monocle.syntax;ApplySetter.composePrism.other" title="monocle.PPrism[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplySetter.composeLens">composeLens</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySetter.composeLens;C">C</a>, <a title="" id="monocle.syntax;ApplySetter.composeLens;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplySetter.composeLens.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplySetter.readResolve" title="(s: S, setter: monocle.PSetter[S,T,C,D])monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplySetter.setter" title="=&gt; monocle.PSetter[S,T,A,B]">setter</a> <a href="../Setter.scala.html#monocle;PSetter.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.PSetter[S,T,C,D]">composeLens</a> <a href="#monocle.syntax;ApplySetter.composeLens.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplySetter.composeIso">composeIso</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySetter.composeIso;C">C</a>, <a title="" id="monocle.syntax;ApplySetter.composeIso;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplySetter.composeIso.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplySetter.readResolve" title="(s: S, setter: monocle.PSetter[S,T,C,D])monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplySetter.setter" title="=&gt; monocle.PSetter[S,T,A,B]">setter</a> <a href="../Setter.scala.html#monocle;PSetter.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.PSetter[S,T,C,D]">composeIso</a> <a href="#monocle.syntax;ApplySetter.composeIso.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>

  <span class="comment">/** alias to composeTraversal */</span>
  @inline def <a title="[C, D](other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplySetter.^|->>">^|-&gt;&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySetter.^|->>;C">C</a>, <a title="" id="monocle.syntax;ApplySetter.^|->>;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[A,B,C,D]" id="monocle.syntax;ApplySetter.^|->>.other">other</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[A,B,C,D]">PTraversal</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplySetter.composeTraversal" title="(other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]">composeTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.^|->>.other" title="monocle.PTraversal[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeOptional */</span>
  @inline def <a title="[C, D](other: monocle.POptional[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplySetter.^|-?">^|-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySetter.^|-?;C">C</a>, <a title="" id="monocle.syntax;ApplySetter.^|-?;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[A,B,C,D]" id="monocle.syntax;ApplySetter.^|-?.other">other</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[A,B,C,D]">POptional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplySetter.composeOptional" title="(other: monocle.POptional[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]">composeOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.^|-?.other" title="monocle.POptional[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composePrism */</span>
  @inline def <a title="[C, D](other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplySetter.^<-?">^&lt;-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySetter.^<-?;C">C</a>, <a title="" id="monocle.syntax;ApplySetter.^<-?;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[A,B,C,D]" id="monocle.syntax;ApplySetter.^<-?.other">other</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[A,B,C,D]">PPrism</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplySetter.composePrism" title="(other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]">composePrism</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.^<-?.other" title="monocle.PPrism[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeLens */</span>
  @inline def <a title="[C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplySetter.^|->">^|-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySetter.^|->;C">C</a>, <a title="" id="monocle.syntax;ApplySetter.^|->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplySetter.^|->.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplySetter.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]">composeLens</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.^|->.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeIso */</span>
  @inline def <a title="[C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplySetter.^<->">^&lt;-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplySetter.^<->;C">C</a>, <a title="" id="monocle.syntax;ApplySetter.^<->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplySetter.^<->.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplySetter.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]">composeIso</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplySetter.^<->.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>
<span class="delimiter">}</span>


final case class <a href="#monocle.syntax;ApplyTraversal.productElement.x$1" title="class ApplyTraversal[S, T, A, B] extends AnyRef with Product with Serializable" id="monocle.syntax.ApplyTraversal.readResolve">ApplyTraversal</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversal;S">S</a>, <a title="" id="monocle.syntax;ApplyTraversal;T">T</a>, <a title="" id="monocle.syntax;ApplyTraversal;A">A</a>, <a title="" id="monocle.syntax;ApplyTraversal;B">B</a><span class="delimiter">]</span><a href="#monocle.syntax.ApplyTraversal.readResolve" title="Product" class="delimiter">(</a><a title="S" id="monocle.syntax;ApplyTraversal.s">s</a>: <a href="#monocle.syntax;ApplyTraversal;S" title="S">S</a>, <a title="monocle.PTraversal[S,T,A,B]" id="monocle.syntax;ApplyTraversal.traversal">traversal</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[S,T,A,B]">PTraversal</a><span class="delimiter">[</span>S, T, A, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">{</span>
  @inline def <a title="=&gt; List[A]" id="monocle.syntax;ApplyTraversal.getAll">getAll</a>: <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyTraversal.traversal" title="=&gt; monocle.PTraversal[S,T,A,B]">traversal</a>.<a href="../Traversal.scala.html#monocle;PTraversal.getAll" title="(s: S)List[A]">getAll</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.s" title="=&gt; S">s</a><span class="delimiter">)</span>
  @inline def <a title="=&gt; Option[A]" id="monocle.syntax;ApplyTraversal.headOption">headOption</a>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyTraversal.traversal" title="=&gt; monocle.PTraversal[S,T,A,B]">traversal</a>.<a href="../Traversal.scala.html#monocle;PTraversal.headOption" title="(s: S)Option[A]">headOption</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @inline def <a title="(b: B)T" id="monocle.syntax;ApplyTraversal.set">set</a><span class="delimiter">(</span><a title="B" id="monocle.syntax;ApplyTraversal.set.b">b</a>: <a href="#monocle.syntax;ApplyTraversal;B" title="B">B</a><span class="delimiter">)</span>: <a href="#monocle.syntax;ApplyTraversal;T" title="T">T</a> = <a href="#monocle.syntax;ApplyTraversal.traversal" title="=&gt; monocle.PTraversal[S,T,A,B]">traversal</a>.<a href="../Traversal.scala.html#monocle;PTraversal.set" title="(b: B)S =&gt; T">set</a><span title="(v1: S)T" class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.set.b" title="B">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.s" title="=&gt; S">s</a><span class="delimiter">)</span>
  @inline def <a title="(f: A =&gt; B)T" id="monocle.syntax;ApplyTraversal.modify">modify</a><span class="delimiter">(</span><a title="A =&gt; B" id="monocle.syntax;ApplyTraversal.modify.f">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#monocle.syntax;ApplyTraversal;T" title="T">T</a> = <a href="#monocle.syntax;ApplyTraversal.traversal" title="=&gt; monocle.PTraversal[S,T,A,B]">traversal</a>.<a href="../Traversal.scala.html#monocle;PTraversal.modify" title="(f: A =&gt; B)S =&gt; T">modify</a><span title="(v1: S)T" class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.modify.f" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.s" title="=&gt; S">s</a><span class="delimiter">)</span>

  @inline def <a title="[C, D](other: monocle.PSetter[A,B,C,D])monocle.syntax.ApplySetter[S,T,C,D]" id="monocle.syntax;ApplyTraversal.composeSetter">composeSetter</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversal.composeSetter;C">C</a>, <a title="" id="monocle.syntax;ApplyTraversal.composeSetter;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PSetter[A,B,C,D]" id="monocle.syntax;ApplyTraversal.composeSetter.other">other</a>: <a href="../Setter.scala.html#monocle;PSetter" title="monocle.PSetter[A,B,C,D]">PSetter</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplySetter.readResolve" title="monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplySetter.readResolve" title="(s: S, setter: monocle.PSetter[S,T,C,D])monocle.syntax.ApplySetter[S,T,C,D]">ApplySetter</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyTraversal.traversal" title="=&gt; monocle.PTraversal[S,T,A,B]">traversal</a> <a href="../Traversal.scala.html#monocle;PTraversal.composeSetter" title="(other: monocle.PSetter[A,B,C,D])monocle.PSetter[S,T,C,D]">composeSetter</a> <a href="#monocle.syntax;ApplyTraversal.composeSetter.other" title="monocle.PSetter[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C](other: monocle.Fold[A,C])monocle.syntax.ApplyFold[S,C]" id="monocle.syntax;ApplyTraversal.composeFold">composeFold</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversal.composeFold;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.Fold[A,C]" id="monocle.syntax;ApplyTraversal.composeFold.other">other</a>: <a href="../Fold.scala.html#monocle;Fold" title="monocle.Fold[A,C]">Fold</a><span class="delimiter">[</span>A, C<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyFold.readResolve" title="monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyFold.readResolve" title="(s: S, _fold: monocle.Fold[S,C])monocle.syntax.ApplyFold[S,C]">ApplyFold</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyTraversal.traversal" title="=&gt; monocle.PTraversal[S,T,A,B]">traversal</a> <a href="../Traversal.scala.html#monocle;PTraversal.composeFold" title="(other: monocle.Fold[A,C])monocle.Fold[S,C]">composeFold</a> <a href="#monocle.syntax;ApplyTraversal.composeFold.other" title="monocle.Fold[A,C]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyTraversal.composeTraversal">composeTraversal</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversal.composeTraversal;C">C</a>, <a title="" id="monocle.syntax;ApplyTraversal.composeTraversal;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[A,B,C,D]" id="monocle.syntax;ApplyTraversal.composeTraversal.other">other</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[A,B,C,D]">PTraversal</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyTraversal.readResolve" title="(s: S, traversal: monocle.PTraversal[S,T,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyTraversal.traversal" title="=&gt; monocle.PTraversal[S,T,A,B]">traversal</a> <a href="../Traversal.scala.html#monocle;PTraversal.composeTraversal" title="(other: monocle.PTraversal[A,B,C,D])monocle.PTraversal[S,T,C,D]">composeTraversal</a> <a href="#monocle.syntax;ApplyTraversal.composeTraversal.other" title="monocle.PTraversal[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyTraversal.composeOptional">composeOptional</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversal.composeOptional;C">C</a>, <a title="" id="monocle.syntax;ApplyTraversal.composeOptional;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[A,B,C,D]" id="monocle.syntax;ApplyTraversal.composeOptional.other">other</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[A,B,C,D]">POptional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyTraversal.readResolve" title="(s: S, traversal: monocle.PTraversal[S,T,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyTraversal.traversal" title="=&gt; monocle.PTraversal[S,T,A,B]">traversal</a> <a href="../Traversal.scala.html#monocle;PTraversal.composeOptional" title="(other: monocle.POptional[A,B,C,D])monocle.PTraversal[S,T,C,D]">composeOptional</a> <a href="#monocle.syntax;ApplyTraversal.composeOptional.other" title="monocle.POptional[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyTraversal.composePrism">composePrism</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversal.composePrism;C">C</a>, <a title="" id="monocle.syntax;ApplyTraversal.composePrism;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[A,B,C,D]" id="monocle.syntax;ApplyTraversal.composePrism.other">other</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[A,B,C,D]">PPrism</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyTraversal.readResolve" title="(s: S, traversal: monocle.PTraversal[S,T,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyTraversal.traversal" title="=&gt; monocle.PTraversal[S,T,A,B]">traversal</a> <a href="../Traversal.scala.html#monocle;PTraversal.composePrism" title="(other: monocle.PPrism[A,B,C,D])monocle.PTraversal[S,T,C,D]">composePrism</a>  <a href="#monocle.syntax;ApplyTraversal.composePrism.other" title="monocle.PPrism[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyTraversal.composeLens">composeLens</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversal.composeLens;C">C</a>, <a title="" id="monocle.syntax;ApplyTraversal.composeLens;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplyTraversal.composeLens.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyTraversal.readResolve" title="(s: S, traversal: monocle.PTraversal[S,T,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyTraversal.traversal" title="=&gt; monocle.PTraversal[S,T,A,B]">traversal</a> <a href="../Traversal.scala.html#monocle;PTraversal.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.PTraversal[S,T,C,D]">composeLens</a> <a href="#monocle.syntax;ApplyTraversal.composeLens.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  @inline def <a title="[C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyTraversal.composeIso">composeIso</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversal.composeIso;C">C</a>, <a title="" id="monocle.syntax;ApplyTraversal.composeIso;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplyTraversal.composeIso.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax.ApplyTraversal.readResolve" title="(s: S, traversal: monocle.PTraversal[S,T,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.s" title="=&gt; S">s</a>, <a href="#monocle.syntax;ApplyTraversal.traversal" title="=&gt; monocle.PTraversal[S,T,A,B]">traversal</a> <a href="../Traversal.scala.html#monocle;PTraversal.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.PTraversal[S,T,C,D]">composeIso</a> <a href="#monocle.syntax;ApplyTraversal.composeIso.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>

  <span class="comment">/** alias to composeTraversal */</span>
  @inline def <a title="[C, D](other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyTraversal.^|->>">^|-&gt;&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversal.^|->>;C">C</a>, <a title="" id="monocle.syntax;ApplyTraversal.^|->>;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PTraversal[A,B,C,D]" id="monocle.syntax;ApplyTraversal.^|->>.other">other</a>: <a href="../Traversal.scala.html#monocle;PTraversal" title="monocle.PTraversal[A,B,C,D]">PTraversal</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyTraversal.composeTraversal" title="(other: monocle.PTraversal[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">composeTraversal</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.^|->>.other" title="monocle.PTraversal[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeOptional */</span>
  @inline def <a title="[C, D](other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyTraversal.^|-?">^|-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversal.^|-?;C">C</a>, <a title="" id="monocle.syntax;ApplyTraversal.^|-?;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.POptional[A,B,C,D]" id="monocle.syntax;ApplyTraversal.^|-?.other">other</a>: <a href="../Optional.scala.html#monocle;POptional" title="monocle.POptional[A,B,C,D]">POptional</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyTraversal.composeOptional" title="(other: monocle.POptional[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">composeOptional</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.^|-?.other" title="monocle.POptional[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composePrism */</span>
  @inline def <a title="[C, D](other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyTraversal.^<-?">^&lt;-?</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversal.^<-?;C">C</a>, <a title="" id="monocle.syntax;ApplyTraversal.^<-?;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PPrism[A,B,C,D]" id="monocle.syntax;ApplyTraversal.^<-?.other">other</a>: <a href="../Prism.scala.html#monocle;PPrism" title="monocle.PPrism[A,B,C,D]">PPrism</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyTraversal.composePrism" title="(other: monocle.PPrism[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">composePrism</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.^<-?.other" title="monocle.PPrism[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeLens */</span>
  @inline def <a title="[C, D](other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyTraversal.^|->">^|-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversal.^|->;C">C</a>, <a title="" id="monocle.syntax;ApplyTraversal.^|->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PLens[A,B,C,D]" id="monocle.syntax;ApplyTraversal.^|->.other">other</a>: <a href="../Lens.scala.html#monocle;PLens" title="monocle.PLens[A,B,C,D]">PLens</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyTraversal.composeLens" title="(other: monocle.PLens[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">composeLens</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.^|->.other" title="monocle.PLens[A,B,C,D]">other</a><span class="delimiter">)</span>
  <span class="comment">/** alias to composeIso */</span>
  @inline def <a title="[C, D](other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]" id="monocle.syntax;ApplyTraversal.^<->">^&lt;-&gt;</a><span class="delimiter">[</span><a title="" id="monocle.syntax;ApplyTraversal.^<->;C">C</a>, <a title="" id="monocle.syntax;ApplyTraversal.^<->;D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="monocle.PIso[A,B,C,D]" id="monocle.syntax;ApplyTraversal.^<->.other">other</a>: <a href="../Iso.scala.html#monocle;PIso" title="monocle.PIso[A,B,C,D]">PIso</a><span class="delimiter">[</span>A, B, C, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.syntax.ApplyTraversal.readResolve" title="monocle.syntax.ApplyTraversal[S,T,C,D]">ApplyTraversal</a><span class="delimiter">[</span>S, T, C, D<span class="delimiter">]</span> = <a href="#monocle.syntax;ApplyTraversal.composeIso" title="(other: monocle.PIso[A,B,C,D])monocle.syntax.ApplyTraversal[S,T,C,D]">composeIso</a><span class="delimiter">(</span><a href="#monocle.syntax;ApplyTraversal.^<->.other" title="monocle.PIso[A,B,C,D]">other</a><span class="delimiter">)</span>
<span class="delimiter">}</span>
        </pre>
    </body>
</html>
