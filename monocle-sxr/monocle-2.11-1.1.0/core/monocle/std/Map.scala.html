<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>core/monocle/std/Map.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
package monocle.std

import monocle.function._
import monocle.<span class="delimiter">{</span>Lens, Prism, Traversal<span class="delimiter">}</span>

import scalaz.std.<span title="scalaz.std.list.type">list</span>._
import scalaz.std.<span title="scalaz.std.map.type">map</span>._
import scalaz.syntax.<span title="scalaz.syntax.traverse.type">traverse</span>._
import scalaz.Applicative

object <a title="monocle.std.map.type" id="monocle.std.map">map</a> extends <a href="#monocle.std;MapInstances" title="monocle.std.MapInstances">MapInstances</a>

trait <a title="trait MapInstances extends AnyRef" id="monocle.std;MapInstances">MapInstances</a> <span title="Unit" class="delimiter">{</span>

  implicit def <a title="[K, V]=&gt; monocle.function.Empty[Map[K,V]]" id="monocle.std;MapInstances.mapEmpty">mapEmpty</a><span class="delimiter">[</span><a title="" id="monocle.std;MapInstances.mapEmpty;K">K</a>, <a title="" id="monocle.std;MapInstances.mapEmpty;V">V</a><span class="delimiter">]</span>: <a href="../function/Empty.scala.html#monocle.function;Empty" title="monocle.function.Empty[Map[K,V]]">Empty</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> = new <a title="&lt;$anon: monocle.function.Empty[Map[K,V]]&gt; extends AnyRef with monocle.function.Empty[Map[K,V]]" id="monocle.std;MapInstances.mapEmpty;$anon">Empty</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="=&gt; monocle.Prism[Map[K,V],Unit]" id="monocle.std;MapInstances.mapEmpty;$anon.empty">empty</a> = <a href="../Prism.scala.html#monocle.Prism.apply" title="[S, A](_getOption: S =&gt; Option[A])(_reverseGet: A =&gt; S)monocle.Prism[S,A]">Prism</a><span title="(_getOption: Map[K,V] =&gt; Option[Unit])(_reverseGet: Unit =&gt; Map[K,V])monocle.Prism[Map[K,V],Unit]" class="delimiter">[</span><span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <span title="Unit">Unit</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,V]" id="monocle.std;MapInstances.mapEmpty;$anon.empty.$anonfun.m">m</a> =&gt; if<span class="delimiter">(</span><a href="#monocle.std;MapInstances.mapEmpty;$anon.empty.$anonfun.m" title="Map[K,V]">m</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="(x: Unit)Some[Unit]">Some</span><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> else <span title="None.type">None</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Unit" id="monocle.std;MapInstances.mapEmpty;$anon.empty.$anonfun.x$1">_</a> =&gt; <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[K,Nothing]">empty</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  implicit def <a title="[K, V]=&gt; monocle.function.At[Map[K,V],K,V]" id="monocle.std;MapInstances.atMap">atMap</a><span class="delimiter">[</span><a title="" id="monocle.std;MapInstances.atMap;K">K</a>, <a title="" id="monocle.std;MapInstances.atMap;V">V</a><span class="delimiter">]</span>: <a href="../function/At.scala.html#monocle.function;At" title="monocle.function.At[Map[K,V],K,V]">At</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, K, V<span class="delimiter">]</span> = new <a title="&lt;$anon: monocle.function.At[Map[K,V],K,V]&gt; extends AnyRef with monocle.function.At[Map[K,V],K,V]" id="monocle.std;MapInstances.atMap;$anon">At</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, K, V<span class="delimiter">]</span><span class="delimiter">{</span>
    def <a title="(i: K)monocle.Lens[Map[K,V],Option[V]]" id="monocle.std;MapInstances.atMap;$anon.at">at</a><span class="delimiter">(</span><a title="K" id="monocle.std;MapInstances.atMap;$anon.at.i">i</a>: <a href="#monocle.std;MapInstances.atMap;K" title="K">K</a><span class="delimiter">)</span> = <a href="../Lens.scala.html#monocle.Lens.apply" title="(get: Map[K,V] =&gt; Option[V])(set: Option[V] =&gt; (Map[K,V] =&gt; Map[K,V]))monocle.Lens[Map[K,V],Option[V]]">Lens</a><span class="delimiter">{</span>m: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> =&gt; <a href="#monocle.std;MapInstances.atMap;$anon.at.$anonfun.m" title="Map[K,V]">m</a>.<span title="(key: K)Option[V]">get</span><span class="delimiter">(</span><a href="#monocle.std;MapInstances.atMap;$anon.at.i" title="K">i</a><span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">(</span><a title="Option[V]" id="monocle.std;MapInstances.atMap;$anon.at.$anonfun.optV">optV</a> =&gt; <a title="Map[K,V]" id="monocle.std;MapInstances.atMap;$anon.at.$anonfun.$anonfun.map">map</a> =&gt; <a href="#monocle.std;MapInstances.atMap;$anon.at.$anonfun.optV" title="Option[V]">optV</a>.<span title="(ifEmpty: =&gt; scala.collection.immutable.Map[K,V])(f: V =&gt; scala.collection.immutable.Map[K,V])scala.collection.immutable.Map[K,V]">fold</span><span class="delimiter">(</span><a href="#monocle.std;MapInstances.atMap;$anon.at.$anonfun.$anonfun.map" title="Map[K,V]">map</a> <span title="(key: K)scala.collection.immutable.Map[K,V]">-</span> <a href="#monocle.std;MapInstances.atMap;$anon.at.i" title="K">i</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="V" id="monocle.std;MapInstances.atMap;$anon.at.$anonfun.$anonfun.$anonfun.v">v</a> =&gt; <a href="#monocle.std;MapInstances.atMap;$anon.at.$anonfun.$anonfun.map" title="Map[K,V]">map</a> <span title="(kv: (K, V))scala.collection.immutable.Map[K,V]">+</span> <span class="delimiter">(</span><a href="#monocle.std;MapInstances.atMap;$anon.at.i" title="(self: K)ArrowAssoc[K]">i</a> <span title="(y: V)(K, V)">-&gt;</span> <a href="#monocle.std;MapInstances.atMap;$anon.at.$anonfun.$anonfun.$anonfun.v" title="V">v</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  implicit def <a title="[K, V]=&gt; monocle.function.Each[Map[K,V],V]" id="monocle.std;MapInstances.mapEach">mapEach</a><span class="delimiter">[</span><a title="" id="monocle.std;MapInstances.mapEach;K">K</a>, <a title="" id="monocle.std;MapInstances.mapEach;V">V</a><span class="delimiter">]</span>: <a href="../function/Each.scala.html#monocle.function;Each" title="monocle.function.Each[Map[K,V],V]">Each</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, V<span class="delimiter">]</span> = <a href="../function/Each.scala.html#monocle.function.Each" title="monocle.function.Each.type">Each</a>.<a href="../function/Each.scala.html#monocle.function;EachFunctions.traverseEach" title="[S[_], A](implicit evidence$1: scalaz.Traverse[S])monocle.function.Each[S[A],A]">traverseEach</a><span title="(implicit evidence$1: scalaz.Traverse[[X_kp1]scala.collection.immutable.Map[K,X_kp1]])monocle.function.Each[scala.collection.immutable.Map[K,V],V]" class="delimiter">[</span>Map<span class="delimiter">[</span>K, ?<span class="delimiter">]</span>, <a href="#monocle.std;MapInstances.mapEach;V" title="V">V</a><span class="delimiter">]</span>

  implicit def <a title="[K, V]=&gt; monocle.function.Index[Map[K,V],K,V]" id="monocle.std;MapInstances.mapIndex">mapIndex</a><span class="delimiter">[</span><a title="" id="monocle.std;MapInstances.mapIndex;K">K</a>, <a title="" id="monocle.std;MapInstances.mapIndex;V">V</a><span class="delimiter">]</span>: <a href="../function/Index.scala.html#monocle.function;Index" title="monocle.function.Index[Map[K,V],K,V]">Index</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, K  , V<span class="delimiter">]</span> = <a href="../function/Index.scala.html#monocle.function.Index" title="monocle.function.Index.type">Index</a>.<a href="../function/Index.scala.html#monocle.function;IndexFunctions.atIndex" title="(implicit ev: monocle.function.At[Map[K,V],K,V])monocle.function.Index[Map[K,V],K,V]">atIndex</a>

  implicit def <a title="[K, V]=&gt; monocle.function.FilterIndex[Map[K,V],K,V]" id="monocle.std;MapInstances.mapFilterIndex">mapFilterIndex</a><span class="delimiter">[</span><a title="" id="monocle.std;MapInstances.mapFilterIndex;K">K</a>, <a title="" id="monocle.std;MapInstances.mapFilterIndex;V">V</a><span class="delimiter">]</span>: <a href="../function/FilterIndex.scala.html#monocle.function;FilterIndex" title="monocle.function.FilterIndex[Map[K,V],K,V]">FilterIndex</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K,V<span class="delimiter">]</span>, K, V<span class="delimiter">]</span> = new <a title="&lt;$anon: monocle.function.FilterIndex[Map[K,V],K,V]&gt; extends AnyRef with monocle.function.FilterIndex[Map[K,V],K,V]" id="monocle.std;MapInstances.mapFilterIndex;$anon">FilterIndex</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, K, V<span class="delimiter">]</span> <span class="delimiter">{</span>
    import scalaz.syntax.<span title="scalaz.syntax.applicative.type">applicative</span>._
    def <a title="(predicate: K =&gt; Boolean)monocle.Traversal[Map[K,V],V]" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex">filterIndex</a><span class="delimiter">(</span><a title="K =&gt; Boolean" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex.predicate">predicate</a>: K =&gt; Boolean<span class="delimiter">)</span> = new <a title="&lt;$anon: monocle.Traversal[Map[K,V],V]&gt; extends monocle.Traversal[Map[K,V],V]" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon">Traversal</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span>, V<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="[F[_]](f: V =&gt; F[V])(s: Map[K,V])(implicit evidence$1: scalaz.Applicative[F])F[Map[K,V]]" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF">modifyF</a><span class="delimiter">[</span><a title="[_]" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF;F">F</a><span class="delimiter">[</span><a title="" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF;F;_">_</a><span class="delimiter">]</span>: Applicative<span class="delimiter">]</span><span class="delimiter">(</span><a title="V =&gt; F[V]" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF.f">f</a>: V =&gt; F<span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Map[K,V]" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF.s">s</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF;F" title="F[Map[K,V]]">F</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> =
        <a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF.s" title="Map[K,V]">s</a>.<span title="(v: List[(K, V)])(implicit F0: scalaz.Traverse[List])scalaz.syntax.TraverseOps[List,(K, V)]">toList</span>.<span title="(f: ((K, V)) =&gt; F[(K, V)])(implicit G: scalaz.Applicative[F])F[List[(K, V)]]">traverse</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.x0$1" title="(v: F[List[(K, V)]])(implicit F0: scalaz.Functor[F])scalaz.syntax.FunctorOps[F,List[(K, V)]]" class="delimiter">{</a> case <span class="delimiter">(</span><a title="K" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.k">k</a>, <a title="V" id="monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.v">v</a><span class="delimiter">)</span> =&gt;
          <span class="delimiter">(</span>if<span class="delimiter">(</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex.predicate" title="(v1: K)Boolean">predicate</a><span class="delimiter">(</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.k" title="K">k</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF.f" title="(v1: V)F[V]">f</a><span class="delimiter">(</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.v" title="V">v</a><span class="delimiter">)</span> else <a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.v" title="(v: =&gt; V)scalaz.syntax.applicative.ApplicativeIdV[V]{lazy val self: V}">v</a>.<span title="[F[_]](implicit evidence$1: scalaz.Applicative[F])F[V]">point</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF.evidence$1" title="(implicit evidence$1: scalaz.Applicative[F])F[V]" class="delimiter">[</a><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF;F" title="F">F</a><span class="delimiter">]</span><span class="delimiter">)</span>.<span title="(b: K)F[(K, V)]">strengthL</span><span class="delimiter">(</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.k" title="K">k</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>.<span title="(f: List[(K, V)] =&gt; scala.collection.immutable.Map[K,V])F[scala.collection.immutable.Map[K,V]]">map</span><span class="delimiter">(</span><a href="#monocle.std;MapInstances.mapFilterIndex;$anon.filterIndex;$anon.modifyF.$anonfun.x$2" title="List[(K, V)]">_</a>.<span title="(implicit ev: &lt;:&lt;[(K, V),(K, V)])scala.collection.immutable.Map[K,V]">toMap</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
