<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>org/specs2/collection/Seqx.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> org.specs2
<span class="keyword">package</span> collection

<span class="keyword">import</span> internal.scalaz._
<span class="keyword">import</span> <span title="object org.specs2.internal.scalaz.Generator">Generator</span>._

<span class="comment">/**
 * This trait provides additional methods on Seqs and nested Seqs
 */</span>
<span class="keyword">private</span><span class="delimiter">[</span>specs2<span class="delimiter">]</span>
<span class="keyword">trait</span> <a title="trait Seqx extends java.lang.Object with ScalaObject" id="9901">Seqx</a> <span title="ScalaObject" class="delimiter">{</span> outer =&gt;

  <span class="comment">/** @return an extension for a nested seq */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](seq: Seq[Seq[T]])Seqx.this.ExtendedNestedSeq[T]" id="48716">extendNestedSeq</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48718">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[Seq[T]]" id="92591">seq</a>: <span title="Seq[Seq[T]]">Seq</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#48719" title="Seqx.this.ExtendedNestedSeq[T]">ExtendedNestedSeq</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="Seqx.this.ExtendedNestedSeq[T]" class="keyword">new</span> <a href="#48719" title="Seqx.this.ExtendedNestedSeq[T]">ExtendedNestedSeq</a><span class="delimiter">(</span><a href="#92591" title="Seq[Seq[T]]">seq</a><span class="delimiter">)</span>
  <span class="comment">/**
   * Additional methods for nested seqs
   */</span>
  <span class="keyword">class</span> <a title="class ExtendedNestedSeq[T] extends java.lang.Object with ScalaObject" id="48719">ExtendedNestedSeq</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48720">T</a><span class="delimiter">]</span><a href="#48719" title="ScalaObject" class="delimiter">(</a><a title="Seq[Seq[T]]" id="93853">seq</a>: <span title="Seq[Seq[T]]">Seq</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Seq[Seq[T]]" id="92775">safeTranspose</a> = <a href="#9901" title="Seqx.this.type">outer</a>.<a href="#48726" title="(xs: Seq[Seq[T]])Seq[Seq[T]]">transpose</a><span class="delimiter">(</span><a href="#93853" title="Seq[Seq[T]]">seq</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/** @return an extension for a seq */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](seq: Seq[T])Seqx.this.ExtendedSeq[T]" id="48721">extendSeq</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48723">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[T]" id="92588">seq</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#48724" title="Seqx.this.ExtendedSeq[T]">ExtendedSeq</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="Seqx.this.ExtendedSeq[T]" class="keyword">new</span> <a href="#48724" title="Seqx.this.ExtendedSeq[T]">ExtendedSeq</a><span class="delimiter">(</span><a href="#92588" title="Seq[T]">seq</a><span class="delimiter">)</span>
  <span class="comment">/**
   * Additional methods for seqs
   */</span>
  <span class="keyword">class</span> <a title="class ExtendedSeq[T] extends java.lang.Object with ScalaObject" id="48724">ExtendedSeq</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48725">T</a><span class="delimiter">]</span><a href="#48724" title="ScalaObject" class="delimiter">(</a><a title="Seq[T]" id="93904">seq</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="keyword">def</span> <a title="[S](reducer: org.specs2.internal.scalaz.Reducer[T,S])S" id="92763">reduceWith</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="92765">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="org.specs2.internal.scalaz.Reducer[T,S]" id="93927">reducer</a>: <span title="org.specs2.internal.scalaz.Reducer[T,S]">Reducer</span><span class="delimiter">[</span>T, S<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="[F[_]](implicit evidence$2: org.specs2.internal.scalaz.Foldable[F])org.specs2.internal.scalaz.Generator[F]">FoldlGenerator</span><span title="(implicit evidence$2: org.specs2.internal.scalaz.Foldable[Seq])org.specs2.internal.scalaz.Generator[Seq]" class="delimiter">[</span><span title="Seq">Seq</span><span class="delimiter">]</span>.<span title="(r: org.specs2.internal.scalaz.Reducer[T,S], c: Seq[T])S">reduce</span><span class="delimiter">(</span><a href="#93927" title="org.specs2.internal.scalaz.Reducer[T,S]">reducer</a>, <a href="#93904" title="Seq[T]">seq</a><span class="delimiter">)</span>

    <span class="comment">/** update the last element if there is one */</span>
    <span class="keyword">def</span> <a title="(f: T =&gt; T)Seq[T]" id="92766">updateLast</a><span class="delimiter">(</span><a title="T =&gt; T" id="93991">f</a>: T =&gt; T<span class="delimiter">)</span> = <a href="#93904" title="Seq[T]">seq</a> <span title="Seq[T]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Seq[T]" id="94025">s</a> <a href="#93995" title="(l: Seq[T])Option[(Seq[T], T)]">:+</a> <a title="T" id="94026">last</a> =&gt; <a href="#94025" title="Seq[T]">s</a> <span title="(elem: T)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[T],T,Seq[T]])Seq[T]">:+</span> <a href="#93991" title="(v1: T)T">f</a><span class="delimiter">(</span><a href="#94026" title="T">last</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Seq[T]" id="94064">other</a>     =&gt; <a href="#94064" title="Seq[T]">other</a>
    <span class="delimiter">}</span>

    <span class="comment">/** update the last element or start the sequence with a new init value */</span>
    <span class="keyword">def</span> <a title="(f: PartialFunction[T,T])(initValue: =&gt; T)Seq[T]" id="92767">updateLastOr</a><span class="delimiter">(</span><a title="PartialFunction[T,T]" id="94067">f</a>: <span title="PartialFunction[T,T]">PartialFunction</span><span class="delimiter">[</span>T, T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; T" id="94068">initValue</a>: =&gt;T<span class="delimiter">)</span> = <a href="#93904" title="Seq[T]">seq</a> <span title="Seq[T]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="Seq[T]" id="94095">s</a> <a href="#93995" title="(l: Seq[T])Option[(Seq[T], T)]">:+</a> <a title="T" id="94096">last</a> =&gt; <a href="#94095" title="Seq[T]">s</a> <span title="(elem: T)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[T],T,Seq[T]])Seq[T]">:+</span> <a href="#94067" title="(v1: T)T">f</a><span class="delimiter">(</span><a href="#94096" title="T">last</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="Seq[T]" id="94134">other</a>     =&gt; <a href="#93904" title="Seq[T]">seq</a> <span title="(elem: T)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[T],T,Seq[T]])Seq[T]">:+</span> <a href="#94068" title="=&gt; T">initValue</a>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * remove the first element satisfying the predicate
     * @return a seq minus the first element satisfying the predicate
     */</span>
    <span class="keyword">def</span> <a title="(predicate: T =&gt; Boolean)Seq[T]" id="92768">removeFirst</a><span class="delimiter">(</span><a title="T =&gt; Boolean" id="92814">predicate</a>: T =&gt; Boolean<span class="delimiter">)</span>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#94172" title="(Seq[T], Seq[T])" class="delimiter">(</a><a href="#94171" title="Seq[T]" id="94172">withoutElement</a>, <a href="#94171" title="Seq[T]" id="94173">startWithElement</a><span class="delimiter">)</span> = <a href="#93904" title="Seq[T]">seq</a> <span title="(p: T =&gt; Boolean)(Seq[T], Seq[T])">span</span> <span class="delimiter">(</span><a title="T" id="94177">x</a> =&gt; <span title="=&gt; Boolean">!</span><a href="#92814" title="(v1: T)Boolean">predicate</a><span class="delimiter">(</span><a href="#94177" title="T">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#94172" title="Seq[T]">withoutElement</a> <span title="(that: scala.collection.GenTraversableOnce[T])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[T],T,Seq[T]])Seq[T]">++</span> <a href="#94173" title="Seq[T]">startWithElement</a>.<span title="(n: Int)Seq[T]">drop</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * @return all the elements in seq which are not in other, even if they are duplicates: Seq(1, 1).diff(Seq(1)) == Seq(1)
     *         this uses a user given comparison function
     */</span>
    <span class="keyword">def</span> <a title="[S](other: Seq[S], compare: (T, S) =&gt; Boolean)Seq[T]" id="92769">delta</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="92771">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[S]" id="94227">other</a>: <span title="Seq[S]">Seq</span><span class="delimiter">[</span>S<span class="delimiter">]</span>, <a title="(T, S) =&gt; Boolean" id="94228">compare</a>: <span class="delimiter">(</span>T, S<span class="delimiter">)</span> =&gt; Boolean<span class="delimiter">)</span>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(ls1: Seq[T], ls2: Seq[S], result: Seq[T])Seq[T]" id="94232">notFound</a><span class="delimiter">(</span><a title="Seq[T]" id="94233">ls1</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Seq[S]" id="94234">ls2</a>: <span title="Seq[S]">Seq</span><span class="delimiter">[</span>S<span class="delimiter">]</span>, <a title="Seq[T]" id="94236">result</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="(elems: Nothing*)Seq[Nothing]">Seq</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span> =
        <a href="#94233" title="Seq[T]">ls1</a> <span title="Seq[T]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#94242" title="Seq[T]">Seq</a><span class="delimiter">(</span><span class="delimiter">)</span>        =&gt; <a href="#94236" title="Seq[T]">result</a>
          <span class="keyword">case</span> <a title="Seq[T]" id="94284">head</a> <a href="#94254" title="(l: Seq[T])Option[(T, Seq[T])]">+:</a> <a title="Seq[T]" id="94285">rest</a> =&gt;
            <span title="Seq[T]" class="keyword">if</span>  <span class="delimiter">(</span><a href="#94234" title="Seq[S]">ls2</a>.<span title="(p: S =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#94228" title="(v1: T, v2: S)Boolean">compare</a><span class="delimiter">(</span><a href="#94284" title="T">head</a>, <a href="#94291" title="S">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#94232" title="(ls1: Seq[T], ls2: Seq[S], result: Seq[T])Seq[T]">notFound</a><span class="delimiter">(</span><a href="#94285" title="Seq[T]">rest</a>, <a href="#48721" title="(seq: Seq[S])Seqx.this.ExtendedSeq[S]">ls2</a>.<a href="#92768" title="(predicate: S =&gt; Boolean)Seq[S]">removeFirst</a><span class="delimiter">(</span><a title="S" id="94331">l</a> =&gt; <a href="#94228" title="(v1: T, v2: S)Boolean">compare</a><span class="delimiter">(</span><a href="#94284" title="T">head</a>, <a href="#94331" title="S">l</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#94236" title="Seq[T]">result</a><span class="delimiter">)</span>
            <span class="keyword">else</span>                               <a href="#94232" title="(ls1: Seq[T], ls2: Seq[S], result: Seq[T])Seq[T]">notFound</a><span class="delimiter">(</span><a href="#94285" title="Seq[T]">rest</a>, <a href="#94234" title="Seq[S]">ls2</a>, <a href="#94236" title="Seq[T]">result</a> <span title="(elem: T)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[T],T,Seq[T]])Seq[T]">:+</span> <a href="#94284" title="T">head</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <a href="#94232" title="(ls1: Seq[T], ls2: Seq[S], result: Seq[T])Seq[T]">notFound</a><span class="delimiter">(</span><a href="#93904" title="Seq[T]">seq</a>, <a href="#94227" title="Seq[S]">other</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This methods works like the transpose method defined on Traversable
   * but it doesn't fail when the input is not formatted like a regular matrix
   *
   *  List(List(&quot;a&quot;,  &quot;bb&quot;, &quot;ccc&quot;),
   *       List(&quot;dd&quot;, &quot;e&quot;,  &quot;fff&quot;)) =&gt;
   *  List(List(&quot;a&quot;,  &quot;dd&quot;),
   *       List(&quot;e&quot;,  &quot;bb&quot;)
   *       List(&quot;ccc&quot;,  &quot;fff&quot;))
   */</span>
  <span class="keyword">def</span> <a title="[T](xs: Seq[Seq[T]])Seq[Seq[T]]" id="48726">transpose</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="48728">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[Seq[T]]" id="93879">xs</a>: <span title="Seq[Seq[T]]">Seq</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[Seq[T]]">Seq</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Seq[Seq[T]]" id="94371">filtered</a> = <a href="#93879" title="Seq[Seq[T]]">xs</a>.<span title="(p: Seq[T] =&gt; Boolean)Seq[Seq[T]]">filter</span><span class="delimiter">(</span><a href="#94375" title="Seq[T]">_</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span>
    <span title="Seq[Seq[T]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#94371" title="Seq[Seq[T]]">filtered</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="(elems: Nothing*)Seq[Nothing]">Seq</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="#94371" title="Seq[Seq[T]]">filtered</a>.<span title="(f: Seq[T] =&gt; T)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Seq[T]],T,Seq[T]])Seq[T]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,T,Seq[T]]" class="delimiter">(</span><a href="#94405" title="Seq[T]">_</a>.<span title="=&gt; T">head</span><span class="delimiter">)</span> <a href="#94388" title="(elem: Seq[T])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Seq[T]],Seq[T],Seq[Seq[T]]])Seq[Seq[T]]">+:</a> <a href="#48726" title="(xs: Seq[Seq[T]])Seq[Seq[T]]">transpose</a><span class="delimiter">(</span><a href="#94371" title="Seq[Seq[T]]">filtered</a>.<span title="(f: Seq[T] =&gt; Seq[T])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Seq[T]],Seq[T],Seq[Seq[T]]])Seq[Seq[T]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,Seq[T],Seq[Seq[T]]]" class="delimiter">(</span><a href="#94446" title="Seq[T]">_</a>.<span title="=&gt; Seq[T]">tail</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * extrator for the first element of Seq[T]
 */</span>
<span class="keyword">object</span> <a title="object org.specs2.collection.+:" id="9902">+:</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[T](l: Seq[T])Option[(T, Seq[T])]" id="94254">unapply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="94256">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[T]" id="94257">l</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[(T, Seq[T])]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>T, Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="Option[(T, Seq[T])]" class="keyword">if</span><span class="delimiter">(</span><a href="#94257" title="Seq[T]">l</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="object None">None</span>
    <span class="keyword">else</span>          <span title="(x: (T, Seq[T]))Some[(T, Seq[T])]">Some</span><span title="(_1: T, _2: Seq[T])(T, Seq[T])" class="delimiter">(</span><a href="#94257" title="Seq[T]">l</a>.<span title="=&gt; T">head</span>, <a href="#94257" title="Seq[T]">l</a>.<span title="=&gt; Seq[T]">tail</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * extrator for the last element of Seq[T]
 */</span>
<span class="keyword">object</span> <a title="object org.specs2.collection.:+" id="9904">:+</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[T](l: Seq[T])Option[(Seq[T], T)]" id="93995">unapply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="93997">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[T]" id="93998">l</a>: <span title="Seq[T]">Seq</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[(Seq[T], T)]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>Seq<span class="delimiter">[</span>T<span class="delimiter">]</span>, T<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="Option[(Seq[T], T)]" class="keyword">if</span><span class="delimiter">(</span><a href="#93998" title="Seq[T]">l</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="object None">None</span>
    <span class="keyword">else</span>          <span title="(x: (Seq[T], T))Some[(Seq[T], T)]">Some</span><span title="(_1: Seq[T], _2: T)(Seq[T], T)" class="delimiter">(</span><a href="#93998" title="Seq[T]">l</a>.<span title="=&gt; Seq[T]">init</span>, <a href="#93998" title="Seq[T]">l</a>.<span title="=&gt; T">last</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">private</span><span class="delimiter">[</span>specs2<span class="delimiter">]</span>
<span class="keyword">object</span> <a title="object org.specs2.collection.Seqx" id="9906">Seqx</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#9901" title="org.specs2.collection.Seqx">Seq</a>x
        </pre>
    </body>
</html>