<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>concurrent/concurrent/Future.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz.concurrent

<span class="keyword">import</span> java.util.concurrent.<span class="delimiter">{</span>Callable, ConcurrentLinkedQueue, CountDownLatch, Executors, ExecutorService<span class="delimiter">}</span>
<span class="keyword">import</span> java.util.concurrent.atomic.<span class="delimiter">{</span>AtomicBoolean, AtomicReference<span class="delimiter">}</span>

<span class="keyword">import</span> collection.<span title="scala.collection.JavaConversions.type">JavaConversions</span>._

<span class="keyword">import</span> scalaz.<span class="delimiter">{</span>Monad, Nondeterminism<span class="delimiter">}</span>
<span class="keyword">import</span> scalaz.<a href="../../core/Free.scala.html#10908" title="scalaz.Free.type">Free</a>.Trampoline
<span class="keyword">import</span> scalaz.Free
<span class="keyword">import</span> scalaz.Trampoline
<span class="keyword">import</span> scalaz.syntax.<a href="../../core/syntax/Syntax.scala.html#30951" title="scalaz.syntax.monad.type">monad</a>._
<span class="keyword">import</span> scalaz.std.<a href="../../core/std/Function.scala.html#24791" title="scalaz.std.function.type">function</a>._

/** 
 * `Future` is a trampolined computation producing an `A` that may 
 * include asynchronous steps. Like `Trampoline`, arbitrary 
 * monadic expressions involving `map` and `flatMap` are guaranteed
 * to use constant stack space. But in addition, one may construct a
 * `Future` from an asynchronous computation, represented as a
 * function, `listen: (A =&gt; Unit) =&gt; Unit`, which registers a callback
 * that will be invoked when the result becomes available. This makes 
 * `Future` useful as a concurrency primitive and as a control 
 * structure for wrapping callback-based APIs with a more 
 * straightforward, monadic API.
 * 
 * Unlike the `Future` implementation in scala 2.10, `map` and 
 * `flatMap` do NOT spawn new tasks and do not require an implicit
 * `ExecutionContext`. Instead, `map` and `flatMap` merely add to 
 * the current (trampolined) continuation that will be run by the 
 * 'current' thread, unless explicitly forked via `Future.fork` or 
 * `Future.apply`. This means that `Future` achieves much better thread
 * reuse than the 2.10 implementation and avoids needless thread
 * pool submit cycles. 
 *  
 * `Future` also differs from the scala 2.10 `Future` type in that it 
 * does not necessarily represent a _running_ computation. Instead, we
 * reintroduce nondeterminism _explicitly_ using the functions of the
 * `scalaz.Nondeterminsm` interface. This simplifies our implementation 
 * and makes code easier to reason about, since the order of effects 
 * and the points of nondeterminism are made fully explicit and do not
 * depend on Scala's evaluation order. 
 * 
 * IMPORTANT NOTE: `Future` does not include any error handling and
 * should generally only be used as a building block by library 
 * writers who want to build on `Future`'s capabilities but wish to 
 * design their own error handling strategy. See 
 * `scalaz.concurrent.Task` for a type that extends `Future` with 
 * proper error handling -- it is merely a wrapper for 
 * `Future[Throwable \/ A]` with a number of additional
 * convenience functions.
 */
<span class="keyword">trait</span> <a title="trait Future[+A] extends AnyRef" id="22751">Future</a><span class="delimiter">[</span>+<a title="" id="22752">A</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">import</span> <a href="#22753" title="scalaz.concurrent.Future.type">Future</a>._

  <span class="keyword">def</span> <a title="[B](f: A =&gt; scalaz.concurrent.Future[B])scalaz.concurrent.Future[B]" id="47873">flatMap</a><span class="delimiter">[</span><a title="" id="47875">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scalaz.concurrent.Future[B]" id="47931">f</a>: A =&gt; Future<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#22751" title="scalaz.concurrent.Future[B]">Future</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <a href="#22751" title="scalaz.concurrent.Future[A]" class="keyword">this</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> Now<a href="#1674563" title="scalaz.concurrent.Future[B]" class="delimiter">(</a><a href="#59617" title="A" id="47965">a</a><span class="delimiter">)</span> =&gt; <a href="#60030" title="(thunk: () =&gt; scalaz.concurrent.Future[B])scalaz.concurrent.Future.Suspend[B]">Suspend</a><a href="#1674570" title="(x: scalaz.concurrent.Future[B])scalaz.concurrent.Future[B]" class="delimiter">(</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#47931" title="(v1: A)scalaz.concurrent.Future[B]">f</a><span class="delimiter">(</span><a href="#47965" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> Suspend<a href="#1674563" title="scalaz.concurrent.Future[B]" class="delimiter">(</a><a href="#47974" title="() =&gt; scalaz.concurrent.Future[A]" id="48005">thunk</a><span class="delimiter">)</span> =&gt; <a href="#60036" title="(thunk: () =&gt; scalaz.concurrent.Future[A], f: A =&gt; scalaz.concurrent.Future[B])scalaz.concurrent.Future.BindSuspend[A,B]">BindSuspend</a><a href="#1674570" title="(x: scalaz.concurrent.Future[B])scalaz.concurrent.Future[B]" class="delimiter">(</a><a href="#48005" title="() =&gt; scalaz.concurrent.Future[A]">thunk</a>, <a href="#47931" title="A =&gt; scalaz.concurrent.Future[B]">f</a><span class="delimiter">)</span>
    <span class="keyword">case</span> Async<a href="#1674563" title="scalaz.concurrent.Future[B]" class="delimiter">(</a><a href="#48682" title="(A =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit" id="48075">listen</a><span class="delimiter">)</span> =&gt; <a href="#60042" title="(onFinish: (A =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit, f: A =&gt; scalaz.concurrent.Future[B])scalaz.concurrent.Future.BindAsync[A,B]">BindAsync</a><a href="#1674570" title="(x: scalaz.concurrent.Future[B])scalaz.concurrent.Future[B]" class="delimiter">(</a><a href="#48075" title="(A =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit">listen</a>, <a href="#47931" title="A =&gt; scalaz.concurrent.Future[B]">f</a><span class="delimiter">)</span>
    <span class="keyword">case</span> BindSuspend<a href="#1674563" title="scalaz.concurrent.Future[B]" class="delimiter">(</a><a href="#48018" title="() =&gt; scalaz.concurrent.Future[Any]" id="48135">thunk</a>, <a href="#48019" title="Any =&gt; scalaz.concurrent.Future[A]" id="48136">g</a><span class="delimiter">)</span> =&gt; 
      <a href="#60030" title="(thunk: () =&gt; scalaz.concurrent.Future[B])scalaz.concurrent.Future.Suspend[B]">Suspend</a><a href="#1674570" title="(x: scalaz.concurrent.Future[B])scalaz.concurrent.Future[B]" class="delimiter">(</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#60036" title="(thunk: () =&gt; scalaz.concurrent.Future[Any], f: Any =&gt; scalaz.concurrent.Future[B])scalaz.concurrent.Future.BindSuspend[Any,B]">BindSuspend</a><span class="delimiter">(</span><a href="#48135" title="() =&gt; scalaz.concurrent.Future[Any]">thunk</a>, <a href="#48136" title="Any =&gt; scalaz.concurrent.Future[A]">g</a> <span title="(g: scalaz.concurrent.Future[A] =&gt; scalaz.concurrent.Future[B])Any =&gt; scalaz.concurrent.Future[B]">andThen</span> <span class="delimiter">(</span><a href="#48148" title="scalaz.concurrent.Future[A]">_</a> <a href="#47873" title="(f: A =&gt; scalaz.concurrent.Future[B])scalaz.concurrent.Future[B]">flatMap</a> <a href="#47931" title="A =&gt; scalaz.concurrent.Future[B]">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> BindAsync<a href="#1674563" title="scalaz.concurrent.Future[B]" class="delimiter">(</a><a href="#48088" title="(Any =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit" id="48181">listen</a>, <a href="#48089" title="Any =&gt; scalaz.concurrent.Future[A]" id="48182">g</a><span class="delimiter">)</span> =&gt; 
      <a href="#60030" title="(thunk: () =&gt; scalaz.concurrent.Future[B])scalaz.concurrent.Future.Suspend[B]">Suspend</a><a href="#1674570" title="(x: scalaz.concurrent.Future[B])scalaz.concurrent.Future[B]" class="delimiter">(</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#60042" title="(onFinish: (Any =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit, f: Any =&gt; scalaz.concurrent.Future[B])scalaz.concurrent.Future.BindAsync[Any,B]">BindAsync</a><span class="delimiter">(</span><a href="#48181" title="(Any =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit">listen</a>, <a href="#48182" title="Any =&gt; scalaz.concurrent.Future[A]">g</a> <span title="(g: scalaz.concurrent.Future[A] =&gt; scalaz.concurrent.Future[B])Any =&gt; scalaz.concurrent.Future[B]">andThen</span> <span class="delimiter">(</span><a href="#48194" title="scalaz.concurrent.Future[A]">_</a> <a href="#47873" title="(f: A =&gt; scalaz.concurrent.Future[B])scalaz.concurrent.Future[B]">flatMap</a> <a href="#47931" title="A =&gt; scalaz.concurrent.Future[B]">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> 
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[B](f: A =&gt; B)scalaz.concurrent.Future[B]" id="47876">map</a><span class="delimiter">[</span><a title="" id="47878">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="48202">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#22751" title="scalaz.concurrent.Future[B]">Future</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =  
    <a href="#47873" title="(f: A =&gt; scalaz.concurrent.Future[B])scalaz.concurrent.Future[B]">flatMap</a><span class="delimiter">(</span><a href="#48202" title="A =&gt; B">f</a> <span title="(g: B =&gt; scalaz.concurrent.Future[B])A =&gt; scalaz.concurrent.Future[B]">andThen</span> <span class="delimiter">(</span><a title="B" id="48210">b</a> =&gt; <a href="#22753" title="scalaz.concurrent.Future.type">Future</a>.<a href="#47913" title="(a: B)scalaz.concurrent.Future[B]">now</a><span class="delimiter">(</span><a href="#48210" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** 
   * Run this computation to obtain an `A`, then invoke the given callback. 
   * Also see `runAsync`. 
   */
  <span class="keyword">def</span> <a title="(cb: A =&gt; scalaz.Free.Trampoline[Unit])Unit" id="47879">listen</a><span class="delimiter">(</span><a title="A =&gt; scalaz.Free.Trampoline[Unit]" id="48218">cb</a>: A =&gt; Trampoline<span class="delimiter">[</span>Unit<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = 
    <a href="#22751" title="Future.this.type" class="keyword">this</a>.<a href="#47881" title="=&gt; scalaz.concurrent.Future[A]">step</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Now<a href="#1674584" title="Unit" class="delimiter">(</a><a href="#59617" title="A" id="48220">a</a><span class="delimiter">)</span> =&gt; <a href="#48218" title="(v1: A)scalaz.Free.Trampoline[Unit]">cb</a><a href="#1674589" title="(x: Unit)Unit" class="delimiter">(</a><a href="#48220" title="A">a</a><span class="delimiter">)</span> 
      <span class="keyword">case</span> Async<a href="#1674584" title="Unit" class="delimiter">(</a><a href="#48682" title="(A =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit" id="48296">onFinish</a><span class="delimiter">)</span> =&gt; <a href="#48296" title="(v1: A =&gt; scalaz.Free.Trampoline[Unit])Unit">onFinish</a><a href="#1674589" title="(x: Unit)Unit" class="delimiter">(</a><a href="#48218" title="A =&gt; scalaz.Free.Trampoline[Unit]">cb</a><span class="delimiter">)</span>
      <span class="keyword">case</span> BindAsync<a href="#1674584" title="Unit" class="delimiter">(</a><a href="#48088" title="(Any =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit" id="48300">onFinish</a>, <a href="#48089" title="Any =&gt; scalaz.concurrent.Future[A]" id="48301">g</a><span class="delimiter">)</span> =&gt; 
        <a href="#48300" title="(v1: Any =&gt; scalaz.Free.Trampoline[Unit])Unit">onFinish</a><a href="#1674589" title="(x: Unit)Unit" class="delimiter">(</a><a title="Any" id="48304">x</a> =&gt; <a href="../../core/Free.scala.html#19731" title="scalaz.Trampoline.type">Trampoline</a>.<a href="../../core/Free.scala.html#48309" title="(a: =&gt; scalaz.concurrent.Future[A])scalaz.Free.Trampoline[scalaz.concurrent.Future[A]]">delay</a><span class="delimiter">(</span><a href="#48301" title="(v1: Any)scalaz.concurrent.Future[A]">g</a><span class="delimiter">(</span><a href="#48304" title="Any">x</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../core/Free.scala.html#48225" title="(f: scalaz.concurrent.Future[A] =&gt; Unit)scalaz.Free[Function0,Unit]">map</a> <span class="delimiter">(</span><a href="#48328" title="scalaz.concurrent.Future[A]">_</a> <a href="#47879" title="(cb: A =&gt; scalaz.Free.Trampoline[Unit])Unit">listen</a> <a href="#48218" title="A =&gt; scalaz.Free.Trampoline[Unit]">cb</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  /**
   * Run this computation to obtain an `A`, so long as `cancel` remains false. 
   * Because of trampolining, we get frequent opportunities to cancel
   * while stepping through the trampoline, so this should provide a fairly 
   * robust means of cancellation.  
   */
  <span class="keyword">def</span> <a title="(cb: A =&gt; scalaz.Free.Trampoline[Unit], cancel: java.util.concurrent.atomic.AtomicBoolean)Unit" id="47880">listenInterruptibly</a><span class="delimiter">(</span><a title="A =&gt; scalaz.Free.Trampoline[Unit]" id="48330">cb</a>: A =&gt; Trampoline<span class="delimiter">[</span>Unit<span class="delimiter">]</span>, <a title="java.util.concurrent.atomic.AtomicBoolean" id="48331">cancel</a>: <span title="java.util.concurrent.atomic.AtomicBoolean">AtomicBoolean</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = 
    <a href="#22751" title="Future.this.type" class="keyword">this</a>.<a href="#47882" title="(cancel: java.util.concurrent.atomic.AtomicBoolean)scalaz.concurrent.Future[A]">stepInterruptibly</a><a href="#1674606" title="Unit" class="delimiter">(</a><a href="#48331" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Now<a href="#1674595" title="Unit" class="delimiter">(</a><a href="#59617" title="A" id="48352">a</a><span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#48331" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a>.<span title="()Boolean">get</span> =&gt; <a href="#48330" title="(v1: A)scalaz.Free.Trampoline[Unit]">cb</a><a href="#1674600" title="(x: Unit)Unit" class="delimiter">(</a><a href="#48352" title="A">a</a><span class="delimiter">)</span> 
      <span class="keyword">case</span> Async<a href="#1674595" title="Unit" class="delimiter">(</a><a href="#48682" title="(A =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit" id="48355">onFinish</a><span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#48331" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a>.<span title="()Boolean">get</span> =&gt; <a href="#48355" title="(v1: A =&gt; scalaz.Free.Trampoline[Unit])Unit">onFinish</a><a href="#1674600" title="(x: Unit)Unit" class="delimiter">(</a><a href="#48330" title="A =&gt; scalaz.Free.Trampoline[Unit]">cb</a><span class="delimiter">)</span>
      <span class="keyword">case</span> BindAsync<a href="#1674595" title="Unit" class="delimiter">(</a><a href="#48088" title="(Any =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit" id="48359">onFinish</a>, <a href="#48089" title="Any =&gt; scalaz.concurrent.Future[A]" id="48360">g</a><span class="delimiter">)</span> <span class="keyword">if</span> <span title="=&gt; Boolean">!</span><a href="#48331" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a>.<span title="()Boolean">get</span> =&gt; 
        <a href="#48359" title="(v1: Any =&gt; scalaz.Free.Trampoline[Unit])Unit">onFinish</a><a href="#1674600" title="(x: Unit)Unit" class="delimiter">(</a><a title="Any" id="48363">x</a> =&gt; 
          <span title="scalaz.Free[Function0,Unit]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#48331" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a>.<span title="()Boolean">get</span><span class="delimiter">)</span> <a href="../../core/Free.scala.html#19731" title="scalaz.Trampoline.type">Trampoline</a>.<a href="../../core/Free.scala.html#48309" title="(a: =&gt; scalaz.concurrent.Future[A])scalaz.Free.Trampoline[scalaz.concurrent.Future[A]]">delay</a><span class="delimiter">(</span><a href="#48360" title="(v1: Any)scalaz.concurrent.Future[A]">g</a><span class="delimiter">(</span><a href="#48363" title="Any">x</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../../core/Free.scala.html#48225" title="(f: scalaz.concurrent.Future[A] =&gt; Unit)scalaz.Free[Function0,Unit]">map</a> <span class="delimiter">(</span><a href="#48371" title="scalaz.concurrent.Future[A]">_</a> <a href="#47880" title="(cb: A =&gt; scalaz.Free.Trampoline[Unit], cancel: java.util.concurrent.atomic.AtomicBoolean)Unit">listenInterruptibly</a> <span class="delimiter">(</span><a href="#48330" title="A =&gt; scalaz.Free.Trampoline[Unit]">cb</a>, <a href="#48331" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">else</span> <a href="../../core/Free.scala.html#19731" title="scalaz.Trampoline.type">Trampoline</a>.<a href="../../core/Free.scala.html#48306" title="(a: Unit)scalaz.Free.Trampoline[Unit]">done</a><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> _ <span class="keyword">if</span> <a href="#48331" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a>.<span title="()Boolean">get</span> =&gt; <a href="#1674600" title="(x: Unit)Unit" class="delimiter">(</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  /** 
   * Evaluate this `Future` to a result, or another asynchronous computation.
   * This has the effect of stripping off any 'pure' trampolined computation at
   * the start of this `Future`. 
   */
  @annotation.tailrec
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; scalaz.concurrent.Future[A]" id="47881">step</a>: <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#22751" title="scalaz.concurrent.Future[A]" class="keyword">this</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> Suspend<a href="#1674607" title="scalaz.concurrent.Future[A]" class="delimiter">(</a><a href="#47974" title="() =&gt; scalaz.concurrent.Future[A]" id="48381">thunk</a><span class="delimiter">)</span> =&gt; <a href="#48381" title="()scalaz.concurrent.Future[A]">thunk</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#1674611" title="(x: scalaz.concurrent.Future[A])scalaz.concurrent.Future[A]">step</a>
    <span class="keyword">case</span> BindSuspend<a href="#1674607" title="scalaz.concurrent.Future[A]" class="delimiter">(</a><a href="#48018" title="() =&gt; scalaz.concurrent.Future[Any]" id="48384">thunk</a>, <a href="#48019" title="Any =&gt; scalaz.concurrent.Future[A]" id="48385">f</a><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span><a href="#48384" title="()scalaz.concurrent.Future[Any]">thunk</a><span class="delimiter">(</span><span class="delimiter">)</span> <a href="#47873" title="(f: Any =&gt; scalaz.concurrent.Future[A])scalaz.concurrent.Future[A]">flatMap</a> <a href="#48385" title="Any =&gt; scalaz.concurrent.Future[A]">f</a><span class="delimiter">)</span>.<a href="#1674611" title="(x: scalaz.concurrent.Future[A])scalaz.concurrent.Future[A]">step</a> 
    <span class="keyword">case</span> _ =&gt; <a href="#1674611" title="(x: scalaz.concurrent.Future[A])scalaz.concurrent.Future[A]" class="keyword">this</a>
  <span class="delimiter">}</span>

  /** Like `step`, but may be interrupted by setting `cancel` to true. */
  @annotation.tailrec
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(cancel: java.util.concurrent.atomic.AtomicBoolean)scalaz.concurrent.Future[A]" id="47882">stepInterruptibly</a><span class="delimiter">(</span><a title="java.util.concurrent.atomic.AtomicBoolean" id="48350">cancel</a>: <span title="java.util.concurrent.atomic.AtomicBoolean">AtomicBoolean</span><span class="delimiter">)</span>: <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = 
    <span title="scalaz.concurrent.Future[A]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#48350" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a>.<span title="()Boolean">get</span><span class="delimiter">)</span> <a href="#22751" title="scalaz.concurrent.Future[A]" class="keyword">this</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Suspend<a href="#1674617" title="scalaz.concurrent.Future[A]" class="delimiter">(</a><a href="#47974" title="() =&gt; scalaz.concurrent.Future[A]" id="48392">thunk</a><span class="delimiter">)</span> =&gt; <a href="#48392" title="()scalaz.concurrent.Future[A]">thunk</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#47882" title="(cancel: java.util.concurrent.atomic.AtomicBoolean)scalaz.concurrent.Future[A]">stepInterruptibly</a><a href="#1674621" title="(x: scalaz.concurrent.Future[A])scalaz.concurrent.Future[A]" class="delimiter">(</a><a href="#48350" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a><span class="delimiter">)</span>
      <span class="keyword">case</span> BindSuspend<a href="#1674617" title="scalaz.concurrent.Future[A]" class="delimiter">(</a><a href="#48018" title="() =&gt; scalaz.concurrent.Future[Any]" id="48395">thunk</a>, <a href="#48019" title="Any =&gt; scalaz.concurrent.Future[A]" id="48396">f</a><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span><a href="#48395" title="()scalaz.concurrent.Future[Any]">thunk</a><span class="delimiter">(</span><span class="delimiter">)</span> <a href="#47873" title="(f: Any =&gt; scalaz.concurrent.Future[A])scalaz.concurrent.Future[A]">flatMap</a> <a href="#48396" title="Any =&gt; scalaz.concurrent.Future[A]">f</a><span class="delimiter">)</span>.<a href="#47882" title="(cancel: java.util.concurrent.atomic.AtomicBoolean)scalaz.concurrent.Future[A]">stepInterruptibly</a><a href="#1674621" title="(x: scalaz.concurrent.Future[A])scalaz.concurrent.Future[A]" class="delimiter">(</a><a href="#48350" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _ =&gt; <a href="#1674621" title="(x: scalaz.concurrent.Future[A])scalaz.concurrent.Future[A]" class="keyword">this</a>
    <span class="delimiter">}</span>
    <span class="keyword">else</span> <a href="#22751" title="scalaz.concurrent.Future[A]" class="keyword">this</a>

  /** 
   * Begins running this `Future` and returns a new future that blocks
   * waiting for the result. Note that this results  
   */
  <span class="keyword">def</span> <a title="=&gt; scalaz.concurrent.Future[A]" id="47883">start</a>: <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="java.util.concurrent.CountDownLatch" id="48400">latch</a> = <span title="java.util.concurrent.CountDownLatch" class="keyword">new</span> java.util.concurrent.<span title="java.util.concurrent.CountDownLatch">CountDownLatch</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    @volatile <span class="keyword">var</span> <a title="Option[A]" id="48401">result</a>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span title="None.type">None</span>
    <a href="#47884" title="(cb: A =&gt; Unit)Unit">runAsync</a> <span class="delimiter">{</span> <a title="A" id="48418">a</a> =&gt; <a href="#48401" title="Option[A]">result</a> = <span title="(x: A)Some[A]">Some</span><span class="delimiter">(</span><a href="#48418" title="A">a</a><span class="delimiter">)</span>; <a href="#48400" title="java.util.concurrent.CountDownLatch">latch</a>.<span title="()Unit">countDown</span> <span class="delimiter">}</span> 
    <a href="#47916" title="(a: =&gt; A)scalaz.concurrent.Future[A]">delay</a> <span class="delimiter">{</span> <a href="#48400" title="java.util.concurrent.CountDownLatch">latch</a>.<span title="()Unit">await</span>; <a href="#48401" title="Option[A]">result</a>.<span title="=&gt; A">get</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** 
   * Run this `Future`, passing the result to the given callback once available. 
   * Any pure, non-asynchronous computation at the head of this `Future` will
   * be forced in the calling thread. At the first `Async` encountered, control
   * switches to whatever thread backs the `Async` and this function returns.
   */
  <span class="keyword">def</span> <a title="(cb: A =&gt; Unit)Unit" id="47884">runAsync</a><span class="delimiter">(</span><a title="A =&gt; Unit" id="48416">cb</a>: A =&gt; Unit<span class="delimiter">)</span>: <span title="Unit">Unit</span> = 
    <a href="#47879" title="(cb: A =&gt; scalaz.Free.Trampoline[Unit])Unit">listen</a><span class="delimiter">(</span><a title="A" id="48495">a</a> =&gt; <a href="../../core/Free.scala.html#19731" title="scalaz.Trampoline.type">Trampoline</a>.<a href="../../core/Free.scala.html#48306" title="(a: Unit)scalaz.Free.Trampoline[Unit]">done</a><span class="delimiter">(</span><a href="#48416" title="(v1: A)Unit">cb</a><span class="delimiter">(</span><a href="#48495" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** 
   * Run this computation to obtain an `A`, so long as `cancel` remains false. 
   * Because of trampolining, we get frequent opportunities to cancel
   * while stepping through the trampoline, this should provide a fairly 
   * robust means of cancellation.  
   */
  <span class="keyword">def</span> <a title="(cb: A =&gt; Unit, cancel: java.util.concurrent.atomic.AtomicBoolean)Unit" id="47885">runAsyncInterruptibly</a><span class="delimiter">(</span><a title="A =&gt; Unit" id="48500">cb</a>: A =&gt; Unit, <a title="java.util.concurrent.atomic.AtomicBoolean" id="48501">cancel</a>: <span title="java.util.concurrent.atomic.AtomicBoolean">AtomicBoolean</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = 
    <a href="#47880" title="(cb: A =&gt; scalaz.Free.Trampoline[Unit], cancel: java.util.concurrent.atomic.AtomicBoolean)Unit">listenInterruptibly</a><span class="delimiter">(</span><a title="A" id="48503">a</a> =&gt; <a href="../../core/Free.scala.html#19731" title="scalaz.Trampoline.type">Trampoline</a>.<a href="../../core/Free.scala.html#48306" title="(a: Unit)scalaz.Free.Trampoline[Unit]">done</a><span class="delimiter">(</span><a href="#48500" title="(v1: A)Unit">cb</a><span class="delimiter">(</span><a href="#48503" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#48501" title="java.util.concurrent.atomic.AtomicBoolean">cancel</a><span class="delimiter">)</span>

  /** Run this `Future` and block awaiting its result. */
  <span class="keyword">def</span> <a title="=&gt; A" id="47886">run</a>: <a href="#22752" title="A">A</a> = <a href="#22751" title="scalaz.concurrent.Future[A]" class="keyword">this</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> Now<a href="#1674627" title="A" class="delimiter">(</a><a href="#59617" title="A" id="48509">a</a><span class="delimiter">)</span> =&gt; <a href="#1674630" title="(x: A)A">a</a>
    <span class="keyword">case</span> _ =&gt; <a href="#1674630" title="(x: A)A" class="delimiter">{</a>
      <span class="keyword">val</span> <a title="java.util.concurrent.CountDownLatch" id="48510">latch</a> = <span title="java.util.concurrent.CountDownLatch" class="keyword">new</span> java.util.concurrent.<span title="java.util.concurrent.CountDownLatch">CountDownLatch</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span> 
      @volatile <span class="keyword">var</span> <a title="Option[A]" id="48511">result</a>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span title="None.type">None</span>
      <a href="#47884" title="(cb: A =&gt; Unit)Unit">runAsync</a> <span class="delimiter">{</span> <a title="A" id="48514">a</a> =&gt; <a href="#48511" title="Option[A]">result</a> = <span title="(x: A)Some[A]">Some</span><span class="delimiter">(</span><a href="#48514" title="A">a</a><span class="delimiter">)</span>; <a href="#48510" title="java.util.concurrent.CountDownLatch">latch</a>.<span title="()Unit">countDown</span> <span class="delimiter">}</span>
      <a href="#48510" title="java.util.concurrent.CountDownLatch">latch</a>.<span title="()Unit">await</span>
      <a href="#48511" title="Option[A]">result</a>.<span title="=&gt; A">get</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="scalaz.concurrent.Future.type" id="22753">Future</a> <a href="#22754" title="scalaz.concurrent.Future.type" class="delimiter">{</a>

  <span class="keyword">case class</span> <a href="#59417" title="class Now[+A] extends AnyRef with scalaz.concurrent.Future[A] with Product with Serializable" id="60020">Now</a><span class="delimiter">[</span>+<a title="" id="47940">A</a><span class="delimiter">]</span><a href="#60020" title="Product" class="delimiter">(</a><a title="A" id="59617">a</a>: <a href="#47940" title="A">A</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  <span class="keyword">case class</span> <a href="#59447" title="class Async[+A] extends AnyRef with scalaz.concurrent.Future[A] with Product with Serializable" id="60025">Async</a><span class="delimiter">[</span>+<a title="" id="48047">A</a><span class="delimiter">]</span><a href="#60025" title="Product" class="delimiter">(</a><a title="(A =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit" id="48682">onFinish</a>: <span class="delimiter">(</span>A =&gt; Trampoline<span class="delimiter">[</span>Unit<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  <span class="keyword">case class</span> <a href="#59482" title="class Suspend[+A] extends AnyRef with scalaz.concurrent.Future[A] with Product with Serializable" id="60030">Suspend</a><span class="delimiter">[</span>+<a title="" id="47973">A</a><span class="delimiter">]</span><a href="#60030" title="Product" class="delimiter">(</a><a title="() =&gt; scalaz.concurrent.Future[A]" id="47974">thunk</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Future<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  <span class="keyword">case class</span> <a href="#59531" title="class BindSuspend[A, B] extends AnyRef with scalaz.concurrent.Future[B] with Product with Serializable" id="60036">BindSuspend</a><span class="delimiter">[</span><a title="" id="48016">A</a>,<a title="" id="48017">B</a><span class="delimiter">]</span><a href="#60036" title="Product" class="delimiter">(</a><a title="() =&gt; scalaz.concurrent.Future[A]" id="48018">thunk</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Future<span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A =&gt; scalaz.concurrent.Future[B]" id="48019">f</a>: A =&gt; Future<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#22751" title="scalaz.concurrent.Future[B]">Future</a><span class="delimiter">[</span>B<span class="delimiter">]</span>
  <span class="keyword">case class</span> <a href="#59589" title="class BindAsync[A, B] extends AnyRef with scalaz.concurrent.Future[B] with Product with Serializable" id="60042">BindAsync</a><span class="delimiter">[</span><a title="" id="48086">A</a>,<a title="" id="48087">B</a><span class="delimiter">]</span><a href="#60042" title="Product" class="delimiter">(</a><a title="(A =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit" id="48088">onFinish</a>: <span class="delimiter">(</span>A =&gt; Trampoline<span class="delimiter">[</span>Unit<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; Unit,
                            <a title="A =&gt; scalaz.concurrent.Future[B]" id="48089">f</a>: A =&gt; Future<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#22751" title="scalaz.concurrent.Future[B]">Future</a><span class="delimiter">[</span>B<span class="delimiter">]</span>
  
  // NB: considered implementing Traverse and Comonad, but these would have
  // to run the Future; leaving out for now

  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="futureInstance extends AnyRef with scalaz.Nondeterminism[scalaz.concurrent.Future]" id="47911">futureInstance</a> = <a href="#48521" title="scalaz.Nondeterminism[scalaz.concurrent.Future]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Nondeterminism[scalaz.concurrent.Future]" id="48521">Nondeterminism</a><span class="delimiter">[</span>Future<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](fa: scalaz.concurrent.Future[A])(f: A =&gt; scalaz.concurrent.Future[B])scalaz.concurrent.Future[B]" id="48566">bind</a><span class="delimiter">[</span><a title="" id="48569">A</a>,<a title="" id="48570">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.concurrent.Future[A]" id="48580">fa</a>: <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.concurrent.Future[B]" id="48581">f</a>: A =&gt; Future<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#22751" title="scalaz.concurrent.Future[B]">Future</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =   
      <a href="#48580" title="scalaz.concurrent.Future[A]">fa</a> <a href="#47873" title="(f: A =&gt; scalaz.concurrent.Future[B])scalaz.concurrent.Future[B]">flatMap</a> <a href="#48581" title="A =&gt; scalaz.concurrent.Future[B]">f</a>
    <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.concurrent.Future[A]" id="48571">point</a><span class="delimiter">[</span><a title="" id="48573">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="48599">a</a>: =&gt; A<span class="delimiter">)</span>: <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#47913" title="(a: A)scalaz.concurrent.Future[A]">now</a><span class="delimiter">(</span><a href="#48599" title="=&gt; A">a</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="[A](h: scalaz.concurrent.Future[A], t: Seq[scalaz.concurrent.Future[A]])scalaz.concurrent.Future[(A, Seq[scalaz.concurrent.Future[A]])]" id="48574">chooseAny</a><span class="delimiter">[</span><a title="" id="48576">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.concurrent.Future[A]" id="48610">h</a>: <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Seq[scalaz.concurrent.Future[A]]" id="48611">t</a>: <span title="Seq[scalaz.concurrent.Future[A]]">Seq</span><span class="delimiter">[</span>Future<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#22751" title="scalaz.concurrent.Future[(A, Seq[scalaz.concurrent.Future[A]])]">Future</a><span class="delimiter">[</span><span class="delimiter">(</span>A, Seq<span class="delimiter">[</span>Future<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      // The details of this implementation are a bit tricky, but general
      // idea is to run all `fs` in parallel, with each decrementing
      // a central CountDownLatch; we then return a Future that awaits on 
      // this latch, then returns whichever result became available first
      // 
      // To account for the fact that the losing computations are still 
      // running, we construct special 'residual' Futures for the losers,
      // that will first return from the already running computation, 
      // then revert back to running the original Future

      <a href="#60025" title="(onFinish: (((A, Seq[scalaz.concurrent.Future[A]])) =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit)scalaz.concurrent.Future.Async[(A, Seq[scalaz.concurrent.Future[A]])]">Async</a> <span class="delimiter">{</span> <span class="delimiter">(</span>cb: Tuple2<span class="delimiter">[</span>A,Seq<span class="delimiter">[</span>Future<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =&gt; Trampoline<span class="delimiter">[</span>Unit<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; 
        @volatile <span class="keyword">var</span> <a title="Option[(A, Int)]" id="48688">result</a>: <span title="Option[(A, Int)]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>A, Int<span class="delimiter">)</span><span class="delimiter">]</span> = <span title="None.type">None</span>
        <span class="keyword">val</span> <a title="java.util.concurrent.CountDownLatch" id="48689">latch</a> = <span title="java.util.concurrent.CountDownLatch" class="keyword">new</span> <span title="java.util.concurrent.CountDownLatch">CountDownLatch</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Seq[scalaz.concurrent.Future[A]]" id="48690">fs</a> = <a href="#48610" title="scalaz.concurrent.Future[A]">h</a> <a href="#48697" title="(elem: scalaz.concurrent.Future[A])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[scalaz.concurrent.Future[A]],scalaz.concurrent.Future[A],Seq[scalaz.concurrent.Future[A]]])Seq[scalaz.concurrent.Future[A]]">+:</a> <a href="#48611" title="Seq[scalaz.concurrent.Future[A]]">t</a>
        // we keep a separate latch and atomic reference for purposes of 
        // computing a residual Future should each Future lose
        <span class="keyword">val</span> <a title="IndexedSeq[(scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A])]" id="48691">fs2</a>: <span title="IndexedSeq[(scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A])]">IndexedSeq</span><span class="delimiter">[</span><span class="delimiter">(</span>Future<span class="delimiter">[</span>A<span class="delimiter">]</span>, CountDownLatch, AtomicReference<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = 
          <a href="#48690" title="Seq[scalaz.concurrent.Future[A]]">fs</a>.<span title="=&gt; scala.collection.immutable.IndexedSeq[scalaz.concurrent.Future[A]]">toIndexedSeq</span>.<span title="(f: scalaz.concurrent.Future[A] =&gt; (scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A]))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq[scalaz.concurrent.Future[A]],(scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A]),IndexedSeq[(scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A])]])IndexedSeq[(scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A])]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.IndexedSeq.Coll,(scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A]),scala.collection.immutable.IndexedSeq[(scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A])]]" class="delimiter">{</span> 
            <span class="delimiter">(</span>f: <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span title="(_1: scalaz.concurrent.Future[A], _2: java.util.concurrent.CountDownLatch, _3: java.util.concurrent.atomic.AtomicReference[A])(scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A])" class="delimiter">(</span><a href="#55395" title="scalaz.concurrent.Future[A]">f</a>, <span title="java.util.concurrent.CountDownLatch" class="keyword">new</span> <span title="java.util.concurrent.CountDownLatch">CountDownLatch</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>, <span title="()java.util.concurrent.atomic.AtomicReference[A]" class="keyword">new</span> <span title="java.util.concurrent.atomic.AtomicReference[A]">AtomicReference</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <a href="#48691" title="IndexedSeq[(scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A])]">fs2</a>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[IndexedSeq[(scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A])],((scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A]), Int),IndexedSeq[((scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A]), Int)]])IndexedSeq[((scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A]), Int)]">zipWithIndex</span>.<span title="(f: (((scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A]), Int)) =&gt; Unit)Unit">foreach</span> <a href="#57584" title="((scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A]), Int)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1674733" title="=&gt; (scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A])" class="delimiter">(</a><a href="#1674734" title="scalaz.concurrent.Future[A]" id="57592">f</a>,<a href="#1674734" title="java.util.concurrent.CountDownLatch" id="57593">flatch</a>,<a href="#1674734" title="java.util.concurrent.atomic.AtomicReference[A]" id="57594">ref</a><span class="delimiter">)</span>, <a href="#1674733" title="Int" id="57595">ind</a><span class="delimiter">)</span> =&gt; <a href="#57592" title="scalaz.concurrent.Future[A]">f</a>.<a href="#47884" title="(cb: A =&gt; Unit)Unit">runAsync</a> <a href="#1674736" title="(x: Unit)Unit" class="delimiter">{</a> <a title="A" id="57598">a</a> =&gt;
          <a href="#57594" title="java.util.concurrent.atomic.AtomicReference[A]">ref</a>.<span title="(x$1: A)Unit">set</span><span class="delimiter">(</span><a href="#57598" title="A">a</a><span class="delimiter">)</span>
          // actually ok if two threads clobber each other here
          <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#48688" title="Option[(A, Int)]">result</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <a href="#48688" title="Option[(A, Int)]">result</a> = <span title="(x: (A, Int))Some[(A, Int)]">Some</span><span class="delimiter">(</span><span title="(_1: A, _2: Int)(A, Int)" class="delimiter">(</span><a href="#57598" title="A">a</a>, <a href="#57595" title="Int">ind</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#57593" title="java.util.concurrent.CountDownLatch">flatch</a>.<span title="()Unit">countDown</span> 
          <a href="#48689" title="java.util.concurrent.CountDownLatch">latch</a>.<span title="()Unit">countDown</span>
        <span class="delimiter">}</span><span class="delimiter">}</span>
        <a href="#48689" title="java.util.concurrent.CountDownLatch">latch</a>.<span title="()Unit">await</span> // wait for any one of the threads to finish
        <span class="keyword">val</span> Some<a href="#1674740" title="(A, Int)" class="delimiter">(</a><a href="#1674742" title="=&gt; (A, Int)" class="delimiter">(</a><a href="#1674741" title="A" id="48693">a</a>, <a href="#1674741" title="Int" id="48694">ind</a><span class="delimiter">)</span><span class="delimiter">)</span> = <a href="#48688" title="Option[(A, Int)]">result</a> // extract the winner
        // for all the losing futures, we compute a 'residual', which includes the
        // 'rest' of the current, partially completed computation, followed by a 
        // repetition of the original computation
        <span class="keyword">val</span> <a title="IndexedSeq[scalaz.concurrent.Future.Async[A]]" id="48695">residuals</a> = <a href="#48691" title="IndexedSeq[(scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A])]">fs2</a>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[IndexedSeq[(scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A])],((scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A]), Int),IndexedSeq[((scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A]), Int)]])IndexedSeq[((scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A]), Int)]">zipWithIndex</span> <span title="(pf: PartialFunction[((scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A]), Int),scalaz.concurrent.Future.Async[A]])(implicit bf: scala.collection.generic.CanBuildFrom[IndexedSeq[((scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A]), Int)],scalaz.concurrent.Future.Async[A],IndexedSeq[scalaz.concurrent.Future.Async[A]]])IndexedSeq[scalaz.concurrent.Future.Async[A]]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[((scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A]), Int),scalaz.concurrent.Future.Async[A]] with Serializable" id="58200" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1674749" title="=&gt; (scalaz.concurrent.Future[A], java.util.concurrent.CountDownLatch, java.util.concurrent.atomic.AtomicReference[A])" class="delimiter">(</a><a href="#1674750" title="scalaz.concurrent.Future[A]" id="57740">f</a>, <a href="#1674750" title="java.util.concurrent.CountDownLatch" id="57741">latch</a>, <a href="#1674750" title="java.util.concurrent.atomic.AtomicReference[A]" id="57742">ref</a><span class="delimiter">)</span>, <a href="#1674749" title="Int" id="58213">i</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#58213" title="Int">i</a> <span title="(x: Int)Boolean">!=</span> <a href="#48694" title="Int">ind</a> =&gt; 
          <span class="keyword">val</span> <a title="java.util.concurrent.atomic.AtomicBoolean" id="57748">used</a> = <span title="java.util.concurrent.atomic.AtomicBoolean" class="keyword">new</span> <span title="java.util.concurrent.atomic.AtomicBoolean">AtomicBoolean</span><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
          <a href="#60025" title="(onFinish: (A =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit)scalaz.concurrent.Future.Async[A]">Async</a> <span class="delimiter">{</span> <span class="delimiter">(</span>cb: A =&gt; Trampoline<span class="delimiter">[</span>Unit<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; 
            <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#57748" title="java.util.concurrent.atomic.AtomicBoolean">used</a>.<span title="()Boolean">get</span><span class="delimiter">)</span> <a href="#57740" title="scalaz.concurrent.Future[A]">f</a>.<a href="#47879" title="(cb: A =&gt; scalaz.Free.Trampoline[Unit])Unit">listen</a><span class="delimiter">(</span><a href="#57754" title="A =&gt; scalaz.Free.Trampoline[Unit]">cb</a><span class="delimiter">)</span> 
            <span class="keyword">else</span> <span class="delimiter">{</span>
              // A bit of trickiness here, since two threads may listen to this
              // Async simultaneously, and we only want one to receive the value
              // inside `ref`. To ensure this, we race to set the `used` flag.
              // Whichever one wins gets the value inside `ref`, the other just
              // delegates to `f`.
              <a href="#57741" title="java.util.concurrent.CountDownLatch">latch</a>.<span title="()Unit">await</span>
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#57748" title="java.util.concurrent.atomic.AtomicBoolean">used</a>.<span title="(x$1: Boolean, x$2: Boolean)Boolean">compareAndSet</span><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">)</span> 
                <a href="#57754" title="(v1: A)scalaz.Free.Trampoline[Unit]">cb</a><span class="delimiter">(</span><a href="#57742" title="java.util.concurrent.atomic.AtomicReference[A]">ref</a>.<span title="()A">get</span><span class="delimiter">)</span>.<a href="../../core/Free.scala.html#48263" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,Unit],scalaz.Free.Trampoline[Unit]])Unit">run</a>
              <span class="keyword">else</span>
                <a href="#57740" title="scalaz.concurrent.Future[A]">f</a>.<a href="#47879" title="(cb: A =&gt; scalaz.Free.Trampoline[Unit])Unit">listen</a><span class="delimiter">(</span><a href="#57754" title="A =&gt; scalaz.Free.Trampoline[Unit]">cb</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#48687" title="(v1: (A, Seq[scalaz.concurrent.Future[A]]))scalaz.Free.Trampoline[Unit]">cb</a><span class="delimiter">(</span><span title="(_1: A, _2: IndexedSeq[scalaz.concurrent.Future.Async[A]])(A, IndexedSeq[scalaz.concurrent.Future.Async[A]])" class="delimiter">(</span><a href="#48693" title="A">a</a>, <a href="#48695" title="IndexedSeq[scalaz.concurrent.Future.Async[A]]">residuals</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../../core/Free.scala.html#48263" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,Unit],scalaz.Free.Trampoline[Unit]])Unit">run</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    // Optimized implementation has all Futures dump to a shared queue, then
    // waits for all to finish
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A](fs: Seq[scalaz.concurrent.Future[A]])scalaz.concurrent.Future[List[A]]" id="48577">gatherUnordered</a><span class="delimiter">[</span><a title="" id="48579">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[scalaz.concurrent.Future[A]]" id="48639">fs</a>: <span title="Seq[scalaz.concurrent.Future[A]]">Seq</span><span class="delimiter">[</span>Future<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#22751" title="scalaz.concurrent.Future[List[A]]">Future</a><span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#60025" title="(onFinish: (List[A] =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit)scalaz.concurrent.Future.Async[List[A]]">Async</a> <span class="delimiter">{</span> <a title="List[A] =&gt; scalaz.Free.Trampoline[Unit]" id="58344">cb</a> =&gt; 
        <span class="keyword">val</span> <a title="java.util.concurrent.CountDownLatch" id="58345">latch</a> = <span title="java.util.concurrent.CountDownLatch" class="keyword">new</span> <span title="java.util.concurrent.CountDownLatch">CountDownLatch</span><span class="delimiter">(</span><a href="#48639" title="Seq[scalaz.concurrent.Future[A]]">fs</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="java.util.concurrent.ConcurrentLinkedQueue[A]" id="58346">results</a> = <span title="java.util.concurrent.ConcurrentLinkedQueue[A]" class="keyword">new</span> <span title="java.util.concurrent.ConcurrentLinkedQueue[A]">ConcurrentLinkedQueue</span><span class="delimiter">[</span>A<span class="delimiter">]</span> 
        <a href="#48639" title="Seq[scalaz.concurrent.Future[A]]">fs</a>.<span title="(f: scalaz.concurrent.Future[A] =&gt; Unit)Unit">foreach</span><span class="delimiter">(</span><a href="#58738" title="scalaz.concurrent.Future[A]">_</a> <a href="#47884" title="(cb: A =&gt; Unit)Unit">runAsync</a> <span class="delimiter">{</span> <a title="A" id="58741">a</a> =&gt; 
          <a href="#58346" title="java.util.concurrent.ConcurrentLinkedQueue[A]">results</a>.<span title="(x$1: A)Boolean">add</span><span class="delimiter">(</span><a href="#58741" title="A">a</a><span class="delimiter">)</span>
          <a href="#58345" title="java.util.concurrent.CountDownLatch">latch</a>.<span title="()Unit">countDown</span>
        <span class="delimiter">}</span><span class="delimiter">)</span>
        <a href="#58345" title="java.util.concurrent.CountDownLatch">latch</a>.<span title="()Unit">await</span>
        <a href="#58344" title="(v1: List[A])scalaz.Free.Trampoline[Unit]">cb</a><span class="delimiter">(</span><a href="#58346" title="(i: java.util.Collection[A])Iterable[A]">results</a>.<span title="=&gt; List[A]">toList</span><span class="delimiter">)</span>.<a href="../../core/Free.scala.html#48263" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,Unit],scalaz.Free.Trampoline[Unit]])Unit">run</a>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Convert a strict value to a `Future`. */
  <span class="keyword">def</span> <a title="[A](a: A)scalaz.concurrent.Future[A]" id="47913">now</a><span class="delimiter">[</span><a title="" id="47915">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="48211">a</a>: <a href="#47915" title="A">A</a><span class="delimiter">)</span>: <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#60020" title="(a: A)scalaz.concurrent.Future.Now[A]">Now</a><span class="delimiter">(</span><a href="#48211" title="A">a</a><span class="delimiter">)</span>

  /** 
   * Promote a non-strict value to a `Future`. Note that since `Future` is 
   * unmemoized, this will recompute `a` each time it is sequenced into a
   * larger computation. Memoize `a` with a lazy value before calling this 
   * function if memoization is desired.  
   */
  <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.concurrent.Future[A]" id="47916">delay</a><span class="delimiter">[</span><a title="" id="47918">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="48422">a</a>: =&gt; A<span class="delimiter">)</span>: <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#60030" title="(thunk: () =&gt; scalaz.concurrent.Future[A])scalaz.concurrent.Future.Suspend[A]">Suspend</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#60020" title="(a: A)scalaz.concurrent.Future.Now[A]">Now</a><span class="delimiter">(</span><a href="#48422" title="=&gt; A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>

  /** 
   * Returns a `Future` that produces the same result as the given `Future`, 
   * but forks its evaluation off into a separate (logical) thread, using
   * the given `ExecutorService`. Note that this forking is only described
   * by the returned `Future`--nothing occurs until the `Future` is run. 
   */
  <span class="keyword">def</span> <a title="[A](a: =&gt; scalaz.concurrent.Future[A])(implicit pool: java.util.concurrent.ExecutorService)scalaz.concurrent.Future[A]" id="47919">fork</a><span class="delimiter">[</span><a title="" id="59633">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.concurrent.Future[A]" id="60043">a</a>: =&gt; Future<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="java.util.concurrent.ExecutorService" id="59631">pool</a>: <span title="java.util.concurrent.ExecutorService">ExecutorService</span> = <a href="Strategy.scala.html#22801" title="scalaz.concurrent.Strategy.type">Strategy</a>.<a href="Strategy.scala.html#59716" title="=&gt; java.util.concurrent.ExecutorService">DefaultExecutorService</a><span class="delimiter">)</span>: <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = 
    <a href="#47928" title="(a: =&gt; scalaz.concurrent.Future[A])(implicit pool: java.util.concurrent.ExecutorService)scalaz.concurrent.Future[scalaz.concurrent.Future[A]]">Future</a><a href="../../core/syntax/BindSyntax.scala.html#45358" title="(v: scalaz.concurrent.Future[scalaz.concurrent.Future[A]])(implicit F0: scalaz.Bind[scalaz.concurrent.Future])scalaz.syntax.BindOps[scalaz.concurrent.Future,scalaz.concurrent.Future[A]]" class="delimiter">(</a><a href="#60043" title="=&gt; scalaz.concurrent.Future[A]">a</a><span class="delimiter">)</span>.<a href="../../core/syntax/BindSyntax.scala.html#52595" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.concurrent.Future[A],scalaz.concurrent.Future[A]])scalaz.concurrent.Future[A]">join</a>

  /** 
   * Produce `f` in the main trampolining loop, `Future.step`, using a fresh
   * call stack. The standard trampolining primitive, useful for avoiding
   * stack overflows. 
   */
  <span class="keyword">def</span> <a title="[A](f: =&gt; scalaz.concurrent.Future[A])scalaz.concurrent.Future[A]" id="47922">suspend</a><span class="delimiter">[</span><a title="" id="47924">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.concurrent.Future[A]" id="59903">f</a>: =&gt; Future<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#60030" title="(thunk: () =&gt; scalaz.concurrent.Future[A])scalaz.concurrent.Future.Suspend[A]">Suspend</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#59903" title="=&gt; scalaz.concurrent.Future[A]">f</a><span class="delimiter">)</span>

  /** 
   * Create a `Future` from an asynchronous computation, which takes the form
   * of a function with which we can register a callback. This can be used
   * to translate from a callback-based API to a straightforward monadic
   * version. See `Task.async` for a version that allows for asynchronous
   * exceptions. 
   */
  <span class="keyword">def</span> <a title="[A](listen: (A =&gt; Unit) =&gt; Unit)scalaz.concurrent.Future[A]" id="47925">async</a><span class="delimiter">[</span><a title="" id="47927">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(A =&gt; Unit) =&gt; Unit" id="59909">listen</a>: <span class="delimiter">(</span>A =&gt; Unit<span class="delimiter">)</span> =&gt; Unit<span class="delimiter">)</span>: <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = 
    <a href="#60025" title="(onFinish: (A =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit)scalaz.concurrent.Future.Async[A]">Async</a><span class="delimiter">(</span><span class="delimiter">(</span>cb: A =&gt; Trampoline<span class="delimiter">[</span>Unit<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <a href="#59909" title="(v1: A =&gt; Unit)Unit">listen</a> <span class="delimiter">{</span> <a title="A" id="59917">a</a> =&gt; <a href="#59914" title="(v1: A)scalaz.Free.Trampoline[Unit]">cb</a><span class="delimiter">(</span><a href="#59917" title="A">a</a><span class="delimiter">)</span>.<a href="../../core/Free.scala.html#48263" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,Unit],scalaz.Free.Trampoline[Unit]])Unit">run</a> <span class="delimiter">}</span><span class="delimiter">)</span>
  
  /** Create a `Future` that will evaluate `a` using the given `ExecutorService`. */
  <span class="keyword">def</span> <a title="[A](a: =&gt; A)(implicit pool: java.util.concurrent.ExecutorService)scalaz.concurrent.Future[A]" id="47928">apply</a><span class="delimiter">[</span><a title="" id="59725">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="60045">a</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="java.util.concurrent.ExecutorService" id="59723">pool</a>: <span title="java.util.concurrent.ExecutorService">ExecutorService</span> = <a href="Strategy.scala.html#22801" title="scalaz.concurrent.Strategy.type">Strategy</a>.<a href="Strategy.scala.html#59716" title="=&gt; java.util.concurrent.ExecutorService">DefaultExecutorService</a><span class="delimiter">)</span>: <a href="#22751" title="scalaz.concurrent.Future[A]">Future</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#60025" title="(onFinish: (A =&gt; scalaz.Free.Trampoline[Unit]) =&gt; Unit)scalaz.concurrent.Future.Async[A]">Async</a> <span class="delimiter">{</span> <a title="A =&gt; scalaz.Free.Trampoline[Unit]" id="59949">cb</a> =&gt; 
    <a href="#59723" title="java.util.concurrent.ExecutorService">pool</a>.<span title="(x$1: java.util.concurrent.Callable[Unit])java.util.concurrent.Future[Unit]">submit</span> <span title="Unit" class="delimiter">{</span> <a href="#59973" title="java.util.concurrent.Callable[Unit]" class="keyword">new</a> <a title="anonymous class $anon extends Object with java.util.concurrent.Callable[Unit]" id="59973">Callable</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="()Unit" id="59975">call</a> = <a href="#59949" title="(v1: A)scalaz.Free.Trampoline[Unit]">cb</a><span class="delimiter">(</span><a href="#60045" title="=&gt; A">a</a><span class="delimiter">)</span>.<a href="../../core/Free.scala.html#48263" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,Unit],scalaz.Free.Trampoline[Unit]])Unit">run</a> <span class="delimiter">}</span><span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>