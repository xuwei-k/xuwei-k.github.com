<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/Unapply.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz

<span class="keyword">import</span> scala.annotation._
<span class="keyword">import</span> <a href="Id.scala.html#8190" title="scalaz.Id.type">Id</a>.Id
<span class="keyword">import</span> <a href="Leibniz.scala.html#11640" title="scalaz.Leibniz.type">Leibniz</a>.<span class="delimiter">{</span>===, refl<span class="delimiter">}</span>

/**
 * Represents a type `MA` that has been destructured into as a type constructor `M[_]`
 * applied to type `A`, along with a corresponding type class instance `TC[M]`.
 *
 * The implicit conversions in the companion object provide a means to obtain type class
 * instances for partially applied type constructors, in lieu of direct compiler support
 * as described in [[https://issues.scala-lang.org/browse/SI-2712 SI-2712]].
 *
 * {{{
 * // Directly depending on Applicative[G]
 * def traverse[G[_], B](f: A =&gt; G[B])(implicit G: Applicative[G]): G[F[B]] =
 *   G.traverse(self)(f)
 *
 * // Indirect lookup of the Applicative instance
 * // Requires -Ydep-method-types or Scala trunk circa Oct 2011
 * def traverseI[GB](f: A =&gt; GB)(implicit G: Unapply[Applicative, GB]): G.M[F[G.A]] /*G[F[B]*/ = {
 *   G.TC.traverse(self)(a =&gt; G(f(a)))
 * }
 *
 * // Deforested version of traverseI
 * def traverseI2[GB](f: A =&gt; GB)(implicit G: Unapply[Applicative, GB]): G.M[F[G.A]] /*G[F[B]*/ = {
 *   G.TC.traverse(self)(G.leibniz.subst[({type λ[α] = A =&gt; α})#λ](f))
 * }
 *
 * // Old usage
 * def stateTraverse1 {
 *   import scalaz._, Scalaz._
 *   import State.{State, stateMonad}
 *   val ls = List(1, 2, 3)
 *   val traverseOpt: Option[List[Int]] = ls.traverse(a =&gt; Some(a))
 *   val traverseState: State[Int, List[Int]] = ls.traverse[({type λ[α]=State[Int, α]})#λ, Int](a =&gt; State((x: Int) =&gt; (x + 1, a)))
 * }
 *
 * // New usage
 * def stateTraverse2 {
 *   import scalaz._, Scalaz._
 *   val ls = List(1, 2, 3)
 *   val traverseOpt: Option[List[Int]] = ls.traverseI(a =&gt; some(a))
 *   val traverseState = ls.traverseI(a =&gt; State((x: Int) =&gt; (x + 1, a)))
 * }
 *
 * }}}
 *
 * Credits to Miles Sabin.
 */
@implicitNotFound<span class="delimiter">(</span>
<span class="string">&quot;&quot;&quot;Unable to unapply type `${MA}` into a type constructor of kind `M[_]` that is classified by the type class `${TC}`
1) Check that the type class is defined by compiling `implicitly[${TC}[&lt;type constructor&gt;]]`.
2) Review the implicits in object Unapply, which only cover common type 'shapes'
(implicit not found: scalaz.Unapply[${TC}, ${MA}])&quot;&quot;&quot;</span><span class="delimiter">)</span>
<span class="keyword">trait</span> <a title="trait Unapply[TC[_[_]], MA] extends AnyRef" id="18791">Unapply</a><span class="delimiter">[</span><a title="[_[_]]" id="23788">TC</a><span class="delimiter">[</span><a title="[_]" id="429672">_</a><span class="delimiter">[</span><a title="" id="429673">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="23789">MA</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>

  /** The type constructor */
  <span class="keyword">type</span> <a title="[_]" id="52637">M</a><span class="delimiter">[</span><a title="" id="52645">_</a><span class="delimiter">]</span>

  /** The type that `M` was applied to */
  <span class="keyword">type</span> <a title="" id="52638">A</a>

  /** The instance of the type class */
  <span class="keyword">def</span> <a title="=&gt; TC[Unapply.this.M]" id="52639">TC</a>: <a href="#23788" title="TC[Unapply.this.M]">TC</a><span class="delimiter">[</span>M<span class="delimiter">]</span>

  /** Evidence that MA =:= M[A] */
  <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz.===[MA,Unapply.this.M[Unapply.this.A]]" id="52640">leibniz</a>: MA <a href="Leibniz.scala.html#11639" title="scalaz.Leibniz.===[MA,Unapply.this.M[Unapply.this.A]]">===</a> M<span class="delimiter">[</span>A<span class="delimiter">]</span>

  /** Compatibility. */
  @inline <span class="keyword">final</span> <span class="keyword">def</span> <a title="(ma: MA)Unapply.this.M[Unapply.this.A]" id="52641">apply</a><span class="delimiter">(</span><a title="MA" id="52649">ma</a>: <a href="#23789" title="MA">MA</a><span class="delimiter">)</span>: <a href="#52637" title="Unapply.this.M[Unapply.this.A]">M</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#52640" title="=&gt; scalaz.Leibniz.===[MA,Unapply.this.M[Unapply.this.A]]">leibniz</a>.<a href="Leibniz.scala.html#384599" title="[F[_ &gt;: scalaz.⊥ &lt;: scalaz.⊤]](p: F[MA])F[Unapply.this.M[Unapply.this.A]]">subst</a><span title="(p: scalaz.Id.Id[MA])scalaz.Id.Id[Unapply.this.M[Unapply.this.A]]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#52649" title="MA">ma</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait Unapply_4 extends AnyRef" id="13403">Unapply_4</a> <span title="Unit" class="delimiter">{</span>
  // /** Unpack a value of type `A0` into type `[a]A0`, given a instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], A0](implicit TC0: TC[[α]A0])scalaz.Unapply[TC,A0]{type M[X] = A0; type A = A0}" id="72919">unapplyA</a><span class="delimiter">[</span><a title="[_[_]]" id="72922">TC</a><span class="delimiter">[</span><a title="[_]" id="73513">_</a><span class="delimiter">[</span><a title="" id="73514">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="72923">A0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]A0]" id="73512">TC0</a>: <a href="#72922" title="TC[[α]A0]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = A0<span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#73515" title="Unapply_4 extends scalaz.Unapply[TC,A0]">Unapply</a><span class="delimiter">[</span>TC, A0<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X<span class="delimiter">]</span> = A0
    <span class="keyword">type</span> A = A0
  <span class="delimiter">}</span> = <a href="#429687" title="scalaz.Unapply[TC,A0]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply[TC,A0]" id="429687">Unapply</a><span class="delimiter">[</span>TC, A0<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]A0" id="429689">M</a><span class="delimiter">[</span><a title="" id="429690">X</a><span class="delimiter">]</span> = <a href="#72923" title="A0">A0</a>
    <span class="keyword">type</span> <a title="A0" id="429691">A</a> = <a href="#72923" title="A0">A0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]A0]" id="429692">TC</a> = <a href="#73512" title="TC[[α]A0]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="429693">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait Unapply_3 extends AnyRef with scalaz.Unapply_4" id="18668">Unapply_3</a> <span title="Unit" class="keyword">extends</span> <a href="#13403" title="scalaz.Unapply_4">Unapply_4</a> <span class="delimiter">{</span>
  /**Unpack a value of type `M0[F[_], A0, A0, B0]` into types `[a]M0[F, a, a, B0]` and `A0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], F[_], M0[F[_], _, _, _], A0, B0](implicit TC0: TC[[α]M0[F,α,α,B0]])scalaz.Unapply[TC,M0[F,A0,A0,B0]]{type M[X] = M0[F,X,X,B0]; type A = A0}" id="72925">unapplyMFABC1and2</a><span class="delimiter">[</span><a title="[_[_]]" id="72931">TC</a><span class="delimiter">[</span><a title="[_]" id="73478">_</a><span class="delimiter">[</span><a title="" id="73479">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_]" id="72932">F</a><span class="delimiter">[</span><a title="" id="73485">_</a><span class="delimiter">]</span>, <a title="[F[_], _, _, _]" id="72933">M0</a><span class="delimiter">[</span><a title="[_]" id="73480">F</a><span class="delimiter">[</span><a title="" id="73484">_</a><span class="delimiter">]</span>, <a title="" id="73481">_</a>, <a title="" id="73482">_</a>, <a title="" id="73483">_</a><span class="delimiter">]</span>, <a title="" id="72934">A0</a>, <a title="" id="72935">B0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[F,α,α,B0]]" id="73477">TC0</a>: <a href="#72931" title="TC[[α]M0[F,α,α,B0]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F, α, α, B0<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#73486" title="Unapply_3 extends scalaz.Unapply[TC,M0[F,A0,A0,B0]]">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F, A0, A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F, X, X, B0<span class="delimiter">]</span>
    <span class="keyword">type</span> A = A0
  <span class="delimiter">}</span> = <a href="#429717" title="scalaz.Unapply[TC,M0[F,A0,A0,B0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply[TC,M0[F,A0,A0,B0]]" id="429717">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F, A0, A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]M0[F,X,X,B0]" id="429719">M</a><span class="delimiter">[</span><a title="" id="429720">X</a><span class="delimiter">]</span> = <a href="#72933" title="M0[F,X,X,B0]">M0</a><span class="delimiter">[</span>F, X, X, B0<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="A0" id="429721">A</a> = <a href="#72934" title="A0">A0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[F,α,α,B0]]" id="429722">TC</a> = <a href="#73477" title="TC[[α]M0[F,α,α,B0]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="429723">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  /**Unpack a value of type `M0[F[_], A0, B0, C0]` into types `[c]M0[F, A0, B0, c]` and `C0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], F[_], M0[F[_], _, _, _], A0, B0, C0](implicit TC0: TC[[ɣ]M0[F,A0,B0,ɣ]])scalaz.Unapply[TC,M0[F,A0,B0,C0]]{type M[X] = M0[F,A0,B0,X]; type A = C0}" id="72936">unapplyMFABC3</a><span class="delimiter">[</span><a title="[_[_]]" id="72943">TC</a><span class="delimiter">[</span><a title="[_]" id="73443">_</a><span class="delimiter">[</span><a title="" id="73444">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_]" id="72944">F</a><span class="delimiter">[</span><a title="" id="73450">_</a><span class="delimiter">]</span>, <a title="[F[_], _, _, _]" id="72945">M0</a><span class="delimiter">[</span><a title="[_]" id="73445">F</a><span class="delimiter">[</span><a title="" id="73449">_</a><span class="delimiter">]</span>, <a title="" id="73446">_</a>, <a title="" id="73447">_</a>, <a title="" id="73448">_</a><span class="delimiter">]</span>, <a title="" id="72946">A0</a>, <a title="" id="72947">B0</a>, <a title="" id="72948">C0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[ɣ]M0[F,A0,B0,ɣ]]" id="73442">TC0</a>: <a href="#72943" title="TC[[ɣ]M0[F,A0,B0,ɣ]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>ɣ<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F, A0, B0, ɣ<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#73451" title="Unapply_3 extends scalaz.Unapply[TC,M0[F,A0,B0,C0]]">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F, A0, B0, C0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F, A0, B0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = C0
  <span class="delimiter">}</span> = <a href="#429745" title="scalaz.Unapply[TC,M0[F,A0,B0,C0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply[TC,M0[F,A0,B0,C0]]" id="429745">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F, A0, B0, C0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]M0[F,A0,B0,X]" id="429747">M</a><span class="delimiter">[</span><a title="" id="429748">X</a><span class="delimiter">]</span> = <a href="#72945" title="M0[F,A0,B0,X]">M0</a><span class="delimiter">[</span>F, A0, B0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="C0" id="429749">A</a> = <a href="#72948" title="C0">C0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[ɣ]M0[F,A0,B0,ɣ]]" id="429750">TC</a> = <a href="#73442" title="TC[[ɣ]M0[F,A0,B0,ɣ]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="429751">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait Unapply_2 extends AnyRef with scalaz.Unapply_3" id="21875">Unapply_2</a> <span title="Unit" class="keyword">extends</span> <a href="#18668" title="scalaz.Unapply_3">Unapply_3</a> <span class="delimiter">{</span>
  // Things get tricky with type State[S, A] = StateT[Id, S, A], both unapplyMAB2 and unapplyMFAB2 are applicable
  // Without characterizing this fully, I'm using the standard implicit prioritization to avoid this.

  /**Unpack a value of type `M0[F[_], A0, B0]` into types `[a]M0[F, a, B0]` and `A0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], F[_], M0[F[_], _, _], A0, B0](implicit TC0: TC[[α]M0[F,α,B0]])scalaz.Unapply[TC,M0[F,A0,B0]]{type M[X] = M0[F,X,B0]; type A = A0}" id="72950">unapplyMFAB1</a><span class="delimiter">[</span><a title="[_[_]]" id="72956">TC</a><span class="delimiter">[</span><a title="[_]" id="73409">_</a><span class="delimiter">[</span><a title="" id="73410">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_]" id="72957">F</a><span class="delimiter">[</span><a title="" id="73415">_</a><span class="delimiter">]</span>, <a title="[F[_], _, _]" id="72958">M0</a><span class="delimiter">[</span><a title="[_]" id="73411">F</a><span class="delimiter">[</span><a title="" id="73414">_</a><span class="delimiter">]</span>, <a title="" id="73412">_</a>, <a title="" id="73413">_</a><span class="delimiter">]</span>, <a title="" id="72959">A0</a>, <a title="" id="72960">B0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[F,α,B0]]" id="73408">TC0</a>: <a href="#72956" title="TC[[α]M0[F,α,B0]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F, α, B0<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#73416" title="Unapply_2 extends scalaz.Unapply[TC,M0[F,A0,B0]]">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F, A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F, X, B0<span class="delimiter">]</span>
    <span class="keyword">type</span> A = A0
  <span class="delimiter">}</span> = <a href="#429775" title="scalaz.Unapply[TC,M0[F,A0,B0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply[TC,M0[F,A0,B0]]" id="429775">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F, A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]M0[F,X,B0]" id="429777">M</a><span class="delimiter">[</span><a title="" id="429778">X</a><span class="delimiter">]</span> = <a href="#72958" title="M0[F,X,B0]">M0</a><span class="delimiter">[</span>F, X, B0<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="A0" id="429779">A</a> = <a href="#72959" title="A0">A0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[F,α,B0]]" id="429780">TC</a> = <a href="#73408" title="TC[[α]M0[F,α,B0]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="429781">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  /**Unpack a value of type `M0[F[_], A0, B0]` into types `[b]M0[F, A0, b]` and `B0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], F[_], M0[F[_], _, _], A0, B0](implicit TC0: TC[[β]M0[F,A0,β]])scalaz.Unapply[TC,M0[F,A0,B0]]{type M[X] = M0[F,A0,X]; type A = B0}" id="72961">unapplyMFAB2</a><span class="delimiter">[</span><a title="[_[_]]" id="72967">TC</a><span class="delimiter">[</span><a title="[_]" id="73375">_</a><span class="delimiter">[</span><a title="" id="73376">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_]" id="72968">F</a><span class="delimiter">[</span><a title="" id="73381">_</a><span class="delimiter">]</span>, <a title="[F[_], _, _]" id="72969">M0</a><span class="delimiter">[</span><a title="[_]" id="73377">F</a><span class="delimiter">[</span><a title="" id="73380">_</a><span class="delimiter">]</span>, <a title="" id="73378">_</a>, <a title="" id="73379">_</a><span class="delimiter">]</span>, <a title="" id="72970">A0</a>, <a title="" id="72971">B0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[β]M0[F,A0,β]]" id="73374">TC0</a>: <a href="#72967" title="TC[[β]M0[F,A0,β]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>β<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F, A0, β<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#73382" title="Unapply_2 extends scalaz.Unapply[TC,M0[F,A0,B0]]">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F, A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F, A0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = B0
  <span class="delimiter">}</span> = <a href="#429803" title="scalaz.Unapply[TC,M0[F,A0,B0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply[TC,M0[F,A0,B0]]" id="429803">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F, A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]M0[F,A0,X]" id="429805">M</a><span class="delimiter">[</span><a title="" id="429806">X</a><span class="delimiter">]</span> = <a href="#72969" title="M0[F,A0,X]">M0</a><span class="delimiter">[</span>F, A0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="B0" id="429807">A</a> = <a href="#72971" title="B0">B0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[β]M0[F,A0,β]]" id="429808">TC</a> = <a href="#73374" title="TC[[β]M0[F,A0,β]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="429809">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait Unapply_1 extends AnyRef with scalaz.Unapply_2" id="12041">Unapply_1</a> <span title="Unit" class="keyword">extends</span> <a href="#21875" title="scalaz.Unapply_2">Unapply_2</a> <span class="delimiter">{</span>
  /**Unpack a value of type `M0[A0, B0, C0, D0, E0, F0, G0]` into types `[g]M0[A0, B0, C0, D0, E0, F0, g]` and `G0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_, _, _, _, _, _, _], A0, B0, C0, D0, E0, F0, G0](implicit TC0: TC[[α]M0[A0,B0,C0,D0,E0,F0,α]])scalaz.Unapply[TC,M0[A0,B0,C0,D0,E0,F0,G0]]{type M[X] = M0[A0,B0,C0,D0,E0,F0,X]; type A = G0}" id="72973">unapplyMABCDEFG7</a><span class="delimiter">[</span><a title="[_[_]]" id="72983">TC</a><span class="delimiter">[</span><a title="[_]" id="73339">_</a><span class="delimiter">[</span><a title="" id="73340">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_, _, _, _, _, _, _]" id="72984">M0</a><span class="delimiter">[</span><a title="" id="73341">_</a>, <a title="" id="73342">_</a>, <a title="" id="73343">_</a>, <a title="" id="73344">_</a>, <a title="" id="73345">_</a>, <a title="" id="73346">_</a>, <a title="" id="73347">_</a><span class="delimiter">]</span>, <a title="" id="72985">A0</a>, <a title="" id="72986">B0</a>, <a title="" id="72987">C0</a>, <a title="" id="72988">D0</a>, <a title="" id="72989">E0</a>, <a title="" id="72990">F0</a>, <a title="" id="72991">G0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[A0,B0,C0,D0,E0,F0,α]]" id="73338">TC0</a>: <a href="#72983" title="TC[[α]M0[A0,B0,C0,D0,E0,F0,α]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, F0, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#73348" title="Unapply_1 extends scalaz.Unapply[TC,M0[A0,B0,C0,D0,E0,F0,G0]]">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, F0, G0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, F0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = G0
  <span class="delimiter">}</span> = <a href="#429833" title="scalaz.Unapply[TC,M0[A0,B0,C0,D0,E0,F0,G0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply[TC,M0[A0,B0,C0,D0,E0,F0,G0]]" id="429833">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, F0, G0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]M0[A0,B0,C0,D0,E0,F0,X]" id="429835">M</a><span class="delimiter">[</span><a title="" id="429836">X</a><span class="delimiter">]</span> = <a href="#72984" title="M0[A0,B0,C0,D0,E0,F0,X]">M0</a><span class="delimiter">[</span>A0, B0, C0, D0, E0, F0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="G0" id="429837">A</a> = <a href="#72991" title="G0">G0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[A0,B0,C0,D0,E0,F0,α]]" id="429838">TC</a> = <a href="#73338" title="TC[[α]M0[A0,B0,C0,D0,E0,F0,α]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="429839">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  /**Unpack a value of type `M0[A0, B0, C0, D0, E0, F0]` into types `[f]M0[A0, B0, C0, D0, E0, f]` and `F0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_, _, _, _, _, _], A0, B0, C0, D0, E0, F0](implicit TC0: TC[[α]M0[A0,B0,C0,D0,E0,α]])scalaz.Unapply[TC,M0[A0,B0,C0,D0,E0,F0]]{type M[X] = M0[A0,B0,C0,D0,E0,X]; type A = F0}" id="72992">unapplyMABCDEF6</a><span class="delimiter">[</span><a title="[_[_]]" id="73001">TC</a><span class="delimiter">[</span><a title="[_]" id="73304">_</a><span class="delimiter">[</span><a title="" id="73305">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_, _, _, _, _, _]" id="73002">M0</a><span class="delimiter">[</span><a title="" id="73306">_</a>, <a title="" id="73307">_</a>, <a title="" id="73308">_</a>, <a title="" id="73309">_</a>, <a title="" id="73310">_</a>, <a title="" id="73311">_</a><span class="delimiter">]</span>, <a title="" id="73003">A0</a>, <a title="" id="73004">B0</a>, <a title="" id="73005">C0</a>, <a title="" id="73006">D0</a>, <a title="" id="73007">E0</a>, <a title="" id="73008">F0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[A0,B0,C0,D0,E0,α]]" id="73303">TC0</a>: <a href="#73001" title="TC[[α]M0[A0,B0,C0,D0,E0,α]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#73312" title="Unapply_1 extends scalaz.Unapply[TC,M0[A0,B0,C0,D0,E0,F0]]">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, F0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = F0
  <span class="delimiter">}</span> = <a href="#429861" title="scalaz.Unapply[TC,M0[A0,B0,C0,D0,E0,F0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply[TC,M0[A0,B0,C0,D0,E0,F0]]" id="429861">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, F0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]M0[A0,B0,C0,D0,E0,X]" id="429863">M</a><span class="delimiter">[</span><a title="" id="429864">X</a><span class="delimiter">]</span> = <a href="#73002" title="M0[A0,B0,C0,D0,E0,X]">M0</a><span class="delimiter">[</span>A0, B0, C0, D0, E0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="F0" id="429865">A</a> = <a href="#73008" title="F0">F0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[A0,B0,C0,D0,E0,α]]" id="429866">TC</a> = <a href="#73303" title="TC[[α]M0[A0,B0,C0,D0,E0,α]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="429867">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  /**Unpack a value of type `M0[A0, B0, C0, D0, E0]` into types `[e]M0[A0, B0, C0, D0, e]` and `E0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_, _, _, _, _], A0, B0, C0, D0, E0](implicit TC0: TC[[α]M0[A0,B0,C0,D0,α]])scalaz.Unapply[TC,M0[A0,B0,C0,D0,E0]]{type M[X] = M0[A0,B0,C0,D0,X]; type A = E0}" id="73009">unapplyMABCDE5</a><span class="delimiter">[</span><a title="[_[_]]" id="73017">TC</a><span class="delimiter">[</span><a title="[_]" id="73270">_</a><span class="delimiter">[</span><a title="" id="73271">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_, _, _, _, _]" id="73018">M0</a><span class="delimiter">[</span><a title="" id="73272">_</a>, <a title="" id="73273">_</a>, <a title="" id="73274">_</a>, <a title="" id="73275">_</a>, <a title="" id="73276">_</a><span class="delimiter">]</span>, <a title="" id="73019">A0</a>, <a title="" id="73020">B0</a>, <a title="" id="73021">C0</a>, <a title="" id="73022">D0</a>, <a title="" id="73023">E0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[A0,B0,C0,D0,α]]" id="73269">TC0</a>: <a href="#73017" title="TC[[α]M0[A0,B0,C0,D0,α]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, D0, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#73277" title="Unapply_1 extends scalaz.Unapply[TC,M0[A0,B0,C0,D0,E0]]">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0, E0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, D0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = E0
  <span class="delimiter">}</span> = <a href="#429889" title="scalaz.Unapply[TC,M0[A0,B0,C0,D0,E0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply[TC,M0[A0,B0,C0,D0,E0]]" id="429889">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0, E0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]M0[A0,B0,C0,D0,X]" id="429891">M</a><span class="delimiter">[</span><a title="" id="429892">X</a><span class="delimiter">]</span> = <a href="#73018" title="M0[A0,B0,C0,D0,X]">M0</a><span class="delimiter">[</span>A0, B0, C0, D0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="E0" id="429893">A</a> = <a href="#73023" title="E0">E0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[A0,B0,C0,D0,α]]" id="429894">TC</a> = <a href="#73269" title="TC[[α]M0[A0,B0,C0,D0,α]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="429895">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  /**Unpack a value of type `M0[A0, B0, C0, D0]` into types `[d]M0[A0, B0, C0, d]` and `D0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_, _, _, _], A0, B0, C0, D0](implicit TC0: TC[[α]M0[A0,B0,C0,α]])scalaz.Unapply[TC,M0[A0,B0,C0,D0]]{type M[X] = M0[A0,B0,C0,X]; type A = D0}" id="73024">unapplyMABCD4</a><span class="delimiter">[</span><a title="[_[_]]" id="73031">TC</a><span class="delimiter">[</span><a title="[_]" id="73237">_</a><span class="delimiter">[</span><a title="" id="73238">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_, _, _, _]" id="73032">M0</a><span class="delimiter">[</span><a title="" id="73239">_</a>, <a title="" id="73240">_</a>, <a title="" id="73241">_</a>, <a title="" id="73242">_</a><span class="delimiter">]</span>, <a title="" id="73033">A0</a>, <a title="" id="73034">B0</a>, <a title="" id="73035">C0</a>, <a title="" id="73036">D0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[A0,B0,C0,α]]" id="73236">TC0</a>: <a href="#73031" title="TC[[α]M0[A0,B0,C0,α]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#73243" title="Unapply_1 extends scalaz.Unapply[TC,M0[A0,B0,C0,D0]]">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = D0
  <span class="delimiter">}</span> = <a href="#429917" title="scalaz.Unapply[TC,M0[A0,B0,C0,D0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply[TC,M0[A0,B0,C0,D0]]" id="429917">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]M0[A0,B0,C0,X]" id="429919">M</a><span class="delimiter">[</span><a title="" id="429920">X</a><span class="delimiter">]</span> = <a href="#73032" title="M0[A0,B0,C0,X]">M0</a><span class="delimiter">[</span>A0, B0, C0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="D0" id="429921">A</a> = <a href="#73036" title="D0">D0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[A0,B0,C0,α]]" id="429922">TC</a> = <a href="#73236" title="TC[[α]M0[A0,B0,C0,α]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="429923">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  /**Unpack a value of type `M0[A0, B0, C0]` into types `[c]M0[A0, B0, c]` and `C0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_, _, _], A0, B0, C0](implicit TC0: TC[[α]M0[A0,B0,α]])scalaz.Unapply[TC,M0[A0,B0,C0]]{type M[X] = M0[A0,B0,X]; type A = C0}" id="73037">unapplyMABC3</a><span class="delimiter">[</span><a title="[_[_]]" id="73043">TC</a><span class="delimiter">[</span><a title="[_]" id="73205">_</a><span class="delimiter">[</span><a title="" id="73206">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_, _, _]" id="73044">M0</a><span class="delimiter">[</span><a title="" id="73207">_</a>, <a title="" id="73208">_</a>, <a title="" id="73209">_</a><span class="delimiter">]</span>, <a title="" id="73045">A0</a>, <a title="" id="73046">B0</a>, <a title="" id="73047">C0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[A0,B0,α]]" id="73204">TC0</a>: <a href="#73043" title="TC[[α]M0[A0,B0,α]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#73210" title="Unapply_1 extends scalaz.Unapply[TC,M0[A0,B0,C0]]">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = C0
  <span class="delimiter">}</span> = <a href="#429945" title="scalaz.Unapply[TC,M0[A0,B0,C0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply[TC,M0[A0,B0,C0]]" id="429945">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]M0[A0,B0,X]" id="429947">M</a><span class="delimiter">[</span><a title="" id="429948">X</a><span class="delimiter">]</span> = <a href="#73044" title="M0[A0,B0,X]">M0</a><span class="delimiter">[</span>A0, B0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="C0" id="429949">A</a> = <a href="#73047" title="C0">C0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[A0,B0,α]]" id="429950">TC</a> = <a href="#73204" title="TC[[α]M0[A0,B0,α]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="429951">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait Unapply_0 extends AnyRef with scalaz.Unapply_1" id="18437">Unapply_0</a> <span title="Unit" class="keyword">extends</span> <a href="#12041" title="scalaz.Unapply_1">Unapply_1</a> <span class="delimiter">{</span>
  /** Unpack a value of type `M0[F0, A0]` where `F0: * -&gt; *` into
    * types `[a]M0[F0, a]` and `A`, given an instance of `TC`
    */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_[_], _], F0[_], A0](implicit TC0: TC[[α]M0[F0,α]])scalaz.Unapply[TC,M0[F0,A0]]{type M[X] = M0[F0,X]; type A = A0}" id="73049">unapplyMFA</a><span class="delimiter">[</span><a title="[_[_]]" id="73054">TC</a><span class="delimiter">[</span><a title="[_]" id="73172">_</a><span class="delimiter">[</span><a title="" id="73173">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_[_], _]" id="73055">M0</a><span class="delimiter">[</span><a title="[_]" id="73174">_</a><span class="delimiter">[</span><a title="" id="73176">_</a><span class="delimiter">]</span>, <a title="" id="73175">_</a><span class="delimiter">]</span>, <a title="[_]" id="73056">F0</a><span class="delimiter">[</span><a title="" id="73177">_</a><span class="delimiter">]</span>, <a title="" id="73057">A0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[F0,α]]" id="73171">TC0</a>: <a href="#73054" title="TC[[α]M0[F0,α]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F0, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#73178" title="Unapply_0 extends scalaz.Unapply[TC,M0[F0,A0]]">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F0, A0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = A0
  <span class="delimiter">}</span> = <a href="#429975" title="scalaz.Unapply[TC,M0[F0,A0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply[TC,M0[F0,A0]]" id="429975">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F0, A0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]M0[F0,X]" id="429977">M</a><span class="delimiter">[</span><a title="" id="429978">X</a><span class="delimiter">]</span> = <a href="#73055" title="M0[F0,X]">M0</a><span class="delimiter">[</span>F0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="A0" id="429979">A</a> = <a href="#73057" title="A0">A0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[F0,α]]" id="429980">TC</a> = <a href="#73171" title="TC[[α]M0[F0,α]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="429981">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  /**Unpack a value of type `M0[A0, B0]` into types `[a]M0[a, B0]` and `A`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_, _], A0, B0](implicit TC0: TC[[α]M0[α,B0]])scalaz.Unapply[TC,M0[A0,B0]]{type M[X] = M0[X,B0]; type A = A0}" id="73058">unapplyMAB1</a><span class="delimiter">[</span><a title="[_[_]]" id="73063">TC</a><span class="delimiter">[</span><a title="[_]" id="73141">_</a><span class="delimiter">[</span><a title="" id="73142">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_, _]" id="73064">M0</a><span class="delimiter">[</span><a title="" id="73143">_</a>, <a title="" id="73144">_</a><span class="delimiter">]</span>, <a title="" id="73065">A0</a>, <a title="" id="73066">B0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[α,B0]]" id="73140">TC0</a>: <a href="#73063" title="TC[[α]M0[α,B0]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>α, B0<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#73145" title="Unapply_0 extends scalaz.Unapply[TC,M0[A0,B0]]">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>X, B0<span class="delimiter">]</span>
    <span class="keyword">type</span> A = A0
  <span class="delimiter">}</span> = <a href="#430003" title="scalaz.Unapply[TC,M0[A0,B0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply[TC,M0[A0,B0]]" id="430003">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]M0[X,B0]" id="430005">M</a><span class="delimiter">[</span><a title="" id="430006">X</a><span class="delimiter">]</span> = <a href="#73064" title="M0[X,B0]">M0</a><span class="delimiter">[</span>X, B0<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="A0" id="430007">A</a> = <a href="#73065" title="A0">A0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[α,B0]]" id="430008">TC</a> = <a href="#73140" title="TC[[α]M0[α,B0]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="430009">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  /**Unpack a value of type `M0[A0, B0]` into types `[b]M0[A0, b]` and `B`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_, _], A0, B0](implicit TC0: TC[[α]M0[A0,α]])scalaz.Unapply[TC,M0[A0,B0]]{type M[X] = M0[A0,X]; type A = B0}" id="73067">unapplyMAB2</a><span class="delimiter">[</span><a title="[_[_]]" id="73072">TC</a><span class="delimiter">[</span><a title="[_]" id="73110">_</a><span class="delimiter">[</span><a title="" id="73111">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_, _]" id="73073">M0</a><span class="delimiter">[</span><a title="" id="73112">_</a>, <a title="" id="73113">_</a><span class="delimiter">]</span>, <a title="" id="73074">A0</a>, <a title="" id="73075">B0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[A0,α]]" id="73109">TC0</a>: <a href="#73072" title="TC[[α]M0[A0,α]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#73114" title="Unapply_0 extends scalaz.Unapply[TC,M0[A0,B0]]">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = B0
  <span class="delimiter">}</span> = <a href="#430031" title="scalaz.Unapply[TC,M0[A0,B0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply[TC,M0[A0,B0]]" id="430031">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]M0[A0,X]" id="430033">M</a><span class="delimiter">[</span><a title="" id="430034">X</a><span class="delimiter">]</span> = <a href="#73073" title="M0[A0,X]">M0</a><span class="delimiter">[</span>A0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="B0" id="430035">A</a> = <a href="#73075" title="B0">B0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[A0,α]]" id="430036">TC</a> = <a href="#73109" title="TC[[α]M0[A0,α]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="430037">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="scalaz.Unapply.type" id="18792">Unapply</a> <a href="#18793" title="scalaz.Unapply.type" class="keyword">extends</a> <a href="#18437" title="scalaz.Unapply_0">Unapply_0</a> <span class="delimiter">{</span>
  /** Unpack a value of type `M0[A0]` into types `M0` and `A0`, given a instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_], A0](implicit TC0: TC[M0])scalaz.Unapply[TC,M0[A0]]{type M[X] = M0[X]; type A = A0}" id="73077">unapplyMA</a><span class="delimiter">[</span><a title="[_[_]]" id="73081">TC</a><span class="delimiter">[</span><a title="[_]" id="73085">_</a><span class="delimiter">[</span><a title="" id="73086">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_]" id="73082">M0</a><span class="delimiter">[</span><a title="" id="73087">_</a><span class="delimiter">]</span>, <a title="" id="73083">A0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[M0]" id="73084">TC0</a>: <a href="#73081" title="TC[M0]">TC</a><span class="delimiter">[</span>M0<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#73088" title="Unapply extends scalaz.Unapply[TC,M0[A0]]">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = A0
  <span class="delimiter">}</span> = <a href="#430059" title="scalaz.Unapply[TC,M0[A0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply[TC,M0[A0]]" id="430059">Unapply</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]M0[X]" id="430061">M</a><span class="delimiter">[</span><a title="" id="430062">X</a><span class="delimiter">]</span> = <a href="#73082" title="M0[X]">M0</a><span class="delimiter">[</span>X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="A0" id="430063">A</a> = <a href="#73083" title="A0">A0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[M0]" id="430064">TC</a> = <a href="#73084" title="TC[M0]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="430065">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  // TODO More!
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait Unapply2[TC[_[_, _]], MAB] extends AnyRef" id="10994">Unapply2</a><span class="delimiter">[</span><a title="[_[_, _]]" id="23790">TC</a><span class="delimiter">[</span><a title="[_, _]" id="430085">_</a><span class="delimiter">[</span><a title="" id="430086">_</a>, <a title="" id="430087">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="23791">MAB</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>

  /** The type constructor */
  <span class="keyword">type</span> <a title="[_, _]" id="154747">M</a><span class="delimiter">[</span><a title="" id="154756">_</a>, <a title="" id="154757">_</a><span class="delimiter">]</span>

  /** The first type that `M` was applied to */
  <span class="keyword">type</span> <a title="" id="154748">A</a>

  /** The second type that `M` was applied to */
  <span class="keyword">type</span> <a title="" id="154749">B</a>

  /** The instance of the type class */
  <span class="keyword">def</span> <a title="=&gt; TC[Unapply2.this.M]" id="154750">TC</a>: <a href="#23790" title="TC[Unapply2.this.M]">TC</a><span class="delimiter">[</span>M<span class="delimiter">]</span>

  /** Evidence that MAB =:= M[A, B] */
  <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz.===[MAB,Unapply2.this.M[Unapply2.this.A,Unapply2.this.B]]" id="154751">leibniz</a>: MAB <a href="Leibniz.scala.html#11639" title="scalaz.Leibniz.===[MAB,Unapply2.this.M[Unapply2.this.A,Unapply2.this.B]]">===</a> M<span class="delimiter">[</span>A, B<span class="delimiter">]</span>

  /** Compatibility. */
  @inline <span class="keyword">final</span> <span class="keyword">def</span> <a title="(ma: MAB)Unapply2.this.M[Unapply2.this.A,Unapply2.this.B]" id="154752">apply</a><span class="delimiter">(</span><a title="MAB" id="154761">ma</a>: <a href="#23791" title="MAB">MAB</a><span class="delimiter">)</span>: <a href="#154747" title="Unapply2.this.M[Unapply2.this.A,Unapply2.this.B]">M</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> = <a href="#154751" title="=&gt; scalaz.Leibniz.===[MAB,Unapply2.this.M[Unapply2.this.A,Unapply2.this.B]]">leibniz</a>.<a href="Leibniz.scala.html#384599" title="[F[_ &gt;: scalaz.⊥ &lt;: scalaz.⊤]](p: F[MAB])F[Unapply2.this.M[Unapply2.this.A,Unapply2.this.B]]">subst</a><span title="(p: scalaz.Id.Id[MAB])scalaz.Id.Id[Unapply2.this.M[Unapply2.this.A,Unapply2.this.B]]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#154761" title="MAB">ma</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait Unapply2_0 extends AnyRef" id="9353">Unapply2_0</a> <span title="Unit" class="delimiter">{</span>
  /**Unpack a value of type `M0[F[_], A0, B0]` into types `[a, b]=M0[F, a, b]`, `A0`, and 'B9', given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_, _]], F[_], M0[F[_], _, _], A0, B0](implicit TC0: TC[[α, β]M0[F,α,β]])scalaz.Unapply2[TC,M0[F,A0,B0]]{type M[X, Y] = M0[F,X,Y]; type A = A0; type B = B0}" id="430098">unapplyMFAB</a><span class="delimiter">[</span><a title="[_[_, _]]" id="430104">TC</a><span class="delimiter">[</span><a title="[_, _]" id="430111">_</a><span class="delimiter">[</span><a title="" id="430112">_</a>, <a title="" id="430113">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_]" id="430105">F</a><span class="delimiter">[</span><a title="" id="430118">_</a><span class="delimiter">]</span>, <a title="[F[_], _, _]" id="430106">M0</a><span class="delimiter">[</span><a title="[_]" id="430114">F</a><span class="delimiter">[</span><a title="" id="430117">_</a><span class="delimiter">]</span>, <a title="" id="430115">_</a>, <a title="" id="430116">_</a><span class="delimiter">]</span>, <a title="" id="430107">A0</a>, <a title="" id="430108">B0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α, β]M0[F,α,β]]" id="430110">TC0</a>: <a href="#430104" title="TC[[α, β]M0[F,α,β]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α, β<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F, α, β<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#430119" title="Unapply2_0 extends scalaz.Unapply2[TC,M0[F,A0,B0]]">Unapply2</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F, A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X, Y<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F, X, Y<span class="delimiter">]</span>
    <span class="keyword">type</span> A = A0
    <span class="keyword">type</span> B = B0
  <span class="delimiter">}</span> = <a href="#430145" title="scalaz.Unapply2[TC,M0[F,A0,B0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply2[TC,M0[F,A0,B0]]" id="430145">Unapply2</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F, A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X, Y]M0[F,X,Y]" id="430147">M</a><span class="delimiter">[</span><a title="" id="430148">X</a>, <a title="" id="430149">Y</a><span class="delimiter">]</span> = <a href="#430106" title="M0[F,X,Y]">M0</a><span class="delimiter">[</span>F, X, Y<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="A0" id="430150">A</a> = <a href="#430107" title="A0">A0</a>
    <span class="keyword">type</span> <a title="B0" id="430151">B</a> = <a href="#430108" title="B0">B0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α, β]M0[F,α,β]]" id="430152">TC</a> = <a href="#430110" title="TC[[α, β]M0[F,α,β]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A,this.B],this.M[this.A,this.B],this.M[this.A,this.B],this.M[this.A,this.B]]" id="430153">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A,this.B],this.M[this.A,this.B],this.M[this.A,this.B],this.M[this.A,this.B]]">refl</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="scalaz.Unapply2.type" id="10995">Unapply2</a> <a href="#10996" title="scalaz.Unapply2.type" class="keyword">extends</a> <a href="#9353" title="scalaz.Unapply2_0">Unapply2_0</a> <span class="delimiter">{</span>
  /**Unpack a value of type `M0[A0, B0]` into types `M0`, `A`, and 'B', given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_, _]], M0[_, _], A0, B0](implicit TC0: TC[M0])scalaz.Unapply2[TC,M0[A0,B0]]{type M[X, Y] = M0[X,Y]; type A = A0; type B = B0}" id="430182">unapplyMAB</a><span class="delimiter">[</span><a title="[_[_, _]]" id="430187">TC</a><span class="delimiter">[</span><a title="[_, _]" id="430193">_</a><span class="delimiter">[</span><a title="" id="430194">_</a>, <a title="" id="430195">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_, _]" id="430188">M0</a><span class="delimiter">[</span><a title="" id="430196">_</a>, <a title="" id="430197">_</a><span class="delimiter">]</span>, <a title="" id="430189">A0</a>, <a title="" id="430190">B0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[M0]" id="430192">TC0</a>: <a href="#430187" title="TC[M0]">TC</a><span class="delimiter">[</span>M0<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#430198" title="Unapply2 extends scalaz.Unapply2[TC,M0[A0,B0]]">Unapply2</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X, Y<span class="delimiter">]</span> = M0<span class="delimiter">[</span>X, Y<span class="delimiter">]</span>
    <span class="keyword">type</span> A = A0
    <span class="keyword">type</span> B = B0
  <span class="delimiter">}</span> = <a href="#430217" title="scalaz.Unapply2[TC,M0[A0,B0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply2[TC,M0[A0,B0]]" id="430217">Unapply2</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X, Y]M0[X,Y]" id="430219">M</a><span class="delimiter">[</span><a title="" id="430220">X</a>, <a title="" id="430221">Y</a><span class="delimiter">]</span> = <a href="#430188" title="M0[X,Y]">M0</a><span class="delimiter">[</span>X, Y<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="A0" id="430222">A</a> = <a href="#430189" title="A0">A0</a>
    <span class="keyword">type</span> <a title="B0" id="430223">B</a> = <a href="#430190" title="B0">B0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[M0]" id="430224">TC</a> = <a href="#430192" title="TC[M0]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A,this.B],this.M[this.A,this.B],this.M[this.A,this.B],this.M[this.A,this.B]]" id="430225">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A,this.B],this.M[this.A,this.B],this.M[this.A,this.B],this.M[this.A,this.B]]">refl</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait Unapply21[TC[_[_, _], _], MAB] extends AnyRef" id="7862">Unapply21</a><span class="delimiter">[</span><a title="[_[_, _], _]" id="23792">TC</a><span class="delimiter">[</span><a title="[_, _]" id="430253">_</a><span class="delimiter">[</span><a title="" id="430255">_</a>, <a title="" id="430256">_</a><span class="delimiter">]</span>, <a title="" id="430254">_</a><span class="delimiter">]</span>, <a title="" id="23793">MAB</a><span class="delimiter">]</span><span title="Unit" class="delimiter">{</span>
  <span class="keyword">type</span> <a title="[_, _]" id="154405">M</a><span class="delimiter">[</span><a title="" id="154414">_</a>, <a title="" id="154415">_</a><span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="" id="154406">A</a>
  <span class="keyword">type</span> <a title="" id="154407">B</a>
  <span class="keyword">def</span> <a title="=&gt; TC[Unapply21.this.M,Unapply21.this.A]" id="154408">TC</a>: <a href="#23792" title="TC[Unapply21.this.M,Unapply21.this.A]">TC</a><span class="delimiter">[</span>M, A<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz.===[MAB,Unapply21.this.M[Unapply21.this.A,Unapply21.this.B]]" id="154409">leibniz</a>: MAB <a href="Leibniz.scala.html#11639" title="scalaz.Leibniz.===[MAB,Unapply21.this.M[Unapply21.this.A,Unapply21.this.B]]">===</a> M<span class="delimiter">[</span>A, B<span class="delimiter">]</span>
  @inline <span class="keyword">final</span> <span class="keyword">def</span> <a title="(mabc: MAB)Unapply21.this.M[Unapply21.this.A,Unapply21.this.B]" id="154410">apply</a><span class="delimiter">(</span><a title="MAB" id="154419">mabc</a>: <a href="#23793" title="MAB">MAB</a><span class="delimiter">)</span>: <a href="#154405" title="Unapply21.this.M[Unapply21.this.A,Unapply21.this.B]">M</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> = <a href="#154409" title="=&gt; scalaz.Leibniz.===[MAB,Unapply21.this.M[Unapply21.this.A,Unapply21.this.B]]">leibniz</a>.<a href="Leibniz.scala.html#384599" title="[F[_ &gt;: scalaz.⊥ &lt;: scalaz.⊤]](p: F[MAB])F[Unapply21.this.M[Unapply21.this.A,Unapply21.this.B]]">subst</a><span title="(p: scalaz.Id.Id[MAB])scalaz.Id.Id[Unapply21.this.M[Unapply21.this.A,Unapply21.this.B]]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#154419" title="MAB">mabc</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="scalaz.Unapply21.type" id="7863">Unapply21</a> <a href="#7864" title="scalaz.Unapply21.type" class="delimiter">{</a>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_, _], _], F[+_, +_], M0[_[+_], _, _], A0, B0, C](implicit TC0: TC[[a, b]M0[[+x]F[a,x],C,b],A0])scalaz.Unapply21[TC,M0[[+x]F[A0,x],C,B0]]{type M[X, Y] = M0[[+a]F[X,a],C,Y]; type A = A0; type B = B0}" id="430267">unapply210MFABC</a><span class="delimiter">[</span><a title="[_[_, _], _]" id="430274">TC</a><span class="delimiter">[</span><a title="[_, _]" id="430282">_</a><span class="delimiter">[</span><a title="" id="430284">_</a>, <a title="" id="430285">_</a><span class="delimiter">]</span>, <a title="" id="430283">_</a><span class="delimiter">]</span>, <a title="[+_, +_]" id="430275">F</a><span class="delimiter">[</span>+<a title="" id="430293">_</a>,+<a title="" id="430294">_</a><span class="delimiter">]</span>, <a title="[_[+_], _, _]" id="430276">M0</a><span class="delimiter">[</span><a title="[+_]" id="430286">_</a><span class="delimiter">[</span>+<a title="" id="430289">_</a><span class="delimiter">]</span>, <a title="" id="430287">_</a>, <a title="" id="430288">_</a><span class="delimiter">]</span>, <a title="" id="430277">A0</a>, <a title="" id="430278">B0</a>, <a title="" id="430279">C</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[a, b]M0[[+x]F[a,x],C,b],A0]" id="430281">TC0</a>: <a href="#430274" title="TC[[a, b]M0[[+x]F[a,x],C,b],A0]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>a, b<span class="delimiter">]</span> = M0<span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> m<span class="delimiter">[</span>+x<span class="delimiter">]</span> = F<span class="delimiter">[</span>a, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#m, C, b<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f, A0<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#430297" title="Unapply21 extends scalaz.Unapply21[TC,M0[[+x]F[A0,x],C,B0]]">Unapply21</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = F<span class="delimiter">[</span>A0, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f, C, B0<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>X, Y<span class="delimiter">]</span> = M0<span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+a<span class="delimiter">]</span> = F<span class="delimiter">[</span>X, a<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f, C, Y<span class="delimiter">]</span>
    <span class="keyword">type</span> A = A0
    <span class="keyword">type</span> B = B0
  <span class="delimiter">}</span> = <a href="#430333" title="scalaz.Unapply21[TC,M0[[+x]F[A0,x],C,B0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Unapply21[TC,M0[[+x]F[A0,x],C,B0]]" id="430333">Unapply21</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = F<span class="delimiter">[</span>A0, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f, C, B0<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X, Y]M0[[+a]F[X,a],C,Y]" id="430340">M</a><span class="delimiter">[</span><a title="" id="430341">X</a>, <a title="" id="430342">Y</a><span class="delimiter">]</span> = <a href="#430276" title="M0[[+a]F[X,a],C,Y]">M0</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+a<span class="delimiter">]</span> = F<span class="delimiter">[</span>X, a<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f, C, Y<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="A0" id="430343">A</a> = <a href="#430277" title="A0">A0</a>
    <span class="keyword">type</span> <a title="B0" id="430344">B</a> = <a href="#430278" title="B0">B0</a>

    <span class="keyword">def</span> <a title="=&gt; TC[[a, b]M0[[+x]F[a,x],C,b],A0]" id="430345">TC</a> = <a href="#430281" title="TC[[a, b]M0[[+x]F[a,x],C,b],A0]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A,this.B],this.M[this.A,this.B],this.M[this.A,this.B],this.M[this.A,this.B]]" id="430346">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A,this.B],this.M[this.A,this.B],this.M[this.A,this.B],this.M[this.A,this.B]]">refl</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait UnapplyProduct[TC[_[_]], MA, MB] extends AnyRef" id="9971">UnapplyProduct</a><span class="delimiter">[</span><a title="[_[_]]" id="23794">TC</a><span class="delimiter">[</span><a title="[_]" id="430424">_</a><span class="delimiter">[</span><a title="" id="430425">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="23795">MA</a>, <a title="" id="23796">MB</a><span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">type</span> <a title="[X]" id="430417">M</a><span class="delimiter">[</span><a title="" id="430427">X</a><span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="" id="430418">A</a>
  <span class="keyword">type</span> <a title="" id="430419">B</a>
  <span class="keyword">def</span> <a title="=&gt; TC[UnapplyProduct.this.M]" id="430420">TC</a>: <a href="#23794" title="TC[UnapplyProduct.this.M]">TC</a><span class="delimiter">[</span>M<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="MA" id="430421">MA_</a> = <a href="#23795" title="MA">MA</a>
  <span class="keyword">def</span> <a title="(ma: MA)UnapplyProduct.this.M[UnapplyProduct.this.A]" id="430422">_1</a><span class="delimiter">(</span><a title="MA" id="430428">ma</a>: <a href="#23795" title="MA">MA</a><span class="delimiter">)</span>: <a href="#430417" title="UnapplyProduct.this.M[UnapplyProduct.this.A]">M</a><span class="delimiter">[</span>A<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="(mb: MB)UnapplyProduct.this.M[UnapplyProduct.this.B]" id="430423">_2</a><span class="delimiter">(</span><a title="MB" id="430429">mb</a>: <a href="#23796" title="MB">MB</a><span class="delimiter">)</span>: <a href="#430417" title="UnapplyProduct.this.M[UnapplyProduct.this.B]">M</a><span class="delimiter">[</span>B<span class="delimiter">]</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="scalaz.UnapplyProduct.type" id="9972">UnapplyProduct</a> <a href="#9973" title="scalaz.UnapplyProduct.type" class="delimiter">{</a>
  <span class="keyword">import</span> <a href="Isomorphism.scala.html#9078" title="scalaz.Isomorphism.type">Isomorphism</a>.&lt;~&gt;
  // This seems to motivate multiple implicit parameter sections. Is there another way?
  // Currently, a type annotation in a parameter declaration may be path-dependent on a
  // parameter from a previous parameter section, hence `iso` can't be in the first parameter
  // section; which itself can't be implicit.
  //
  // There are two possible changes to Scalac that could help:
  //
  // 1. Allow multiple implicit parameter sections
  // 2. Allow path-dependent parameter types to refer to the current (or even subsequent)
  //    parameter sections.
  //
  //    A motivating example for #2 is in neg/depmet_try_implicit.scala
  //
  //    def foo[T, T2](a: T, x: T2)(implicit w: ComputeT2[T, T2]) // awkward, if you provide T you must also provide T2
  //    def foo[T](a: T, x: w.T2)(implicit w: ComputeT2[T])       // more compact, and allows you to provide T1 and infer T2.
  //
  /*implicit */ <span class="keyword">def</span> <a title="[TC[_[_]], MA0, MB0](U1: scalaz.Unapply[TC,MA0], U2: scalaz.Unapply[TC,MB0])(implicit iso: scalaz.Isomorphism.&lt;~&gt;[U1.M,U2.M])scalaz.UnapplyProduct[TC,MA0,MB0]{type M[X] = U1.M[X]; type A = U1.A; type B = U2.A}" id="430432">unapply</a><span class="delimiter">[</span><a title="[_[_]]" id="430436">TC</a><span class="delimiter">[</span><a title="[_]" id="430444">_</a><span class="delimiter">[</span><a title="" id="430445">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="430437">MA0</a>, <a title="" id="430438">MB0</a><span class="delimiter">]</span><span class="delimiter">(</span>/*implicit */<a title="scalaz.Unapply[TC,MA0]" id="430440">U1</a>: <a href="#18791" title="scalaz.Unapply[TC,MA0]">Unapply</a><span class="delimiter">[</span>TC, MA0<span class="delimiter">]</span>, <a title="scalaz.Unapply[TC,MB0]" id="430441">U2</a>: <a href="#18791" title="scalaz.Unapply[TC,MB0]">Unapply</a><span class="delimiter">[</span>TC, MB0<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Isomorphism.&lt;~&gt;[U1.M,U2.M]" id="430442">iso</a>: U1.M <a href="Isomorphism.scala.html#51675" title="scalaz.Isomorphism.&lt;~&gt;[U1.M,U2.M]">&lt;~&gt;</a> U2.M<span class="delimiter">)</span> = <a href="#430443" title="scalaz.UnapplyProduct[TC,MA0,MB0]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.UnapplyProduct[TC,MA0,MB0]" id="430443">UnapplyProduct</a><span class="delimiter">[</span>TC, MA0, MB0<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[X]U1.M[X]" id="430447">M</a><span class="delimiter">[</span><a title="" id="430448">X</a><span class="delimiter">]</span> = U1.<a href="#52637" title="U1.M[X]">M</a><span class="delimiter">[</span>X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="U1.A" id="430449">A</a> = U1.<a href="#52638" title="U1.A">A</a>
    <span class="keyword">type</span> <a title="U2.A" id="430450">B</a> = U2.<a href="#52638" title="U2.A">A</a>
    <span class="keyword">def</span> <a title="=&gt; TC[U1.M]" id="430451">TC</a> = <a href="#430440" title="scalaz.Unapply[TC,MA0]">U1</a>.<a href="#52639" title="=&gt; TC[U1.M]">TC</a>
    <span class="keyword">def</span> <a title="(ma: MA0)U1.M[U1.A]" id="430452">_1</a><span class="delimiter">(</span><a title="MA0" id="430461">ma</a>: <a href="#430437" title="MA0">MA0</a><span class="delimiter">)</span> = <a href="#52641" title="(ma: MA0)U1.M[U1.A]">U1</a><span class="delimiter">(</span><a href="#430461" title="MA0">ma</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(mb: MB0)U1.M[U2.A]" id="430453">_2</a><span class="delimiter">(</span><a title="MB0" id="430466">mb</a>: <a href="#430438" title="MB0">MB0</a><span class="delimiter">)</span> = <a href="#430442" title="scalaz.Isomorphism.&lt;~&gt;[U1.M,U2.M]">iso</a>.<a href="NaturalTransformation.scala.html#144451" title="(fa: U2.M[U2.A])U1.M[U2.A]">from</a><span class="delimiter">(</span><a href="#52641" title="(ma: MB0)U2.M[U2.A]">U2</a><span class="delimiter">(</span><a href="#430466" title="MB0">mb</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

/** Unapply a covariant type constructor, maintaining the covariance */
<span title="AnyRef" class="keyword">trait</span> <a title="trait UnapplyCo[TC[_[_]], MA] extends AnyRef" id="14783">UnapplyCo</a><span class="delimiter">[</span><a title="[_[_]]" id="23797">TC</a><span class="delimiter">[</span><a title="[_]" id="430543">_</a><span class="delimiter">[</span><a title="" id="430544">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="23798">MA</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>

  /** The type constructor */
  <span class="keyword">type</span> <a title="[+_]" id="154056">M</a><span class="delimiter">[</span>+<a title="" id="154063">_</a><span class="delimiter">]</span>

  /** The type that `M` was applied to */
  <span class="keyword">type</span> <a title="" id="154057">A</a>

  /** The instance of the type class */
  <span class="keyword">def</span> <a title="=&gt; TC[UnapplyCo.this.M]" id="154058">TC</a>: <a href="#23797" title="TC[UnapplyCo.this.M]">TC</a><span class="delimiter">[</span>M<span class="delimiter">]</span>

  /** Evidence that MA =:= M[A] */
  <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz.===[MA,UnapplyCo.this.M[UnapplyCo.this.A]]" id="154059">leibniz</a>: MA <a href="Leibniz.scala.html#11639" title="scalaz.Leibniz.===[MA,UnapplyCo.this.M[UnapplyCo.this.A]]">===</a> M<span class="delimiter">[</span>A<span class="delimiter">]</span>

  /** Compatibility. */
  @inline <span class="keyword">final</span> <span class="keyword">def</span> <a title="(ma: MA)UnapplyCo.this.M[UnapplyCo.this.A]" id="154060">apply</a><span class="delimiter">(</span><a title="MA" id="154067">ma</a>: <a href="#23798" title="MA">MA</a><span class="delimiter">)</span>: <a href="#154056" title="UnapplyCo.this.M[UnapplyCo.this.A]">M</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#154059" title="=&gt; scalaz.Leibniz.===[MA,UnapplyCo.this.M[UnapplyCo.this.A]]">leibniz</a>.<a href="Leibniz.scala.html#384599" title="[F[_ &gt;: scalaz.⊥ &lt;: scalaz.⊤]](p: F[MA])F[UnapplyCo.this.M[UnapplyCo.this.A]]">subst</a><span title="(p: scalaz.Id.Id[MA])scalaz.Id.Id[UnapplyCo.this.M[UnapplyCo.this.A]]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#154067" title="MA">ma</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait UnapplyCo_3 extends AnyRef" id="10694">UnapplyCo_3</a> <span title="Unit" class="delimiter">{</span>
  /** Unpack a value of type `A0` into type `[a]A0`, given a instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], A0](implicit TC0: TC[[α]A0])scalaz.UnapplyCo[TC,A0]{type M[+X] = A0; type A = A0}" id="153865">unapplyA</a><span class="delimiter">[</span><a title="[_[_]]" id="153868">TC</a><span class="delimiter">[</span><a title="[_]" id="430556">_</a><span class="delimiter">[</span><a title="" id="430557">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="" id="153869">A0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]A0]" id="430555">TC0</a>: <a href="#153868" title="TC[[α]A0]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = A0<span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#430558" title="UnapplyCo_3 extends scalaz.UnapplyCo[TC,A0]">UnapplyCo</a><span class="delimiter">[</span>TC, A0<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>+X<span class="delimiter">]</span> = A0
    <span class="keyword">type</span> A = A0
  <span class="delimiter">}</span> = <a href="#430577" title="scalaz.UnapplyCo[TC,A0]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.UnapplyCo[TC,A0]" id="430577">UnapplyCo</a><span class="delimiter">[</span>TC, A0<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[+X]A0" id="430579">M</a><span class="delimiter">[</span>+<a title="" id="430580">X</a><span class="delimiter">]</span> = <a href="#153869" title="A0">A0</a>
    <span class="keyword">type</span> <a title="A0" id="430581">A</a> = <a href="#153869" title="A0">A0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]A0]" id="430582">TC</a> = <a href="#430555" title="TC[[α]A0]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="430583">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait UnapplyCo_2 extends AnyRef with scalaz.UnapplyCo_3" id="13031">UnapplyCo_2</a> <span title="Unit" class="keyword">extends</span> <a href="#10694" title="scalaz.UnapplyCo_3">UnapplyCo_3</a> <span class="delimiter">{</span>
  /**Unpack a value of type `M0[F[+_], A0, B0]` into types `[a]M0[F, a, B0]` and `A0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], F[+_], M0[F[+_], +_, _], A0, B0](implicit TC0: TC[[α]M0[F,α,B0]])scalaz.UnapplyCo[TC,M0[F,A0,B0]]{type M[+X] = M0[F,X,B0]; type A = A0}" id="153871">unapplyMFAB1</a><span class="delimiter">[</span><a title="[_[_]]" id="153877">TC</a><span class="delimiter">[</span><a title="[_]" id="430606">_</a><span class="delimiter">[</span><a title="" id="430607">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[+_]" id="153878">F</a><span class="delimiter">[</span>+<a title="" id="430612">_</a><span class="delimiter">]</span>, <a title="[F[+_], +_, _]" id="153879">M0</a><span class="delimiter">[</span><a title="[+_]" id="430608">F</a><span class="delimiter">[</span>+<a title="" id="430611">_</a><span class="delimiter">]</span>, +<a title="" id="430609">_</a>, <a title="" id="430610">_</a><span class="delimiter">]</span>, <a title="" id="153880">A0</a>, <a title="" id="153881">B0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[F,α,B0]]" id="430605">TC0</a>: <a href="#153877" title="TC[[α]M0[F,α,B0]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F, α, B0<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#430613" title="UnapplyCo_2 extends scalaz.UnapplyCo[TC,M0[F,A0,B0]]">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F, A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>+X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F, X, B0<span class="delimiter">]</span>
    <span class="keyword">type</span> A = A0
  <span class="delimiter">}</span> = <a href="#430633" title="scalaz.UnapplyCo[TC,M0[F,A0,B0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.UnapplyCo[TC,M0[F,A0,B0]]" id="430633">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F, A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[+X]M0[F,X,B0]" id="430635">M</a><span class="delimiter">[</span>+<a title="" id="430636">X</a><span class="delimiter">]</span> = <a href="#153879" title="M0[F,X,B0]">M0</a><span class="delimiter">[</span>F, X, B0<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="A0" id="430637">A</a> = <a href="#153880" title="A0">A0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[F,α,B0]]" id="430638">TC</a> = <a href="#430605" title="TC[[α]M0[F,α,B0]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="430639">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  /**Unpack a value of type `M0[F[+_], A0, B0]` into types `[b]M0[F, A0, b]` and `B0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], F[+_], M0[F[+_], _, +_], A0, B0](implicit TC0: TC[[β]M0[F,A0,β]])scalaz.UnapplyCo[TC,M0[F,A0,B0]]{type M[+X] = M0[F,A0,X]; type A = B0}" id="153882">unapplyMFAB2</a><span class="delimiter">[</span><a title="[_[_]]" id="153888">TC</a><span class="delimiter">[</span><a title="[_]" id="430660">_</a><span class="delimiter">[</span><a title="" id="430661">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[+_]" id="153889">F</a><span class="delimiter">[</span>+<a title="" id="430666">_</a><span class="delimiter">]</span>, <a title="[F[+_], _, +_]" id="153890">M0</a><span class="delimiter">[</span><a title="[+_]" id="430662">F</a><span class="delimiter">[</span>+<a title="" id="430665">_</a><span class="delimiter">]</span>, <a title="" id="430663">_</a>, +<a title="" id="430664">_</a><span class="delimiter">]</span>, <a title="" id="153891">A0</a>, <a title="" id="153892">B0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[β]M0[F,A0,β]]" id="430659">TC0</a>: <a href="#153888" title="TC[[β]M0[F,A0,β]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>β<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F, A0, β<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#430667" title="UnapplyCo_2 extends scalaz.UnapplyCo[TC,M0[F,A0,B0]]">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F, A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>+X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>F, A0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = B0
  <span class="delimiter">}</span> = <a href="#430687" title="scalaz.UnapplyCo[TC,M0[F,A0,B0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.UnapplyCo[TC,M0[F,A0,B0]]" id="430687">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>F, A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[+X]M0[F,A0,X]" id="430689">M</a><span class="delimiter">[</span>+<a title="" id="430690">X</a><span class="delimiter">]</span> = <a href="#153890" title="M0[F,A0,X]">M0</a><span class="delimiter">[</span>F, A0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="B0" id="430691">A</a> = <a href="#153892" title="B0">B0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[β]M0[F,A0,β]]" id="430692">TC</a> = <a href="#430659" title="TC[[β]M0[F,A0,β]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="430693">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait UnapplyCo_1 extends AnyRef with scalaz.UnapplyCo_2" id="18740">UnapplyCo_1</a> <span title="Unit" class="keyword">extends</span> <a href="#13031" title="scalaz.UnapplyCo_2">UnapplyCo_2</a> <span class="delimiter">{</span>
  /**Unpack a value of type `M0[A0, B0, C0, D0, E0, F0, G0]` into types `[g]M0[A0, B0, C0, D0, E0, F0, g]` and `G0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_, _, _, _, _, _, +_], A0, B0, C0, D0, E0, F0, G0](implicit TC0: TC[[α]M0[A0,B0,C0,D0,E0,F0,α]])scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0,E0,F0,G0]]{type M[+X] = M0[A0,B0,C0,D0,E0,F0,X]; type A = G0}" id="153894">unapplyMABCDEFG7</a><span class="delimiter">[</span><a title="[_[_]]" id="153904">TC</a><span class="delimiter">[</span><a title="[_]" id="430716">_</a><span class="delimiter">[</span><a title="" id="430717">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_, _, _, _, _, _, +_]" id="153905">M0</a><span class="delimiter">[</span><a title="" id="430718">_</a>, <a title="" id="430719">_</a>, <a title="" id="430720">_</a>, <a title="" id="430721">_</a>, <a title="" id="430722">_</a>, <a title="" id="430723">_</a>, +<a title="" id="430724">_</a><span class="delimiter">]</span>, <a title="" id="153906">A0</a>, <a title="" id="153907">B0</a>, <a title="" id="153908">C0</a>, <a title="" id="153909">D0</a>, <a title="" id="153910">E0</a>, <a title="" id="153911">F0</a>, <a title="" id="153912">G0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[A0,B0,C0,D0,E0,F0,α]]" id="430715">TC0</a>: <a href="#153904" title="TC[[α]M0[A0,B0,C0,D0,E0,F0,α]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, F0, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#430725" title="UnapplyCo_1 extends scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0,E0,F0,G0]]">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, F0, G0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>+X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, F0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = G0
  <span class="delimiter">}</span> = <a href="#430745" title="scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0,E0,F0,G0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0,E0,F0,G0]]" id="430745">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, F0, G0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[+X]M0[A0,B0,C0,D0,E0,F0,X]" id="430747">M</a><span class="delimiter">[</span>+<a title="" id="430748">X</a><span class="delimiter">]</span> = <a href="#153905" title="M0[A0,B0,C0,D0,E0,F0,X]">M0</a><span class="delimiter">[</span>A0, B0, C0, D0, E0, F0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="G0" id="430749">A</a> = <a href="#153912" title="G0">G0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[A0,B0,C0,D0,E0,F0,α]]" id="430750">TC</a> = <a href="#430715" title="TC[[α]M0[A0,B0,C0,D0,E0,F0,α]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="430751">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  /**Unpack a value of type `M0[A0, B0, C0, D0, E0, F0]` into types `[f]M0[A0, B0, C0, D0, E0, f]` and `F0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_, _, _, _, _, +_], A0, B0, C0, D0, E0, F0](implicit TC0: TC[[α]M0[A0,B0,C0,D0,E0,α]])scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0,E0,F0]]{type M[+X] = M0[A0,B0,C0,D0,E0,X]; type A = F0}" id="153913">unapplyMABCDEF6</a><span class="delimiter">[</span><a title="[_[_]]" id="153922">TC</a><span class="delimiter">[</span><a title="[_]" id="430772">_</a><span class="delimiter">[</span><a title="" id="430773">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_, _, _, _, _, +_]" id="153923">M0</a><span class="delimiter">[</span><a title="" id="430774">_</a>, <a title="" id="430775">_</a>, <a title="" id="430776">_</a>, <a title="" id="430777">_</a>, <a title="" id="430778">_</a>, +<a title="" id="430779">_</a><span class="delimiter">]</span>, <a title="" id="153924">A0</a>, <a title="" id="153925">B0</a>, <a title="" id="153926">C0</a>, <a title="" id="153927">D0</a>, <a title="" id="153928">E0</a>, <a title="" id="153929">F0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[A0,B0,C0,D0,E0,α]]" id="430771">TC0</a>: <a href="#153922" title="TC[[α]M0[A0,B0,C0,D0,E0,α]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#430780" title="UnapplyCo_1 extends scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0,E0,F0]]">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, F0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>+X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = F0
  <span class="delimiter">}</span> = <a href="#430800" title="scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0,E0,F0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0,E0,F0]]" id="430800">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0, E0, F0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[+X]M0[A0,B0,C0,D0,E0,X]" id="430802">M</a><span class="delimiter">[</span>+<a title="" id="430803">X</a><span class="delimiter">]</span> = <a href="#153923" title="M0[A0,B0,C0,D0,E0,X]">M0</a><span class="delimiter">[</span>A0, B0, C0, D0, E0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="F0" id="430804">A</a> = <a href="#153929" title="F0">F0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[A0,B0,C0,D0,E0,α]]" id="430805">TC</a> = <a href="#430771" title="TC[[α]M0[A0,B0,C0,D0,E0,α]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="430806">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  /**Unpack a value of type `M0[A0, B0, C0, D0, E0]` into types `[e]M0[A0, B0, C0, D0, e]` and `E0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_, _, _, _, +_], A0, B0, C0, D0, E0](implicit TC0: TC[[α]M0[A0,B0,C0,D0,α]])scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0,E0]]{type M[+X] = M0[A0,B0,C0,D0,X]; type A = E0}" id="153930">unapplyMABCDE5</a><span class="delimiter">[</span><a title="[_[_]]" id="153938">TC</a><span class="delimiter">[</span><a title="[_]" id="430827">_</a><span class="delimiter">[</span><a title="" id="430828">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_, _, _, _, +_]" id="153939">M0</a><span class="delimiter">[</span><a title="" id="430829">_</a>, <a title="" id="430830">_</a>, <a title="" id="430831">_</a>, <a title="" id="430832">_</a>, +<a title="" id="430833">_</a><span class="delimiter">]</span>, <a title="" id="153940">A0</a>, <a title="" id="153941">B0</a>, <a title="" id="153942">C0</a>, <a title="" id="153943">D0</a>, <a title="" id="153944">E0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[A0,B0,C0,D0,α]]" id="430826">TC0</a>: <a href="#153938" title="TC[[α]M0[A0,B0,C0,D0,α]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, D0, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#430834" title="UnapplyCo_1 extends scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0,E0]]">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0, E0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>+X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, D0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = E0
  <span class="delimiter">}</span> = <a href="#430854" title="scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0,E0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0,E0]]" id="430854">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0, E0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[+X]M0[A0,B0,C0,D0,X]" id="430856">M</a><span class="delimiter">[</span>+<a title="" id="430857">X</a><span class="delimiter">]</span> = <a href="#153939" title="M0[A0,B0,C0,D0,X]">M0</a><span class="delimiter">[</span>A0, B0, C0, D0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="E0" id="430858">A</a> = <a href="#153944" title="E0">E0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[A0,B0,C0,D0,α]]" id="430859">TC</a> = <a href="#430826" title="TC[[α]M0[A0,B0,C0,D0,α]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="430860">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  /**Unpack a value of type `M0[A0, B0, C0, D0]` into types `[d]M0[A0, B0, C0, d]` and `D0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_, _, _, +_], A0, B0, C0, D0](implicit TC0: TC[[α]M0[A0,B0,C0,α]])scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0]]{type M[+X] = M0[A0,B0,C0,X]; type A = D0}" id="153945">unapplyMABCD4</a><span class="delimiter">[</span><a title="[_[_]]" id="153952">TC</a><span class="delimiter">[</span><a title="[_]" id="430881">_</a><span class="delimiter">[</span><a title="" id="430882">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_, _, _, +_]" id="153953">M0</a><span class="delimiter">[</span><a title="" id="430883">_</a>, <a title="" id="430884">_</a>, <a title="" id="430885">_</a>, +<a title="" id="430886">_</a><span class="delimiter">]</span>, <a title="" id="153954">A0</a>, <a title="" id="153955">B0</a>, <a title="" id="153956">C0</a>, <a title="" id="153957">D0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[A0,B0,C0,α]]" id="430880">TC0</a>: <a href="#153952" title="TC[[α]M0[A0,B0,C0,α]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#430887" title="UnapplyCo_1 extends scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0]]">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>+X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, C0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = D0
  <span class="delimiter">}</span> = <a href="#430907" title="scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.UnapplyCo[TC,M0[A0,B0,C0,D0]]" id="430907">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0, D0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[+X]M0[A0,B0,C0,X]" id="430909">M</a><span class="delimiter">[</span>+<a title="" id="430910">X</a><span class="delimiter">]</span> = <a href="#153953" title="M0[A0,B0,C0,X]">M0</a><span class="delimiter">[</span>A0, B0, C0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="D0" id="430911">A</a> = <a href="#153957" title="D0">D0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[A0,B0,C0,α]]" id="430912">TC</a> = <a href="#430880" title="TC[[α]M0[A0,B0,C0,α]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="430913">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  /**Unpack a value of type `M0[A0, B0, C0]` into types `[c]M0[A0, B0, c]` and `C0`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_, _, +_], A0, B0, C0](implicit TC0: TC[[α]M0[A0,B0,α]])scalaz.UnapplyCo[TC,M0[A0,B0,C0]]{type M[+X] = M0[A0,B0,X]; type A = C0}" id="153958">unapplyMABC3</a><span class="delimiter">[</span><a title="[_[_]]" id="153964">TC</a><span class="delimiter">[</span><a title="[_]" id="430934">_</a><span class="delimiter">[</span><a title="" id="430935">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_, _, +_]" id="153965">M0</a><span class="delimiter">[</span><a title="" id="430936">_</a>, <a title="" id="430937">_</a>, +<a title="" id="430938">_</a><span class="delimiter">]</span>, <a title="" id="153966">A0</a>, <a title="" id="153967">B0</a>, <a title="" id="153968">C0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[A0,B0,α]]" id="430933">TC0</a>: <a href="#153964" title="TC[[α]M0[A0,B0,α]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#430939" title="UnapplyCo_1 extends scalaz.UnapplyCo[TC,M0[A0,B0,C0]]">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>+X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, B0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = C0
  <span class="delimiter">}</span> = <a href="#430959" title="scalaz.UnapplyCo[TC,M0[A0,B0,C0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.UnapplyCo[TC,M0[A0,B0,C0]]" id="430959">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0, C0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[+X]M0[A0,B0,X]" id="430961">M</a><span class="delimiter">[</span>+<a title="" id="430962">X</a><span class="delimiter">]</span> = <a href="#153965" title="M0[A0,B0,X]">M0</a><span class="delimiter">[</span>A0, B0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="C0" id="430963">A</a> = <a href="#153968" title="C0">C0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[A0,B0,α]]" id="430964">TC</a> = <a href="#430933" title="TC[[α]M0[A0,B0,α]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="430965">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait UnapplyCo_0 extends AnyRef with scalaz.UnapplyCo_1" id="9524">UnapplyCo_0</a> <span title="Unit" class="keyword">extends</span> <a href="#18740" title="scalaz.UnapplyCo_1">UnapplyCo_1</a> <span class="delimiter">{</span>
  /**Unpack a value of type `M0[A0, B0]` into types `[a]M0[a, B0]` and `A`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[+_, _], A0, B0](implicit TC0: TC[[α]M0[α,B0]])scalaz.UnapplyCo[TC,M0[A0,B0]]{type M[+X] = M0[X,B0]; type A = A0}" id="153970">unapplyMAB1</a><span class="delimiter">[</span><a title="[_[_]]" id="153975">TC</a><span class="delimiter">[</span><a title="[_]" id="430988">_</a><span class="delimiter">[</span><a title="" id="430989">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[+_, _]" id="153976">M0</a><span class="delimiter">[</span>+<a title="" id="430990">_</a>, <a title="" id="430991">_</a><span class="delimiter">]</span>, <a title="" id="153977">A0</a>, <a title="" id="153978">B0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[α,B0]]" id="430987">TC0</a>: <a href="#153975" title="TC[[α]M0[α,B0]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>α, B0<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#430992" title="UnapplyCo_0 extends scalaz.UnapplyCo[TC,M0[A0,B0]]">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>+X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>X, B0<span class="delimiter">]</span>
    <span class="keyword">type</span> A = A0
  <span class="delimiter">}</span> = <a href="#431012" title="scalaz.UnapplyCo[TC,M0[A0,B0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.UnapplyCo[TC,M0[A0,B0]]" id="431012">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[+X]M0[X,B0]" id="431014">M</a><span class="delimiter">[</span>+<a title="" id="431015">X</a><span class="delimiter">]</span> = <a href="#153976" title="M0[X,B0]">M0</a><span class="delimiter">[</span>X, B0<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="A0" id="431016">A</a> = <a href="#153977" title="A0">A0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[α,B0]]" id="431017">TC</a> = <a href="#430987" title="TC[[α]M0[α,B0]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="431018">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  /**Unpack a value of type `M0[A0, B0]` into types `[b]M0[A0, b]` and `B`, given an instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[_, +_], A0, B0](implicit TC0: TC[[α]M0[A0,α]])scalaz.UnapplyCo[TC,M0[A0,B0]]{type M[+X] = M0[A0,X]; type A = B0}" id="153979">unapplyMAB2</a><span class="delimiter">[</span><a title="[_[_]]" id="153984">TC</a><span class="delimiter">[</span><a title="[_]" id="431039">_</a><span class="delimiter">[</span><a title="" id="431040">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[_, +_]" id="153985">M0</a><span class="delimiter">[</span><a title="" id="431041">_</a>, +<a title="" id="431042">_</a><span class="delimiter">]</span>, <a title="" id="153986">A0</a>, <a title="" id="153987">B0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[[α]M0[A0,α]]" id="431038">TC0</a>: <a href="#153984" title="TC[[α]M0[A0,α]]">TC</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#431043" title="UnapplyCo_0 extends scalaz.UnapplyCo[TC,M0[A0,B0]]">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>+X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>A0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = B0
  <span class="delimiter">}</span> = <a href="#431063" title="scalaz.UnapplyCo[TC,M0[A0,B0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.UnapplyCo[TC,M0[A0,B0]]" id="431063">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0, B0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[+X]M0[A0,X]" id="431065">M</a><span class="delimiter">[</span>+<a title="" id="431066">X</a><span class="delimiter">]</span> = <a href="#153985" title="M0[A0,X]">M0</a><span class="delimiter">[</span>A0, X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="B0" id="431067">A</a> = <a href="#153987" title="B0">B0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[[α]M0[A0,α]]" id="431068">TC</a> = <a href="#431038" title="TC[[α]M0[A0,α]]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="431069">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="scalaz.UnapplyCo.type" id="14784">UnapplyCo</a> <a href="#14785" title="scalaz.UnapplyCo.type" class="keyword">extends</a> <a href="#9524" title="scalaz.UnapplyCo_0">UnapplyCo_0</a> <span class="delimiter">{</span>
  /** Unpack a value of type `M0[A0]` into types `M0` and `A0`, given a instance of `TC` */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[TC[_[_]], M0[+_], A0](implicit TC0: TC[M0])scalaz.UnapplyCo[TC,M0[A0]]{type M[+X] = M0[X]; type A = A0}" id="153989">unapplyMA</a><span class="delimiter">[</span><a title="[_[_]]" id="153993">TC</a><span class="delimiter">[</span><a title="[_]" id="431091">_</a><span class="delimiter">[</span><a title="" id="431092">_</a><span class="delimiter">]</span><span class="delimiter">]</span>, <a title="[+_]" id="153994">M0</a><span class="delimiter">[</span>+<a title="" id="431093">_</a><span class="delimiter">]</span>, <a title="" id="153995">A0</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="TC[M0]" id="431090">TC0</a>: <a href="#153993" title="TC[M0]">TC</a><span class="delimiter">[</span>M0<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#431094" title="UnapplyCo extends scalaz.UnapplyCo[TC,M0[A0]]">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> M<span class="delimiter">[</span>+X<span class="delimiter">]</span> = M0<span class="delimiter">[</span>X<span class="delimiter">]</span>
    <span class="keyword">type</span> A = A0
  <span class="delimiter">}</span> = <a href="#431107" title="scalaz.UnapplyCo[TC,M0[A0]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.UnapplyCo[TC,M0[A0]]" id="431107">UnapplyCo</a><span class="delimiter">[</span>TC, M0<span class="delimiter">[</span>A0<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="[+X]M0[X]" id="431109">M</a><span class="delimiter">[</span>+<a title="" id="431110">X</a><span class="delimiter">]</span> = <a href="#153994" title="M0[X]">M0</a><span class="delimiter">[</span>X<span class="delimiter">]</span>
    <span class="keyword">type</span> <a title="A0" id="431111">A</a> = <a href="#153995" title="A0">A0</a>
    <span class="keyword">def</span> <a title="=&gt; TC[M0]" id="431112">TC</a> = <a href="#431090" title="TC[M0]">TC0</a>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]" id="431113">leibniz</a> = <a href="Leibniz.scala.html#384631" title="scalaz.Leibniz[this.M[this.A],this.M[this.A],this.M[this.A],this.M[this.A]]">refl</a>
  <span class="delimiter">}</span>

  // TODO More!
<span class="delimiter">}</span>


        </pre>
    </body>
</html>