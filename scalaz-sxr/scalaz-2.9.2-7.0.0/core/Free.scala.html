<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/Free.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz

<span class="keyword">import</span> annotation.tailrec
<span class="keyword">import</span> <a href="#10908" title="scalaz.Free.type">Free</a>._
<span class="keyword">import</span> std.<a href="std/Function.scala.html#24791" title="scalaz.std.function.type">function</a>._
<span class="keyword">import</span> std.<a href="std/Tuple.scala.html#24098" title="scalaz.std.tuple.type">tuple</a>._

// TODO report compiler bug when this appears just above FreeInstances:
//      &quot;java.lang.Error: typeConstructor inapplicable for &lt;none&gt;&quot;
<span class="keyword">object</span> <a title="scalaz.Free.type" id="10908">Free</a> <a href="#10909" title="scalaz.Free.type" class="keyword">extends</a> <a href="#12776" title="scalaz.FreeFunctions">FreeFunctions</a> <span class="keyword">with</span> <a href="#17378" title="scalaz.FreeInstances">FreeInstances</a> <span class="delimiter">{</span>

  /** Return from the computation with the given value. */
  <span class="keyword">case class</span> <a href="#282591" title="class Return[S[+_], +A] extends scalaz.Free[S,A] with Product with Serializable" id="283421">Return</a><span class="delimiter">[</span><a title="[+_]" id="283390">S</a><span class="delimiter">[</span>+<a title="" id="283406">_</a><span class="delimiter">]</span>: Functor, +<a title="" id="283391">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="283395">a</a>: <a href="#283391" title="A">A</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#10907" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span>

  /** Suspend the computation with the given suspension. */
  <span class="keyword">case class</span> <a href="#282956" title="class Suspend[S[+_], +A] extends scalaz.Free[S,A] with Product with Serializable" id="283463">Suspend</a><span class="delimiter">[</span><a title="[+_]" id="283432">S</a><span class="delimiter">[</span>+<a title="" id="283448">_</a><span class="delimiter">]</span>: Functor, +<a title="" id="283433">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="283437">a</a>: <a href="#283432" title="S[scalaz.Free[S,A]]">S</a><span class="delimiter">[</span>Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#10907" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span>

  /** Call a subroutine and continue with the given function. */
  <span class="keyword">case class</span> <a href="#283344" title="class Gosub[S[+_], A, +B] extends scalaz.Free[S,B] with Product with Serializable" id="283518">Gosub</a><span class="delimiter">[</span><a title="[+_]" id="283477">S</a><span class="delimiter">[</span>+<a title="" id="283497">_</a><span class="delimiter">]</span>: Functor, <a title="" id="283478">A</a>, +<a title="" id="283479">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="() =&gt; scalaz.Free[S,A]" id="283483">a</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span>,
                                          <a title="A =&gt; scalaz.Free[S,B]" id="283484">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#10907" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span>

  /** A computation that can be stepped through, suspended, and paused */
  <span class="keyword">type</span> <a title="[+A]scalaz.Free[Function0,A]" id="44507">Trampoline</a><span class="delimiter">[</span>+<a title="" id="44508">A</a><span class="delimiter">]</span> = <a href="#10907" title="scalaz.Free[Function0,A]">Free</a><span class="delimiter">[</span>Function0, A<span class="delimiter">]</span>

  /** A computation that produces values of type `A`, eventually resulting in a value of type `B`. */
  <span class="keyword">type</span> <a title="[A, +B]scalaz.Free[[+x](A, x),B]" id="44509">Source</a><span class="delimiter">[</span><a title="" id="44510">A</a>, +<a title="" id="44511">B</a><span class="delimiter">]</span> = <a href="#10907" title="scalaz.Free[[+x](A, x),B]">Free</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>A, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#f, B<span class="delimiter">]</span>

  /** A computation that accepts values of type `A`, eventually resulting in a value of type `B`.
    * Note the similarity to an [[scalaz.iteratee.Iteratee]].
    */
  <span class="keyword">type</span> <a title="[A, +B]scalaz.Free[[+x](=&gt; A) =&gt; x,B]" id="44512">Sink</a><span class="delimiter">[</span><a title="" id="44513">A</a>, +<a title="" id="44514">B</a><span class="delimiter">]</span> = <a href="#10907" title="scalaz.Free[[+x](=&gt; A) =&gt; x,B]">Free</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; A<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#f, B<span class="delimiter">]</span>
<span class="delimiter">}</span>

/** A free operational monad for some functor `S`. Binding is done using the heap instead of the stack,
  * allowing tail-call elimination. */
<span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Free[S[+_], +A] extends AnyRef" id="10907">Free</a><span class="delimiter">[</span><a title="[+_]" id="23151">S</a><span class="delimiter">[</span>+<a title="" id="283519">_</a><span class="delimiter">]</span>, +<a title="" id="23152">A</a><span class="delimiter">]</span><a href="#10907" title="scalaz.Free[S,A]" class="delimiter">(</a><span class="keyword">implicit</span> <a title="scalaz.Functor[S]" id="282242">S</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[S]">Functor</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B](f: A =&gt; B)scalaz.Free[S,B]" id="48225">map</a><span class="delimiter">[</span><a title="" id="48227">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="48322">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#10907" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> =
    <a href="#48231" title="(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]">flatMap</a><span class="delimiter">(</span><a title="A" id="283527">a</a> =&gt; <a href="#283421" title="(a: B)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,B]">Return</a><a href="#282242" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#48322" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#283527" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** Alias for `flatMap` */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B](f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]" id="48228">&gt;&gt;=</a><span class="delimiter">[</span><a title="" id="48230">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free[S,B]" id="151368">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#10907" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> = <a href="#10907" title="Free.this.type" class="keyword">this</a> <a href="#48231" title="(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]">flatMap</a> <a href="#151368" title="A =&gt; scalaz.Free[S,B]">f</a>

  /** Binds the given continuation to the result of this computation.
    * All left-associated binds are reassociated to the right. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B](f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]" id="48231">flatMap</a><span class="delimiter">[</span><a title="" id="48233">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free[S,B]" id="283522">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#10907" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> = <a href="#10907" title="scalaz.Free[S,A]" class="keyword">this</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> Gosub<a href="#1677398" title="scalaz.Free[S,B]" class="delimiter">(</a><a href="#283483" title="() =&gt; scalaz.Free[S,Any]" id="283859">a</a>, <a href="#283484" title="Any =&gt; scalaz.Free[S,A]" id="283860">g</a><span class="delimiter">)</span> =&gt; <a href="#283518" title="(a: () =&gt; scalaz.Free[S,Any], f: Any =&gt; scalaz.Free[S,B])(implicit evidence$3: scalaz.Functor[S])scalaz.Free.Gosub[S,Any,B]">Gosub</a><a href="#1677401" title="(x: scalaz.Free[S,B])scalaz.Free[S,B]" class="delimiter">(</a><a href="#283859" title="() =&gt; scalaz.Free[S,Any]">a</a>, <span class="delimiter">(</span>x: <span title="Any">Any</span><span class="delimiter">)</span> =&gt; <a href="#283518" title="(a: () =&gt; scalaz.Free[S,A], f: A =&gt; scalaz.Free[S,B])(implicit evidence$3: scalaz.Functor[S])scalaz.Free.Gosub[S,A,B]">Gosub</a><a href="#282242" title="scalaz.Functor[S]" class="delimiter">(</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#283860" title="(v1: Any)scalaz.Free[S,A]">g</a><span class="delimiter">(</span><a href="#283872" title="Any">x</a><span class="delimiter">)</span>, <a href="#283522" title="A =&gt; scalaz.Free[S,B]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> a           =&gt; <a href="#283518" title="(a: () =&gt; scalaz.Free[S,A], f: A =&gt; scalaz.Free[S,B])(implicit evidence$3: scalaz.Functor[S])scalaz.Free.Gosub[S,A,B]">Gosub</a><a href="#1677401" title="(x: scalaz.Free[S,B])scalaz.Free[S,B]" class="delimiter">(</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#1677398" title="scalaz.Free[S,A]">a</a>, <a href="#283522" title="A =&gt; scalaz.Free[S,B]">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Evaluates a single layer of the free monad. */
  @tailrec <span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]" id="48234">resume</a>: <span class="delimiter">(</span>S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">]</span> <a href="Either.scala.html#18614" title="scalaz.\/[S[scalaz.Free[S,A]],A]">\/</a> A<span class="delimiter">)</span> = <a href="#10907" title="scalaz.Free[S,A]" class="keyword">this</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> Return<a href="#1677417" title="scalaz.\/[S[scalaz.Free[S,A]],A]" class="delimiter">(</a><a href="#283395" title="A" id="284856">a</a><span class="delimiter">)</span>  =&gt; <a href="Either.scala.html#18615" title="scalaz.\/.type">\/</a>.<a href="Either.scala.html#72383" title="(v1: A)scalaz.\/[Nothing,A]">right</a><a href="#1677422" title="(x: scalaz.\/[S[scalaz.Free[S,A]],A])scalaz.\/[S[scalaz.Free[S,A]],A]" class="delimiter">(</a><a href="#284856" title="A">a</a><span class="delimiter">)</span>
    <span class="keyword">case</span> Suspend<a href="#1677417" title="scalaz.\/[S[scalaz.Free[S,A]],A]" class="delimiter">(</a><a href="#283437" title="S[scalaz.Free[S,A]]" id="284865">t</a><span class="delimiter">)</span> =&gt; <a href="Either.scala.html#18615" title="scalaz.\/.type">\/</a>.<a href="Either.scala.html#72378" title="(v1: S[scalaz.Free[S,A]])scalaz.\/[S[scalaz.Free[S,A]],Nothing]">left</a><a href="#1677422" title="(x: scalaz.\/[S[scalaz.Free[S,A]],A])scalaz.\/[S[scalaz.Free[S,A]],A]" class="delimiter">(</a><a href="#284865" title="S[scalaz.Free[S,A]]">t</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a href="#283483" title="() =&gt; scalaz.Free[S,Any]" id="284875">a</a> <a href="#1677417" title="scalaz.\/[S[scalaz.Free[S,A]],A]">Gosub</a> <a href="#283484" title="Any =&gt; scalaz.Free[S,A]" id="284876">f</a>  =&gt; <a href="#284875" title="()scalaz.Free[S,Any]">a</a><a href="#1677422" title="(x: scalaz.\/[S[scalaz.Free[S,A]],A])scalaz.\/[S[scalaz.Free[S,A]],A]" class="delimiter">(</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Return<a href="#1677406" title="scalaz.\/[S[scalaz.Free[S,A]],A]" class="delimiter">(</a><a href="#283395" title="Any" id="284881">a</a><span class="delimiter">)</span>  =&gt; <a href="#284876" title="(v1: Any)scalaz.Free[S,A]">f</a><span class="delimiter">(</span><a href="#284881" title="Any">a</a><span class="delimiter">)</span>.<a href="#1677411" title="(x: scalaz.\/[S[scalaz.Free[S,A]],A])scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a>
      <span class="keyword">case</span> Suspend<a href="#1677406" title="scalaz.\/[S[scalaz.Free[S,A]],A]" class="delimiter">(</a><a href="#283437" title="S[scalaz.Free[S,Any]]" id="284887">t</a><span class="delimiter">)</span> =&gt; <a href="Either.scala.html#18615" title="scalaz.\/.type">\/</a>.<a href="Either.scala.html#72378" title="(v1: S[scalaz.Free[S,A]])scalaz.\/[S[scalaz.Free[S,A]],Nothing]">left</a><a href="#1677411" title="(x: scalaz.\/[S[scalaz.Free[S,A]],A])scalaz.\/[S[scalaz.Free[S,A]],A]" class="delimiter">(</a><a href="#282242" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#33415" title="(fa: S[scalaz.Free[S,Any]])(f: scalaz.Free[S,Any] =&gt; scalaz.Free[S,A])S[scalaz.Free[S,A]]">map</a><span class="delimiter">(</span><a href="#284887" title="S[scalaz.Free[S,Any]]">t</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#284901" title="scalaz.Free[S,Any]">_</a>: <a href="#10907" title="scalaz.Free[S,Any]">Free</a><span class="delimiter">[</span>S, Any<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#48231" title="(f: Any =&gt; scalaz.Free[S,A])scalaz.Free[S,A]">flatMap</a> <a href="#284876" title="Any =&gt; scalaz.Free[S,A]">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#283483" title="() =&gt; scalaz.Free[S,Any]" id="284914">b</a> <a href="#1677406" title="scalaz.\/[S[scalaz.Free[S,A]],A]">Gosub</a> <a href="#283484" title="Any =&gt; scalaz.Free[S,Any]" id="284915">g</a>  =&gt; <a href="#284914" title="()scalaz.Free[S,Any]">b</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#48231" title="(f: Any =&gt; scalaz.Free[S,A])scalaz.Free[S,A]">flatMap</a><span class="delimiter">(</span><span class="delimiter">(</span>x: <span title="Any">Any</span><span class="delimiter">)</span> =&gt; <a href="#284915" title="(v1: Any)scalaz.Free[S,Any]">g</a><span class="delimiter">(</span><a href="#284919" title="Any">x</a><span class="delimiter">)</span> <a href="#48231" title="(f: Any =&gt; scalaz.Free[S,A])scalaz.Free[S,A]">flatMap</a> <a href="#284876" title="Any =&gt; scalaz.Free[S,A]">f</a><span class="delimiter">)</span>.<a href="#1677411" title="(x: scalaz.\/[S[scalaz.Free[S,A]],A])scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Changes the suspension functor by the given natural transformation. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[T[+_]](f: scalaz.~&gt;[S,T])(implicit evidence$4: scalaz.Functor[T])scalaz.Free[T,A]" id="284926">mapSuspension</a><span class="delimiter">[</span><a title="[+_]" id="48237">T</a><span class="delimiter">[</span>+<a title="" id="284927">_</a><span class="delimiter">]</span>:Functor<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.~&gt;[S,T]" id="284925">f</a>: S <a href="NaturalTransformation.scala.html#19940" title="scalaz.~&gt;[S,T]">~&gt;</a> T<span class="delimiter">)</span>: <a href="#10907" title="scalaz.Free[T,A]">Free</a><span class="delimiter">[</span>T, A<span class="delimiter">]</span> =
    <a href="#48234" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> -\/<a href="#1677428" title="scalaz.Free[T,A]" class="delimiter">(</a><a href="Either.scala.html#50471" title="S[scalaz.Free[S,A]]" id="284931">s</a><span class="delimiter">)</span>  =&gt; <a href="#283463" title="(a: T[scalaz.Free[T,A]])(implicit evidence$2: scalaz.Functor[T])scalaz.Free.Suspend[T,A]">Suspend</a><a href="#1677432" title="(x: scalaz.Free[T,A])scalaz.Free[T,A]" class="delimiter">(</a><a href="NaturalTransformation.scala.html#144451" title="(fa: S[scalaz.Free[T,A]])T[scalaz.Free[T,A]]">f</a><span class="delimiter">(</span><a href="#282242" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#33415" title="(fa: S[scalaz.Free[S,A]])(f: scalaz.Free[S,A] =&gt; scalaz.Free[T,A])S[scalaz.Free[T,A]]">map</a><span class="delimiter">(</span><a href="#284931" title="S[scalaz.Free[S,A]]">s</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#284952" title="scalaz.Free[S,A]">_</a>: <a href="#10907" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#284926" title="(f: scalaz.~&gt;[S,T])(implicit evidence$4: scalaz.Functor[T])scalaz.Free[T,A]">mapSuspension</a> <a href="#284925" title="scalaz.~&gt;[S,T]">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> \/-<a href="#1677428" title="scalaz.Free[T,A]" class="delimiter">(</a><a href="Either.scala.html#50507" title="A" id="285595">r</a><span class="delimiter">)</span> =&gt; <a href="#283421" title="(a: A)(implicit evidence$1: scalaz.Functor[T])scalaz.Free.Return[T,A]">Return</a><a href="#1677432" title="(x: scalaz.Free[T,A])scalaz.Free[T,A]" class="delimiter">(</a><a href="#285595" title="A">r</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  /** Modifies the first suspension with the given natural transformation. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(f: scalaz.~&gt;[S,S])scalaz.Free[S,A]" id="48238">mapFirstSuspension</a><span class="delimiter">(</span><a title="scalaz.~&gt;[S,S]" id="285918">f</a>: S <a href="NaturalTransformation.scala.html#19940" title="scalaz.~&gt;[S,S]">~&gt;</a> S<span class="delimiter">)</span>: <a href="#10907" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> = <a href="#48234" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> -\/<a href="#1677437" title="scalaz.Free[S,A]" class="delimiter">(</a><a href="Either.scala.html#50471" title="S[scalaz.Free[S,A]]" id="285920">s</a><span class="delimiter">)</span> =&gt; <a href="#283463" title="(a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><a href="#1677441" title="(x: scalaz.Free[S,A])scalaz.Free[S,A]" class="delimiter">(</a><a href="NaturalTransformation.scala.html#144451" title="(fa: S[scalaz.Free[S,A]])S[scalaz.Free[S,A]]">f</a><span class="delimiter">(</span><a href="#285920" title="S[scalaz.Free[S,A]]">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> \/-<a href="#1677437" title="scalaz.Free[S,A]" class="delimiter">(</a><a href="Either.scala.html#50507" title="A" id="286249">r</a><span class="delimiter">)</span> =&gt; <a href="#283421" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><a href="#1677441" title="(x: scalaz.Free[S,A])scalaz.Free[S,A]" class="delimiter">(</a><a href="#286249" title="A">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Applies a function `f` to a value in this monad and a corresponding value in the dual comonad, annihilating both. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[G[+_], B, C](bs: scalaz.Cofree[G,B])(f: (A, B) =&gt; C)(implicit G: scalaz.Functor[G], implicit d: scalaz.Zap[S,G])C" id="48239">zapWith</a><span class="delimiter">[</span><a title="[+_]" id="48243">G</a><span class="delimiter">[</span>+<a title="" id="286575">_</a><span class="delimiter">]</span>, <a title="" id="48244">B</a>, <a title="" id="48245">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Cofree[G,B]" id="286571">bs</a>: <a href="Cofree.scala.html#8798" title="scalaz.Cofree[G,B]">Cofree</a><span class="delimiter">[</span>G, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="286572">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[G]" id="286573">G</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[G]">Functor</a><span class="delimiter">[</span>G<span class="delimiter">]</span>, <a title="scalaz.Zap[S,G]" id="286574">d</a>: <a href="Zap.scala.html#13949" title="scalaz.Zap[S,G]">Zap</a><span class="delimiter">[</span>S, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#48245" title="C">C</a> =
    <a href="Zap.scala.html#13950" title="scalaz.Zap.type">Zap</a>.<a href="Zap.scala.html#144629" title="(implicit d: scalaz.Zap[S,G], implicit F: scalaz.Functor[S], implicit G: scalaz.Functor[G])scalaz.Zap[[α]scalaz.Free[S,α],[α]scalaz.Cofree[G,α]]">monadComonadZap</a>.<a href="Zap.scala.html#75359" title="(fa: scalaz.Free[S,A], gb: scalaz.Cofree[G,B])(f: (A, B) =&gt; C)C">zapWith</a><span class="delimiter">(</span><a href="#10907" title="scalaz.Free[S,A]" class="keyword">this</a>, <a href="#286571" title="scalaz.Cofree[G,B]">bs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#286572" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span>

  /** Applies a function in a comonad to the corresponding value in this monad, annihilating both. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[G[+_], B](fs: scalaz.Cofree[G,A =&gt; B])(implicit G: scalaz.Functor[G], implicit d: scalaz.Zap[S,G])B" id="48246">zap</a><span class="delimiter">[</span><a title="[+_]" id="48249">G</a><span class="delimiter">[</span>+<a title="" id="287489">_</a><span class="delimiter">]</span>, <a title="" id="48250">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Cofree[G,A =&gt; B]" id="287486">fs</a>: <a href="Cofree.scala.html#8798" title="scalaz.Cofree[G,A =&gt; B]">Cofree</a><span class="delimiter">[</span>G, A =&gt; B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[G]" id="287487">G</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[G]">Functor</a><span class="delimiter">[</span>G<span class="delimiter">]</span>, <a title="scalaz.Zap[S,G]" id="287488">d</a>: <a href="Zap.scala.html#13949" title="scalaz.Zap[S,G]">Zap</a><span class="delimiter">[</span>S, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#48250" title="B">B</a> =
    <a href="#48239" title="(bs: scalaz.Cofree[G,A =&gt; B])(f: (A, A =&gt; B) =&gt; B)(implicit G: scalaz.Functor[G], implicit d: scalaz.Zap[S,G])B">zapWith</a><span class="delimiter">(</span><a href="#287486" title="scalaz.Cofree[G,A =&gt; B]">fs</a><span class="delimiter">)</span><a href="#287487" title="scalaz.Functor[G]" class="delimiter">(</a><span class="delimiter">(</span><a title="A" id="287514">a</a>, <a title="A =&gt; B" id="287515">f</a><span class="delimiter">)</span> =&gt; <a href="#287515" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#287514" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>

  /** Runs a single step, using a function that extracts the resumption from its suspension functor. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[AA &gt;: A](f: S[scalaz.Free[S,A]] =&gt; scalaz.Free[S,AA])scalaz.Free[S,AA]" id="48251">bounce</a><span class="delimiter">[</span><a title=" &gt;: A" id="48253">AA</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]] =&gt; scalaz.Free[S,AA]" id="288066">f</a>: S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">]</span> =&gt; Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#10907" title="scalaz.Free[S,AA]">Free</a><span class="delimiter">[</span>S, AA<span class="delimiter">]</span> = <a href="#48234" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a> <span class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> -\/<a href="#1677446" title="scalaz.Free[S,AA]" class="delimiter">(</a><a href="Either.scala.html#50471" title="S[scalaz.Free[S,A]]" id="288069">s</a><span class="delimiter">)</span> =&gt; <a href="#288066" title="(v1: S[scalaz.Free[S,A]])scalaz.Free[S,AA]">f</a><a href="#1677450" title="(x: scalaz.Free[S,AA])scalaz.Free[S,AA]" class="delimiter">(</a><a href="#288069" title="S[scalaz.Free[S,A]]">s</a><span class="delimiter">)</span>
    <span class="keyword">case</span> \/-<a href="#1677446" title="scalaz.Free[S,AA]" class="delimiter">(</a><a href="Either.scala.html#50507" title="A" id="288072">r</a><span class="delimiter">)</span> =&gt; <a href="#283421" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><a href="#1677450" title="(x: scalaz.Free[S,AA])scalaz.Free[S,AA]" class="delimiter">(</a><a href="#288072" title="A">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Runs to completion, using a function that extracts the resumption from its suspension functor. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[AA &gt;: A](f: S[scalaz.Free[S,AA]] =&gt; scalaz.Free[S,AA])AA" id="48254">go</a><span class="delimiter">[</span><a title=" &gt;: A" id="48256">AA</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,AA]] =&gt; scalaz.Free[S,AA]" id="288394">f</a>: S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">]</span> =&gt; Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#48256" title="AA">AA</a> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(t: scalaz.Free[S,AA])AA" id="288396">go2</a><span class="delimiter">(</span><a title="scalaz.Free[S,AA]" id="288397">t</a>: <a href="#10907" title="scalaz.Free[S,AA]">Free</a><span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#48256" title="AA">AA</a> = <a href="#288397" title="scalaz.Free[S,AA]">t</a>.<a href="#48234" title="=&gt; scalaz.\/[S[scalaz.Free[S,AA]],AA]">resume</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> -\/<a href="#1677455" title="AA" class="delimiter">(</a><a href="Either.scala.html#50471" title="S[scalaz.Free[S,AA]]" id="288402">s</a><span class="delimiter">)</span> =&gt; <a href="#288396" title="(t: scalaz.Free[S,AA])AA">go2</a><a href="#1677459" title="(x: AA)AA" class="delimiter">(</a><a href="#288394" title="(v1: S[scalaz.Free[S,AA]])scalaz.Free[S,AA]">f</a><span class="delimiter">(</span><a href="#288402" title="S[scalaz.Free[S,AA]]">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> \/-<a href="#1677455" title="AA" class="delimiter">(</a><a href="Either.scala.html#50507" title="AA" id="288407">r</a><span class="delimiter">)</span> =&gt; <a href="#1677459" title="(x: AA)AA">r</a>
    <span class="delimiter">}</span>
    <a href="#288396" title="(t: scalaz.Free[S,AA])AA">go2</a><span class="delimiter">(</span><a href="#10907" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Runs to completion, allowing the resumption function to thread an arbitrary state of type `B`. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B, AA &gt;: A](b: B)(f: (B, S[scalaz.Free[S,AA]]) =&gt; (B, scalaz.Free[S,AA]))(B, AA)" id="48257">foldRun</a><span class="delimiter">[</span><a title="" id="48260">B</a>, <a title=" &gt;: A" id="48261">AA</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="288408">b</a>: <a href="#48260" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, S[scalaz.Free[S,AA]]) =&gt; (B, scalaz.Free[S,AA])" id="288409">f</a>: <span class="delimiter">(</span>B, S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>B, Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(B, AA)" class="delimiter">(</span>B, AA<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(t: scalaz.Free[S,AA], z: B)(B, AA)" id="288412">foldRun2</a><span class="delimiter">(</span><a title="scalaz.Free[S,AA]" id="288413">t</a>: <a href="#10907" title="scalaz.Free[S,AA]">Free</a><span class="delimiter">[</span>S, AA<span class="delimiter">]</span>, <a title="B" id="288414">z</a>: <a href="#48260" title="B">B</a><span class="delimiter">)</span>: <span title="(B, AA)" class="delimiter">(</span>B, AA<span class="delimiter">)</span> = <a href="#288413" title="scalaz.Free[S,AA]">t</a>.<a href="#48234" title="=&gt; scalaz.\/[S[scalaz.Free[S,AA]],AA]">resume</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> -\/<a href="#1677470" title="(B, AA)" class="delimiter">(</a><a href="Either.scala.html#50471" title="S[scalaz.Free[S,AA]]" id="288419">s</a><span class="delimiter">)</span> =&gt; <a href="#1677474" title="(x: (B, AA))(B, AA)" class="delimiter">{</a>
        <span class="keyword">val</span> <a href="#1677466" title="(x: (B, scalaz.Free[S,AA]))(B, scalaz.Free[S,AA])" class="delimiter">(</a><a href="#1677464" title="B" id="288421">b1</a>, <a href="#1677464" title="scalaz.Free[S,AA]" id="288422">s1</a><span class="delimiter">)</span> = <a href="#288409" title="(v1: B, v2: S[scalaz.Free[S,AA]])(B, scalaz.Free[S,AA])">f</a><a href="#1677464" title="(B, scalaz.Free[S,AA]) @unchecked" class="delimiter">(</a><a href="#288414" title="B">z</a>, <a href="#288419" title="S[scalaz.Free[S,AA]]">s</a><span class="delimiter">)</span>
        <a href="#288412" title="(t: scalaz.Free[S,AA], z: B)(B, AA)">foldRun2</a><span class="delimiter">(</span><a href="#288422" title="scalaz.Free[S,AA]">s1</a>, <a href="#288421" title="B">b1</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">case</span> \/-<a href="#1677470" title="(B, AA)" class="delimiter">(</a><a href="Either.scala.html#50507" title="AA" id="288441">r</a><span class="delimiter">)</span> =&gt; <a href="#1677474" title="(x: (B, AA))(B, AA)" class="delimiter">(</a><a href="#288414" title="B">z</a>, <a href="#288441" title="AA">r</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#288412" title="(t: scalaz.Free[S,AA], z: B)(B, AA)">foldRun2</a><span class="delimiter">(</span><a href="#10907" title="scalaz.Free[S,A]" class="keyword">this</a>, <a href="#288408" title="B">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">import</span> <a href="Liskov.scala.html#15738" title="scalaz.Liskov.type">Liskov</a>._

  /** Runs a trampoline all the way to the end, tail-recursively. */
  <span class="keyword">def</span> <a title="[B &gt;: A](implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,B],scalaz.Free.Trampoline[B]])B" id="48263">run</a><span class="delimiter">[</span><a title=" &gt;: A" id="48265">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,B],scalaz.Free.Trampoline[B]]" id="57759">ev</a>: Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span> <a href="Liskov.scala.html#15737" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,B],scalaz.Free.Trampoline[B]]">&lt;~&lt;</a> Trampoline<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#48265" title="B">B</a> =
    <a href="Liskov.scala.html#58128" title="(a: scalaz.Free[S,B])scalaz.Free.Trampoline[B]">ev</a><span class="delimiter">(</span><a href="#10907" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>.<a href="#48254" title="(f: (() =&gt; scalaz.Free[Function0,B]) =&gt; scalaz.Free[Function0,B])B">go</a><span class="delimiter">(</span><a href="#288458" title="()scalaz.Free[Function0,B]">_</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** Interleave this computation with another, combining the results with the given function. */
  <span class="keyword">def</span> <a title="[B, C](tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]" id="48266">zipWith</a><span class="delimiter">[</span><a title="" id="48269">B</a>, <a title="" id="48270">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[S,B]" id="288459">tb</a>: <a href="#10907" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span>, <a title="(A, B) =&gt; C" id="288460">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#10907" title="scalaz.Free[S,C]">Free</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#1677479" title="(_1: scalaz.\/[S[scalaz.Free[S,A]],A], _2: scalaz.\/[S[scalaz.Free[S,B]],B])(scalaz.\/[S[scalaz.Free[S,A]],A], scalaz.\/[S[scalaz.Free[S,B]],B])" class="delimiter">(</a><a href="#48234" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a>, <a href="#288459" title="scalaz.Free[S,B]">tb</a>.<a href="#48234" title="=&gt; scalaz.\/[S[scalaz.Free[S,B]],B]">resume</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>-\/<a href="#1677479" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]" class="delimiter">(</a><a href="Either.scala.html#50471" title="S[scalaz.Free[S,A]]" id="288474">a</a><span class="delimiter">)</span>, -\/<a href="#1677479" title="=&gt; scalaz.\/[S[scalaz.Free[S,B]],B]" class="delimiter">(</a><a href="Either.scala.html#50471" title="S[scalaz.Free[S,B]]" id="288478">b</a><span class="delimiter">)</span><span class="delimiter">)</span>   =&gt; <a href="#283463" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#1677497" title="(x: scalaz.Free[S,C])scalaz.Free[S,C]" class="delimiter">(</a><a href="#282242" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#33415" title="(fa: S[scalaz.Free[S,A]])(f: scalaz.Free[S,A] =&gt; scalaz.Free.Suspend[S,C])S[scalaz.Free.Suspend[S,C]]">map</a><span class="delimiter">(</span><a href="#288474" title="S[scalaz.Free[S,A]]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="288496">x</a> =&gt; <a href="#283463" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#282242" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#282242" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#33415" title="(fa: S[scalaz.Free[S,B]])(f: scalaz.Free[S,B] =&gt; scalaz.Free[S,C])S[scalaz.Free[S,C]]">map</a><span class="delimiter">(</span><a href="#288478" title="S[scalaz.Free[S,B]]">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,B]" id="288514">y</a> =&gt; <a href="#288496" title="scalaz.Free[S,A]">x</a> <a href="#48266" title="(tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]">zipWith</a><span class="delimiter">(</span><a href="#288514" title="scalaz.Free[S,B]">y</a>, <a href="#288460" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>-\/<a href="#1677479" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]" class="delimiter">(</a><a href="Either.scala.html#50471" title="S[scalaz.Free[S,A]]" id="289160">a</a><span class="delimiter">)</span>, \/-<a href="#1677479" title="=&gt; scalaz.\/[S[scalaz.Free[S,B]],B]" class="delimiter">(</a><a href="Either.scala.html#50507" title="B" id="289164">b</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#283463" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#1677497" title="(x: scalaz.Free[S,C])scalaz.Free[S,C]" class="delimiter">(</a><a href="#282242" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#33415" title="(fa: S[scalaz.Free[S,A]])(f: scalaz.Free[S,A] =&gt; scalaz.Free[S,C])S[scalaz.Free[S,C]]">map</a><span class="delimiter">(</span><a href="#289160" title="S[scalaz.Free[S,A]]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="289182">x</a> =&gt; <a href="#289182" title="scalaz.Free[S,A]">x</a> <a href="#48266" title="(tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]">zipWith</a><span class="delimiter">(</span><a href="#283421" title="(a: B)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,B]">Return</a><a href="#282242" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#289164" title="B">b</a><span class="delimiter">)</span>, <a href="#288460" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>\/-<a href="#1677479" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]" class="delimiter">(</a><a href="Either.scala.html#50507" title="A" id="289832">a</a><span class="delimiter">)</span>, -\/<a href="#1677479" title="=&gt; scalaz.\/[S[scalaz.Free[S,B]],B]" class="delimiter">(</a><a href="Either.scala.html#50471" title="S[scalaz.Free[S,B]]" id="289836">b</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#283463" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#1677497" title="(x: scalaz.Free[S,C])scalaz.Free[S,C]" class="delimiter">(</a><a href="#282242" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#33415" title="(fa: S[scalaz.Free[S,B]])(f: scalaz.Free[S,B] =&gt; scalaz.Free[S,C])S[scalaz.Free[S,C]]">map</a><span class="delimiter">(</span><a href="#289836" title="S[scalaz.Free[S,B]]">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,B]" id="289854">y</a> =&gt; <a href="#283421" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span class="delimiter">(</span><a href="#289832" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#282242" title="scalaz.Functor[S]">S</a><span class="delimiter">)</span> <a href="#48266" title="(tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]">zipWith</a><span class="delimiter">(</span><a href="#289854" title="scalaz.Free[S,B]">y</a>, <a href="#288460" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>\/-<a href="#1677479" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]" class="delimiter">(</a><a href="Either.scala.html#50507" title="A" id="290195">a</a><span class="delimiter">)</span>, \/-<a href="#1677479" title="=&gt; scalaz.\/[S[scalaz.Free[S,B]],B]" class="delimiter">(</a><a href="Either.scala.html#50507" title="B" id="290199">b</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#283421" title="(a: C)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,C]">Return</a><a href="#1677497" title="(x: scalaz.Free[S,C])scalaz.Free[S,C]" class="delimiter">(</a><a href="#288460" title="(v1: A, v2: B)C">f</a><span class="delimiter">(</span><a href="#290195" title="A">a</a>, <a href="#290199" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Runs a `Source` all the way to the end, tail-recursively, collecting the produced values. */
  <span class="keyword">def</span> <a title="[B, C &gt;: A](implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[B,C]])(Vector[B], C)" id="48271">collect</a><span class="delimiter">[</span><a title="" id="48274">B</a>, <a title=" &gt;: A" id="48275">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[B,C]]" id="290523">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#15737" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[B,C]]">&lt;~&lt;</a> Source<span class="delimiter">[</span>B, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Vector[B], C)" class="delimiter">(</span>Vector<span class="delimiter">[</span>B<span class="delimiter">]</span>, C<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(c: scalaz.Free.Source[B,C], v: Vector[B])(Vector[B], C)" id="290525">go</a><span class="delimiter">(</span><a title="scalaz.Free.Source[B,C]" id="290526">c</a>: <a href="#10907" title="scalaz.Free.Source[B,C]">Source</a><span class="delimiter">[</span>B, C<span class="delimiter">]</span>, <a title="Vector[B]" id="290528">v</a>: <span title="Vector[B]">Vector</span><span class="delimiter">[</span>B<span class="delimiter">]</span> = <span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(Vector[B], C)" class="delimiter">(</span>Vector<span class="delimiter">[</span>B<span class="delimiter">]</span>, C<span class="delimiter">)</span> =
      <a href="#290526" title="scalaz.Free.Source[B,C]">c</a>.<a href="#48234" title="=&gt; scalaz.\/[(B, scalaz.Free[[+x](B, x),C]),C]">resume</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> -\/<a href="#1677504" title="(Vector[B], C)" class="delimiter">(</a><a href="Either.scala.html#50471" title="=&gt; (B, scalaz.Free[[+x](B, x),C])" class="delimiter">(</a><a href="#1677505" title="B" id="290541">b</a>, <a href="#1677505" title="scalaz.Free[[+x](B, x),C]" id="290542">cont</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#290525" title="(c: scalaz.Free.Source[B,C], v: Vector[B])(Vector[B], C)">go</a><a href="#1677509" title="(x: (Vector[B], C))(Vector[B], C)" class="delimiter">(</a><a href="#290542" title="scalaz.Free[[+x](B, x),C]">cont</a>, <a href="#290528" title="Vector[B]">v</a> <span title="(elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[B],B,Vector[B]])Vector[B]">:+</span> <a href="#290541" title="B">b</a><span class="delimiter">)</span>
        <span class="keyword">case</span> \/-<a href="#1677504" title="(Vector[B], C)" class="delimiter">(</a><a href="Either.scala.html#50507" title="C" id="290848">r</a><span class="delimiter">)</span>        =&gt; <a href="#1677509" title="(x: (Vector[B], C))(Vector[B], C)" class="delimiter">(</a><a href="#290528" title="Vector[B]">v</a>, <a href="#290848" title="C">r</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#290525" title="(c: scalaz.Free.Source[B,C], v: Vector[B])(Vector[B], C)">go</a><span class="delimiter">(</span><a href="Liskov.scala.html#58128" title="(a: scalaz.Free[S,C])scalaz.Free.Source[B,C]">ev</a><span class="delimiter">(</span><a href="#10907" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Drive this `Source` with the given Sink. */
  <span class="keyword">def</span> <a title="[E, B, C &gt;: A](sink: scalaz.Free.Sink[Option[E],B])(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[E,C]])(C, B)" id="48276">drive</a><span class="delimiter">[</span><a title="" id="48280">E</a>, <a title="" id="48281">B</a>, <a title=" &gt;: A" id="48282">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Sink[Option[E],B]" id="290859">sink</a>: <a href="#10907" title="scalaz.Free.Sink[Option[E],B]">Sink</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>E<span class="delimiter">]</span>, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[E,C]]" id="290860">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#15737" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[E,C]]">&lt;~&lt;</a> Source<span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)" id="290863">go</a><span class="delimiter">(</span><a title="scalaz.Free.Source[E,C]" id="290864">src</a>: <a href="#10907" title="scalaz.Free.Source[E,C]">Source</a><span class="delimiter">[</span>E, C<span class="delimiter">]</span>, <a title="scalaz.Free.Sink[Option[E],B]" id="290865">snk</a>: <a href="#10907" title="scalaz.Free.Sink[Option[E],B]">Sink</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>E<span class="delimiter">]</span>, B<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> =
      <a href="#1677514" title="(_1: scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C], _2: scalaz.\/[(=&gt; Option[E]) =&gt; scalaz.Free[[+x](=&gt; Option[E]) =&gt; x,B],B])(scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C], scalaz.\/[(=&gt; Option[E]) =&gt; scalaz.Free[[+x](=&gt; Option[E]) =&gt; x,B],B])" class="delimiter">(</a><a href="#290864" title="scalaz.Free.Source[E,C]">src</a>.<a href="#48234" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C]">resume</a>, <a href="#290865" title="scalaz.Free.Sink[Option[E],B]">snk</a>.<a href="#48234" title="=&gt; scalaz.\/[(=&gt; Option[E]) =&gt; scalaz.Free[[+x](=&gt; Option[E]) =&gt; x,B],B]">resume</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span class="delimiter">(</span>-\/<a href="#1677514" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C]" class="delimiter">(</a><a href="Either.scala.html#50471" title="=&gt; (E, scalaz.Free[[+x](E, x),C])" class="delimiter">(</a><a href="#1677517" title="E" id="290889">e</a>, <a href="#1677517" title="scalaz.Free[[+x](E, x),C]" id="290890">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, -\/<a href="#1677514" title="=&gt; scalaz.\/[(=&gt; Option[E]) =&gt; scalaz.Free[[+x](=&gt; Option[E]) =&gt; x,B],B]" class="delimiter">(</a><a href="Either.scala.html#50471" title="(=&gt; Option[E]) =&gt; scalaz.Free[[+x](=&gt; Option[E]) =&gt; x,B]" id="290895">f</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#290863" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><a href="#1677534" title="(x: (C, B))(C, B)" class="delimiter">(</a><a href="#290890" title="scalaz.Free[[+x](E, x),C]">c</a>, <a href="#290895" title="(v1: =&gt; Option[E])scalaz.Free[[+x](=&gt; Option[E]) =&gt; x,B]">f</a><span class="delimiter">(</span><span title="(x: E)Some[E]">Some</span><span class="delimiter">(</span><a href="#290889" title="E">e</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span class="delimiter">(</span>-\/<a href="#1677514" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C]" class="delimiter">(</a><a href="Either.scala.html#50471" title="=&gt; (E, scalaz.Free[[+x](E, x),C])" class="delimiter">(</a>e, <a href="#1677522" title="scalaz.Free[[+x](E, x),C]" id="290917">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, \/-<a href="#1677514" title="=&gt; scalaz.\/[(=&gt; Option[E]) =&gt; scalaz.Free[[+x](=&gt; Option[E]) =&gt; x,B],B]" class="delimiter">(</a><a href="Either.scala.html#50507" title="B" id="290922">y</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#290863" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><a href="#1677534" title="(x: (C, B))(C, B)" class="delimiter">(</a><a href="#290917" title="scalaz.Free[[+x](E, x),C]">c</a>, <a href="#15828" title="scalaz.Sink.type">Sink</a>.<a href="#44523" title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x](=&gt; S) =&gt; x,x]]">sinkMonad</a><span title="scalaz.Monad[[x]scalaz.Free[[+x](=&gt; Option[E]) =&gt; x,x]]" class="delimiter">[</span><span title="Option[E]">Option</span><span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">]</span>.<a href="Applicative.scala.html#34513" title="(a: =&gt; B)scalaz.Free[[+x](=&gt; Option[E]) =&gt; x,B]">pure</a><span class="delimiter">(</span><a href="#290922" title="B">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span class="delimiter">(</span>\/-<a href="#1677514" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C]" class="delimiter">(</a><a href="Either.scala.html#50507" title="C" id="290943">x</a><span class="delimiter">)</span>, -\/<a href="#1677514" title="=&gt; scalaz.\/[(=&gt; Option[E]) =&gt; scalaz.Free[[+x](=&gt; Option[E]) =&gt; x,B],B]" class="delimiter">(</a><a href="Either.scala.html#50471" title="(=&gt; Option[E]) =&gt; scalaz.Free[[+x](=&gt; Option[E]) =&gt; x,B]" id="290948">f</a><span class="delimiter">)</span><span class="delimiter">)</span>      =&gt; <a href="#290863" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><a href="#1677534" title="(x: (C, B))(C, B)" class="delimiter">(</a><a href="#22245" title="scalaz.Source.type">Source</a>.<a href="#44527" title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]">sourceMonad</a><span title="scalaz.Monad[[x]scalaz.Free[[+x](E, x),x]]" class="delimiter">[</span><a href="#48280" title="E">E</a><span class="delimiter">]</span>.<a href="Applicative.scala.html#34513" title="(a: =&gt; C)scalaz.Free[[+x](E, x),C]">pure</a><span class="delimiter">(</span><a href="#290943" title="C">x</a><span class="delimiter">)</span>, <a href="#290948" title="(v1: =&gt; Option[E])scalaz.Free[[+x](=&gt; Option[E]) =&gt; x,B]">f</a><span class="delimiter">(</span><span title="None.type">None</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span class="delimiter">(</span>\/-<a href="#1677514" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C]" class="delimiter">(</a><a href="Either.scala.html#50507" title="C" id="290970">x</a><span class="delimiter">)</span>, \/-<a href="#1677514" title="=&gt; scalaz.\/[(=&gt; Option[E]) =&gt; scalaz.Free[[+x](=&gt; Option[E]) =&gt; x,B],B]" class="delimiter">(</a><a href="Either.scala.html#50507" title="B" id="290975">y</a><span class="delimiter">)</span><span class="delimiter">)</span>     =&gt; <a href="#1677534" title="(x: (C, B))(C, B)" class="delimiter">(</a><a href="#290970" title="C">x</a>, <a href="#290975" title="B">y</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#290863" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><span class="delimiter">(</span><a href="Liskov.scala.html#58128" title="(a: scalaz.Free[S,C])scalaz.Free.Source[E,C]">ev</a><span class="delimiter">(</span><a href="#10907" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>, <a href="#290859" title="scalaz.Free.Sink[Option[E],B]">sink</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Feed the given stream to this `Source`. */
  <span class="keyword">def</span> <a title="[E, C &gt;: A](ss: Stream[E])(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]])C" id="48283">feed</a><span class="delimiter">[</span><a title="" id="48286">E</a>, <a title=" &gt;: A" id="48287">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="Stream[E]" id="290983">ss</a>: <span title="Stream[E]">Stream</span><span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]" id="290984">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#15737" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]">&lt;~&lt;</a> Sink<span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#48287" title="C">C</a> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C" id="290987">go</a><span class="delimiter">(</span><a title="scalaz.Free.Sink[E,C]" id="290988">snk</a>: <a href="#10907" title="scalaz.Free.Sink[E,C]">Sink</a><span class="delimiter">[</span>E, C<span class="delimiter">]</span>, <a title="Stream[E]" id="290989">rest</a>: <span title="Stream[E]">Stream</span><span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#48287" title="C">C</a> = <a href="#1677541" title="(_1: Stream[E], _2: scalaz.\/[(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C],C])(Stream[E], scalaz.\/[(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C],C])" class="delimiter">(</a><a href="#290989" title="Stream[E]">rest</a>, <a href="#290988" title="scalaz.Free.Sink[E,C]">snk</a>.<a href="#48234" title="=&gt; scalaz.\/[(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C],C]">resume</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span class="delimiter">(</span><a title="E" id="291028">x</a> <a href="#1677541" title="=&gt; Stream[E]">#::</a> <a title="scala.collection.immutable.Stream[E]" id="291029">xs</a>, -\/<a href="#1677541" title="=&gt; scalaz.\/[(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C],C]" class="delimiter">(</a><a href="Either.scala.html#50471" title="(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C]" id="291034">f</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#290987" title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C">go</a><a href="#1677556" title="(x: C)C" class="delimiter">(</a><a href="#291034" title="(v1: =&gt; E)scalaz.Free[[+x](=&gt; E) =&gt; x,C]">f</a><span class="delimiter">(</span><a href="#291028" title="E">x</a><span class="delimiter">)</span>, <a href="#291029" title="scala.collection.immutable.Stream[E]">xs</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1677546" title="(x: scala.collection.immutable.Stream[E])Some[scala.collection.immutable.Stream[E]]">Stream</a><a href="#1677541" title="=&gt; Stream[E]" class="delimiter">(</a><span class="delimiter">)</span>, -\/<a href="#1677541" title="=&gt; scalaz.\/[(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C],C]" class="delimiter">(</a><a href="Either.scala.html#50471" title="(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C]" id="291064">f</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#290987" title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C">go</a><a href="#1677556" title="(x: C)C" class="delimiter">(</a><a href="#291064" title="(v1: =&gt; E)scalaz.Free[[+x](=&gt; E) =&gt; x,C]">f</a><span class="delimiter">(</span>sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;No more values.&quot;)" class="string">&quot;No more values.&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="(xs: Nothing*)scala.collection.immutable.Stream[Nothing]">Stream</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>_, \/-<a href="#1677541" title="=&gt; scalaz.\/[(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C],C]" class="delimiter">(</a><a href="Either.scala.html#50507" title="C" id="291083">r</a><span class="delimiter">)</span><span class="delimiter">)</span>       =&gt; <a href="#1677556" title="(x: C)C">r</a>
    <span class="delimiter">}</span>
    <a href="#290987" title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C">go</a><span class="delimiter">(</span><a href="Liskov.scala.html#58128" title="(a: scalaz.Free[S,C])scalaz.Free.Sink[E,C]">ev</a><span class="delimiter">(</span><a href="#10907" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>, <a href="#290983" title="Stream[E]">ss</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Feed the given source to this `Sink`. */
  <span class="keyword">def</span> <a title="[E, B, C &gt;: A](source: scalaz.Free.Source[E,B])(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]])(C, B)" id="48288">drain</a><span class="delimiter">[</span><a title="" id="48292">E</a>, <a title="" id="48293">B</a>, <a title=" &gt;: A" id="48294">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Source[E,B]" id="291085">source</a>: <a href="#10907" title="scalaz.Free.Source[E,B]">Source</a><span class="delimiter">[</span>E, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]" id="291086">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#15737" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]">&lt;~&lt;</a> Sink<span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)" id="291089">go</a><span class="delimiter">(</span><a title="scalaz.Free.Source[E,B]" id="291090">src</a>: <a href="#10907" title="scalaz.Free.Source[E,B]">Source</a><span class="delimiter">[</span>E, B<span class="delimiter">]</span>, <a title="scalaz.Free.Sink[E,C]" id="291091">snk</a>: <a href="#10907" title="scalaz.Free.Sink[E,C]">Sink</a><span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> = <a href="#1677569" title="(_1: scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B], _2: scalaz.\/[(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C],C])(scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B], scalaz.\/[(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C],C])" class="delimiter">(</a><a href="#291090" title="scalaz.Free.Source[E,B]">src</a>.<a href="#48234" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B]">resume</a>, <a href="#291091" title="scalaz.Free.Sink[E,C]">snk</a>.<a href="#48234" title="=&gt; scalaz.\/[(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C],C]">resume</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>-\/<a href="#1677569" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B]" class="delimiter">(</a><a href="Either.scala.html#50471" title="=&gt; (E, scalaz.Free[[+x](E, x),B])" class="delimiter">(</a><a href="#1677572" title="E" id="291115">e</a>, <a href="#1677572" title="scalaz.Free[[+x](E, x),B]" id="291116">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, -\/<a href="#1677569" title="=&gt; scalaz.\/[(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C],C]" class="delimiter">(</a><a href="Either.scala.html#50471" title="(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C]" id="291121">f</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#291089" title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)">go</a><a href="#1677589" title="(x: (C, B))(C, B)" class="delimiter">(</a><a href="#291116" title="scalaz.Free[[+x](E, x),B]">c</a>, <a href="#291121" title="(v1: =&gt; E)scalaz.Free[[+x](=&gt; E) =&gt; x,C]">f</a><span class="delimiter">(</span><a href="#291115" title="E">e</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>-\/<a href="#1677569" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B]" class="delimiter">(</a><a href="Either.scala.html#50471" title="=&gt; (E, scalaz.Free[[+x](E, x),B])" class="delimiter">(</a>e, <a href="#1677577" title="scalaz.Free[[+x](E, x),B]" id="291140">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, \/-<a href="#1677569" title="=&gt; scalaz.\/[(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C],C]" class="delimiter">(</a><a href="Either.scala.html#50507" title="C" id="291145">y</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#291089" title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)">go</a><a href="#1677589" title="(x: (C, B))(C, B)" class="delimiter">(</a><a href="#291140" title="scalaz.Free[[+x](E, x),B]">c</a>, <a href="#15828" title="scalaz.Sink.type">Sink</a>.<a href="#44523" title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x](=&gt; S) =&gt; x,x]]">sinkMonad</a><span title="scalaz.Monad[[x]scalaz.Free[[+x](=&gt; E) =&gt; x,x]]" class="delimiter">[</span><a href="#48292" title="E">E</a><span class="delimiter">]</span>.<a href="Applicative.scala.html#34513" title="(a: =&gt; C)scalaz.Free[[+x](=&gt; E) =&gt; x,C]">pure</a><span class="delimiter">(</span><a href="#291145" title="C">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>\/-<a href="#1677569" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B]" class="delimiter">(</a>x<span class="delimiter">)</span>, -\/<a href="#1677569" title="=&gt; scalaz.\/[(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C],C]" class="delimiter">(</a>f<span class="delimiter">)</span><span class="delimiter">)</span>      =&gt; sys.<span title="(message: String)Nothing">error</span><a href="#1677589" title="(x: (C, B))(C, B)" class="delimiter">(</a><span title="String(&quot;Not enough values in source.&quot;)" class="string">&quot;Not enough values in source.&quot;</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>\/-<a href="#1677569" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B]" class="delimiter">(</a><a href="Either.scala.html#50507" title="B" id="291183">x</a><span class="delimiter">)</span>, \/-<a href="#1677569" title="=&gt; scalaz.\/[(=&gt; E) =&gt; scalaz.Free[[+x](=&gt; E) =&gt; x,C],C]" class="delimiter">(</a><a href="Either.scala.html#50507" title="C" id="291188">y</a><span class="delimiter">)</span><span class="delimiter">)</span>     =&gt; <a href="#1677589" title="(x: (C, B))(C, B)" class="delimiter">(</a><a href="#291188" title="C">y</a>, <a href="#291183" title="B">x</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#291089" title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)">go</a><span class="delimiter">(</span><a href="#291085" title="scalaz.Free.Source[E,B]">source</a>, <a href="Liskov.scala.html#58128" title="(a: scalaz.Free[S,C])scalaz.Free.Sink[E,C]">ev</a><span class="delimiter">(</span><a href="#10907" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="scalaz.Trampoline.type" id="19731">Trampoline</a> <a href="#19732" title="scalaz.Trampoline.type" class="keyword">extends</a> <a href="#12848" title="scalaz.TrampolineInstances">TrampolineInstances</a> <span class="delimiter">{</span>

  <span class="keyword">def</span> <a title="[A](a: A)scalaz.Free.Trampoline[A]" id="48306">done</a><span class="delimiter">[</span><a title="" id="48308">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="48373">a</a>: <a href="#48308" title="A">A</a><span class="delimiter">)</span>: <a href="#10907" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = 
    <a href="#10908" title="scalaz.Free.type">Free</a>.<a href="#283421" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[Function0])scalaz.Free.Return[Function0,A]" class="delimiter">[</span><span title="Function0">Function0</span>,<a href="#48308" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#44548" title="=&gt; scalaz.Traverse[Function0] with scalaz.Monad[Function0] with scalaz.Comonad[Function0] with scalaz.Distributive[Function0]" class="delimiter">(</a><a href="#48373" title="A">a</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free.Trampoline[A]" id="48309">delay</a><span class="delimiter">[</span><a title="" id="48311">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="48315">a</a>: =&gt; A<span class="delimiter">)</span>: <a href="#10907" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = 
    <a href="#48312" title="(a: =&gt; scalaz.Free.Trampoline[A])scalaz.Free.Trampoline[A]">suspend</a><span class="delimiter">(</span><a href="#48306" title="(a: A)scalaz.Free.Trampoline[A]">done</a><span class="delimiter">(</span><a href="#48315" title="=&gt; A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[A](a: =&gt; scalaz.Free.Trampoline[A])scalaz.Free.Trampoline[A]" id="48312">suspend</a><span class="delimiter">[</span><a title="" id="48314">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.Free.Trampoline[A]" id="291503">a</a>: =&gt; Trampoline<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#10907" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#10908" title="scalaz.Free.type">Free</a>.<a href="#283463" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: () =&gt; scalaz.Free[Function0,A])(implicit evidence$2: scalaz.Functor[Function0])scalaz.Free.Suspend[Function0,A]" class="delimiter">[</span><span title="Function0">Function0</span>, <a href="#48314" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#44548" title="=&gt; scalaz.Traverse[Function0] with scalaz.Monad[Function0] with scalaz.Comonad[Function0] with scalaz.Distributive[Function0]" class="delimiter">(</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#291503" title="=&gt; scalaz.Free.Trampoline[A]">a</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait TrampolineInstances extends AnyRef" id="12848">TrampolineInstances</a> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Monad[scalaz.Free.Trampoline]" id="44516">trampolineMonad</a>: <a href="Monad.scala.html#15566" title="scalaz.Monad[scalaz.Free.Trampoline]">Monad</a><span class="delimiter">[</span>Trampoline<span class="delimiter">]</span> = <a href="#291820" title="scalaz.Monad[scalaz.Free.Trampoline]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Monad[scalaz.Free.Trampoline]" id="291820">Monad</a><span class="delimiter">[</span>Trampoline<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free[Function0,A]" id="291822">point</a><span class="delimiter">[</span><a title="" id="291824">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="291857">a</a>: =&gt; A<span class="delimiter">)</span> = <a href="#44473" title="[S[+_], A](value: =&gt; A)(implicit S: scalaz.Applicative[S])scalaz.Free[S,A]">return_</a><span title="(value: =&gt; A)(implicit S: scalaz.Applicative[Function0])scalaz.Free[Function0,A]" class="delimiter">[</span><span title="Function0">Function0</span>, <a href="#291824" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#44548" title="=&gt; scalaz.Traverse[Function0] with scalaz.Monad[Function0] with scalaz.Comonad[Function0] with scalaz.Distributive[Function0]" class="delimiter">(</a><a href="#291857" title="=&gt; A">a</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[A, B](ta: scalaz.Free.Trampoline[A])(f: A =&gt; scalaz.Free.Trampoline[B])scalaz.Free[Function0,B]" id="291825">bind</a><span class="delimiter">[</span><a title="" id="291828">A</a>, <a title="" id="291829">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Trampoline[A]" id="292158">ta</a>: <a href="#10907" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free.Trampoline[B]" id="292159">f</a>: A =&gt; Trampoline<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#292158" title="scalaz.Free.Trampoline[A]">ta</a> <a href="#48231" title="(f: A =&gt; scalaz.Free[Function0,B])scalaz.Free[Function0,B]">flatMap</a> <a href="#292159" title="A =&gt; scalaz.Free.Trampoline[B]">f</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="scalaz.Sink.type" id="15828">Sink</a> <a href="#15829" title="scalaz.Sink.type" class="keyword">extends</a> <a href="#15140" title="scalaz.SinkInstances">SinkInstances</a>

<span class="keyword">trait</span> <a title="trait SinkInstances extends AnyRef" id="15140">SinkInstances</a> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x](=&gt; S) =&gt; x,x]]" id="44523">sinkMonad</a><span class="delimiter">[</span><a title="" id="44525">S</a><span class="delimiter">]</span>: <a href="Monad.scala.html#15566" title="scalaz.Monad[[x]scalaz.Free[[+x](=&gt; S) =&gt; x,x]]">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Sink<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> =
    <a href="#292199" title="scalaz.Monad[[x]scalaz.Free[[+x](=&gt; S) =&gt; x,x]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Monad[[x]scalaz.Free[[+x](=&gt; S) =&gt; x,x]]" id="292199">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Sink<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free.Suspend[[+x](=&gt; S) =&gt; x,A]" id="292206">point</a><span class="delimiter">[</span><a title="" id="292208">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="292241">a</a>: =&gt; A<span class="delimiter">)</span> =
        <a href="#283463" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: (=&gt; S) =&gt; scalaz.Free[[+x](=&gt; S) =&gt; x,A])(implicit evidence$2: scalaz.Functor[[+x](=&gt; S) =&gt; x])scalaz.Free.Suspend[[+x](=&gt; S) =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; S<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](=&gt; S) =&gt; x">f</span>, <a href="#292208" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#44555" title="FunctionInstances extends scalaz.Monad[[a](=&gt; S) =&gt; a] with scalaz.Zip[[a](=&gt; S) =&gt; a] with scalaz.Unzip[[a](=&gt; S) =&gt; a] with scalaz.Distributive[[a](=&gt; S) =&gt; a]" class="delimiter">(</a><a title="=&gt; S" id="292258">s</a> =&gt;
          <a href="#283421" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[[+x](=&gt; S) =&gt; x])scalaz.Free.Return[[+x](=&gt; S) =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; S<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](=&gt; S) =&gt; x">f</span>, <a href="#292208" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#44555" title="FunctionInstances extends scalaz.Monad[[a](=&gt; S) =&gt; a] with scalaz.Zip[[a](=&gt; S) =&gt; a] with scalaz.Unzip[[a](=&gt; S) =&gt; a] with scalaz.Distributive[[a](=&gt; S) =&gt; a]" class="delimiter">(</a><a href="#292241" title="=&gt; A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="[A, B](s: scalaz.Free.Sink[S,A])(f: A =&gt; scalaz.Free.Sink[S,B])scalaz.Free[[+x](=&gt; S) =&gt; x,B]" id="292209">bind</a><span class="delimiter">[</span><a title="" id="292212">A</a>, <a title="" id="292213">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Sink[S,A]" id="292976">s</a>: <a href="#10907" title="scalaz.Free.Sink[S,A]">Sink</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free.Sink[S,B]" id="292977">f</a>: A =&gt; Sink<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#292976" title="scalaz.Free.Sink[S,A]">s</a> <a href="#48231" title="(f: A =&gt; scalaz.Free[[+x](=&gt; S) =&gt; x,B])scalaz.Free[[+x](=&gt; S) =&gt; x,B]">flatMap</a> <a href="#292977" title="A =&gt; scalaz.Free.Sink[S,B]">f</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="scalaz.Source.type" id="22245">Source</a> <a href="#22246" title="scalaz.Source.type" class="keyword">extends</a> <a href="#13199" title="scalaz.SourceInstances">SourceInstances</a>

<span class="keyword">trait</span> <a title="trait SourceInstances extends AnyRef" id="13199">SourceInstances</a> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]" id="44527">sourceMonad</a><span class="delimiter">[</span><a title="" id="44529">S</a><span class="delimiter">]</span>: <a href="Monad.scala.html#15566" title="scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Source<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> =
    <a href="#293029" title="scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]" id="293029">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Source<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free.Return[[+x](S, x),A]" id="293036">point</a><span class="delimiter">[</span><a title="" id="293038">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="293071">a</a>: =&gt; A<span class="delimiter">)</span> = <a href="#283421" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[[+x](S, x)])scalaz.Free.Return[[+x](S, x),A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>S, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](S, x)">f</span>, <a href="#293038" title="A">A</a><span class="delimiter">]</span><a href="std/Tuple.scala.html#45953" title="TupleInstances0 extends scalaz.Traverse[[x](S, x)] with scalaz.Comonad[[x](S, x)]" class="delimiter">(</a><a href="#293071" title="=&gt; A">a</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="[A, B](s: scalaz.Free.Source[S,A])(f: A =&gt; scalaz.Free.Source[S,B])scalaz.Free[[+x](S, x),B]" id="293039">bind</a><span class="delimiter">[</span><a title="" id="293042">A</a>, <a title="" id="293043">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Source[S,A]" id="293661">s</a>: <a href="#10907" title="scalaz.Free.Source[S,A]">Source</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free.Source[S,B]" id="293662">f</a>: A =&gt; Source<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#293661" title="scalaz.Free.Source[S,A]">s</a> <a href="#48231" title="(f: A =&gt; scalaz.Free[[+x](S, x),B])scalaz.Free[[+x](S, x),B]">flatMap</a> <a href="#293662" title="A =&gt; scalaz.Free.Source[S,B]">f</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

// Trampoline, Sink, and Source are type aliases. We need to add their type class instances
// to Free to be part of the implicit scope.
<span title="AnyRef" class="keyword">trait</span> <a title="trait FreeInstances extends AnyRef with scalaz.TrampolineInstances with scalaz.SinkInstances with scalaz.SourceInstances" id="17378">FreeInstances</a> <span title="Unit" class="keyword">extends</span> <a href="#12848" title="scalaz.TrampolineInstances">TrampolineInstances</a> <span class="keyword">with</span> <a href="#15140" title="scalaz.SinkInstances">SinkInstances</a> <span class="keyword">with</span> <a href="#13199" title="scalaz.SourceInstances">SourceInstances</a> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S[+_]](implicit evidence$5: scalaz.Functor[S])scalaz.Monad[[x]scalaz.Free[S,x]]" id="58163">freeMonad</a><span class="delimiter">[</span><a title="[+_]" id="44521">S</a><span class="delimiter">[</span>+<a title="" id="58167">_</a><span class="delimiter">]</span>:Functor<span class="delimiter">]</span>: <a href="Monad.scala.html#15566" title="scalaz.Monad[[x]scalaz.Free[S,x]]">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Free<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> =
    <a href="#293714" title="scalaz.Monad[[x]scalaz.Free[S,x]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Monad[[x]scalaz.Free[S,x]]" id="293714">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Free<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free.Return[S,A]" id="293721">point</a><span class="delimiter">[</span><a title="" id="293723">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="293761">a</a>: =&gt; A<span class="delimiter">)</span> = <a href="#283421" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><a href="#58163" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#293761" title="=&gt; A">a</a><span class="delimiter">)</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](fa: scalaz.Free[S,A])(f: A =&gt; B)scalaz.Free[S,B]" id="293724">map</a><span class="delimiter">[</span><a title="" id="293727">A</a>, <a title="" id="293728">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="294093">fa</a>: <a href="#10907" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="294094">f</a>: A =&gt; B<span class="delimiter">)</span> = <a href="#294093" title="scalaz.Free[S,A]">fa</a> <a href="#48225" title="(f: A =&gt; B)scalaz.Free[S,B]">map</a> <a href="#294094" title="A =&gt; B">f</a>
      <span class="keyword">def</span> <a title="[A, B](a: scalaz.Free[S,A])(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]" id="293729">bind</a><span class="delimiter">[</span><a title="" id="293732">A</a>, <a title="" id="293733">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="294133">a</a>: <a href="#10907" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free[S,B]" id="294134">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#294133" title="scalaz.Free[S,A]">a</a> <a href="#48231" title="(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]">flatMap</a> <a href="#294134" title="A =&gt; scalaz.Free[S,B]">f</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait FreeFunctions extends AnyRef" id="12776">FreeFunctions</a> <span title="Unit" class="delimiter">{</span>
  /** Collapse a trampoline to a single step. */
  <span class="keyword">def</span> <a title="[A](r: scalaz.Free.Trampoline[A])scalaz.Free.Trampoline[A]" id="44470">reset</a><span class="delimiter">[</span><a title="" id="44472">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Trampoline[A]" id="294188">r</a>: <a href="#10907" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#10907" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a title="A" id="294190">a</a> = <a href="#294188" title="scalaz.Free.Trampoline[A]">r</a>.<a href="#48263" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,A],scalaz.Free.Trampoline[A]])A">run</a>; <a href="#44473" title="(value: =&gt; A)(implicit S: scalaz.Applicative[Function0])scalaz.Free[Function0,A]">return_</a><a href="std/Function.scala.html#44548" title="=&gt; scalaz.Traverse[Function0] with scalaz.Monad[Function0] with scalaz.Comonad[Function0] with scalaz.Distributive[Function0]" class="delimiter">(</a><a href="#294190" title="A">a</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  /** Suspend the given computation in a single step. */
  <span class="keyword">def</span> <a title="[S[+_], A](value: =&gt; A)(implicit S: scalaz.Applicative[S])scalaz.Free[S,A]" id="44473">return_</a><span class="delimiter">[</span><a title="[+_]" id="44476">S</a><span class="delimiter">[</span>+<a title="" id="151410">_</a><span class="delimiter">]</span>, <a title="" id="44477">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="151408">value</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[S]" id="151409">S</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[S]">Applicative</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#10907" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> =
    <a href="#283463" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]" class="delimiter">[</span><a href="#44476" title="S">S</a>, <a href="#44477" title="A">A</a><span class="delimiter">]</span><a href="#151409" title="scalaz.Applicative[S]" class="delimiter">(</a><a href="#151409" title="scalaz.Applicative[S]">S</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; scalaz.Free.Return[S,A])S[scalaz.Free.Return[S,A]]">point</a><span class="delimiter">(</span><a href="#283421" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]" class="delimiter">[</span><a href="#44476" title="S">S</a>, <a href="#44477" title="A">A</a><span class="delimiter">]</span><a href="#151409" title="scalaz.Applicative[S]" class="delimiter">(</a><a href="#151408" title="=&gt; A">value</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[S[+_], A](value: =&gt; scalaz.Free[S,A])(implicit S: scalaz.Applicative[S])scalaz.Free[S,A]" id="44478">suspend</a><span class="delimiter">[</span><a title="[+_]" id="44481">S</a><span class="delimiter">[</span>+<a title="" id="151241">_</a><span class="delimiter">]</span>, <a title="" id="44482">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.Free[S,A]" id="151239">value</a>: =&gt; Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[S]" id="151240">S</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[S]">Applicative</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#10907" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> =
    <a href="#283463" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]" class="delimiter">[</span><a href="#44481" title="S">S</a>, <a href="#44482" title="A">A</a><span class="delimiter">]</span><a href="#151240" title="scalaz.Applicative[S]" class="delimiter">(</a><a href="#151240" title="scalaz.Applicative[S]">S</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; scalaz.Free[S,A])S[scalaz.Free[S,A]]">point</a><span class="delimiter">(</span><a href="#151239" title="=&gt; scalaz.Free[S,A]">value</a><span class="delimiter">)</span><span class="delimiter">)</span>

  /** A trampoline step that doesn't do anything. */
  <span class="keyword">def</span> <a title="=&gt; scalaz.Free.Trampoline[Unit]" id="44483">pause</a>: <a href="#10907" title="scalaz.Free.Trampoline[Unit]">Trampoline</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> =
    <a href="#44473" title="(value: =&gt; Unit)(implicit S: scalaz.Applicative[Function0])scalaz.Free[Function0,Unit]">return_</a><a href="std/Function.scala.html#44548" title="=&gt; scalaz.Traverse[Function0] with scalaz.Monad[Function0] with scalaz.Comonad[Function0] with scalaz.Distributive[Function0]" class="delimiter">(</a><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** A source that produces the given value. */
  <span class="keyword">def</span> <a title="[A](a: A)scalaz.Free.Source[A,Unit]" id="44484">produce</a><span class="delimiter">[</span><a title="" id="44486">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="295979">a</a>: <a href="#44486" title="A">A</a><span class="delimiter">)</span>: <a href="#10907" title="scalaz.Free.Source[A,Unit]">Source</a><span class="delimiter">[</span>A, Unit<span class="delimiter">]</span> =
    <a href="#283463" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: (A, scalaz.Free[[+x](A, x),Unit]))(implicit evidence$2: scalaz.Functor[[+x](A, x)])scalaz.Free.Suspend[[+x](A, x),Unit]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>A, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](A, x)">f</span>, <span title="Unit">Unit</span><span class="delimiter">]</span><a href="std/Tuple.scala.html#45953" title="TupleInstances0 extends scalaz.Traverse[[x](A, x)] with scalaz.Comonad[[x](A, x)]" class="delimiter">(</a><a href="#295979" title="(x: A)ArrowAssoc[A]">a</a> <span title="(y: scalaz.Free.Return[[+x](A, x),Unit])(A, scalaz.Free.Return[[+x](A, x),Unit])">-&gt;</span> <a href="#283421" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: Unit)(implicit evidence$1: scalaz.Functor[[+x](A, x)])scalaz.Free.Return[[+x](A, x),Unit]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>A, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](A, x)">f</span>, <span title="Unit">Unit</span><span class="delimiter">]</span><a href="std/Tuple.scala.html#45953" title="TupleInstances0 extends scalaz.Traverse[[x](A, x)] with scalaz.Comonad[[x](A, x)]" class="delimiter">(</a><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** A sink that waits for a single value and returns it. */
  <span class="keyword">def</span> <a title="[A]=&gt; scalaz.Free.Sink[A,A]" id="44487">await</a><span class="delimiter">[</span><a title="" id="44489">A</a><span class="delimiter">]</span>: <a href="#10907" title="scalaz.Free.Sink[A,A]">Sink</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#283463" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: (=&gt; A) =&gt; scalaz.Free[[+x](=&gt; A) =&gt; x,A])(implicit evidence$2: scalaz.Functor[[+x](=&gt; A) =&gt; x])scalaz.Free.Suspend[[+x](=&gt; A) =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; A<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](=&gt; A) =&gt; x">f</span>, <a href="#44489" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#44555" title="FunctionInstances extends scalaz.Monad[[a](=&gt; A) =&gt; a] with scalaz.Zip[[a](=&gt; A) =&gt; a] with scalaz.Unzip[[a](=&gt; A) =&gt; a] with scalaz.Distributive[[a](=&gt; A) =&gt; a]" class="delimiter">(</a><a title="=&gt; A" id="297417">a</a> =&gt; <a href="#283421" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[[+x](=&gt; A) =&gt; x])scalaz.Free.Return[[+x](=&gt; A) =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; A<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](=&gt; A) =&gt; x">f</span>, <a href="#44489" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#44555" title="FunctionInstances extends scalaz.Monad[[a](=&gt; A) =&gt; a] with scalaz.Zip[[a](=&gt; A) =&gt; a] with scalaz.Unzip[[a](=&gt; A) =&gt; a] with scalaz.Distributive[[a](=&gt; A) =&gt; a]" class="delimiter">(</a><a href="#297417" title="=&gt; A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>