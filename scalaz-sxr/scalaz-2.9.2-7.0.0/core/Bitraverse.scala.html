<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/Bitraverse.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz

////
<span class="keyword">import</span> scalaz.<a href="Id.scala.html#8190" title="scalaz.Id.type">Id</a>.Id

/**
 * A type giving rise to two unrelated [[scalaz.Traverse]]s.
 */
////
<span class="keyword">trait</span> <a title="trait Bitraverse[F[_, _]] extends AnyRef with scalaz.Bifunctor[F] with scalaz.Bifoldable[F]" id="12491">Bitraverse</a><span class="delimiter">[</span><a title="[_, _]" id="22877">F</a><span class="delimiter">[</span><a title="" id="80621">_</a>, <a title="" id="80622">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="Bifunctor.scala.html#18509" title="scalaz.Bifunctor[F]">Bifunctor</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="keyword">with</span> <a href="Bifoldable.scala.html#8966" title="scalaz.Bifoldable[F]">Bifoldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span> self =&gt;
  ////

  /** Collect `G`s while applying `f` and `g` in some order. */
  <span class="keyword">def</span> <a title="[G[_], A, B, C, D](fab: F[A,B])(f: A =&gt; G[C], g: B =&gt; G[D])(implicit evidence$1: scalaz.Applicative[G])G[F[C,D]]" id="80703">bitraverseImpl</a><span class="delimiter">[</span><a title="[_]" id="72507">G</a><span class="delimiter">[</span><a title="" id="80704">_</a><span class="delimiter">]</span> : Applicative, <a title="" id="72508">A</a>, <a title="" id="72509">B</a>, <a title="" id="72510">C</a>, <a title="" id="72511">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="80700">fab</a>: <a href="#22877" title="F[A,B]">F</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; G[C]" id="80701">f</a>: A =&gt; G<span class="delimiter">[</span>C<span class="delimiter">]</span>, <a title="B =&gt; G[D]" id="80702">g</a>: B =&gt; G<span class="delimiter">[</span>D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#72507" title="G[F[C,D]]">G</a><span class="delimiter">[</span>F<span class="delimiter">[</span>C, D<span class="delimiter">]</span><span class="delimiter">]</span>

  // derived functions

  /**The composition of Bitraverses `F` and `G`, `[x,y]F[G[x,y],G[x,y]]`, is a Bitraverse */
  <span class="keyword">def</span> <a title="[G[_, _]](implicit G0: scalaz.Bitraverse[G])scalaz.Bitraverse[[α, β]F[G[α,β],G[α,β]]]" id="72512">compose</a><span class="delimiter">[</span><a title="[_, _]" id="72514">G</a><span class="delimiter">[</span><a title="" id="141382">_</a>, <a title="" id="141383">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bitraverse[G]" id="141377">G0</a>: <a href="#12491" title="scalaz.Bitraverse[G]">Bitraverse</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#12491" title="scalaz.Bitraverse[[α, β]F[G[α,β],G[α,β]]]">Bitraverse</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α, β<span class="delimiter">]</span>=F<span class="delimiter">[</span>G<span class="delimiter">[</span>α, β<span class="delimiter">]</span>, G<span class="delimiter">[</span>α, β<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#141396" title="scalaz.CompositionBitraverse[F,G]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.CompositionBitraverse[F,G]" id="141396">CompositionBitraverse</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Bitraverse[F]" id="141418">F</a> = <a href="#12491" title="scalaz.Bitraverse[F]">self</a>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Bitraverse[G]" id="141419">G</a> = <a href="#141377" title="scalaz.Bitraverse[G]">G0</a>
  <span class="delimiter">}</span>

  /**The product of Bitraverses `F` and `G`, `[x,y]F[G[x,y],G[x,y]]`, is a Bitraverse */
  <span class="keyword">def</span> <a title="[G[_, _]](implicit G0: scalaz.Bitraverse[G])scalaz.Bitraverse[[α, β](F[α,β], G[α,β])]" id="72515">product</a><span class="delimiter">[</span><a title="[_, _]" id="72517">G</a><span class="delimiter">[</span><a title="" id="141426">_</a>, <a title="" id="141427">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bitraverse[G]" id="141421">G0</a>: <a href="#12491" title="scalaz.Bitraverse[G]">Bitraverse</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#12491" title="scalaz.Bitraverse[[α, β](F[α,β], G[α,β])]">Bitraverse</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α, β<span class="delimiter">]</span>=<span class="delimiter">(</span>F<span class="delimiter">[</span>α, β<span class="delimiter">]</span>, G<span class="delimiter">[</span>α, β<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#141553" title="scalaz.ProductBitraverse[F,G]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.ProductBitraverse[F,G]" id="141553">ProductBitraverse</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Bitraverse[F]" id="141575">F</a> = <a href="#12491" title="scalaz.Bitraverse[F]">self</a>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Bitraverse[G]" id="141576">G</a> = <a href="#141421" title="scalaz.Bitraverse[G]">G0</a>
  <span class="delimiter">}</span>

  /** Flipped `bitraverse`. */
  <span class="keyword">def</span> <a title="[G[_], A, B, C, D](f: A =&gt; G[C], g: B =&gt; G[D])(implicit evidence$2: scalaz.Applicative[G])F[A,B] =&gt; G[F[C,D]]" id="141637">bitraverseF</a><span class="delimiter">[</span><a title="[_]" id="72524">G</a><span class="delimiter">[</span><a title="" id="141638">_</a><span class="delimiter">]</span> : Applicative, <a title="" id="72525">A</a>, <a title="" id="72526">B</a>, <a title="" id="72527">C</a>, <a title="" id="72528">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; G[C]" id="141635">f</a>: A =&gt; G<span class="delimiter">[</span>C<span class="delimiter">]</span>, <a title="B =&gt; G[D]" id="141636">g</a>: B =&gt; G<span class="delimiter">[</span>D<span class="delimiter">]</span><span class="delimiter">)</span>: F<span class="delimiter">[</span>A, B<span class="delimiter">]</span> =&gt; G<span class="delimiter">[</span>F<span class="delimiter">[</span>C, D<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#80703" title="(fab: F[A,B])(f: A =&gt; G[C], g: B =&gt; G[D])(implicit evidence$1: scalaz.Applicative[G])G[F[C,D]]">bitraverseImpl</a><span class="delimiter">(</span><a href="#141644" title="F[A,B]">_</a><span class="delimiter">)</span><a href="#141637" title="scalaz.Applicative[G]" class="delimiter">(</a><a href="#141635" title="A =&gt; G[C]">f</a>, <a href="#141636" title="B =&gt; G[D]">g</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[A, B, C, D](fab: F[A,B])(f: A =&gt; C, g: B =&gt; D)F[C,D]" id="72529">bimap</a><span class="delimiter">[</span><a title="" id="72534">A</a>, <a title="" id="72535">B</a>, <a title="" id="72536">C</a>, <a title="" id="72537">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="80618">fab</a>: <a href="#22877" title="F[A,B]">F</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; C" id="80619">f</a>: A =&gt; C, <a title="B =&gt; D" id="80620">g</a>: B =&gt; D<span class="delimiter">)</span>: <a href="#22877" title="F[C,D]">F</a><span class="delimiter">[</span>C, D<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#80703" title="[G[_], A, B, C, D](fab: F[A,B])(f: A =&gt; G[C], g: B =&gt; G[D])(implicit evidence$1: scalaz.Applicative[G])G[F[C,D]]">bitraverseImpl</a><span title="(fab: F[A,B])(f: A =&gt; scalaz.Id.Id[C], g: B =&gt; scalaz.Id.Id[D])(implicit evidence$1: scalaz.Applicative[scalaz.Id.Id])scalaz.Id.Id[F[C,D]]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#72534" title="A">A</a>, <a href="#72535" title="B">B</a>, <a href="#72536" title="C">C</a>, <a href="#72537" title="D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#80618" title="F[A,B]">fab</a><span class="delimiter">)</span><a href="package.scala.html#30683" title="=&gt; scalaz.Traverse1[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]" class="delimiter">(</a><a href="#80619" title="A =&gt; C">f</a>, <a href="#80620" title="B =&gt; D">g</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Extract the Traverse on the first param. */
  <span class="keyword">def</span> <a title="[X]=&gt; scalaz.Traverse[[α]F[α,X]]" id="72538">leftTraverse</a><span class="delimiter">[</span><a title="" id="72540">X</a><span class="delimiter">]</span>: <a href="Traverse.scala.html#20819" title="scalaz.Traverse[[α]F[α,X]]">Traverse</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = F<span class="delimiter">[</span>α, X<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#141694" title="scalaz.Traverse[[α]F[α,X]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Traverse[[α]F[α,X]]" id="141694">Traverse</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = F<span class="delimiter">[</span>α, X<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[G[_], A, B](fa: F[A,X])(f: A =&gt; G[B])(implicit evidence$3: scalaz.Applicative[G])G[F[B,X]]" id="141787">traverseImpl</a><span class="delimiter">[</span><a title="[_]" id="141705">G</a><span class="delimiter">[</span><a title="" id="141788">_</a><span class="delimiter">]</span>:Applicative,<a title="" id="141706">A</a>,<a title="" id="141707">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,X]" id="141785">fa</a>: <a href="#22877" title="F[A,X]">F</a><span class="delimiter">[</span>A, X<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; G[B]" id="141786">f</a>: A =&gt; G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#141705" title="G[F[B,X]]">G</a><span class="delimiter">[</span>F<span class="delimiter">[</span>B, X<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#80703" title="(fab: F[A,X])(f: A =&gt; G[B], g: X =&gt; G[X])(implicit evidence$1: scalaz.Applicative[G])G[F[B,X]]">bitraverseImpl</a><span class="delimiter">(</span><a href="#141785" title="F[A,X]">fa</a><span class="delimiter">)</span><a href="#141787" title="scalaz.Applicative[G]" class="delimiter">(</a><a href="#141786" title="A =&gt; G[B]">f</a>, <a title="X" id="141831">x</a> =&gt; <a href="Applicative.scala.html#51082" title="[F[_]](implicit F: scalaz.Applicative[F])scalaz.Applicative[F]">Applicative</a><a href="#141787" title="(implicit F: scalaz.Applicative[G])scalaz.Applicative[G]" class="delimiter">[</a><a href="#141705" title="G">G</a><span class="delimiter">]</span> <a href="Applicative.scala.html#34510" title="(a: =&gt; X)G[X]">point</a> <a href="#141831" title="X">x</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Extract the Traverse on the second param. */
  <span class="keyword">def</span> <a title="[X]=&gt; scalaz.Traverse[[α]F[X,α]]" id="72541">rightTraverse</a><span class="delimiter">[</span><a title="" id="72543">X</a><span class="delimiter">]</span>: <a href="Traverse.scala.html#20819" title="scalaz.Traverse[[α]F[X,α]]">Traverse</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = F<span class="delimiter">[</span>X, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#141861" title="scalaz.Traverse[[α]F[X,α]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Traverse[[α]F[X,α]]" id="141861">Traverse</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = F<span class="delimiter">[</span>X, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[G[_], A, B](fa: F[X,A])(f: A =&gt; G[B])(implicit evidence$4: scalaz.Applicative[G])G[F[X,B]]" id="141907">traverseImpl</a><span class="delimiter">[</span><a title="[_]" id="141872">G</a><span class="delimiter">[</span><a title="" id="141908">_</a><span class="delimiter">]</span>:Applicative,<a title="" id="141873">A</a>,<a title="" id="141874">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[X,A]" id="141905">fa</a>: <a href="#22877" title="F[X,A]">F</a><span class="delimiter">[</span>X, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; G[B]" id="141906">f</a>: A =&gt; G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#141872" title="G[F[X,B]]">G</a><span class="delimiter">[</span>F<span class="delimiter">[</span>X, B<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#80703" title="(fab: F[X,A])(f: X =&gt; G[X], g: A =&gt; G[B])(implicit evidence$1: scalaz.Applicative[G])G[F[X,B]]">bitraverseImpl</a><span class="delimiter">(</span><a href="#141905" title="F[X,A]">fa</a><span class="delimiter">)</span><a href="#141907" title="scalaz.Applicative[G]" class="delimiter">(</a><a title="X" id="141951">x</a> =&gt; <a href="Applicative.scala.html#51082" title="[F[_]](implicit F: scalaz.Applicative[F])scalaz.Applicative[F]">Applicative</a><a href="#141907" title="(implicit F: scalaz.Applicative[G])scalaz.Applicative[G]" class="delimiter">[</a><a href="#141872" title="G">G</a><span class="delimiter">]</span> <a href="Applicative.scala.html#34510" title="(a: =&gt; X)G[X]">point</a> <a href="#141951" title="X">x</a>, <a href="#141906" title="A =&gt; G[B]">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class Bitraversal[G[_]] extends AnyRef" id="72544">Bitraversal</a><span class="delimiter">[</span><a title="[_]" id="72545">G</a><span class="delimiter">[</span><a title="" id="141984">_</a><span class="delimiter">]</span><span class="delimiter">]</span><a href="#72544" title="Bitraverse.this.Bitraversal[G]" class="delimiter">(</a><span class="keyword">implicit</span> <a title="scalaz.Applicative[G]" id="141987">G</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[G]">Applicative</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B, C, D](fa: F[A,B])(f: A =&gt; G[C])(g: B =&gt; G[D])G[F[C,D]]" id="141975">run</a><span class="delimiter">[</span><a title="" id="141980">A</a>,<a title="" id="141981">B</a>,<a title="" id="141982">C</a>,<a title="" id="141983">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="141988">fa</a>: <a href="#22877" title="F[A,B]">F</a><span class="delimiter">[</span>A,B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; G[C]" id="141989">f</a>: A =&gt; G<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; G[D]" id="141990">g</a>: B =&gt; G<span class="delimiter">[</span>D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#72545" title="G[F[C,D]]">G</a><span class="delimiter">[</span>F<span class="delimiter">[</span>C, D<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#80703" title="[G[_], A, B, C, D](fab: F[A,B])(f: A =&gt; G[C], g: B =&gt; G[D])(implicit evidence$1: scalaz.Applicative[G])G[F[C,D]]">bitraverseImpl</a><span title="(fab: F[A,B])(f: A =&gt; G[C], g: B =&gt; G[D])(implicit evidence$1: scalaz.Applicative[G])G[F[C,D]]" class="delimiter">[</span><a href="#72545" title="G">G</a>,<a href="#141980" title="A">A</a>,<a href="#141981" title="B">B</a>,<a href="#141982" title="C">C</a>,<a href="#141983" title="D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#141988" title="F[A,B]">fa</a><span class="delimiter">)</span><a href="#141987" title="scalaz.Applicative[G]" class="delimiter">(</a><a href="#141989" title="A =&gt; G[C]">f</a>, <a href="#141990" title="B =&gt; G[D]">g</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  // reduce - given monoid
  <span class="keyword">def</span> <a title="[G[_]](implicit evidence$5: scalaz.Applicative[G])Bitraverse.this.Bitraversal[G]" id="141999">bitraversal</a><span class="delimiter">[</span><a title="[_]" id="72548">G</a><span class="delimiter">[</span><a title="" id="142000">_</a><span class="delimiter">]</span>:Applicative<span class="delimiter">]</span>: <a href="#72544" title="Bitraverse.this.Bitraversal[G]">Bitraversal</a><span class="delimiter">[</span>G<span class="delimiter">]</span> =
    <a href="#141999" title="Bitraverse.this.Bitraversal[G]" class="keyword">new</a> <a href="#72544" title="Bitraverse.this.Bitraversal[G]">Bitraversal</a><span class="delimiter">[</span>G<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="[S]=&gt; Bitraverse.this.Bitraversal[[x]scalaz.IndexedStateT[[+X]X,S,S,x]]" id="72549">bitraversalS</a><span class="delimiter">[</span><a title="" id="72551">S</a><span class="delimiter">]</span>: <a href="#72544" title="Bitraverse.this.Bitraversal[[x]scalaz.IndexedStateT[[+X]X,S,S,x]]">Bitraversal</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span>=State<span class="delimiter">[</span>S,x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> =
    <span title="Bitraverse.this.Bitraversal[[x]scalaz.IndexedStateT[[+X]X,S,S,x]]" class="keyword">new</span> <a href="#72544" title="Bitraverse.this.Bitraversal[[x]scalaz.IndexedStateT[[+X]X,S,S,x]]">Bitraversal</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span>=State<span class="delimiter">[</span>S,x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="package.scala.html#30737" title="scalaz.StateT.type">StateT</a>.<a href="StateT.scala.html#142094" title="scalaz.MonadState[[s, +a]scalaz.IndexedStateT[[+X]X,s,s,a],S]">stateMonad</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[G[_], A, B, C, D](fa: F[A,B])(f: A =&gt; G[C])(g: B =&gt; G[D])(implicit evidence$6: scalaz.Applicative[G])G[F[C,D]]" id="142132">bitraverse</a><span class="delimiter">[</span><a title="[_]" id="72558">G</a><span class="delimiter">[</span><a title="" id="142133">_</a><span class="delimiter">]</span>:Applicative,<a title="" id="72559">A</a>,<a title="" id="72560">B</a>,<a title="" id="72561">C</a>,<a title="" id="72562">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="142129">fa</a>: <a href="#22877" title="F[A,B]">F</a><span class="delimiter">[</span>A,B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; G[C]" id="142130">f</a>: A =&gt; G<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; G[D]" id="142131">g</a>: B =&gt; G<span class="delimiter">[</span>D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#72558" title="G[F[C,D]]">G</a><span class="delimiter">[</span>F<span class="delimiter">[</span>C, D<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#141999" title="[G[_]](implicit evidence$5: scalaz.Applicative[G])Bitraverse.this.Bitraversal[G]">bitraversal</a><a href="#142132" title="(implicit evidence$5: scalaz.Applicative[G])Bitraverse.this.Bitraversal[G]" class="delimiter">[</a><a href="#72558" title="G">G</a><span class="delimiter">]</span>.<a href="#141975" title="(fa: F[A,B])(f: A =&gt; G[C])(g: B =&gt; G[D])G[F[C,D]]">run</a><span class="delimiter">(</span><a href="#142129" title="F[A,B]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142130" title="A =&gt; G[C]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142131" title="B =&gt; G[D]">g</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[S, A, B, C, D](fa: F[A,B])(f: A =&gt; scalaz.State[S,C])(g: B =&gt; scalaz.State[S,D])scalaz.State[S,F[C,D]]" id="72563">bitraverseS</a><span class="delimiter">[</span><a title="" id="72569">S</a>,<a title="" id="72570">A</a>,<a title="" id="72571">B</a>,<a title="" id="72572">C</a>,<a title="" id="72573">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="142164">fa</a>: <a href="#22877" title="F[A,B]">F</a><span class="delimiter">[</span>A,B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.State[S,C]" id="142165">f</a>: A =&gt; State<span class="delimiter">[</span>S,C<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; scalaz.State[S,D]" id="142166">g</a>: B =&gt; State<span class="delimiter">[</span>S,D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="StateT.scala.html#20021" title="scalaz.State[S,F[C,D]]">State</a><span class="delimiter">[</span>S,F<span class="delimiter">[</span>C, D<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#72549" title="[S]=&gt; Bitraverse.this.Bitraversal[[x]scalaz.IndexedStateT[[+X]X,S,S,x]]">bitraversalS</a><span title="Bitraverse.this.Bitraversal[[x]scalaz.IndexedStateT[[+X]X,S,S,x]]" class="delimiter">[</span><a href="#72569" title="S">S</a><span class="delimiter">]</span>.<a href="#141975" title="(fa: F[A,B])(f: A =&gt; scalaz.IndexedStateT[[+X]X,S,S,C])(g: B =&gt; scalaz.IndexedStateT[[+X]X,S,S,D])scalaz.IndexedStateT[[+X]X,S,S,F[C,D]]">run</a><span class="delimiter">(</span><a href="#142164" title="F[A,B]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142165" title="A =&gt; scalaz.State[S,C]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142166" title="B =&gt; scalaz.State[S,D]">g</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[S, A, B, C, D](fa: F[A,B], s: S)(f: A =&gt; scalaz.State[S,C])(g: B =&gt; scalaz.State[S,D])(S, F[C,D])" id="72574">runBitraverseS</a><span class="delimiter">[</span><a title="" id="72580">S</a>,<a title="" id="72581">A</a>,<a title="" id="72582">B</a>,<a title="" id="72583">C</a>,<a title="" id="72584">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="142212">fa</a>: <a href="#22877" title="F[A,B]">F</a><span class="delimiter">[</span>A,B<span class="delimiter">]</span>, <a title="S" id="142213">s</a>: <a href="#72580" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.State[S,C]" id="142214">f</a>: A =&gt; State<span class="delimiter">[</span>S,C<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; scalaz.State[S,D]" id="142215">g</a>: B =&gt; State<span class="delimiter">[</span>S,D<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(S, F[C,D])" class="delimiter">(</span>S, F<span class="delimiter">[</span>C, D<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#72563" title="(fa: F[A,B])(f: A =&gt; scalaz.State[S,C])(g: B =&gt; scalaz.State[S,D])scalaz.State[S,F[C,D]]">bitraverseS</a><span class="delimiter">(</span><a href="#142212" title="F[A,B]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142214" title="A =&gt; scalaz.State[S,C]">f</a><span class="delimiter">)</span><a href="StateT.scala.html#70591" title="(initial: S)(S, F[C,D])" class="delimiter">(</a><a href="#142215" title="B =&gt; scalaz.State[S,D]">g</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142213" title="S">s</a><span class="delimiter">)</span>

  /** Bitraverse `fa` with a `State[S, G[C]]` and `State[S, G[D]]`, internally using a `Trampoline` to avoid stack overflow. */
  <span class="keyword">def</span> <a title="[S, G[_], A, B, C, D](fa: F[A,B])(f: A =&gt; scalaz.State[S,G[C]])(g: B =&gt; scalaz.State[S,G[D]])(implicit evidence$7: scalaz.Applicative[G])scalaz.State[S,G[F[C,D]]]" id="142249">traverseSTrampoline</a><span class="delimiter">[</span><a title="" id="72592">S</a>, <a title="[_]" id="72593">G</a><span class="delimiter">[</span><a title="" id="142250">_</a><span class="delimiter">]</span> : Applicative, <a title="" id="72594">A</a>, <a title="" id="72595">B</a>, <a title="" id="72596">C</a>, <a title="" id="72597">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="142246">fa</a>: <a href="#22877" title="F[A,B]">F</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.State[S,G[C]]" id="142247">f</a>: A =&gt; State<span class="delimiter">[</span>S, G<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; scalaz.State[S,G[D]]" id="142248">g</a>: B =&gt; State<span class="delimiter">[</span>S, G<span class="delimiter">[</span>D<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="StateT.scala.html#20021" title="scalaz.State[S,G[F[C,D]]]">State</a><span class="delimiter">[</span>S, G<span class="delimiter">[</span>F<span class="delimiter">[</span>C, D<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">import</span> <a href="Free.scala.html#10908" title="scalaz.Free.type">Free</a>._
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Applicative[[α]scalaz.IndexedStateT[scalaz.Free.Trampoline,S,S,G[α]]]" id="142257">A</a> = <a href="package.scala.html#30737" title="scalaz.StateT.type">StateT</a>.<a href="StateT.scala.html#142084" title="[S, F[+_]](implicit F0: scalaz.Monad[F])scalaz.MonadState[[s, +a]scalaz.IndexedStateT[F,s,s,a],S]">stateTMonadState</a><a href="Free.scala.html#44516" title="(implicit F0: scalaz.Monad[scalaz.Free.Trampoline])scalaz.MonadState[[s, +a]scalaz.IndexedStateT[scalaz.Free.Trampoline,s,s,a],S]" class="delimiter">[</a><a href="#72592" title="S">S</a>, <a href="Free.scala.html#10907" title="scalaz.Free.Trampoline">Trampoline</a><span class="delimiter">]</span>.<a href="Applicative.scala.html#34550" title="(implicit G0: scalaz.Applicative[G])scalaz.Applicative[[α]scalaz.IndexedStateT[scalaz.Free.Trampoline,S,S,G[α]]]">compose</a><span class="delimiter">(</span><a href="Applicative.scala.html#51082" title="[F[_]](implicit F: scalaz.Applicative[F])scalaz.Applicative[F]">Applicative</a><a href="#142249" title="(implicit F: scalaz.Applicative[G])scalaz.Applicative[G]" class="delimiter">[</a><a href="#72593" title="G">G</a><span class="delimiter">]</span><span class="delimiter">)</span>

    <a href="#142395" title="scalaz.State[S,G[F[C,D]]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.State[S,G[F[C,D]]]" id="142395">State</a><span class="delimiter">[</span>S, G<span class="delimiter">[</span>F<span class="delimiter">[</span>C, D<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(initial: S)(S, G[F[C,D]])" id="142397">apply</a><span class="delimiter">(</span><a title="S" id="142399">initial</a>: <a href="#72592" title="S">S</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="scalaz.IndexedStateT[[+A]scalaz.Free[Function0,A],S,S,G[F[C,D]]]" id="142403">st</a> = <a href="#142132" title="[G[_], A, B, C, D](fa: F[A,B])(f: A =&gt; G[C])(g: B =&gt; G[D])(implicit evidence$6: scalaz.Applicative[G])G[F[C,D]]">bitraverse</a><span title="(fa: F[A,B])(f: A =&gt; scalaz.IndexedStateT[[+A]scalaz.Free[Function0,A],S,S,G[C]])(g: B =&gt; scalaz.IndexedStateT[[+A]scalaz.Free[Function0,A],S,S,G[D]])(implicit evidence$6: scalaz.Applicative[[α]scalaz.IndexedStateT[[+A]scalaz.Free[Function0,A],S,S,G[α]]])scalaz.IndexedStateT[[+A]scalaz.Free[Function0,A],S,S,G[F[C,D]]]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span>=StateT<span class="delimiter">[</span>Trampoline, S, G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#<a href="StateT.scala.html#20021" title="[α]scalaz.IndexedStateT[[+A]scalaz.Free[Function0,A],S,S,G[α]]">λ</a>, <a href="#72594" title="A">A</a>, <a href="#72595" title="B">B</a>, <a href="#72596" title="C">C</a>, <a href="#72597" title="D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#142246" title="F[A,B]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142247" title="(v1: A)scalaz.State[S,G[C]]">f</a><span class="delimiter">(</span><a href="#142414" title="A">_</a>: <a href="#72594" title="A">A</a><span class="delimiter">)</span>.<a href="StateT.scala.html#70637" title="[M[+_]](implicit evidence$1: scalaz.Applicative[M])scalaz.IndexedStateT[[+α]M[scalaz.Id.Id[α]],S,S,G[C]]">lift</a><a href="Free.scala.html#44516" title="(implicit evidence$1: scalaz.Applicative[scalaz.Free.Trampoline])scalaz.IndexedStateT[[+α]scalaz.Free.Trampoline[scalaz.Id.Id[α]],S,S,G[C]]" class="delimiter">[</a><a href="Free.scala.html#10907" title="scalaz.Free.Trampoline">Trampoline</a><span class="delimiter">]</span><span class="delimiter">)</span><a href="#142257" title="scalaz.Applicative[[α]scalaz.IndexedStateT[scalaz.Free.Trampoline,S,S,G[α]]]" class="delimiter">(</a><a href="#142248" title="(v1: B)scalaz.State[S,G[D]]">g</a><span class="delimiter">(</span><a href="#142470" title="B">_</a>: <a href="#72595" title="B">B</a><span class="delimiter">)</span>.<a href="StateT.scala.html#70637" title="[M[+_]](implicit evidence$1: scalaz.Applicative[M])scalaz.IndexedStateT[[+α]M[scalaz.Id.Id[α]],S,S,G[D]]">lift</a><a href="Free.scala.html#44516" title="(implicit evidence$1: scalaz.Applicative[scalaz.Free.Trampoline])scalaz.IndexedStateT[[+α]scalaz.Free.Trampoline[scalaz.Id.Id[α]],S,S,G[D]]" class="delimiter">[</a><a href="Free.scala.html#10907" title="scalaz.Free.Trampoline">Trampoline</a><span class="delimiter">]</span><span class="delimiter">)</span>
        <a href="StateT.scala.html#70591" title="(initial: S)scalaz.Free[Function0,(S, G[F[C,D]])]">st</a><span class="delimiter">(</span><a href="#142399" title="S">initial</a><span class="delimiter">)</span>.<a href="Free.scala.html#48263" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,(S, G[F[C,D]])],scalaz.Free.Trampoline[(S, G[F[C,D]])]])(S, G[F[C,D]])">run</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Bitraverse `fa` with a `Kleisli[G, S, C]` and `Kleisli[G, S, D]`, internally using a `Trampoline` to avoid stack overflow. */
  <span class="keyword">def</span> <a title="[S, G[+_], A, B, C, D](fa: F[A,B])(f: A =&gt; scalaz.Kleisli[G,S,C])(g: B =&gt; scalaz.Kleisli[G,S,D])(implicit evidence$8: scalaz.Applicative[G])scalaz.Kleisli[G,S,F[C,D]]" id="142572">bitraverseKTrampoline</a><span class="delimiter">[</span><a title="" id="72605">S</a>, <a title="[+_]" id="72606">G</a><span class="delimiter">[</span>+<a title="" id="142573">_</a><span class="delimiter">]</span> : Applicative, <a title="" id="72607">A</a>, <a title="" id="72608">B</a>, <a title="" id="72609">C</a>, <a title="" id="72610">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="142569">fa</a>: <a href="#22877" title="F[A,B]">F</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Kleisli[G,S,C]" id="142570">f</a>: A =&gt; Kleisli<span class="delimiter">[</span>G, S, C<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; scalaz.Kleisli[G,S,D]" id="142571">g</a>: B =&gt; Kleisli<span class="delimiter">[</span>G, S, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Kleisli.scala.html#13760" title="scalaz.Kleisli[G,S,F[C,D]]">Kleisli</a><span class="delimiter">[</span>G, S, F<span class="delimiter">[</span>C, D<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">import</span> <a href="Free.scala.html#10908" title="scalaz.Free.type">Free</a>._
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Applicative[[α]scalaz.Kleisli[scalaz.Free.Trampoline,S,G[α]]]" id="142580">A</a> = <a href="Kleisli.scala.html#13761" title="scalaz.Kleisli.type">Kleisli</a>.<a href="Kleisli.scala.html#44425" title="[F[+_], R](implicit F0: scalaz.Monad[F])scalaz.KleisliMonadReader[F,R]">kleisliMonadReader</a><a href="Free.scala.html#44516" title="(implicit F0: scalaz.Monad[scalaz.Free.Trampoline])scalaz.KleisliMonadReader[scalaz.Free.Trampoline,S]" class="delimiter">[</a><a href="Free.scala.html#10907" title="scalaz.Free.Trampoline">Trampoline</a>, <a href="#72605" title="S">S</a><span class="delimiter">]</span>.<a href="Applicative.scala.html#34550" title="(implicit G0: scalaz.Applicative[G])scalaz.Applicative[[α]scalaz.Kleisli[scalaz.Free.Trampoline,S,G[α]]]">compose</a><span class="delimiter">(</span><a href="Applicative.scala.html#51082" title="[F[_]](implicit F: scalaz.Applicative[F])scalaz.Applicative[F]">Applicative</a><a href="#142572" title="(implicit F: scalaz.Applicative[G])scalaz.Applicative[G]" class="delimiter">[</a><a href="#72606" title="G">G</a><span class="delimiter">]</span><span class="delimiter">)</span>

    <a href="Kleisli.scala.html#44370" title="[M[+_], A, B](f: A =&gt; M[B])scalaz.Kleisli[M,A,B]">Kleisli</a><span title="(f: S =&gt; G[F[C,D]])scalaz.Kleisli[G,S,F[C,D]]" class="delimiter">[</span><a href="#72606" title="G">G</a>, <a href="#72605" title="S">S</a>, <a href="#22877" title="F[C,D]">F</a><span class="delimiter">[</span>C, D<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="142710">s</a> =&gt; <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scalaz.Kleisli[[+A]scalaz.Free[Function0,A],S,G[F[C,D]]]" id="142711">kl</a> = <a href="#142132" title="[G[_], A, B, C, D](fa: F[A,B])(f: A =&gt; G[C])(g: B =&gt; G[D])(implicit evidence$6: scalaz.Applicative[G])G[F[C,D]]">bitraverse</a><span title="(fa: F[A,B])(f: A =&gt; scalaz.Kleisli[[+A]scalaz.Free[Function0,A],S,G[C]])(g: B =&gt; scalaz.Kleisli[[+A]scalaz.Free[Function0,A],S,G[D]])(implicit evidence$6: scalaz.Applicative[[α]scalaz.Kleisli[[+A]scalaz.Free[Function0,A],S,G[α]]])scalaz.Kleisli[[+A]scalaz.Free[Function0,A],S,G[F[C,D]]]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span>=Kleisli<span class="delimiter">[</span>Trampoline, S, G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#<a href="Kleisli.scala.html#13760" title="[α]scalaz.Kleisli[[+A]scalaz.Free[Function0,A],S,G[α]]">λ</a>, <a href="#72607" title="A">A</a>, <a href="#72608" title="B">B</a>, <a href="#72609" title="C">C</a>, <a href="#72610" title="D">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#142569" title="F[A,B]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="142722">z</a> =&gt; <a href="Kleisli.scala.html#44370" title="[M[+_], A, B](f: A =&gt; M[B])scalaz.Kleisli[M,A,B]">Kleisli</a><span title="(f: S =&gt; scalaz.Id.Id[G[C]])scalaz.Kleisli[scalaz.Id.Id,S,G[C]]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#72605" title="S">S</a>, <a href="#72606" title="G[C]">G</a><span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="142725">i</a> =&gt; <a href="#142570" title="(v1: A)scalaz.Kleisli[G,S,C]">f</a><a href="Kleisli.scala.html#44350" title="(v1: S)G[C]" class="delimiter">(</a><a href="#142722" title="A">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142725" title="S">i</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="Kleisli.scala.html#112870" title="[L[+_]](implicit evidence$1: scalaz.Applicative[L])scalaz.Kleisli[[+α]L[scalaz.Id.Id[α]],S,G[C]]">lift</a><a href="Free.scala.html#44516" title="(implicit evidence$1: scalaz.Applicative[scalaz.Free.Trampoline])scalaz.Kleisli[[+α]scalaz.Free.Trampoline[scalaz.Id.Id[α]],S,G[C]]" class="delimiter">[</a><a href="Free.scala.html#10907" title="scalaz.Free.Trampoline">Trampoline</a><span class="delimiter">]</span><span class="delimiter">)</span><a href="#142580" title="scalaz.Applicative[[α]scalaz.Kleisli[scalaz.Free.Trampoline,S,G[α]]]" class="delimiter">(</a><a title="B" id="142870">z</a> =&gt; <a href="Kleisli.scala.html#44370" title="[M[+_], A, B](f: A =&gt; M[B])scalaz.Kleisli[M,A,B]">Kleisli</a><span title="(f: S =&gt; scalaz.Id.Id[G[D]])scalaz.Kleisli[scalaz.Id.Id,S,G[D]]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#72605" title="S">S</a>, <a href="#72606" title="G[D]">G</a><span class="delimiter">[</span>D<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="142873">i</a> =&gt; <a href="#142571" title="(v1: B)scalaz.Kleisli[G,S,D]">g</a><a href="Kleisli.scala.html#44350" title="(v1: S)G[D]" class="delimiter">(</a><a href="#142870" title="B">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#142873" title="S">i</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="Kleisli.scala.html#112870" title="[L[+_]](implicit evidence$1: scalaz.Applicative[L])scalaz.Kleisli[[+α]L[scalaz.Id.Id[α]],S,G[D]]">lift</a><a href="Free.scala.html#44516" title="(implicit evidence$1: scalaz.Applicative[scalaz.Free.Trampoline])scalaz.Kleisli[[+α]scalaz.Free.Trampoline[scalaz.Id.Id[α]],S,G[D]]" class="delimiter">[</a><a href="Free.scala.html#10907" title="scalaz.Free.Trampoline">Trampoline</a><span class="delimiter">]</span><span class="delimiter">)</span>
      <a href="#142711" title="scalaz.Kleisli[[+A]scalaz.Free[Function0,A],S,G[F[C,D]]]">kl</a>.<a href="Kleisli.scala.html#112818" title="(a: S)scalaz.Free[Function0,G[F[C,D]]]">run</a><span class="delimiter">(</span><a href="#142710" title="S">s</a><span class="delimiter">)</span>.<a href="Free.scala.html#48263" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,G[F[C,D]]],scalaz.Free.Trampoline[G[F[C,D]]]])G[F[C,D]]">run</a>
    <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[A, B, C](fa: F[A,B], z: C)(f: (C, A) =&gt; C)(g: (C, B) =&gt; C)(C, F[Unit,Unit])" id="72611">bifoldLShape</a><span class="delimiter">[</span><a title="" id="72615">A</a>,<a title="" id="72616">B</a>,<a title="" id="72617">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="143058">fa</a>: <a href="#22877" title="F[A,B]">F</a><span class="delimiter">[</span>A,B<span class="delimiter">]</span>, <a title="C" id="143059">z</a>: <a href="#72617" title="C">C</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(C, A) =&gt; C" id="143060">f</a>: <span class="delimiter">(</span>C,A<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><a title="(C, B) =&gt; C" id="143061">g</a>: <span class="delimiter">(</span>C,B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <span title="(C, F[Unit,Unit])" class="delimiter">(</span>C, F<span class="delimiter">[</span>Unit, Unit<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#72574" title="(fa: F[A,B], s: C)(f: A =&gt; scalaz.State[C,Unit])(g: B =&gt; scalaz.State[C,Unit])(C, F[Unit,Unit])">runBitraverseS</a><span class="delimiter">(</span><a href="#143058" title="F[A,B]">fa</a>, <a href="#143059" title="C">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="143086">a</a> =&gt; <a href="package.scala.html#30741" title="scalaz.State.type">State</a>.<a href="State.scala.html#45087" title="(f: C =&gt; C)scalaz.State[C,Unit]">modify</a><span class="delimiter">(</span><a href="#143060" title="(v1: C, v2: A)C">f</a><span class="delimiter">(</span><a href="#143093" title="C">_</a>,<a href="#143086" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="B" id="143101">b</a> =&gt; <a href="package.scala.html#30741" title="scalaz.State.type">State</a>.<a href="State.scala.html#45087" title="(f: C =&gt; C)scalaz.State[C,Unit]">modify</a><span class="delimiter">(</span><a href="#143061" title="(v1: C, v2: B)C">g</a><span class="delimiter">(</span><a href="#143105" title="C">_</a>,<a href="#143101" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[G[_], A, B](x: F[G[A],G[B]])(implicit evidence$9: scalaz.Applicative[G])G[F[A,B]]" id="143113">bisequence</a><span class="delimiter">[</span><a title="[_]" id="72622">G</a><span class="delimiter">[</span><a title="" id="143114">_</a><span class="delimiter">]</span> : Applicative, <a title="" id="72623">A</a>, <a title="" id="72624">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[G[A],G[B]]" id="143112">x</a>: <a href="#22877" title="F[G[A],G[B]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>A<span class="delimiter">]</span>, G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#72622" title="G[F[A,B]]">G</a><span class="delimiter">[</span>F<span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#80703" title="(fab: F[G[A],G[B]])(f: G[A] =&gt; G[A], g: G[B] =&gt; G[B])(implicit evidence$1: scalaz.Applicative[G])G[F[A,B]]">bitraverseImpl</a><span class="delimiter">(</span><a href="#143112" title="F[G[A],G[B]]">x</a><span class="delimiter">)</span><a href="#143113" title="scalaz.Applicative[G]" class="delimiter">(</a><a title="G[A]" id="143139">fa</a> =&gt; <a href="#143139" title="G[A]">fa</a>, <a title="G[B]" id="143141">fb</a> =&gt; <a href="#143141" title="G[B]">fb</a><span class="delimiter">)</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B, C](fa: F[A,B], z: C)(f: (C, A) =&gt; C)(g: (C, B) =&gt; C)C" id="72625">bifoldLeft</a><span class="delimiter">[</span><a title="" id="72629">A</a>,<a title="" id="72630">B</a>,<a title="" id="72631">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="141442">fa</a>: <a href="#22877" title="F[A,B]">F</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>, <a title="C" id="141443">z</a>: <a href="#72631" title="C">C</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(C, A) =&gt; C" id="141444">f</a>: <span class="delimiter">(</span>C, A<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><a title="(C, B) =&gt; C" id="141445">g</a>: <span class="delimiter">(</span>C, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#72631" title="C">C</a> =
    <a href="#72611" title="(fa: F[A,B], z: C)(f: (C, A) =&gt; C)(g: (C, B) =&gt; C)(C, F[Unit,Unit])">bifoldLShape</a><span class="delimiter">(</span><a href="#141442" title="F[A,B]">fa</a>, <a href="#141443" title="C">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#141444" title="(C, A) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#141445" title="(C, B) =&gt; C">g</a><span class="delimiter">)</span>.<span title="=&gt; C">_1</span>

  <span class="keyword">def</span> <a title="[A, B, M](fa: F[A,B])(f: A =&gt; M)(g: B =&gt; M)(implicit F: scalaz.Monoid[M])M" id="72632">bifoldMap</a><span class="delimiter">[</span><a title="" id="72636">A</a>,<a title="" id="72637">B</a>,<a title="" id="72638">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="141499">fa</a>: <a href="#22877" title="F[A,B]">F</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; M" id="141500">f</a>: A =&gt; M<span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; M" id="141501">g</a>: B =&gt; M<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monoid[M]" id="141502">F</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[M]">Monoid</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#72638" title="M">M</a> =
    <a href="#72611" title="(fa: F[A,B], z: M)(f: (M, A) =&gt; M)(g: (M, B) =&gt; M)(M, F[Unit,Unit])">bifoldLShape</a><span class="delimiter">(</span><a href="#141499" title="F[A,B]">fa</a>, <a href="#141502" title="scalaz.Monoid[M]">F</a>.<a href="Monoid.scala.html#51158" title="=&gt; M">zero</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="M" id="143182">m</a>, <a title="A" id="143183">a</a><span class="delimiter">)</span> =&gt; <a href="#141502" title="scalaz.Monoid[M]">F</a>.<a href="Semigroup.scala.html#51147" title="(f1: M, f2: =&gt; M)M">append</a><span class="delimiter">(</span><a href="#143182" title="M">m</a>, <a href="#141500" title="(v1: A)M">f</a><span class="delimiter">(</span><a href="#143183" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="M" id="143188">m</a>, <a title="B" id="143189">b</a><span class="delimiter">)</span> =&gt; <a href="#141502" title="scalaz.Monoid[M]">F</a>.<a href="Semigroup.scala.html#51147" title="(f1: M, f2: =&gt; M)M">append</a><span class="delimiter">(</span><a href="#143188" title="M">m</a>, <a href="#141501" title="(v1: B)M">g</a><span class="delimiter">(</span><a href="#143189" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; M">_1</span>

  <span class="keyword">def</span> <a title="[A, B, C](fa: F[A,B], z: =&gt; C)(f: (A, =&gt; C) =&gt; C)(g: (B, =&gt; C) =&gt; C)C" id="72639">bifoldRight</a><span class="delimiter">[</span><a title="" id="72643">A</a>,<a title="" id="72644">B</a>,<a title="" id="72645">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="141473">fa</a>: <a href="#22877" title="F[A,B]">F</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>, <a title="=&gt; C" id="141474">z</a>: =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, =&gt; C) =&gt; C" id="141475">f</a>: <span class="delimiter">(</span>A, =&gt; C<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, =&gt; C) =&gt; C" id="141476">g</a>: <span class="delimiter">(</span>B, =&gt; C<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#72645" title="C">C</a> =
    <a href="#72632" title="(fa: F[A,B])(f: A =&gt; scalaz.Endo[C])(g: B =&gt; scalaz.Endo[C])(implicit F: scalaz.Monoid[scalaz.Endo[C]])scalaz.Endo[C]">bifoldMap</a><span class="delimiter">(</span><a href="#141473" title="F[A,B]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span>a: <a href="#72643" title="A">A</a><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span><a href="Endo.scala.html#10845" title="scalaz.Endo.type">Endo</a>.<a href="Endo.scala.html#51344" title="(f: C =&gt; C)scalaz.Endo[C]">endo</a><span class="delimiter">(</span><a href="#141475" title="(v1: A, v2: =&gt; C)C">f</a><span class="delimiter">(</span><a href="#143216" title="A">a</a>, <a href="#143220" title="C">_</a>: <a href="#72645" title="C">C</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><a href="Endo.scala.html#51363" title="scalaz.Monoid[scalaz.Endo[C]]" class="delimiter">(</a><span class="delimiter">(</span>b: <a href="#72644" title="B">B</a><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span><a href="Endo.scala.html#10845" title="scalaz.Endo.type">Endo</a>.<a href="Endo.scala.html#51344" title="(f: C =&gt; C)scalaz.Endo[C]">endo</a><span class="delimiter">(</span><a href="#141476" title="(v1: B, v2: =&gt; C)C">g</a><span class="delimiter">(</span><a href="#143233" title="B">b</a>, <a href="#143237" title="C">_</a>: <a href="#72645" title="C">C</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Endo.scala.html#51379" title="(a: C)C">apply</a> <a href="#141474" title="=&gt; C">z</a>

  ////
  <span class="keyword">val</span> <a title="bitraverseSyntax extends AnyRef with scalaz.syntax.BitraverseSyntax[F]" id="72646">bitraverseSyntax</a> = <a href="#141349" title="scalaz.syntax.BitraverseSyntax[F]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.syntax.BitraverseSyntax[F]" id="141349">scalaz</a>.syntax.<a href="syntax/BitraverseSyntax.scala.html#27622" title="scalaz.syntax.BitraverseSyntax[F]">BitraverseSyntax</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Bitraverse[F]" id="141358">F</a> = <a href="#12491" title="scalaz.Bitraverse[F]">Bitraverse</a>.<span class="keyword">this</span> <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="scalaz.Bitraverse.type" id="12492">Bitraverse</a> <a href="#12493" title="scalaz.Bitraverse.type" class="delimiter">{</a>
  @inline <span class="keyword">def</span> <a title="[F[_, _]](implicit F: scalaz.Bitraverse[F])scalaz.Bitraverse[F]" id="143247">apply</a><span class="delimiter">[</span><a title="[_, _]" id="143249">F</a><span class="delimiter">[</span><a title="" id="143252">_</a>, <a title="" id="143253">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bitraverse[F]" id="143251">F</a>: <a href="#12491" title="scalaz.Bitraverse[F]">Bitraverse</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#12491" title="scalaz.Bitraverse[F]">Bitraverse</a><span class="delimiter">[</span>F<span class="delimiter">]</span> = <a href="#143251" title="scalaz.Bitraverse[F]">F</a>

  ////

  ////
<span class="delimiter">}</span>

        </pre>
    </body>
</html>