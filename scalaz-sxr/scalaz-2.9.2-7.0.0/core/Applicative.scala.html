<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/Applicative.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz

////
/**
 * Applicative Functor, described in [[http://www.soi.city.ac.uk/~ross/papers/Applicative.html Applicative Programming with Effects]]
 *
 * Whereas a [[scalaz.Functor]] allows application of a pure function to a value in a context, an Applicative
 * also allows application of a function in a context to a value in a context (`ap`).
 *
 * It follows that a pure function can be applied to arguments in a context. (See `map2`, `map3`, ... )
 *
 * Applicative instances come in a few flavours:
 *  - All [[scalaz.Monad]]s are also `Applicative`
 *  - Any [[scalaz.Monoid]] can be treated as an Applicative (see [[scalaz.Monoid]]#applicative)
 *  - Zipping together corresponding elements of Naperian data structures (those of of a fixed, possibly infinite shape)
 *
 *  @see [[scalaz.Applicative.ApplicativeLaw]]
 */
////
<span class="keyword">trait</span> <a title="trait Applicative[F[_]] extends AnyRef with scalaz.Apply[F]" id="15416">Applicative</a><span class="delimiter">[</span><a title="[_]" id="22829">F</a><span class="delimiter">[</span><a title="" id="48602">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="Apply.scala.html#17291" title="scalaz.Apply[F]">Apply</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span> self =&gt;
  ////
  <span class="keyword">def</span> <a title="[A](a: =&gt; A)F[A]" id="34510">point</a><span class="delimiter">[</span><a title="" id="34512">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="48601">a</a>: =&gt; A<span class="delimiter">)</span>: <a href="#22829" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>

  // alias for point
  <span class="keyword">def</span> <a title="[A](a: =&gt; A)F[A]" id="34513">pure</a><span class="delimiter">[</span><a title="" id="34515">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="115462">a</a>: =&gt; A<span class="delimiter">)</span>: <a href="#22829" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#34510" title="(a: =&gt; A)F[A]">point</a><span class="delimiter">(</span><a href="#115462" title="=&gt; A">a</a><span class="delimiter">)</span>

  // derived functions
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](fa: F[A])(f: A =&gt; B)F[B]" id="34516">map</a><span class="delimiter">[</span><a title="" id="34519">A</a>, <a title="" id="34520">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="50939">fa</a>: <a href="#22829" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="50940">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#22829" title="F[B]">F</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
    <a href="Apply.scala.html#33953" title="(fa: =&gt; F[A])(f: =&gt; F[A =&gt; B])F[B]">ap</a><span class="delimiter">(</span><a href="#50939" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#34510" title="(a: =&gt; A =&gt; B)F[A =&gt; B]">point</a><span class="delimiter">(</span><a href="#50940" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B, C](fa: =&gt; F[A], fb: =&gt; F[B])(f: (A, B) =&gt; C)F[C]" id="34521">apply2</a><span class="delimiter">[</span><a title="" id="34525">A</a>, <a title="" id="34526">B</a>, <a title="" id="34527">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; F[A]" id="69913">fa</a>: =&gt; F<span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="=&gt; F[B]" id="69914">fb</a>: =&gt; F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="69915">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#22829" title="F[C]">F</a><span class="delimiter">[</span>C<span class="delimiter">]</span> =
    <a href="Apply.scala.html#33982" title="(fa: =&gt; F[A], fb: =&gt; F[B])(f: F[(A, B) =&gt; C])F[C]">ap2</a><span class="delimiter">(</span><a href="#69913" title="=&gt; F[A]">fa</a>, <a href="#69914" title="=&gt; F[B]">fb</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#34510" title="(a: =&gt; (A, B) =&gt; C)F[(A, B) =&gt; C]">point</a><span class="delimiter">(</span><a href="#69915" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  // impls of sequence, traverse, etc

  <span class="keyword">def</span> <a title="[A, G[_], B](value: G[A])(f: A =&gt; F[B])(implicit G: scalaz.Traverse[G])F[G[B]]" id="34528">traverse</a><span class="delimiter">[</span><a title="" id="34532">A</a>, <a title="[_]" id="34533">G</a><span class="delimiter">[</span><a title="" id="115512">_</a><span class="delimiter">]</span>, <a title="" id="34534">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="G[A]" id="115509">value</a>: <a href="#34533" title="G[A]">G</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; F[B]" id="115510">f</a>: A =&gt; F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Traverse[G]" id="115511">G</a>: <a href="Traverse.scala.html#20819" title="scalaz.Traverse[G]">Traverse</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#22829" title="F[G[B]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#115511" title="scalaz.Traverse[G]">G</a>.<a href="Traverse.scala.html#33494" title="(fa: G[A])(f: A =&gt; F[B])(implicit evidence$3: scalaz.Applicative[F])F[G[B]]">traverse</a><span class="delimiter">(</span><a href="#115509" title="G[A]">value</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#115510" title="A =&gt; F[B]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#15416" title="scalaz.Applicative[F]" class="keyword">this</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[A, G[_]](as: G[F[A]])(implicit evidence$1: scalaz.Traverse[G])F[G[A]]" id="115546">sequence</a><span class="delimiter">[</span><a title="" id="34538">A</a>, <a title="[_]" id="34539">G</a><span class="delimiter">[</span><a title="" id="115547">_</a><span class="delimiter">]</span>: Traverse<span class="delimiter">]</span><span class="delimiter">(</span><a title="G[F[A]]" id="115545">as</a>: <a href="#34539" title="G[F[A]]">G</a><span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#22829" title="F[G[A]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#34528" title="(value: G[F[A]])(f: F[A] =&gt; F[A])(implicit G: scalaz.Traverse[G])F[G[A]]">traverse</a><span class="delimiter">(</span><a href="#115545" title="G[F[A]]">as</a><span class="delimiter">)</span><a href="#115546" title="scalaz.Traverse[G]" class="delimiter">(</a><a title="F[A]" id="115566">a</a> =&gt; <a href="#115566" title="F[A]">a</a><span class="delimiter">)</span>

  <span class="keyword">import</span> std.<a href="std/List.scala.html#25475" title="scalaz.std.list.type">list</a>._

  /** Performs the action `n` times, returning the list of results. */
  <span class="keyword">def</span> <a title="[A](n: Int, fa: F[A])F[List[A]]" id="34541">replicateM</a><span class="delimiter">[</span><a title="" id="34543">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="115570">n</a>: <span title="Int">Int</span>, <a title="F[A]" id="115571">fa</a>: <a href="#22829" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#22829" title="F[List[A]]">F</a><span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="std/List.scala.html#45739" title="=&gt; scalaz.Traverse[List] with scalaz.MonadPlus[List] with scalaz.Each[List] with scalaz.Index[List] with scalaz.Length[List] with scalaz.Zip[List] with scalaz.Unzip[List] with scalaz.IsEmpty[List]{def empty[A]: List[Nothing]}">listInstance</a>.<a href="Traverse.scala.html#33538" title="(fga: List[F[A]])(implicit evidence$6: scalaz.Applicative[F])F[List[A]]">sequence</a><span class="delimiter">(</span><span title="scala.collection.immutable.List.type">List</span>.<span title="(n: Int)(elem: =&gt; F[A])List[F[A]]">fill</span><span class="delimiter">(</span><a href="#115570" title="Int">n</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#115571" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#15416" title="scalaz.Applicative[F]" class="keyword">this</a><span class="delimiter">)</span>

  /** Performs the action `n` times, returning nothing. */
  <span class="keyword">def</span> <a title="[A](n: Int, fa: F[A])F[Unit]" id="34544">replicateM_</a><span class="delimiter">[</span><a title="" id="34546">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="115685">n</a>: <span title="Int">Int</span>, <a title="F[A]" id="115686">fa</a>: <a href="#22829" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#22829" title="F[Unit]">F</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> =
    <a href="std/List.scala.html#45739" title="=&gt; scalaz.Traverse[List] with scalaz.MonadPlus[List] with scalaz.Each[List] with scalaz.Index[List] with scalaz.Length[List] with scalaz.Zip[List] with scalaz.Unzip[List] with scalaz.IsEmpty[List]{def empty[A]: List[Nothing]}">listInstance</a>.<a href="Foldable.scala.html#33717" title="(fa: List[F[A]])(implicit a: scalaz.Applicative[F])F[Unit]">sequence_</a><span class="delimiter">(</span><span title="scala.collection.immutable.List.type">List</span>.<span title="(n: Int)(elem: =&gt; F[A])List[F[A]]">fill</span><span class="delimiter">(</span><a href="#115685" title="Int">n</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#115686" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#15416" title="scalaz.Applicative[F]" class="keyword">this</a><span class="delimiter">)</span>

  /** Filter `l` according to an applicative predicate. */
  <span class="keyword">def</span> <a title="[A](l: List[A])(f: A =&gt; F[Boolean])F[List[A]]" id="34547">filterM</a><span class="delimiter">[</span><a title="" id="34549">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="List[A]" id="115742">l</a>: <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; F[Boolean]" id="115743">f</a>: A =&gt; F<span class="delimiter">[</span>Boolean<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#22829" title="F[List[A]]">F</a><span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#115742" title="List[A]">l</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#1675138" title="F[List[A]]">Nil</a> =&gt; <a href="#34510" title="(a: =&gt; List[A])F[List[A]]">point</a><a href="#1675143" title="(x: F[List[A]])F[List[A]]" class="delimiter">(</a>List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#1675140" title="A" id="115824">h</a> <a href="#1675138" title="F[List[A]]">::</a> <a href="#1675140" title="List[A]" id="115825">t</a> =&gt; <a href="Apply.scala.html#33953" title="(fa: =&gt; F[List[A]])(f: =&gt; F[List[A] =&gt; List[A]])F[List[A]]">ap</a><span class="delimiter">(</span><a href="#34547" title="(l: List[A])(f: A =&gt; F[Boolean])F[List[A]]">filterM</a><span class="delimiter">(</span><a href="#115825" title="List[A]">t</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#115743" title="A =&gt; F[Boolean]">f</a><span class="delimiter">)</span><span class="delimiter">)</span><a href="#1675143" title="(x: F[List[A]])F[List[A]]" class="delimiter">(</a><a href="#34516" title="(fa: F[Boolean])(f: Boolean =&gt; (List[A] =&gt; List[A]))F[List[A] =&gt; List[A]]">map</a><span class="delimiter">(</span><a href="#115743" title="(v1: A)F[Boolean]">f</a><span class="delimiter">(</span><a href="#115824" title="A">h</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Boolean" id="115870">b</a> =&gt; <a title="List[A]" id="115872">t</a> =&gt; <span title="List[A]" class="keyword">if</span> <span class="delimiter">(</span><a href="#115870" title="Boolean">b</a><span class="delimiter">)</span> <a href="#115824" title="A">h</a> <a href="#115873" title="(x: A)List[A]">::</a> <a href="#115872" title="List[A]">t</a> <span class="keyword">else</span> <a href="#115872" title="List[A]">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  /**The composition of Applicatives `F` and `G`, `[x]F[G[x]]`, is an Applicative */
  <span class="keyword">def</span> <a title="[G[_]](implicit G0: scalaz.Applicative[G])scalaz.Applicative[[α]F[G[α]]]" id="34550">compose</a><span class="delimiter">[</span><a title="[_]" id="34552">G</a><span class="delimiter">[</span><a title="" id="75772">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[G]" id="75768">G0</a>: <a href="#15416" title="scalaz.Applicative[G]">Applicative</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#15416" title="scalaz.Applicative[[α]F[G[α]]]">Applicative</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = F<span class="delimiter">[</span>G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#115885" title="scalaz.CompositionApplicative[F,G]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.CompositionApplicative[F,G]" id="115885">CompositionApplicative</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Applicative[F]" id="115898">F</a> = <a href="#15416" title="scalaz.Applicative[F]">self</a>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Applicative[G]" id="115899">G</a> = <a href="#75768" title="scalaz.Applicative[G]">G0</a>
  <span class="delimiter">}</span>

  /**The product of Applicatives `F` and `G`, `[x](F[x], G[x]])`, is an Applicative */
  <span class="keyword">def</span> <a title="[G[_]](implicit G0: scalaz.Applicative[G])scalaz.Applicative[[α](F[α], G[α])]" id="34553">product</a><span class="delimiter">[</span><a title="[_]" id="34555">G</a><span class="delimiter">[</span><a title="" id="75737">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[G]" id="75733">G0</a>: <a href="#15416" title="scalaz.Applicative[G]">Applicative</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#15416" title="scalaz.Applicative[[α](F[α], G[α])]">Applicative</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = <span class="delimiter">(</span>F<span class="delimiter">[</span>α<span class="delimiter">]</span>, G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#115974" title="scalaz.ProductApplicative[F,G]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.ProductApplicative[F,G]" id="115974">ProductApplicative</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Applicative[F]" id="115987">F</a> = <a href="#15416" title="scalaz.Applicative[F]">self</a>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Applicative[G]" id="115988">G</a> = <a href="#75733" title="scalaz.Applicative[G]">G0</a>
  <span class="delimiter">}</span>

  /** An `Applicative` for `F` in which effects happen in the opposite order. */
  <span class="keyword">def</span> <a title="=&gt; scalaz.Applicative[F]" id="34556">flip</a>: <a href="#15416" title="scalaz.Applicative[F]">Applicative</a><span class="delimiter">[</span>F<span class="delimiter">]</span> = <a href="#116063" title="scalaz.Applicative[F]{}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Applicative[F]" id="116063">Applicative</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="scalaz.Applicative[F]" id="116065">F</a> = <a href="#15416" title="scalaz.Applicative[F]">Applicative</a>.<span class="keyword">this</span>
    <span class="keyword">def</span> <a title="[A](a: =&gt; A)F[A]" id="116067">point</a><span class="delimiter">[</span><a title="" id="116069">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="116090">a</a>: =&gt; A<span class="delimiter">)</span> = <a href="#116065" title="=&gt; scalaz.Applicative[F]">F</a>.<a href="#34510" title="(a: =&gt; A)F[A]">point</a><span class="delimiter">(</span><a href="#116090" title="=&gt; A">a</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[A, B](fa: =&gt; F[A])(f: =&gt; F[A =&gt; B])F[B]" id="116070">ap</a><span class="delimiter">[</span><a title="" id="116073">A</a>,<a title="" id="116074">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; F[A]" id="116104">fa</a>: =&gt; F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; F[A =&gt; B]" id="116105">f</a>: =&gt; F<span class="delimiter">[</span>A =&gt; B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#22829" title="F[B]">F</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
      <a href="#116065" title="=&gt; scalaz.Applicative[F]">F</a>.<a href="Apply.scala.html#33953" title="(fa: =&gt; F[A =&gt; B])(f: =&gt; F[(A =&gt; B) =&gt; B])F[B]">ap</a><span class="delimiter">(</span><a href="#116105" title="=&gt; F[A =&gt; B]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#116065" title="=&gt; scalaz.Applicative[F]">F</a>.<a href="#34516" title="(fa: F[A])(f: A =&gt; ((A =&gt; B) =&gt; B))F[(A =&gt; B) =&gt; B]">map</a><span class="delimiter">(</span><a href="#116104" title="=&gt; F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="116142">a</a> =&gt; <span class="delimiter">(</span>f: A =&gt; B<span class="delimiter">)</span> =&gt; <a href="#116144" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#116142" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait ApplicativeLaw extends AnyRef with Applicative.this.FunctorLaw" id="34557">ApplicativeLaw</a> <span title="Unit" class="keyword">extends</span> <a href="Functor.scala.html#33467" title="Applicative.this.FunctorLaw">FunctorLaw</a> <span class="delimiter">{</span>
    /** `point(identity)` is a no-op. */
    <span class="keyword">def</span> <a title="[A](fa: F[A])(implicit FA: scalaz.Equal[F[A]])Boolean" id="116166">identityAp</a><span class="delimiter">[</span><a title="" id="116168">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="116193">fa</a>: <a href="#22829" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Equal[F[A]]" id="116194">FA</a>: <a href="Equal.scala.html#19253" title="scalaz.Equal[F[A]]">Equal</a><span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <a href="#116194" title="scalaz.Equal[F[A]]">FA</a>.<a href="Equal.scala.html#50753" title="(a1: F[A], a2: F[A])Boolean">equal</a><span class="delimiter">(</span><a href="Apply.scala.html#33953" title="(fa: =&gt; F[A])(f: =&gt; F[A =&gt; A])F[A]">ap</a><span class="delimiter">(</span><a href="#116193" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#34510" title="(a: =&gt; A =&gt; A)F[A =&gt; A]">point</a><span class="delimiter">(</span><span class="delimiter">(</span>a: <a href="#116168" title="A">A</a><span class="delimiter">)</span> =&gt; <a href="#116213" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#116193" title="F[A]">fa</a><span class="delimiter">)</span>

    /** Lifted functions can be fused. */
    <span class="keyword">def</span> <a title="[A, B, C](fbc: F[B =&gt; C], fab: F[A =&gt; B], fa: F[A])(implicit FC: scalaz.Equal[F[C]])Boolean" id="116169">composition</a><span class="delimiter">[</span><a title="" id="116173">A</a>, <a title="" id="116174">B</a>, <a title="" id="116175">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[B =&gt; C]" id="116217">fbc</a>: <a href="#22829" title="F[B =&gt; C]">F</a><span class="delimiter">[</span>B =&gt; C<span class="delimiter">]</span>, <a title="F[A =&gt; B]" id="116218">fab</a>: <a href="#22829" title="F[A =&gt; B]">F</a><span class="delimiter">[</span>A =&gt; B<span class="delimiter">]</span>, <a title="F[A]" id="116219">fa</a>: <a href="#22829" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Equal[F[C]]" id="116220">FC</a>: <a href="Equal.scala.html#19253" title="scalaz.Equal[F[C]]">Equal</a><span class="delimiter">[</span>F<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#116220" title="scalaz.Equal[F[C]]">FC</a>.<a href="Equal.scala.html#50753" title="(a1: F[C], a2: F[C])Boolean">equal</a><span class="delimiter">(</span><a href="Apply.scala.html#33953" title="(fa: =&gt; F[B])(f: =&gt; F[B =&gt; C])F[C]">ap</a><span class="delimiter">(</span><a href="Apply.scala.html#33953" title="(fa: =&gt; F[A])(f: =&gt; F[A =&gt; B])F[B]">ap</a><span class="delimiter">(</span><a href="#116219" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#116218" title="F[A =&gt; B]">fab</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#116217" title="F[B =&gt; C]">fbc</a><span class="delimiter">)</span>, <a href="Apply.scala.html#33953" title="(fa: =&gt; F[A])(f: =&gt; F[A =&gt; C])F[C]">ap</a><span class="delimiter">(</span><a href="#116219" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Apply.scala.html#33953" title="(fa: =&gt; F[A =&gt; B])(f: =&gt; F[(A =&gt; B) =&gt; (A =&gt; C)])F[A =&gt; C]">ap</a><span class="delimiter">(</span><a href="#116218" title="F[A =&gt; B]">fab</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Apply.scala.html#33953" title="(fa: =&gt; F[B =&gt; C])(f: =&gt; F[(B =&gt; C) =&gt; ((A =&gt; B) =&gt; (A =&gt; C))])F[(A =&gt; B) =&gt; (A =&gt; C)]">ap</a><span class="delimiter">(</span><a href="#116217" title="F[B =&gt; C]">fbc</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#34510" title="(a: =&gt; (B =&gt; C) =&gt; ((A =&gt; B) =&gt; (A =&gt; C)))F[(B =&gt; C) =&gt; ((A =&gt; B) =&gt; (A =&gt; C))]">point</a><span class="delimiter">(</span><span class="delimiter">(</span>bc: B =&gt; C<span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>ab: A =&gt; B<span class="delimiter">)</span> =&gt; <a href="#116272" title="B =&gt; C">bc</a> <span title="(g: A =&gt; B)A =&gt; C">compose</span> <a href="#116274" title="A =&gt; B">ab</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

    /** `point` distributes over function applications. */
    <span class="keyword">def</span> <a title="[A, B](ab: A =&gt; B, a: A)(implicit FB: scalaz.Equal[F[B]])Boolean" id="116176">homomorphism</a><span class="delimiter">[</span><a title="" id="116179">A</a>, <a title="" id="116180">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="116290">ab</a>: A =&gt; B, <a title="A" id="116291">a</a>: <a href="#116179" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Equal[F[B]]" id="116292">FB</a>: <a href="Equal.scala.html#19253" title="scalaz.Equal[F[B]]">Equal</a><span class="delimiter">[</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <a href="#116292" title="scalaz.Equal[F[B]]">FB</a>.<a href="Equal.scala.html#50753" title="(a1: F[B], a2: F[B])Boolean">equal</a><span class="delimiter">(</span><a href="Apply.scala.html#33953" title="(fa: =&gt; F[A])(f: =&gt; F[A =&gt; B])F[B]">ap</a><span class="delimiter">(</span><a href="#34510" title="(a: =&gt; A)F[A]">point</a><span class="delimiter">(</span><a href="#116291" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#34510" title="(a: =&gt; A =&gt; B)F[A =&gt; B]">point</a><span class="delimiter">(</span><a href="#116290" title="A =&gt; B">ab</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#34510" title="(a: =&gt; B)F[B]">point</a><span class="delimiter">(</span><a href="#116290" title="(v1: A)B">ab</a><span class="delimiter">(</span><a href="#116291" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

    /** `point` is a left and right identity, F-wise. */
    <span class="keyword">def</span> <a title="[A, B](f: F[A =&gt; B], a: A)(implicit FB: scalaz.Equal[F[B]])Boolean" id="116181">interchange</a><span class="delimiter">[</span><a title="" id="116184">A</a>, <a title="" id="116185">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A =&gt; B]" id="116319">f</a>: <a href="#22829" title="F[A =&gt; B]">F</a><span class="delimiter">[</span>A =&gt; B<span class="delimiter">]</span>, <a title="A" id="116320">a</a>: <a href="#116184" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Equal[F[B]]" id="116321">FB</a>: <a href="Equal.scala.html#19253" title="scalaz.Equal[F[B]]">Equal</a><span class="delimiter">[</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <a href="#116321" title="scalaz.Equal[F[B]]">FB</a>.<a href="Equal.scala.html#50753" title="(a1: F[B], a2: F[B])Boolean">equal</a><span class="delimiter">(</span><a href="Apply.scala.html#33953" title="(fa: =&gt; F[A])(f: =&gt; F[A =&gt; B])F[B]">ap</a><span class="delimiter">(</span><a href="#34510" title="(a: =&gt; A)F[A]">point</a><span class="delimiter">(</span><a href="#116320" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#116319" title="F[A =&gt; B]">f</a><span class="delimiter">)</span>, <a href="Apply.scala.html#33953" title="(fa: =&gt; F[A =&gt; B])(f: =&gt; F[(A =&gt; B) =&gt; B])F[B]">ap</a><span class="delimiter">(</span><a href="#116319" title="F[A =&gt; B]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#34510" title="(a: =&gt; (A =&gt; B) =&gt; B)F[(A =&gt; B) =&gt; B]">point</a><span class="delimiter">(</span><span class="delimiter">(</span>f: A =&gt; B<span class="delimiter">)</span> =&gt; <a href="#116352" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#116320" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

    /** `map` is like the one derived from `point` and `ap`. */
    <span class="keyword">def</span> <a title="[A, B](f: A =&gt; B, fa: F[A])(implicit FB: scalaz.Equal[F[B]])Boolean" id="116186">mapLikeDerived</a><span class="delimiter">[</span><a title="" id="116189">A</a>, <a title="" id="116190">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="116357">f</a>: A =&gt; B, <a title="F[A]" id="116358">fa</a>: <a href="#22829" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Equal[F[B]]" id="116359">FB</a>: <a href="Equal.scala.html#19253" title="scalaz.Equal[F[B]]">Equal</a><span class="delimiter">[</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      <a href="#116359" title="scalaz.Equal[F[B]]">FB</a>.<a href="Equal.scala.html#50753" title="(a1: F[B], a2: F[B])Boolean">equal</a><span class="delimiter">(</span><a href="#34516" title="(fa: F[A])(f: A =&gt; B)F[B]">map</a><span class="delimiter">(</span><a href="#116358" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#116357" title="A =&gt; B">f</a><span class="delimiter">)</span>, <a href="Apply.scala.html#33953" title="(fa: =&gt; F[A])(f: =&gt; F[A =&gt; B])F[B]">ap</a><span class="delimiter">(</span><a href="#116358" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#34510" title="(a: =&gt; A =&gt; B)F[A =&gt; B]">point</a><span class="delimiter">(</span><a href="#116357" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="=&gt; Applicative.this.ApplicativeLaw" id="34558">applicativeLaw</a> = <a href="#116395" title="Applicative.this.ApplicativeLaw" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Applicative.this.ApplicativeLaw" id="116395">ApplicativeLaw</a> <span class="delimiter">{</span><span class="delimiter">}</span>

  ////
  <span class="keyword">val</span> <a title="applicativeSyntax extends AnyRef with scalaz.syntax.ApplicativeSyntax[F]" id="34559">applicativeSyntax</a> = <a href="#115317" title="scalaz.syntax.ApplicativeSyntax[F]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.syntax.ApplicativeSyntax[F]" id="115317">scalaz</a>.syntax.<a href="syntax/ApplicativeSyntax.scala.html#26944" title="scalaz.syntax.ApplicativeSyntax[F]">ApplicativeSyntax</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Applicative[F]" id="115442">F</a> = <a href="#15416" title="scalaz.Applicative[F]">Applicative</a>.<span class="keyword">this</span> <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="scalaz.Applicative.type" id="15417">Applicative</a> <a href="#15418" title="scalaz.Applicative.type" class="delimiter">{</a>
  @inline <span class="keyword">def</span> <a title="[F[_]](implicit F: scalaz.Applicative[F])scalaz.Applicative[F]" id="51082">apply</a><span class="delimiter">[</span><a title="[_]" id="51084">F</a><span class="delimiter">[</span><a title="" id="51089">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[F]" id="51088">F</a>: <a href="#15416" title="scalaz.Applicative[F]">Applicative</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#15416" title="scalaz.Applicative[F]">Applicative</a><span class="delimiter">[</span>F<span class="delimiter">]</span> = <a href="#51088" title="scalaz.Applicative[F]">F</a>

  ////

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[M](implicit evidence$2: scalaz.Monoid[M])scalaz.Applicative[[α]M]" id="72102">monoidApplicative</a><span class="delimiter">[</span><a title="" id="51087">M</a>:Monoid<span class="delimiter">]</span>: <a href="#15416" title="scalaz.Applicative[[α]M]">Applicative</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = M<span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="Monoid.scala.html#51388" title="[F](implicit F: scalaz.Monoid[F])scalaz.Monoid[F]">Monoid</a><a href="#72102" title="(implicit F: scalaz.Monoid[M])scalaz.Monoid[M]" class="delimiter">[</a><a href="#51087" title="M">M</a><span class="delimiter">]</span>.<a href="Monoid.scala.html#51173" title="=&gt; scalaz.Applicative[[α]M]">applicative</a>

  ////
<span class="delimiter">}</span>

        </pre>
    </body>
</html>