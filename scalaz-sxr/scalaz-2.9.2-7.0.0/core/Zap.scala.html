<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/Zap.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz

<span class="keyword">import</span> <a href="Id.scala.html#8190" title="scalaz.Id.type">Id</a>._

/** Functors that annihilate each other. */
<span class="keyword">trait</span> <a title="trait Zap[F[_], G[_]] extends AnyRef" id="13949">Zap</a><span class="delimiter">[</span><a title="[_]" id="23872">F</a><span class="delimiter">[</span><a title="" id="445437">_</a><span class="delimiter">]</span>, <a title="[_]" id="23873">G</a><span class="delimiter">[</span><a title="" id="445438">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span> self =&gt;
  <span class="keyword">def</span> <a title="[A, B, C](fa: F[A], gb: G[B])(f: (A, B) =&gt; C)C" id="75359">zapWith</a><span class="delimiter">[</span><a title="" id="75363">A</a>, <a title="" id="75364">B</a>, <a title="" id="75365">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="75478">fa</a>: <a href="#23872" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="G[B]" id="75479">gb</a>: <a href="#23873" title="G[B]">G</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="75480">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#75365" title="C">C</a>
  <span class="keyword">def</span> <a title="[A, B](f: F[A =&gt; B], g: G[A])B" id="75366">zap</a><span class="delimiter">[</span><a title="" id="75369">A</a>, <a title="" id="75370">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A =&gt; B]" id="445440">f</a>: <a href="#23872" title="F[A =&gt; B]">F</a><span class="delimiter">[</span>A =&gt; B<span class="delimiter">]</span>, <a title="G[A]" id="445441">g</a>: <a href="#23873" title="G[A]">G</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#75370" title="B">B</a> = <a href="#75359" title="(fa: F[A =&gt; B], gb: G[A])(f: (A =&gt; B, A) =&gt; B)B">zapWith</a><span class="delimiter">(</span><a href="#445440" title="F[A =&gt; B]">f</a>, <a href="#445441" title="G[A]">g</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#445456" title="(v1: A)B">_</a><span class="delimiter">(</span><a href="#445457" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="=&gt; scalaz.Zap[G,F]" id="75371">flip</a>: <a href="#13949" title="scalaz.Zap[G,F]">Zap</a><span class="delimiter">[</span>G, F<span class="delimiter">]</span> = <a href="#445461" title="scalaz.Zap[G,F]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Zap[G,F]" id="445461">Zap</a><span class="delimiter">[</span>G, F<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B, C](ga: G[A], fb: F[B])(f: (A, B) =&gt; C)C" id="445463">zapWith</a><span class="delimiter">[</span><a title="" id="445467">A</a>, <a title="" id="445468">B</a>, <a title="" id="445469">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="G[A]" id="445471">ga</a>: <a href="#23873" title="G[A]">G</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="F[B]" id="445472">fb</a>: <a href="#23872" title="F[B]">F</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="445473">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#445469" title="C">C</a> =
      <a href="#13949" title="Zap.this.type">self</a>.<a href="#75359" title="(fa: F[B], gb: G[A])(f: (B, A) =&gt; C)C">zapWith</a><span class="delimiter">(</span><a href="#445472" title="F[B]">fb</a>, <a href="#445471" title="G[A]">ga</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="B" id="445506">b</a>, <a title="A" id="445507">a</a><span class="delimiter">)</span> =&gt; <a href="#445473" title="(v1: A, v2: B)C">f</a><span class="delimiter">(</span><a href="#445507" title="A">a</a>, <a href="#445506" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait ZapInstances extends AnyRef" id="19772">ZapInstances</a> <span title="Unit" class="delimiter">{</span>

  /** The identity functor annihilates itself. */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Zap[scalaz.Id.Id,scalaz.Id.Id]" id="144609">identityZap</a>: <a href="#13949" title="scalaz.Zap[scalaz.Id.Id,scalaz.Id.Id]">Zap</a><span class="delimiter">[</span>Id, Id<span class="delimiter">]</span> = <a href="#445518" title="scalaz.Zap[scalaz.Id.Id,scalaz.Id.Id]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Zap[scalaz.Id.Id,scalaz.Id.Id]" id="445518">Zap</a><span class="delimiter">[</span>Id, Id<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B, C](a: A, b: B)(f: (A, B) =&gt; C)C" id="445520">zapWith</a><span class="delimiter">[</span><a title="" id="445524">A</a>, <a title="" id="445525">B</a>, <a title="" id="445526">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="445528">a</a>: <a href="#445524" title="A">A</a>, <a title="B" id="445529">b</a>: <a href="#445525" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="445530">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#445526" title="C">C</a> = <a href="#445530" title="(v1: A, v2: B)C">f</a><span class="delimiter">(</span><a href="#445528" title="A">a</a>, <a href="#445529" title="B">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** The product of two functors annihilates their coproduct. */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[F[_], FF[_], G[_], GG[_]](implicit d1: scalaz.Zap[F,FF], implicit d2: scalaz.Zap[G,GG])scalaz.Zap[[α]scalaz.\/[F[α],G[α]],[α](FF[α], GG[α])]" id="144611">productCoproductZap</a><span class="delimiter">[</span><a title="[_]" id="144616">F</a><span class="delimiter">[</span><a title="" id="445561">_</a><span class="delimiter">]</span>, <a title="[_]" id="144617">FF</a><span class="delimiter">[</span><a title="" id="445568">_</a><span class="delimiter">]</span>, <a title="[_]" id="144618">G</a><span class="delimiter">[</span><a title="" id="445562">_</a><span class="delimiter">]</span>, <a title="[_]" id="144619">GG</a><span class="delimiter">[</span><a title="" id="445569">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Zap[F,FF]" id="445556">d1</a>: <a href="#13949" title="scalaz.Zap[F,FF]">Zap</a><span class="delimiter">[</span>F, FF<span class="delimiter">]</span>, <a title="scalaz.Zap[G,GG]" id="445557">d2</a>: <a href="#13949" title="scalaz.Zap[G,GG]">Zap</a><span class="delimiter">[</span>G, GG<span class="delimiter">]</span><span class="delimiter">)</span>:
    <a href="#13949" title="scalaz.Zap[[α]scalaz.\/[F[α],G[α]],[α](FF[α], GG[α])]">Zap</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = <span class="delimiter">(</span>F<span class="delimiter">[</span>α<span class="delimiter">]</span> \/ G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>#λ, <span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = <span class="delimiter">(</span>FF<span class="delimiter">[</span>α<span class="delimiter">]</span>, GG<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> =
      <a href="#445578" title="scalaz.Zap[[α]scalaz.\/[F[α],G[α]],[α](FF[α], GG[α])]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Zap[[α]scalaz.\/[F[α],G[α]],[α](FF[α], GG[α])]" id="445578">Zap</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = <span class="delimiter">(</span>F<span class="delimiter">[</span>α<span class="delimiter">]</span> \/ G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>#λ, <span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = <span class="delimiter">(</span>FF<span class="delimiter">[</span>α<span class="delimiter">]</span>, GG<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="[A, B, C](a: scalaz.\/[F[A],G[A]], b: (FF[B], GG[B]))(f: (A, B) =&gt; C)C" id="445590">zapWith</a><span class="delimiter">[</span><a title="" id="445594">A</a>, <a title="" id="445595">B</a>, <a title="" id="445596">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.\/[F[A],G[A]]" id="445598">a</a>: <span class="delimiter">(</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="Either.scala.html#18614" title="scalaz.\/[F[A],G[A]]">\/</a> G<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>, <a title="(FF[B], GG[B])" id="445599">b</a>: <span title="(FF[B], GG[B])" class="delimiter">(</span>FF<span class="delimiter">[</span>B<span class="delimiter">]</span>, GG<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="445600">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span> =
          <a href="#445598" title="scalaz.\/[F[A],G[A]]">a</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> -\/<a href="#1681356" title="C" class="delimiter">(</a><a href="Either.scala.html#50471" title="F[A]" id="445624">fa</a><span class="delimiter">)</span> =&gt; <a href="#445556" title="scalaz.Zap[F,FF]">d1</a>.<a href="#75359" title="(fa: F[A], gb: FF[B])(f: (A, B) =&gt; C)C">zapWith</a><span class="delimiter">(</span><a href="#445624" title="F[A]">fa</a>, <a href="#445599" title="(FF[B], GG[B])">b</a>.<span title="=&gt; FF[B]">_1</span><span class="delimiter">)</span><a href="#1681360" title="(x: C)C" class="delimiter">(</a><a href="#445600" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span>
            <span class="keyword">case</span> \/-<a href="#1681356" title="C" class="delimiter">(</a><a href="Either.scala.html#50507" title="G[A]" id="445641">ga</a><span class="delimiter">)</span> =&gt; <a href="#445557" title="scalaz.Zap[G,GG]">d2</a>.<a href="#75359" title="(fa: G[A], gb: GG[B])(f: (A, B) =&gt; C)C">zapWith</a><span class="delimiter">(</span><a href="#445641" title="G[A]">ga</a>, <a href="#445599" title="(FF[B], GG[B])">b</a>.<span title="=&gt; GG[B]">_2</span><span class="delimiter">)</span><a href="#1681360" title="(x: C)C" class="delimiter">(</a><a href="#445600" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>

  /** The coproduct of two functors annihilates their product. */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[F[_], FF[_], G[_], GG[_]](implicit d1: scalaz.Zap[FF,F], implicit d2: scalaz.Zap[GG,G])scalaz.Zap[[α](FF[α], GG[α]),[α]scalaz.\/[F[α],G[α]]]" id="144620">coproductProductZap</a><span class="delimiter">[</span><a title="[_]" id="144625">F</a><span class="delimiter">[</span><a title="" id="445697">_</a><span class="delimiter">]</span>, <a title="[_]" id="144626">FF</a><span class="delimiter">[</span><a title="" id="445690">_</a><span class="delimiter">]</span>, <a title="[_]" id="144627">G</a><span class="delimiter">[</span><a title="" id="445698">_</a><span class="delimiter">]</span>, <a title="[_]" id="144628">GG</a><span class="delimiter">[</span><a title="" id="445691">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Zap[FF,F]" id="445685">d1</a>: <a href="#13949" title="scalaz.Zap[FF,F]">Zap</a><span class="delimiter">[</span>FF, F<span class="delimiter">]</span>, <a title="scalaz.Zap[GG,G]" id="445686">d2</a>: <a href="#13949" title="scalaz.Zap[GG,G]">Zap</a><span class="delimiter">[</span>GG, G<span class="delimiter">]</span><span class="delimiter">)</span>:
    <a href="#13949" title="scalaz.Zap[[α](FF[α], GG[α]),[α]scalaz.\/[F[α],G[α]]]">Zap</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = <span class="delimiter">(</span>FF<span class="delimiter">[</span>α<span class="delimiter">]</span>, GG<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>#λ, <span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = <span class="delimiter">(</span>F<span class="delimiter">[</span>α<span class="delimiter">]</span> \/ G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> =
      <a href="#445707" title="scalaz.Zap[[α](FF[α], GG[α]),[α]scalaz.\/[F[α],G[α]]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Zap[[α](FF[α], GG[α]),[α]scalaz.\/[F[α],G[α]]]" id="445707">Zap</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = <span class="delimiter">(</span>FF<span class="delimiter">[</span>α<span class="delimiter">]</span>, GG<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>#λ, <span class="delimiter">(</span><span class="delimiter">{</span> <span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = <span class="delimiter">(</span>F<span class="delimiter">[</span>α<span class="delimiter">]</span> \/ G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="[A, B, C](a: (FF[A], GG[A]), b: scalaz.\/[F[B],G[B]])(f: (A, B) =&gt; C)C" id="445719">zapWith</a><span class="delimiter">[</span><a title="" id="445723">A</a>, <a title="" id="445724">B</a>, <a title="" id="445725">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(FF[A], GG[A])" id="445727">a</a>: <span title="(FF[A], GG[A])" class="delimiter">(</span>FF<span class="delimiter">[</span>A<span class="delimiter">]</span>, GG<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>, <a title="scalaz.\/[F[B],G[B]]" id="445728">b</a>: <span class="delimiter">(</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span> <a href="Either.scala.html#18614" title="scalaz.\/[F[B],G[B]]">\/</a> G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="445729">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span> =
          <a href="#445728" title="scalaz.\/[F[B],G[B]]">b</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> -\/<a href="#1681365" title="C" class="delimiter">(</a><a href="Either.scala.html#50471" title="F[B]" id="445753">fb</a><span class="delimiter">)</span> =&gt; <a href="#445685" title="scalaz.Zap[FF,F]">d1</a>.<a href="#75359" title="(fa: FF[A], gb: F[B])(f: (A, B) =&gt; C)C">zapWith</a><span class="delimiter">(</span><a href="#445727" title="(FF[A], GG[A])">a</a>.<span title="=&gt; FF[A]">_1</span>, <a href="#445753" title="F[B]">fb</a><span class="delimiter">)</span><a href="#1681369" title="(x: C)C" class="delimiter">(</a><a href="#445729" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span>
            <span class="keyword">case</span> \/-<a href="#1681365" title="C" class="delimiter">(</a><a href="Either.scala.html#50507" title="G[B]" id="445770">gb</a><span class="delimiter">)</span> =&gt; <a href="#445686" title="scalaz.Zap[GG,G]">d2</a>.<a href="#75359" title="(fa: GG[A], gb: G[B])(f: (A, B) =&gt; C)C">zapWith</a><span class="delimiter">(</span><a href="#445727" title="(FF[A], GG[A])">a</a>.<span title="=&gt; GG[A]">_2</span>, <a href="#445770" title="G[B]">gb</a><span class="delimiter">)</span><a href="#1681369" title="(x: C)C" class="delimiter">(</a><a href="#445729" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>

  /** A free monad and a cofree comonad annihilate each other */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[F[+_], G[+_]](implicit d: scalaz.Zap[F,G], implicit F: scalaz.Functor[F], implicit G: scalaz.Functor[G])scalaz.Zap[[α]scalaz.Free[F,α],[α]scalaz.Cofree[G,α]]" id="144629">monadComonadZap</a><span class="delimiter">[</span><a title="[+_]" id="144632">F</a><span class="delimiter">[</span>+<a title="" id="286586">_</a><span class="delimiter">]</span>, <a title="[+_]" id="144633">G</a><span class="delimiter">[</span>+<a title="" id="286592">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Zap[F,G]" id="286580">d</a>: <a href="#13949" title="scalaz.Zap[F,G]">Zap</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span>, <a title="scalaz.Functor[F]" id="286581">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span>, <a title="scalaz.Functor[G]" id="286582">G</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[G]">Functor</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>:
    <a href="#13949" title="scalaz.Zap[[α]scalaz.Free[F,α],[α]scalaz.Cofree[G,α]]">Zap</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = Free<span class="delimiter">[</span>F, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ, <span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = Cofree<span class="delimiter">[</span>G, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> =
      <a href="#445818" title="scalaz.Zap[[α]scalaz.Free[F,α],[α]scalaz.Cofree[G,α]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Zap[[α]scalaz.Free[F,α],[α]scalaz.Cofree[G,α]]" id="445818">Zap</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = Free<span class="delimiter">[</span>F, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ, <span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = Cofree<span class="delimiter">[</span>G, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="[A, B, C](ma: scalaz.Free[F,A], wb: scalaz.Cofree[G,B])(f: (A, B) =&gt; C)C" id="445830">zapWith</a><span class="delimiter">[</span><a title="" id="445834">A</a>, <a title="" id="445835">B</a>, <a title="" id="445836">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[F,A]" id="445838">ma</a>: <a href="Free.scala.html#10907" title="scalaz.Free[F,A]">Free</a><span class="delimiter">[</span>F, A<span class="delimiter">]</span>, <a title="scalaz.Cofree[G,B]" id="445839">wb</a>: <a href="Cofree.scala.html#8798" title="scalaz.Cofree[G,B]">Cofree</a><span class="delimiter">[</span>G, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="445840">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#445836" title="C">C</a> =
          <a href="#445838" title="scalaz.Free[F,A]">ma</a>.<a href="Free.scala.html#48234" title="=&gt; scalaz.\/[F[scalaz.Free[F,A]],A]">resume</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> \/-<a href="#1681374" title="C" class="delimiter">(</a><a href="Either.scala.html#50507" title="A" id="445868">a</a><span class="delimiter">)</span> =&gt; <a href="#445840" title="(v1: A, v2: B)C">f</a><a href="#1681378" title="(x: C)C" class="delimiter">(</a><a href="#445868" title="A">a</a>, <a href="#445839" title="scalaz.Cofree[G,B]">wb</a>.<a href="Cofree.scala.html#144244" title="=&gt; B">head</a><span class="delimiter">)</span>
            <span class="keyword">case</span> -\/<a href="#1681374" title="C" class="delimiter">(</a><a href="Either.scala.html#50471" title="F[scalaz.Free[F,A]]" id="445874">k</a><span class="delimiter">)</span> =&gt; <a href="#286580" title="scalaz.Zap[F,G]">d</a>.<a href="#75359" title="(fa: F[scalaz.Free[F,A]], gb: G[scalaz.Cofree[G,B]])(f: (scalaz.Free[F,A], scalaz.Cofree[G,B]) =&gt; C)C">zapWith</a><span class="delimiter">(</span><a href="#445874" title="F[scalaz.Free[F,A]]">k</a>, <a href="#445839" title="scalaz.Cofree[G,B]">wb</a>.<a href="Cofree.scala.html#144246" title="=&gt; G[scalaz.Cofree[G,B]]">tail</a><span class="delimiter">)</span><a href="#1681378" title="(x: C)C" class="delimiter">(</a><a href="#445830" title="(ma: scalaz.Free[F,A], wb: scalaz.Cofree[G,B])(f: (A, B) =&gt; C)C">zapWith</a><span class="delimiter">(</span><a href="#445889" title="scalaz.Free[F,A]">_</a>, <a href="#445890" title="scalaz.Cofree[G,B]">_</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#445840" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>

  /** A cofree comonad and a free monad annihilate each other */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[F[+_], G[+_]](implicit d: scalaz.Zap[F,G], implicit F: scalaz.Functor[F], implicit G: scalaz.Functor[G])scalaz.Zap[[α]scalaz.Cofree[F,α],[α]scalaz.Free[G,α]]" id="144634">comonadMonadZap</a><span class="delimiter">[</span><a title="[+_]" id="144637">F</a><span class="delimiter">[</span>+<a title="" id="144646">_</a><span class="delimiter">]</span>, <a title="[+_]" id="144638">G</a><span class="delimiter">[</span>+<a title="" id="144652">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Zap[F,G]" id="144640">d</a>: <a href="#13949" title="scalaz.Zap[F,G]">Zap</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span>, <a title="scalaz.Functor[F]" id="144641">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span>, <a title="scalaz.Functor[G]" id="144642">G</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[G]">Functor</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>:
    <a href="#13949" title="scalaz.Zap[[α]scalaz.Cofree[F,α],[α]scalaz.Free[G,α]]">Zap</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = Cofree<span class="delimiter">[</span>F, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ, <span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = Free<span class="delimiter">[</span>G, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> =
      <a href="#445926" title="scalaz.Zap[[α]scalaz.Cofree[F,α],[α]scalaz.Free[G,α]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Zap[[α]scalaz.Cofree[F,α],[α]scalaz.Free[G,α]]" id="445926">Zap</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = Cofree<span class="delimiter">[</span>F, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ, <span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = Free<span class="delimiter">[</span>G, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="[A, B, C](wa: scalaz.Cofree[F,A], mb: scalaz.Free[G,B])(f: (A, B) =&gt; C)C" id="445938">zapWith</a><span class="delimiter">[</span><a title="" id="445942">A</a>, <a title="" id="445943">B</a>, <a title="" id="445944">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Cofree[F,A]" id="445946">wa</a>: <a href="Cofree.scala.html#8798" title="scalaz.Cofree[F,A]">Cofree</a><span class="delimiter">[</span>F, A<span class="delimiter">]</span>, <a title="scalaz.Free[G,B]" id="445947">mb</a>: <a href="Free.scala.html#10907" title="scalaz.Free[G,B]">Free</a><span class="delimiter">[</span>G, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="445948">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#445944" title="C">C</a> =
          <a href="#445947" title="scalaz.Free[G,B]">mb</a>.<a href="Free.scala.html#48234" title="=&gt; scalaz.\/[G[scalaz.Free[G,B]],B]">resume</a> <span class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> \/-<a href="#1681383" title="C" class="delimiter">(</a><a href="Either.scala.html#50507" title="B" id="445976">b</a><span class="delimiter">)</span> =&gt; <a href="#445948" title="(v1: A, v2: B)C">f</a><a href="#1681387" title="(x: C)C" class="delimiter">(</a><a href="#445946" title="scalaz.Cofree[F,A]">wa</a>.<a href="Cofree.scala.html#144244" title="=&gt; A">head</a>, <a href="#445976" title="B">b</a><span class="delimiter">)</span>
            <span class="keyword">case</span> -\/<a href="#1681383" title="C" class="delimiter">(</a><a href="Either.scala.html#50471" title="G[scalaz.Free[G,B]]" id="445982">k</a><span class="delimiter">)</span> =&gt; <a href="#144640" title="scalaz.Zap[F,G]">d</a>.<a href="#75359" title="(fa: F[scalaz.Cofree[F,A]], gb: G[scalaz.Free[G,B]])(f: (scalaz.Cofree[F,A], scalaz.Free[G,B]) =&gt; C)C">zapWith</a><span class="delimiter">(</span><a href="#445946" title="scalaz.Cofree[F,A]">wa</a>.<a href="Cofree.scala.html#144246" title="=&gt; F[scalaz.Cofree[F,A]]">tail</a>, <a href="#445982" title="G[scalaz.Free[G,B]]">k</a><span class="delimiter">)</span><a href="#1681387" title="(x: C)C" class="delimiter">(</a><a href="#445938" title="(wa: scalaz.Cofree[F,A], mb: scalaz.Free[G,B])(f: (A, B) =&gt; C)C">zapWith</a><span class="delimiter">(</span><a href="#445997" title="scalaz.Cofree[F,A]">_</a>, <a href="#445998" title="scalaz.Free[G,B]">_</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#445948" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="scalaz.Zap.type" id="13950">Zap</a> <a href="#13951" title="scalaz.Zap.type" class="keyword">extends</a> <a href="#19772" title="scalaz.ZapInstances">ZapInstances</a> 

        </pre>
    </body>
</html>