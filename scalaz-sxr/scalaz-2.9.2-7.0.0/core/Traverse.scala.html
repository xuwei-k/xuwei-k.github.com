<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/Traverse.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz

////
<span class="keyword">import</span> scalaz.<a href="Id.scala.html#8190" title="scalaz.Id.type">Id</a>.Id

/**
 * Idiomatic traversal of a structure, as described in
 * [[http://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf The Essence of the Iterator Pattern]].
 *
 * @see [[scalaz.Traverse.TraverseLaw]]
 */
////
<span class="keyword">trait</span> <a title="trait Traverse[F[_]] extends AnyRef with scalaz.Functor[F] with scalaz.Foldable[F]" id="20819">Traverse</a><span class="delimiter">[</span><a title="[_]" id="23766">F</a><span class="delimiter">[</span><a title="" id="51002">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="keyword">with</span> <a href="Foldable.scala.html#17390" title="scalaz.Foldable[F]">Foldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span> self =&gt;
  ////

  /** Transform `fa` using `f`, collecting all the `G`s with `ap`. */
  <span class="keyword">def</span> <a title="[G[_], A, B](fa: F[A])(f: A =&gt; G[B])(implicit evidence$1: scalaz.Applicative[G])G[F[B]]" id="51054">traverseImpl</a><span class="delimiter">[</span><a title="[_]" id="33477">G</a><span class="delimiter">[</span><a title="" id="51055">_</a><span class="delimiter">]</span>:Applicative,<a title="" id="33478">A</a>,<a title="" id="33479">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="51052">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; G[B]" id="51053">f</a>: A =&gt; G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33477" title="G[F[B]]">G</a><span class="delimiter">[</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span>

  // derived functions

  /**The composition of Traverses `F` and `G`, `[x]F[G[x]]`, is a Traverse */
  <span class="keyword">def</span> <a title="[G[_]](implicit G0: scalaz.Traverse[G])scalaz.Traverse[[α]F[G[α]]]" id="33480">compose</a><span class="delimiter">[</span><a title="[_]" id="33482">G</a><span class="delimiter">[</span><a title="" id="141752">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Traverse[G]" id="141748">G0</a>: <a href="#20819" title="scalaz.Traverse[G]">Traverse</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20819" title="scalaz.Traverse[[α]F[G[α]]]">Traverse</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = F<span class="delimiter">[</span>G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#423303" title="scalaz.CompositionTraverse[F,G]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.CompositionTraverse[F,G]" id="423303">CompositionTraverse</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Traverse[F]" id="423305">F</a> = <a href="#20819" title="scalaz.Traverse[F]">self</a>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Traverse[G]" id="423306">G</a> = <a href="#141748" title="scalaz.Traverse[G]">G0</a>
  <span class="delimiter">}</span>

  /**The product of Traverses `F` and `G`, `[x](F[x], G[x]])`, is a Traverse */
  <span class="keyword">def</span> <a title="[G[_]](implicit G0: scalaz.Traverse[G])scalaz.Traverse[[α](F[α], G[α])]" id="33483">product</a><span class="delimiter">[</span><a title="[_]" id="33485">G</a><span class="delimiter">[</span><a title="" id="141728">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Traverse[G]" id="141724">G0</a>: <a href="#20819" title="scalaz.Traverse[G]">Traverse</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20819" title="scalaz.Traverse[[α](F[α], G[α])]">Traverse</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = <span class="delimiter">(</span>F<span class="delimiter">[</span>α<span class="delimiter">]</span>, G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#423351" title="scalaz.ProductTraverse[F,G]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.ProductTraverse[F,G]" id="423351">ProductTraverse</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Traverse[F]" id="423353">F</a> = <a href="#20819" title="scalaz.Traverse[F]">self</a>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Traverse[G]" id="423354">G</a> = <a href="#141724" title="scalaz.Traverse[G]">G0</a>
  <span class="delimiter">}</span>

  <span class="keyword">class</span> <a title="class Traversal[G[_]] extends AnyRef" id="33486">Traversal</a><span class="delimiter">[</span><a title="[_]" id="33487">G</a><span class="delimiter">[</span><a title="" id="423405">_</a><span class="delimiter">]</span><span class="delimiter">]</span><a href="#33486" title="Traverse.this.Traversal[G]" class="delimiter">(</a><span class="keyword">implicit</span> <a title="scalaz.Applicative[G]" id="423408">G</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[G]">Applicative</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](fa: F[A])(f: A =&gt; G[B])G[F[B]]" id="423400">run</a><span class="delimiter">[</span><a title="" id="423403">A</a>,<a title="" id="423404">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="423409">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; G[B]" id="423410">f</a>: A =&gt; G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33487" title="G[F[B]]">G</a><span class="delimiter">[</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#51054" title="[G[_], A, B](fa: F[A])(f: A =&gt; G[B])(implicit evidence$1: scalaz.Applicative[G])G[F[B]]">traverseImpl</a><span title="(fa: F[A])(f: A =&gt; G[B])(implicit evidence$1: scalaz.Applicative[G])G[F[B]]" class="delimiter">[</span><a href="#33487" title="G">G</a>,<a href="#423403" title="A">A</a>,<a href="#423404" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#423409" title="F[A]">fa</a><span class="delimiter">)</span><a href="#423408" title="scalaz.Applicative[G]" class="delimiter">(</a><a href="#423410" title="A =&gt; G[B]">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  // reduce - given monoid
  <span class="keyword">def</span> <a title="[G[_]](implicit evidence$2: scalaz.Applicative[G])Traverse.this.Traversal[G]" id="423417">traversal</a><span class="delimiter">[</span><a title="[_]" id="33490">G</a><span class="delimiter">[</span><a title="" id="423418">_</a><span class="delimiter">]</span>:Applicative<span class="delimiter">]</span>: <a href="#33486" title="Traverse.this.Traversal[G]">Traversal</a><span class="delimiter">[</span>G<span class="delimiter">]</span> =
    <a href="#423417" title="Traverse.this.Traversal[G]" class="keyword">new</a> <a href="#33486" title="Traverse.this.Traversal[G]">Traversal</a><span class="delimiter">[</span>G<span class="delimiter">]</span>
  <span class="keyword">def</span> <a title="[S]=&gt; Traverse.this.Traversal[[x]scalaz.IndexedStateT[[+X]X,S,S,x]]" id="33491">traversalS</a><span class="delimiter">[</span><a title="" id="33493">S</a><span class="delimiter">]</span>: <a href="#33486" title="Traverse.this.Traversal[[x]scalaz.IndexedStateT[[+X]X,S,S,x]]">Traversal</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span>=State<span class="delimiter">[</span>S,x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> =
    <span title="Traverse.this.Traversal[[x]scalaz.IndexedStateT[[+X]X,S,S,x]]" class="keyword">new</span> <a href="#33486" title="Traverse.this.Traversal[[x]scalaz.IndexedStateT[[+X]X,S,S,x]]">Traversal</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span>=State<span class="delimiter">[</span>S,x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="package.scala.html#30737" title="scalaz.StateT.type">StateT</a>.<a href="StateT.scala.html#142094" title="scalaz.MonadState[[s, +a]scalaz.IndexedStateT[[+X]X,s,s,a],S]">stateMonad</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[G[_], A, B](fa: F[A])(f: A =&gt; G[B])(implicit evidence$3: scalaz.Applicative[G])G[F[B]]" id="115519">traverse</a><span class="delimiter">[</span><a title="[_]" id="33498">G</a><span class="delimiter">[</span><a title="" id="115520">_</a><span class="delimiter">]</span>:Applicative,<a title="" id="33499">A</a>,<a title="" id="33500">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="115517">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; G[B]" id="115518">f</a>: A =&gt; G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33498" title="G[F[B]]">G</a><span class="delimiter">[</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#423417" title="[G[_]](implicit evidence$2: scalaz.Applicative[G])Traverse.this.Traversal[G]">traversal</a><a href="#115519" title="(implicit evidence$2: scalaz.Applicative[G])Traverse.this.Traversal[G]" class="delimiter">[</a><a href="#33498" title="G">G</a><span class="delimiter">]</span>.<a href="#423400" title="(fa: F[A])(f: A =&gt; G[B])G[F[B]]">run</a><span class="delimiter">(</span><a href="#115517" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#115518" title="A =&gt; G[B]">f</a><span class="delimiter">)</span>

  /** A version of `traverse` that infers the type constructor `G`. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[A, GB](self: F[A])(f: A =&gt; GB)(implicit G: scalaz.Unapply[scalaz.Applicative,GB])G.M[F[G.A]]" id="33501">traverseU</a><span class="delimiter">[</span><a title="" id="33504">A</a>,<a title="" id="33505">GB</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="423462">self</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; GB" id="423463">f</a>: A =&gt; GB<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Unapply[scalaz.Applicative,GB]" id="423464">G</a>: <a href="Unapply.scala.html#18791" title="scalaz.Unapply[scalaz.Applicative,GB]">Unapply</a><span class="delimiter">[</span>Applicative, GB<span class="delimiter">]</span><span class="delimiter">)</span>: G.<a href="Unapply.scala.html#52637" title="G.M[F[G.A]]">M</a><span class="delimiter">[</span>F<span class="delimiter">[</span>G.A<span class="delimiter">]</span><span class="delimiter">]</span> /*G[F[B]]*/ = <span class="delimiter">{</span>
    <a href="#423464" title="scalaz.Unapply[scalaz.Applicative,GB]">G</a>.<a href="Unapply.scala.html#52639" title="=&gt; scalaz.Applicative[G.M]">TC</a>.<a href="Applicative.scala.html#34528" title="(value: F[A])(f: A =&gt; G.M[G.A])(implicit G: scalaz.Traverse[F])G.M[F[G.A]]">traverse</a><span class="delimiter">(</span><a href="#423462" title="F[A]">self</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#423464" title="scalaz.Unapply[scalaz.Applicative,GB]">G</a>.<a href="Unapply.scala.html#52640" title="=&gt; scalaz.Leibniz.===[GB,G.M[G.A]]">leibniz</a>.<a href="Leibniz.scala.html#384599" title="[F[_ &gt;: scalaz.⊥ &lt;: scalaz.⊤]](p: F[GB])F[G.M[G.A]]">subst</a><span title="(p: A =&gt; GB)A =&gt; G.M[G.A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = A =&gt; α<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[α]A =&gt; α">λ</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#423463" title="A =&gt; GB">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#20819" title="scalaz.Traverse[F]" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Traverse with `State`. */
  <span class="keyword">def</span> <a title="[S, A, B](fa: F[A])(f: A =&gt; scalaz.State[S,B])scalaz.State[S,F[B]]" id="33506">traverseS</a><span class="delimiter">[</span><a title="" id="33510">S</a>,<a title="" id="33511">A</a>,<a title="" id="33512">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="69974">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.State[S,B]" id="69975">f</a>: A =&gt; State<span class="delimiter">[</span>S,B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="StateT.scala.html#20021" title="scalaz.State[S,F[B]]">State</a><span class="delimiter">[</span>S,F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#33491" title="[S]=&gt; Traverse.this.Traversal[[x]scalaz.IndexedStateT[[+X]X,S,S,x]]">traversalS</a><span title="Traverse.this.Traversal[[x]scalaz.IndexedStateT[[+X]X,S,S,x]]" class="delimiter">[</span><a href="#33510" title="S">S</a><span class="delimiter">]</span>.<a href="#423400" title="(fa: F[A])(f: A =&gt; scalaz.IndexedStateT[[+X]X,S,S,B])scalaz.IndexedStateT[[+X]X,S,S,F[B]]">run</a><span class="delimiter">(</span><a href="#69974" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#69975" title="A =&gt; scalaz.State[S,B]">f</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[S, A, B](fa: F[A], s: S)(f: A =&gt; scalaz.State[S,B])(S, F[B])" id="33513">runTraverseS</a><span class="delimiter">[</span><a title="" id="33517">S</a>,<a title="" id="33518">A</a>,<a title="" id="33519">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="423522">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="S" id="423523">s</a>: <a href="#33517" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.State[S,B]" id="423524">f</a>: A =&gt; State<span class="delimiter">[</span>S,B<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(S, F[B])" class="delimiter">(</span>S, F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#33506" title="(fa: F[A])(f: A =&gt; scalaz.State[S,B])scalaz.State[S,F[B]]">traverseS</a><span class="delimiter">(</span><a href="#423522" title="F[A]">fa</a><span class="delimiter">)</span><a href="StateT.scala.html#70591" title="(initial: S)(S, F[B])" class="delimiter">(</a><a href="#423524" title="A =&gt; scalaz.State[S,B]">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#423523" title="S">s</a><span class="delimiter">)</span>

  /** Traverse `fa` with a `State[S, G[B]]`, internally using a `Trampoline` to avoid stack overflow. */
  <span class="keyword">def</span> <a title="[S, G[+_], A, B](fa: F[A])(f: A =&gt; scalaz.State[S,G[B]])(implicit evidence$4: scalaz.Applicative[G])scalaz.State[S,G[F[B]]]" id="423543">traverseSTrampoline</a><span class="delimiter">[</span><a title="" id="33525">S</a>, <a title="[+_]" id="33526">G</a><span class="delimiter">[</span>+<a title="" id="423544">_</a><span class="delimiter">]</span> : Applicative, <a title="" id="33527">A</a>, <a title="" id="33528">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="423541">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.State[S,G[B]]" id="423542">f</a>: A =&gt; State<span class="delimiter">[</span>S, G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="StateT.scala.html#20021" title="scalaz.State[S,G[F[B]]]">State</a><span class="delimiter">[</span>S, G<span class="delimiter">[</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">import</span> <a href="Free.scala.html#10908" title="scalaz.Free.type">Free</a>._
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Applicative[[α]scalaz.IndexedStateT[scalaz.Free.Trampoline,S,S,G[α]]]" id="423550">A</a> = <a href="package.scala.html#30737" title="scalaz.StateT.type">StateT</a>.<a href="StateT.scala.html#142084" title="[S, F[+_]](implicit F0: scalaz.Monad[F])scalaz.MonadState[[s, +a]scalaz.IndexedStateT[F,s,s,a],S]">stateTMonadState</a><a href="Free.scala.html#44516" title="(implicit F0: scalaz.Monad[scalaz.Free.Trampoline])scalaz.MonadState[[s, +a]scalaz.IndexedStateT[scalaz.Free.Trampoline,s,s,a],S]" class="delimiter">[</a><a href="#33525" title="S">S</a>, <a href="Free.scala.html#10907" title="scalaz.Free.Trampoline">Trampoline</a><span class="delimiter">]</span>.<a href="Applicative.scala.html#34550" title="(implicit G0: scalaz.Applicative[G])scalaz.Applicative[[α]scalaz.IndexedStateT[scalaz.Free.Trampoline,S,S,G[α]]]">compose</a><span class="delimiter">(</span><a href="Applicative.scala.html#51082" title="[F[_]](implicit F: scalaz.Applicative[F])scalaz.Applicative[F]">Applicative</a><a href="#423543" title="(implicit F: scalaz.Applicative[G])scalaz.Applicative[G]" class="delimiter">[</a><a href="#33526" title="G">G</a><span class="delimiter">]</span><span class="delimiter">)</span>
    <a href="package.scala.html#70672" title="[S, A](f: S =&gt; (S, A))scalaz.State[S,A]">State</a><span title="(f: S =&gt; (S, G[F[B]]))scalaz.State[S,G[F[B]]]" class="delimiter">[</span><a href="#33525" title="S">S</a>, <a href="#33526" title="G[F[B]]">G</a><span class="delimiter">[</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="423680">s</a> =&gt; <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scalaz.IndexedStateT[[+A]scalaz.Free[Function0,A],S,S,G[F[B]]]" id="423681">st</a> = <a href="#115519" title="[G[_], A, B](fa: F[A])(f: A =&gt; G[B])(implicit evidence$3: scalaz.Applicative[G])G[F[B]]">traverse</a><span title="(fa: F[A])(f: A =&gt; scalaz.IndexedStateT[[+A]scalaz.Free[Function0,A],S,S,G[B]])(implicit evidence$3: scalaz.Applicative[[α]scalaz.IndexedStateT[[+A]scalaz.Free[Function0,A],S,S,G[α]]])scalaz.IndexedStateT[[+A]scalaz.Free[Function0,A],S,S,G[F[B]]]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span>=StateT<span class="delimiter">[</span>Trampoline, S, G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#<a href="StateT.scala.html#20021" title="[α]scalaz.IndexedStateT[[+A]scalaz.Free[Function0,A],S,S,G[α]]">λ</a>, <a href="#33527" title="A">A</a>, <a href="#33528" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#423541" title="F[A]">fa</a><span class="delimiter">)</span><a href="#423550" title="scalaz.Applicative[[α]scalaz.IndexedStateT[scalaz.Free.Trampoline,S,S,G[α]]]" class="delimiter">(</a><a href="#423542" title="(v1: A)scalaz.State[S,G[B]]">f</a><span class="delimiter">(</span><a href="#423691" title="A">_</a>: <a href="#33527" title="A">A</a><span class="delimiter">)</span>.<a href="StateT.scala.html#70637" title="[M[+_]](implicit evidence$1: scalaz.Applicative[M])scalaz.IndexedStateT[[+α]M[scalaz.Id.Id[α]],S,S,G[B]]">lift</a><a href="Free.scala.html#44516" title="(implicit evidence$1: scalaz.Applicative[scalaz.Free.Trampoline])scalaz.IndexedStateT[[+α]scalaz.Free.Trampoline[scalaz.Id.Id[α]],S,S,G[B]]" class="delimiter">[</a><a href="Free.scala.html#10907" title="scalaz.Free.Trampoline">Trampoline</a><span class="delimiter">]</span><span class="delimiter">)</span>
      <a href="#423681" title="scalaz.IndexedStateT[[+A]scalaz.Free[Function0,A],S,S,G[F[B]]]">st</a>.<a href="StateT.scala.html#70592" title="(initial: S)scalaz.Free[Function0,(S, G[F[B]])]">run</a><span class="delimiter">(</span><a href="#423680" title="S">s</a><span class="delimiter">)</span>.<a href="Free.scala.html#48263" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,(S, G[F[B]])],scalaz.Free.Trampoline[(S, G[F[B]])]])(S, G[F[B]])">run</a>
    <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Traverse `fa` with a `Kleisli[G, S, B]`, internally using a `Trampoline` to avoid stack overflow. */
  <span class="keyword">def</span> <a title="[S, G[+_], A, B](fa: F[A])(f: A =&gt; scalaz.Kleisli[G,S,B])(implicit evidence$5: scalaz.Applicative[G])scalaz.Kleisli[G,S,F[B]]" id="423784">traverseKTrampoline</a><span class="delimiter">[</span><a title="" id="33534">S</a>, <a title="[+_]" id="33535">G</a><span class="delimiter">[</span>+<a title="" id="423785">_</a><span class="delimiter">]</span> : Applicative, <a title="" id="33536">A</a>, <a title="" id="33537">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="423782">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Kleisli[G,S,B]" id="423783">f</a>: A =&gt; Kleisli<span class="delimiter">[</span>G, S, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Kleisli.scala.html#13760" title="scalaz.Kleisli[G,S,F[B]]">Kleisli</a><span class="delimiter">[</span>G, S, F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">import</span> <a href="Free.scala.html#10908" title="scalaz.Free.type">Free</a>._
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Applicative[[α]scalaz.Kleisli[scalaz.Free.Trampoline,S,G[α]]]" id="423791">A</a> = <a href="Kleisli.scala.html#13761" title="scalaz.Kleisli.type">Kleisli</a>.<a href="Kleisli.scala.html#44425" title="[F[+_], R](implicit F0: scalaz.Monad[F])scalaz.KleisliMonadReader[F,R]">kleisliMonadReader</a><a href="Free.scala.html#44516" title="(implicit F0: scalaz.Monad[scalaz.Free.Trampoline])scalaz.KleisliMonadReader[scalaz.Free.Trampoline,S]" class="delimiter">[</a><a href="Free.scala.html#10907" title="scalaz.Free.Trampoline">Trampoline</a>, <a href="#33534" title="S">S</a><span class="delimiter">]</span>.<a href="Applicative.scala.html#34550" title="(implicit G0: scalaz.Applicative[G])scalaz.Applicative[[α]scalaz.Kleisli[scalaz.Free.Trampoline,S,G[α]]]">compose</a><span class="delimiter">(</span><a href="Applicative.scala.html#51082" title="[F[_]](implicit F: scalaz.Applicative[F])scalaz.Applicative[F]">Applicative</a><a href="#423784" title="(implicit F: scalaz.Applicative[G])scalaz.Applicative[G]" class="delimiter">[</a><a href="#33535" title="G">G</a><span class="delimiter">]</span><span class="delimiter">)</span>
    <a href="Kleisli.scala.html#44370" title="[M[+_], A, B](f: A =&gt; M[B])scalaz.Kleisli[M,A,B]">Kleisli</a><span title="(f: S =&gt; G[F[B]])scalaz.Kleisli[G,S,F[B]]" class="delimiter">[</span><a href="#33535" title="G">G</a>, <a href="#33534" title="S">S</a>, <a href="#23766" title="F[B]">F</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="423921">s</a> =&gt; <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scalaz.Free[Function0,G[F[B]]]" id="423922">kl</a> = <a href="#115519" title="[G[_], A, B](fa: F[A])(f: A =&gt; G[B])(implicit evidence$3: scalaz.Applicative[G])G[F[B]]">traverse</a><span title="(fa: F[A])(f: A =&gt; scalaz.Kleisli[[+A]scalaz.Free[Function0,A],S,G[B]])(implicit evidence$3: scalaz.Applicative[[α]scalaz.Kleisli[[+A]scalaz.Free[Function0,A],S,G[α]]])scalaz.Kleisli[[+A]scalaz.Free[Function0,A],S,G[F[B]]]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span>=Kleisli<span class="delimiter">[</span>Trampoline, S, G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#<a href="Kleisli.scala.html#13760" title="[α]scalaz.Kleisli[[+A]scalaz.Free[Function0,A],S,G[α]]">λ</a>, <a href="#33536" title="A">A</a>, <a href="#33537" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#423782" title="F[A]">fa</a><span class="delimiter">)</span><a href="#423791" title="scalaz.Applicative[[α]scalaz.Kleisli[scalaz.Free.Trampoline,S,G[α]]]" class="delimiter">(</a><a title="A" id="423932">z</a> =&gt; <a href="Kleisli.scala.html#44370" title="[M[+_], A, B](f: A =&gt; M[B])scalaz.Kleisli[M,A,B]">Kleisli</a><span title="(f: S =&gt; scalaz.Id.Id[G[B]])scalaz.Kleisli[scalaz.Id.Id,S,G[B]]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#33534" title="S">S</a>, <a href="#33535" title="G[B]">G</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="423935">i</a> =&gt; <a href="#423783" title="(v1: A)scalaz.Kleisli[G,S,B]">f</a><a href="Kleisli.scala.html#44350" title="(v1: S)G[B]" class="delimiter">(</a><a href="#423932" title="A">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#423935" title="S">i</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="Kleisli.scala.html#112870" title="[L[+_]](implicit evidence$1: scalaz.Applicative[L])scalaz.Kleisli[[+α]L[scalaz.Id.Id[α]],S,G[B]]">lift</a><a href="Free.scala.html#44516" title="(implicit evidence$1: scalaz.Applicative[scalaz.Free.Trampoline])scalaz.Kleisli[[+α]scalaz.Free.Trampoline[scalaz.Id.Id[α]],S,G[B]]" class="delimiter">[</a><a href="Free.scala.html#10907" title="scalaz.Free.Trampoline">Trampoline</a><span class="delimiter">]</span><span class="delimiter">)</span>.<a href="Kleisli.scala.html#112818" title="(a: S)scalaz.Free[Function0,G[F[B]]]">run</a><span class="delimiter">(</span><a href="#423921" title="S">s</a><span class="delimiter">)</span>
      <a href="#423922" title="scalaz.Free[Function0,G[F[B]]]">kl</a>.<a href="Free.scala.html#48263" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,G[F[B]]],scalaz.Free.Trampoline[G[F[B]]]])G[F[B]]">run</a>
    <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Traverse with the identity function. */
  <span class="keyword">def</span> <a title="[G[_], A](fga: F[G[A]])(implicit evidence$6: scalaz.Applicative[G])G[F[A]]" id="115577">sequence</a><span class="delimiter">[</span><a title="[_]" id="33541">G</a><span class="delimiter">[</span><a title="" id="115578">_</a><span class="delimiter">]</span>:Applicative,<a title="" id="33542">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[G[A]]" id="115576">fga</a>: <a href="#23766" title="F[G[A]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33541" title="G[F[A]]">G</a><span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#423417" title="[G[_]](implicit evidence$2: scalaz.Applicative[G])Traverse.this.Traversal[G]">traversal</a><a href="#115577" title="(implicit evidence$2: scalaz.Applicative[G])Traverse.this.Traversal[G]" class="delimiter">[</a><a href="#33541" title="G">G</a><span class="delimiter">]</span>.<a href="#423400" title="[A, B](fa: F[A])(f: A =&gt; G[B])G[F[B]]">run</a><span title="(fa: F[G[A]])(f: G[A] =&gt; G[A])G[F[A]]" class="delimiter">[</span><a href="#33541" title="G[A]">G</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a href="#33542" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#115576" title="F[G[A]]">fga</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="G[A]" id="424121">ga</a> =&gt; <a href="#424121" title="G[A]">ga</a><span class="delimiter">)</span>

  /** Traverse with `State`. */
  <span class="keyword">def</span> <a title="[S, A](fga: F[scalaz.State[S,A]])scalaz.State[S,F[A]]" id="33543">sequenceS</a><span class="delimiter">[</span><a title="" id="33546">S</a>,<a title="" id="33547">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[scalaz.State[S,A]]" id="424122">fga</a>: <a href="#23766" title="F[scalaz.State[S,A]]">F</a><span class="delimiter">[</span>State<span class="delimiter">[</span>S,A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="StateT.scala.html#20021" title="scalaz.State[S,F[A]]">State</a><span class="delimiter">[</span>S,F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#33491" title="[S]=&gt; Traverse.this.Traversal[[x]scalaz.IndexedStateT[[+X]X,S,S,x]]">traversalS</a><span title="Traverse.this.Traversal[[x]scalaz.IndexedStateT[[+X]X,S,S,x]]" class="delimiter">[</span><a href="#33546" title="S">S</a><span class="delimiter">]</span>.<a href="#423400" title="(fa: F[scalaz.State[S,A]])(f: scalaz.State[S,A] =&gt; scalaz.IndexedStateT[[+X]X,S,S,A])scalaz.IndexedStateT[[+X]X,S,S,F[A]]">run</a><span class="delimiter">(</span><a href="#424122" title="F[scalaz.State[S,A]]">fga</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.State[S,A]" id="424137">a</a> =&gt; <a href="#424137" title="scalaz.State[S,A]">a</a><span class="delimiter">)</span>

  /** A version of `sequence` that infers the nested type constructor. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[A](self: F[A])(implicit G: scalaz.Unapply[scalaz.Applicative,A])G.M[F[G.A]]" id="33548">sequenceU</a><span class="delimiter">[</span><a title="" id="33550">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="72879">self</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Unapply[scalaz.Applicative,A]" id="72880">G</a>: <a href="Unapply.scala.html#18791" title="scalaz.Unapply[scalaz.Applicative,A]">Unapply</a><span class="delimiter">[</span>Applicative, A<span class="delimiter">]</span><span class="delimiter">)</span>: G.<a href="Unapply.scala.html#52637" title="G.M[F[G.A]]">M</a><span class="delimiter">[</span>F<span class="delimiter">[</span>G.A<span class="delimiter">]</span><span class="delimiter">]</span> /*G[F[A]] */ = <span class="delimiter">{</span>
    <a href="#72880" title="scalaz.Unapply[scalaz.Applicative,A]">G</a>.<a href="Unapply.scala.html#52639" title="=&gt; scalaz.Applicative[G.M]">TC</a>.<a href="Applicative.scala.html#34528" title="(value: F[A])(f: A =&gt; G.M[G.A])(implicit G: scalaz.Traverse[F])G.M[F[G.A]]">traverse</a><span class="delimiter">(</span><a href="#72879" title="F[A]">self</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="424169">x</a> =&gt; <a href="#72880" title="scalaz.Unapply[scalaz.Applicative,A]">G</a>.<a href="Unapply.scala.html#52641" title="(ma: A)G.M[G.A]">apply</a><span class="delimiter">(</span><a href="#424169" title="A">x</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#20819" title="scalaz.Traverse[F]" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](fa: F[A])(f: A =&gt; B)F[B]" id="33551">map</a><span class="delimiter">[</span><a title="" id="33554">A</a>,<a title="" id="33555">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="51000">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="51001">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#23766" title="F[B]">F</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
    <a href="#423417" title="[G[_]](implicit evidence$2: scalaz.Applicative[G])Traverse.this.Traversal[G]">traversal</a><span title="(implicit evidence$2: scalaz.Applicative[scalaz.Id.Id])Traverse.this.Traversal[scalaz.Id.Id]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Id.scala.html#8190" title="scalaz.Id.type">Id</a>.<a href="Id.scala.html#33409" title="=&gt; scalaz.Traverse1[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]">id</a><span class="delimiter">)</span>.<a href="#423400" title="(fa: F[A])(f: A =&gt; scalaz.Id.Id[B])scalaz.Id.Id[F[B]]">run</a><span class="delimiter">(</span><a href="#51000" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#51001" title="A =&gt; B">f</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[A, B](fa: F[A], z: B)(f: (B, A) =&gt; B)(B, F[Unit])" id="33556">foldLShape</a><span class="delimiter">[</span><a title="" id="33559">A</a>,<a title="" id="33560">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="424187">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="B" id="424188">z</a>: <a href="#33560" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, A) =&gt; B" id="424189">f</a>: <span class="delimiter">(</span>B,A<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <span title="(B, F[Unit])" class="delimiter">(</span>B, F<span class="delimiter">[</span>Unit<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#33513" title="(fa: F[A], s: B)(f: A =&gt; scalaz.State[B,Unit])(B, F[Unit])">runTraverseS</a><span class="delimiter">(</span><a href="#424187" title="F[A]">fa</a>, <a href="#424188" title="B">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="424206">a</a> =&gt; <a href="package.scala.html#30741" title="scalaz.State.type">State</a>.<a href="State.scala.html#45087" title="(f: B =&gt; B)scalaz.State[B,Unit]">modify</a><span class="delimiter">(</span><a href="#424189" title="(v1: B, v2: A)B">f</a><span class="delimiter">(</span><a href="#424210" title="B">_</a>, <a href="#424206" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](fa: F[A], z: B)(f: (B, A) =&gt; B)B" id="33561">foldLeft</a><span class="delimiter">[</span><a title="" id="33564">A</a>,<a title="" id="33565">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="69992">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="B" id="69993">z</a>: <a href="#33565" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, A) =&gt; B" id="69994">f</a>: <span class="delimiter">(</span>B,A<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#33565" title="B">B</a> = <a href="#33556" title="(fa: F[A], z: B)(f: (B, A) =&gt; B)(B, F[Unit])">foldLShape</a><span class="delimiter">(</span><a href="#69992" title="F[A]">fa</a>, <a href="#69993" title="B">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#69994" title="(B, A) =&gt; B">f</a><span class="delimiter">)</span>.<span title="=&gt; B">_1</span>

  <span class="keyword">def</span> <a title="[A, B](fa: F[A])(f: A =&gt; B)(implicit F: scalaz.Monoid[B])B" id="33566">foldMap</a><span class="delimiter">[</span><a title="" id="33569">A</a>,<a title="" id="33570">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="51306">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="51307">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monoid[B]" id="51308">F</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[B]">Monoid</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33570" title="B">B</a> = <a href="#33556" title="(fa: F[A], z: B)(f: (B, A) =&gt; B)(B, F[Unit])">foldLShape</a><span class="delimiter">(</span><a href="#51306" title="F[A]">fa</a>, <a href="#51308" title="scalaz.Monoid[B]">F</a>.<a href="Monoid.scala.html#51158" title="=&gt; B">zero</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="B" id="424238">b</a>, <a title="A" id="424239">a</a><span class="delimiter">)</span> =&gt; <a href="#51308" title="scalaz.Monoid[B]">F</a>.<a href="Semigroup.scala.html#51147" title="(f1: B, f2: =&gt; B)B">append</a><span class="delimiter">(</span><a href="#424238" title="B">b</a>, <a href="#51307" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#424239" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; B">_1</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](fa: F[A], z: =&gt; B)(f: (A, =&gt; B) =&gt; B)B" id="33571">foldRight</a><span class="delimiter">[</span><a title="" id="33574">A</a>, <a title="" id="33575">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="51275">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="=&gt; B" id="51276">z</a>: =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, =&gt; B) =&gt; B" id="51277">f</a>: <span class="delimiter">(</span>A, =&gt; B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span> =
    <a href="#33566" title="(fa: F[A])(f: A =&gt; scalaz.Endo[B])(implicit F: scalaz.Monoid[scalaz.Endo[B]])scalaz.Endo[B]">foldMap</a><span class="delimiter">(</span><a href="#51275" title="F[A]">fa</a><span class="delimiter">)</span><a href="Endo.scala.html#51363" title="scalaz.Monoid[scalaz.Endo[B]]" class="delimiter">(</a><span class="delimiter">(</span>a: <a href="#33574" title="A">A</a><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span><a href="Endo.scala.html#10845" title="scalaz.Endo.type">Endo</a>.<a href="Endo.scala.html#51344" title="(f: B =&gt; B)scalaz.Endo[B]">endo</a><span class="delimiter">(</span><a href="#51277" title="(v1: A, v2: =&gt; B)B">f</a><span class="delimiter">(</span><a href="#51342" title="A">a</a>, <a href="#51372" title="B">_</a>: <a href="#33575" title="B">B</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Endo.scala.html#51379" title="(a: B)B">apply</a> <a href="#51276" title="=&gt; B">z</a>

  <span class="keyword">def</span> <a title="[A](fa: F[A])F[A]" id="33576">reverse</a><span class="delimiter">[</span><a title="" id="33578">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="424244">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a href="#1680430" title="(x: (List[A], F[A]))(List[A], F[A])" class="delimiter">(</a><a href="#1680428" title="List[A]" id="424248">as</a>, <a href="#1680428" title="F[A]" id="424249">shape</a><span class="delimiter">)</span> = <a href="#33610" title="(fa: F[A], z: List[A])(f: (List[A], A) =&gt; (List[A], A))(List[A], F[A])">mapAccumL</a><span class="delimiter">(</span><a href="#424244" title="F[A]">fa</a>, scala.List<span class="delimiter">[</span>A<span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><a href="#1680428" title="(List[A], F[A]) @unchecked" class="delimiter">(</a><span class="delimiter">(</span><a title="List[A]" id="424276">t</a>,<a title="A" id="424277">h</a><span class="delimiter">)</span> =&gt; <span title="(_1: List[A], _2: A)(List[A], A)" class="delimiter">(</span><a href="#424277" title="A">h</a> <a href="#424282" title="(x: A)List[A]">::</a> <a href="#424276" title="List[A]">t</a>,<a href="#424277" title="A">h</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#33513" title="(fa: F[A], s: List[A])(f: A =&gt; scalaz.State[List[A],A])(List[A], F[A])">runTraverseS</a><span class="delimiter">(</span><a href="#424249" title="F[A]">shape</a>, <a href="#424248" title="List[A]">as</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="424316">_</a> =&gt; <span class="keyword">for</span> <span class="delimiter">{</span>
      <a title="List[A]" id="424324">e</a> &lt;- <a href="package.scala.html#30741" title="scalaz.State.type">State</a>.<a href="StateT.scala.html#70632" title="(f: List[A] =&gt; scalaz.IndexedStateT[scalaz.Id.Id,List[A],List[A],A])(implicit F: scalaz.Bind[scalaz.Id.Id])scalaz.IndexedStateT[scalaz.Id.Id,List[A],List[A],A]">get</a>
      <a title="Unit" id="424333">_</a> &lt;- <a href="package.scala.html#30741" title="scalaz.State.type">State</a>.<a href="State.scala.html#45084" title="(s: List[A])scalaz.State[List[A],Unit]">put</a><a href="StateT.scala.html#70604" title="(f: Unit =&gt; A)(implicit F: scalaz.Functor[scalaz.Id.Id])scalaz.IndexedStateT[scalaz.Id.Id,List[A],List[A],A]" class="delimiter">(</a><a href="#424324" title="List[A]">e</a>.<span title="=&gt; List[A]">tail</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">yield</span> <a href="#424324" title="List[A]">e</a>.<span title="=&gt; A">head</span><span class="delimiter">)</span>.<span title="=&gt; F[A]">_2</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[A, B, C](fa: F[A], fb: F[B])(f: (A, Option[B]) =&gt; C)(List[B], F[C])" id="33579">zipWith</a><span class="delimiter">[</span><a title="" id="33583">A</a>,<a title="" id="33584">B</a>,<a title="" id="33585">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="356056">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="F[B]" id="356057">fb</a>: <a href="#23766" title="F[B]">F</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, Option[B]) =&gt; C" id="356058">f</a>: <span class="delimiter">(</span>A, Option<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <span title="(List[B], F[C])" class="delimiter">(</span>List<span class="delimiter">[</span>B<span class="delimiter">]</span>, F<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#33513" title="(fa: F[A], s: List[B])(f: A =&gt; scalaz.State[List[B],C])(List[B], F[C])">runTraverseS</a><span class="delimiter">(</span><a href="#356056" title="F[A]">fa</a>, <a href="Foldable.scala.html#33758" title="(fa: F[B])List[B]">toList</a><span class="delimiter">(</span><a href="#356057" title="F[B]">fb</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="424368">a</a> =&gt; <span class="keyword">for</span> <span class="delimiter">{</span>
      <a title="List[B]" id="424376">bs</a> &lt;- <a href="package.scala.html#30741" title="scalaz.State.type">State</a>.<a href="StateT.scala.html#70632" title="(f: List[B] =&gt; scalaz.IndexedStateT[scalaz.Id.Id,List[B],List[B],C])(implicit F: scalaz.Bind[scalaz.Id.Id])scalaz.IndexedStateT[scalaz.Id.Id,List[B],List[B],C]">get</a>
      <a title="Unit" id="424385">_</a> &lt;- <a href="package.scala.html#30741" title="scalaz.State.type">State</a>.<a href="State.scala.html#45084" title="(s: List[B])scalaz.State[List[B],Unit]">put</a><a href="StateT.scala.html#70604" title="(f: Unit =&gt; C)(implicit F: scalaz.Functor[scalaz.Id.Id])scalaz.IndexedStateT[scalaz.Id.Id,List[B],List[B],C]" class="delimiter">(</a><span title="List[B]" class="keyword">if</span> <span class="delimiter">(</span><a href="#424376" title="List[B]">bs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#424376" title="List[B]">bs</a> <span class="keyword">else</span> <a href="#424376" title="List[B]">bs</a>.<span title="=&gt; List[B]">tail</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">yield</span> <a href="#356058" title="(v1: A, v2: Option[B])C">f</a><span class="delimiter">(</span><a href="#424368" title="A">a</a>, <a href="#424376" title="List[B]">bs</a>.<span title="=&gt; Option[B]">headOption</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[A, B, C](fa: F[A], fb: F[B])(f: (A, Option[B]) =&gt; C)F[C]" id="33586">zipWithL</a><span class="delimiter">[</span><a title="" id="33590">A</a>,<a title="" id="33591">B</a>,<a title="" id="33592">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="424393">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="F[B]" id="424394">fb</a>: <a href="#23766" title="F[B]">F</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, Option[B]) =&gt; C" id="424395">f</a>: <span class="delimiter">(</span>A,Option<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#23766" title="F[C]">F</a><span class="delimiter">[</span>C<span class="delimiter">]</span> = <a href="#33579" title="(fa: F[A], fb: F[B])(f: (A, Option[B]) =&gt; C)(List[B], F[C])">zipWith</a><span class="delimiter">(</span><a href="#424393" title="F[A]">fa</a>, <a href="#424394" title="F[B]">fb</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#424395" title="(A, Option[B]) =&gt; C">f</a><span class="delimiter">)</span>.<span title="=&gt; F[C]">_2</span>
  <span class="keyword">def</span> <a title="[A, B, C](fa: F[A], fb: F[B])(f: (Option[A], B) =&gt; C)F[C]" id="33593">zipWithR</a><span class="delimiter">[</span><a title="" id="33597">A</a>,<a title="" id="33598">B</a>,<a title="" id="33599">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="424414">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="F[B]" id="424415">fb</a>: <a href="#23766" title="F[B]">F</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(Option[A], B) =&gt; C" id="424416">f</a>: <span class="delimiter">(</span>Option<span class="delimiter">[</span>A<span class="delimiter">]</span>,B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#23766" title="F[C]">F</a><span class="delimiter">[</span>C<span class="delimiter">]</span> = <a href="#33579" title="(fa: F[B], fb: F[A])(f: (B, Option[A]) =&gt; C)(List[A], F[C])">zipWith</a><span class="delimiter">(</span><a href="#424415" title="F[B]">fb</a>, <a href="#424414" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="B" id="424433">b</a>,<a title="Option[A]" id="424434">oa</a><span class="delimiter">)</span> =&gt; <a href="#424416" title="(v1: Option[A], v2: B)C">f</a><span class="delimiter">(</span><a href="#424434" title="Option[A]">oa</a>,<a href="#424433" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; F[C]">_2</span>

  <span class="keyword">def</span> <a title="[A, B](fa: F[A], fb: F[B])F[(A, Option[B])]" id="33600">zipL</a><span class="delimiter">[</span><a title="" id="33603">A</a>,<a title="" id="33604">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="424440">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="F[B]" id="424441">fb</a>: <a href="#23766" title="F[B]">F</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23766" title="F[(A, Option[B])]">F</a><span class="delimiter">[</span><span class="delimiter">(</span>A, Option<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#33586" title="(fa: F[A], fb: F[B])(f: (A, Option[B]) =&gt; (A, Option[B]))F[(A, Option[B])]">zipWithL</a><span class="delimiter">(</span><a href="#424440" title="F[A]">fa</a>, <a href="#424441" title="F[B]">fb</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(_1: A, _2: Option[B])(A, Option[B])" class="delimiter">(</span><a href="#424457" title="A">_</a>,<a href="#424458" title="Option[B]">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[A, B](fa: F[A], fb: F[B])F[(Option[A], B)]" id="33605">zipR</a><span class="delimiter">[</span><a title="" id="33608">A</a>,<a title="" id="33609">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="424467">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="F[B]" id="424468">fb</a>: <a href="#23766" title="F[B]">F</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23766" title="F[(Option[A], B)]">F</a><span class="delimiter">[</span><span class="delimiter">(</span>Option<span class="delimiter">[</span>A<span class="delimiter">]</span>, B<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#33593" title="(fa: F[A], fb: F[B])(f: (Option[A], B) =&gt; (Option[A], B))F[(Option[A], B)]">zipWithR</a><span class="delimiter">(</span><a href="#424467" title="F[A]">fa</a>, <a href="#424468" title="F[B]">fb</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(_1: Option[A], _2: B)(Option[A], B)" class="delimiter">(</span><a href="#424484" title="Option[A]">_</a>,<a href="#424485" title="B">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[S, A, B](fa: F[A], z: S)(f: (S, A) =&gt; (S, B))(S, F[B])" id="33610">mapAccumL</a><span class="delimiter">[</span><a title="" id="33614">S</a>,<a title="" id="33615">A</a>,<a title="" id="33616">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="424250">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="S" id="424251">z</a>: <a href="#33614" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(S, A) =&gt; (S, B)" id="424252">f</a>: <span class="delimiter">(</span>S,A<span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>S,B<span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(S, F[B])" class="delimiter">(</span>S, F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#33513" title="(fa: F[A], s: S)(f: A =&gt; scalaz.State[S,B])(S, F[B])">runTraverseS</a><span class="delimiter">(</span><a href="#424250" title="F[A]">fa</a>, <a href="#424251" title="S">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="424506">a</a> =&gt; <span class="keyword">for</span> <span class="delimiter">{</span>
      <a title="S" id="424512">s1</a> &lt;- <a href="package.scala.html#30741" title="scalaz.State.type">State</a>.<a href="State.scala.html#45073" title="[S]=&gt; scalaz.State[S,S]">init</a><a href="StateT.scala.html#70604" title="(f: S =&gt; (S, (S, B)))(implicit F: scalaz.Functor[scalaz.Id.Id])scalaz.IndexedStateT[scalaz.Id.Id,S,S,(S, (S, B))]" class="delimiter">[</a><a href="#33614" title="S">S</a><span class="delimiter">]</span>
      <a href="#1680436" title="(x: ((S, B), S, B))((S, B), S, B)" id="424514" class="delimiter">(</a><a href="#1680434" title="S" id="424561">s2</a>,<a href="#1680434" title="B" id="424562">b</a><span class="delimiter">)</span> = <a href="#424252" title="(v1: S, v2: A)(S, B)">f</a><a href="#1680434" title="(S, B) @unchecked" class="delimiter">(</a><a href="#424512" title="S">s1</a>,<a href="#424506" title="A">a</a><span class="delimiter">)</span>
      <a title="Unit" id="424571">_</a> &lt;- <a href="package.scala.html#30741" title="scalaz.State.type">State</a>.<a href="State.scala.html#45084" title="(s: S)scalaz.State[S,Unit]">put</a><a href="StateT.scala.html#70604" title="(f: Unit =&gt; B)(implicit F: scalaz.Functor[scalaz.Id.Id])scalaz.IndexedStateT[scalaz.Id.Id,S,S,B]" class="delimiter">(</a><a href="#424561" title="S">s2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">yield</span> <a href="#424562" title="B">b</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[S, A, B](fa: F[A], z: S)(f: (S, A) =&gt; (S, B))(S, F[B])" id="33617">mapAccumR</a><span class="delimiter">[</span><a title="" id="33621">S</a>,<a title="" id="33622">A</a>,<a title="" id="33623">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="424576">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="S" id="424577">z</a>: <a href="#33621" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(S, A) =&gt; (S, B)" id="424578">f</a>: <span class="delimiter">(</span>S,A<span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>S,B<span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(S, F[B])" class="delimiter">(</span>S, F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> =
    <a href="#33610" title="(fa: F[A], z: S)(f: (S, A) =&gt; (S, B))(S, F[B])">mapAccumL</a><span class="delimiter">(</span><a href="#33576" title="(fa: F[A])F[A]">reverse</a><span class="delimiter">(</span><a href="#424576" title="F[A]">fa</a><span class="delimiter">)</span>, <a href="#424577" title="S">z</a><span class="delimiter">)</span><a href="#1680447" title="(S, F[B])" class="delimiter">(</a><a href="#424578" title="(S, A) =&gt; (S, B)">f</a><span class="delimiter">)</span> <span class="keyword">match</span> <span class="delimiter">{</span> <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1680447" title="S" id="424602">s</a>, <a href="#1680447" title="F[B]" id="424603">fb</a><span class="delimiter">)</span> =&gt; <a href="#1680449" title="(x: (S, F[B]))(S, F[B])" class="delimiter">(</a><a href="#424602" title="S">s</a>, <a href="#33576" title="(fa: F[B])F[B]">reverse</a><span class="delimiter">(</span><a href="#424603" title="F[B]">fb</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait TraverseLaw extends AnyRef with Traverse.this.FunctorLaw" id="33624">TraverseLaw</a> <span title="Unit" class="keyword">extends</span> <a href="Functor.scala.html#33467" title="Traverse.this.FunctorLaw">FunctorLaw</a> <span class="delimiter">{</span>
    /** Traversal through the [[scalaz.Id]] effect is equivalent to `Functor#map` */
    <span class="keyword">def</span> <a title="[A, B](fa: F[A], f: A =&gt; B)(implicit FB: scalaz.Equal[F[B]])Boolean" id="424614">identityTraverse</a><span class="delimiter">[</span><a title="" id="424617">A</a>, <a title="" id="424618">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="424653">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A =&gt; B" id="424654">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Equal[F[B]]" id="424655">FB</a>: <a href="Equal.scala.html#19253" title="scalaz.Equal[F[B]]">Equal</a><span class="delimiter">[</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <a href="#424655" title="scalaz.Equal[F[B]]">FB</a>.<a href="Equal.scala.html#50753" title="(a1: F[B], a2: F[B])Boolean">equal</a><span class="delimiter">(</span><a href="#115519" title="[G[_], A, B](fa: F[A])(f: A =&gt; G[B])(implicit evidence$3: scalaz.Applicative[G])G[F[B]]">traverse</a><span title="(fa: F[A])(f: A =&gt; scalaz.Id.Id[B])(implicit evidence$3: scalaz.Applicative[scalaz.Id.Id])scalaz.Id.Id[F[B]]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#424617" title="A">A</a>, <a href="#424618" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#424653" title="F[A]">fa</a><span class="delimiter">)</span><a href="package.scala.html#30683" title="=&gt; scalaz.Traverse1[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]" class="delimiter">(</a><a href="#424654" title="A =&gt; B">f</a><span class="delimiter">)</span>, <a href="#33551" title="(fa: F[A])(f: A =&gt; B)F[B]">map</a><span class="delimiter">(</span><a href="#424653" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#424654" title="A =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Two sequentially dependent effects can be fused into one, their composition */
    <span class="keyword">def</span> <a title="[N[_], M[_], A, B, C](fa: F[A], amb: A =&gt; M[B], bnc: B =&gt; N[C])(implicit N: scalaz.Applicative[N], implicit M: scalaz.Applicative[M], implicit MN: scalaz.Equal[M[N[F[C]]]])Boolean" id="424619">sequentialFusion</a><span class="delimiter">[</span><a title="[_]" id="424625">N</a><span class="delimiter">[</span><a title="" id="424695">_</a><span class="delimiter">]</span>, <a title="[_]" id="424626">M</a><span class="delimiter">[</span><a title="" id="424694">_</a><span class="delimiter">]</span>, <a title="" id="424627">A</a>, <a title="" id="424628">B</a>, <a title="" id="424629">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="424687">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A =&gt; M[B]" id="424688">amb</a>: A =&gt; M<span class="delimiter">[</span>B<span class="delimiter">]</span>, <a title="B =&gt; N[C]" id="424689">bnc</a>: B =&gt; N<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">)</span>
                                               <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[N]" id="424690">N</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span>, <a title="scalaz.Applicative[M]" id="424691">M</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[M]">Applicative</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="scalaz.Equal[M[N[F[C]]]]" id="424692">MN</a>: <a href="Equal.scala.html#19253" title="scalaz.Equal[M[N[F[C]]]]">Equal</a><span class="delimiter">[</span>M<span class="delimiter">[</span>N<span class="delimiter">[</span>F<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="[A]M[N[A]]" id="424702">MN</a><span class="delimiter">[</span><a title="" id="424703">A</a><span class="delimiter">]</span> = <a href="#424626" title="M[N[A]]">M</a><span class="delimiter">[</span>N<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="keyword">val</span> <a title="MN[F[C]]" id="424704">t1</a>: <a href="#424626" title="MN[F[C]]">MN</a><span class="delimiter">[</span>F<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#424691" title="scalaz.Applicative[M]">M</a>.<a href="Applicative.scala.html#34516" title="(fa: M[F[B]])(f: F[B] =&gt; N[F[C]])M[N[F[C]]]">map</a><span class="delimiter">(</span><a href="#115519" title="[G[_], A, B](fa: F[A])(f: A =&gt; G[B])(implicit evidence$3: scalaz.Applicative[G])G[F[B]]">traverse</a><span title="(fa: F[A])(f: A =&gt; M[B])(implicit evidence$3: scalaz.Applicative[M])M[F[B]]" class="delimiter">[</span><a href="#424626" title="M">M</a>, <a href="#424627" title="A">A</a>, <a href="#424628" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#424687" title="F[A]">fa</a><span class="delimiter">)</span><a href="#424691" title="scalaz.Applicative[M]" class="delimiter">(</a><a href="#424688" title="A =&gt; M[B]">amb</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="F[B]" id="424724">fb</a> =&gt; <a href="#115519" title="[G[_], A, B](fa: F[A])(f: A =&gt; G[B])(implicit evidence$3: scalaz.Applicative[G])G[F[B]]">traverse</a><span title="(fa: F[B])(f: B =&gt; N[C])(implicit evidence$3: scalaz.Applicative[N])N[F[C]]" class="delimiter">[</span><a href="#424625" title="N">N</a>, <a href="#424628" title="B">B</a>, <a href="#424629" title="C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#424724" title="F[B]">fb</a><span class="delimiter">)</span><a href="#424690" title="scalaz.Applicative[N]" class="delimiter">(</a><a href="#424689" title="B =&gt; N[C]">bnc</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="MN[F[C]]" id="424705">t2</a>: <a href="#424626" title="MN[F[C]]">MN</a><span class="delimiter">[</span>F<span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#115519" title="[G[_], A, B](fa: F[A])(f: A =&gt; G[B])(implicit evidence$3: scalaz.Applicative[G])G[F[B]]">traverse</a><span title="(fa: F[A])(f: A =&gt; MN[C])(implicit evidence$3: scalaz.Applicative[MN])MN[F[C]]" class="delimiter">[</span><a href="#424626" title="MN">MN</a>, <a href="#424627" title="A">A</a>, <a href="#424629" title="C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#424687" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="424736">a</a> =&gt; <a href="#424691" title="scalaz.Applicative[M]">M</a>.<a href="Applicative.scala.html#34516" title="(fa: M[B])(f: B =&gt; N[C])M[N[C]]">map</a><span class="delimiter">(</span><a href="#424688" title="(v1: A)M[B]">amb</a><span class="delimiter">(</span><a href="#424736" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="B" id="424749">b</a> =&gt; <a href="#424689" title="(v1: B)N[C]">bnc</a><span class="delimiter">(</span><a href="#424749" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#424691" title="scalaz.Applicative[M]">M</a> <a href="Applicative.scala.html#34550" title="(implicit G0: scalaz.Applicative[N])scalaz.Applicative[[α]M[N[α]]]">compose</a> <a href="#424690" title="scalaz.Applicative[N]">N</a><span class="delimiter">)</span>
      <a href="#424692" title="scalaz.Equal[M[N[F[C]]]]">MN</a>.<a href="Equal.scala.html#50753" title="(a1: M[N[F[C]]], a2: M[N[F[C]]])Boolean">equal</a><span class="delimiter">(</span><a href="#424704" title="MN[F[C]]">t1</a>, <a href="#424705" title="MN[F[C]]">t2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Traversal with the `point` function is the same as applying the `point` function directly */
    <span class="keyword">def</span> <a title="[G[_], A](fa: F[A])(implicit G: scalaz.Applicative[G], implicit GFA: scalaz.Equal[G[F[A]]])Boolean" id="424630">purity</a><span class="delimiter">[</span><a title="[_]" id="424633">G</a><span class="delimiter">[</span><a title="" id="424803">_</a><span class="delimiter">]</span>, <a title="" id="424634">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="424799">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[G]" id="424800">G</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[G]">Applicative</a><span class="delimiter">[</span>G<span class="delimiter">]</span>, <a title="scalaz.Equal[G[F[A]]]" id="424801">GFA</a>: <a href="Equal.scala.html#19253" title="scalaz.Equal[G[F[A]]]">Equal</a><span class="delimiter">[</span>G<span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="#424801" title="scalaz.Equal[G[F[A]]]">GFA</a>.<a href="Equal.scala.html#50753" title="(a1: G[F[A]], a2: G[F[A]])Boolean">equal</a><span class="delimiter">(</span><a href="#115519" title="[G[_], A, B](fa: F[A])(f: A =&gt; G[B])(implicit evidence$3: scalaz.Applicative[G])G[F[B]]">traverse</a><span title="(fa: F[A])(f: A =&gt; G[A])(implicit evidence$3: scalaz.Applicative[G])G[F[A]]" class="delimiter">[</span><a href="#424633" title="G">G</a>, <a href="#424634" title="A">A</a>, <a href="#424634" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#424799" title="F[A]">fa</a><span class="delimiter">)</span><a href="#424800" title="scalaz.Applicative[G]" class="delimiter">(</a><a href="#424800" title="scalaz.Applicative[G]">G</a>.<a href="Applicative.scala.html#34510" title="[A](a: =&gt; A)G[A]">point</a><span title="(a: =&gt; A)G[A]" class="delimiter">[</span><a href="#424634" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#424813" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#424800" title="scalaz.Applicative[G]">G</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; F[A])G[F[A]]">point</a><span class="delimiter">(</span><a href="#424799" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /**
     * @param nat A natural transformation from `M` to `N` for which these properties hold:
     *            `(a: A) =&gt; nat(Applicative[M].pure[A](a)) === Applicative[M].point[A](a)`
     *            `(f: M[A =&gt; B], ma: M[A]) =&gt; nat(Applicative[M].ap(ma)(f)) === Applicative[N].ap(nat(ma))(nat(f))`
     */
    <span class="keyword">def</span> <a title="[N[_], M[_], A](nat: scalaz.~&gt;[M,N])(fma: F[M[A]])(implicit N: scalaz.Applicative[N], implicit M: scalaz.Applicative[M], implicit NFA: scalaz.Equal[N[F[A]]])Boolean" id="424635">naturality</a><span class="delimiter">[</span><a title="[_]" id="424639">N</a><span class="delimiter">[</span><a title="" id="424826">_</a><span class="delimiter">]</span>, <a title="[_]" id="424640">M</a><span class="delimiter">[</span><a title="" id="424825">_</a><span class="delimiter">]</span>, <a title="" id="424641">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.~&gt;[M,N]" id="424819">nat</a>: <span class="delimiter">(</span>M <a href="NaturalTransformation.scala.html#19940" title="scalaz.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span><span class="delimiter">)</span>
                                 <span class="delimiter">(</span><a title="F[M[A]]" id="424820">fma</a>: <a href="#23766" title="F[M[A]]">F</a><span class="delimiter">[</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
                                 <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[N]" id="424821">N</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span>, <a title="scalaz.Applicative[M]" id="424822">M</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[M]">Applicative</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="scalaz.Equal[N[F[A]]]" id="424823">NFA</a>: <a href="Equal.scala.html#19253" title="scalaz.Equal[N[F[A]]]">Equal</a><span class="delimiter">[</span>N<span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="N[F[A]]" id="424832">n1</a>: <a href="#424639" title="N[F[A]]">N</a><span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="NaturalTransformation.scala.html#144451" title="[A](fa: M[A])N[A]">nat</a><span title="(fa: M[F[A]])N[F[A]]" class="delimiter">[</span><a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#115577" title="[G[_], A](fga: F[G[A]])(implicit evidence$6: scalaz.Applicative[G])G[F[A]]">sequence</a><span title="(fga: F[M[A]])(implicit evidence$6: scalaz.Applicative[M])M[F[A]]" class="delimiter">[</span><a href="#424640" title="M">M</a>, <a href="#424641" title="A">A</a><span class="delimiter">]</span><a href="#424822" title="scalaz.Applicative[M]" class="delimiter">(</a><a href="#424820" title="F[M[A]]">fma</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="N[F[A]]" id="424833">n2</a>: <a href="#424639" title="N[F[A]]">N</a><span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#115577" title="[G[_], A](fga: F[G[A]])(implicit evidence$6: scalaz.Applicative[G])G[F[A]]">sequence</a><span title="(fga: F[N[A]])(implicit evidence$6: scalaz.Applicative[N])N[F[A]]" class="delimiter">[</span><a href="#424639" title="N">N</a>, <a href="#424641" title="A">A</a><span class="delimiter">]</span><a href="#424821" title="scalaz.Applicative[N]" class="delimiter">(</a><a href="#33551" title="(fa: F[M[A]])(f: M[A] =&gt; N[A])F[N[A]]">map</a><span class="delimiter">(</span><a href="#424820" title="F[M[A]]">fma</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="M[A]" id="424854">ma</a> =&gt; <a href="NaturalTransformation.scala.html#144451" title="(fa: M[A])N[A]">nat</a><span class="delimiter">(</span><a href="#424854" title="M[A]">ma</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#424823" title="scalaz.Equal[N[F[A]]]">NFA</a>.<a href="Equal.scala.html#50753" title="(a1: N[F[A]], a2: N[F[A]])Boolean">equal</a><span class="delimiter">(</span><a href="#424832" title="N[F[A]]">n1</a>, <a href="#424833" title="N[F[A]]">n2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    /** Two independent effects can be fused into a single effect, their product. */
    <span class="keyword">def</span> <a title="[N[_], M[_], A, B](fa: F[A], amb: A =&gt; M[B], anb: A =&gt; N[B])(implicit N: scalaz.Applicative[N], implicit M: scalaz.Applicative[M], implicit MN: scalaz.Equal[(M[F[B]], N[F[B]])])Boolean" id="424642">parallelFusion</a><span class="delimiter">[</span><a title="[_]" id="424647">N</a><span class="delimiter">[</span><a title="" id="424872">_</a><span class="delimiter">]</span>, <a title="[_]" id="424648">M</a><span class="delimiter">[</span><a title="" id="424871">_</a><span class="delimiter">]</span>, <a title="" id="424649">A</a>, <a title="" id="424650">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="424864">fa</a>: <a href="#23766" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A =&gt; M[B]" id="424865">amb</a>: A =&gt; M<span class="delimiter">[</span>B<span class="delimiter">]</span>, <a title="A =&gt; N[B]" id="424866">anb</a>: A =&gt; N<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>
                                        <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[N]" id="424867">N</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[N]">Applicative</a><span class="delimiter">[</span>N<span class="delimiter">]</span>, <a title="scalaz.Applicative[M]" id="424868">M</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[M]">Applicative</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="scalaz.Equal[(M[F[B]], N[F[B]])]" id="424869">MN</a>: <a href="Equal.scala.html#19253" title="scalaz.Equal[(M[F[B]], N[F[B]])]">Equal</a><span class="delimiter">[</span><span class="delimiter">(</span>M<span class="delimiter">[</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span>, N<span class="delimiter">[</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="[A](M[A], N[A])" id="424879">MN</a><span class="delimiter">[</span><a title="" id="424880">A</a><span class="delimiter">]</span> = <span title="(M[A], N[A])" class="delimiter">(</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span>, N<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="(M[F[B]], N[F[B]])" id="424881">t1</a>: <span title="(M[F[B]], N[F[B]])">MN</span><span class="delimiter">[</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(_1: M[F[B]], _2: N[F[B]])(M[F[B]], N[F[B]])" class="delimiter">(</span><a href="#115519" title="[G[_], A, B](fa: F[A])(f: A =&gt; G[B])(implicit evidence$3: scalaz.Applicative[G])G[F[B]]">traverse</a><span title="(fa: F[A])(f: A =&gt; M[B])(implicit evidence$3: scalaz.Applicative[M])M[F[B]]" class="delimiter">[</span><a href="#424648" title="M">M</a>, <a href="#424649" title="A">A</a>, <a href="#424650" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#424864" title="F[A]">fa</a><span class="delimiter">)</span><a href="#424868" title="scalaz.Applicative[M]" class="delimiter">(</a><a href="#424865" title="A =&gt; M[B]">amb</a><span class="delimiter">)</span>, <a href="#115519" title="[G[_], A, B](fa: F[A])(f: A =&gt; G[B])(implicit evidence$3: scalaz.Applicative[G])G[F[B]]">traverse</a><span title="(fa: F[A])(f: A =&gt; N[B])(implicit evidence$3: scalaz.Applicative[N])N[F[B]]" class="delimiter">[</span><a href="#424647" title="N">N</a>, <a href="#424649" title="A">A</a>, <a href="#424650" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#424864" title="F[A]">fa</a><span class="delimiter">)</span><a href="#424867" title="scalaz.Applicative[N]" class="delimiter">(</a><a href="#424866" title="A =&gt; N[B]">anb</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="(M[F[B]], N[F[B]])" id="424882">t2</a>: <span title="(M[F[B]], N[F[B]])">MN</span><span class="delimiter">[</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#115519" title="[G[_], A, B](fa: F[A])(f: A =&gt; G[B])(implicit evidence$3: scalaz.Applicative[G])G[F[B]]">traverse</a><span title="(fa: F[A])(f: A =&gt; (M[B], N[B]))(implicit evidence$3: scalaz.Applicative[MN])(M[F[B]], N[F[B]])" class="delimiter">[</span><span title="MN">MN</span>, <a href="#424649" title="A">A</a>, <a href="#424650" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#424864" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="424903">a</a> =&gt; <span title="(_1: M[B], _2: N[B])(M[B], N[B])" class="delimiter">(</span><a href="#424865" title="(v1: A)M[B]">amb</a><span class="delimiter">(</span><a href="#424903" title="A">a</a><span class="delimiter">)</span>, <a href="#424866" title="(v1: A)N[B]">anb</a><span class="delimiter">(</span><a href="#424903" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#424868" title="scalaz.Applicative[M]">M</a> <a href="Applicative.scala.html#34553" title="(implicit G0: scalaz.Applicative[N])scalaz.Applicative[[α](M[α], N[α])]">product</a> <a href="#424867" title="scalaz.Applicative[N]">N</a><span class="delimiter">)</span>
      <a href="#424869" title="scalaz.Equal[(M[F[B]], N[F[B]])]">MN</a>.<a href="Equal.scala.html#50753" title="(a1: (M[F[B]], N[F[B]]), a2: (M[F[B]], N[F[B]]))Boolean">equal</a><span class="delimiter">(</span><a href="#424881" title="(M[F[B]], N[F[B]])">t1</a>, <a href="#424882" title="(M[F[B]], N[F[B]])">t2</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="=&gt; Traverse.this.TraverseLaw" id="33625">traverseLaw</a> = <a href="#424947" title="Traverse.this.TraverseLaw" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Traverse.this.TraverseLaw" id="424947">TraverseLaw</a> <span class="delimiter">{</span><span class="delimiter">}</span>

  ////
  <span class="keyword">val</span> <a title="traverseSyntax extends AnyRef with scalaz.syntax.TraverseSyntax[F]" id="33626">traverseSyntax</a> = <a href="#423277" title="scalaz.syntax.TraverseSyntax[F]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.syntax.TraverseSyntax[F]" id="423277">scalaz</a>.syntax.<a href="syntax/TraverseSyntax.scala.html#28333" title="scalaz.syntax.TraverseSyntax[F]">TraverseSyntax</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Traverse[F]" id="423284">F</a> = <a href="#20819" title="scalaz.Traverse[F]">Traverse</a>.<span class="keyword">this</span> <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="scalaz.Traverse.type" id="20820">Traverse</a> <a href="#20821" title="scalaz.Traverse.type" class="delimiter">{</a>
  @inline <span class="keyword">def</span> <a title="[F[_]](implicit F: scalaz.Traverse[F])scalaz.Traverse[F]" id="72870">apply</a><span class="delimiter">[</span><a title="[_]" id="72872">F</a><span class="delimiter">[</span><a title="" id="72874">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Traverse[F]" id="72873">F</a>: <a href="#20819" title="scalaz.Traverse[F]">Traverse</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20819" title="scalaz.Traverse[F]">Traverse</a><span class="delimiter">[</span>F<span class="delimiter">]</span> = <a href="#72873" title="scalaz.Traverse[F]">F</a>

  ////

  ////
<span class="delimiter">}</span>

        </pre>
    </body>
</html>