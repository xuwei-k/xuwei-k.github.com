<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/std/Map.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz
<span class="keyword">package</span> std

<span class="keyword">trait</span> <a title="trait MapInstances0 extends AnyRef" id="24664">MapInstances0</a> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">private</span><span class="delimiter">[</span>std<span class="delimiter">]</span> <span class="keyword">trait</span> <a title="trait MapEqual[K, V] extends AnyRef with scalaz.Equal[Map[K,V]]" id="45751">MapEqual</a><span class="delimiter">[</span><a title="" id="45752">K</a>, <a title="" id="45753">V</a><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="../Equal.scala.html#19253" title="scalaz.Equal[Map[K,V]]">Equal</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Order[K]" id="467494">OK</a>: <a href="../Order.scala.html#20138" title="scalaz.Order[K]">Order</a><span class="delimiter">[</span>K<span class="delimiter">]</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Equal[V]" id="467495">OV</a>: <a href="../Equal.scala.html#19253" title="scalaz.Equal[V]">Equal</a><span class="delimiter">[</span>V<span class="delimiter">]</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(a1: Map[K,V], a2: Map[K,V])Boolean" id="467496">equal</a><span class="delimiter">(</span><a title="Map[K,V]" id="467505">a1</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="Map[K,V]" id="467506">a2</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">import</span> <a href="Set.scala.html#24503" title="scalaz.std.set.type">set</a>._
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#467497" title="=&gt; Boolean">equalIsNatural</a><span class="delimiter">)</span> <a href="#467505" title="Map[K,V]">a1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#467506" title="Map[K,V]">a2</a>
      <span class="keyword">else</span> <a href="../Equal.scala.html#50773" title="[F](implicit F: scalaz.Equal[F])scalaz.Equal[F]">Equal</a><a href="Set.scala.html#45839" title="(implicit F: scalaz.Equal[Set[K]])scalaz.Equal[Set[K]]" class="delimiter">[</a><span title="Set[K]">Set</span><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">]</span>.<a href="../Equal.scala.html#50753" title="(a1: Set[K], a2: Set[K])Boolean">equal</a><span class="delimiter">(</span><a href="#467505" title="Map[K,V]">a1</a>.<span title="=&gt; scala.collection.immutable.Set[K]">keySet</span>, <a href="#467505" title="Map[K,V]">a1</a>.<span title="=&gt; scala.collection.immutable.Set[K]">keySet</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <a href="#467505" title="Map[K,V]">a1</a>.<span title="(p: ((K, V)) =&gt; Boolean)Boolean">forall</span> <a href="#467533" title="(K, V)" class="delimiter">{</a>
          <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1682703" title="K" id="467536">k</a>, <a href="#1682703" title="V" id="467537">v</a><span class="delimiter">)</span> =&gt; <a href="../Equal.scala.html#50773" title="[F](implicit F: scalaz.Equal[F])scalaz.Equal[F]">Equal</a><a href="#467495" title="(implicit F: scalaz.Equal[V])scalaz.Equal[V]" class="delimiter">[</a><a href="#45753" title="V">V</a><span class="delimiter">]</span>.<a href="../Equal.scala.html#50753" title="(a1: V, a2: V)Boolean">equal</a><a href="#1682705" title="(x: Boolean)Boolean" class="delimiter">(</a><a href="#467537" title="V">v</a>, <a href="#467506" title="(key: K)V">a2</a><span class="delimiter">(</span><a href="#467536" title="K">k</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="467497">equalIsNatural</a>: <span title="Boolean">Boolean</span> = <a href="../Equal.scala.html#50773" title="[F](implicit F: scalaz.Equal[F])scalaz.Equal[F]">Equal</a><a href="#467494" title="(implicit F: scalaz.Equal[K])scalaz.Equal[K]" class="delimiter">[</a><a href="#45752" title="K">K</a><span class="delimiter">]</span>.<a href="../Equal.scala.html#50757" title="=&gt; Boolean">equalIsNatural</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="../Equal.scala.html#50773" title="[F](implicit F: scalaz.Equal[F])scalaz.Equal[F]">Equal</a><a href="#467495" title="(implicit F: scalaz.Equal[V])scalaz.Equal[V]" class="delimiter">[</a><a href="#45753" title="V">V</a><span class="delimiter">]</span>.<a href="../Equal.scala.html#50757" title="=&gt; Boolean">equalIsNatural</a>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V](implicit evidence$1: scalaz.Order[K], implicit evidence$2: scalaz.Equal[V])scalaz.Equal[Map[K,V]]" id="104254">mapEqual</a><span class="delimiter">[</span><a title="" id="45757">K</a>: Order, <a title="" id="45758">V</a>: Equal<span class="delimiter">]</span>: <a href="../Equal.scala.html#19253" title="scalaz.Equal[Map[K,V]]">Equal</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#467573" title="MapInstances0.this.MapEqual[K,V]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with MapInstances0.this.MapEqual[K,V]" id="467573">MapEqual</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Order[K]" id="467575">OK</a> = <a href="../Order.scala.html#61798" title="[F](implicit F: scalaz.Order[F])scalaz.Order[F]">Order</a><a href="#104254" title="(implicit F: scalaz.Order[K])scalaz.Order[K]" class="delimiter">[</a><a href="#45757" title="K">K</a><span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Equal[V]" id="467576">OV</a> = <a href="../Equal.scala.html#50773" title="[F](implicit F: scalaz.Equal[F])scalaz.Equal[F]">Equal</a><a href="#104254" title="(implicit F: scalaz.Equal[V])scalaz.Equal[V]" class="delimiter">[</a><a href="#45758" title="V">V</a><span class="delimiter">]</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait MapInstances extends AnyRef with scalaz.std.MapInstances0" id="26065">MapInstances</a> <span title="Unit" class="keyword">extends</span> <a href="#24664" title="scalaz.std.MapInstances0">MapInstances0</a> <span class="delimiter">{</span>
  <span class="keyword">import</span> syntax.std.<a href="../syntax/std/package.scala.html#31027" title="scalaz.syntax.std.function2.type">function2</a>._

  /** Covariant over the value parameter, where `plus` applies the
    * `Last` semigroup to values.
    */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K]=&gt; scalaz.Traverse[[V]scala.collection.immutable.Map[K,V]] with scalaz.IsEmpty[[V]scala.collection.immutable.Map[K,V]]" id="45761">mapInstance</a><span class="delimiter">[</span><a title="" id="45763">K</a><span class="delimiter">]</span> = <a href="#103560" title="scalaz.Traverse[[V]scala.collection.immutable.Map[K,V]] with scalaz.IsEmpty[[V]scala.collection.immutable.Map[K,V]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Traverse[[V]scala.collection.immutable.Map[K,V]] with scalaz.IsEmpty[[V]scala.collection.immutable.Map[K,V]]" id="103560">Traverse</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> F<span class="delimiter">[</span>V<span class="delimiter">]</span> = Map<span class="delimiter">[</span>K,V<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#F<span class="delimiter">]</span> <span class="keyword">with</span> <a href="../IsEmpty.scala.html#21929" title="scalaz.IsEmpty[[V]scala.collection.immutable.Map[K,V]]">IsEmpty</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> F<span class="delimiter">[</span>V<span class="delimiter">]</span> = Map<span class="delimiter">[</span>K,V<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#F<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[V]=&gt; scala.collection.immutable.Map[K,V]" id="103762">empty</a><span class="delimiter">[</span><a title="" id="103764">V</a><span class="delimiter">]</span> = <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[K,V]" class="delimiter">[</span><a href="#45763" title="K">K</a>, <a href="#103764" title="V">V</a><span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="[V](a: Map[K,V], b: =&gt; Map[K,V])scala.collection.immutable.Map[K,V]" id="103765">plus</a><span class="delimiter">[</span><a title="" id="103767">V</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,V]" id="103825">a</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="=&gt; Map[K,V]" id="103826">b</a>: =&gt; Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#103825" title="Map[K,V]">a</a> <span title="(xs: scala.collection.GenTraversableOnce[(K, V)])scala.collection.immutable.Map[K,V]">++</span> <a href="#103826" title="=&gt; Map[K,V]">b</a>
    <span class="keyword">def</span> <a title="[V](fa: Map[K,V])Boolean" id="103768">isEmpty</a><span class="delimiter">[</span><a title="" id="103770">V</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,V]" id="104062">fa</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#104062" title="Map[K,V]">fa</a>.<span title="=&gt; Boolean">isEmpty</span>

    <span class="keyword">def</span> <a title="[G[_], A, B](m: Map[K,A])(f: A =&gt; G[B])(implicit G: scalaz.Applicative[G])G[Map[K,B]]" id="103771">traverseImpl</a><span class="delimiter">[</span><a title="[_]" id="103775">G</a><span class="delimiter">[</span><a title="" id="104077">_</a><span class="delimiter">]</span>,<a title="" id="103776">A</a>,<a title="" id="103777">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="104074">m</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K,A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; G[B]" id="104075">f</a>: A =&gt; G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[G]" id="104076">G</a>: <a href="../Applicative.scala.html#15416" title="scalaz.Applicative[G]">Applicative</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#103775" title="G[Map[K,B]]">G</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K,B<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">import</span> <a href="#104076" title="scalaz.Applicative[G]">G</a>.<a href="../Functor.scala.html#33469" title="=&gt; scalaz.syntax.FunctorSyntax[G]">functorSyntax</a>._
      <a href="List.scala.html#25475" title="scalaz.std.list.type">list</a>.<a href="List.scala.html#45739" title="=&gt; scalaz.Traverse[List] with scalaz.MonadPlus[List] with scalaz.Each[List] with scalaz.Index[List] with scalaz.Length[List] with scalaz.Zip[List] with scalaz.Unzip[List] with scalaz.IsEmpty[List]{def empty[A]: List[Nothing]}">listInstance</a>.<a href="../Traverse.scala.html#33473" title="(fa: List[(K, A)])(f: ((K, A)) =&gt; G[(K, B)])(implicit evidence$1: scalaz.Applicative[G])G[List[(K, B)]]">traverseImpl</a><span class="delimiter">(</span><a href="#104074" title="Map[K,A]">m</a>.<span title="=&gt; List[(K, A)]">toList</span><span class="delimiter">)</span><a href="../syntax/FunctorSyntax.scala.html#104125" title="(v: G[List[(K, B)]])scalaz.syntax.FunctorOps[G,List[(K, B)]]" class="delimiter">(</a><a href="#104194" title="(K, A)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1682709" title="K" id="104199">k</a>, <a href="#1682709" title="A" id="104200">v</a><span class="delimiter">)</span> =&gt; <a href="#104075" title="(v1: A)G[B]">f</a><a href="../syntax/FunctorSyntax.scala.html#104125" title="(v: G[B])scalaz.syntax.FunctorOps[G,B]" class="delimiter">(</a><a href="#104200" title="A">v</a><span class="delimiter">)</span> <a href="#1682711" title="(x: G[(K, B)])G[(K, B)]">map</a> <span class="delimiter">(</span><a href="#104199" title="(x: K)ArrowAssoc[K]">k</a> <span title="(y: B)(K, B)">-&gt;</span> <a href="#105927" title="B">_</a><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span> <a href="../syntax/FunctorSyntax.scala.html#52942" title="(f: List[(K, B)] =&gt; scala.collection.immutable.Map[K,B])G[scala.collection.immutable.Map[K,B]]">map</a> <span class="delimiter">(</span><a href="#106250" title="List[(K, B)]">_</a>.<span title="(implicit ev: &lt;:&lt;[(K, B),(K, B)])scala.collection.immutable.Map[K,B]">toMap</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  /** Map union monoid, unifying values with `V`'s `append`. */
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V](implicit evidence$3: scalaz.Semigroup[V])scalaz.Monoid[Map[K,V]]" id="103554">mapMonoid</a><span class="delimiter">[</span><a title="" id="45767">K</a>, <a title="" id="45768">V</a>: Semigroup<span class="delimiter">]</span>: <a href="../Monoid.scala.html#12518" title="scalaz.Monoid[Map[K,V]]">Monoid</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#467592" title="scalaz.Monoid[Map[K,V]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Monoid[Map[K,V]]" id="467592">Monoid</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Map[K,V]" id="467594">zero</a> = <span title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</span><span title="(elems: (K, V)*)scala.collection.immutable.Map[K,V]" class="delimiter">[</span><a href="#45767" title="K">K</a>, <a href="#45768" title="V">V</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(m1: Map[K,V], m2: =&gt; Map[K,V])Map[K,V]" id="467595">append</a><span class="delimiter">(</span><a title="Map[K,V]" id="467601">m1</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="=&gt; Map[K,V]" id="467602">m2</a>: =&gt; Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      // Eagerly consume m2 as the value is used more than once.
      <span class="keyword">val</span> <a title="Map[K,V]" id="467607">m2Instance</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <a href="#467602" title="=&gt; Map[K,V]">m2</a>
      // semigroups are not commutative, so order may matter.
      <span class="keyword">val</span> <a href="#1682717" title="(x: (Map[K,V], Map[K,V], (V, V) =&gt; V))(Map[K,V], Map[K,V], (V, V) =&gt; V)" class="delimiter">(</a><a href="#1682715" title="Map[K,V]" id="467609">from</a>, <a href="#1682715" title="Map[K,V]" id="467610">to</a>, <a href="#1682715" title="(V, V) =&gt; V" id="467611">semigroup</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <a href="#1682715" title="(Map[K,V], Map[K,V], (V, V) =&gt; V)" class="keyword">if</a> <span class="delimiter">(</span><a href="#467601" title="Map[K,V]">m1</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <a href="#467607" title="Map[K,V]">m2Instance</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <span title="(_1: Map[K,V], _2: Map[K,V], _3: (V, V) =&gt; V)(Map[K,V], Map[K,V], (V, V) =&gt; V)" class="delimiter">(</span><a href="#467607" title="Map[K,V]">m2Instance</a>, <a href="#467601" title="Map[K,V]">m1</a>, <a href="../Semigroup.scala.html#51415" title="[F](implicit F: scalaz.Semigroup[F])scalaz.Semigroup[F]">Semigroup</a><a href="#103554" title="(implicit F: scalaz.Semigroup[V])scalaz.Semigroup[V]" class="delimiter">[</a><a href="#45768" title="V">V</a><span class="delimiter">]</span>.<a href="../Semigroup.scala.html#51147" title="(f1: V, f2: =&gt; V)V">append</a><span class="delimiter">(</span><a href="#467623" title="V">_</a>: <a href="#45768" title="V">V</a>, <a href="#467624" title="V">_</a>: <a href="#45768" title="V">V</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="(_1: Map[K,V], _2: Map[K,V], _3: (V, V) =&gt; V)(Map[K,V], Map[K,V], (V, V) =&gt; V)" class="delimiter">(</span><a href="#467601" title="Map[K,V]">m1</a>, <a href="#467607" title="Map[K,V]">m2Instance</a>, <span class="delimiter">(</span><a href="../Semigroup.scala.html#51415" title="[F](implicit F: scalaz.Semigroup[F])scalaz.Semigroup[F]">Semigroup</a><a href="#103554" title="(implicit F: scalaz.Semigroup[V])scalaz.Semigroup[V]" class="delimiter">[</a><a href="#45768" title="V">V</a><span class="delimiter">]</span>.<a href="../Semigroup.scala.html#51147" title="(f1: V, f2: =&gt; V)V">append</a><a href="../syntax/std/Function2Ops.scala.html#46941" title="(f: (V, V) =&gt; V)scalaz.syntax.std.Function2Ops[V,V,V]{val self: (V, V) =&gt; V}" class="delimiter">(</a><a href="#467649" title="V">_</a>: <a href="#45768" title="V">V</a>, <a href="#467650" title="V">_</a>: <a href="#45768" title="V">V</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../syntax/std/Function2Ops.scala.html#104220" title="=&gt; (V, V) =&gt; V">flip</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <a href="#467609" title="Map[K,V]">from</a>.<span title="(z: Map[K,V])(op: (Map[K,V], (K, V)) =&gt; Map[K,V])Map[K,V]">foldLeft</span><span class="delimiter">(</span><a href="#467610" title="Map[K,V]">to</a><span class="delimiter">)</span> <a href="#467734" title="(_1: Map[K,V], _2: (K, V))(Map[K,V], (K, V))" class="delimiter">{</a>
        <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1682721" title="Map[K,V]" id="467747">to</a>, <a href="#1682721" title="=&gt; (K, V)" class="delimiter">(</a><a href="#1682722" title="K" id="467752">k</a>, <a href="#1682722" title="V" id="467753">v</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#467747" title="Map[K,V]">to</a> <a href="#1682724" title="(x: Map[K,V])Map[K,V]">+</a> <span class="delimiter">(</span><a href="#467752" title="(x: K)ArrowAssoc[K]">k</a> <span title="(y: V)(K, V)">-&gt;</span> <a href="#467747" title="Map[K,V]">to</a>.<span title="(key: K)Option[V]">get</span><span class="delimiter">(</span><a href="#467752" title="K">k</a><span class="delimiter">)</span>.<span title="(f: V =&gt; V)Option[V]">map</span><span class="delimiter">(</span><a href="#467611" title="(v1: V, v2: V)V">semigroup</a><span class="delimiter">(</span><a href="#467829" title="V">_</a>, <a href="#467753" title="V">v</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(default: =&gt; V)V">getOrElse</span><span class="delimiter">(</span><a href="#467753" title="V">v</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V](implicit K: scalaz.Show[K], implicit V: scalaz.Show[V])scalaz.Show[Map[K,V]]" id="45769">mapShow</a><span class="delimiter">[</span><a title="" id="45772">K</a>, <a title="" id="45773">V</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Show[K]" id="103549">K</a>: <a href="../Show.scala.html#9644" title="scalaz.Show[K]">Show</a><span class="delimiter">[</span>K<span class="delimiter">]</span>, <a title="scalaz.Show[V]" id="103550">V</a>: <a href="../Show.scala.html#9644" title="scalaz.Show[V]">Show</a><span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Show.scala.html#9644" title="scalaz.Show[Map[K,V]]">Show</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="../Show.scala.html#9645" title="scalaz.Show.type">Show</a>.<a href="../Show.scala.html#143450" title="(f: Map[K,V] =&gt; scalaz.Cord)scalaz.Show[Map[K,V]]">show</a><span class="delimiter">(</span><a title="Map[K,V]" id="467847">m</a> =&gt; <span title="String(&quot;Map[&quot;)" class="string">&quot;Map[&quot;</span> <a href="../Cord.scala.html#99925" title="(x: =&gt; String)scalaz.Cord">+:</a>
                <a href="../Cord.scala.html#8391" title="scalaz.Cord.type">Cord</a>.<a href="../Cord.scala.html#100191" title="(sep: scalaz.Cord, as: scalaz.Cord*)scalaz.Cord">mkCord</a><span class="delimiter">(</span><a href="../Cord.scala.html#100183" title="implicit scalaz.Cord.stringToCord : (s: String)scalaz.Cord" class="string">&quot;, &quot;</a>, <a href="#467847" title="Map[K,V]">m</a>.<span title="=&gt; Seq[(K, V)]">toSeq</span>.<span title="=&gt; scala.collection.SeqView[(K, V),Seq[(K, V)]]">view</span>.<span title="(f: ((K, V)) =&gt; scalaz.Cord)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.SeqView[(K, V),Seq[(K, V)]],scalaz.Cord,scala.collection.SeqView[scalaz.Cord,Seq[_]]])scala.collection.SeqView[scalaz.Cord,Seq[_]]">map</span><a href="#468850" title="(K, V)" class="delimiter">{</a>
                  <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1682728" title="K" id="468855">k</a>, <a href="#1682728" title="V" id="468856">v</a><span class="delimiter">)</span> =&gt; <a href="../Cord.scala.html#100186" title="(as: scalaz.Cord*)scalaz.Cord">Cord</a><a href="#1682730" title="(x: scalaz.Cord)scalaz.Cord" class="delimiter">(</a><a href="#103549" title="scalaz.Show[K]">K</a> <a href="../Show.scala.html#68438" title="(f: K)scalaz.Cord">show</a> <a href="#468855" title="K">k</a>, <a href="../Cord.scala.html#100183" title="implicit scalaz.Cord.stringToCord : (s: String)scalaz.Cord" class="string">&quot;-&gt;&quot;</a>, <a href="#103550" title="scalaz.Show[V]">V</a> <a href="../Show.scala.html#68438" title="(f: V)scalaz.Cord">show</a> <a href="#468856" title="V">v</a><span class="delimiter">)</span>
                <span class="delimiter">}</span>: _*<span class="delimiter">)</span> <a href="../Cord.scala.html#99924" title="(x: =&gt; String)scalaz.Cord">:+</a> <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V](implicit evidence$4: scalaz.Order[K], implicit evidence$5: scalaz.Order[V])scalaz.Order[Map[K,V]]" id="103544">mapOrder</a><span class="delimiter">[</span><a title="" id="45777">K</a>: Order, <a title="" id="45778">V</a>: Order<span class="delimiter">]</span>: <a href="../Order.scala.html#20138" title="scalaz.Order[Map[K,V]]">Order</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#469438" title="scalaz.Order[Map[K,V]] with MapInstances.this.MapEqual[K,V]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Order[Map[K,V]] with MapInstances.this.MapEqual[K,V]" id="469438">Order</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> <span class="keyword">with</span> <a href="#45751" title="MapInstances.this.MapEqual[K,V]">MapEqual</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Order[K]" id="469440">OK</a> = <a href="../Order.scala.html#61798" title="[F](implicit F: scalaz.Order[F])scalaz.Order[F]">Order</a><a href="#103544" title="(implicit F: scalaz.Order[K])scalaz.Order[K]" class="delimiter">[</a><a href="#45777" title="K">K</a><span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Equal[V]" id="469441">OV</a> = <a href="../Equal.scala.html#50773" title="[F](implicit F: scalaz.Equal[F])scalaz.Equal[F]">Equal</a><a href="#103544" title="(implicit F: scalaz.Equal[V])scalaz.Equal[V]" class="delimiter">[</a><a href="#45778" title="V">V</a><span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="(x: Map[K,V], y: Map[K,V])scalaz.Ordering" id="469442">order</a><span class="delimiter">(</span><a title="Map[K,V]" id="469467">x</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="Map[K,V]" id="469468">y</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Ordering.scala.html#14957" title="scalaz.Ordering">Ordering</a> = <span class="delimiter">{</span>
      <span class="keyword">import</span> collection.immutable.IndexedSeq
      <span class="keyword">import</span> <a href="IndexedSeq.scala.html#24608" title="scalaz.std.indexedSeq.type">indexedSeq</a>._
      <span class="keyword">import</span> <a href="Tuple.scala.html#24098" title="scalaz.std.tuple.type">tuple</a>._
      <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scala.math.Ordering[K]" id="469477">ok</a> = <a href="../Order.scala.html#61798" title="[F](implicit F: scalaz.Order[F])scalaz.Order[F]">Order</a><a href="#103544" title="(implicit F: scalaz.Order[K])scalaz.Order[K]" class="delimiter">[</a><a href="#45777" title="K">K</a><span class="delimiter">]</span>.<a href="../Order.scala.html#51583" title="=&gt; scala.math.Ordering[K]">toScalaOrdering</a>
      <a href="../Semigroup.scala.html#51415" title="[F](implicit F: scalaz.Semigroup[F])scalaz.Semigroup[F]">Semigroup</a><a href="../Ordering.scala.html#61839" title="(implicit F: scalaz.Semigroup[scalaz.Ordering])scalaz.Semigroup[scalaz.Ordering]" class="delimiter">[</a><a href="../Ordering.scala.html#14957" title="scalaz.Ordering">Ordering</a><span class="delimiter">]</span>
       .<a href="../Semigroup.scala.html#51147" title="(f1: scalaz.Ordering, f2: =&gt; scalaz.Ordering)scalaz.Ordering">append</a><span class="delimiter">(</span><a href="../Order.scala.html#61798" title="[F](implicit F: scalaz.Order[F])scalaz.Order[F]">Order</a><a href="../Order.scala.html#61803" title="(implicit F: scalaz.Order[Int])scalaz.Order[Int]" class="delimiter">[</a><span title="Int">Int</span><span class="delimiter">]</span>.<a href="../Order.scala.html#51572" title="(x: Int, y: Int)scalaz.Ordering">order</a><span class="delimiter">(</span><a href="#469467" title="Map[K,V]">x</a>.<span title="=&gt; Int">size</span>, <a href="#469468" title="Map[K,V]">y</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>,
               <a href="../Order.scala.html#61798" title="[F](implicit F: scalaz.Order[F])scalaz.Order[F]">Order</a><a href="IndexedSeq.scala.html#149366" title="(implicit F: scalaz.Order[scala.collection.immutable.IndexedSeq[(K, V)]])scalaz.Order[scala.collection.immutable.IndexedSeq[(K, V)]]" class="delimiter">[</a><span title="scala.collection.immutable.IndexedSeq[(K, V)]">IndexedSeq</span><span class="delimiter">[</span><span class="delimiter">(</span>K, V<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span>
                .<a href="../Order.scala.html#51572" title="(x: scala.collection.immutable.IndexedSeq[(K, V)], y: scala.collection.immutable.IndexedSeq[(K, V)])scalaz.Ordering">order</a><span class="delimiter">(</span><a href="#469467" title="Map[K,V]">x</a>.<span title="=&gt; scala.collection.immutable.IndexedSeq[(K, V)]">toIndexedSeq</span>.<span title="(f: ((K, V)) =&gt; K)(implicit ord: scala.math.Ordering[K])scala.collection.immutable.IndexedSeq[(K, V)]">sortBy</span><a href="#469477" title="scala.math.Ordering[K]" class="delimiter">(</a><span class="delimiter">(</span><a href="#471388" title="(K, V)">_</a>:<span title="(K, V)" class="delimiter">(</span>K,V<span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; K">_1</span><span class="delimiter">)</span>,
                       <a href="#469468" title="Map[K,V]">y</a>.<span title="=&gt; scala.collection.immutable.IndexedSeq[(K, V)]">toIndexedSeq</span>.<span title="(f: ((K, V)) =&gt; K)(implicit ord: scala.math.Ordering[K])scala.collection.immutable.IndexedSeq[(K, V)]">sortBy</span><a href="#469477" title="scala.math.Ordering[K]" class="delimiter">(</a><span class="delimiter">(</span><a href="#471622" title="(K, V)">_</a>:<span title="(K, V)" class="delimiter">(</span>K,V<span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; K">_1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait MapFunctions extends AnyRef" id="25363">MapFunctions</a> <span title="Unit" class="delimiter">{</span>
  /** Vary the value of `m get k`. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[K, A](m: Map[K,A], k: K)(f: Option[A] =&gt; Option[A])Map[K,A]" id="471854">alter</a><span class="delimiter">[</span><a title="" id="471857">K</a>, <a title="" id="471858">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="471900">m</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span>, <a title="K" id="471901">k</a>: <a href="#471857" title="K">K</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Option[A] =&gt; Option[A]" id="471902">f</a>: <span class="delimiter">(</span>Option<span class="delimiter">[</span>A<span class="delimiter">]</span> =&gt; Option<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span> =
    <a href="#471902" title="(v1: Option[A])Option[A]">f</a><span class="delimiter">(</span><a href="#471900" title="Map[K,A]">m</a> <span title="(key: K)Option[A]">get</span> <a href="#471901" title="K">k</a><span class="delimiter">)</span> <span title="(f: A =&gt; scala.collection.immutable.Map[K,A])Option[scala.collection.immutable.Map[K,A]]">map</span> <span class="delimiter">(</span><a href="#471900" title="Map[K,A]">m</a>.<span title="(key: K, value: A)scala.collection.immutable.Map[K,A]">updated</span><span class="delimiter">(</span><a href="#471901" title="K">k</a>, <a href="#471913" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(default: =&gt; scala.collection.immutable.Map[K,A])scala.collection.immutable.Map[K,A]">getOrElse</span> <span class="delimiter">(</span><a href="#471900" title="Map[K,A]">m</a> <span title="(key: K)scala.collection.immutable.Map[K,A]">-</span> <a href="#471901" title="K">k</a><span class="delimiter">)</span>

  /** Like `intersectWith`, but tell `f` about the key. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[K, A, B, C](m1: Map[K,A], m2: Map[K,B])(f: (K, A, B) =&gt; C)Map[K,C]" id="471859">intersectWithKey</a><span class="delimiter">[</span><a title="" id="471864">K</a>,<a title="" id="471865">A</a>,<a title="" id="471866">B</a>,<a title="" id="471867">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="471963">m1</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span>, <a title="Map[K,B]" id="471964">m2</a>: <span title="Map[K,B]">Map</span><span class="delimiter">[</span>K, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(K, A, B) =&gt; C" id="471965">f</a>: <span class="delimiter">(</span>K, A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <span title="Map[K,C]">Map</span><span class="delimiter">[</span>K, C<span class="delimiter">]</span> = <a href="#471963" title="Map[K,A]">m1</a> <span title="(pf: PartialFunction[(K, A),(K, C)])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[K,A],(K, C),Map[K,C]])Map[K,C]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[(K, A),(K, C)] with Serializable" id="472039" class="delimiter">{</a>
    <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1682734" title="K" id="472046">k</a>, <a href="#1682734" title="A" id="471992">v</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#471964" title="Map[K,B]">m2</a> <span title="(key: K)Boolean">contains</span> <a href="#472046" title="K">k</a> =&gt; <a href="#472046" title="(x: K)ArrowAssoc[K]">k</a> <a href="#1682736" title="(x: B1)B1">-&gt;</a> <a href="#471965" title="(v1: K, v2: A, v3: B)C">f</a><span class="delimiter">(</span><a href="#472046" title="K">k</a>, <a href="#471992" title="A">v</a>, <a href="#471964" title="(key: K)B">m2</a><span class="delimiter">(</span><a href="#472046" title="K">k</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Collect only elements with matching keys, joining their
    * associated values with `f`.
    */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[K, A, B, C](m1: Map[K,A], m2: Map[K,B])(f: (A, B) =&gt; C)Map[K,C]" id="471868">intersectWith</a><span class="delimiter">[</span><a title="" id="471873">K</a>,<a title="" id="471874">A</a>,<a title="" id="471875">B</a>,<a title="" id="471876">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="472115">m1</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span>, <a title="Map[K,B]" id="472116">m2</a>: <span title="Map[K,B]">Map</span><span class="delimiter">[</span>K, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="472117">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <span title="Map[K,C]">Map</span><span class="delimiter">[</span>K, C<span class="delimiter">]</span> =
    <a href="#471859" title="(m1: Map[K,A], m2: Map[K,B])(f: (K, A, B) =&gt; C)Map[K,C]">intersectWithKey</a><span class="delimiter">(</span><a href="#472115" title="Map[K,A]">m1</a>, <a href="#472116" title="Map[K,B]">m2</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="K" id="472170">_</a>, <a title="A" id="472171">x</a>, <a title="B" id="472172">y</a><span class="delimiter">)</span> =&gt; <a href="#472117" title="(v1: A, v2: B)C">f</a><span class="delimiter">(</span><a href="#472171" title="A">x</a>, <a href="#472172" title="B">y</a><span class="delimiter">)</span><span class="delimiter">)</span>

  /** Exchange keys of `m` according to `f`.  Result may be smaller if
    * `f` maps two or more `K`s to the same `K2`, in which case the
    * resulting associated value is an arbitrary choice.
    */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[K, K2, A](m: Map[K,A])(f: K =&gt; K2)Map[K2,A]" id="471877">mapKeys</a><span class="delimiter">[</span><a title="" id="471881">K</a>, <a title="" id="471882">K2</a>, <a title="" id="471883">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="472177">m</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="K =&gt; K2" id="472178">f</a>: K =&gt; K2<span class="delimiter">)</span>: <span title="Map[K2,A]">Map</span><span class="delimiter">[</span>K2, A<span class="delimiter">]</span> =
    <a href="#472177" title="Map[K,A]">m</a> <span title="(f: ((K, A)) =&gt; (K2, A))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[K,A],(K2, A),Map[K2,A]])Map[K2,A]">map</span> <a href="#472197" title="(K, A)" class="delimiter">{</a><span class="keyword">case</span> <span class="delimiter">(</span><a href="#1682746" title="K" id="472202">k</a>, <a href="#1682746" title="A" id="472203">v</a><span class="delimiter">)</span> =&gt; <a href="#472178" title="(v1: K)K2">f</a><span title="(x: K2)ArrowAssoc[K2]" class="delimiter">(</span><a href="#472202" title="K">k</a><span class="delimiter">)</span> <a href="#1682748" title="(x: (K2, A))(K2, A)">-&gt;</a> <a href="#472203" title="A">v</a><span class="delimiter">}</span>

  /** Like `unionWith`, but telling `f` about the key. */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[K, A](m1: Map[K,A], m2: Map[K,A])(f: (K, A, A) =&gt; A)Map[K,A]" id="471884">unionWithKey</a><span class="delimiter">[</span><a title="" id="471887">K</a>,<a title="" id="471888">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="472265">m1</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span>, <a title="Map[K,A]" id="472266">m2</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(K, A, A) =&gt; A" id="472267">f</a>: <span class="delimiter">(</span>K, A, A<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.Map[K,A]" id="472271">diff</a> = <a href="#472266" title="Map[K,A]">m2</a> <span title="(xs: scala.collection.GenTraversableOnce[K])scala.collection.immutable.Map[K,A]">--</span> <a href="#472265" title="Map[K,A]">m1</a>.<span title="=&gt; scala.collection.immutable.Set[K]">keySet</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.Map[K,A]" id="472272">aug</a> = <a href="#472265" title="Map[K,A]">m1</a> <span title="(f: ((K, A)) =&gt; (K, A))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[K,A],(K, A),scala.collection.immutable.Map[K,A]])scala.collection.immutable.Map[K,A]">map</span> <a href="#472290" title="(K, A)" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1682752" title="K" id="472295">k</a>, <a href="#1682752" title="A" id="472296">v</a><span class="delimiter">)</span> =&gt; <a href="#1682754" title="(x: (K, A))(K, A)" class="keyword">if</a> <span class="delimiter">(</span><a href="#472266" title="Map[K,A]">m2</a> <span title="(key: K)Boolean">contains</span> <a href="#472295" title="K">k</a><span class="delimiter">)</span> <a href="#472295" title="(x: K)ArrowAssoc[K]">k</a> <span title="(y: A)(K, A)">-&gt;</span> <a href="#472267" title="(v1: K, v2: A, v3: A)A">f</a><span class="delimiter">(</span><a href="#472295" title="K">k</a>, <a href="#472296" title="A">v</a>, <a href="#472266" title="(key: K)A">m2</a><span class="delimiter">(</span><a href="#472295" title="K">k</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="(_1: K, _2: A)(K, A)" class="delimiter">(</span><a href="#472295" title="K">k</a>, <a href="#472296" title="A">v</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#472272" title="scala.collection.immutable.Map[K,A]">aug</a> <span title="(xs: scala.collection.GenTraversableOnce[(K, A)])scala.collection.immutable.Map[K,A]">++</span> <a href="#472271" title="scala.collection.immutable.Map[K,A]">diff</a>
  <span class="delimiter">}</span>

  /** Union, resolving collisions with `f`, where the first arg is
    * guaranteed to be from `m1`, the second from `m2`.
    *
    * @note iff `f` gives rise to a [[scalaz.Semigroup]], so does
    *       `unionWith(_, _)(f)`.*/
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[K, A](m1: Map[K,A], m2: Map[K,A])(f: (A, A) =&gt; A)Map[K,A]" id="471889">unionWith</a><span class="delimiter">[</span><a title="" id="471892">K</a>,<a title="" id="471893">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="472560">m1</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span>, <a title="Map[K,A]" id="472561">m2</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, A) =&gt; A" id="472562">f</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span> =
    <a href="#471884" title="(m1: Map[K,A], m2: Map[K,A])(f: (K, A, A) =&gt; A)Map[K,A]">unionWithKey</a><span class="delimiter">(</span><a href="#472560" title="Map[K,A]">m1</a>, <a href="#472561" title="Map[K,A]">m2</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="K" id="472595">_</a>, <a title="A" id="472596">x</a>, <a title="A" id="472597">y</a><span class="delimiter">)</span> =&gt; <a href="#472562" title="(v1: A, v2: A)A">f</a><span class="delimiter">(</span><a href="#472596" title="A">x</a>, <a href="#472597" title="A">y</a><span class="delimiter">)</span><span class="delimiter">)</span>

  /** As with `Map.updated`, but resolve a collision with `f`.  The
    * first argument is guaranteed to be from `m1`.
    */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[K, A](m1: Map[K,A], k: K, v: A)(f: (A, A) =&gt; A)Map[K,A]" id="471894">insertWith</a><span class="delimiter">[</span><a title="" id="471897">K</a>,<a title="" id="471898">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="472600">m1</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span>, <a title="K" id="472601">k</a>: <a href="#471897" title="K">K</a>, <a title="A" id="472602">v</a>: <a href="#471898" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, A) =&gt; A" id="472603">f</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span> =
    <span title="scala.collection.immutable.Map[K,A]" class="keyword">if</span><span class="delimiter">(</span><a href="#472600" title="Map[K,A]">m1</a> <span title="(key: K)Boolean">contains</span> <a href="#472601" title="K">k</a><span class="delimiter">)</span> <a href="#472600" title="Map[K,A]">m1</a> <span title="(kv: (K, A))scala.collection.immutable.Map[K,A]">+</span> <span class="delimiter">(</span><a href="#472601" title="(x: K)ArrowAssoc[K]">k</a> <span title="(y: A)(K, A)">-&gt;</span> <a href="#472603" title="(v1: A, v2: A)A">f</a><span class="delimiter">(</span><a href="#472600" title="(key: K)A">m1</a><span class="delimiter">(</span><a href="#472601" title="K">k</a><span class="delimiter">)</span>, <a href="#472602" title="A">v</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#472600" title="Map[K,A]">m1</a> <span title="(kv: (K, A))scala.collection.immutable.Map[K,A]">+</span> <span class="delimiter">(</span><a href="#472601" title="(x: K)ArrowAssoc[K]">k</a> <span title="(y: A)(K, A)">-&gt;</span> <a href="#472602" title="A">v</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="scalaz.std.map.type" id="25199">map</a> <a href="#25200" title="scalaz.std.map.type" class="keyword">extends</a> <a href="#26065" title="scalaz.std.MapInstances">MapInstances</a> <span class="keyword">with</span> <a href="#25363" title="scalaz.std.MapFunctions">MapFunctions</a>


        </pre>
    </body>
</html>