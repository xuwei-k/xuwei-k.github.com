<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/StateT.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz

<span class="keyword">import</span> <a href="Id.scala.html#8190" title="scalaz.Id.type">Id</a>._

// TODO
//dabblego: I have another, sec, but it will require Enum
//[06:57am] dabblego: can you please put a comment there while yer there?
//[06:57am] dabblego: \p -&gt; if p then succ else id -- for a start
//[06:58am] dabblego: :t \f p -&gt; evalStateT (StateT (\s -&gt; do r &lt;- f s; q &lt;- p s; return (r, if q then succ s else s))) mempty
//[06:58am] lambdabot: forall s (m :: * -&gt; *) a. (Monad m, Enum s, Monoid s) =&gt; (s -&gt; m a) -&gt; (s -&gt; m Bool) -&gt; m a
//
<span class="keyword">trait</span> <a title="trait IndexedStateT[F[+_], -S1, +S2, +A] extends AnyRef" id="20021">IndexedStateT</a><span class="delimiter">[</span><a title="[+_]" id="23699">F</a><span class="delimiter">[</span>+<a title="" id="417875">_</a><span class="delimiter">]</span>, -<a title="" id="23700">S1</a>, +<a title="" id="23701">S2</a>, +<a title="" id="23702">A</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span> self =&gt;
  /** Run and return the final value and state in the context of `F` */
  <span class="keyword">def</span> <a title="(initial: S1)F[(S2, A)]" id="70591">apply</a><span class="delimiter">(</span><a title="S1" id="71089">initial</a>: <a href="#23700" title="S1">S1</a><span class="delimiter">)</span>: <a href="#23699" title="F[(S2, A)]">F</a><span class="delimiter">[</span><span class="delimiter">(</span>S2, A<span class="delimiter">)</span><span class="delimiter">]</span>

  /** An alias for `apply` */
  <span class="keyword">def</span> <a title="(initial: S1)F[(S2, A)]" id="70592">run</a><span class="delimiter">(</span><a title="S1" id="405135">initial</a>: <a href="#23700" title="S1">S1</a><span class="delimiter">)</span>: <a href="#23699" title="F[(S2, A)]">F</a><span class="delimiter">[</span><span class="delimiter">(</span>S2, A<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#70591" title="(initial: S1)F[(S2, A)]">apply</a><span class="delimiter">(</span><a href="#405135" title="S1">initial</a><span class="delimiter">)</span>

  /** Calls `run` using `Monoid[S].zero` as the initial state */
  <span class="keyword">def</span> <a title="[S &lt;: S1](implicit S: scalaz.Monoid[S])F[(S2, A)]" id="70593">runZero</a><span class="delimiter">[</span><a title=" &lt;: S1" id="70595">S</a> &lt;: S1<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monoid[S]" id="417877">S</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[S]">Monoid</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23699" title="F[(S2, A)]">F</a><span class="delimiter">[</span><span class="delimiter">(</span>S2, A<span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#70592" title="(initial: S1)F[(S2, A)]">run</a><span class="delimiter">(</span><a href="#417877" title="scalaz.Monoid[S]">S</a>.<a href="Monoid.scala.html#51158" title="=&gt; S">zero</a><span class="delimiter">)</span>

  /** Run, discard the final state, and return the final value in the context of `F` */
  <span class="keyword">def</span> <a title="(initial: S1)(implicit F: scalaz.Functor[F])F[A]" id="70596">eval</a><span class="delimiter">(</span><a title="S1" id="255683">initial</a>: <a href="#23700" title="S1">S1</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="255684">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23699" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#255684" title="scalaz.Functor[F]">F</a>.<a href="Functor.scala.html#33415" title="(fa: F[(S2, A)])(f: ((S2, A)) =&gt; A)F[A]">map</a><span class="delimiter">(</span><a href="#70591" title="(initial: S1)F[(S2, A)]">apply</a><span class="delimiter">(</span><a href="#255683" title="S1">initial</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#417889" title="(S2, A)">_</a>.<span title="=&gt; A">_2</span><span class="delimiter">)</span>

  /** Calls `eval` using `Monoid[S].zero` as the initial state */
  <span class="keyword">def</span> <a title="[S &lt;: S1](implicit F: scalaz.Functor[F], implicit S: scalaz.Monoid[S])F[A]" id="70597">evalZero</a><span class="delimiter">[</span><a title=" &lt;: S1" id="70599">S</a> &lt;: S1<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="417903">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span>, <a title="scalaz.Monoid[S]" id="417904">S</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[S]">Monoid</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23699" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#70596" title="(initial: S1)(implicit F: scalaz.Functor[F])F[A]">eval</a><a href="#417903" title="scalaz.Functor[F]" class="delimiter">(</a><a href="#417904" title="scalaz.Monoid[S]">S</a>.<a href="Monoid.scala.html#51158" title="=&gt; S">zero</a><span class="delimiter">)</span>

  /** Run, discard the final value, and return the final state in the context of `F` */
  <span class="keyword">def</span> <a title="(initial: S1)(implicit F: scalaz.Functor[F])F[S2]" id="70600">exec</a><span class="delimiter">(</span><a title="S1" id="417912">initial</a>: <a href="#23700" title="S1">S1</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="417913">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23699" title="F[S2]">F</a><span class="delimiter">[</span>S2<span class="delimiter">]</span> =
    <a href="#417913" title="scalaz.Functor[F]">F</a>.<a href="Functor.scala.html#33415" title="(fa: F[(S2, A)])(f: ((S2, A)) =&gt; S2)F[S2]">map</a><span class="delimiter">(</span><a href="#70591" title="(initial: S1)F[(S2, A)]">apply</a><span class="delimiter">(</span><a href="#417912" title="S1">initial</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#417924" title="(S2, A)">_</a>.<span title="=&gt; S2">_1</span><span class="delimiter">)</span>

  /** Calls `exec` using `Monoid[S].zero` as the initial state */
  <span class="keyword">def</span> <a title="[S &lt;: S1](implicit F: scalaz.Functor[F], implicit S: scalaz.Monoid[S])F[S2]" id="70601">execZero</a><span class="delimiter">[</span><a title=" &lt;: S1" id="70603">S</a> &lt;: S1<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="417938">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span>, <a title="scalaz.Monoid[S]" id="417939">S</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[S]">Monoid</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23699" title="F[S2]">F</a><span class="delimiter">[</span>S2<span class="delimiter">]</span> =
    <a href="#70600" title="(initial: S1)(implicit F: scalaz.Functor[F])F[S2]">exec</a><a href="#417938" title="scalaz.Functor[F]" class="delimiter">(</a><a href="#417939" title="scalaz.Monoid[S]">S</a>.<a href="Monoid.scala.html#51158" title="=&gt; S">zero</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[B](f: A =&gt; B)(implicit F: scalaz.Functor[F])scalaz.IndexedStateT[F,S1,S2,B]" id="70604">map</a><span class="delimiter">[</span><a title="" id="70606">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="417947">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="417948">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[F,S1,S2,B]">IndexedStateT</a><span class="delimiter">[</span>F, S1, S2, B<span class="delimiter">]</span> = <a href="#280312" title="(f: S1 =&gt; F[(S2, B)])scalaz.IndexedStateT[F,S1,S2,B]">IndexedStateT</a><span class="delimiter">(</span><a title="S1" id="417959">s</a> =&gt; <a href="#417948" title="scalaz.Functor[F]">F</a>.<a href="Functor.scala.html#33415" title="(fa: F[(S2, A)])(f: ((S2, A)) =&gt; (S2, B))F[(S2, B)]">map</a><span class="delimiter">(</span><a href="#70591" title="(initial: S1)F[(S2, A)]">apply</a><span class="delimiter">(</span><a href="#417959" title="S1">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#417970" title="(S2, A)" class="delimiter">{</a>
    <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1680321" title="S2" id="417973">s1</a>, <a href="#1680321" title="A" id="417974">a</a><span class="delimiter">)</span> =&gt; <a href="#1680323" title="(x: (S2, B))(S2, B)" class="delimiter">(</a><a href="#417973" title="S2">s1</a>, <a href="#417947" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#417974" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[X1, X2](f: S2 =&gt; X1)(g: X2 =&gt; S1)(implicit F: scalaz.Functor[F])scalaz.IndexedStateT[F,X2,X1,A]" id="70607">xmap</a><span class="delimiter">[</span><a title="" id="70610">X1</a>, <a title="" id="70611">X2</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S2 =&gt; X1" id="417987">f</a>: S2 =&gt; X1<span class="delimiter">)</span><span class="delimiter">(</span><a title="X2 =&gt; S1" id="417988">g</a>: X2 =&gt; S1<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="417989">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[F,X2,X1,A]">IndexedStateT</a><span class="delimiter">[</span>F, X2, X1, A<span class="delimiter">]</span> = <a href="#280312" title="(f: X2 =&gt; F[(X1, A)])scalaz.IndexedStateT[F,X2,X1,A]">IndexedStateT</a><span class="delimiter">(</span><a title="X2" id="418001">s</a> =&gt; <a href="#417989" title="scalaz.Functor[F]">F</a>.<a href="Functor.scala.html#33415" title="(fa: F[(S2, A)])(f: ((S2, A)) =&gt; (X1, A))F[(X1, A)]">map</a><span class="delimiter">(</span><a href="#70591" title="(initial: S1)F[(S2, A)]">apply</a><span class="delimiter">(</span><a href="#417988" title="(v1: X2)S1">g</a><span class="delimiter">(</span><a href="#418001" title="X2">s</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#418013" title="(S2, A)" class="delimiter">{</a>
    <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1680327" title="S2" id="418016">s1</a>, <a href="#1680327" title="A" id="418017">a</a><span class="delimiter">)</span> =&gt; <a href="#1680329" title="(x: (X1, A))(X1, A)" class="delimiter">(</a><a href="#417987" title="(v1: S2)X1">f</a><span class="delimiter">(</span><a href="#418016" title="S2">s1</a><span class="delimiter">)</span>, <a href="#418017" title="A">a</a><span class="delimiter">)</span>
  <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="keyword">import</span> <a href="BijectionT.scala.html#19314" title="scalaz.BijectionT.type">BijectionT</a>._
  <span class="keyword">def</span> <a title="[X, S &gt;: S2 &lt;: S1](b: scalaz.BijectionT.Bijection[S,X])(implicit F: scalaz.Functor[F])scalaz.StateT[F,X,A]" id="70613">bmap</a><span class="delimiter">[</span><a title="" id="70616">X</a>, <a title=" &gt;: S2 &lt;: S1" id="70617">S</a> &gt;: S2 &lt;: S1<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.BijectionT.Bijection[S,X]" id="418030">b</a>: <a href="BijectionT.scala.html#19313" title="scalaz.BijectionT.Bijection[S,X]">Bijection</a><span class="delimiter">[</span>S, X<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="418031">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.StateT[F,X,A]">StateT</a><span class="delimiter">[</span>F, X, A<span class="delimiter">]</span> =
    <a href="#70607" title="(f: S2 =&gt; scalaz.Id.Id[X])(g: X =&gt; S1)(implicit F: scalaz.Functor[F])scalaz.IndexedStateT[F,X,scalaz.Id.Id[X],A]">xmap</a><span class="delimiter">(</span><a href="#418030" title="scalaz.BijectionT.Bijection[S,X]">b</a> <a href="BijectionT.scala.html#125417" title="(a: S)scalaz.Id.Id[X]">to</a> <a href="#418039" title="S2">_</a><span class="delimiter">)</span><a href="#418031" title="scalaz.Functor[F]" class="delimiter">(</a><a href="#418030" title="scalaz.BijectionT.Bijection[S,X]">b</a> <a href="BijectionT.scala.html#125418" title="(b: X)scalaz.Id.Id[S]">from</a> <a href="#418044" title="X">_</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[X](g: X =&gt; S1)scalaz.IndexedStateT[F,X,S2,A]" id="70618">contramap</a><span class="delimiter">[</span><a title="" id="70620">X</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="X =&gt; S1" id="418056">g</a>: X =&gt; S1<span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[F,X,S2,A]">IndexedStateT</a><span class="delimiter">[</span>F, X, S2, A<span class="delimiter">]</span> =
    <a href="#280312" title="(f: X =&gt; F[(S2, A)])scalaz.IndexedStateT[F,X,S2,A]">IndexedStateT</a><span class="delimiter">(</span><a title="X" id="418067">s</a> =&gt; <a href="#70591" title="(initial: S1)F[(S2, A)]">apply</a><span class="delimiter">(</span><a href="#418056" title="(v1: X)S1">g</a><span class="delimiter">(</span><a href="#418067" title="X">s</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[X](f: S2 =&gt; X)(implicit F: scalaz.Functor[F])scalaz.IndexedStateT[F,S1,X,A]" id="70621">imap</a><span class="delimiter">[</span><a title="" id="70623">X</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S2 =&gt; X" id="418072">f</a>: S2 =&gt; X<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="418073">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[F,S1,X,A]">IndexedStateT</a><span class="delimiter">[</span>F, S1, X, A<span class="delimiter">]</span> = <a href="#280312" title="(f: S1 =&gt; F[(X, A)])scalaz.IndexedStateT[F,S1,X,A]">IndexedStateT</a><span class="delimiter">(</span><a title="S1" id="418084">s</a> =&gt; <a href="#418073" title="scalaz.Functor[F]">F</a>.<a href="Functor.scala.html#33415" title="(fa: F[(S2, A)])(f: ((S2, A)) =&gt; (X, A))F[(X, A)]">map</a><span class="delimiter">(</span><a href="#70591" title="(initial: S1)F[(S2, A)]">apply</a><span class="delimiter">(</span><a href="#418084" title="S1">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#418095" title="(S2, A)" class="delimiter">{</a>
    <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1680333" title="S2" id="418098">s1</a>, <a href="#1680333" title="A" id="418099">a</a><span class="delimiter">)</span> =&gt; <a href="#1680335" title="(x: (X, A))(X, A)" class="delimiter">(</a><a href="#418072" title="(v1: S2)X">f</a><span class="delimiter">(</span><a href="#418098" title="S2">s1</a><span class="delimiter">)</span>, <a href="#418099" title="A">a</a><span class="delimiter">)</span>
  <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[X, B](f: S2 =&gt; X)(g: A =&gt; B)(implicit F: scalaz.Functor[F])scalaz.IndexedStateT[F,S1,X,B]" id="70624">bimap</a><span class="delimiter">[</span><a title="" id="70627">X</a>, <a title="" id="70628">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S2 =&gt; X" id="418112">f</a>: S2 =&gt; X<span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="418113">g</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="418114">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[F,S1,X,B]">IndexedStateT</a><span class="delimiter">[</span>F, S1, X, B<span class="delimiter">]</span> = <a href="#280312" title="(f: S1 =&gt; F[(X, B)])scalaz.IndexedStateT[F,S1,X,B]">IndexedStateT</a><span class="delimiter">(</span><a title="S1" id="418126">s</a> =&gt; <a href="#418114" title="scalaz.Functor[F]">F</a>.<a href="Functor.scala.html#33415" title="(fa: F[(S2, A)])(f: ((S2, A)) =&gt; (X, B))F[(X, B)]">map</a><span class="delimiter">(</span><a href="#70591" title="(initial: S1)F[(S2, A)]">apply</a><span class="delimiter">(</span><a href="#418126" title="S1">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#418137" title="(S2, A)" class="delimiter">{</a>
    <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1680339" title="S2" id="418140">s1</a>, <a href="#1680339" title="A" id="418141">a</a><span class="delimiter">)</span> =&gt; <a href="#1680341" title="(x: (X, B))(X, B)" class="delimiter">(</a><a href="#418112" title="(v1: S2)X">f</a><span class="delimiter">(</span><a href="#418140" title="S2">s1</a><span class="delimiter">)</span>, <a href="#418113" title="(v1: A)B">g</a><span class="delimiter">(</span><a href="#418141" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[X](f: S2 =&gt; X)(implicit F: scalaz.Functor[F])scalaz.IndexedStateT[F,S1,X,A]" id="70629">leftMap</a><span class="delimiter">[</span><a title="" id="70631">X</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S2 =&gt; X" id="418155">f</a>: S2 =&gt; X<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="418156">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[F,S1,X,A]">IndexedStateT</a><span class="delimiter">[</span>F, S1, X, A<span class="delimiter">]</span> =
    <a href="#70621" title="(f: S2 =&gt; X)(implicit F: scalaz.Functor[F])scalaz.IndexedStateT[F,S1,X,A]">imap</a><a href="#418156" title="scalaz.Functor[F]" class="delimiter">(</a><a href="#418155" title="S2 =&gt; X">f</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[S3, B](f: A =&gt; scalaz.IndexedStateT[F,S2,S3,B])(implicit F: scalaz.Bind[F])scalaz.IndexedStateT[F,S1,S3,B]" id="70632">flatMap</a><span class="delimiter">[</span><a title="" id="70635">S3</a>, <a title="" id="70636">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scalaz.IndexedStateT[F,S2,S3,B]" id="255674">f</a>: A =&gt; IndexedStateT<span class="delimiter">[</span>F, S2, S3, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bind[F]" id="255675">F</a>: <a href="Bind.scala.html#11813" title="scalaz.Bind[F]">Bind</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[F,S1,S3,B]">IndexedStateT</a><span class="delimiter">[</span>F, S1, S3, B<span class="delimiter">]</span> = <a href="#280312" title="(f: S1 =&gt; F[(S3, B)])scalaz.IndexedStateT[F,S1,S3,B]">IndexedStateT</a><span class="delimiter">(</span><a title="S1" id="418178">s</a> =&gt; <a href="#255675" title="scalaz.Bind[F]">F</a>.<a href="Bind.scala.html#34574" title="(fa: F[(S2, A)])(f: ((S2, A)) =&gt; F[(S3, B)])F[(S3, B)]">bind</a><span class="delimiter">(</span><a href="#70591" title="(initial: S1)F[(S2, A)]">apply</a><span class="delimiter">(</span><a href="#418178" title="S1">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#418190" title="(S2, A)" class="delimiter">{</a>
    <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1680345" title="S2" id="418193">s1</a>, <a href="#1680345" title="A" id="418194">a</a><span class="delimiter">)</span> =&gt; <a href="#255674" title="(v1: A)scalaz.IndexedStateT[F,S2,S3,B]">f</a><a href="#70591" title="(initial: S2)F[(S3, B)]" class="delimiter">(</a><a href="#418194" title="A">a</a><span class="delimiter">)</span><a href="#1680347" title="(x: F[(S3, B)])F[(S3, B)]" class="delimiter">(</a><a href="#418193" title="S2">s1</a><span class="delimiter">)</span>
  <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[M[+_]](implicit evidence$1: scalaz.Applicative[M])scalaz.IndexedStateT[[+α]M[F[α]],S1,S2,A]" id="142416">lift</a><span class="delimiter">[</span><a title="[+_]" id="70639">M</a><span class="delimiter">[</span>+<a title="" id="142420">_</a><span class="delimiter">]</span>: Applicative<span class="delimiter">]</span>: <a href="#20021" title="scalaz.IndexedStateT[[+α]M[F[α]],S1,S2,A]">IndexedStateT</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>+α<span class="delimiter">]</span>=M<span class="delimiter">[</span>F<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ, S1, S2, A<span class="delimiter">]</span> = <a href="#418204" title="scalaz.IndexedStateT[[+α]M[F[α]],S1,S2,A]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.IndexedStateT[[+α]M[F[α]],S1,S2,A]" id="418204">IndexedStateT</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>+α<span class="delimiter">]</span>=M<span class="delimiter">[</span>F<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ, S1, S2, A<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(initial: S1)M[F[(S2, A)]]" id="418211">apply</a><span class="delimiter">(</span><a title="S1" id="418213">initial</a>: <a href="#23700" title="S1">S1</a><span class="delimiter">)</span>: <a href="#70639" title="M[F[(S2, A)]]">M</a><span class="delimiter">[</span>F<span class="delimiter">[</span><span class="delimiter">(</span>S2, A<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="Applicative.scala.html#51082" title="[F[_]](implicit F: scalaz.Applicative[F])scalaz.Applicative[F]">Applicative</a><a href="#142416" title="(implicit F: scalaz.Applicative[M])scalaz.Applicative[M]" class="delimiter">[</a><a href="#70639" title="M">M</a><span class="delimiter">]</span>.<a href="Applicative.scala.html#34510" title="(a: =&gt; F[(S2, A)])M[F[(S2, A)]]">point</a><span class="delimiter">(</span><a href="#70591" title="(initial: S1)F[(S2, A)]">self</a><span class="delimiter">(</span><a href="#418213" title="S1">initial</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">import</span> <a href="Liskov.scala.html#15738" title="scalaz.Liskov.type">Liskov</a>._
  <span class="keyword">def</span> <a title="[M[+_], FF[+_], AA &gt;: A, S1m &lt;: S1, S2m &gt;: S2](implicit M: scalaz.Comonad[M], implicit ev: scalaz.Liskov.&lt;~&lt;[IndexedStateT.this.type,scalaz.IndexedStateT[[+α]M[FF[α]],S1m,S2m,AA]])scalaz.IndexedStateT[FF,S1m,S2m,AA]" id="70641">unlift</a><span class="delimiter">[</span><a title="[+_]" id="70647">M</a><span class="delimiter">[</span>+<a title="" id="418234">_</a><span class="delimiter">]</span>, <a title="[+_]" id="70648">FF</a><span class="delimiter">[</span>+<a title="" id="418233">_</a><span class="delimiter">]</span>, <a title=" &gt;: A" id="70649">AA</a> &gt;: A, <a title=" &lt;: S1" id="70650">S1m</a> &lt;: S1, <a title=" &gt;: S2" id="70651">S2m</a> &gt;: S2<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Comonad[M]" id="418231">M</a>: <a href="Comonad.scala.html#20012" title="scalaz.Comonad[M]">Comonad</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="scalaz.Liskov.&lt;~&lt;[IndexedStateT.this.type,scalaz.IndexedStateT[[+α]M[FF[α]],S1m,S2m,AA]]" id="418232">ev</a>: <span class="keyword">this</span>.<span class="keyword">type</span> <a href="Liskov.scala.html#15737" title="scalaz.Liskov.&lt;~&lt;[IndexedStateT.this.type,scalaz.IndexedStateT[[+α]M[FF[α]],S1m,S2m,AA]]">&lt;~&lt;</a> IndexedStateT<span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>+α<span class="delimiter">]</span> = M<span class="delimiter">[</span>FF<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ, S1m, S2m, AA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[FF,S1m,S2m,AA]">IndexedStateT</a><span class="delimiter">[</span>FF, S1m, S2m, AA<span class="delimiter">]</span> = <a href="#418244" title="scalaz.IndexedStateT[FF,S1m,S2m,AA]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.IndexedStateT[FF,S1m,S2m,AA]" id="418244">IndexedStateT</a><span class="delimiter">[</span>FF, S1m, S2m, AA<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(initial: S1m)FF[(S2m, AA)]" id="418246">apply</a><span class="delimiter">(</span><a title="S1m" id="418248">initial</a>: <a href="#70650" title="S1m">S1m</a><span class="delimiter">)</span>: <a href="#70648" title="FF[(S2m, AA)]">FF</a><span class="delimiter">[</span><span class="delimiter">(</span>S2m, AA<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="Comonad.scala.html#145940" title="[F[_]](implicit F: scalaz.Comonad[F])scalaz.Comonad[F]">Comonad</a><a href="#418231" title="(implicit F: scalaz.Comonad[M])scalaz.Comonad[M]" class="delimiter">[</a><a href="#70647" title="M">M</a><span class="delimiter">]</span>.<a href="Comonad.scala.html#34607" title="(p: M[FF[(S2m, AA)]])FF[(S2m, AA)]">copoint</a><span class="delimiter">(</span><a href="Liskov.scala.html#58128" title="(a: IndexedStateT.this.type)scalaz.IndexedStateT[[+α]M[FF[α]],S1m,S2m,AA]">ev</a><a href="#70591" title="(initial: S1m)M[FF[(S2m, AA)]]" class="delimiter">(</a><a href="#20021" title="IndexedStateT.this.type">self</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#418248" title="S1m">initial</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[M[+_], AA &gt;: A, S1m &lt;: S1, S2m &gt;: S2](implicit M: scalaz.Comonad[M], implicit ev: scalaz.Liskov.&lt;~&lt;[IndexedStateT.this.type,scalaz.IndexedStateT[M,S1m,S2m,AA]])scalaz.IndexedState[S1m,S2m,AA]" id="70652">unliftId</a><span class="delimiter">[</span><a title="[+_]" id="70657">M</a><span class="delimiter">[</span>+<a title="" id="418267">_</a><span class="delimiter">]</span>, <a title=" &gt;: A" id="70658">AA</a> &gt;: A, <a title=" &lt;: S1" id="70659">S1m</a> &lt;: S1, <a title=" &gt;: S2" id="70660">S2m</a> &gt;: S2<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Comonad[M]" id="418265">M</a>: <a href="Comonad.scala.html#20012" title="scalaz.Comonad[M]">Comonad</a><span class="delimiter">[</span>M<span class="delimiter">]</span>, <a title="scalaz.Liskov.&lt;~&lt;[IndexedStateT.this.type,scalaz.IndexedStateT[M,S1m,S2m,AA]]" id="418266">ev</a>: <span class="keyword">this</span>.<span class="keyword">type</span> <a href="Liskov.scala.html#15737" title="scalaz.Liskov.&lt;~&lt;[IndexedStateT.this.type,scalaz.IndexedStateT[M,S1m,S2m,AA]]">&lt;~&lt;</a> IndexedStateT<span class="delimiter">[</span>M, S1m, S2m, AA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedState[S1m,S2m,AA]">IndexedState</a><span class="delimiter">[</span>S1m, S2m, AA<span class="delimiter">]</span> = <a href="#70641" title="[M[+_], FF[+_], AA &gt;: A, S1m &lt;: S1, S2m &gt;: S2](implicit M: scalaz.Comonad[M], implicit ev: scalaz.Liskov.&lt;~&lt;[IndexedStateT.this.type,scalaz.IndexedStateT[[+α]M[FF[α]],S1m,S2m,AA]])scalaz.IndexedStateT[FF,S1m,S2m,AA]">unlift</a><a href="#418265" title="(implicit M: scalaz.Comonad[M], implicit ev: scalaz.Liskov.&lt;~&lt;[IndexedStateT.this.type,scalaz.IndexedStateT[[+α]M[scalaz.Id.Id[α]],S1m,S2m,AA]])scalaz.IndexedStateT[scalaz.Id.Id,S1m,S2m,AA]" class="delimiter">[</a><a href="#70657" title="M">M</a>, <a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#70658" title="AA">AA</a>, <a href="#70659" title="S1m">S1m</a>, <a href="#70660" title="S2m">S2m</a><span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="[W, R](implicit F: scalaz.Functor[F], implicit W: scalaz.Monoid[W])scalaz.IndexedReaderWriterStateT[F,R,W,S1,S2,A]" id="70661">rwst</a><span class="delimiter">[</span><a title="" id="70664">W</a>, <a title="" id="70665">R</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="418300">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span>, <a title="scalaz.Monoid[W]" id="418301">W</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[W]">Monoid</a><span class="delimiter">[</span>W<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="ReaderWriterStateT.scala.html#20750" title="scalaz.IndexedReaderWriterStateT[F,R,W,S1,S2,A]">IndexedReaderWriterStateT</a><span class="delimiter">[</span>F, R, W, S1, S2, A<span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#411818" title="(f: (R, S1) =&gt; F[(W, A, S2)])scalaz.IndexedReaderWriterStateT[F,R,W,S1,S2,A]">IndexedReaderWriterStateT</a><span class="delimiter">(</span>
    <span class="delimiter">(</span><a title="R" id="418315">r</a>, <a title="S1" id="418316">s</a><span class="delimiter">)</span> =&gt; <a href="#418300" title="scalaz.Functor[F]">F</a>.<a href="Functor.scala.html#33415" title="(fa: F[(S2, A)])(f: ((S2, A)) =&gt; (W, A, S2))F[(W, A, S2)]">map</a><span class="delimiter">(</span><a href="#70591" title="(initial: S1)F[(S2, A)]">self</a><span class="delimiter">(</span><a href="#418316" title="S1">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#418327" title="(S2, A)" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1680351" title="S2" id="418330">s</a>, <a href="#1680351" title="A" id="418331">a</a><span class="delimiter">)</span> =&gt; <a href="#1680353" title="(x: (W, A, S2))(W, A, S2)" class="delimiter">(</a><a href="#418301" title="scalaz.Monoid[W]">W</a>.<a href="Monoid.scala.html#51158" title="=&gt; W">zero</a>, <a href="#418331" title="A">a</a>, <a href="#418330" title="S2">s</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[S0, S3](l: scalaz.LensFamily[S0,S3,S1,S2])(implicit F: scalaz.Functor[F])scalaz.IndexedStateT[F,S0,S3,A]" id="70666">zoom</a><span class="delimiter">[</span><a title="" id="70669">S0</a>, <a title="" id="70670">S3</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.LensFamily[S0,S3,S1,S2]" id="418346">l</a>: <a href="Lens.scala.html#11120" title="scalaz.LensFamily[S0,S3,S1,S2]">LensFamily</a><span class="delimiter">[</span>S0, S3, S1, S2<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="418347">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[F,S0,S3,A]">IndexedStateT</a><span class="delimiter">[</span>F, S0, S3, A<span class="delimiter">]</span> = <a href="#418349" title="scalaz.IndexedStateT[F,S0,S3,A]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.IndexedStateT[F,S0,S3,A]" id="418349">IndexedStateT</a><span class="delimiter">[</span>F, S0, S3, A<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(s0: S0)F[(S3, A)]" id="418351">apply</a><span class="delimiter">(</span><a title="S0" id="418353">s0</a>: <a href="#70669" title="S0">S0</a><span class="delimiter">)</span> = <a href="#418347" title="scalaz.Functor[F]">F</a>.<a href="Functor.scala.html#33415" title="(fa: F[(S2, A)])(f: ((S2, A)) =&gt; (S3, A))F[(S3, A)]">map</a><span class="delimiter">(</span><a href="#70591" title="(initial: S1)F[(S2, A)]">self</a><span class="delimiter">(</span><a href="#418346" title="scalaz.LensFamily[S0,S3,S1,S2]">l</a> <a href="Lens.scala.html#125660" title="(a: S0)S1">get</a> <a href="#418353" title="S0">s0</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#418368" title="(S2, A)" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1680357" title="S2" id="418371">s2</a>, <a href="#1680357" title="A" id="418372">a</a><span class="delimiter">)</span> =&gt; <a href="#1680359" title="(x: (S3, A))(S3, A)" class="delimiter">(</a><a href="#418346" title="scalaz.LensFamily[S0,S3,S1,S2]">l</a>.<a href="Lens.scala.html#125661" title="(a: S0, b: S2)S3">set</a><span class="delimiter">(</span><a href="#418353" title="S0">s0</a>, <a href="#418371" title="S2">s2</a><span class="delimiter">)</span>, <a href="#418372" title="A">a</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="scalaz.IndexedStateT.type" id="20022">IndexedStateT</a> <a href="#20023" title="scalaz.IndexedStateT.type" class="keyword">extends</a> <a href="#14126" title="scalaz.StateTFunctions">StateTFunctions</a> <span class="keyword">with</span> <a href="#21362" title="scalaz.StateTInstances">StateTInstances</a> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[F[+_], S1, S2, A](f: S1 =&gt; F[(S2, A)])scalaz.IndexedStateT[F,S1,S2,A]" id="280312">apply</a><span class="delimiter">[</span><a title="[+_]" id="280317">F</a><span class="delimiter">[</span>+<a title="" id="411660">_</a><span class="delimiter">]</span>, <a title="" id="280318">S1</a>, <a title="" id="280319">S2</a>, <a title="" id="280320">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S1 =&gt; F[(S2, A)]" id="411659">f</a>: S1 =&gt; F<span class="delimiter">[</span><span class="delimiter">(</span>S2, A<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[F,S1,S2,A]">IndexedStateT</a><span class="delimiter">[</span>F, S1, S2, A<span class="delimiter">]</span> = <a href="#418387" title="scalaz.IndexedStateT[F,S1,S2,A]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.IndexedStateT[F,S1,S2,A]" id="418387">IndexedStateT</a><span class="delimiter">[</span>F, S1, S2, A<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(s: S1)F[(S2, A)]" id="418389">apply</a><span class="delimiter">(</span><a title="S1" id="418391">s</a>: <a href="#280318" title="S1">S1</a><span class="delimiter">)</span> = <a href="#411659" title="(v1: S1)F[(S2, A)]">f</a><span class="delimiter">(</span><a href="#418391" title="S1">s</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

//
// Prioritized Implicits for type class instances
//

<span class="keyword">trait</span> <a title="trait IndexedStateTInstances2 extends AnyRef" id="12821">IndexedStateTInstances2</a> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S2, A0, F[+_]]=&gt; scalaz.Contravariant[[-a]scalaz.IndexedStateT[F,a,S2,A0]]" id="142054">indexedStateTContravariant</a><span class="delimiter">[</span><a title="" id="142058">S2</a>, <a title="" id="142059">A0</a>, <a title="[+_]" id="142060">F</a><span class="delimiter">[</span>+<a title="" id="280374">_</a><span class="delimiter">]</span><span class="delimiter">]</span>: <a href="Contravariant.scala.html#17069" title="scalaz.Contravariant[[-a]scalaz.IndexedStateT[F,a,S2,A0]]">Contravariant</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>-a<span class="delimiter">]</span> = IndexedStateT<span class="delimiter">[</span>F, a, S2, A0<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> = <a href="#418401" title="scalaz.IndexedStateTContravariant[S2,A0,F]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.IndexedStateTContravariant[S2,A0,F]" id="418401">IndexedStateTContravariant</a><span class="delimiter">[</span>S2, A0, F<span class="delimiter">]</span> <span class="delimiter">{</span><span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait IndexedStateTInstances1 extends AnyRef with scalaz.IndexedStateTInstances2" id="15380">IndexedStateTInstances1</a> <span title="Unit" class="keyword">extends</span> <a href="#12821" title="scalaz.IndexedStateTInstances2">IndexedStateTInstances2</a> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S1, A0, F[+_]](implicit F0: scalaz.Functor[F])scalaz.Functor[[+a]scalaz.IndexedStateT[F,S1,a,A0]]" id="142062">indexedStateTFunctorLeft</a><span class="delimiter">[</span><a title="" id="142066">S1</a>, <a title="" id="142067">A0</a>, <a title="[+_]" id="142068">F</a><span class="delimiter">[</span>+<a title="" id="280366">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="280362">F0</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Functor.scala.html#14144" title="scalaz.Functor[[+a]scalaz.IndexedStateT[F,S1,a,A0]]">Functor</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+a<span class="delimiter">]</span> = IndexedStateT<span class="delimiter">[</span>F, S1, a, A0<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> = <a href="#418426" title="scalaz.IndexedStateTFunctorLeft[S1,A0,F]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.IndexedStateTFunctorLeft[S1,A0,F]" id="418426">IndexedStateTFunctorLeft</a><span class="delimiter">[</span>S1, A0, F<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Functor[F]" id="418441">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span> = <a href="#280362" title="scalaz.Functor[F]">F0</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait IndexedStateTInstances0 extends AnyRef with scalaz.IndexedStateTInstances1" id="21311">IndexedStateTInstances0</a> <span title="Unit" class="keyword">extends</span> <a href="#15380" title="scalaz.IndexedStateTInstances1">IndexedStateTInstances1</a> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S1, F[+_]](implicit F0: scalaz.Functor[F])scalaz.Bifunctor[[+a, +b]scalaz.IndexedStateT[F,S1,a,b]]" id="142070">indexedStateTBifunctor</a><span class="delimiter">[</span><a title="" id="142073">S1</a>, <a title="[+_]" id="142074">F</a><span class="delimiter">[</span>+<a title="" id="280357">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="280352">F0</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Bifunctor.scala.html#18509" title="scalaz.Bifunctor[[+a, +b]scalaz.IndexedStateT[F,S1,a,b]]">Bifunctor</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+a, +b<span class="delimiter">]</span> = IndexedStateT<span class="delimiter">[</span>F, S1, a, b<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> = <a href="#418457" title="scalaz.IndexedStateTBifunctor[S1,F]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.IndexedStateTBifunctor[S1,F]" id="418457">IndexedStateTBifunctor</a><span class="delimiter">[</span>S1, F<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Functor[F]" id="418477">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span> = <a href="#280352" title="scalaz.Functor[F]">F0</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait IndexedStateTInstances extends AnyRef with scalaz.IndexedStateTInstances0" id="15677">IndexedStateTInstances</a> <span title="Unit" class="keyword">extends</span> <a href="#21311" title="scalaz.IndexedStateTInstances0">IndexedStateTInstances0</a> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S1, S2, F[+_]](implicit F0: scalaz.Functor[F])scalaz.Functor[[+a]scalaz.IndexedStateT[F,S1,S2,a]]" id="142076">indexedStateTFunctorRight</a><span class="delimiter">[</span><a title="" id="142080">S1</a>, <a title="" id="142081">S2</a>, <a title="[+_]" id="142082">F</a><span class="delimiter">[</span>+<a title="" id="280347">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[F]" id="280343">F0</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Functor.scala.html#14144" title="scalaz.Functor[[+a]scalaz.IndexedStateT[F,S1,S2,a]]">Functor</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+a<span class="delimiter">]</span> = IndexedStateT<span class="delimiter">[</span>F, S1, S2, a<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> = <a href="#418497" title="scalaz.IndexedStateTFunctorRight[S1,S2,F]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.IndexedStateTFunctorRight[S1,S2,F]" id="418497">IndexedStateTFunctorRight</a><span class="delimiter">[</span>S1, S2, F<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Functor[F]" id="418512">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span> = <a href="#280343" title="scalaz.Functor[F]">F0</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait StateTInstances1 extends AnyRef with scalaz.IndexedStateTInstances" id="16883">StateTInstances1</a> <span title="Unit" class="keyword">extends</span> <a href="#15677" title="scalaz.IndexedStateTInstances">IndexedStateTInstances</a> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S, F[+_]](implicit F0: scalaz.Monad[F])scalaz.MonadState[[s, +a]scalaz.IndexedStateT[F,s,s,a],S]" id="142084">stateTMonadState</a><span class="delimiter">[</span><a title="" id="142087">S</a>, <a title="[+_]" id="142088">F</a><span class="delimiter">[</span>+<a title="" id="142263">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monad[F]" id="142258">F0</a>: <a href="Monad.scala.html#15566" title="scalaz.Monad[F]">Monad</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="MonadState.scala.html#19274" title="scalaz.MonadState[[s, +a]scalaz.IndexedStateT[F,s,s,a],S]">MonadState</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>s, +a<span class="delimiter">]</span> = StateT<span class="delimiter">[</span>F, s, a<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f, S<span class="delimiter">]</span> = <a href="#418528" title="scalaz.StateTMonadState[S,F]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.StateTMonadState[S,F]" id="418528">StateTMonadState</a><span class="delimiter">[</span>S, F<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Monad[F]" id="418554">F</a>: <a href="Monad.scala.html#15566" title="scalaz.Monad[F]">Monad</a><span class="delimiter">[</span>F<span class="delimiter">]</span> = <a href="#142258" title="scalaz.Monad[F]">F0</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait StateTInstances0 extends AnyRef with scalaz.StateTInstances1" id="7370">StateTInstances0</a> <span title="Unit" class="keyword">extends</span> <a href="#16883" title="scalaz.StateTInstances1">StateTInstances1</a> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S]=&gt; scalaz.Hoist[[g[+_], +a]scalaz.IndexedStateT[g,S,S,a]]" id="142090">StateMonadTrans</a><span class="delimiter">[</span><a title="" id="142092">S</a><span class="delimiter">]</span>: <a href="MonadTrans.scala.html#11657" title="scalaz.Hoist[[g[+_], +a]scalaz.IndexedStateT[g,S,S,a]]">Hoist</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>g<span class="delimiter">[</span>+_<span class="delimiter">]</span>, +a<span class="delimiter">]</span> = StateT<span class="delimiter">[</span>g, S, a<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> = <a href="#418600" title="scalaz.StateTHoist[S]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.StateTHoist[S]" id="418600">StateTHoist</a><span class="delimiter">[</span>S<span class="delimiter">]</span> <span class="delimiter">{</span><span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait StateTInstances extends AnyRef with scalaz.StateTInstances0" id="21362">StateTInstances</a> <span title="Unit" class="keyword">extends</span> <a href="#7370" title="scalaz.StateTInstances0">StateTInstances0</a> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S]=&gt; scalaz.MonadState[[s, +a]scalaz.IndexedStateT[[+X]X,s,s,a],S]" id="142094">stateMonad</a><span class="delimiter">[</span><a title="" id="142096">S</a><span class="delimiter">]</span>: <a href="MonadState.scala.html#19274" title="scalaz.MonadState[[s, +a]scalaz.IndexedStateT[[+X]X,s,s,a],S]">MonadState</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>s, +a<span class="delimiter">]</span> = State<span class="delimiter">[</span>s, a<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f, S<span class="delimiter">]</span> =
      <a href="package.scala.html#30737" title="scalaz.StateT.type">StateT</a>.<a href="#142084" title="[S, F[+_]](implicit F0: scalaz.Monad[F])scalaz.MonadState[[s, +a]scalaz.IndexedStateT[F,s,s,a],S]">stateTMonadState</a><span title="(implicit F0: scalaz.Monad[scalaz.Id.Id])scalaz.MonadState[[s, +a]scalaz.IndexedStateT[scalaz.Id.Id,s,s,a],S]" class="delimiter">[</span><a href="#142096" title="S">S</a>, <a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Id.scala.html#8190" title="scalaz.Id.type">Id</a>.<a href="Id.scala.html#33409" title="=&gt; scalaz.Traverse1[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]">id</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait IndexedStateTFunctions extends AnyRef" id="10136">IndexedStateTFunctions</a> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[F[+_], S1, S2, A](a: A)(s: =&gt; S2)(implicit F: scalaz.Applicative[F])scalaz.IndexedStateT[F,S1,S2,A]" id="142021">constantIndexedStateT</a><span class="delimiter">[</span><a title="[+_]" id="142026">F</a><span class="delimiter">[</span>+<a title="" id="418663">_</a><span class="delimiter">]</span>, <a title="" id="142027">S1</a>, <a title="" id="142028">S2</a>, <a title="" id="142029">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="418660">a</a>: <a href="#142029" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; S2" id="418661">s</a>: =&gt; S2<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[F]" id="418662">F</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[F]">Applicative</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[F,S1,S2,A]">IndexedStateT</a><span class="delimiter">[</span>F, S1, S2, A<span class="delimiter">]</span> =
    <a href="#280312" title="(f: S1 =&gt; F[(S2, A)])scalaz.IndexedStateT[F,S1,S2,A]">IndexedStateT</a><span class="delimiter">(</span><span class="delimiter">(</span>_: <a href="#142027" title="S1">S1</a><span class="delimiter">)</span> =&gt; <a href="#418662" title="scalaz.Applicative[F]">F</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; (S2, A))F[(S2, A)]">point</a><span class="delimiter">(</span><span title="(_1: S2, _2: A)(S2, A)" class="delimiter">(</span><a href="#418661" title="=&gt; S2">s</a>, <a href="#418660" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait StateTFunctions extends AnyRef with scalaz.IndexedStateTFunctions" id="14126">StateTFunctions</a> <span title="Unit" class="keyword">extends</span> <a href="#10136" title="scalaz.IndexedStateTFunctions">IndexedStateTFunctions</a> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="[F[+_], S, A](a: A)(s: =&gt; S)(implicit F: scalaz.Applicative[F])scalaz.StateT[F,S,A]" id="142031">constantStateT</a><span class="delimiter">[</span><a title="[+_]" id="142035">F</a><span class="delimiter">[</span>+<a title="" id="418694">_</a><span class="delimiter">]</span>, <a title="" id="142036">S</a>, <a title="" id="142037">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="418691">a</a>: <a href="#142037" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="=&gt; S" id="418692">s</a>: =&gt; S<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[F]" id="418693">F</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[F]">Applicative</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.StateT[F,S,A]">StateT</a><span class="delimiter">[</span>F, S, A<span class="delimiter">]</span> =
    <a href="package.scala.html#142046" title="(f: S =&gt; F[(S, A)])scalaz.StateT[F,S,A]">StateT</a><span class="delimiter">(</span><span class="delimiter">(</span>_: <a href="#142036" title="S">S</a><span class="delimiter">)</span> =&gt; <a href="#418693" title="scalaz.Applicative[F]">F</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; (S, A))F[(S, A)]">point</a><span class="delimiter">(</span><span title="(_1: S, _2: A)(S, A)" class="delimiter">(</span><a href="#418692" title="=&gt; S">s</a>, <a href="#418691" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[F[+_], S, A](a: A)(implicit F: scalaz.Applicative[F])scalaz.StateT[F,S,A]" id="142038">stateT</a><span class="delimiter">[</span><a title="[+_]" id="142042">F</a><span class="delimiter">[</span>+<a title="" id="418722">_</a><span class="delimiter">]</span>, <a title="" id="142043">S</a>, <a title="" id="142044">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="418720">a</a>: <a href="#142044" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[F]" id="418721">F</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[F]">Applicative</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.StateT[F,S,A]">StateT</a><span class="delimiter">[</span>F, S, A<span class="delimiter">]</span> =
    <a href="package.scala.html#142046" title="(f: S =&gt; F[(S, A)])scalaz.StateT[F,S,A]">StateT</a><span class="delimiter">(</span><a title="S" id="418734">s</a> =&gt; <a href="#418721" title="scalaz.Applicative[F]">F</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; (S, A))F[(S, A)]">point</a><span class="delimiter">(</span><span title="(_1: S, _2: A)(S, A)" class="delimiter">(</span><a href="#418734" title="S">s</a>, <a href="#418720" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

//
// Implementation traits for type class instances
//

<span class="keyword">private</span><span class="delimiter">[</span>scalaz<span class="delimiter">]</span> <span class="keyword">trait</span> <a title="trait IndexedStateTContravariant[S2, A0, F[+_]] extends AnyRef with scalaz.Contravariant[[-a]scalaz.IndexedStateT[F,a,S2,A0]]" id="22145">IndexedStateTContravariant</a><span class="delimiter">[</span><a title="" id="23703">S2</a>, <a title="" id="23704">A0</a>, <a title="[+_]" id="23705">F</a><span class="delimiter">[</span>+<a title="" id="418406">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="Contravariant.scala.html#17069" title="scalaz.Contravariant[[-a]scalaz.IndexedStateT[F,a,S2,A0]]">Contravariant</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>-a<span class="delimiter">]</span> = IndexedStateT<span class="delimiter">[</span>F, a, S2, A0<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](fa: scalaz.IndexedStateT[F,A,S2,A0])(f: B =&gt; A)scalaz.IndexedStateT[F,B,S2,A0]" id="418409">contramap</a><span class="delimiter">[</span><a title="" id="418412">A</a>, <a title="" id="418413">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.IndexedStateT[F,A,S2,A0]" id="418751">fa</a>: <a href="#20021" title="scalaz.IndexedStateT[F,A,S2,A0]">IndexedStateT</a><span class="delimiter">[</span>F, A, S2, A0<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; A" id="418752">f</a>: B =&gt; A<span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[F,B,S2,A0]">IndexedStateT</a><span class="delimiter">[</span>F, B, S2, A0<span class="delimiter">]</span> = <a href="#418751" title="scalaz.IndexedStateT[F,A,S2,A0]">fa</a>.<a href="#70618" title="(g: B =&gt; A)scalaz.IndexedStateT[F,B,S2,A0]">contramap</a><span class="delimiter">(</span><a href="#418752" title="B =&gt; A">f</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">private</span><span class="delimiter">[</span>scalaz<span class="delimiter">]</span> <span class="keyword">trait</span> <a title="trait IndexedStateTBifunctor[S1, F[+_]] extends AnyRef with scalaz.Bifunctor[[+a, +b]scalaz.IndexedStateT[F,S1,a,b]]" id="9773">IndexedStateTBifunctor</a><span class="delimiter">[</span><a title="" id="23706">S1</a>, <a title="[+_]" id="23707">F</a><span class="delimiter">[</span>+<a title="" id="418463">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="Bifunctor.scala.html#18509" title="scalaz.Bifunctor[[+a, +b]scalaz.IndexedStateT[F,S1,a,b]]">Bifunctor</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+a, +b<span class="delimiter">]</span> = IndexedStateT<span class="delimiter">[</span>F, S1, a, b<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Functor[F]" id="418466">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B, C, D](fab: scalaz.IndexedStateT[F,S1,A,B])(f: A =&gt; C, g: B =&gt; D)scalaz.IndexedStateT[F,S1,C,D]" id="418467">bimap</a><span class="delimiter">[</span><a title="" id="418472">A</a>, <a title="" id="418473">B</a>, <a title="" id="418474">C</a>, <a title="" id="418475">D</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.IndexedStateT[F,S1,A,B]" id="418769">fab</a>: <a href="#20021" title="scalaz.IndexedStateT[F,S1,A,B]">IndexedStateT</a><span class="delimiter">[</span>F, S1, A, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; C" id="418770">f</a>: A =&gt; C, <a title="B =&gt; D" id="418771">g</a>: B =&gt; D<span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[F,S1,C,D]">IndexedStateT</a><span class="delimiter">[</span>F, S1, C, D<span class="delimiter">]</span> = <a href="#418769" title="scalaz.IndexedStateT[F,S1,A,B]">fab</a>.<a href="#70624" title="(f: A =&gt; C)(g: B =&gt; D)(implicit F: scalaz.Functor[F])scalaz.IndexedStateT[F,S1,C,D]">bimap</a><span class="delimiter">(</span><a href="#418770" title="A =&gt; C">f</a><span class="delimiter">)</span><a href="#418466" title="=&gt; scalaz.Functor[F]" class="delimiter">(</a><a href="#418771" title="B =&gt; D">g</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">private</span><span class="delimiter">[</span>scalaz<span class="delimiter">]</span> <span class="keyword">trait</span> <a title="trait IndexedStateTFunctorLeft[S1, A0, F[+_]] extends AnyRef with scalaz.Functor[[+a]scalaz.IndexedStateT[F,S1,a,A0]]" id="21776">IndexedStateTFunctorLeft</a><span class="delimiter">[</span><a title="" id="23708">S1</a>, <a title="" id="23709">A0</a>, <a title="[+_]" id="23710">F</a><span class="delimiter">[</span>+<a title="" id="418431">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="Functor.scala.html#14144" title="scalaz.Functor[[+a]scalaz.IndexedStateT[F,S1,a,A0]]">Functor</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+a<span class="delimiter">]</span> = IndexedStateT<span class="delimiter">[</span>F, S1, a, A0<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Functor[F]" id="418434">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](fa: scalaz.IndexedStateT[F,S1,A,A0])(f: A =&gt; B)scalaz.IndexedStateT[F,S1,B,A0]" id="418435">map</a><span class="delimiter">[</span><a title="" id="418438">A</a>, <a title="" id="418439">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.IndexedStateT[F,S1,A,A0]" id="418804">fa</a>: <a href="#20021" title="scalaz.IndexedStateT[F,S1,A,A0]">IndexedStateT</a><span class="delimiter">[</span>F, S1, A, A0<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="418805">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[F,S1,B,A0]">IndexedStateT</a><span class="delimiter">[</span>F, S1, B, A0<span class="delimiter">]</span> = <a href="#418804" title="scalaz.IndexedStateT[F,S1,A,A0]">fa</a>.<a href="#70621" title="(f: A =&gt; B)(implicit F: scalaz.Functor[F])scalaz.IndexedStateT[F,S1,B,A0]">imap</a><a href="#418434" title="=&gt; scalaz.Functor[F]" class="delimiter">(</a><a href="#418805" title="A =&gt; B">f</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">private</span><span class="delimiter">[</span>scalaz<span class="delimiter">]</span> <span class="keyword">trait</span> <a title="trait IndexedStateTFunctorRight[S1, S2, F[+_]] extends AnyRef with scalaz.Functor[[+a]scalaz.IndexedStateT[F,S1,S2,a]]" id="16277">IndexedStateTFunctorRight</a><span class="delimiter">[</span><a title="" id="23711">S1</a>, <a title="" id="23712">S2</a>, <a title="[+_]" id="23713">F</a><span class="delimiter">[</span>+<a title="" id="418502">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="Functor.scala.html#14144" title="scalaz.Functor[[+a]scalaz.IndexedStateT[F,S1,S2,a]]">Functor</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+a<span class="delimiter">]</span> = IndexedStateT<span class="delimiter">[</span>F, S1, S2, a<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Functor[F]" id="418505">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](fa: scalaz.IndexedStateT[F,S1,S2,A])(f: A =&gt; B)scalaz.IndexedStateT[F,S1,S2,B]" id="418506">map</a><span class="delimiter">[</span><a title="" id="418509">A</a>, <a title="" id="418510">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.IndexedStateT[F,S1,S2,A]" id="418828">fa</a>: <a href="#20021" title="scalaz.IndexedStateT[F,S1,S2,A]">IndexedStateT</a><span class="delimiter">[</span>F, S1, S2, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="418829">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#20021" title="scalaz.IndexedStateT[F,S1,S2,B]">IndexedStateT</a><span class="delimiter">[</span>F, S1, S2, B<span class="delimiter">]</span> = <a href="#418828" title="scalaz.IndexedStateT[F,S1,S2,A]">fa</a>.<a href="#70604" title="(f: A =&gt; B)(implicit F: scalaz.Functor[F])scalaz.IndexedStateT[F,S1,S2,B]">map</a><a href="#418505" title="=&gt; scalaz.Functor[F]" class="delimiter">(</a><a href="#418829" title="A =&gt; B">f</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">private</span><span class="delimiter">[</span>scalaz<span class="delimiter">]</span> <span class="keyword">trait</span> <a title="trait StateTMonadState[S, F[+_]] extends AnyRef with scalaz.MonadState[[s, +a]scalaz.IndexedStateT[F,s,s,a],S]" id="18350">StateTMonadState</a><span class="delimiter">[</span><a title="" id="23714">S</a>, <a title="[+_]" id="23715">F</a><span class="delimiter">[</span>+<a title="" id="418534">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="MonadState.scala.html#19274" title="scalaz.MonadState[[s, +a]scalaz.IndexedStateT[F,s,s,a],S]">MonadState</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>s, +a<span class="delimiter">]</span> = StateT<span class="delimiter">[</span>F, s, a<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f, S<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Monad[F]" id="418537">F</a>: <a href="Monad.scala.html#15566" title="scalaz.Monad[F]">Monad</a><span class="delimiter">[</span>F<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="[A, B](fa: scalaz.StateT[F,S,A])(f: A =&gt; scalaz.StateT[F,S,B])scalaz.StateT[F,S,B]" id="418538">bind</a><span class="delimiter">[</span><a title="" id="418541">A</a>, <a title="" id="418542">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.StateT[F,S,A]" id="418852">fa</a>: <a href="#20021" title="scalaz.StateT[F,S,A]">StateT</a><span class="delimiter">[</span>F, S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.StateT[F,S,B]" id="418853">f</a>: A =&gt; StateT<span class="delimiter">[</span>F, S, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.StateT[F,S,B]">StateT</a><span class="delimiter">[</span>F, S, B<span class="delimiter">]</span> = <a href="#418852" title="scalaz.StateT[F,S,A]">fa</a>.<a href="#70632" title="(f: A =&gt; scalaz.IndexedStateT[F,S,S,B])(implicit F: scalaz.Bind[F])scalaz.IndexedStateT[F,S,S,B]">flatMap</a><a href="#418537" title="=&gt; scalaz.Monad[F]" class="delimiter">(</a><a href="#418853" title="A =&gt; scalaz.StateT[F,S,B]">f</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.StateT[F,S,A]" id="418543">point</a><span class="delimiter">[</span><a title="" id="418545">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="418870">a</a>: =&gt; A<span class="delimiter">)</span>: <a href="#20021" title="scalaz.StateT[F,S,A]">StateT</a><span class="delimiter">[</span>F, S, A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="A" id="418875">aa</a> = <a href="#418870" title="=&gt; A">a</a>
    <a href="package.scala.html#142046" title="(f: S =&gt; F[(S, A)])scalaz.StateT[F,S,A]">StateT</a><span class="delimiter">(</span><a title="S" id="418885">s</a> =&gt; <a href="#418537" title="=&gt; scalaz.Monad[F]">F</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; (S, A))F[(S, A)]">point</a><span title="(_1: S, _2: A)(S, A)" class="delimiter">(</span><a href="#418885" title="S">s</a>, <a href="#418875" title="=&gt; A">aa</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="=&gt; scalaz.StateT[F,S,S]" id="418546">init</a>: <a href="#20021" title="scalaz.StateT[F,S,S]">StateT</a><span class="delimiter">[</span>F, S, S<span class="delimiter">]</span> = <a href="package.scala.html#142046" title="(f: S =&gt; F[(S, S)])scalaz.StateT[F,S,S]">StateT</a><span class="delimiter">(</span><a title="S" id="418908">s</a> =&gt; <a href="#418537" title="=&gt; scalaz.Monad[F]">F</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; (S, S))F[(S, S)]">point</a><span class="delimiter">(</span><span title="(_1: S, _2: S)(S, S)" class="delimiter">(</span><a href="#418908" title="S">s</a>, <a href="#418908" title="S">s</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="=&gt; scalaz.StateT[F,S,S]" id="418547">get</a> = <a href="#418546" title="=&gt; scalaz.StateT[F,S,S]">init</a>

  <span class="keyword">def</span> <a title="(s: S)scalaz.StateT[F,S,Unit]" id="418548">put</a><span class="delimiter">(</span><a title="S" id="418924">s</a>: <a href="#23714" title="S">S</a><span class="delimiter">)</span>: <a href="#20021" title="scalaz.StateT[F,S,Unit]">StateT</a><span class="delimiter">[</span>F, S, Unit<span class="delimiter">]</span> = <a href="package.scala.html#142046" title="(f: S =&gt; F[(S, Unit)])scalaz.StateT[F,S,Unit]">StateT</a><span class="delimiter">(</span><a title="S" id="418935">_</a> =&gt; <a href="#418537" title="=&gt; scalaz.Monad[F]">F</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; (S, Unit))F[(S, Unit)]">point</a><span class="delimiter">(</span><span title="(_1: S, _2: Unit)(S, Unit)" class="delimiter">(</span><a href="#418924" title="S">s</a>, <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="(f: S =&gt; S)scalaz.StateT[F,S,Unit]" id="418549">modify</a><span class="delimiter">(</span><a title="S =&gt; S" id="418948">f</a>: S =&gt; S<span class="delimiter">)</span>: <a href="#20021" title="scalaz.StateT[F,S,Unit]">StateT</a><span class="delimiter">[</span>F, S, Unit<span class="delimiter">]</span> = <a href="package.scala.html#142046" title="(f: S =&gt; F[(S, Unit)])scalaz.StateT[F,S,Unit]">StateT</a><span class="delimiter">(</span><a title="S" id="418959">s</a> =&gt; <a href="#418537" title="=&gt; scalaz.Monad[F]">F</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; (S, Unit))F[(S, Unit)]">point</a><span class="delimiter">(</span><span title="(_1: S, _2: Unit)(S, Unit)" class="delimiter">(</span><a href="#418948" title="(v1: S)S">f</a><span class="delimiter">(</span><a href="#418959" title="S">s</a><span class="delimiter">)</span>, <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A](f: S =&gt; A)scalaz.StateT[F,S,A]" id="418550">gets</a><span class="delimiter">[</span><a title="" id="418552">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; A" id="418973">f</a>: S =&gt; A<span class="delimiter">)</span>: <a href="#20021" title="scalaz.StateT[F,S,A]">StateT</a><span class="delimiter">[</span>F, S, A<span class="delimiter">]</span> = <a href="package.scala.html#142046" title="(f: S =&gt; F[(S, A)])scalaz.StateT[F,S,A]">StateT</a><span class="delimiter">(</span><a title="S" id="418987">s</a> =&gt; <a href="#418537" title="=&gt; scalaz.Monad[F]">F</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; (S, A))F[(S, A)]">point</a><span class="delimiter">(</span><span title="(_1: S, _2: A)(S, A)" class="delimiter">(</span><a href="#418987" title="S">s</a>, <a href="#418973" title="(v1: S)A">f</a><span class="delimiter">(</span><a href="#418987" title="S">s</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">private</span><span class="delimiter">[</span>scalaz<span class="delimiter">]</span> <span class="keyword">trait</span> <a title="trait StateTHoist[S] extends AnyRef with scalaz.Hoist[[g[+_], +a]scalaz.IndexedStateT[g,S,S,a]]" id="19580">StateTHoist</a><span class="delimiter">[</span><a title="" id="23716">S</a><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="MonadTrans.scala.html#11657" title="scalaz.Hoist[[g[+_], +a]scalaz.IndexedStateT[g,S,S,a]]">Hoist</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>g<span class="delimiter">[</span>+_<span class="delimiter">]</span>, +a<span class="delimiter">]</span> = StateT<span class="delimiter">[</span>g, S, a<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>

  <span class="keyword">type</span> <a title="StateTHoist[G[+_], S] extends AnyRef" id="418609">StateTF</a><span class="delimiter">[</span><a title="[+_]" id="418610">G</a><span class="delimiter">[</span>+<a title="" id="419008">_</a><span class="delimiter">]</span>, <a title="" id="418611">S</a><span class="delimiter">]</span> = <a href="#419005" title="StateTHoist extends AnyRef" class="delimiter">{</a>
    <span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = StateT<span class="delimiter">[</span>G, S, x<span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[G[+_], A](ga: G[A])(implicit G: scalaz.Monad[G])scalaz.StateT[G,S,A]" id="418612">liftM</a><span class="delimiter">[</span><a title="[+_]" id="418615">G</a><span class="delimiter">[</span>+<a title="" id="419011">_</a><span class="delimiter">]</span>, <a title="" id="418616">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="G[A]" id="419009">ga</a>: <a href="#418615" title="G[A]">G</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monad[G]" id="419010">G</a>: <a href="Monad.scala.html#15566" title="scalaz.Monad[G]">Monad</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#20021" title="scalaz.StateT[G,S,A]">StateT</a><span class="delimiter">[</span>G, S, A<span class="delimiter">]</span> =
    <a href="package.scala.html#142046" title="(f: S =&gt; G[(S, A)])scalaz.StateT[G,S,A]">StateT</a><span class="delimiter">(</span><a title="S" id="419027">s</a> =&gt; <a href="#419010" title="scalaz.Monad[G]">G</a>.<a href="Monad.scala.html#34563" title="(fa: G[A])(f: A =&gt; (S, A))G[(S, A)]">map</a><span class="delimiter">(</span><a href="#419009" title="G[A]">ga</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="419044">a</a> =&gt; <span title="(_1: S, _2: A)(S, A)" class="delimiter">(</span><a href="#419027" title="S">s</a>, <a href="#419044" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[M[+_], N[+_]](f: scalaz.~&gt;[M,N])(implicit evidence$2: scalaz.Monad[M])scalaz.~&gt;[[+x]scalaz.IndexedStateT[M,S,S,x],[+x]scalaz.IndexedStateT[N,S,S,x]]" id="419057">hoist</a><span class="delimiter">[</span><a title="[+_]" id="418620">M</a><span class="delimiter">[</span>+<a title="" id="419059">_</a><span class="delimiter">]</span>: Monad, <a title="[+_]" id="418621">N</a><span class="delimiter">[</span>+<a title="" id="419060">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.~&gt;[M,N]" id="419056">f</a>: M <a href="NaturalTransformation.scala.html#19940" title="scalaz.~&gt;[M,N]">~&gt;</a> N<span class="delimiter">)</span> = <a href="#419074" title="scalaz.~&gt;[[+x]scalaz.IndexedStateT[M,S,S,x],[+x]scalaz.IndexedStateT[N,S,S,x]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.~&gt;[[+x]scalaz.IndexedStateT[M,S,S,x],[+x]scalaz.IndexedStateT[N,S,S,x]]" id="419074" class="delimiter">(</a>StateTF<span class="delimiter">[</span>M, S<span class="delimiter">]</span>#f <a href="NaturalTransformation.scala.html#19940" title="scalaz.~&gt;[[+x]scalaz.IndexedStateT[M,S,S,x],[+x]scalaz.IndexedStateT[N,S,S,x]]">~&gt;</a> StateTF<span class="delimiter">[</span>N, S<span class="delimiter">]</span>#f<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A](action: scalaz.StateT[M,S,A])scalaz.StateT[N,S,A]" id="419100">apply</a><span class="delimiter">[</span><a title="" id="419102">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.StateT[M,S,A]" id="419104">action</a>: <a href="#20021" title="scalaz.StateT[M,S,A]">StateT</a><span class="delimiter">[</span>M, S, A<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="package.scala.html#142046" title="[F[+_], S, A](f: S =&gt; F[(S, A)])scalaz.StateT[F,S,A]">StateT</a><span title="(f: S =&gt; N[(S, A)])scalaz.StateT[N,S,A]" class="delimiter">[</span><a href="#418621" title="N">N</a>, <a href="#23716" title="S">S</a>, <a href="#419102" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S" id="419116">s</a> =&gt; <a href="NaturalTransformation.scala.html#144451" title="(fa: M[(S, A)])N[(S, A)]">f</a><span class="delimiter">(</span><a href="#70591" title="(initial: S)M[(S, A)]">action</a><span class="delimiter">(</span><a href="#419116" title="S">s</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[G[+_]](implicit evidence$3: scalaz.Monad[G])scalaz.Monad[[+α]scalaz.IndexedStateT[G,S,S,α]]" id="419175">apply</a><span class="delimiter">[</span><a title="[+_]" id="418624">G</a><span class="delimiter">[</span>+<a title="" id="419179">_</a><span class="delimiter">]</span> : Monad<span class="delimiter">]</span>: <a href="Monad.scala.html#15566" title="scalaz.Monad[[+α]scalaz.IndexedStateT[G,S,S,α]]">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>+α<span class="delimiter">]</span> = StateT<span class="delimiter">[</span>G, S, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="package.scala.html#30737" title="scalaz.StateT.type">StateT</a>.<a href="#142084" title="[S, F[+_]](implicit F0: scalaz.Monad[F])scalaz.MonadState[[s, +a]scalaz.IndexedStateT[F,s,s,a],S]">stateTMonadState</a><a href="#419175" title="(implicit F0: scalaz.Monad[G])scalaz.MonadState[[s, +a]scalaz.IndexedStateT[G,s,s,a],S]" class="delimiter">[</a><a href="#23716" title="S">S</a>, <a href="#418624" title="G">G</a><span class="delimiter">]</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>