<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/Bifoldable.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz

////
/**
 * A type giving rise to two unrelated [[scalaz.Foldable]]s.
 */
////
<span class="keyword">trait</span> <a title="trait Bifoldable[F[_, _]] extends AnyRef" id="8966">Bifoldable</a><span class="delimiter">[</span><a title="[_, _]" id="22854">F</a><span class="delimiter">[</span><a title="" id="122943">_</a>, <a title="" id="122944">_</a><span class="delimiter">]</span><span class="delimiter">]</span>  <span title="Unit" class="delimiter">{</span> self =&gt;
  ////

  /** Accumulate `A`s and `B`s in some unspecified order. */
  <span class="keyword">def</span> <a title="[A, B, M](fa: F[A,B])(f: A =&gt; M)(g: B =&gt; M)(implicit F: scalaz.Monoid[M])M" id="72650">bifoldMap</a><span class="delimiter">[</span><a title="" id="72654">A</a>,<a title="" id="72655">B</a>,<a title="" id="72656">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="122969">fa</a>: <a href="#22854" title="F[A,B]">F</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; M" id="122970">f</a>: A =&gt; M<span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; M" id="122971">g</a>: B =&gt; M<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monoid[M]" id="122972">F</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[M]">Monoid</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#72656" title="M">M</a>

  /** Accumulate to `C` starting at the &quot;right&quot;.  `f` and `g` may be
    * interleaved.
    */
  <span class="keyword">def</span> <a title="[A, B, C](fa: F[A,B], z: =&gt; C)(f: (A, =&gt; C) =&gt; C)(g: (B, =&gt; C) =&gt; C)C" id="72657">bifoldRight</a><span class="delimiter">[</span><a title="" id="72661">A</a>,<a title="" id="72662">B</a>,<a title="" id="72663">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="122977">fa</a>: <a href="#22854" title="F[A,B]">F</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>, <a title="=&gt; C" id="122978">z</a>: =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, =&gt; C) =&gt; C" id="122979">f</a>: <span class="delimiter">(</span>A, =&gt; C<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, =&gt; C) =&gt; C" id="122980">g</a>: <span class="delimiter">(</span>B, =&gt; C<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#72663" title="C">C</a>

  // derived functions

  /** `bifoldRight`, but defined to run in the opposite direction. */
  <span class="keyword">def</span> <a title="[A, B, C](fa: F[A,B], z: C)(f: (C, A) =&gt; C)(g: (C, B) =&gt; C)C" id="72664">bifoldLeft</a><span class="delimiter">[</span><a title="" id="72668">A</a>,<a title="" id="72669">B</a>,<a title="" id="72670">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="122985">fa</a>: <a href="#22854" title="F[A,B]">F</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>, <a title="C" id="122986">z</a>: <a href="#72670" title="C">C</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(C, A) =&gt; C" id="122987">f</a>: <span class="delimiter">(</span>C, A<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><a title="(C, B) =&gt; C" id="122988">g</a>: <span class="delimiter">(</span>C, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#72670" title="C">C</a> = <span class="delimiter">{</span>
    <span class="keyword">import</span> <a href="Dual.scala.html#12198" title="scalaz.Dual.type">Dual</a>._, <a href="Endo.scala.html#10845" title="scalaz.Endo.type">Endo</a>._, syntax.std.<a href="syntax/std/package.scala.html#31039" title="scalaz.syntax.std.all.type">all</a>._
    <a href="#72650" title="(fa: F[A,B])(f: A =&gt; scalaz.@@[scalaz.Endo[C],scalaz.Tags.Dual])(g: B =&gt; scalaz.@@[scalaz.Endo[C],scalaz.Tags.Dual])(implicit F: scalaz.Monoid[scalaz.@@[scalaz.Endo[C],scalaz.Tags.Dual]])scalaz.@@[scalaz.Endo[C],scalaz.Tags.Dual]">bifoldMap</a><span class="delimiter">(</span><a href="#122985" title="F[A,B]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span>a: <a href="#72668" title="A">A</a><span class="delimiter">)</span> =&gt; <a href="Dual.scala.html#123004" title="(a: scalaz.Endo[C])scalaz.@@[scalaz.Endo[C],scalaz.Tags.Dual]">Dual</a><span class="delimiter">(</span><a href="Endo.scala.html#10845" title="scalaz.Endo.type">Endo</a>.<a href="Endo.scala.html#51344" title="(f: C =&gt; C)scalaz.Endo[C]">endo</a><span class="delimiter">(</span><a href="syntax/std/Function2Ops.scala.html#46941" title="(f: (C, A) =&gt; C)scalaz.syntax.std.Function2Ops[C,A,C]{val self: (C, A) =&gt; C}">f</a>.<a href="syntax/std/Function2Ops.scala.html#104220" title="=&gt; (A, C) =&gt; C">flip</a>.<span title="(v1: A)C =&gt; C">curried</span><span class="delimiter">(</span><a href="#123027" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span>b: <a href="#72669" title="B">B</a><span class="delimiter">)</span> =&gt; <a href="Dual.scala.html#123004" title="(a: scalaz.Endo[C])scalaz.@@[scalaz.Endo[C],scalaz.Tags.Dual]">Dual</a><span class="delimiter">(</span><a href="Endo.scala.html#10845" title="scalaz.Endo.type">Endo</a>.<a href="Endo.scala.html#51344" title="(f: C =&gt; C)scalaz.Endo[C]">endo</a><span class="delimiter">(</span><a href="syntax/std/Function2Ops.scala.html#46941" title="(f: (C, B) =&gt; C)scalaz.syntax.std.Function2Ops[C,B,C]{val self: (C, B) =&gt; C}">g</a>.<a href="syntax/std/Function2Ops.scala.html#104220" title="=&gt; (B, C) =&gt; C">flip</a>.<span title="(v1: B)C =&gt; C">curried</span><span class="delimiter">(</span><a href="#124057" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="Dual.scala.html#122997" title="[F](implicit F0: scalaz.Monoid[F])scalaz.DualMonoid[F]">dualMonoid</a><a href="Endo.scala.html#51363" title="(implicit F0: scalaz.Monoid[scalaz.Endo[C]])scalaz.DualMonoid[scalaz.Endo[C]]" class="delimiter">[</a><a href="Endo.scala.html#10844" title="scalaz.Endo[C]">Endo</a><span class="delimiter">[</span>C<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <a href="Endo.scala.html#51379" title="(a: C)C">apply</a> <a href="#122986" title="C">z</a>
  <span class="delimiter">}</span>

  /**The composition of Bifoldables `F` and `G`, `[x,y]F[G[x,y],G[x,y]]`, is a Bifoldable */
  <span class="keyword">def</span> <a title="[G[_, _]](implicit G0: scalaz.Bifoldable[G])scalaz.Bifoldable[[α, β]F[G[α,β],G[α,β]]]" id="72671">compose</a><span class="delimiter">[</span><a title="[_, _]" id="72673">G</a><span class="delimiter">[</span><a title="" id="124137">_</a>, <a title="" id="124138">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bifoldable[G]" id="124132">G0</a>: <a href="#8966" title="scalaz.Bifoldable[G]">Bifoldable</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#8966" title="scalaz.Bifoldable[[α, β]F[G[α,β],G[α,β]]]">Bifoldable</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α, β<span class="delimiter">]</span>=F<span class="delimiter">[</span>G<span class="delimiter">[</span>α, β<span class="delimiter">]</span>, G<span class="delimiter">[</span>α, β<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#124144" title="scalaz.CompositionBifoldable[F,G]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.CompositionBifoldable[F,G]" id="124144">CompositionBifoldable</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Bifoldable[F]" id="124176">F</a> = <a href="#8966" title="scalaz.Bifoldable[F]">self</a>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Bifoldable[G]" id="124177">G</a> = <a href="#124132" title="scalaz.Bifoldable[G]">G0</a>
  <span class="delimiter">}</span>

  /**The product of Bifoldables `F` and `G`, `[x,y]F[G[x,y],G[x,y]]`, is a Bifoldable */
  <span class="keyword">def</span> <a title="[G[_, _]](implicit G0: scalaz.Bifoldable[G])scalaz.Bifoldable[[α, β](F[α,β], G[α,β])]" id="72674">product</a><span class="delimiter">[</span><a title="[_, _]" id="72676">G</a><span class="delimiter">[</span><a title="" id="124204">_</a>, <a title="" id="124205">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bifoldable[G]" id="124199">G0</a>: <a href="#8966" title="scalaz.Bifoldable[G]">Bifoldable</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#8966" title="scalaz.Bifoldable[[α, β](F[α,β], G[α,β])]">Bifoldable</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α, β<span class="delimiter">]</span>=<span class="delimiter">(</span>F<span class="delimiter">[</span>α, β<span class="delimiter">]</span>, G<span class="delimiter">[</span>α, β<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#124211" title="scalaz.ProductBifoldable[F,G]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.ProductBifoldable[F,G]" id="124211">ProductBifoldable</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Bifoldable[F]" id="124243">F</a> = <a href="#8966" title="scalaz.Bifoldable[F]">self</a>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Bifoldable[G]" id="124244">G</a> = <a href="#124199" title="scalaz.Bifoldable[G]">G0</a>
  <span class="delimiter">}</span>

  // derived functions
  <span class="keyword">def</span> <a title="[A, B, M](fa: F[A,B])(f: A =&gt; M)(g: B =&gt; M)(implicit F: scalaz.Semigroup[M])Option[M]" id="72677">bifoldMap1</a><span class="delimiter">[</span><a title="" id="72681">A</a>,<a title="" id="72682">B</a>,<a title="" id="72683">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="124266">fa</a>: <a href="#22854" title="F[A,B]">F</a><span class="delimiter">[</span>A,B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; M" id="124267">f</a>: A =&gt; M<span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; M" id="124268">g</a>: B =&gt; M<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Semigroup[M]" id="124269">F</a>: <a href="Semigroup.scala.html#7832" title="scalaz.Semigroup[M]">Semigroup</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[M]">Option</span><span class="delimiter">[</span>M<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">import</span> std.<a href="std/Option.scala.html#24065" title="scalaz.std.option.type">option</a>._
    <a href="#72650" title="(fa: F[A,B])(f: A =&gt; Option[M])(g: B =&gt; Option[M])(implicit F: scalaz.Monoid[Option[M]])Option[M]">bifoldMap</a><span class="delimiter">(</span><a href="#124266" title="F[A,B]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="124294">a</a> =&gt; <a href="std/Option.scala.html#46802" title="(a: M)Option[M]">some</a><span class="delimiter">(</span><a href="#124267" title="(v1: A)M">f</a><span class="delimiter">(</span><a href="#124294" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><a href="std/Option.scala.html#45786" title="(implicit evidence$1: scalaz.Semigroup[M])scalaz.Monoid[Option[M]]" class="delimiter">(</a><a title="B" id="124310">b</a> =&gt; <a href="std/Option.scala.html#46802" title="(a: M)Option[M]">some</a><span class="delimiter">(</span><a href="#124268" title="(v1: B)M">g</a><span class="delimiter">(</span><a href="#124310" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /**Curried version of `foldRight` */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[A, B, C](fa: F[A,B], z: =&gt; C)(f: A =&gt; ((=&gt; C) =&gt; C))(g: B =&gt; ((=&gt; C) =&gt; C))C" id="72684">bifoldR</a><span class="delimiter">[</span><a title="" id="72688">A</a>, <a title="" id="72689">B</a>, <a title="" id="72690">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="124338">fa</a>: <a href="#22854" title="F[A,B]">F</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>, <a title="=&gt; C" id="124339">z</a>: =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; ((=&gt; C) =&gt; C)" id="124340">f</a>: A =&gt; <span class="delimiter">(</span>=&gt; C<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; ((=&gt; C) =&gt; C)" id="124341">g</a>: B =&gt; <span class="delimiter">(</span>=&gt; C<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#72690" title="C">C</a> =
    <a href="#72657" title="(fa: F[A,B], z: =&gt; C)(f: (A, =&gt; C) =&gt; C)(g: (B, =&gt; C) =&gt; C)C">bifoldRight</a><span class="delimiter">(</span><a href="#124338" title="F[A,B]">fa</a>, <a href="#124339" title="=&gt; C">z</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="Function.type">Function</span>.<span title="(f: A =&gt; ((=&gt; C) =&gt; C))(A, =&gt; C) =&gt; C">uncurried</span><span class="delimiter">(</span><a href="#124340" title="A =&gt; ((=&gt; C) =&gt; C)">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="Function.type">Function</span>.<span title="(f: B =&gt; ((=&gt; C) =&gt; C))(B, =&gt; C) =&gt; C">uncurried</span><span class="delimiter">(</span><a href="#124341" title="B =&gt; ((=&gt; C) =&gt; C)">g</a><span class="delimiter">)</span><span class="delimiter">)</span>

  /**Curred version of `foldLeft` */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[A, B, C](fa: F[A,B], z: C)(f: C =&gt; (A =&gt; C))(g: C =&gt; (B =&gt; C))C" id="72691">bifoldL</a><span class="delimiter">[</span><a title="" id="72695">A</a>, <a title="" id="72696">B</a>, <a title="" id="72697">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="124510">fa</a>: <a href="#22854" title="F[A,B]">F</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>, <a title="C" id="124511">z</a>: <a href="#72697" title="C">C</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="C =&gt; (A =&gt; C)" id="124512">f</a>: C =&gt; A =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><a title="C =&gt; (B =&gt; C)" id="124513">g</a>: C =&gt; B =&gt; C<span class="delimiter">)</span>: <a href="#72697" title="C">C</a> =
    <a href="#72664" title="(fa: F[A,B], z: C)(f: (C, A) =&gt; C)(g: (C, B) =&gt; C)C">bifoldLeft</a><span class="delimiter">(</span><a href="#124510" title="F[A,B]">fa</a>, <a href="#124511" title="C">z</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="Function.type">Function</span>.<span title="(f: C =&gt; (A =&gt; C))(C, A) =&gt; C">uncurried</span><span class="delimiter">(</span><a href="#124512" title="C =&gt; (A =&gt; C)">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="Function.type">Function</span>.<span title="(f: C =&gt; (B =&gt; C))(C, B) =&gt; C">uncurried</span><span class="delimiter">(</span><a href="#124513" title="C =&gt; (B =&gt; C)">g</a><span class="delimiter">)</span><span class="delimiter">)</span>

  /** Extract the Foldable on the first parameter. */
  <span class="keyword">def</span> <a title="[X]=&gt; scalaz.Foldable[[α]F[α,X]]" id="72698">leftFoldable</a><span class="delimiter">[</span><a title="" id="72700">X</a><span class="delimiter">]</span>: <a href="Foldable.scala.html#17390" title="scalaz.Foldable[[α]F[α,X]]">Foldable</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = F<span class="delimiter">[</span>α, X<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#124598" title="scalaz.Foldable[[α]F[α,X]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Foldable[[α]F[α,X]]" id="124598">Foldable</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = F<span class="delimiter">[</span>α, X<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](fa: F[A,X])(f: A =&gt; B)(implicit F: scalaz.Monoid[B])B" id="124605">foldMap</a><span class="delimiter">[</span><a title="" id="124608">A</a>,<a title="" id="124609">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,X]" id="124616">fa</a>: <a href="#22854" title="F[A,X]">F</a><span class="delimiter">[</span>A, X<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="124617">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monoid[B]" id="124618">F</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[B]">Monoid</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#124609" title="B">B</a> =
      <a href="#72650" title="(fa: F[A,X])(f: A =&gt; B)(g: X =&gt; B)(implicit F: scalaz.Monoid[B])B">bifoldMap</a><span class="delimiter">(</span><a href="#124616" title="F[A,X]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#124617" title="A =&gt; B">f</a><span class="delimiter">)</span><a href="#124618" title="scalaz.Monoid[B]" class="delimiter">(</a><span title="Function.type">Function</span> <a href="#124697" title="(x: B)(y: X)B">const</a> <a href="#124618" title="scalaz.Monoid[B]">F</a>.<a href="Monoid.scala.html#51158" title="=&gt; B">zero</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="[A, B](fa: F[A,X], z: =&gt; B)(f: (A, =&gt; B) =&gt; B)B" id="124610">foldRight</a><span class="delimiter">[</span><a title="" id="124613">A</a>, <a title="" id="124614">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,X]" id="124633">fa</a>: <a href="#22854" title="F[A,X]">F</a><span class="delimiter">[</span>A, X<span class="delimiter">]</span>, <a title="=&gt; B" id="124634">z</a>: =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, =&gt; B) =&gt; B" id="124635">f</a>: <span class="delimiter">(</span>A, =&gt; B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#124614" title="B">B</a> =
      <a href="#72657" title="(fa: F[A,X], z: =&gt; B)(f: (A, =&gt; B) =&gt; B)(g: (X, =&gt; B) =&gt; B)B">bifoldRight</a><span class="delimiter">(</span><a href="#124633" title="F[A,X]">fa</a>, <a href="#124634" title="=&gt; B">z</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#124635" title="(A, =&gt; B) =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="X" id="124722">_</a>, <a title="=&gt; B" id="124723">b</a><span class="delimiter">)</span> =&gt; <a href="#124723" title="=&gt; B">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Extract the Foldable on the second parameter. */
  <span class="keyword">def</span> <a title="[X]=&gt; scalaz.Foldable[[α]F[X,α]]" id="72701">rightFoldable</a><span class="delimiter">[</span><a title="" id="72703">X</a><span class="delimiter">]</span>: <a href="Foldable.scala.html#17390" title="scalaz.Foldable[[α]F[X,α]]">Foldable</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = F<span class="delimiter">[</span>X, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#124741" title="scalaz.Foldable[[α]F[X,α]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Foldable[[α]F[X,α]]" id="124741">Foldable</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = F<span class="delimiter">[</span>X, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](fa: F[X,A])(f: A =&gt; B)(implicit F: scalaz.Monoid[B])B" id="124748">foldMap</a><span class="delimiter">[</span><a title="" id="124751">A</a>,<a title="" id="124752">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[X,A]" id="124759">fa</a>: <a href="#22854" title="F[X,A]">F</a><span class="delimiter">[</span>X, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="124760">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monoid[B]" id="124761">F</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[B]">Monoid</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#124752" title="B">B</a> =
      <a href="#72650" title="(fa: F[X,A])(f: X =&gt; B)(g: A =&gt; B)(implicit F: scalaz.Monoid[B])B">bifoldMap</a><span class="delimiter">(</span><a href="#124759" title="F[X,A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="Function.type">Function</span> <a href="#124832" title="(x: B)(y: X)B">const</a> <a href="#124761" title="scalaz.Monoid[B]">F</a>.<a href="Monoid.scala.html#51158" title="=&gt; B">zero</a><span class="delimiter">)</span><a href="#124761" title="scalaz.Monoid[B]" class="delimiter">(</a><a href="#124760" title="A =&gt; B">f</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="[A, B](fa: F[X,A], z: =&gt; B)(f: (A, =&gt; B) =&gt; B)B" id="124753">foldRight</a><span class="delimiter">[</span><a title="" id="124756">A</a>, <a title="" id="124757">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[X,A]" id="124776">fa</a>: <a href="#22854" title="F[X,A]">F</a><span class="delimiter">[</span>X, A<span class="delimiter">]</span>, <a title="=&gt; B" id="124777">z</a>: =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, =&gt; B) =&gt; B" id="124778">f</a>: <span class="delimiter">(</span>A, =&gt; B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#124757" title="B">B</a> =
      <a href="#72657" title="(fa: F[X,A], z: =&gt; B)(f: (X, =&gt; B) =&gt; B)(g: (A, =&gt; B) =&gt; B)B">bifoldRight</a><span class="delimiter">(</span><a href="#124776" title="F[X,A]">fa</a>, <a href="#124777" title="=&gt; B">z</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="X" id="124865">_</a>, <a title="=&gt; B" id="124866">b</a><span class="delimiter">)</span> =&gt; <a href="#124866" title="=&gt; B">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#124778" title="(A, =&gt; B) =&gt; B">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  ////
  <span class="keyword">val</span> <a title="bifoldableSyntax extends AnyRef with scalaz.syntax.BifoldableSyntax[F]" id="72704">bifoldableSyntax</a> = <a href="#122946" title="scalaz.syntax.BifoldableSyntax[F]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.syntax.BifoldableSyntax[F]" id="122946">scalaz</a>.syntax.<a href="syntax/BifoldableSyntax.scala.html#28288" title="scalaz.syntax.BifoldableSyntax[F]">BifoldableSyntax</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Bifoldable[F]" id="122955">F</a> = <a href="#8966" title="scalaz.Bifoldable[F]">Bifoldable</a>.<span class="keyword">this</span> <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="scalaz.Bifoldable.type" id="8967">Bifoldable</a> <a href="#8968" title="scalaz.Bifoldable.type" class="delimiter">{</a>
  @inline <span class="keyword">def</span> <a title="[F[_, _]](implicit F: scalaz.Bifoldable[F])scalaz.Bifoldable[F]" id="124878">apply</a><span class="delimiter">[</span><a title="[_, _]" id="124880">F</a><span class="delimiter">[</span><a title="" id="124887">_</a>, <a title="" id="124888">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bifoldable[F]" id="124886">F</a>: <a href="#8966" title="scalaz.Bifoldable[F]">Bifoldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#8966" title="scalaz.Bifoldable[F]">Bifoldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span> = <a href="#124886" title="scalaz.Bifoldable[F]">F</a>

  ////
  /**
   * Template trait to define `Bifoldable` in terms of `bifoldMap`.
   */
  <span class="keyword">trait</span> <a title="trait FromBifoldMap[F[_, _]] extends AnyRef with scalaz.Bifoldable[F]" id="124881">FromBifoldMap</a><span class="delimiter">[</span><a title="[_, _]" id="124882">F</a><span class="delimiter">[</span><a title="" id="124899">_</a>, <a title="" id="124900">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="#8966" title="scalaz.Bifoldable[F]">Bifoldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B, C](fa: F[A,B], z: =&gt; C)(f: (A, =&gt; C) =&gt; C)(g: (B, =&gt; C) =&gt; C)C" id="124892">bifoldRight</a><span class="delimiter">[</span><a title="" id="124896">A</a>,<a title="" id="124897">B</a>,<a title="" id="124898">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="124903">fa</a>: <a href="#124882" title="F[A,B]">F</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>, <a title="=&gt; C" id="124904">z</a>: =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, =&gt; C) =&gt; C" id="124905">f</a>: <span class="delimiter">(</span>A, =&gt; C<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, =&gt; C) =&gt; C" id="124906">g</a>: <span class="delimiter">(</span>B, =&gt; C<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span> =
      <a href="#72650" title="(fa: F[A,B])(f: A =&gt; scalaz.Endo[C])(g: B =&gt; scalaz.Endo[C])(implicit F: scalaz.Monoid[scalaz.Endo[C]])scalaz.Endo[C]">bifoldMap</a><span class="delimiter">(</span><a href="#124903" title="F[A,B]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span>a: <a href="#124896" title="A">A</a><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span><a href="Endo.scala.html#10845" title="scalaz.Endo.type">Endo</a>.<a href="Endo.scala.html#51344" title="(f: C =&gt; C)scalaz.Endo[C]">endo</a><span class="delimiter">(</span><a href="#124905" title="(v1: A, v2: =&gt; C)C">f</a><span class="delimiter">(</span><a href="#124955" title="A">a</a>, <a href="#124959" title="C">_</a>: <a href="#124898" title="C">C</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><a href="Endo.scala.html#51363" title="scalaz.Monoid[scalaz.Endo[C]]" class="delimiter">(</a><span class="delimiter">(</span>b: <a href="#124897" title="B">B</a><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span><a href="Endo.scala.html#10845" title="scalaz.Endo.type">Endo</a>.<a href="Endo.scala.html#51344" title="(f: C =&gt; C)scalaz.Endo[C]">endo</a><span class="delimiter">(</span><a href="#124906" title="(v1: B, v2: =&gt; C)C">g</a><span class="delimiter">(</span><a href="#124972" title="B">b</a>, <a href="#124976" title="C">_</a>: <a href="#124898" title="C">C</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Endo.scala.html#51379" title="(a: C)C">apply</a> <a href="#124904" title="=&gt; C">z</a>
  <span class="delimiter">}</span>

  /**
   * Template trait to define `Foldable` in terms of `foldr`
   */
  <span class="keyword">trait</span> <a title="trait FromBifoldr[F[_, _]] extends AnyRef with scalaz.Bifoldable[F]" id="124883">FromBifoldr</a><span class="delimiter">[</span><a title="[_, _]" id="124884">F</a><span class="delimiter">[</span><a title="" id="124997">_</a>, <a title="" id="124998">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="#8966" title="scalaz.Bifoldable[F]">Bifoldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B, M](fa: F[A,B])(f: A =&gt; M)(g: B =&gt; M)(implicit F: scalaz.Monoid[M])M" id="124990">bifoldMap</a><span class="delimiter">[</span><a title="" id="124994">A</a>, <a title="" id="124995">B</a>, <a title="" id="124996">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A,B]" id="125001">fa</a>: <a href="#124884" title="F[A,B]">F</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; M" id="125002">f</a>: A =&gt; M<span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; M" id="125003">g</a>: B =&gt; M<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monoid[M]" id="125004">F</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[M]">Monoid</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#72684" title="(fa: F[A,B], z: =&gt; M)(f: A =&gt; ((=&gt; M) =&gt; M))(g: B =&gt; ((=&gt; M) =&gt; M))M">bifoldR</a><span class="delimiter">(</span><a href="#125001" title="F[A,B]">fa</a>, <a href="#125004" title="scalaz.Monoid[M]">F</a>.<a href="Monoid.scala.html#51158" title="=&gt; M">zero</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="125050">x</a> =&gt; <a title="=&gt; M" id="125052">y</a> =&gt; <a href="#125004" title="scalaz.Monoid[M]">F</a>.<a href="Semigroup.scala.html#51147" title="(f1: M, f2: =&gt; M)M">append</a><span class="delimiter">(</span><a href="#125002" title="(v1: A)M">f</a><span class="delimiter">(</span><a href="#125050" title="A">x</a><span class="delimiter">)</span>,  <a href="#125052" title="=&gt; M">y</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="B" id="125057">x</a> =&gt; <a title="=&gt; M" id="125059">y</a> =&gt; <a href="#125004" title="scalaz.Monoid[M]">F</a>.<a href="Semigroup.scala.html#51147" title="(f1: M, f2: =&gt; M)M">append</a><span class="delimiter">(</span><a href="#125003" title="(v1: B)M">g</a><span class="delimiter">(</span><a href="#125057" title="B">x</a><span class="delimiter">)</span>,  <a href="#125059" title="=&gt; M">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  ////
<span class="delimiter">}</span>

        </pre>
    </body>
</html>