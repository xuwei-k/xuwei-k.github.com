<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/package.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
/**
 * '''Scalaz''': Type classes and pure functional data structures for Scala.
 *
 * This package, [[scalaz]], contains:
 *  - type class definitions
 *  - data structures
 *  - related functions
 *
 * Type class instances and other functions related to the Scala and Java standard library
 * are in scalaz.[[scalaz.std]]
 *
 * Implicit conversions and wrapper classes that provide a more convenient syntax for accessing
 * the functionality of the library are in scalaz.[[scalaz.syntax]].
 *
 * '''Type Classes Index'''
 *
 *  - [[scalaz.Semigroup]]
 *  - [[scalaz.Monoid]] extends [[scalaz.Semigroup]]
 *  - [[scalaz.Equal]]
 *  - [[scalaz.Length]]
 *  - [[scalaz.Show]]
 *  - [[scalaz.Order]] extends [[scalaz.Equal]]
 *  - [[scalaz.Enum]] extends [[scalaz.Order]]
 *
 *  - [[scalaz.MetricSpace]]
 *  - [[scalaz.Plus]]
 *  - [[scalaz.PlusEmpty]] extends [[scalaz.Plus]]
 *  - [[scalaz.IsEmpty]] extends [[scalaz.PlusEmpty]]
 *  - [[scalaz.Each]]
 *  - [[scalaz.Index]]
 *  - [[scalaz.Functor]]
 *  - [[scalaz.Contravariant]]
 *  - [[scalaz.Apply]] extends [[scalaz.Functor]]
 *  - [[scalaz.Applicative]] extends [[scalaz.Apply]]
 *  - [[scalaz.Zip]]
 *  - [[scalaz.Unzip]]
 *  - [[scalaz.Cozip]]
 *  - [[scalaz.Bind]] extends [[scalaz.Apply]]
 *  - [[scalaz.Monad]] extends [[scalaz.Applicative]] with [[scalaz.Bind]]
 *  - [[scalaz.Cojoin]] extends [[scalaz.Functor]]
 *  - [[scalaz.Cobind]] extends [[scalaz.Functor]]
 *  - [[scalaz.Comonad]] extends [[scalaz.Cojoin]] with [[scalaz.Cobind]]
 *  - [[scalaz.ApplicativePlus]] extends [[scalaz.Applicative]] with [[scalaz.PlusEmpty]]
 *  - [[scalaz.MonadPlus]] extends [[scalaz.Monad]] with [[scalaz.ApplicativePlus]]
 *  - [[scalaz.Foldable]]
 *  - [[scalaz.Traverse]] extends [[scalaz.Functor]] with [[scalaz.Foldable]]
 *
 *  - [[scalaz.Bifunctor]]
 *  - [[scalaz.Bifoldable]]
 *  - [[scalaz.Bitraverse]] extends [[scalaz.Bifunctor]] with [[scalaz.Bifoldable]]
 *  - [[scalaz.Compose]]
 *  - [[scalaz.Profunctor]]
 *  - [[scalaz.Category]] extends [[scalaz.Compose]]
 *  - [[scalaz.Choice]] extends [[scalaz.Category]]
 *  - [[scalaz.Split]] extends [[scalaz.Category]]
 *  - [[scalaz.Arrow]] extends [[scalaz.Split]] with [[scalaz.Profunctor]]
 *
 *  '''Data Structures Index'''
 *  - [[scalaz.Validation]] Represent computations that may succeed or fail, accumulating multiple errors.
 *  - [[scalaz.NonEmptyList]] A list containing at least one element.
 *  - [[scalaz.DList]] A difference list, supporting efficient append and prepend.
 *  - [[scalaz.EphemeralStream]] A stream that holds weak references to its elements, and recomputes them if needed
 *    if reclaimed by the garbage collector.
 *  - [[scalaz.Heap]] A priority queue, implemented with bootstrapped skew binomial heaps.
 *  - [[scalaz.Endo]] Represents functions from `A =&gt; A`.
 *  - [[scalaz.FingerTree]] A tree containing elements at it's leaves, and measures at the nodes. Can be adapted to
 *    various purposes by choosing a different measure, for example [[scalaz.IndSeq]] and [[scalaz.OrdSeq]].
 *  - [[scalaz.Lens]] Composable, functional alternative to getters and setters
 *  - [[scalaz.Tree]] A multiway tree. Each node contains a single element, and a `Stream` of sub-trees.
 *  - [[scalaz.TreeLoc]] A cursor over a [[scalaz.Tree]].
 *  - [[scalaz.Zipper]] A functional cursor over a List.
 *
 *  - [[scalaz.Kleisli]] Represents a function `A =&gt; M[B]`, allowing chaining. Also known, and aliased, as `scalaz.ReaderT`.
 *  - [[scalaz.StateT]] Computations that modify state.
 *  - [[scalaz.WriterT]] Computations that log a value
 *  - [[scalaz.OptionT]] Represents computations of type `F[Option[A]]`
 *  - [[scalaz.EitherT]] Represents computations of type `F[A \/ B]`
 */
<span class="keyword">package</span> <span class="keyword">object</span> <a title="scalaz.package.type" id="20634">scalaz</a> <a href="#20635" title="scalaz.package.type" class="delimiter">{</a>
  <span class="keyword">import</span> <a href="Id.scala.html#8190" title="scalaz.Id.type">Id</a>._

  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="package extends scalaz.Traverse1[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]" id="30683">idInstance</a>: <a href="#33412" title="package extends scalaz.Traverse1[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]">Traverse1</a><span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Each<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Monad<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Comonad<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Cojoin<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Distributive<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Zip<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Unzip<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Cozip<span class="delimiter">[</span>Id<span class="delimiter">]</span> = <a href="Id.scala.html#8190" title="scalaz.Id.type">Id</a>.<a href="Id.scala.html#33409" title="=&gt; scalaz.Traverse1[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]">id</a>

  <span class="keyword">type</span> <a title="package[T] extends AnyRef" id="30685">Tagged</a><span class="delimiter">[</span><a title="" id="30686">T</a><span class="delimiter">]</span> = <a href="#51457" title="package extends AnyRef" class="delimiter">{</a><span class="keyword">type</span> Tag = T<span class="delimiter">}</span>

  /**
   * Tag a type `T` with `Tag`. The resulting type is a subtype of `T`.
   *
   * The resulting type is used to discriminate between type class instances.
   *
   * @see [[scalaz.Tag]] and [[scalaz.Tags]]
   *
   * Credit to Miles Sabin for the idea.
   */
  <span class="keyword">type</span> <a title="package[+T, Tag] extends T with scalaz.package.Tagged[Tag]" id="30687">@@</a><span class="delimiter">[</span>+<a title="" id="30688">T</a>, <a title="" id="30689">Tag</a><span class="delimiter">]</span> = <a href="#51465" title="package extends T with scalaz.package.Tagged[Tag]">T</a> <span class="keyword">with</span> Tagged<span class="delimiter">[</span>Tag<span class="delimiter">]</span>

  /** A [[scalaz.NaturalTransformation]][F, G]. */
  <span class="keyword">type</span> <a title="[-F[_], +G[_]]scalaz.NaturalTransformation[F,G]" id="30690">~&gt;</a><span class="delimiter">[</span>-<a title="[_]" id="30691">F</a><span class="delimiter">[</span><a title="" id="144447">_</a><span class="delimiter">]</span>, +<a title="[_]" id="30692">G</a><span class="delimiter">[</span><a title="" id="144448">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="NaturalTransformation.scala.html#19940" title="scalaz.NaturalTransformation[F,G]">NaturalTransformation</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span>
  /** A [[scalaz.NaturalTransformation]][G, F]. */
  <span class="keyword">type</span> <a title="[+F[_], -G[_]]scalaz.NaturalTransformation[G,F]" id="30693">&lt;~</a><span class="delimiter">[</span>+<a title="[_]" id="30694">F</a><span class="delimiter">[</span><a title="" id="448501">_</a><span class="delimiter">]</span>, -<a title="[_]" id="30695">G</a><span class="delimiter">[</span><a title="" id="448502">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="NaturalTransformation.scala.html#19940" title="scalaz.NaturalTransformation[G,F]">NaturalTransformation</a><span class="delimiter">[</span>G, F<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[-F[_, _], +G[_, _]]scalaz.BiNaturalTransformation[F,G]" id="30696">~~&gt;</a><span class="delimiter">[</span>-<a title="[_, _]" id="30697">F</a><span class="delimiter">[</span><a title="" id="370611">_</a>,<a title="" id="370612">_</a><span class="delimiter">]</span>, +<a title="[_, _]" id="30698">G</a><span class="delimiter">[</span><a title="" id="370613">_</a>,<a title="" id="370614">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="NaturalTransformation.scala.html#19130" title="scalaz.BiNaturalTransformation[F,G]">BiNaturalTransformation</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="Nothing" id="30699">‚ä•</a> = <span title="Nothing">Nothing</span>
  <span class="keyword">type</span> <a title="Any" id="30700">‚ä§</a> = <span title="Any">Any</span>

  <span class="keyword">type</span> <a title="[G[_], F[_]]scalaz.MonadPartialOrder[G,F]" id="30701">|&gt;=|</a><span class="delimiter">[</span><a title="[_]" id="30702">G</a><span class="delimiter">[</span><a title="" id="448503">_</a><span class="delimiter">]</span>, <a title="[_]" id="30703">F</a><span class="delimiter">[</span><a title="" id="448504">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="MonadTrans.scala.html#14270" title="scalaz.MonadPartialOrder[G,F]">MonadPartialOrder</a><span class="delimiter">[</span>G, F<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[F[+_], -E, +A]scalaz.Kleisli[F,E,A]" id="30704">ReaderT</a><span class="delimiter">[</span><a title="[+_]" id="30705">F</a><span class="delimiter">[</span>+<a title="" id="114038">_</a><span class="delimiter">]</span>, -<a title="" id="30706">E</a>, +<a title="" id="30707">A</a><span class="delimiter">]</span> = <a href="Kleisli.scala.html#13760" title="scalaz.Kleisli[F,E,A]">Kleisli</a><span class="delimiter">[</span>F, E, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[-E, +A]scalaz.Kleisli[Option,E,A]" id="30708">=?&gt;</a><span class="delimiter">[</span>-<a title="" id="30709">E</a>, +<a title="" id="30710">A</a><span class="delimiter">]</span> = <a href="Kleisli.scala.html#13760" title="scalaz.Kleisli[Option,E,A]">Kleisli</a><span class="delimiter">[</span>Option, E, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[-E, +A]scalaz.package.ReaderT[scalaz.Id.Id,E,A]" id="30711">Reader</a><span class="delimiter">[</span>-<a title="" id="30712">E</a>, +<a title="" id="30713">A</a><span class="delimiter">]</span> = <a href="Kleisli.scala.html#13760" title="scalaz.package.ReaderT[scalaz.Id.Id,E,A]">ReaderT</a><span class="delimiter">[</span>Id, E, A<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[+W, +A]scalaz.WriterT[scalaz.Id.Id,W,A]" id="30714">Writer</a><span class="delimiter">[</span>+<a title="" id="30715">W</a>, +<a title="" id="30716">A</a><span class="delimiter">]</span> = <a href="WriterT.scala.html#11144" title="scalaz.WriterT[scalaz.Id.Id,W,A]">WriterT</a><span class="delimiter">[</span>Id, W, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[+W, +A]scalaz.UnwriterT[scalaz.Id.Id,W,A]" id="30717">Unwriter</a><span class="delimiter">[</span>+<a title="" id="30718">W</a>, +<a title="" id="30719">A</a><span class="delimiter">]</span> = <a href="UnwriterT.scala.html#13310" title="scalaz.UnwriterT[scalaz.Id.Id,W,A]">UnwriterT</a><span class="delimiter">[</span>Id, W, A<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="scalaz.package.Reader.type" id="30720">Reader</a> <a href="#30721" title="scalaz.package.Reader.type" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[E, A](f: E =&gt; A)scalaz.package.Reader[E,A]" id="114040">apply</a><span class="delimiter">[</span><a title="" id="114043">E</a>, <a title="" id="114044">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="E =&gt; A" id="114045">f</a>: E =&gt; A<span class="delimiter">)</span>: <a href="Kleisli.scala.html#13760" title="scalaz.package.Reader[E,A]">Reader</a><span class="delimiter">[</span>E, A<span class="delimiter">]</span> = <a href="Kleisli.scala.html#44370" title="[M[+_], A, B](f: A =&gt; M[B])scalaz.Kleisli[M,A,B]">Kleisli</a><span title="(f: E =&gt; scalaz.Id.Id[A])scalaz.Kleisli[scalaz.Id.Id,E,A]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#114043" title="E">E</a>, <a href="#114044" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#114045" title="E =&gt; A">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="scalaz.package.Writer.type" id="30722">Writer</a> <a href="#30723" title="scalaz.package.Writer.type" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[W, A](w: W, a: A)scalaz.WriterT[scalaz.Id.Id,W,A]" id="114054">apply</a><span class="delimiter">[</span><a title="" id="114057">W</a>, <a title="" id="114058">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="W" id="114059">w</a>: <a href="#114057" title="W">W</a>, <a title="A" id="114060">a</a>: <a href="#114058" title="A">A</a><span class="delimiter">)</span>: <a href="WriterT.scala.html#11144" title="scalaz.WriterT[scalaz.Id.Id,W,A]">WriterT</a><span class="delimiter">[</span>Id, W, A<span class="delimiter">]</span> = <a href="WriterT.scala.html#111647" title="[F[+_], W, A](v: F[(W, A)])scalaz.WriterT[F,W,A]">WriterT</a><span title="(v: (W, A))scalaz.WriterT[scalaz.Id.Id,W,A]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#114057" title="W">W</a>, <a href="#114058" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="(_1: W, _2: A)(W, A)" class="delimiter">(</span><a href="#114059" title="W">w</a>, <a href="#114060" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="scalaz.package.Unwriter.type" id="30724">Unwriter</a> <a href="#30725" title="scalaz.package.Unwriter.type" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[U, A](u: U, a: A)scalaz.UnwriterT[scalaz.Id.Id,U,A]" id="440216">apply</a><span class="delimiter">[</span><a title="" id="440219">U</a>, <a title="" id="440220">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="440221">u</a>: <a href="#440219" title="U">U</a>, <a title="A" id="440222">a</a>: <a href="#440220" title="A">A</a><span class="delimiter">)</span>: <a href="UnwriterT.scala.html#13310" title="scalaz.UnwriterT[scalaz.Id.Id,U,A]">UnwriterT</a><span class="delimiter">[</span>Id, U, A<span class="delimiter">]</span> = <a href="UnwriterT.scala.html#436895" title="[F[+_], W, A](v: F[(W, A)])scalaz.UnwriterT[F,W,A]">UnwriterT</a><span title="(v: (U, A))scalaz.UnwriterT[scalaz.Id.Id,U,A]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#440219" title="U">U</a>, <a href="#440220" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="(_1: U, _2: A)(U, A)" class="delimiter">(</span><a href="#440221" title="U">u</a>, <a href="#440222" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /**
   * StateT Monad Transformer
   *
   * [[http://www.youtube.com/watch?feature=player_detailpage&amp;v=XVmhK8WbRLY#t=585s An introduction to the State Monad]]
   */
  <span class="keyword">type</span> <a title="[F[+_], S, +A]scalaz.IndexedStateT[F,S,S,A]" id="30726">StateT</a><span class="delimiter">[</span><a title="[+_]" id="30727">F</a><span class="delimiter">[</span>+<a title="" id="70588">_</a><span class="delimiter">]</span>, <a title="" id="30728">S</a>, +<a title="" id="30729">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#20021" title="scalaz.IndexedStateT[F,S,S,A]">IndexedStateT</a><span class="delimiter">[</span>F, S, S, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[-S1, +S2, +A]scalaz.IndexedStateT[scalaz.Id.Id,S1,S2,A]" id="30730">IndexedState</a><span class="delimiter">[</span>-<a title="" id="30731">S1</a>, +<a title="" id="30732">S2</a>, +<a title="" id="30733">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#20021" title="scalaz.IndexedStateT[scalaz.Id.Id,S1,S2,A]">IndexedStateT</a><span class="delimiter">[</span>Id, S1, S2, A<span class="delimiter">]</span>
  /** A state transition, representing a function `S =&gt; (A, S)`. */
  <span class="keyword">type</span> <a title="[S, +A]scalaz.package.StateT[scalaz.Id.Id,S,A]" id="30734">State</a><span class="delimiter">[</span><a title="" id="30735">S</a>, +<a title="" id="30736">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#20021" title="scalaz.package.StateT[scalaz.Id.Id,S,A]">StateT</a><span class="delimiter">[</span>Id, S, A<span class="delimiter">]</span>

  // important to define here, rather than at the top-level, to avoid Scala 2.9.2 bug
  <span class="keyword">object</span> <a title="scalaz.package.StateT.type" id="30737">StateT</a> <a href="#30738" title="scalaz.package.StateT.type" class="keyword">extends</a> <a href="StateT.scala.html#14126" title="scalaz.StateTFunctions">StateTFunctions</a> <span class="keyword">with</span> <a href="StateT.scala.html#21362" title="scalaz.StateTInstances">StateTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[F[+_], S, A](f: S =&gt; F[(S, A)])scalaz.package.StateT[F,S,A]" id="142046">apply</a><span class="delimiter">[</span><a title="[+_]" id="142050">F</a><span class="delimiter">[</span>+<a title="" id="372722">_</a><span class="delimiter">]</span>, <a title="" id="142051">S</a>, <a title="" id="142052">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; F[(S, A)]" id="372721">f</a>: S =&gt; F<span class="delimiter">[</span><span class="delimiter">(</span>S, A<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="StateT.scala.html#20021" title="scalaz.package.StateT[F,S,A]">StateT</a><span class="delimiter">[</span>F, S, A<span class="delimiter">]</span> = <a href="#448524" title="scalaz.package.StateT[F,S,A]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.package.StateT[F,S,A]" id="448524">StateT</a><span class="delimiter">[</span>F, S, A<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(s: S)F[(S, A)]" id="448526">apply</a><span class="delimiter">(</span><a title="S" id="448528">s</a>: <a href="#142051" title="S">S</a><span class="delimiter">)</span> = <a href="#372721" title="(v1: S)F[(S, A)]">f</a><span class="delimiter">(</span><a href="#448528" title="S">s</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="scalaz.package.IndexedState.type" id="30739">IndexedState</a> <a href="#30740" title="scalaz.package.IndexedState.type" class="keyword">extends</a> <a href="State.scala.html#12497" title="scalaz.StateFunctions">StateFunctions</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[S1, S2, A](f: S1 =&gt; (S2, A))scalaz.package.IndexedState[S1,S2,A]" id="385903">apply</a><span class="delimiter">[</span><a title="" id="385907">S1</a>, <a title="" id="385908">S2</a>, <a title="" id="385909">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S1 =&gt; (S2, A)" id="385910">f</a>: S1 =&gt; <span class="delimiter">(</span>S2, A<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="StateT.scala.html#20021" title="scalaz.package.IndexedState[S1,S2,A]">IndexedState</a><span class="delimiter">[</span>S1, S2, A<span class="delimiter">]</span> = <a href="#448536" title="scalaz.package.IndexedState[S1,S2,A]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.package.IndexedState[S1,S2,A]" id="448536">IndexedState</a><span class="delimiter">[</span>S1, S2, A<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(s: S1)(S2, A)" id="448538">apply</a><span class="delimiter">(</span><a title="S1" id="448540">s</a>: <a href="#385907" title="S1">S1</a><span class="delimiter">)</span> = <a href="#385910" title="(v1: S1)(S2, A)">f</a><span class="delimiter">(</span><a href="#448540" title="S1">s</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="scalaz.package.State.type" id="30741">State</a> <a href="#30742" title="scalaz.package.State.type" class="keyword">extends</a> <a href="State.scala.html#12497" title="scalaz.StateFunctions">StateFunctions</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[S, A](f: S =&gt; (S, A))scalaz.package.State[S,A]" id="70672">apply</a><span class="delimiter">[</span><a title="" id="70675">S</a>, <a title="" id="70676">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; (S, A)" id="70677">f</a>: S =&gt; <span class="delimiter">(</span>S, A<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="StateT.scala.html#20021" title="scalaz.package.State[S,A]">State</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> = <a href="#448548" title="scalaz.package.StateT[scalaz.Id.Id,S,A]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.package.StateT[scalaz.Id.Id,S,A]" id="448548">StateT</a><span class="delimiter">[</span>Id, S, A<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(s: S)(S, A)" id="448550">apply</a><span class="delimiter">(</span><a title="S" id="448552">s</a>: <a href="#70675" title="S">S</a><span class="delimiter">)</span> = <a href="#70677" title="(v1: S)(S, A)">f</a><span class="delimiter">(</span><a href="#448552" title="S">s</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[F[+_], A, +B]scalaz.IndexedStoreT[F,A,A,B]" id="30743">StoreT</a><span class="delimiter">[</span><a title="[+_]" id="30744">F</a><span class="delimiter">[</span>+<a title="" id="386703">_</a><span class="delimiter">]</span>, <a title="" id="30745">A</a>, +<a title="" id="30746">B</a><span class="delimiter">]</span> = <a href="StoreT.scala.html#10850" title="scalaz.IndexedStoreT[F,A,A,B]">IndexedStoreT</a><span class="delimiter">[</span>F, A, A, B<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[+I, -A, +B]scalaz.IndexedStoreT[scalaz.Id.Id,I,A,B]" id="30747">IndexedStore</a><span class="delimiter">[</span>+<a title="" id="30748">I</a>, -<a title="" id="30749">A</a>, +<a title="" id="30750">B</a><span class="delimiter">]</span> = <a href="StoreT.scala.html#10850" title="scalaz.IndexedStoreT[scalaz.Id.Id,I,A,B]">IndexedStoreT</a><span class="delimiter">[</span>Id, I, A, B<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[A, +B]scalaz.package.StoreT[scalaz.Id.Id,A,B]" id="30751">Store</a><span class="delimiter">[</span><a title="" id="30752">A</a>, +<a title="" id="30753">B</a><span class="delimiter">]</span> = <a href="StoreT.scala.html#10850" title="scalaz.package.StoreT[scalaz.Id.Id,A,B]">StoreT</a><span class="delimiter">[</span>Id, A, B<span class="delimiter">]</span>
  // flipped
  <span class="keyword">type</span> <a title="[+A, B]scalaz.package.Store[B,A]" id="30754">|--&gt;</a><span class="delimiter">[</span>+<a title="" id="30755">A</a>, <a title="" id="30756">B</a><span class="delimiter">]</span> = <a href="StoreT.scala.html#10850" title="scalaz.package.Store[B,A]">Store</a><span class="delimiter">[</span>B, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="scalaz.package.StoreT.type" id="30757">StoreT</a> <a href="#30758" title="scalaz.package.StoreT.type" class="keyword">extends</a> <a href="StoreT.scala.html#13511" title="scalaz.StoreTFunctions">StoreTFunctions</a> <span class="keyword">with</span> <a href="StoreT.scala.html#18569" title="scalaz.StoreTInstances">StoreTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[F[+_], A, B](r: (F[A =&gt; B], A))scalaz.package.StoreT[F,A,B]" id="385131">apply</a><span class="delimiter">[</span><a title="[+_]" id="385135">F</a><span class="delimiter">[</span>+<a title="" id="420305">_</a><span class="delimiter">]</span>, <a title="" id="385136">A</a>, <a title="" id="385137">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(F[A =&gt; B], A)" id="420304">r</a>: <span title="(F[A =&gt; B], A)" class="delimiter">(</span>F<span class="delimiter">[</span>A =&gt; B<span class="delimiter">]</span>, A<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="StoreT.scala.html#10850" title="scalaz.package.StoreT[F,A,B]">StoreT</a><span class="delimiter">[</span>F, A, B<span class="delimiter">]</span> =
      <a href="StoreT.scala.html#385118" title="(r: (F[A =&gt; B], A))scalaz.StoreT[F,A,B]">storeT</a><span class="delimiter">(</span><a href="#420304" title="(F[A =&gt; B], A)">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="scalaz.package.IndexedStore.type" id="30759">IndexedStore</a> <a href="#30760" title="scalaz.package.IndexedStore.type" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[I, A, B](f: A =&gt; B, i: I)scalaz.package.IndexedStore[I,A,B]" id="386144">apply</a><span class="delimiter">[</span><a title="" id="386148">I</a>, <a title="" id="386149">A</a>, <a title="" id="386150">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="386151">f</a>: A =&gt; B, <a title="I" id="386152">i</a>: <a href="#386148" title="I">I</a><span class="delimiter">)</span>: <a href="StoreT.scala.html#10850" title="scalaz.package.IndexedStore[I,A,B]">IndexedStore</a><span class="delimiter">[</span>I, A, B<span class="delimiter">]</span> = <a href="StoreT.scala.html#10851" title="scalaz.IndexedStoreT.type">IndexedStoreT</a>.<a href="StoreT.scala.html#385110" title="(i: I)(f: A =&gt; B)scalaz.IndexedStore[I,A,B]">indexedStore</a><span class="delimiter">(</span><a href="#386152" title="I">i</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#386151" title="A =&gt; B">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="scalaz.package.Store.type" id="30761">Store</a> <a href="#30762" title="scalaz.package.Store.type" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[A, B](f: A =&gt; B, a: A)scalaz.package.Store[A,B]" id="126265">apply</a><span class="delimiter">[</span><a title="" id="126268">A</a>, <a title="" id="126269">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="126270">f</a>: A =&gt; B, <a title="A" id="126271">a</a>: <a href="#126268" title="A">A</a><span class="delimiter">)</span>: <a href="StoreT.scala.html#10850" title="scalaz.package.Store[A,B]">Store</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> = <a href="#30757" title="scalaz.package.StoreT.type">StoreT</a>.<a href="StoreT.scala.html#385125" title="(a: A)(f: A =&gt; B)scalaz.Store[A,B]">store</a><span class="delimiter">(</span><a href="#126271" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#126270" title="A =&gt; B">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>


  <span class="keyword">type</span> <a title="[F[+_], -R, +W, S, +A]scalaz.IndexedReaderWriterStateT[F,R,W,S,S,A]" id="30763">ReaderWriterStateT</a><span class="delimiter">[</span><a title="[+_]" id="30764">F</a><span class="delimiter">[</span>+<a title="" id="372533">_</a><span class="delimiter">]</span>, -<a title="" id="30765">R</a>, +<a title="" id="30766">W</a>, <a title="" id="30767">S</a>, +<a title="" id="30768">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#20750" title="scalaz.IndexedReaderWriterStateT[F,R,W,S,S,A]">IndexedReaderWriterStateT</a><span class="delimiter">[</span>F, R, W, S, S, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="scalaz.package.ReaderWriterStateT.type" id="30769">ReaderWriterStateT</a> <a href="#30770" title="scalaz.package.ReaderWriterStateT.type" class="keyword">extends</a> <a href="ReaderWriterStateT.scala.html#16310" title="scalaz.ReaderWriterStateTFunctions">ReaderWriterStateTFunctions</a> <span class="keyword">with</span> <a href="ReaderWriterStateT.scala.html#20903" title="scalaz.ReaderWriterStateTInstances">ReaderWriterStateTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[F[+_], R, W, S, A](f: (R, S) =&gt; F[(W, A, S)])scalaz.package.ReaderWriterStateT[F,R,W,S,A]" id="372551">apply</a><span class="delimiter">[</span><a title="[+_]" id="372557">F</a><span class="delimiter">[</span>+<a title="" id="372592">_</a><span class="delimiter">]</span>, <a title="" id="372558">R</a>, <a title="" id="372559">W</a>, <a title="" id="372560">S</a>, <a title="" id="372561">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(R, S) =&gt; F[(W, A, S)]" id="372591">f</a>: <span class="delimiter">(</span>R, S<span class="delimiter">)</span> =&gt; F<span class="delimiter">[</span><span class="delimiter">(</span>W, A, S<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="ReaderWriterStateT.scala.html#20750" title="scalaz.package.ReaderWriterStateT[F,R,W,S,A]">ReaderWriterStateT</a><span class="delimiter">[</span>F, R, W, S, A<span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#411818" title="[F[+_], R, W, S1, S2, A](f: (R, S1) =&gt; F[(W, A, S2)])scalaz.IndexedReaderWriterStateT[F,R,W,S1,S2,A]">IndexedReaderWriterStateT</a><span title="(f: (R, S) =&gt; F[(W, A, S)])scalaz.IndexedReaderWriterStateT[F,R,W,S,S,A]" class="delimiter">[</span><a href="#372557" title="F">F</a>, <a href="#372558" title="R">R</a>, <a href="#372559" title="W">W</a>, <a href="#372560" title="S">S</a>, <a href="#372560" title="S">S</a>, <a href="#372561" title="A">A</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="delimiter">(</span>r: <a href="#372558" title="R">R</a>, s: <a href="#372560" title="S">S</a><span class="delimiter">)</span> =&gt; <a href="#372591" title="(v1: R, v2: S)F[(W, A, S)]">f</a><span class="delimiter">(</span><a href="#448595" title="R">r</a>, <a href="#448596" title="S">s</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[-R, +W, -S1, +S2, +A]scalaz.IndexedReaderWriterStateT[scalaz.Id.Id,R,W,S1,S2,A]" id="30771">IndexedReaderWriterState</a><span class="delimiter">[</span>-<a title="" id="30772">R</a>, +<a title="" id="30773">W</a>, -<a title="" id="30774">S1</a>, +<a title="" id="30775">S2</a>, +<a title="" id="30776">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#20750" title="scalaz.IndexedReaderWriterStateT[scalaz.Id.Id,R,W,S1,S2,A]">IndexedReaderWriterStateT</a><span class="delimiter">[</span>Id, R, W, S1, S2, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="scalaz.package.IndexedReaderWriterState.type" id="30777">IndexedReaderWriterState</a> <a href="#30778" title="scalaz.package.IndexedReaderWriterState.type" class="keyword">extends</a> <a href="ReaderWriterStateT.scala.html#16310" title="scalaz.ReaderWriterStateTFunctions">ReaderWriterStateTFunctions</a> <span class="keyword">with</span> <a href="ReaderWriterStateT.scala.html#20903" title="scalaz.ReaderWriterStateTInstances">ReaderWriterStateTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[R, W, S1, S2, A](f: (R, S1) =&gt; (W, A, S2))scalaz.package.IndexedReaderWriterState[R,W,S1,S2,A]" id="448477">apply</a><span class="delimiter">[</span><a title="" id="448483">R</a>, <a title="" id="448484">W</a>, <a title="" id="448485">S1</a>, <a title="" id="448486">S2</a>, <a title="" id="448487">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(R, S1) =&gt; (W, A, S2)" id="448600">f</a>: <span class="delimiter">(</span>R, S1<span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>W, A, S2<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="ReaderWriterStateT.scala.html#20750" title="scalaz.package.IndexedReaderWriterState[R,W,S1,S2,A]">IndexedReaderWriterState</a><span class="delimiter">[</span>R, W, S1, S2, A<span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#411818" title="[F[+_], R, W, S1, S2, A](f: (R, S1) =&gt; F[(W, A, S2)])scalaz.IndexedReaderWriterStateT[F,R,W,S1,S2,A]">IndexedReaderWriterStateT</a><span title="(f: (R, S1) =&gt; (W, A, S2))scalaz.IndexedReaderWriterStateT[scalaz.Id.Id,R,W,S1,S2,A]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#448483" title="R">R</a>, <a href="#448484" title="W">W</a>, <a href="#448485" title="S1">S1</a>, <a href="#448486" title="S2">S2</a>, <a href="#448487" title="A">A</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="delimiter">(</span>r: <a href="#448483" title="R">R</a>, s: <a href="#448485" title="S1">S1</a><span class="delimiter">)</span> =&gt; <a href="#448600" title="(v1: R, v2: S1)(W, A, S2)">f</a><span class="delimiter">(</span><a href="#448605" title="R">r</a>, <a href="#448606" title="S1">s</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[-R, +W, S, +A]scalaz.package.ReaderWriterStateT[scalaz.Id.Id,R,W,S,A]" id="30779">ReaderWriterState</a><span class="delimiter">[</span>-<a title="" id="30780">R</a>, +<a title="" id="30781">W</a>, <a title="" id="30782">S</a>, +<a title="" id="30783">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#20750" title="scalaz.package.ReaderWriterStateT[scalaz.Id.Id,R,W,S,A]">ReaderWriterStateT</a><span class="delimiter">[</span>Id, R, W, S, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="scalaz.package.ReaderWriterState.type" id="30784">ReaderWriterState</a> <a href="#30785" title="scalaz.package.ReaderWriterState.type" class="keyword">extends</a> <a href="ReaderWriterStateT.scala.html#16310" title="scalaz.ReaderWriterStateTFunctions">ReaderWriterStateTFunctions</a> <span class="keyword">with</span> <a href="ReaderWriterStateT.scala.html#20903" title="scalaz.ReaderWriterStateTInstances">ReaderWriterStateTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[R, W, S, A](f: (R, S) =&gt; (W, A, S))scalaz.package.ReaderWriterState[R,W,S,A]" id="448489">apply</a><span class="delimiter">[</span><a title="" id="448494">R</a>, <a title="" id="448495">W</a>, <a title="" id="448496">S</a>, <a title="" id="448497">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(R, S) =&gt; (W, A, S)" id="448610">f</a>: <span class="delimiter">(</span>R, S<span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>W, A, S<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="ReaderWriterStateT.scala.html#20750" title="scalaz.package.ReaderWriterState[R,W,S,A]">ReaderWriterState</a><span class="delimiter">[</span>R, W, S, A<span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#411818" title="[F[+_], R, W, S1, S2, A](f: (R, S1) =&gt; F[(W, A, S2)])scalaz.IndexedReaderWriterStateT[F,R,W,S1,S2,A]">IndexedReaderWriterStateT</a><span title="(f: (R, S) =&gt; (W, A, S))scalaz.IndexedReaderWriterStateT[scalaz.Id.Id,R,W,S,S,A]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#448494" title="R">R</a>, <a href="#448495" title="W">W</a>, <a href="#448496" title="S">S</a>, <a href="#448496" title="S">S</a>, <a href="#448497" title="A">A</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="delimiter">(</span>r: <a href="#448494" title="R">R</a>, s: <a href="#448496" title="S">S</a><span class="delimiter">)</span> =&gt; <a href="#448610" title="(v1: R, v2: S)(W, A, S)">f</a><span class="delimiter">(</span><a href="#448615" title="R">r</a>, <a href="#448616" title="S">s</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[F[+_], -R, +W, -S1, +S2, +A]scalaz.IndexedReaderWriterStateT[F,R,W,S1,S2,A]" id="30786">IRWST</a><span class="delimiter">[</span><a title="[+_]" id="30787">F</a><span class="delimiter">[</span>+<a title="" id="448619">_</a><span class="delimiter">]</span>, -<a title="" id="30788">R</a>, +<a title="" id="30789">W</a>, -<a title="" id="30790">S1</a>, +<a title="" id="30791">S2</a>, +<a title="" id="30792">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#20750" title="scalaz.IndexedReaderWriterStateT[F,R,W,S1,S2,A]">IndexedReaderWriterStateT</a><span class="delimiter">[</span>F, R, W, S1, S2, A<span class="delimiter">]</span>
  <span class="keyword">val</span> <a title="scalaz.IndexedReaderWriterStateT.type" id="30793">IRWST</a>: IndexedReaderWriterStateT.<span class="keyword">type</span> = <a href="ReaderWriterStateT.scala.html#20751" title="scalaz.IndexedReaderWriterStateT.type">IndexedReaderWriterStateT</a>
  <span class="keyword">type</span> <a title="[-R, +W, -S1, +S2, +A]scalaz.package.IndexedReaderWriterState[R,W,S1,S2,A]" id="30795">IRWS</a><span class="delimiter">[</span>-<a title="" id="30796">R</a>, +<a title="" id="30797">W</a>, -<a title="" id="30798">S1</a>, +<a title="" id="30799">S2</a>, +<a title="" id="30800">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#20750" title="scalaz.package.IndexedReaderWriterState[R,W,S1,S2,A]">IndexedReaderWriterState</a><span class="delimiter">[</span>R, W, S1, S2, A<span class="delimiter">]</span>
  <span class="keyword">val</span> <a title="scalaz.package.IndexedReaderWriterState.type" id="30801">IRWS</a>: IndexedReaderWriterState.<span class="keyword">type</span> = <a href="#30777" title="scalaz.package.IndexedReaderWriterState.type">IndexedReaderWriterState</a>
  <span class="keyword">type</span> <a title="[F[+_], -R, +W, S, +A]scalaz.package.ReaderWriterStateT[F,R,W,S,A]" id="30803">RWST</a><span class="delimiter">[</span><a title="[+_]" id="30804">F</a><span class="delimiter">[</span>+<a title="" id="448620">_</a><span class="delimiter">]</span>, -<a title="" id="30805">R</a>, +<a title="" id="30806">W</a>, <a title="" id="30807">S</a>, +<a title="" id="30808">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#20750" title="scalaz.package.ReaderWriterStateT[F,R,W,S,A]">ReaderWriterStateT</a><span class="delimiter">[</span>F, R, W, S, A<span class="delimiter">]</span>
  <span class="keyword">val</span> <a title="scalaz.package.ReaderWriterStateT.type" id="30809">RWST</a>: ReaderWriterStateT.<span class="keyword">type</span> = <a href="#30769" title="scalaz.package.ReaderWriterStateT.type">ReaderWriterStateT</a>
  <span class="keyword">type</span> <a title="[-R, +W, S, +A]scalaz.package.ReaderWriterState[R,W,S,A]" id="30811">RWS</a><span class="delimiter">[</span>-<a title="" id="30812">R</a>, +<a title="" id="30813">W</a>, <a title="" id="30814">S</a>, +<a title="" id="30815">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#20750" title="scalaz.package.ReaderWriterState[R,W,S,A]">ReaderWriterState</a><span class="delimiter">[</span>R, W, S, A<span class="delimiter">]</span>
  <span class="keyword">val</span> <a title="scalaz.package.ReaderWriterState.type" id="30816">RWS</a>: ReaderWriterState.<span class="keyword">type</span> = <a href="#30784" title="scalaz.package.ReaderWriterState.type">ReaderWriterState</a>

  <span class="keyword">type</span> <a title="[F[_]]scalaz.ApplicativePlus[F]" id="30818">Alternative</a><span class="delimiter">[</span><a title="[_]" id="30819">F</a><span class="delimiter">[</span><a title="" id="448621">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="ApplicativePlus.scala.html#8588" title="scalaz.ApplicativePlus[F]">ApplicativePlus</a><span class="delimiter">[</span>F<span class="delimiter">]</span>

  /**
   * An [[scalaz.Validation]] with a [[scalaz.NonEmptyList]] as the failure type.
   *
   * Useful for accumulating errors through the corresponding [[scalaz.Applicative]] instance.
   */
  <span class="keyword">type</span> <a title="[+E, +X]scalaz.Validation[scalaz.NonEmptyList[E],X]" id="30820">ValidationNel</a><span class="delimiter">[</span>+<a title="" id="30821">E</a>, +<a title="" id="30822">X</a><span class="delimiter">]</span> = <a href="Validation.scala.html#11129" title="scalaz.Validation[scalaz.NonEmptyList[E],X]">Validation</a><span class="delimiter">[</span>NonEmptyList<span class="delimiter">[</span>E<span class="delimiter">]</span>, X<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[A,scalaz.Tags.FirstVal]" id="30823">FirstOf</a><span class="delimiter">[</span><a title="" id="30824">A</a><span class="delimiter">]</span> = A <a href="#448623" title="scalaz.package.@@[A,scalaz.Tags.FirstVal]">@@</a> Tags.FirstVal
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[A,scalaz.Tags.LastVal]" id="30825">LastOf</a><span class="delimiter">[</span><a title="" id="30826">A</a><span class="delimiter">]</span> = A <a href="#448630" title="scalaz.package.@@[A,scalaz.Tags.LastVal]">@@</a> Tags.LastVal
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[A,scalaz.Tags.MinVal]" id="30827">MinOf</a><span class="delimiter">[</span><a title="" id="30828">A</a><span class="delimiter">]</span> = A <a href="#448637" title="scalaz.package.@@[A,scalaz.Tags.MinVal]">@@</a> Tags.MinVal
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[A,scalaz.Tags.MaxVal]" id="30829">MaxOf</a><span class="delimiter">[</span><a title="" id="30830">A</a><span class="delimiter">]</span> = A <a href="#448644" title="scalaz.package.@@[A,scalaz.Tags.MaxVal]">@@</a> Tags.MaxVal

  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.First]" id="30831">FirstOption</a><span class="delimiter">[</span><a title="" id="30832">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#102283" title="scalaz.package.@@[Option[A],scalaz.Tags.First]">@@</a> Tags.First
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.Last]" id="30833">LastOption</a><span class="delimiter">[</span><a title="" id="30834">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#102465" title="scalaz.package.@@[Option[A],scalaz.Tags.Last]">@@</a> Tags.Last
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.Min]" id="30835">MinOption</a><span class="delimiter">[</span><a title="" id="30836">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#102635" title="scalaz.package.@@[Option[A],scalaz.Tags.Min]">@@</a> Tags.Min
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.Max]" id="30837">MaxOption</a><span class="delimiter">[</span><a title="" id="30838">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#100694" title="scalaz.package.@@[Option[A],scalaz.Tags.Max]">@@</a> Tags.Max

  //
  // Lens type aliases
  //
  /** A lens that doesn't transform the type of the record. */
  <span class="keyword">type</span> <a title="[A, B]scalaz.LensFamily[A,A,B,B]" id="30839">Lens</a><span class="delimiter">[</span><a title="" id="30840">A</a>, <a title="" id="30841">B</a><span class="delimiter">]</span> = <a href="Lens.scala.html#11120" title="scalaz.LensFamily[A,A,B,B]">LensFamily</a><span class="delimiter">[</span>A, A, B, B<span class="delimiter">]</span>

  // important to define here, rather than at the top-level, to avoid Scala 2.9.2 bug
  <span class="keyword">object</span> <a title="scalaz.package.Lens.type" id="30842">Lens</a> <a href="#30843" title="scalaz.package.Lens.type" class="keyword">extends</a> <a href="Lens.scala.html#21470" title="scalaz.LensFunctions">LensFunctions</a> <span class="keyword">with</span> <a href="Lens.scala.html#11033" title="scalaz.LensInstances">LensInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](r: A =&gt; scalaz.package.Store[B,A])scalaz.package.Lens[A,B]" id="125969">apply</a><span class="delimiter">[</span><a title="" id="125972">A</a>, <a title="" id="125973">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scalaz.package.Store[B,A]" id="126255">r</a>: A =&gt; Store<span class="delimiter">[</span>B, A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Lens.scala.html#11120" title="scalaz.package.Lens[A,B]">Lens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
      <a href="Lens.scala.html#125891" title="(r: A =&gt; scalaz.Store[B,A])scalaz.Lens[A,B]">lens</a><span class="delimiter">(</span><a href="#126255" title="A =&gt; scalaz.package.Store[B,A]">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[A, B]scalaz.package.Lens[A,B]" id="30844">@&gt;</a><span class="delimiter">[</span><a title="" id="30845">A</a>, <a title="" id="30846">B</a><span class="delimiter">]</span> = <a href="Lens.scala.html#11120" title="scalaz.package.Lens[A,B]">Lens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>

  //
  // Partial Lens type aliases
  //
  /** A partial lens that doesn't transform the type of the record. */
  <span class="keyword">type</span> <a title="[A, B]scalaz.PLensFamily[A,A,B,B]" id="30847">PLens</a><span class="delimiter">[</span><a title="" id="30848">A</a>, <a title="" id="30849">B</a><span class="delimiter">]</span> = <a href="PLens.scala.html#21380" title="scalaz.PLensFamily[A,A,B,B]">PLensFamily</a><span class="delimiter">[</span>A, A, B, B<span class="delimiter">]</span>

  // important to define here, rather than at the top-level, to avoid Scala 2.9.2 bug
  <span class="keyword">object</span> <a title="scalaz.package.PLens.type" id="30850">PLens</a> <a href="#30851" title="scalaz.package.PLens.type" class="keyword">extends</a> <a href="PLens.scala.html#16295" title="scalaz.PLensFunctions">PLensFunctions</a> <span class="keyword">with</span> <a href="PLens.scala.html#20387" title="scalaz.PLensInstances">PLensInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](r: A =&gt; Option[scalaz.package.Store[B,A]])scalaz.package.PLens[A,B]" id="366627">apply</a><span class="delimiter">[</span><a title="" id="366630">A</a>, <a title="" id="366631">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; Option[scalaz.package.Store[B,A]]" id="448676">r</a>: A =&gt; Option<span class="delimiter">[</span>Store<span class="delimiter">[</span>B, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="PLens.scala.html#21380" title="scalaz.package.PLens[A,B]">PLens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
      <a href="PLens.scala.html#69388" title="(r: A =&gt; Option[scalaz.Store[B,A]])scalaz.PLens[A,B]">plens</a><span class="delimiter">(</span><a href="#448676" title="A =&gt; Option[scalaz.package.Store[B,A]]">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[A, B]scalaz.package.PLens[A,B]" id="30852">@?&gt;</a><span class="delimiter">[</span><a title="" id="30853">A</a>, <a title="" id="30854">B</a><span class="delimiter">]</span> = <a href="PLens.scala.html#21380" title="scalaz.package.PLens[A,B]">PLens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[F[+_], -S1, +S2, +A]scalaz.IndexedStateT[F,S1,S2,Option[A]]" id="30855">PIndexedStateT</a><span class="delimiter">[</span><a title="[+_]" id="30856">F</a><span class="delimiter">[</span>+<a title="" id="405047">_</a><span class="delimiter">]</span>, -<a title="" id="30857">S1</a>, +<a title="" id="30858">S2</a>, +<a title="" id="30859">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#20021" title="scalaz.IndexedStateT[F,S1,S2,Option[A]]">IndexedStateT</a><span class="delimiter">[</span>F, S1, S2, Option<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[F[+_], S, +A]scalaz.package.PIndexedStateT[F,S,S,A]" id="30860">PStateT</a><span class="delimiter">[</span><a title="[+_]" id="30861">F</a><span class="delimiter">[</span>+<a title="" id="405046">_</a><span class="delimiter">]</span>, <a title="" id="30862">S</a>, +<a title="" id="30863">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#20021" title="scalaz.package.PIndexedStateT[F,S,S,A]">PIndexedStateT</a><span class="delimiter">[</span>F, S, S, A<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[-S1, +S2, +A]scalaz.package.PIndexedStateT[scalaz.Id.Id,S1,S2,A]" id="30864">PIndexedState</a><span class="delimiter">[</span>-<a title="" id="30865">S1</a>, +<a title="" id="30866">S2</a>, +<a title="" id="30867">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#20021" title="scalaz.package.PIndexedStateT[scalaz.Id.Id,S1,S2,A]">PIndexedStateT</a><span class="delimiter">[</span>Id, S1, S2, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[S, +A]scalaz.package.PStateT[scalaz.Id.Id,S,A]" id="30868">PState</a><span class="delimiter">[</span><a title="" id="30869">S</a>, +<a title="" id="30870">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#20021" title="scalaz.package.PStateT[scalaz.Id.Id,S,A]">PStateT</a><span class="delimiter">[</span>Id, S, A<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[W[+_], +R, -O, +A]scalaz.IndexedContsT[W,scalaz.Id.Id,R,O,A]" id="30871">IndexedConts</a><span class="delimiter">[</span><a title="[+_]" id="30872">W</a><span class="delimiter">[</span>+<a title="" id="448683">_</a><span class="delimiter">]</span>, +<a title="" id="30873">R</a>, -<a title="" id="30874">O</a>, +<a title="" id="30875">A</a><span class="delimiter">]</span> = <a href="IndexedContsT.scala.html#19751" title="scalaz.IndexedContsT[W,scalaz.Id.Id,R,O,A]">IndexedContsT</a><span class="delimiter">[</span>W, Id, R, O, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="scalaz.package.IndexedConts.type" id="30876">IndexedConts</a> <a href="#30877" title="scalaz.package.IndexedConts.type" class="keyword">extends</a> <a href="IndexedContsT.scala.html#20966" title="scalaz.IndexedContsTFunctions">IndexedContsTFunctions</a> <span class="keyword">with</span> <a href="IndexedContsT.scala.html#10448" title="scalaz.IndexedContsTInstances">IndexedContsTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[W[+_], R, O, A](f: W[A =&gt; O] =&gt; R)scalaz.package.IndexedConts[W,R,O,A]" id="448685">apply</a><span class="delimiter">[</span><a title="[+_]" id="448690">W</a><span class="delimiter">[</span>+<a title="" id="448696">_</a><span class="delimiter">]</span>, <a title="" id="448691">R</a>, <a title="" id="448692">O</a>, <a title="" id="448693">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="W[A =&gt; O] =&gt; R" id="448695">f</a>: W<span class="delimiter">[</span>A =&gt; O<span class="delimiter">]</span> =&gt; R<span class="delimiter">)</span>: <a href="IndexedContsT.scala.html#19751" title="scalaz.package.IndexedConts[W,R,O,A]">IndexedConts</a><span class="delimiter">[</span>W, R, O, A<span class="delimiter">]</span> = <a href="IndexedContsT.scala.html#364042" title="[W[+_], M[+_], R, O, A](f: W[A =&gt; M[O]] =&gt; M[R])scalaz.IndexedContsT[W,M,R,O,A]">IndexedContsT</a><span title="(f: W[A =&gt; scalaz.Id.Id[O]] =&gt; scalaz.Id.Id[R])scalaz.IndexedContsT[W,scalaz.Id.Id,R,O,A]" class="delimiter">[</span><a href="#448690" title="W">W</a>, <a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#448691" title="R">R</a>, <a href="#448692" title="O">O</a>, <a href="#448693" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#448695" title="W[A =&gt; O] =&gt; R">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[M[+_], +R, -O, +A]scalaz.IndexedContsT[scalaz.Id.Id,M,R,O,A]" id="30878">IndexedContT</a><span class="delimiter">[</span><a title="[+_]" id="30879">M</a><span class="delimiter">[</span>+<a title="" id="448700">_</a><span class="delimiter">]</span>, +<a title="" id="30880">R</a>, -<a title="" id="30881">O</a>, +<a title="" id="30882">A</a><span class="delimiter">]</span> = <a href="IndexedContsT.scala.html#19751" title="scalaz.IndexedContsT[scalaz.Id.Id,M,R,O,A]">IndexedContsT</a><span class="delimiter">[</span>Id, M, R, O, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="scalaz.package.IndexedContT.type" id="30883">IndexedContT</a> <a href="#30884" title="scalaz.package.IndexedContT.type" class="keyword">extends</a> <a href="IndexedContsT.scala.html#20966" title="scalaz.IndexedContsTFunctions">IndexedContsTFunctions</a> <span class="keyword">with</span> <a href="IndexedContsT.scala.html#10448" title="scalaz.IndexedContsTInstances">IndexedContsTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[M[+_], R, O, A](f: (A =&gt; M[O]) =&gt; M[R])scalaz.package.IndexedContT[M,R,O,A]" id="448702">apply</a><span class="delimiter">[</span><a title="[+_]" id="448707">M</a><span class="delimiter">[</span>+<a title="" id="448713">_</a><span class="delimiter">]</span>, <a title="" id="448708">R</a>, <a title="" id="448709">O</a>, <a title="" id="448710">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(A =&gt; M[O]) =&gt; M[R]" id="448712">f</a>: <span class="delimiter">(</span>A =&gt; M<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; M<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="IndexedContsT.scala.html#19751" title="scalaz.package.IndexedContT[M,R,O,A]">IndexedContT</a><span class="delimiter">[</span>M, R, O, A<span class="delimiter">]</span> = <a href="IndexedContsT.scala.html#364042" title="[W[+_], M[+_], R, O, A](f: W[A =&gt; M[O]] =&gt; M[R])scalaz.IndexedContsT[W,M,R,O,A]">IndexedContsT</a><span title="(f: (A =&gt; M[O]) =&gt; M[R])scalaz.IndexedContsT[scalaz.Id.Id,M,R,O,A]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#448707" title="M">M</a>, <a href="#448708" title="R">R</a>, <a href="#448709" title="O">O</a>, <a href="#448710" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#448712" title="(A =&gt; M[O]) =&gt; M[R]">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[+R, -O, +A]scalaz.package.IndexedContT[scalaz.Id.Id,R,O,A]" id="30885">IndexedCont</a><span class="delimiter">[</span>+<a title="" id="30886">R</a>, -<a title="" id="30887">O</a>, +<a title="" id="30888">A</a><span class="delimiter">]</span> = <a href="IndexedContsT.scala.html#19751" title="scalaz.package.IndexedContT[scalaz.Id.Id,R,O,A]">IndexedContT</a><span class="delimiter">[</span>Id, R, O, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="scalaz.package.IndexedCont.type" id="30889">IndexedCont</a> <a href="#30890" title="scalaz.package.IndexedCont.type" class="keyword">extends</a> <a href="IndexedContsT.scala.html#20966" title="scalaz.IndexedContsTFunctions">IndexedContsTFunctions</a> <span class="keyword">with</span> <a href="IndexedContsT.scala.html#10448" title="scalaz.IndexedContsTInstances">IndexedContsTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[W[+_], R, O, A](f: (A =&gt; O) =&gt; R)scalaz.package.IndexedCont[R,O,A]" id="448718">apply</a><span class="delimiter">[</span><a title="[+_]" id="448723">W</a><span class="delimiter">[</span>+<a title="" id="448730">_</a><span class="delimiter">]</span>, <a title="" id="448724">R</a>, <a title="" id="448725">O</a>, <a title="" id="448726">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(A =&gt; O) =&gt; R" id="448728">f</a>: <span class="delimiter">(</span>A =&gt; O<span class="delimiter">)</span> =&gt; R<span class="delimiter">)</span>: <a href="IndexedContsT.scala.html#19751" title="scalaz.package.IndexedCont[R,O,A]">IndexedCont</a><span class="delimiter">[</span>R, O, A<span class="delimiter">]</span> = <a href="IndexedContsT.scala.html#364042" title="[W[+_], M[+_], R, O, A](f: W[A =&gt; M[O]] =&gt; M[R])scalaz.IndexedContsT[W,M,R,O,A]">IndexedContsT</a><span title="(f: (A =&gt; scalaz.Id.Id[O]) =&gt; scalaz.Id.Id[R])scalaz.IndexedContsT[scalaz.Id.Id,scalaz.Id.Id,R,O,A]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#448724" title="R">R</a>, <a href="#448725" title="O">O</a>, <a href="#448726" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#448728" title="(A =&gt; O) =&gt; R">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[W[+_], M[+_], R, +A]scalaz.IndexedContsT[W,M,R,R,A]" id="30891">ContsT</a><span class="delimiter">[</span><a title="[+_]" id="30892">W</a><span class="delimiter">[</span>+<a title="" id="364389">_</a><span class="delimiter">]</span>, <a title="[+_]" id="30893">M</a><span class="delimiter">[</span>+<a title="" id="364390">_</a><span class="delimiter">]</span>, <a title="" id="30894">R</a>, +<a title="" id="30895">A</a><span class="delimiter">]</span> = <a href="IndexedContsT.scala.html#19751" title="scalaz.IndexedContsT[W,M,R,R,A]">IndexedContsT</a><span class="delimiter">[</span>W, M, R, R, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="scalaz.package.ContsT.type" id="30896">ContsT</a> <a href="#30897" title="scalaz.package.ContsT.type" class="keyword">extends</a> <a href="IndexedContsT.scala.html#20966" title="scalaz.IndexedContsTFunctions">IndexedContsTFunctions</a> <span class="keyword">with</span> <a href="IndexedContsT.scala.html#10448" title="scalaz.IndexedContsTInstances">IndexedContsTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[W[+_], M[+_], R, A](f: W[A =&gt; M[R]] =&gt; M[R])scalaz.package.ContsT[W,M,R,A]" id="364473">apply</a><span class="delimiter">[</span><a title="[+_]" id="364478">W</a><span class="delimiter">[</span>+<a title="" id="364483">_</a><span class="delimiter">]</span>, <a title="[+_]" id="364479">M</a><span class="delimiter">[</span>+<a title="" id="364484">_</a><span class="delimiter">]</span>, <a title="" id="364480">R</a>, <a title="" id="364481">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="W[A =&gt; M[R]] =&gt; M[R]" id="364482">f</a>: W<span class="delimiter">[</span>A =&gt; M<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">]</span> =&gt; M<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="IndexedContsT.scala.html#19751" title="scalaz.package.ContsT[W,M,R,A]">ContsT</a><span class="delimiter">[</span>W, M, R, A<span class="delimiter">]</span> = <a href="IndexedContsT.scala.html#364042" title="[W[+_], M[+_], R, O, A](f: W[A =&gt; M[O]] =&gt; M[R])scalaz.IndexedContsT[W,M,R,O,A]">IndexedContsT</a><span title="(f: W[A =&gt; M[R]] =&gt; M[R])scalaz.IndexedContsT[W,M,R,R,A]" class="delimiter">[</span><a href="#364478" title="W">W</a>, <a href="#364479" title="M">M</a>, <a href="#364480" title="R">R</a>, <a href="#364480" title="R">R</a>, <a href="#364481" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#364482" title="W[A =&gt; M[R]] =&gt; M[R]">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[W[+_], R, +A]scalaz.package.ContsT[W,scalaz.Id.Id,R,A]" id="30898">Conts</a><span class="delimiter">[</span><a title="[+_]" id="30899">W</a><span class="delimiter">[</span>+<a title="" id="448735">_</a><span class="delimiter">]</span>, <a title="" id="30900">R</a>, +<a title="" id="30901">A</a><span class="delimiter">]</span> = <a href="IndexedContsT.scala.html#19751" title="scalaz.package.ContsT[W,scalaz.Id.Id,R,A]">ContsT</a><span class="delimiter">[</span>W, Id, R, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="scalaz.package.Conts.type" id="30902">Conts</a> <a href="#30903" title="scalaz.package.Conts.type" class="keyword">extends</a> <a href="IndexedContsT.scala.html#20966" title="scalaz.IndexedContsTFunctions">IndexedContsTFunctions</a> <span class="keyword">with</span> <a href="IndexedContsT.scala.html#10448" title="scalaz.IndexedContsTInstances">IndexedContsTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[W[+_], R, A](f: W[A =&gt; R] =&gt; R)scalaz.package.Conts[W,R,A]" id="448737">apply</a><span class="delimiter">[</span><a title="[+_]" id="448741">W</a><span class="delimiter">[</span>+<a title="" id="448746">_</a><span class="delimiter">]</span>, <a title="" id="448742">R</a>, <a title="" id="448743">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="W[A =&gt; R] =&gt; R" id="448745">f</a>: W<span class="delimiter">[</span>A =&gt; R<span class="delimiter">]</span> =&gt; R<span class="delimiter">)</span>: <a href="IndexedContsT.scala.html#19751" title="scalaz.package.Conts[W,R,A]">Conts</a><span class="delimiter">[</span>W, R, A<span class="delimiter">]</span> = <a href="IndexedContsT.scala.html#364042" title="[W[+_], M[+_], R, O, A](f: W[A =&gt; M[O]] =&gt; M[R])scalaz.IndexedContsT[W,M,R,O,A]">IndexedContsT</a><span title="(f: W[A =&gt; scalaz.Id.Id[R]] =&gt; scalaz.Id.Id[R])scalaz.IndexedContsT[W,scalaz.Id.Id,R,R,A]" class="delimiter">[</span><a href="#448741" title="W">W</a>, <a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#448742" title="R">R</a>, <a href="#448742" title="R">R</a>, <a href="#448743" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#448745" title="W[A =&gt; R] =&gt; R">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[M[+_], R, +A]scalaz.package.ContsT[scalaz.Id.Id,M,R,A]" id="30904">ContT</a><span class="delimiter">[</span><a title="[+_]" id="30905">M</a><span class="delimiter">[</span>+<a title="" id="448750">_</a><span class="delimiter">]</span>, <a title="" id="30906">R</a>, +<a title="" id="30907">A</a><span class="delimiter">]</span> = <a href="IndexedContsT.scala.html#19751" title="scalaz.package.ContsT[scalaz.Id.Id,M,R,A]">ContsT</a><span class="delimiter">[</span>Id, M, R, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="scalaz.package.ContT.type" id="30908">ContT</a> <a href="#30909" title="scalaz.package.ContT.type" class="keyword">extends</a> <a href="IndexedContsT.scala.html#20966" title="scalaz.IndexedContsTFunctions">IndexedContsTFunctions</a> <span class="keyword">with</span> <a href="IndexedContsT.scala.html#10448" title="scalaz.IndexedContsTInstances">IndexedContsTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[M[+_], R, A](f: (A =&gt; M[R]) =&gt; M[R])scalaz.package.ContT[M,R,A]" id="448752">apply</a><span class="delimiter">[</span><a title="[+_]" id="448756">M</a><span class="delimiter">[</span>+<a title="" id="448761">_</a><span class="delimiter">]</span>, <a title="" id="448757">R</a>, <a title="" id="448758">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(A =&gt; M[R]) =&gt; M[R]" id="448760">f</a>: <span class="delimiter">(</span>A =&gt; M<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span> =&gt; M<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="IndexedContsT.scala.html#19751" title="scalaz.package.ContT[M,R,A]">ContT</a><span class="delimiter">[</span>M, R, A<span class="delimiter">]</span> = <a href="IndexedContsT.scala.html#364042" title="[W[+_], M[+_], R, O, A](f: W[A =&gt; M[O]] =&gt; M[R])scalaz.IndexedContsT[W,M,R,O,A]">IndexedContsT</a><span title="(f: (A =&gt; M[R]) =&gt; M[R])scalaz.IndexedContsT[scalaz.Id.Id,M,R,R,A]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#448756" title="M">M</a>, <a href="#448757" title="R">R</a>, <a href="#448757" title="R">R</a>, <a href="#448758" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#448760" title="(A =&gt; M[R]) =&gt; M[R]">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[R, +A]scalaz.package.ContT[scalaz.Id.Id,R,A]" id="30910">Cont</a><span class="delimiter">[</span><a title="" id="30911">R</a>, +<a title="" id="30912">A</a><span class="delimiter">]</span> = <a href="IndexedContsT.scala.html#19751" title="scalaz.package.ContT[scalaz.Id.Id,R,A]">ContT</a><span class="delimiter">[</span>Id, R, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="scalaz.package.Cont.type" id="30913">Cont</a> <a href="#30914" title="scalaz.package.Cont.type" class="keyword">extends</a> <a href="IndexedContsT.scala.html#20966" title="scalaz.IndexedContsTFunctions">IndexedContsTFunctions</a> <span class="keyword">with</span> <a href="IndexedContsT.scala.html#10448" title="scalaz.IndexedContsTInstances">IndexedContsTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[R, A](f: (A =&gt; R) =&gt; R)scalaz.package.Cont[R,A]" id="448766">apply</a><span class="delimiter">[</span><a title="" id="448769">R</a>, <a title="" id="448770">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(A =&gt; R) =&gt; R" id="448772">f</a>: <span class="delimiter">(</span>A =&gt; R<span class="delimiter">)</span> =&gt; R<span class="delimiter">)</span>: <a href="IndexedContsT.scala.html#19751" title="scalaz.package.Cont[R,A]">Cont</a><span class="delimiter">[</span>R, A<span class="delimiter">]</span> = <a href="IndexedContsT.scala.html#364042" title="[W[+_], M[+_], R, O, A](f: W[A =&gt; M[O]] =&gt; M[R])scalaz.IndexedContsT[W,M,R,O,A]">IndexedContsT</a><span title="(f: (A =&gt; scalaz.Id.Id[R]) =&gt; scalaz.Id.Id[R])scalaz.IndexedContsT[scalaz.Id.Id,scalaz.Id.Id,R,R,A]" class="delimiter">[</span><a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="Id.scala.html#33406" title="scalaz.Id.Id">Id</a>, <a href="#448769" title="R">R</a>, <a href="#448769" title="R">R</a>, <a href="#448770" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#448772" title="(A =&gt; R) =&gt; R">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>