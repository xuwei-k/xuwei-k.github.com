<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/Adjunction.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz

<span class="keyword">import</span> <a href="Id.scala.html#8190" title="scalaz.Id.type">Id</a>._

/**
 * An adjunction formed by two functors `F` and `G` such that `F` is left-adjoint to `G`.
 * The composite functor GF is a monad and the composite functor FG is a comonad.
 *
 * The minimal defition is either (unit, counit) or (leftAdjunct, rightAdjunct)
 */
<span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Adjunction[F[_], G[_]] extends AnyRef" id="17330">Adjunction</a><span class="delimiter">[</span><a title="[_]" id="22821">F</a><span class="delimiter">[</span><a title="" id="75352">_</a><span class="delimiter">]</span>, <a title="[_]" id="22822">G</a><span class="delimiter">[</span><a title="" id="75353">_</a><span class="delimiter">]</span><span class="delimiter">]</span><a href="#17330" title="scalaz.Adjunction[F,G]" class="delimiter">(</a><span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Functor[F]" id="75398">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="scalaz.Functor[G]" id="75399">G</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[G]">Functor</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span> self =&gt;

  /** Puts a value into the monad. */
  <span class="keyword">def</span> <a title="[A](a: =&gt; A)G[F[A]]" id="75320">unit</a><span class="delimiter">[</span><a title="" id="75322">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="75400">a</a>: =&gt; A<span class="delimiter">)</span>: <a href="#22822" title="G[F[A]]">G</a><span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#75326" title="(a: =&gt; A)(f: F[A] =&gt; F[A])G[F[A]]">leftAdjunct</a><span class="delimiter">(</span><a href="#75400" title="=&gt; A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="F[A]" id="75415">x</a> =&gt; <a href="#75415" title="F[A]">x</a><span class="delimiter">)</span>

  /** Extracts a value out of the comonad. */
  <span class="keyword">def</span> <a title="[A](a: F[G[A]])A" id="75323">counit</a><span class="delimiter">[</span><a title="" id="75325">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[G[A]]" id="75418">a</a>: <a href="#22821" title="F[G[A]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#75325" title="A">A</a> = <a href="#75331" title="(a: F[G[A]])(f: G[A] =&gt; G[A])A">rightAdjunct</a><span class="delimiter">(</span><a href="#75418" title="F[G[A]]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="G[A]" id="75433">x</a> =&gt; <a href="#75433" title="G[A]">x</a><span class="delimiter">)</span>

  /** Every `F`-algebra maps to a `G`-coalgebra. */
  <span class="keyword">def</span> <a title="[A, B](a: =&gt; A)(f: F[A] =&gt; B)G[B]" id="75326">leftAdjunct</a><span class="delimiter">[</span><a title="" id="75329">A</a>, <a title="" id="75330">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="75402">a</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="F[A] =&gt; B" id="75403">f</a>: F<span class="delimiter">[</span>A<span class="delimiter">]</span> =&gt; B<span class="delimiter">)</span>: <a href="#22822" title="G[B]">G</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <a href="#75399" title="=&gt; scalaz.Functor[G]">G</a>.<a href="Functor.scala.html#33415" title="(fa: G[F[A]])(f: F[A] =&gt; B)G[B]">map</a><span class="delimiter">(</span><a href="#75320" title="(a: =&gt; A)G[F[A]]">unit</a><span class="delimiter">(</span><a href="#75402" title="=&gt; A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#75403" title="F[A] =&gt; B">f</a><span class="delimiter">)</span>

  /** Every `G`-coalgebra maps to an `F`-algebra. */
  <span class="keyword">def</span> <a title="[A, B](a: F[A])(f: A =&gt; G[B])B" id="75331">rightAdjunct</a><span class="delimiter">[</span><a title="" id="75334">A</a>, <a title="" id="75335">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="75420">a</a>: <a href="#22821" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; G[B]" id="75421">f</a>: A =&gt; G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#75335" title="B">B</a> = <a href="#75323" title="(a: F[G[B]])B">counit</a><span class="delimiter">(</span><a href="#75398" title="=&gt; scalaz.Functor[F]">F</a>.<a href="Functor.scala.html#33415" title="(fa: F[A])(f: A =&gt; G[B])F[G[B]]">map</a><span class="delimiter">(</span><a href="#75420" title="F[A]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#75421" title="A =&gt; G[B]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  /** Adjoint functors annihilate each other. */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Zap[F,G]" id="75336">zapFG</a>: <a href="Zap.scala.html#13949" title="scalaz.Zap[F,G]">Zap</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span> = <a href="#75464" title="scalaz.Zap[F,G]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Zap[F,G]" id="75464">Zap</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B, C](a: F[A], b: G[B])(f: (A, B) =&gt; C)C" id="75466">zapWith</a><span class="delimiter">[</span><a title="" id="75470">A</a>, <a title="" id="75471">B</a>, <a title="" id="75472">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="75474">a</a>: <a href="#22821" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="G[B]" id="75475">b</a>: <a href="#22822" title="G[B]">G</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="75476">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#75472" title="C">C</a> =
      <a href="#75476" title="(A, B) =&gt; C">f</a>.<span title="(v1: (A, B))C">tupled</span><span class="delimiter">(</span><a href="#75323" title="(a: F[G[(A, B)]])(A, B)">counit</a><span class="delimiter">(</span><a href="#75398" title="=&gt; scalaz.Functor[F]">F</a>.<a href="Functor.scala.html#33415" title="(fa: F[(A, G[B])])(f: ((A, G[B])) =&gt; G[(A, B)])F[G[(A, B)]]">map</a><span class="delimiter">(</span><a href="#75398" title="=&gt; scalaz.Functor[F]">F</a>.<a href="Functor.scala.html#33435" title="(f: F[A], b: G[B])F[(A, G[B])]">strengthR</a><span class="delimiter">(</span><a href="#75474" title="F[A]">a</a>, <a href="#75475" title="G[B]">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, G[B])" id="75527">p</a> =&gt; <a href="#75399" title="=&gt; scalaz.Functor[G]">G</a>.<a href="Functor.scala.html#33430" title="(a: A, f: G[B])G[(A, B)]">strengthL</a><span class="delimiter">(</span><a href="#75527" title="(A, G[B])">p</a>.<span title="=&gt; A">_1</span>, <a href="#75527" title="(A, G[B])">p</a>.<span title="=&gt; G[B]">_2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Adjoint functors annihilate each other. */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Zap[G,F]" id="75338">zapGF</a>: <a href="Zap.scala.html#13949" title="scalaz.Zap[G,F]">Zap</a><span class="delimiter">[</span>G, F<span class="delimiter">]</span> = <a href="#75546" title="scalaz.Zap[G,F]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Zap[G,F]" id="75546">Zap</a><span class="delimiter">[</span>G, F<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B, C](a: G[A], b: F[B])(f: (A, B) =&gt; C)C" id="75548">zapWith</a><span class="delimiter">[</span><a title="" id="75552">A</a>, <a title="" id="75553">B</a>, <a title="" id="75554">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="G[A]" id="75556">a</a>: <a href="#22822" title="G[A]">G</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="F[B]" id="75557">b</a>: <a href="#22821" title="F[B]">F</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="75558">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#75554" title="C">C</a> =
      <a href="#75558" title="(A, B) =&gt; C">f</a>.<span title="(v1: (A, B))C">tupled</span><span class="delimiter">(</span><a href="#75323" title="(a: F[G[(A, B)]])(A, B)">counit</a><span class="delimiter">(</span><a href="#75398" title="=&gt; scalaz.Functor[F]">F</a>.<a href="Functor.scala.html#33415" title="(fa: F[(G[A], B)])(f: ((G[A], B)) =&gt; G[(A, B)])F[G[(A, B)]]">map</a><span class="delimiter">(</span><a href="#75398" title="=&gt; scalaz.Functor[F]">F</a>.<a href="Functor.scala.html#33430" title="(a: G[A], f: F[B])F[(G[A], B)]">strengthL</a><span class="delimiter">(</span><a href="#75556" title="G[A]">a</a>, <a href="#75557" title="F[B]">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(G[A], B)" id="75599">p</a> =&gt; <a href="#75399" title="=&gt; scalaz.Functor[G]">G</a>.<a href="Functor.scala.html#33435" title="(f: G[A], b: B)G[(A, B)]">strengthR</a><span class="delimiter">(</span><a href="#75599" title="(G[A], B)">p</a>.<span title="=&gt; G[A]">_1</span>, <a href="#75599" title="(G[A], B)">p</a>.<span title="=&gt; B">_2</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Every adjunction is representable. */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Representable[G,F[Unit]]" id="75340">representable</a>: <a href="Representable.scala.html#11450" title="scalaz.Representable[G,F[Unit]]">Representable</a><span class="delimiter">[</span>G, F<span class="delimiter">[</span>Unit<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#75614" title="scalaz.Representable[G,F[Unit]]" class="keyword">new</a> <a title="anonymous class $anon extends scalaz.Representable[G,F[Unit]]" id="75614">Representable</a><span class="delimiter">[</span>G, F<span class="delimiter">[</span>Unit<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A](f: F[Unit] =&gt; A)G[A]" id="75616">rep</a><span class="delimiter">[</span><a title="" id="75618">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[Unit] =&gt; A" id="75625">f</a>: F<span class="delimiter">[</span>Unit<span class="delimiter">]</span> =&gt; A<span class="delimiter">)</span>: <a href="#22822" title="G[A]">G</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#75326" title="(a: =&gt; Unit)(f: F[Unit] =&gt; A)G[A]">leftAdjunct</a><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#75625" title="F[Unit] =&gt; A">f</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[A](g: G[A])F[Unit] =&gt; A" id="75619">unrep</a><span class="delimiter">[</span><a title="" id="75621">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="G[A]" id="75633">g</a>: <a href="#22822" title="G[A]">G</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: F<span class="delimiter">[</span>Unit<span class="delimiter">]</span> =&gt; A = <a title="F[Unit]" id="75666">fu</a> =&gt; <a href="#75331" title="(a: F[Unit])(f: Unit =&gt; G[A])A">rightAdjunct</a><span class="delimiter">(</span><a href="#75666" title="F[Unit]">fu</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Unit" id="75676">u</a> =&gt; <a href="#75633" title="G[A]">g</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Every adjunction gives rise to a monad. */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Monad[[α]G[F[α]]]" id="75342">monad</a>: <a href="Monad.scala.html#15566" title="scalaz.Monad[[α]G[F[α]]]">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = G<span class="delimiter">[</span>F<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#75683" title="scalaz.Monad[[α]G[F[α]]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Monad[[α]G[F[α]]]" id="75683">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = G<span class="delimiter">[</span>F<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A](a: =&gt; A)G[F[A]]" id="75690">point</a><span class="delimiter">[</span><a title="" id="75692">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="75813">a</a>: =&gt; A<span class="delimiter">)</span> = <a href="#75320" title="(a: =&gt; A)G[F[A]]">unit</a><span class="delimiter">(</span><a href="#75813" title="=&gt; A">a</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[A, B](a: G[F[A]])(f: A =&gt; G[F[B]])G[F[B]]" id="75693">bind</a><span class="delimiter">[</span><a title="" id="75696">A</a>,<a title="" id="75697">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="G[F[A]]" id="75827">a</a>: <a href="#22822" title="G[F[A]]">G</a><span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; G[F[B]]" id="75828">f</a>: A =&gt; G<span class="delimiter">[</span>F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#75399" title="=&gt; scalaz.Functor[G]">G</a>.<a href="Functor.scala.html#33415" title="(fa: G[F[A]])(f: F[A] =&gt; F[B])G[F[B]]">map</a><span class="delimiter">(</span><a href="#75827" title="G[F[A]]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#75331" title="(a: F[A])(f: A =&gt; G[F[B]])F[B]">rightAdjunct</a><span class="delimiter">(</span><a href="#75855" title="F[A]">_</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#75828" title="A =&gt; G[F[B]]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /** Every adjunction gives rise to a comonad. */
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Comonad[[α]F[G[α]]]" id="75344">comonad</a>: <a href="Comonad.scala.html#20012" title="scalaz.Comonad[[α]F[G[α]]]">Comonad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = F<span class="delimiter">[</span>G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#75891" title="scalaz.Comonad[[α]F[G[α]]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.Comonad[[α]F[G[α]]]" id="75891">Comonad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = F<span class="delimiter">[</span>G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A](a: F[G[A]])A" id="75898">copoint</a><span class="delimiter">[</span><a title="" id="75900">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[G[A]]" id="75918">a</a>: <a href="#22821" title="F[G[A]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#75323" title="(a: F[G[A]])A">counit</a><span class="delimiter">(</span><a href="#75918" title="F[G[A]]">a</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[A, B](a: F[G[A]])(f: F[G[A]] =&gt; B)F[G[B]]" id="75901">cobind</a><span class="delimiter">[</span><a title="" id="75904">A</a>,<a title="" id="75905">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[G[A]]" id="75933">a</a>: <a href="#22821" title="F[G[A]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="F[G[A]] =&gt; B" id="75934">f</a>: F<span class="delimiter">[</span>G<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =&gt; B<span class="delimiter">)</span>: <a href="#22821" title="F[G[B]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#75398" title="=&gt; scalaz.Functor[F]">F</a>.<a href="Functor.scala.html#33415" title="(fa: F[G[A]])(f: G[A] =&gt; G[B])F[G[B]]">map</a><span class="delimiter">(</span><a href="#75933" title="F[G[A]]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#75326" title="(a: =&gt; G[A])(f: F[G[A]] =&gt; B)G[B]">leftAdjunct</a><span class="delimiter">(</span><a href="#76037" title="G[A]">_</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#75934" title="F[G[A]] =&gt; B">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[A, B](a: F[G[A]])(f: A =&gt; B)F[G[B]]" id="75906">map</a><span class="delimiter">[</span><a title="" id="75909">A</a>,<a title="" id="75910">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[G[A]]" id="75946">a</a>: <a href="#22821" title="F[G[A]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="75947">f</a>: A =&gt; B<span class="delimiter">)</span> = <a href="#75901" title="(a: F[G[A]])(f: F[G[A]] =&gt; B)F[G[B]]">cobind</a><span class="delimiter">(</span><a href="#75946" title="F[G[A]]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="F[G[A]]" id="75974">x</a> =&gt; <a href="#75947" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#75323" title="(a: F[G[A]])A">counit</a><span class="delimiter">(</span><a href="#75974" title="F[G[A]]">x</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[A](a: F[G[A]])F[G[F[G[A]]]]" id="75911">cojoin</a><span class="delimiter">[</span><a title="" id="75913">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[G[A]]" id="75985">a</a>: <a href="#22821" title="F[G[A]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#75901" title="(a: F[G[A]])(f: F[G[A]] =&gt; F[G[A]])F[G[F[G[A]]]]">cobind</a><span class="delimiter">(</span><a href="#75985" title="F[G[A]]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="F[G[A]]" id="76006">x</a> =&gt; <a href="#76006" title="F[G[A]]">x</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">import</span> <a href="#17331" title="scalaz.Adjunction.type">Adjunction</a>.-|

  /**
   * Adjunctions compose in a natural fashion. If `F -| G` is an adjunction, and `P -| Q` is an
   * adjunction, then PF -| GQ is an adjunction. In fact, adjunctions in Scala form a monoid.
   */
  <span class="keyword">def</span> <a title="[P[_], Q[_]](implicit A: scalaz.Adjunction.-|[P,Q])scalaz.Adjunction.-|[[α]P[F[α]],[α]G[Q[α]]]" id="75347">compose</a><span class="delimiter">[</span><a title="[_]" id="75350">P</a><span class="delimiter">[</span><a title="" id="76113">_</a><span class="delimiter">]</span>, <a title="[_]" id="75351">Q</a><span class="delimiter">[</span><a title="" id="76119">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Adjunction.-|[P,Q]" id="76109">A</a>: P <a href="#17330" title="scalaz.Adjunction.-|[P,Q]">-|</a> Q<span class="delimiter">)</span>: <span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = P<span class="delimiter">[</span>F<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ <a href="#17330" title="scalaz.Adjunction.-|[[α]P[F[α]],[α]G[Q[α]]]">-|</a> <span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = G<span class="delimiter">[</span>Q<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ = <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Functor[P]" id="76129">P</a> = <a href="#76109" title="scalaz.Adjunction.-|[P,Q]">A</a>.<a href="#75398" title="=&gt; scalaz.Functor[P]">F</a>
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Functor[Q]" id="76130">Q</a> = <a href="#76109" title="scalaz.Adjunction.-|[P,Q]">A</a>.<a href="#75399" title="=&gt; scalaz.Functor[Q]">G</a>
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Functor[[α]P[F[α]]]" id="76131">PF</a> = <a href="#76129" title="scalaz.Functor[P]">P</a> <a href="Functor.scala.html#33461" title="(implicit G0: scalaz.Functor[F])scalaz.Functor[[α]P[F[α]]]">compose</a> <a href="#75398" title="=&gt; scalaz.Functor[F]">F</a>
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Functor[[α]G[Q[α]]]" id="76132">GQ</a> = <a href="#75399" title="=&gt; scalaz.Functor[G]">G</a> <a href="Functor.scala.html#33461" title="(implicit G0: scalaz.Functor[Q])scalaz.Functor[[α]G[Q[α]]]">compose</a> <a href="#76130" title="scalaz.Functor[Q]">Q</a>
    <a href="#76145" title="scalaz.Adjunction.-|[[α]P[F[α]],[α]G[Q[α]]]" class="keyword">new</a> <a title="anonymous class $anon extends scalaz.Adjunction.-|[[α]P[F[α]],[α]G[Q[α]]]" id="76145" class="delimiter">(</a><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = P<span class="delimiter">[</span>F<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ <a href="#17330" title="scalaz.Adjunction.-|[[α]P[F[α]],[α]G[Q[α]]]">-|</a> <span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = G<span class="delimiter">[</span>Q<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A](a: =&gt; A)G[Q[P[F[A]]]]" id="76157">unit</a><span class="delimiter">[</span><a title="" id="76159">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="76166">a</a>: =&gt; A<span class="delimiter">)</span>: <a href="#22822" title="G[Q[P[F[A]]]]">G</a><span class="delimiter">[</span>Q<span class="delimiter">[</span>P<span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#17330" title="Adjunction.this.type">self</a>.<a href="#75399" title="=&gt; scalaz.Functor[G]">G</a>.<a href="Functor.scala.html#33415" title="(fa: G[F[A]])(f: F[A] =&gt; Q[P[F[A]]])G[Q[P[F[A]]]]">map</a><span class="delimiter">(</span><a href="#17330" title="Adjunction.this.type">self</a>.<a href="#75320" title="(a: =&gt; A)G[F[A]]">unit</a><span class="delimiter">(</span><a href="#76166" title="=&gt; A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="F[A]" id="76239">x</a> =&gt; <a href="#76109" title="scalaz.Adjunction.-|[P,Q]">A</a>.<a href="#75320" title="(a: =&gt; F[A])Q[P[F[A]]]">unit</a><span class="delimiter">(</span><a href="#76239" title="F[A]">x</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A](a: P[F[G[Q[A]]]])A" id="76160">counit</a><span class="delimiter">[</span><a title="" id="76162">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="P[F[G[Q[A]]]]" id="76171">a</a>: <a href="#75350" title="P[F[G[Q[A]]]]">P</a><span class="delimiter">[</span>F<span class="delimiter">[</span>G<span class="delimiter">[</span>Q<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#76162" title="A">A</a> = <a href="#76109" title="scalaz.Adjunction.-|[P,Q]">A</a>.<a href="#75323" title="(a: P[Q[A]])A">counit</a><span class="delimiter">(</span><a href="#76129" title="scalaz.Functor[P]">P</a>.<a href="Functor.scala.html#33415" title="(fa: P[F[G[Q[A]]]])(f: F[G[Q[A]]] =&gt; Q[A])P[Q[A]]">map</a><span class="delimiter">(</span><a href="#76171" title="P[F[G[Q[A]]]]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#17330" title="Adjunction.this.type">self</a>.<a href="#75323" title="(a: F[G[Q[A]]])Q[A]">counit</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="scalaz.Adjunction.type" id="17331">Adjunction</a> <a href="#17332" title="scalaz.Adjunction.type" class="keyword">extends</a> <a href="#14072" title="scalaz.AdjunctionInstances">AdjunctionInstances</a> <span class="keyword">with</span> <a href="#9398" title="scalaz.AdjunctionFunctions">AdjunctionFunctions</a>

<span class="keyword">trait</span> <a title="trait AdjunctionFunctions extends AnyRef" id="9398">AdjunctionFunctions</a> <span title="Unit" class="delimiter">{</span>

  <span class="keyword">type</span> <a title="[F[_], G[_]]scalaz.Adjunction[F,G]" id="76101">-|</a><span class="delimiter">[</span><a title="[_]" id="76102">F</a><span class="delimiter">[</span><a title="" id="76123">_</a><span class="delimiter">]</span>, <a title="[_]" id="76103">G</a><span class="delimiter">[</span><a title="" id="76124">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#17330" title="scalaz.Adjunction[F,G]">Adjunction</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span>

  <span class="keyword">def</span> <a title="[F[_], G[_]](implicit A: AdjunctionFunctions.this.-|[F,G], implicit F: scalaz.Functor[F], implicit G: scalaz.Functor[F])AdjunctionFunctions.this.-|[F,G]" id="76104">apply</a><span class="delimiter">[</span><a title="[_]" id="76107">F</a><span class="delimiter">[</span><a title="" id="76288">_</a><span class="delimiter">]</span>, <a title="[_]" id="76108">G</a><span class="delimiter">[</span><a title="" id="76289">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="AdjunctionFunctions.this.-|[F,G]" id="76285">A</a>: F <a href="#17330" title="AdjunctionFunctions.this.-|[F,G]">-|</a> G, <a title="scalaz.Functor[F]" id="76286">F</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span>, <a title="scalaz.Functor[F]" id="76287">G</a>: <a href="Functor.scala.html#14144" title="scalaz.Functor[F]">Functor</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: F <a href="#17330" title="AdjunctionFunctions.this.-|[F,G]">-|</a> G = <a href="#76285" title="AdjunctionFunctions.this.-|[F,G]">A</a>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">trait</span> <a title="trait AdjunctionInstances extends AnyRef" id="14072">AdjunctionInstances</a> <span title="Unit" class="delimiter">{</span>
  <span class="keyword">import</span> <a href="#17331" title="scalaz.Adjunction.type">Adjunction</a>.-|

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[F[_], P[_], G[_], Q[_]](implicit A1: scalaz.Adjunction.-|[F,G], implicit A2: scalaz.Adjunction.-|[P,Q])scalaz.Adjunction.-|[[α]P[F[α]],[α]G[Q[α]]]" id="76075">compositeAdjunction</a><span class="delimiter">[</span><a title="[_]" id="76080">F</a><span class="delimiter">[</span><a title="" id="76301">_</a><span class="delimiter">]</span>, <a title="[_]" id="76081">P</a><span class="delimiter">[</span><a title="" id="76300">_</a><span class="delimiter">]</span>, <a title="[_]" id="76082">G</a><span class="delimiter">[</span><a title="" id="76307">_</a><span class="delimiter">]</span>, <a title="[_]" id="76083">Q</a><span class="delimiter">[</span><a title="" id="76308">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Adjunction.-|[F,G]" id="76295">A1</a>: F <a href="#17330" title="scalaz.Adjunction.-|[F,G]">-|</a> G, <a title="scalaz.Adjunction.-|[P,Q]" id="76296">A2</a>: P <a href="#17330" title="scalaz.Adjunction.-|[P,Q]">-|</a> Q<span class="delimiter">)</span>: <span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = P<span class="delimiter">[</span>F<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ <a href="#17330" title="scalaz.Adjunction.-|[[α]P[F[α]],[α]G[Q[α]]]">-|</a> <span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = G<span class="delimiter">[</span>Q<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ =
    <a href="#76295" title="scalaz.Adjunction.-|[F,G]">A1</a> <a href="#75347" title="(implicit A: scalaz.Adjunction.-|[P,Q])scalaz.Adjunction.-|[[α]P[F[α]],[α]G[Q[α]]]">compose</a> <a href="#76296" title="scalaz.Adjunction.-|[P,Q]">A2</a>

  <span class="keyword">import</span> std.<a href="std/AllInstances.scala.html#25532" title="scalaz.std.AllInstances.type">AllInstances</a>._

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S]=&gt; scalaz.Adjunction.-|[[α](S, α),[α]S =&gt; α]" id="76085">curryUncurryAdjunction</a><span class="delimiter">[</span><a title="" id="76087">S</a><span class="delimiter">]</span>: <span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = <span class="delimiter">(</span>S, α<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ <a href="#17330" title="scalaz.Adjunction.-|[[α](S, α),[α]S =&gt; α]">-|</a> <span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = S =&gt; α<span class="delimiter">}</span><span class="delimiter">)</span>#λ =
    <a href="#76359" title="scalaz.Adjunction[[α](S, α),[α]S =&gt; α]" class="keyword">new</a> <a title="anonymous class $anon extends scalaz.Adjunction[[α](S, α),[α]S =&gt; α]" id="76359">Adjunction</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = <span class="delimiter">(</span>S, α<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ, <span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = S =&gt; α<span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](a: =&gt; A)(f: ((S, A)) =&gt; B)S =&gt; B" id="76371">leftAdjunct</a><span class="delimiter">[</span><a title="" id="76374">A</a>, <a title="" id="76375">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="76384">a</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="((S, A)) =&gt; B" id="76385">f</a>: <span class="delimiter">(</span><span class="delimiter">(</span>S, A<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: S =&gt; B = <a title="S" id="107588">s</a> =&gt; <a href="#76385" title="(v1: (S, A))B">f</a><span title="(_1: S, _2: A)(S, A)" class="delimiter">(</span><a href="#107588" title="S">s</a>, <a href="#76384" title="=&gt; A">a</a><span class="delimiter">)</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](a: (S, A))(f: A =&gt; (S =&gt; B))B" id="76376">rightAdjunct</a><span class="delimiter">[</span><a title="" id="76379">A</a>, <a title="" id="76380">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(S, A)" id="76395">a</a>: <span title="(S, A)" class="delimiter">(</span>S, A<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; (S =&gt; B)" id="76396">f</a>: A =&gt; S =&gt; B<span class="delimiter">)</span>: <a href="#76380" title="B">B</a> = <a href="#76396" title="(v1: A)S =&gt; B">f</a><span title="(v1: S)B" class="delimiter">(</span><a href="#76395" title="(S, A)">a</a>.<span title="=&gt; A">_2</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#76395" title="(S, A)">a</a>.<span title="=&gt; S">_1</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Adjunction.-|[scalaz.Id.Id,scalaz.Id.Id]" id="76088">identityAdjunction</a>: Id <a href="#17330" title="scalaz.Adjunction.-|[scalaz.Id.Id,scalaz.Id.Id]">-|</a> Id = <a href="#107614" title="scalaz.Adjunction[scalaz.Id.Id,scalaz.Id.Id]" class="keyword">new</a> <a title="anonymous class $anon extends scalaz.Adjunction[scalaz.Id.Id,scalaz.Id.Id]" id="107614">Adjunction</a><span class="delimiter">[</span>Id, Id<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](a: =&gt; A)(f: A =&gt; B)B" id="107616">leftAdjunct</a><span class="delimiter">[</span><a title="" id="107619">A</a>, <a title="" id="107620">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="107629">a</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="107630">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#107620" title="B">B</a> = <a href="#107630" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#107629" title="=&gt; A">a</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](a: A)(f: A =&gt; B)B" id="107621">rightAdjunct</a><span class="delimiter">[</span><a title="" id="107624">A</a>, <a title="" id="107625">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="107640">a</a>: <a href="#107624" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="107641">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#107625" title="B">B</a> = <a href="#107641" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#107640" title="A">a</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Adjunction.-|[Function0,Function0]" id="76090">f0Adjunction</a>: Function0 <a href="#17330" title="scalaz.Adjunction.-|[Function0,Function0]">-|</a> Function0 = <a href="#108475" title="scalaz.Adjunction[Function0,Function0]" class="keyword">new</a> <a title="anonymous class $anon extends scalaz.Adjunction[Function0,Function0]" id="108475">Adjunction</a><span class="delimiter">[</span>Function0, Function0<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](a: =&gt; A)(f: (() =&gt; A) =&gt; B)() =&gt; B" id="108477">leftAdjunct</a><span class="delimiter">[</span><a title="" id="108480">A</a>, <a title="" id="108481">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="108490">a</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="(() =&gt; A) =&gt; B" id="108491">f</a>: <span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; B = <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#108491" title="(v1: () =&gt; A)B">f</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#108490" title="=&gt; A">a</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](a: () =&gt; A)(f: A =&gt; (() =&gt; B))B" id="108482">rightAdjunct</a><span class="delimiter">[</span><a title="" id="108485">A</a>, <a title="" id="108486">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="() =&gt; A" id="108501">a</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; (() =&gt; B)" id="108502">f</a>: A =&gt; <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#108486" title="B">B</a> = <a href="#108502" title="(v1: A)() =&gt; B">f</a><span title="()B" class="delimiter">(</span><a href="#108501" title="()A">a</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Adjunction.-|[scalaz.Id.Id,Function0]" id="76092">idF0Adjunction</a>: Id <a href="#17330" title="scalaz.Adjunction.-|[scalaz.Id.Id,Function0]">-|</a> Function0 = <a href="#109340" title="scalaz.Adjunction[scalaz.Id.Id,Function0]" class="keyword">new</a> <a title="anonymous class $anon extends scalaz.Adjunction[scalaz.Id.Id,Function0]" id="109340">Adjunction</a><span class="delimiter">[</span>Id, Function0<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](a: =&gt; A)(f: A =&gt; B)() =&gt; B" id="109342">leftAdjunct</a><span class="delimiter">[</span><a title="" id="109345">A</a>, <a title="" id="109346">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="109355">a</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="109356">f</a>: A =&gt; B<span class="delimiter">)</span>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; B = <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#109356" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#109355" title="=&gt; A">a</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](a: A)(f: A =&gt; (() =&gt; B))B" id="109347">rightAdjunct</a><span class="delimiter">[</span><a title="" id="109350">A</a>, <a title="" id="109351">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="109366">a</a>: <a href="#109350" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; (() =&gt; B)" id="109367">f</a>: A =&gt; <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#109351" title="B">B</a> = <a href="#109367" title="(v1: A)() =&gt; B">f</a><span title="()B" class="delimiter">(</span><a href="#109366" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Adjunction.-|[Function0,scalaz.Id.Id]" id="76094">f0IdAdjunction</a>: Function0 <a href="#17330" title="scalaz.Adjunction.-|[Function0,scalaz.Id.Id]">-|</a> Id = <a href="#110203" title="scalaz.Adjunction[Function0,scalaz.Id.Id]" class="keyword">new</a> <a title="anonymous class $anon extends scalaz.Adjunction[Function0,scalaz.Id.Id]" id="110203">Adjunction</a><span class="delimiter">[</span>Function0, Id<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](a: =&gt; A)(f: (() =&gt; A) =&gt; B)B" id="110205">leftAdjunct</a><span class="delimiter">[</span><a title="" id="110208">A</a>, <a title="" id="110209">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="110218">a</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="(() =&gt; A) =&gt; B" id="110219">f</a>: <span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#110209" title="B">B</a> = <a href="#110219" title="(v1: () =&gt; A)B">f</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#110218" title="=&gt; A">a</a><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](a: () =&gt; A)(f: A =&gt; B)B" id="110210">rightAdjunct</a><span class="delimiter">[</span><a title="" id="110213">A</a>, <a title="" id="110214">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="() =&gt; A" id="110229">a</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="110230">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#110214" title="B">B</a> = <a href="#110230" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#110229" title="()A">a</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[E]=&gt; scalaz.Adjunction[[α]scalaz.WriterT[[+X]X,E,α],[α]scalaz.Kleisli[[+X]X,E,α]]" id="76096">writerReaderAdjunction</a><span class="delimiter">[</span><a title="" id="76098">E</a><span class="delimiter">]</span>: <a href="#17330" title="scalaz.Adjunction[[α]scalaz.WriterT[[+X]X,E,α],[α]scalaz.Kleisli[[+X]X,E,α]]">Adjunction</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = Writer<span class="delimiter">[</span>E, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ, <span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = Reader<span class="delimiter">[</span>E, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#111070" title="scalaz.Adjunction[[α]scalaz.WriterT[[+X]X,E,α],[α]scalaz.Kleisli[[+X]X,E,α]]" class="keyword">new</a> <a title="anonymous class $anon extends scalaz.Adjunction[[α]scalaz.WriterT[[+X]X,E,α],[α]scalaz.Kleisli[[+X]X,E,α]]" id="111070">Adjunction</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = Writer<span class="delimiter">[</span>E, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ, <span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = Reader<span class="delimiter">[</span>E, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](a: =&gt; A)(f: scalaz.Writer[E,A] =&gt; B)scalaz.Reader[E,B]" id="111082">leftAdjunct</a><span class="delimiter">[</span><a title="" id="111085">A</a>, <a title="" id="111086">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="111095">a</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Writer[E,A] =&gt; B" id="111096">f</a>: Writer<span class="delimiter">[</span>E, A<span class="delimiter">]</span> =&gt; B<span class="delimiter">)</span>: <a href="Kleisli.scala.html#13760" title="scalaz.Reader[E,B]">Reader</a><span class="delimiter">[</span>E, B<span class="delimiter">]</span> =
      <a href="package.scala.html#114040" title="(f: E =&gt; B)scalaz.Reader[E,B]">Reader</a><span class="delimiter">(</span><a title="E" id="114051">e</a> =&gt; <a href="#111096" title="(v1: scalaz.Writer[E,A])B">f</a><span class="delimiter">(</span><a href="package.scala.html#114054" title="(w: E, a: A)scalaz.WriterT[scalaz.Id.Id,E,A]">Writer</a><span class="delimiter">(</span><a href="#114051" title="E">e</a>, <a href="#111095" title="=&gt; A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](w: scalaz.Writer[E,A])(f: A =&gt; scalaz.Reader[E,B])B" id="111087">rightAdjunct</a><span class="delimiter">[</span><a title="" id="111090">A</a>, <a title="" id="111091">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Writer[E,A]" id="111106">w</a>: <a href="WriterT.scala.html#11144" title="scalaz.Writer[E,A]">Writer</a><span class="delimiter">[</span>E, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Reader[E,B]" id="111107">f</a>: A =&gt; Reader<span class="delimiter">[</span>E, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#111091" title="B">B</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a href="#1674972" title="(x: (E, A))(E, A)" class="delimiter">(</a><a href="#1674970" title="E" id="114075">e</a>, <a href="#1674970" title="A" id="114076">a</a><span class="delimiter">)</span> = <a href="#111106" title="scalaz.Writer[E,A]">w</a>.<a href="WriterT.scala.html#111128" title="=&gt; (E, A)">run</a>
      <a href="#111107" title="(v1: A)scalaz.Reader[E,B]">f</a><a href="Kleisli.scala.html#44350" title="(v1: E)scalaz.Id.Id[B]" class="delimiter">(</a><a href="#114076" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#114075" title="E">e</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>