<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/Foldable.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz

////
/**
 * A type parameter implying the ability to extract zero or more
 * values of that type.
 */
////
<span class="keyword">trait</span> <a title="trait Foldable[F[_]] extends AnyRef" id="17390">Foldable</a><span class="delimiter">[</span><a title="[_]" id="23135">F</a><span class="delimiter">[</span><a title="" id="279970">_</a><span class="delimiter">]</span><span class="delimiter">]</span>  <span title="Unit" class="delimiter">{</span> self =&gt;
  ////
  /** Map each element of the structure to a [[scalaz.Monoid]], and combine the results. */
  <span class="keyword">def</span> <a title="[A, B](fa: F[A])(f: A =&gt; B)(implicit F: scalaz.Monoid[B])B" id="33665">foldMap</a><span class="delimiter">[</span><a title="" id="33668">A</a>,<a title="" id="33669">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="51310">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="51311">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monoid[B]" id="51312">F</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[B]">Monoid</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33669" title="B">B</a>

  /**Right-associative fold of a structure. */
  <span class="keyword">def</span> <a title="[A, B](fa: F[A], z: =&gt; B)(f: (A, =&gt; B) =&gt; B)B" id="33670">foldRight</a><span class="delimiter">[</span><a title="" id="33673">A</a>, <a title="" id="33674">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="51279">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="=&gt; B" id="51280">z</a>: =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, =&gt; B) =&gt; B" id="51281">f</a>: <span class="delimiter">(</span>A, =&gt; B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#33674" title="B">B</a>

  /**The composition of Foldables `F` and `G`, `[x]F[G[x]]`, is a Foldable */
  <span class="keyword">def</span> <a title="[G[_]](implicit G0: scalaz.Foldable[G])scalaz.Foldable[[α]F[G[α]]]" id="33675">compose</a><span class="delimiter">[</span><a title="[_]" id="33677">G</a><span class="delimiter">[</span><a title="" id="141744">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Foldable[G]" id="141740">G0</a>: <a href="#17390" title="scalaz.Foldable[G]">Foldable</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#17390" title="scalaz.Foldable[[α]F[G[α]]]">Foldable</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = F<span class="delimiter">[</span>G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#279995" title="scalaz.CompositionFoldable[F,G]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.CompositionFoldable[F,G]" id="279995">CompositionFoldable</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Foldable[F]" id="279997">F</a> = <a href="#17390" title="scalaz.Foldable[F]">self</a>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Foldable[G]" id="279998">G</a> = <a href="#141740" title="scalaz.Foldable[G]">G0</a>
  <span class="delimiter">}</span>

  /**The product of Foldables `F` and `G`, `[x](F[x], G[x]])`, is a Foldable */
  <span class="keyword">def</span> <a title="[G[_]](implicit G0: scalaz.Foldable[G])scalaz.Foldable[[α](F[α], G[α])]" id="33678">product</a><span class="delimiter">[</span><a title="[_]" id="33680">G</a><span class="delimiter">[</span><a title="" id="141720">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Foldable[G]" id="141716">G0</a>: <a href="#17390" title="scalaz.Foldable[G]">Foldable</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#17390" title="scalaz.Foldable[[α](F[α], G[α])]">Foldable</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span> = <span class="delimiter">(</span>F<span class="delimiter">[</span>α<span class="delimiter">]</span>, G<span class="delimiter">[</span>α<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#λ<span class="delimiter">]</span> = <a href="#280014" title="scalaz.ProductFoldable[F,G]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.ProductFoldable[F,G]" id="280014">ProductFoldable</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Foldable[F]" id="280039">F</a> = <a href="#17390" title="scalaz.Foldable[F]">self</a>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Foldable[G]" id="280040">G</a> = <a href="#141716" title="scalaz.Foldable[G]">G0</a>
  <span class="delimiter">}</span>

  /**Left-associative fold of a structure. */
  <span class="keyword">def</span> <a title="[A, B](fa: F[A], z: B)(f: (B, A) =&gt; B)B" id="33681">foldLeft</a><span class="delimiter">[</span><a title="" id="33684">A</a>, <a title="" id="33685">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="69996">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="B" id="69997">z</a>: <a href="#33685" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, A) =&gt; B" id="69998">f</a>: <span class="delimiter">(</span>B, A<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#33685" title="B">B</a> = <span class="delimiter">{</span>
    <span class="keyword">import</span> <a href="Dual.scala.html#12198" title="scalaz.Dual.type">Dual</a>._, <a href="Endo.scala.html#10845" title="scalaz.Endo.type">Endo</a>._, syntax.std.<a href="syntax/std/package.scala.html#31039" title="scalaz.syntax.std.all.type">all</a>._
    <a href="#33665" title="(fa: F[A])(f: A =&gt; scalaz.@@[scalaz.Endo[B],scalaz.Tags.Dual])(implicit F: scalaz.Monoid[scalaz.@@[scalaz.Endo[B],scalaz.Tags.Dual]])scalaz.@@[scalaz.Endo[B],scalaz.Tags.Dual]">foldMap</a><span class="delimiter">(</span><a href="#69996" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span>a: <a href="#33684" title="A">A</a><span class="delimiter">)</span> =&gt; <a href="Dual.scala.html#123004" title="(a: scalaz.Endo[B])scalaz.@@[scalaz.Endo[B],scalaz.Tags.Dual]">Dual</a><span class="delimiter">(</span><a href="Endo.scala.html#10845" title="scalaz.Endo.type">Endo</a>.<a href="Endo.scala.html#51344" title="(f: B =&gt; B)scalaz.Endo[B]">endo</a><span class="delimiter">(</span><a href="syntax/std/Function2Ops.scala.html#46941" title="(f: (B, A) =&gt; B)scalaz.syntax.std.Function2Ops[B,A,B]{val self: (B, A) =&gt; B}">f</a>.<a href="syntax/std/Function2Ops.scala.html#104220" title="=&gt; (A, B) =&gt; B">flip</a>.<span title="(v1: A)B =&gt; B">curried</span><span class="delimiter">(</span><a href="#280074" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="Dual.scala.html#122997" title="(implicit F0: scalaz.Monoid[scalaz.Endo[B]])scalaz.DualMonoid[scalaz.Endo[B]]">dualMonoid</a><span class="delimiter">)</span> <a href="Endo.scala.html#51379" title="(a: B)B">apply</a> <span class="delimiter">(</span><a href="#69997" title="B">z</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  /**Right-associative, monadic fold of a structure. */
  <span class="keyword">def</span> <a title="[G[_], A, B](fa: F[A], z: =&gt; B)(f: (A, =&gt; B) =&gt; G[B])(implicit M: scalaz.Monad[G])G[B]" id="33686">foldRightM</a><span class="delimiter">[</span><a title="[_]" id="33690">G</a><span class="delimiter">[</span><a title="" id="280163">_</a><span class="delimiter">]</span>, <a title="" id="33691">A</a>, <a title="" id="33692">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280159">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="=&gt; B" id="280160">z</a>: =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, =&gt; B) =&gt; G[B]" id="280161">f</a>: <span class="delimiter">(</span>A, =&gt; B<span class="delimiter">)</span> =&gt; G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monad[G]" id="280162">M</a>: <a href="Monad.scala.html#15566" title="scalaz.Monad[G]">Monad</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33690" title="G[B]">G</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
    <a href="#33681" title="[A, B](fa: F[A], z: B)(f: (B, A) =&gt; B)B">foldLeft</a><span title="(fa: F[A], z: B =&gt; G[B])(f: (B =&gt; G[B], A) =&gt; B =&gt; G[B])B =&gt; G[B]" class="delimiter">[</span><a href="#33691" title="A">A</a>, B =&gt; G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#280159" title="F[A]">fa</a>, <a href="#280162" title="scalaz.Monad[G]">M</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; B)G[B]">point</a><span class="delimiter">(</span><a href="#280172" title="B">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span title="(v1: B)G[B]" class="delimiter">(</span><span class="delimiter">(</span><a title="B =&gt; G[B]" id="280177">b</a>, <a title="A" id="280178">a</a><span class="delimiter">)</span> =&gt; <a title="B" id="280180">w</a> =&gt; <a href="#280162" title="scalaz.Monad[G]">M</a>.<a href="Bind.scala.html#34574" title="(fa: G[B])(f: B =&gt; G[B])G[B]">bind</a><span class="delimiter">(</span><a href="#280161" title="(v1: A, v2: =&gt; B)G[B]">f</a><span class="delimiter">(</span><a href="#280178" title="A">a</a>, <a href="#280180" title="B">w</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#280177" title="B =&gt; G[B]">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#280160" title="=&gt; B">z</a><span class="delimiter">)</span>

  /**Left-associative, monadic fold of a structure. */
  <span class="keyword">def</span> <a title="[G[_], A, B](fa: F[A], z: B)(f: (B, A) =&gt; G[B])(implicit M: scalaz.Monad[G])G[B]" id="33693">foldLeftM</a><span class="delimiter">[</span><a title="[_]" id="33697">G</a><span class="delimiter">[</span><a title="" id="280200">_</a><span class="delimiter">]</span>, <a title="" id="33698">A</a>, <a title="" id="33699">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280196">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="B" id="280197">z</a>: <a href="#33699" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, A) =&gt; G[B]" id="280198">f</a>: <span class="delimiter">(</span>B, A<span class="delimiter">)</span> =&gt; G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monad[G]" id="280199">M</a>: <a href="Monad.scala.html#15566" title="scalaz.Monad[G]">Monad</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33697" title="G[B]">G</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
    <a href="#33670" title="[A, B](fa: F[A], z: =&gt; B)(f: (A, =&gt; B) =&gt; B)B">foldRight</a><span title="(fa: F[A], z: =&gt; B =&gt; G[B])(f: (A, =&gt; B =&gt; G[B]) =&gt; B =&gt; G[B])B =&gt; G[B]" class="delimiter">[</span><a href="#33698" title="A">A</a>, B =&gt; G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#280196" title="F[A]">fa</a>, <a href="#280199" title="scalaz.Monad[G]">M</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; B)G[B]">point</a><span class="delimiter">(</span><a href="#280209" title="B">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span title="(v1: B)G[B]" class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="280214">a</a>, <a title="=&gt; B =&gt; G[B]" id="280215">b</a><span class="delimiter">)</span> =&gt; <a title="B" id="280217">w</a> =&gt; <a href="#280199" title="scalaz.Monad[G]">M</a>.<a href="Bind.scala.html#34574" title="(fa: G[B])(f: B =&gt; G[B])G[B]">bind</a><span class="delimiter">(</span><a href="#280198" title="(v1: B, v2: A)G[B]">f</a><span class="delimiter">(</span><a href="#280217" title="B">w</a>, <a href="#280214" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#280215" title="=&gt; B =&gt; G[B]">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#280197" title="B">z</a><span class="delimiter">)</span>
  
  /** Combine the elements of a structure using a monoid. */
  <span class="keyword">def</span> <a title="[M](t: F[M])(implicit evidence$1: scalaz.Monoid[M])M" id="280234">fold</a><span class="delimiter">[</span><a title="" id="33702">M</a>: Monoid<span class="delimiter">]</span><span class="delimiter">(</span><a title="F[M]" id="280233">t</a>: <a href="#23135" title="F[M]">F</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33702" title="M">M</a> = <a href="#33665" title="[A, B](fa: F[A])(f: A =&gt; B)(implicit F: scalaz.Monoid[B])B">foldMap</a><span title="(fa: F[M])(f: M =&gt; M)(implicit F: scalaz.Monoid[M])M" class="delimiter">[</span><a href="#33702" title="M">M</a>, <a href="#33702" title="M">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#280233" title="F[M]">t</a><span class="delimiter">)</span><a href="#280234" title="scalaz.Monoid[M]" class="delimiter">(</a><a title="M" id="280241">x</a> =&gt; <a href="#280241" title="M">x</a><span class="delimiter">)</span>

  /** Strict traversal in an applicative functor `M` that ignores the result of `f`. */  
  <span class="keyword">def</span> <a title="[M[_], A, B](fa: F[A])(f: A =&gt; M[B])(implicit a: scalaz.Applicative[M])M[Unit]" id="33703">traverse_</a><span class="delimiter">[</span><a title="[_]" id="33707">M</a><span class="delimiter">[</span><a title="" id="280245">_</a><span class="delimiter">]</span>, <a title="" id="33708">A</a>, <a title="" id="33709">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280242">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; M[B]" id="280243">f</a>: A =&gt; M<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[M]" id="280244">a</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[M]">Applicative</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33707" title="M[Unit]">M</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> =
    <a href="#33681" title="(fa: F[A], z: M[Unit])(f: (M[Unit], A) =&gt; M[Unit])M[Unit]">foldLeft</a><span class="delimiter">(</span><a href="#280242" title="F[A]">fa</a>, <a href="#280244" title="scalaz.Applicative[M]">a</a>.<a href="Applicative.scala.html#34513" title="(a: =&gt; Unit)M[Unit]">pure</a><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="M[Unit]" id="280263">x</a>, <a title="A" id="280264">y</a><span class="delimiter">)</span> =&gt; <a href="#280244" title="scalaz.Applicative[M]">a</a>.<a href="Apply.scala.html#33953" title="(fa: =&gt; M[B])(f: =&gt; M[B =&gt; Unit])M[Unit]">ap</a><span class="delimiter">(</span><a href="#280243" title="(v1: A)M[B]">f</a><span class="delimiter">(</span><a href="#280264" title="A">y</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#280244" title="scalaz.Applicative[M]">a</a>.<a href="Applicative.scala.html#34516" title="(fa: M[Unit])(f: Unit =&gt; (B =&gt; Unit))M[B =&gt; Unit]">map</a><span class="delimiter">(</span><a href="#280263" title="M[Unit]">x</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Unit" id="280289">_</a> =&gt; <a title="B" id="280291">_</a> =&gt; <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** `traverse_` specialized to `State` **/
  <span class="keyword">def</span> <a title="[S, A, B](fa: F[A])(f: A =&gt; scalaz.State[S,B])scalaz.State[S,Unit]" id="33710">traverseS_</a><span class="delimiter">[</span><a title="" id="33714">S</a>, <a title="" id="33715">A</a>, <a title="" id="33716">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280296">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.State[S,B]" id="280297">f</a>: A =&gt; State<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="StateT.scala.html#20021" title="scalaz.State[S,Unit]">State</a><span class="delimiter">[</span>S, Unit<span class="delimiter">]</span> =
    <a href="#33703" title="[M[_], A, B](fa: F[A])(f: A =&gt; M[B])(implicit a: scalaz.Applicative[M])M[Unit]">traverse_</a><span title="(fa: F[A])(f: A =&gt; scalaz.IndexedStateT[[+X]X,S,S,B])(implicit a: scalaz.Applicative[[α]scalaz.IndexedStateT[[+X]X,S,S,α]])scalaz.IndexedStateT[[+X]X,S,S,Unit]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> λ<span class="delimiter">[</span>α<span class="delimiter">]</span>=State<span class="delimiter">[</span>S, α<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#<a href="StateT.scala.html#20021" title="[α]scalaz.IndexedStateT[[+X]X,S,S,α]">λ</a>, <a href="#33715" title="A">A</a>, <a href="#33716" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#280296" title="F[A]">fa</a><span class="delimiter">)</span><a href="StateT.scala.html#142094" title="scalaz.MonadState[[s, +a]scalaz.IndexedStateT[[+X]X,s,s,a],S]" class="delimiter">(</a><a href="#280297" title="A =&gt; scalaz.State[S,B]">f</a><span class="delimiter">)</span>

  /** Strict sequencing in an applicative functor `M` that ignores the value in `fa`. */
  <span class="keyword">def</span> <a title="[M[_], A, B](fa: F[M[A]])(implicit a: scalaz.Applicative[M])M[Unit]" id="33717">sequence_</a><span class="delimiter">[</span><a title="[_]" id="33721">M</a><span class="delimiter">[</span><a title="" id="115692">_</a><span class="delimiter">]</span>, <a title="" id="33722">A</a>, <a title="" id="33723">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[M[A]]" id="115690">fa</a>: <a href="#23135" title="F[M[A]]">F</a><span class="delimiter">[</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[M]" id="115691">a</a>: <a href="Applicative.scala.html#15416" title="scalaz.Applicative[M]">Applicative</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33721" title="M[Unit]">M</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> =
    <a href="#33703" title="(fa: F[M[A]])(f: M[A] =&gt; M[A])(implicit a: scalaz.Applicative[M])M[Unit]">traverse_</a><span class="delimiter">(</span><a href="#115690" title="F[M[A]]">fa</a><span class="delimiter">)</span><a href="#115691" title="scalaz.Applicative[M]" class="delimiter">(</a><a title="M[A]" id="280425">x</a> =&gt; <a href="#280425" title="M[A]">x</a><span class="delimiter">)</span>

  /** `sequence_` specialized to `State` **/
  <span class="keyword">def</span> <a title="[S, A](fga: F[scalaz.State[S,A]])scalaz.State[S,Unit]" id="33724">sequenceS_</a><span class="delimiter">[</span><a title="" id="33727">S</a>, <a title="" id="33728">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[scalaz.State[S,A]]" id="280432">fga</a>: <a href="#23135" title="F[scalaz.State[S,A]]">F</a><span class="delimiter">[</span>State<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="StateT.scala.html#20021" title="scalaz.State[S,Unit]">State</a><span class="delimiter">[</span>S, Unit<span class="delimiter">]</span> =
    <a href="#33710" title="(fa: F[scalaz.State[S,A]])(f: scalaz.State[S,A] =&gt; scalaz.State[S,A])scalaz.State[S,Unit]">traverseS_</a><span class="delimiter">(</span><a href="#280432" title="F[scalaz.State[S,A]]">fga</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.State[S,A]" id="280444">x</a> =&gt; <a href="#280444" title="scalaz.State[S,A]">x</a><span class="delimiter">)</span>

  /**Curried version of `foldRight` */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[A, B](fa: F[A], z: =&gt; B)(f: A =&gt; ((=&gt; B) =&gt; B))B" id="33729">foldr</a><span class="delimiter">[</span><a title="" id="33732">A</a>, <a title="" id="33733">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280447">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="=&gt; B" id="280448">z</a>: =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; ((=&gt; B) =&gt; B)" id="280449">f</a>: A =&gt; <span class="delimiter">(</span>=&gt; B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span>: <a href="#33733" title="B">B</a> = <a href="#33670" title="(fa: F[A], z: =&gt; B)(f: (A, =&gt; B) =&gt; B)B">foldRight</a><span class="delimiter">(</span><a href="#280447" title="F[A]">fa</a>, <a href="#280448" title="=&gt; B">z</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="280464">a</a>, <a title="=&gt; B" id="280465">b</a><span class="delimiter">)</span> =&gt; <a href="#280449" title="(v1: A)(=&gt; B) =&gt; B">f</a><span title="(v1: =&gt; B)B" class="delimiter">(</span><a href="#280464" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#280465" title="=&gt; B">b</a><span class="delimiter">)</span><span class="delimiter">)</span>

  /**Curred version of `foldLeft` */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[A, B](fa: F[A], z: B)(f: B =&gt; (A =&gt; B))B" id="33734">foldl</a><span class="delimiter">[</span><a title="" id="33737">A</a>, <a title="" id="33738">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280468">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="B" id="280469">z</a>: <a href="#33738" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; (A =&gt; B)" id="280470">f</a>: B =&gt; A =&gt; B<span class="delimiter">)</span> = <a href="#33681" title="(fa: F[A], z: B)(f: (B, A) =&gt; B)B">foldLeft</a><span class="delimiter">(</span><a href="#280468" title="F[A]">fa</a>, <a href="#280469" title="B">z</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="B" id="280482">b</a>, <a title="A" id="280483">a</a><span class="delimiter">)</span> =&gt; <a href="#280470" title="(v1: B)A =&gt; B">f</a><span title="(v1: A)B" class="delimiter">(</span><a href="#280482" title="B">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#280483" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>

  /**Curried version of `foldRightM` */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[G[_], A, B](fa: F[A], z: =&gt; B)(f: A =&gt; ((=&gt; B) =&gt; G[B]))(implicit M: scalaz.Monad[G])G[B]" id="33739">foldrM</a><span class="delimiter">[</span><a title="[_]" id="33743">G</a><span class="delimiter">[</span><a title="" id="280493">_</a><span class="delimiter">]</span>, <a title="" id="33744">A</a>, <a title="" id="33745">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280489">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="=&gt; B" id="280490">z</a>: =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; ((=&gt; B) =&gt; G[B])" id="280491">f</a>: A =&gt; <span class="delimiter">(</span> =&gt; B<span class="delimiter">)</span> =&gt; G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monad[G]" id="280492">M</a>: <a href="Monad.scala.html#15566" title="scalaz.Monad[G]">Monad</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33743" title="G[B]">G</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = 
    <a href="#33686" title="(fa: F[A], z: =&gt; B)(f: (A, =&gt; B) =&gt; G[B])(implicit M: scalaz.Monad[G])G[B]">foldRightM</a><span class="delimiter">(</span><a href="#280489" title="F[A]">fa</a>, <a href="#280490" title="=&gt; B">z</a><span class="delimiter">)</span><a href="#280492" title="scalaz.Monad[G]" class="delimiter">(</a><span class="delimiter">(</span><a title="A" id="280515">a</a>, <a title="=&gt; B" id="280516">b</a><span class="delimiter">)</span> =&gt; <a href="#280491" title="(v1: A)(=&gt; B) =&gt; G[B]">f</a><span title="(v1: =&gt; B)G[B]" class="delimiter">(</span><a href="#280515" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#280516" title="=&gt; B">b</a><span class="delimiter">)</span><span class="delimiter">)</span>

  /**Curried version of `foldLeftM` */
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[G[_], A, B](fa: F[A], z: =&gt; B)(f: B =&gt; (A =&gt; G[B]))(implicit M: scalaz.Monad[G])G[B]" id="33746">foldlM</a><span class="delimiter">[</span><a title="[_]" id="33750">G</a><span class="delimiter">[</span><a title="" id="280529">_</a><span class="delimiter">]</span>, <a title="" id="33751">A</a>, <a title="" id="33752">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280525">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="=&gt; B" id="280526">z</a>: =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><a title="B =&gt; (A =&gt; G[B])" id="280527">f</a>: B =&gt; A =&gt; G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monad[G]" id="280528">M</a>: <a href="Monad.scala.html#15566" title="scalaz.Monad[G]">Monad</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33750" title="G[B]">G</a><span class="delimiter">[</span>B<span class="delimiter">]</span> =
    <a href="#33693" title="(fa: F[A], z: B)(f: (B, A) =&gt; G[B])(implicit M: scalaz.Monad[G])G[B]">foldLeftM</a><span class="delimiter">(</span><a href="#280525" title="F[A]">fa</a>, <a href="#280526" title="=&gt; B">z</a><span class="delimiter">)</span><a href="#280528" title="scalaz.Monad[G]" class="delimiter">(</a><span class="delimiter">(</span><a title="B" id="280551">b</a>, <a title="A" id="280552">a</a><span class="delimiter">)</span> =&gt; <a href="#280527" title="(v1: B)A =&gt; G[B]">f</a><span title="(v1: A)G[B]" class="delimiter">(</span><a href="#280551" title="B">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#280552" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>

  /** Unbiased sum of monoidal values. */
  <span class="keyword">def</span> <a title="[A, B](fa: F[A])(implicit F: scalaz.Monoid[A])A" id="33753">foldMapIdentity</a><span class="delimiter">[</span><a title="" id="33756">A</a>,<a title="" id="33757">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280561">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monoid[A]" id="280562">F</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[A]">Monoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33756" title="A">A</a> = <a href="#33665" title="(fa: F[A])(f: A =&gt; A)(implicit F: scalaz.Monoid[A])A">foldMap</a><span class="delimiter">(</span><a href="#280561" title="F[A]">fa</a><span class="delimiter">)</span><a href="#280562" title="scalaz.Monoid[A]" class="delimiter">(</a><a title="A" id="280578">a</a> =&gt; <a href="#280578" title="A">a</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[A](fa: F[A])List[A]" id="33758">toList</a><span class="delimiter">[</span><a title="" id="33760">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280584">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[A]">List</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#33681" title="(fa: F[A], z: List[A])(f: (List[A], A) =&gt; List[A])List[A]">foldLeft</a><span class="delimiter">(</span><a href="#280584" title="F[A]">fa</a>, scala.List<span class="delimiter">[</span>A<span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="List[A]" id="280606">t</a>, <a title="A" id="280607">h</a><span class="delimiter">)</span> =&gt; <a href="#280607" title="A">h</a> <a href="#280608" title="(x: A)List[A]">::</a> <a href="#280606" title="List[A]">t</a><span class="delimiter">)</span>.<span title="=&gt; List[A]">reverse</span>
  <span class="keyword">def</span> <a title="[A](fa: F[A])IndexedSeq[A]" id="33761">toIndexedSeq</a><span class="delimiter">[</span><a title="" id="33763">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280630">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="IndexedSeq[A]">IndexedSeq</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#33681" title="(fa: F[A], z: IndexedSeq[A])(f: (IndexedSeq[A], A) =&gt; IndexedSeq[A])IndexedSeq[A]">foldLeft</a><span class="delimiter">(</span><a href="#280630" title="F[A]">fa</a>, <span title="[A](elems: A*)IndexedSeq[A]">IndexedSeq</span><span title="(elems: A*)IndexedSeq[A]" class="delimiter">[</span><a href="#33763" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#280651" title="IndexedSeq[A]">_</a> <span title="(elem: A)(implicit bf: scala.collection.generic.CanBuildFrom[IndexedSeq[A],A,IndexedSeq[A]])IndexedSeq[A]">:+</span> <a href="#280652" title="A">_</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[A](fa: F[A])Set[A]" id="33764">toSet</a><span class="delimiter">[</span><a title="" id="33766">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280691">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Set[A]">Set</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#33681" title="(fa: F[A], z: scala.collection.immutable.Set[A])(f: (scala.collection.immutable.Set[A], A) =&gt; scala.collection.immutable.Set[A])scala.collection.immutable.Set[A]">foldLeft</a><span class="delimiter">(</span><a href="#280691" title="F[A]">fa</a>, <span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: A*)scala.collection.immutable.Set[A]" class="delimiter">[</span><a href="#33766" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#280715" title="scala.collection.immutable.Set[A]">_</a> <span title="(elem: A)scala.collection.immutable.Set[A]">+</span> <a href="#280716" title="A">_</a><span class="delimiter">)</span>
  <span class="keyword">def</span> <a title="[A](fa: F[A])Stream[A]" id="33767">toStream</a><span class="delimiter">[</span><a title="" id="33769">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280724">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Stream[A]">Stream</span><span class="delimiter">[</span>A<span class="delimiter">]</span> = <a href="#33670" title="[A, B](fa: F[A], z: =&gt; B)(f: (A, =&gt; B) =&gt; B)B">foldRight</a><span title="(fa: F[A], z: =&gt; Stream[A])(f: (A, =&gt; Stream[A]) =&gt; Stream[A])Stream[A]" class="delimiter">[</span><a href="#33769" title="A">A</a>, <span title="Stream[A]">Stream</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#280724" title="F[A]">fa</a>, <span title="=&gt; collection.immutable.Stream.type">Stream</span>.<span title="scala.collection.immutable.Stream[Nothing]">empty</span><span class="delimiter">)</span><span class="delimiter">(</span><span title="=&gt; collection.immutable.Stream.type">Stream</span>.<span title="(hd: A, tl: =&gt; scala.collection.immutable.Stream[A])Stream.Cons[A]">cons</span><span class="delimiter">(</span><a href="#280745" title="A">_</a>, <a href="#280746" title="=&gt; Stream[A]">_</a><span class="delimiter">)</span><span class="delimiter">)</span>

  /** Whether all `A`s in `fa` yield true from `p`. */
  <span class="keyword">def</span> <a title="[A](fa: F[A])(p: A =&gt; Boolean)Boolean" id="33770">all</a><span class="delimiter">[</span><a title="" id="33772">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280767">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; Boolean" id="280768">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#33670" title="(fa: F[A], z: =&gt; Boolean)(f: (A, =&gt; Boolean) =&gt; Boolean)Boolean">foldRight</a><span class="delimiter">(</span><a href="#280767" title="F[A]">fa</a>, <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#280768" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#280782" title="A">_</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#280783" title="=&gt; Boolean">_</a><span class="delimiter">)</span>
  /** `all` with monadic traversal. */
  <span class="keyword">def</span> <a title="[G[_], A](fa: F[A])(p: A =&gt; G[Boolean])(implicit G: scalaz.Monad[G])G[Boolean]" id="33773">allM</a><span class="delimiter">[</span><a title="[_]" id="33776">G</a><span class="delimiter">[</span><a title="" id="280788">_</a><span class="delimiter">]</span>, <a title="" id="33777">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280785">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; G[Boolean]" id="280786">p</a>: A =&gt; G<span class="delimiter">[</span>Boolean<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monad[G]" id="280787">G</a>: <a href="Monad.scala.html#15566" title="scalaz.Monad[G]">Monad</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33776" title="G[Boolean]">G</a><span class="delimiter">[</span>Boolean<span class="delimiter">]</span> =
    <a href="#33670" title="(fa: F[A], z: =&gt; G[Boolean])(f: (A, =&gt; G[Boolean]) =&gt; G[Boolean])G[Boolean]">foldRight</a><span class="delimiter">(</span><a href="#280785" title="F[A]">fa</a>, <a href="#280787" title="scalaz.Monad[G]">G</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; Boolean)G[Boolean]">point</a><span class="delimiter">(</span><span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="280806">a</a>, <a title="=&gt; G[Boolean]" id="280807">b</a><span class="delimiter">)</span> =&gt; <a href="#280787" title="scalaz.Monad[G]">G</a>.<a href="Bind.scala.html#34574" title="(fa: G[Boolean])(f: Boolean =&gt; G[Boolean])G[Boolean]">bind</a><span class="delimiter">(</span><a href="#280786" title="(v1: A)G[Boolean]">p</a><span class="delimiter">(</span><a href="#280806" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Boolean" id="280820">q</a> =&gt; <span title="G[Boolean]" class="keyword">if</span><span class="delimiter">(</span><a href="#280820" title="Boolean">q</a><span class="delimiter">)</span> <a href="#280807" title="=&gt; G[Boolean]">b</a> <span class="keyword">else</span> <a href="#280787" title="scalaz.Monad[G]">G</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; Boolean)G[Boolean]">point</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  /** Whether any `A`s in `fa` yield true from `p`. */
  <span class="keyword">def</span> <a title="[A](fa: F[A])(p: A =&gt; Boolean)Boolean" id="33778">any</a><span class="delimiter">[</span><a title="" id="33780">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280826">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; Boolean" id="280827">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#33670" title="(fa: F[A], z: =&gt; Boolean)(f: (A, =&gt; Boolean) =&gt; Boolean)Boolean">foldRight</a><span class="delimiter">(</span><a href="#280826" title="F[A]">fa</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#280827" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#280841" title="A">_</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#280842" title="=&gt; Boolean">_</a><span class="delimiter">)</span>
  /** `any` with monadic traversal. */
  <span class="keyword">def</span> <a title="[G[_], A](fa: F[A])(p: A =&gt; G[Boolean])(implicit G: scalaz.Monad[G])G[Boolean]" id="33781">anyM</a><span class="delimiter">[</span><a title="[_]" id="33784">G</a><span class="delimiter">[</span><a title="" id="280847">_</a><span class="delimiter">]</span>, <a title="" id="33785">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280844">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; G[Boolean]" id="280845">p</a>: A =&gt; G<span class="delimiter">[</span>Boolean<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monad[G]" id="280846">G</a>: <a href="Monad.scala.html#15566" title="scalaz.Monad[G]">Monad</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33784" title="G[Boolean]">G</a><span class="delimiter">[</span>Boolean<span class="delimiter">]</span> =
    <a href="#33670" title="(fa: F[A], z: =&gt; G[Boolean])(f: (A, =&gt; G[Boolean]) =&gt; G[Boolean])G[Boolean]">foldRight</a><span class="delimiter">(</span><a href="#280844" title="F[A]">fa</a>, <a href="#280846" title="scalaz.Monad[G]">G</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; Boolean)G[Boolean]">point</a><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="280865">a</a>, <a title="=&gt; G[Boolean]" id="280866">b</a><span class="delimiter">)</span> =&gt; <a href="#280846" title="scalaz.Monad[G]">G</a>.<a href="Bind.scala.html#34574" title="(fa: G[Boolean])(f: Boolean =&gt; G[Boolean])G[Boolean]">bind</a><span class="delimiter">(</span><a href="#280845" title="(v1: A)G[Boolean]">p</a><span class="delimiter">(</span><a href="#280865" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="Boolean" id="280879">q</a> =&gt; <span title="G[Boolean]" class="keyword">if</span><span class="delimiter">(</span><a href="#280879" title="Boolean">q</a><span class="delimiter">)</span> <a href="#280846" title="scalaz.Monad[G]">G</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; Boolean)G[Boolean]">point</a><span class="delimiter">(</span><span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#280866" title="=&gt; G[Boolean]">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
  /** Deforested alias for `toStream(fa).size`. */
  <span class="keyword">def</span> <a title="[A](fa: F[A])Int" id="33786">count</a><span class="delimiter">[</span><a title="" id="33788">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280885">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#33681" title="(fa: F[A], z: Int)(f: (Int, A) =&gt; Int)Int">foldLeft</a><span class="delimiter">(</span><a href="#280885" title="F[A]">fa</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Int" id="280898">b</a>, <a title="A" id="280899">_</a><span class="delimiter">)</span> =&gt; <a href="#280898" title="Int">b</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
  <span class="keyword">import</span> <a href="Ordering.scala.html#14958" title="scalaz.Ordering.type">Ordering</a>.<span class="delimiter">{</span>GT, LT<span class="delimiter">}</span>
  <span class="keyword">import</span> std.<a href="std/Option.scala.html#24065" title="scalaz.std.option.type">option</a>.<span class="delimiter">{</span>some, none<span class="delimiter">}</span>
  /** The greatest element of `fa`, or None if `fa` is empty. */
  <span class="keyword">def</span> <a title="[A](fa: F[A])(implicit evidence$2: scalaz.Order[A])Option[A]" id="280905">maximum</a><span class="delimiter">[</span><a title="" id="33793">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280904">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#33681" title="(fa: F[A], z: Option[A])(f: (Option[A], A) =&gt; Option[A])Option[A]">foldLeft</a><span class="delimiter">(</span><a href="#280904" title="F[A]">fa</a>, <a href="std/Option.scala.html#46805" title="[A]=&gt; Option[A]">none</a><span title="Option[A]" class="delimiter">[</span><a href="#33793" title="A">A</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#280919" title="(_1: Option[A], _2: A)(Option[A], A)" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1677228" title="=&gt; Option[A]">None</a>, <a href="#1677228" title="A" id="280931">y</a><span class="delimiter">)</span> =&gt; <a href="std/Option.scala.html#46802" title="(a: A)Option[A]">some</a><a href="#1677235" title="(x: Option[A])Option[A]" class="delimiter">(</a><a href="#280931" title="A">y</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>Some<a href="#1677228" title="=&gt; Option[A]" class="delimiter">(</a><a href="#1677232" title="A" id="280941">x</a><span class="delimiter">)</span>, <a href="#1677228" title="A" id="280942">y</a><span class="delimiter">)</span> =&gt; <a href="std/Option.scala.html#46802" title="(a: A)Option[A]">some</a><a href="#1677235" title="(x: Option[A])Option[A]" class="delimiter">(</a><span title="A" class="keyword">if</span> <span class="delimiter">(</span><a href="Order.scala.html#61798" title="[F](implicit F: scalaz.Order[F])scalaz.Order[F]">Order</a><a href="#280905" title="(implicit F: scalaz.Order[A])scalaz.Order[A]" class="delimiter">[</a><a href="#33793" title="A">A</a><span class="delimiter">]</span>.<a href="Order.scala.html#51572" title="(x: A, y: A)scalaz.Ordering">order</a><span class="delimiter">(</span><a href="#280941" title="A">x</a>, <a href="#280942" title="A">y</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Ordering.scala.html#61835" title="scalaz.Ordering.GT.type">GT</a><span class="delimiter">)</span> <a href="#280941" title="A">x</a> <span class="keyword">else</span> <a href="#280942" title="A">y</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  /** The smallest element of `fa`, or None if `fa` is empty. */
  <span class="keyword">def</span> <a title="[A](fa: F[A])(implicit evidence$3: scalaz.Order[A])Option[A]" id="280955">minimum</a><span class="delimiter">[</span><a title="" id="33796">A</a>: Order<span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="280954">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[A]">Option</span><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#33681" title="(fa: F[A], z: Option[A])(f: (Option[A], A) =&gt; Option[A])Option[A]">foldLeft</a><span class="delimiter">(</span><a href="#280954" title="F[A]">fa</a>, <a href="std/Option.scala.html#46805" title="[A]=&gt; Option[A]">none</a><span title="Option[A]" class="delimiter">[</span><a href="#33796" title="A">A</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#280969" title="(_1: Option[A], _2: A)(Option[A], A)" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1677243" title="=&gt; Option[A]">None</a>, <a href="#1677243" title="A" id="280981">y</a><span class="delimiter">)</span> =&gt; <a href="std/Option.scala.html#46802" title="(a: A)Option[A]">some</a><a href="#1677250" title="(x: Option[A])Option[A]" class="delimiter">(</a><a href="#280981" title="A">y</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span>Some<a href="#1677243" title="=&gt; Option[A]" class="delimiter">(</a><a href="#1677247" title="A" id="280991">x</a><span class="delimiter">)</span>, <a href="#1677243" title="A" id="280992">y</a><span class="delimiter">)</span> =&gt; <a href="std/Option.scala.html#46802" title="(a: A)Option[A]">some</a><a href="#1677250" title="(x: Option[A])Option[A]" class="delimiter">(</a><span title="A" class="keyword">if</span> <span class="delimiter">(</span><a href="Order.scala.html#61798" title="[F](implicit F: scalaz.Order[F])scalaz.Order[F]">Order</a><a href="#280955" title="(implicit F: scalaz.Order[A])scalaz.Order[A]" class="delimiter">[</a><a href="#33796" title="A">A</a><span class="delimiter">]</span>.<a href="Order.scala.html#51572" title="(x: A, y: A)scalaz.Ordering">order</a><span class="delimiter">(</span><a href="#280991" title="A">x</a>, <a href="#280992" title="A">y</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Ordering.scala.html#61831" title="scalaz.Ordering.LT.type">LT</a><span class="delimiter">)</span> <a href="#280991" title="A">x</a> <span class="keyword">else</span> <a href="#280992" title="A">y</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="keyword">def</span> <a title="[A](fa: F[A])(implicit d: &lt;:&lt;[A,scalaz.Digit])Long" id="33797">longDigits</a><span class="delimiter">[</span><a title="" id="33799">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="281004">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="&lt;:&lt;[A,scalaz.Digit]" id="281005">d</a>: A <span title="&lt;:&lt;[A,scalaz.Digit]">&lt;:&lt;</span> Digit<span class="delimiter">)</span>: <span title="Long">Long</span> = <a href="#33681" title="(fa: F[A], z: Long)(f: (Long, A) =&gt; Long)Long">foldLeft</a><span class="delimiter">(</span><a href="#281004" title="F[A]">fa</a>, <span title="Long(0L)" class="long">0L</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="Long" id="281019">n</a>, <a title="A" id="281020">a</a><span class="delimiter">)</span> =&gt; <a href="#281019" title="Long">n</a> <span title="(x: Long)Long">*</span> <span title="Long(10L)" class="long">10L</span> <span title="(x: Long)Long">+</span> <span class="delimiter">(</span><a href="#281005" title="(v1: A)scalaz.Digit">a</a>: <a href="Digit.scala.html#16022" title="scalaz.Digit">Digit</a><span class="delimiter">)</span><span class="delimiter">)</span>
  /** Deforested alias for `toStream(fa).isEmpty`. */
  <span class="keyword">def</span> <a title="[A](fa: F[A])Boolean" id="33800">empty</a><span class="delimiter">[</span><a title="" id="33802">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="68902">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#33770" title="(fa: F[A])(p: A =&gt; Boolean)Boolean">all</a><span class="delimiter">(</span><a href="#68902" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="A" id="281038">_</a> =&gt; <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
  /** Whether `a` is an element of `fa`. */
  <span class="keyword">def</span> <a title="[A](fa: F[A], a: A)(implicit evidence$4: scalaz.Equal[A])Boolean" id="281041">element</a><span class="delimiter">[</span><a title="" id="33805">A</a>: Equal<span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="281039">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A" id="281040">a</a>: <a href="#33805" title="A">A</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#33778" title="(fa: F[A])(p: A =&gt; Boolean)Boolean">any</a><span class="delimiter">(</span><a href="#281039" title="F[A]">fa</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Equal.scala.html#50773" title="[F](implicit F: scalaz.Equal[F])scalaz.Equal[F]">Equal</a><a href="#281041" title="(implicit F: scalaz.Equal[A])scalaz.Equal[A]" class="delimiter">[</a><a href="#33805" title="A">A</a><span class="delimiter">]</span>.<a href="Equal.scala.html#50753" title="(a1: A, a2: A)Boolean">equal</a><span class="delimiter">(</span><a href="#281040" title="A">a</a>, <a href="#281053" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
  /** Insert an `A` between every A, yielding the sum. */
  <span class="keyword">def</span> <a title="[A](fa: F[A], a: A)(implicit A: scalaz.Monoid[A])A" id="33806">intercalate</a><span class="delimiter">[</span><a title="" id="33808">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="281057">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A" id="281058">a</a>: <a href="#33808" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monoid[A]" id="281059">A</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[A]">Monoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33808" title="A">A</a> =
    <span class="delimiter">(</span><a href="#33670" title="(fa: F[A], z: =&gt; Option[A])(f: (A, =&gt; Option[A]) =&gt; Option[A])Option[A]">foldRight</a><span class="delimiter">(</span><a href="#281057" title="F[A]">fa</a>, <a href="std/Option.scala.html#46805" title="[A]=&gt; Option[A]">none</a><span title="Option[A]" class="delimiter">[</span><a href="#33808" title="A">A</a><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#281074" title="(_1: A, _2: Option[A])(A, Option[A])" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1677258" title="A" id="281086">l</a>, <a href="#1677258" title="=&gt; Option[A]">None</a><span class="delimiter">)</span> =&gt; <a href="std/Option.scala.html#46802" title="(a: A)Option[A]">some</a><a href="#1677265" title="(x: Option[A])Option[A]" class="delimiter">(</a><a href="#281086" title="A">l</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1677258" title="A" id="281094">l</a>, Some<a href="#1677258" title="=&gt; Option[A]" class="delimiter">(</a><a href="#1677262" title="A" id="281097">r</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="std/Option.scala.html#46802" title="(a: A)Option[A]">some</a><a href="#1677265" title="(x: Option[A])Option[A]" class="delimiter">(</a><a href="#281059" title="scalaz.Monoid[A]">A</a>.<a href="Semigroup.scala.html#51147" title="(f1: A, f2: =&gt; A)A">append</a><span class="delimiter">(</span><a href="#281094" title="A">l</a>, <a href="#281059" title="scalaz.Monoid[A]">A</a>.<a href="Semigroup.scala.html#51147" title="(f1: A, f2: =&gt; A)A">append</a><span class="delimiter">(</span><a href="#281058" title="A">a</a>, <a href="#281097" title="A">r</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>.<span title="(default: =&gt; A)A">getOrElse</span><span class="delimiter">(</span><a href="#281059" title="scalaz.Monoid[A]">A</a>.<a href="Monoid.scala.html#51158" title="=&gt; A">zero</a><span class="delimiter">)</span>

  /**
   * Splits the elements into groups that alternatively satisfy and don't satisfy the predicate p.
   */
  <span class="keyword">def</span> <a title="[A](fa: F[A])(p: A =&gt; Boolean)List[List[A]]" id="33809">splitWith</a><span class="delimiter">[</span><a title="" id="33811">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="281108">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; Boolean" id="281109">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <span title="List[List[A]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#33670" title="(fa: F[A], z: =&gt; (List[List[A]], Option[Boolean]))(f: (A, =&gt; (List[List[A]], Option[Boolean])) =&gt; (List[List[A]], Option[Boolean]))(List[List[A]], Option[Boolean])">foldRight</a><span class="delimiter">(</span><a href="#281108" title="F[A]">fa</a>, <span title="(_1: List[List[A]], _2: Option[Boolean])(List[List[A]], Option[Boolean])" class="delimiter">(</span>List<span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>, <span title="None.type">None</span> : <span title="Option[Boolean]">Option</span><span class="delimiter">[</span>Boolean<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="281138">a</a>, <a title="=&gt; (List[List[A]], Option[Boolean])" id="281139">b</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Boolean" id="281140">pa</a> = <a href="#281109" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#281138" title="A">a</a><span class="delimiter">)</span>
      <span title="(_1: List[List[A]], _2: Some[Boolean])(List[List[A]], Some[Boolean])" class="delimiter">(</span><a href="#281139" title="=&gt; (List[List[A]], Option[Boolean])">b</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span class="delimiter">(</span>_, <a href="#1677273" title="=&gt; Option[Boolean]">None</a><span class="delimiter">)</span> =&gt; <span title="(xs: List[A]*)List[List[A]]">List</span><a href="#1677281" title="(x: List[List[A]])List[List[A]]" class="delimiter">(</a><span title="(xs: A*)List[A]">List</span><span class="delimiter">(</span><a href="#281138" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1677273" title="List[List[A]]" id="281170">x</a>, Some<a href="#1677273" title="=&gt; Option[Boolean]" class="delimiter">(</a><a href="#1677278" title="Boolean" id="281172">q</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#1677281" title="(x: List[List[A]])List[List[A]]" class="keyword">if</a> <span class="delimiter">(</span><a href="#281140" title="Boolean">pa</a> <span title="(x: Boolean)Boolean">==</span> <a href="#281172" title="Boolean">q</a><span class="delimiter">)</span> <span class="delimiter">(</span><a href="#281138" title="A">a</a> <a href="#281178" title="(x: A)List[A]">::</a> <a href="#281170" title="List[List[A]]">x</a>.<span title="=&gt; List[A]">head</span><span class="delimiter">)</span> <a href="#281177" title="(x: List[A])List[List[A]]">::</a> <a href="#281170" title="List[List[A]]">x</a>.<span title="=&gt; List[List[A]]">tail</span> <span class="keyword">else</span> <span title="(xs: A*)List[A]">List</span><span class="delimiter">(</span><a href="#281138" title="A">a</a><span class="delimiter">)</span> <a href="#281189" title="(x: List[A])List[List[A]]">::</a> <a href="#281170" title="List[List[A]]">x</a>
      <span class="delimiter">}</span>, <span title="(x: Boolean)Some[Boolean]">Some</span><span class="delimiter">(</span><a href="#281140" title="Boolean">pa</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>.<span title="=&gt; List[List[A]]">_1</span>


  /**
   * Selects groups of elements that satisfy p and discards others.
   */
  <span class="keyword">def</span> <a title="[A](fa: F[A])(p: A =&gt; Boolean)List[List[A]]" id="33812">selectSplit</a><span class="delimiter">[</span><a title="" id="33814">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="281208">fa</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; Boolean" id="281209">p</a>: A =&gt; Boolean<span class="delimiter">)</span>: <span title="List[List[A]]">List</span><span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#33670" title="(fa: F[A], z: =&gt; (List[List[A]], Boolean))(f: (A, =&gt; (List[List[A]], Boolean)) =&gt; (List[List[A]], Boolean))(List[List[A]], Boolean)">foldRight</a><span class="delimiter">(</span><a href="#281208" title="F[A]">fa</a>, <span title="(_1: List[List[A]], _2: Boolean)(List[List[A]], Boolean)" class="delimiter">(</span>List<span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="281238">a</a>, <a title="=&gt; (List[List[A]], Boolean)" id="281239">xb</a><span class="delimiter">)</span> =&gt; <a href="#281239" title="=&gt; (List[List[A]], Boolean)">xb</a> <span class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1677289" title="List[List[A]]" id="281243">x</a>, <a href="#1677289" title="Boolean" id="281244">b</a><span class="delimiter">)</span> =&gt; <a href="#1677291" title="(x: (List[List[A]], Boolean))(List[List[A]], Boolean)" class="delimiter">{</a>
        <span class="keyword">val</span> <a title="Boolean" id="281245">pa</a> = <a href="#281209" title="(v1: A)Boolean">p</a><span class="delimiter">(</span><a href="#281238" title="A">a</a><span class="delimiter">)</span>
        <span title="(_1: List[List[A]], _2: Boolean)(List[List[A]], Boolean)" class="delimiter">(</span><span title="List[List[A]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#281245" title="Boolean">pa</a><span class="delimiter">)</span>
          <span title="List[List[A]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#281244" title="Boolean">b</a><span class="delimiter">)</span>
            <span class="delimiter">(</span><a href="#281238" title="A">a</a> <a href="#281252" title="(x: A)List[A]">::</a> <a href="#281243" title="List[List[A]]">x</a>.<span title="=&gt; List[A]">head</span><span class="delimiter">)</span> <a href="#281251" title="(x: List[A])List[List[A]]">::</a> <a href="#281243" title="List[List[A]]">x</a>.<span title="=&gt; List[List[A]]">tail</span> <span class="keyword">else</span>
            <span title="(xs: A*)List[A]">List</span><span class="delimiter">(</span><a href="#281238" title="A">a</a><span class="delimiter">)</span> <a href="#281267" title="(x: List[A])List[List[A]]">::</a> <a href="#281243" title="List[List[A]]">x</a>
        <span class="keyword">else</span> <a href="#281243" title="List[List[A]]">x</a>, <a href="#281245" title="Boolean">pa</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>.<span title="=&gt; List[List[A]]">_1</span>

  <span class="keyword">def</span> <a title="[X[_], A](x: F[A])(implicit F: scalaz.Foldable[F], implicit A: scalaz.ApplicativePlus[X])X[A]" id="33815">collapse</a><span class="delimiter">[</span><a title="[_]" id="33818">X</a><span class="delimiter">[</span><a title="" id="281286">_</a><span class="delimiter">]</span>, <a title="" id="33819">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="281283">x</a>: <a href="#23135" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Foldable[F]" id="281284">F</a>: <a href="#17390" title="scalaz.Foldable[F]">Foldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span>, <a title="scalaz.ApplicativePlus[X]" id="281285">A</a>: <a href="ApplicativePlus.scala.html#8588" title="scalaz.ApplicativePlus[X]">ApplicativePlus</a><span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33818" title="X[A]">X</a><span class="delimiter">[</span>A<span class="delimiter">]</span> =
    <a href="#281284" title="scalaz.Foldable[F]">F</a>.<a href="#33670" title="(fa: F[A], z: =&gt; X[A])(f: (A, =&gt; X[A]) =&gt; X[A])X[A]">foldRight</a><span class="delimiter">(</span><a href="#281283" title="F[A]">x</a>, <a href="#281285" title="scalaz.ApplicativePlus[X]">A</a>.<a href="PlusEmpty.scala.html#68558" title="[A]=&gt; X[A]">empty</a><span title="X[A]" class="delimiter">[</span><a href="#33819" title="A">A</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="281301">a</a>, <a title="=&gt; X[A]" id="281302">b</a><span class="delimiter">)</span> =&gt; <a href="#281285" title="scalaz.ApplicativePlus[X]">A</a>.<a href="Plus.scala.html#68546" title="(a: X[A], b: =&gt; X[A])X[A]">plus</a><span class="delimiter">(</span><a href="#281285" title="scalaz.ApplicativePlus[X]">A</a>.<a href="Applicative.scala.html#34510" title="(a: =&gt; A)X[A]">point</a><span class="delimiter">(</span><a href="#281301" title="A">a</a><span class="delimiter">)</span>, <a href="#281302" title="=&gt; X[A]">b</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[G[_], X[_], A](x: F[G[A]])(implicit F: scalaz.Foldable[F], implicit G: scalaz.Foldable[G], implicit A: scalaz.ApplicativePlus[X])X[A]" id="33820">collapse2</a><span class="delimiter">[</span><a title="[_]" id="33824">G</a><span class="delimiter">[</span><a title="" id="281318">_</a><span class="delimiter">]</span>, <a title="[_]" id="33825">X</a><span class="delimiter">[</span><a title="" id="281317">_</a><span class="delimiter">]</span>, <a title="" id="33826">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[G[A]]" id="281313">x</a>: <a href="#23135" title="F[G[A]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span>
                                            <a title="scalaz.Foldable[F]" id="281314">F</a>: <a href="#17390" title="scalaz.Foldable[F]">Foldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span>
                                          , <a title="scalaz.Foldable[G]" id="281315">G</a>: <a href="#17390" title="scalaz.Foldable[G]">Foldable</a><span class="delimiter">[</span>G<span class="delimiter">]</span>
                                          , <a title="scalaz.ApplicativePlus[X]" id="281316">A</a>: <a href="ApplicativePlus.scala.html#8588" title="scalaz.ApplicativePlus[X]">ApplicativePlus</a><span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33825" title="X[A]">X</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Foldable[[α]F[G[α]]]" id="281323">Z</a> = <a href="#281314" title="scalaz.Foldable[F]">F</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[G])scalaz.Foldable[[α]F[G[α]]]">compose</a> <a href="#281315" title="scalaz.Foldable[G]">G</a>
    <a href="#281323" title="scalaz.Foldable[[α]F[G[α]]]">Z</a> <a href="#33815" title="(x: F[G[A]])(implicit F: scalaz.Foldable[[α]F[G[α]]], implicit A: scalaz.ApplicativePlus[X])X[A]">collapse</a> <a href="#281313" title="F[G[A]]">x</a>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[G[_], H[_], X[_], A](x: F[G[H[A]]])(implicit F: scalaz.Foldable[F], implicit G: scalaz.Foldable[G], implicit H: scalaz.Foldable[H], implicit A: scalaz.ApplicativePlus[X])X[A]" id="33827">collapse3</a><span class="delimiter">[</span><a title="[_]" id="33832">G</a><span class="delimiter">[</span><a title="" id="281361">_</a><span class="delimiter">]</span>, <a title="[_]" id="33833">H</a><span class="delimiter">[</span><a title="" id="281362">_</a><span class="delimiter">]</span>, <a title="[_]" id="33834">X</a><span class="delimiter">[</span><a title="" id="281360">_</a><span class="delimiter">]</span>, <a title="" id="33835">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[G[H[A]]]" id="281355">x</a>: <a href="#23135" title="F[G[H[A]]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>H<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span>
                                                     <a title="scalaz.Foldable[F]" id="281356">F</a>: <a href="#17390" title="scalaz.Foldable[F]">Foldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span>
                                                   , <a title="scalaz.Foldable[G]" id="281357">G</a>: <a href="#17390" title="scalaz.Foldable[G]">Foldable</a><span class="delimiter">[</span>G<span class="delimiter">]</span>
                                                   , <a title="scalaz.Foldable[H]" id="281358">H</a>: <a href="#17390" title="scalaz.Foldable[H]">Foldable</a><span class="delimiter">[</span>H<span class="delimiter">]</span>
                                                   , <a title="scalaz.ApplicativePlus[X]" id="281359">A</a>: <a href="ApplicativePlus.scala.html#8588" title="scalaz.ApplicativePlus[X]">ApplicativePlus</a><span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33834" title="X[A]">X</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Foldable[[α]F[G[H[α]]]]" id="281368">Z</a> = <a href="#281356" title="scalaz.Foldable[F]">F</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[G])scalaz.Foldable[[α]F[G[α]]]">compose</a> <a href="#281357" title="scalaz.Foldable[G]">G</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[H])scalaz.Foldable[[α]F[G[H[α]]]]">compose</a> <a href="#281358" title="scalaz.Foldable[H]">H</a>
    <a href="#281368" title="scalaz.Foldable[[α]F[G[H[α]]]]">Z</a>.<a href="#33815" title="(x: F[G[H[A]]])(implicit F: scalaz.Foldable[[α]F[G[H[α]]]], implicit A: scalaz.ApplicativePlus[X])X[A]">collapse</a><a href="#281368" title="scalaz.Foldable[[α]F[G[H[α]]]]" class="delimiter">(</a><a href="#281355" title="F[G[H[A]]]">x</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[G[_], H[_], I[_], X[_], A](x: F[G[H[I[A]]]])(implicit F: scalaz.Foldable[F], implicit G: scalaz.Foldable[G], implicit H: scalaz.Foldable[H], implicit I: scalaz.Foldable[I], implicit A: scalaz.ApplicativePlus[X])X[A]" id="33836">collapse4</a><span class="delimiter">[</span><a title="[_]" id="33842">G</a><span class="delimiter">[</span><a title="" id="281414">_</a><span class="delimiter">]</span>, <a title="[_]" id="33843">H</a><span class="delimiter">[</span><a title="" id="281415">_</a><span class="delimiter">]</span>, <a title="[_]" id="33844">I</a><span class="delimiter">[</span><a title="" id="281416">_</a><span class="delimiter">]</span>, <a title="[_]" id="33845">X</a><span class="delimiter">[</span><a title="" id="281413">_</a><span class="delimiter">]</span>, <a title="" id="33846">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[G[H[I[A]]]]" id="281407">x</a>: <a href="#23135" title="F[G[H[I[A]]]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>H<span class="delimiter">[</span>I<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span>
                                                              <a title="scalaz.Foldable[F]" id="281408">F</a>: <a href="#17390" title="scalaz.Foldable[F]">Foldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span>
                                                            , <a title="scalaz.Foldable[G]" id="281409">G</a>: <a href="#17390" title="scalaz.Foldable[G]">Foldable</a><span class="delimiter">[</span>G<span class="delimiter">]</span>
                                                            , <a title="scalaz.Foldable[H]" id="281410">H</a>: <a href="#17390" title="scalaz.Foldable[H]">Foldable</a><span class="delimiter">[</span>H<span class="delimiter">]</span>
                                                            , <a title="scalaz.Foldable[I]" id="281411">I</a>: <a href="#17390" title="scalaz.Foldable[I]">Foldable</a><span class="delimiter">[</span>I<span class="delimiter">]</span>
                                                            , <a title="scalaz.ApplicativePlus[X]" id="281412">A</a>: <a href="ApplicativePlus.scala.html#8588" title="scalaz.ApplicativePlus[X]">ApplicativePlus</a><span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33845" title="X[A]">X</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Foldable[[α]F[G[H[I[α]]]]]" id="281423">Z</a> = <a href="#281408" title="scalaz.Foldable[F]">F</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[G])scalaz.Foldable[[α]F[G[α]]]">compose</a> <a href="#281409" title="scalaz.Foldable[G]">G</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[H])scalaz.Foldable[[α]F[G[H[α]]]]">compose</a> <a href="#281410" title="scalaz.Foldable[H]">H</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[I])scalaz.Foldable[[α]F[G[H[I[α]]]]]">compose</a> <a href="#281411" title="scalaz.Foldable[I]">I</a>
    <a href="#281423" title="scalaz.Foldable[[α]F[G[H[I[α]]]]]">Z</a>.<a href="#33815" title="(x: F[G[H[I[A]]]])(implicit F: scalaz.Foldable[[α]F[G[H[I[α]]]]], implicit A: scalaz.ApplicativePlus[X])X[A]">collapse</a><a href="#281423" title="scalaz.Foldable[[α]F[G[H[I[α]]]]]" class="delimiter">(</a><a href="#281407" title="F[G[H[I[A]]]]">x</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[G[_], H[_], I[_], J[_], X[_], A](x: F[G[H[I[J[A]]]]])(implicit F: scalaz.Foldable[F], implicit G: scalaz.Foldable[G], implicit H: scalaz.Foldable[H], implicit I: scalaz.Foldable[I], implicit J: scalaz.Foldable[J], implicit A: scalaz.ApplicativePlus[X])X[A]" id="33847">collapse5</a><span class="delimiter">[</span><a title="[_]" id="33854">G</a><span class="delimiter">[</span><a title="" id="281477">_</a><span class="delimiter">]</span>, <a title="[_]" id="33855">H</a><span class="delimiter">[</span><a title="" id="281478">_</a><span class="delimiter">]</span>, <a title="[_]" id="33856">I</a><span class="delimiter">[</span><a title="" id="281479">_</a><span class="delimiter">]</span>, <a title="[_]" id="33857">J</a><span class="delimiter">[</span><a title="" id="281480">_</a><span class="delimiter">]</span>, <a title="[_]" id="33858">X</a><span class="delimiter">[</span><a title="" id="281476">_</a><span class="delimiter">]</span>, <a title="" id="33859">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[G[H[I[J[A]]]]]" id="281469">x</a>: <a href="#23135" title="F[G[H[I[J[A]]]]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>H<span class="delimiter">[</span>I<span class="delimiter">[</span>J<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span>
                                                                       <a title="scalaz.Foldable[F]" id="281470">F</a>: <a href="#17390" title="scalaz.Foldable[F]">Foldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span>
                                                                     , <a title="scalaz.Foldable[G]" id="281471">G</a>: <a href="#17390" title="scalaz.Foldable[G]">Foldable</a><span class="delimiter">[</span>G<span class="delimiter">]</span>
                                                                     , <a title="scalaz.Foldable[H]" id="281472">H</a>: <a href="#17390" title="scalaz.Foldable[H]">Foldable</a><span class="delimiter">[</span>H<span class="delimiter">]</span>
                                                                     , <a title="scalaz.Foldable[I]" id="281473">I</a>: <a href="#17390" title="scalaz.Foldable[I]">Foldable</a><span class="delimiter">[</span>I<span class="delimiter">]</span>
                                                                     , <a title="scalaz.Foldable[J]" id="281474">J</a>: <a href="#17390" title="scalaz.Foldable[J]">Foldable</a><span class="delimiter">[</span>J<span class="delimiter">]</span>
                                                                     , <a title="scalaz.ApplicativePlus[X]" id="281475">A</a>: <a href="ApplicativePlus.scala.html#8588" title="scalaz.ApplicativePlus[X]">ApplicativePlus</a><span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33858" title="X[A]">X</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Foldable[[α]F[G[H[I[J[α]]]]]]" id="281488">Z</a> = <a href="#281470" title="scalaz.Foldable[F]">F</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[G])scalaz.Foldable[[α]F[G[α]]]">compose</a> <a href="#281471" title="scalaz.Foldable[G]">G</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[H])scalaz.Foldable[[α]F[G[H[α]]]]">compose</a> <a href="#281472" title="scalaz.Foldable[H]">H</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[I])scalaz.Foldable[[α]F[G[H[I[α]]]]]">compose</a> <a href="#281473" title="scalaz.Foldable[I]">I</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[J])scalaz.Foldable[[α]F[G[H[I[J[α]]]]]]">compose</a> <a href="#281474" title="scalaz.Foldable[J]">J</a>
    <a href="#281488" title="scalaz.Foldable[[α]F[G[H[I[J[α]]]]]]">Z</a>.<a href="#33815" title="(x: F[G[H[I[J[A]]]]])(implicit F: scalaz.Foldable[[α]F[G[H[I[J[α]]]]]], implicit A: scalaz.ApplicativePlus[X])X[A]">collapse</a><a href="#281488" title="scalaz.Foldable[[α]F[G[H[I[J[α]]]]]]" class="delimiter">(</a><a href="#281469" title="F[G[H[I[J[A]]]]]">x</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[G[_], H[_], I[_], J[_], K[_], X[_], A](x: F[G[H[I[J[K[A]]]]]])(implicit F: scalaz.Foldable[F], implicit G: scalaz.Foldable[G], implicit H: scalaz.Foldable[H], implicit I: scalaz.Foldable[I], implicit J: scalaz.Foldable[J], implicit K: scalaz.Foldable[K], implicit A: scalaz.ApplicativePlus[X])X[A]" id="33860">collapse6</a><span class="delimiter">[</span><a title="[_]" id="33868">G</a><span class="delimiter">[</span><a title="" id="281550">_</a><span class="delimiter">]</span>, <a title="[_]" id="33869">H</a><span class="delimiter">[</span><a title="" id="281551">_</a><span class="delimiter">]</span>, <a title="[_]" id="33870">I</a><span class="delimiter">[</span><a title="" id="281552">_</a><span class="delimiter">]</span>, <a title="[_]" id="33871">J</a><span class="delimiter">[</span><a title="" id="281553">_</a><span class="delimiter">]</span>, <a title="[_]" id="33872">K</a><span class="delimiter">[</span><a title="" id="281554">_</a><span class="delimiter">]</span>, <a title="[_]" id="33873">X</a><span class="delimiter">[</span><a title="" id="281549">_</a><span class="delimiter">]</span>, <a title="" id="33874">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[G[H[I[J[K[A]]]]]]" id="281541">x</a>: <a href="#23135" title="F[G[H[I[J[K[A]]]]]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>H<span class="delimiter">[</span>I<span class="delimiter">[</span>J<span class="delimiter">[</span>K<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span>
                                                                                <a title="scalaz.Foldable[F]" id="281542">F</a>: <a href="#17390" title="scalaz.Foldable[F]">Foldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span>
                                                                              , <a title="scalaz.Foldable[G]" id="281543">G</a>: <a href="#17390" title="scalaz.Foldable[G]">Foldable</a><span class="delimiter">[</span>G<span class="delimiter">]</span>
                                                                              , <a title="scalaz.Foldable[H]" id="281544">H</a>: <a href="#17390" title="scalaz.Foldable[H]">Foldable</a><span class="delimiter">[</span>H<span class="delimiter">]</span>
                                                                              , <a title="scalaz.Foldable[I]" id="281545">I</a>: <a href="#17390" title="scalaz.Foldable[I]">Foldable</a><span class="delimiter">[</span>I<span class="delimiter">]</span>
                                                                              , <a title="scalaz.Foldable[J]" id="281546">J</a>: <a href="#17390" title="scalaz.Foldable[J]">Foldable</a><span class="delimiter">[</span>J<span class="delimiter">]</span>
                                                                              , <a title="scalaz.Foldable[K]" id="281547">K</a>: <a href="#17390" title="scalaz.Foldable[K]">Foldable</a><span class="delimiter">[</span>K<span class="delimiter">]</span>
                                                                              , <a title="scalaz.ApplicativePlus[X]" id="281548">A</a>: <a href="ApplicativePlus.scala.html#8588" title="scalaz.ApplicativePlus[X]">ApplicativePlus</a><span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33873" title="X[A]">X</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Foldable[[α]F[G[H[I[J[K[α]]]]]]]" id="281563">Z</a> = <a href="#281542" title="scalaz.Foldable[F]">F</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[G])scalaz.Foldable[[α]F[G[α]]]">compose</a> <a href="#281543" title="scalaz.Foldable[G]">G</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[H])scalaz.Foldable[[α]F[G[H[α]]]]">compose</a> <a href="#281544" title="scalaz.Foldable[H]">H</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[I])scalaz.Foldable[[α]F[G[H[I[α]]]]]">compose</a> <a href="#281545" title="scalaz.Foldable[I]">I</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[J])scalaz.Foldable[[α]F[G[H[I[J[α]]]]]]">compose</a> <a href="#281546" title="scalaz.Foldable[J]">J</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[K])scalaz.Foldable[[α]F[G[H[I[J[K[α]]]]]]]">compose</a> <a href="#281547" title="scalaz.Foldable[K]">K</a>
    <a href="#281563" title="scalaz.Foldable[[α]F[G[H[I[J[K[α]]]]]]]">Z</a>.<a href="#33815" title="(x: F[G[H[I[J[K[A]]]]]])(implicit F: scalaz.Foldable[[α]F[G[H[I[J[K[α]]]]]]], implicit A: scalaz.ApplicativePlus[X])X[A]">collapse</a><a href="#281563" title="scalaz.Foldable[[α]F[G[H[I[J[K[α]]]]]]]" class="delimiter">(</a><a href="#281541" title="F[G[H[I[J[K[A]]]]]]">x</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[G[_], H[_], I[_], J[_], K[_], L[_], X[_], A](x: F[G[H[I[J[K[L[A]]]]]]])(implicit F: scalaz.Foldable[F], implicit G: scalaz.Foldable[G], implicit H: scalaz.Foldable[H], implicit I: scalaz.Foldable[I], implicit J: scalaz.Foldable[J], implicit K: scalaz.Foldable[K], implicit L: scalaz.Foldable[L], implicit A: scalaz.ApplicativePlus[X])X[A]" id="33875">collapse7</a><span class="delimiter">[</span><a title="[_]" id="33884">G</a><span class="delimiter">[</span><a title="" id="281633">_</a><span class="delimiter">]</span>, <a title="[_]" id="33885">H</a><span class="delimiter">[</span><a title="" id="281634">_</a><span class="delimiter">]</span>, <a title="[_]" id="33886">I</a><span class="delimiter">[</span><a title="" id="281635">_</a><span class="delimiter">]</span>, <a title="[_]" id="33887">J</a><span class="delimiter">[</span><a title="" id="281636">_</a><span class="delimiter">]</span>, <a title="[_]" id="33888">K</a><span class="delimiter">[</span><a title="" id="281637">_</a><span class="delimiter">]</span>, <a title="[_]" id="33889">L</a><span class="delimiter">[</span><a title="" id="281638">_</a><span class="delimiter">]</span>, <a title="[_]" id="33890">X</a><span class="delimiter">[</span><a title="" id="281632">_</a><span class="delimiter">]</span>, <a title="" id="33891">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[G[H[I[J[K[L[A]]]]]]]" id="281623">x</a>: <a href="#23135" title="F[G[H[I[J[K[L[A]]]]]]]">F</a><span class="delimiter">[</span>G<span class="delimiter">[</span>H<span class="delimiter">[</span>I<span class="delimiter">[</span>J<span class="delimiter">[</span>K<span class="delimiter">[</span>L<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span>
                                                                                         <a title="scalaz.Foldable[F]" id="281624">F</a>: <a href="#17390" title="scalaz.Foldable[F]">Foldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span>
                                                                                       , <a title="scalaz.Foldable[G]" id="281625">G</a>: <a href="#17390" title="scalaz.Foldable[G]">Foldable</a><span class="delimiter">[</span>G<span class="delimiter">]</span>
                                                                                       , <a title="scalaz.Foldable[H]" id="281626">H</a>: <a href="#17390" title="scalaz.Foldable[H]">Foldable</a><span class="delimiter">[</span>H<span class="delimiter">]</span>
                                                                                       , <a title="scalaz.Foldable[I]" id="281627">I</a>: <a href="#17390" title="scalaz.Foldable[I]">Foldable</a><span class="delimiter">[</span>I<span class="delimiter">]</span>
                                                                                       , <a title="scalaz.Foldable[J]" id="281628">J</a>: <a href="#17390" title="scalaz.Foldable[J]">Foldable</a><span class="delimiter">[</span>J<span class="delimiter">]</span>
                                                                                       , <a title="scalaz.Foldable[K]" id="281629">K</a>: <a href="#17390" title="scalaz.Foldable[K]">Foldable</a><span class="delimiter">[</span>K<span class="delimiter">]</span>
                                                                                       , <a title="scalaz.Foldable[L]" id="281630">L</a>: <a href="#17390" title="scalaz.Foldable[L]">Foldable</a><span class="delimiter">[</span>L<span class="delimiter">]</span>
                                                                                       , <a title="scalaz.ApplicativePlus[X]" id="281631">A</a>: <a href="ApplicativePlus.scala.html#8588" title="scalaz.ApplicativePlus[X]">ApplicativePlus</a><span class="delimiter">[</span>X<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#33890" title="X[A]">X</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Foldable[[α]F[G[H[I[J[K[L[α]]]]]]]]" id="281648">Z</a> = <a href="#281624" title="scalaz.Foldable[F]">F</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[G])scalaz.Foldable[[α]F[G[α]]]">compose</a> <a href="#281625" title="scalaz.Foldable[G]">G</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[H])scalaz.Foldable[[α]F[G[H[α]]]]">compose</a> <a href="#281626" title="scalaz.Foldable[H]">H</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[I])scalaz.Foldable[[α]F[G[H[I[α]]]]]">compose</a> <a href="#281627" title="scalaz.Foldable[I]">I</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[J])scalaz.Foldable[[α]F[G[H[I[J[α]]]]]]">compose</a> <a href="#281628" title="scalaz.Foldable[J]">J</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[K])scalaz.Foldable[[α]F[G[H[I[J[K[α]]]]]]]">compose</a> <a href="#281629" title="scalaz.Foldable[K]">K</a> <a href="#33675" title="(implicit G0: scalaz.Foldable[L])scalaz.Foldable[[α]F[G[H[I[J[K[L[α]]]]]]]]">compose</a> <a href="#281630" title="scalaz.Foldable[L]">L</a>
    <a href="#281648" title="scalaz.Foldable[[α]F[G[H[I[J[K[L[α]]]]]]]]">Z</a>.<a href="#33815" title="(x: F[G[H[I[J[K[L[A]]]]]]])(implicit F: scalaz.Foldable[[α]F[G[H[I[J[K[L[α]]]]]]]], implicit A: scalaz.ApplicativePlus[X])X[A]">collapse</a><a href="#281648" title="scalaz.Foldable[[α]F[G[H[I[J[K[L[α]]]]]]]]" class="delimiter">(</a><a href="#281623" title="F[G[H[I[J[K[L[A]]]]]]]">x</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  ////
  <span class="keyword">val</span> <a title="foldableSyntax extends AnyRef with scalaz.syntax.FoldableSyntax[F]" id="33892">foldableSyntax</a> = <a href="#279972" title="scalaz.syntax.FoldableSyntax[F]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.syntax.FoldableSyntax[F]" id="279972">scalaz</a>.syntax.<a href="syntax/FoldableSyntax.scala.html#27640" title="scalaz.syntax.FoldableSyntax[F]">FoldableSyntax</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Foldable[F]" id="279979">F</a> = <a href="#17390" title="scalaz.Foldable[F]">Foldable</a>.<span class="keyword">this</span> <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">object</span> <a title="scalaz.Foldable.type" id="17391">Foldable</a> <a href="#17392" title="scalaz.Foldable.type" class="delimiter">{</a>
  @inline <span class="keyword">def</span> <a title="[F[_]](implicit F: scalaz.Foldable[F])scalaz.Foldable[F]" id="100602">apply</a><span class="delimiter">[</span><a title="[_]" id="100604">F</a><span class="delimiter">[</span><a title="" id="281717">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Foldable[F]" id="281716">F</a>: <a href="#17390" title="scalaz.Foldable[F]">Foldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#17390" title="scalaz.Foldable[F]">Foldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span> = <a href="#281716" title="scalaz.Foldable[F]">F</a>

  ////
  /**
   * Template trait to define `Foldable` in terms of `foldMap`.
   *
   * Example:
   * {{{
   * new Foldable[Option] with Foldable.FromFoldMap[Option] {
   *   def foldMap[A, B](fa: Option[A])(f: A =&gt; B)(implicit F: Monoid[B]) = fa match {
   *     case Some(a) =&gt; f(a)
   *     case None    =&gt; F.zero
   *   }
   * }
   * }}}
   */
  <span class="keyword">trait</span> <a title="trait FromFoldMap[F[_]] extends AnyRef with scalaz.Foldable[F]" id="100605">FromFoldMap</a><span class="delimiter">[</span><a title="[_]" id="100606">F</a><span class="delimiter">[</span><a title="" id="281720">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="#17390" title="scalaz.Foldable[F]">Foldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](fa: F[A], z: =&gt; B)(f: (A, =&gt; B) =&gt; B)B" id="100621">foldRight</a><span class="delimiter">[</span><a title="" id="100624">A</a>, <a title="" id="100625">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="281723">fa</a>: <a href="#100606" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="=&gt; B" id="281724">z</a>: =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, =&gt; B) =&gt; B" id="281725">f</a>: <span class="delimiter">(</span>A, =&gt; B<span class="delimiter">)</span> =&gt; B<span class="delimiter">)</span> =
      <a href="#33665" title="(fa: F[A])(f: A =&gt; scalaz.Endo[B])(implicit F: scalaz.Monoid[scalaz.Endo[B]])scalaz.Endo[B]">foldMap</a><span class="delimiter">(</span><a href="#281723" title="F[A]">fa</a><span class="delimiter">)</span><a href="Endo.scala.html#51363" title="scalaz.Monoid[scalaz.Endo[B]]" class="delimiter">(</a><span class="delimiter">(</span>a: <a href="#100624" title="A">A</a><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span><a href="Endo.scala.html#10845" title="scalaz.Endo.type">Endo</a>.<a href="Endo.scala.html#51344" title="(f: B =&gt; B)scalaz.Endo[B]">endo</a><span class="delimiter">(</span><a href="#281725" title="(v1: A, v2: =&gt; B)B">f</a><span class="delimiter">(</span><a href="#281762" title="A">a</a>, <a href="#281766" title="B">_</a>: <a href="#100625" title="B">B</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="Endo.scala.html#51379" title="(a: B)B">apply</a> <a href="#281724" title="=&gt; B">z</a>
  <span class="delimiter">}</span>

  /**
   * Template trait to define `Foldable` in terms of `foldr`
   *
   * Example:
   * {{{
   * new Foldable[Option] with Foldable.FromFoldr[Option] {
   *   def foldr[A, B](fa: Option[A], z: B)(f: (A) =&gt; (=&gt; B) =&gt; B) = fa match {
   *     case Some(a) =&gt; f(a)(z)
   *     case None =&gt; z
   *   }
   * }
   * }}}
   */
  <span class="keyword">trait</span> <a title="trait FromFoldr[F[_]] extends AnyRef with scalaz.Foldable[F]" id="100607">FromFoldr</a><span class="delimiter">[</span><a title="[_]" id="100608">F</a><span class="delimiter">[</span><a title="" id="254587">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="#17390" title="scalaz.Foldable[F]">Foldable</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](fa: F[A])(f: A =&gt; B)(implicit F: scalaz.Monoid[B])B" id="112015">foldMap</a><span class="delimiter">[</span><a title="" id="112018">A</a>, <a title="" id="112019">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="281784">fa</a>: <a href="#100608" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="281785">f</a>: A =&gt; B<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Monoid[B]" id="281786">F</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[B]">Monoid</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> =
        <a href="#33729" title="[A, B](fa: F[A], z: =&gt; B)(f: A =&gt; ((=&gt; B) =&gt; B))B">foldr</a><span title="(fa: F[A], z: =&gt; B)(f: A =&gt; ((=&gt; B) =&gt; B))B" class="delimiter">[</span><a href="#112018" title="A">A</a>, <a href="#112019" title="B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#281784" title="F[A]">fa</a>, <a href="#281786" title="scalaz.Monoid[B]">F</a>.<a href="Monoid.scala.html#51158" title="=&gt; B">zero</a><span class="delimiter">)</span><span class="delimiter">(</span> <a title="A" id="281814">x</a> =&gt; <a title="=&gt; B" id="281816">y</a> =&gt; <a href="#281786" title="scalaz.Monoid[B]">F</a>.<a href="Semigroup.scala.html#51147" title="(f1: B, f2: =&gt; B)B">append</a><span class="delimiter">(</span><a href="#281785" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#281814" title="A">x</a><span class="delimiter">)</span>,  <a href="#281816" title="=&gt; B">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  ////
<span class="delimiter">}</span>

        </pre>
    </body>
</html>