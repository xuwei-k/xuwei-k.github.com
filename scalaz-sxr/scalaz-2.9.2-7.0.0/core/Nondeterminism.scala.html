<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>core/Nondeterminism.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz

////
/**
 * A context supporting nondeterministic choice. Unlike `Monad.bind`, 
 * which imposes a total order on the sequencing of effects throughout a
 * computation, the `choose` and `chooseAny` operations let us
 * partially order the sequencing of effects. Canonical instances are
 * `concurrent.Future` and `concurrent.Task`, which run their arguments
 * in parallel, returning whichever comes back 'first'. 
 * 
 * TODO - laws
 */
////
<span class="keyword">trait</span> <a title="trait Nondeterminism[F[_]] extends AnyRef with scalaz.Monad[F]" id="10886">Nondeterminism</a><span class="delimiter">[</span><a title="[_]" id="23549">F</a><span class="delimiter">[</span><a title="" id="48615">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="Monad.scala.html#15566" title="scalaz.Monad[F]">Monad</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span> self =&gt;
  ////

  /** 
   * A commutative operation which chooses nondeterministically to obtain 
   * a value from either `a` or `b`. If `a` 'wins', a 'residual' context
   * for `b` is returned; if `b` wins, a residual context for `a` is
   * returned. The residual is useful for various instances like `Future`,
   * which may race the two computations and require a residual to ensure
   * the result of the 'losing' computation is not discarded. 
   *
   * This function can be defined in terms of `chooseAny` or vice versa. 
   * The default implementation calls `chooseAny` with a
   * two-element list and uses the `Functor` for `F` to fix up types.
   */
  <span class="keyword">def</span> <a title="[A, B](a: F[A], b: F[B])F[scalaz.\/[(A, F[B]),(F[A], B)]]" id="48524">choose</a><span class="delimiter">[</span><a title="" id="48527">A</a>,<a title="" id="48528">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="401988">a</a>: <a href="#23549" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="F[B]" id="401989">b</a>: <a href="#23549" title="F[B]">F</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23549" title="F[scalaz.\/[(A, F[B]),(F[A], B)]]">F</a><span class="delimiter">[</span><span class="delimiter">(</span>  A,  F<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> \/
                                       <span class="delimiter">(</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span>,   B <span class="delimiter">)</span><span class="delimiter">]</span> = 
    <a href="Monad.scala.html#34563" title="(fa: F[(scalaz.\/[A,B], Seq[F[scalaz.\/[A,B]]])])(f: ((scalaz.\/[A,B], Seq[F[scalaz.\/[A,B]]])) =&gt; scalaz.\/[(A, F[B]),(F[A], B)])F[scalaz.\/[(A, F[B]),(F[A], B)]]">map</a><span class="delimiter">(</span><a href="#48529" title="(a: Seq[F[scalaz.\/[A,B]]])Option[F[(scalaz.\/[A,B], Seq[F[scalaz.\/[A,B]]])]]">chooseAny</a><span class="delimiter">(</span><span title="[A](xs: A*)List[A]">List</span><span title="(xs: F[scalaz.\/[A,B]]*)List[F[scalaz.\/[A,B]]]" class="delimiter">[</span><a href="#23549" title="F[scalaz.\/[A,B]]">F</a><span class="delimiter">[</span>A \/ B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="Monad.scala.html#34563" title="(fa: F[A])(f: A =&gt; scalaz.\/[A,B])F[scalaz.\/[A,B]]">map</a><span class="delimiter">(</span><a href="#401988" title="F[A]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Either.scala.html#50463" title="(a: A)scalaz.-\/[A]">-\/</a><span class="delimiter">(</span><a href="#402038" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="Monad.scala.html#34563" title="(fa: F[B])(f: B =&gt; scalaz.\/[A,B])F[scalaz.\/[A,B]]">map</a><span class="delimiter">(</span><a href="#401989" title="F[B]">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="Either.scala.html#50499" title="(b: B)scalaz.\/-[B]">\/-</a><span class="delimiter">(</span><a href="#402057" title="B">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; F[(scalaz.\/[A,B], Seq[F[scalaz.\/[A,B]]])]">get</span><span class="delimiter">)</span> <span class="delimiter">{</span> 
      <span class="delimiter">(</span>x: <span title="(scalaz.\/[A,B], Seq[F[scalaz.\/[A,B]]])" class="delimiter">(</span>A \/ B, Seq<span class="delimiter">[</span>F<span class="delimiter">[</span>A \/ B<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#402074" title="(scalaz.\/[A,B], Seq[F[scalaz.\/[A,B]]])">x</a> <span class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span class="delimiter">(</span>-\/<a href="#1679436" title="=&gt; scalaz.\/[A,B]" class="delimiter">(</a><a href="Either.scala.html#50471" title="A" id="402082">a</a><span class="delimiter">)</span>, <a href="#1679438" title="(x: Seq[F[scalaz.\/[A,B]]])Some[Seq[F[scalaz.\/[A,B]]]]">Seq</a><a href="#1679436" title="=&gt; Seq[F[scalaz.\/[A,B]]]" class="delimiter">(</a><a title="F[scalaz.\/[A,B]]" id="402101">br</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; 
          <a href="Either.scala.html#50463" title="(a: (A, F[B]))scalaz.-\/[(A, F[B])]">-\/</a><a href="#1679448" title="(x: scalaz.\/[(A, F[B]),(F[A], B)])scalaz.\/[(A, F[B]),(F[A], B)]" class="delimiter">(</a><span title="(_1: A, _2: F[B])(A, F[B])" class="delimiter">(</span><a href="#402082" title="A">a</a>, <a href="Monad.scala.html#34563" title="(fa: F[scalaz.\/[A,B]])(f: scalaz.\/[A,B] =&gt; B)F[B]">map</a><span class="delimiter">(</span><a href="#402101" title="F[scalaz.\/[A,B]]">br</a><span class="delimiter">)</span> <a href="#402121" title="scalaz.\/[A,B]" class="delimiter">{</a> 
            <span class="keyword">case</span> \/-<a href="#1679420" title="B" class="delimiter">(</a><a href="Either.scala.html#50507" title="B" id="402125">b</a><span class="delimiter">)</span> =&gt; <a href="#1679423" title="(x: B)B">b</a>
            <span class="keyword">case</span> _ =&gt; sys.<span title="(message: String)Nothing">error</span><a href="#1679423" title="(x: B)B" class="delimiter">(</a><span title="String(&quot;broken residual handling in a Nondeterminism instance&quot;)" class="string">&quot;broken residual handling in a Nondeterminism instance&quot;</span><span class="delimiter">)</span> 
          <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span class="delimiter">(</span>\/-<a href="#1679436" title="=&gt; scalaz.\/[A,B]" class="delimiter">(</a><a href="Either.scala.html#50507" title="B" id="402138">b</a><span class="delimiter">)</span>, <a href="#1679443" title="(x: Seq[F[scalaz.\/[A,B]]])Some[Seq[F[scalaz.\/[A,B]]]]">Seq</a><a href="#1679436" title="=&gt; Seq[F[scalaz.\/[A,B]]]" class="delimiter">(</a><a title="F[scalaz.\/[A,B]]" id="402153">ar</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
          <a href="Either.scala.html#50499" title="(b: (F[A], B))scalaz.\/-[(F[A], B)]">\/-</a><a href="#1679448" title="(x: scalaz.\/[(A, F[B]),(F[A], B)])scalaz.\/[(A, F[B]),(F[A], B)]" class="delimiter">(</a><span title="(_1: F[A], _2: B)(F[A], B)" class="delimiter">(</span><a href="Monad.scala.html#34563" title="(fa: F[scalaz.\/[A,B]])(f: scalaz.\/[A,B] =&gt; A)F[A]">map</a><span class="delimiter">(</span><a href="#402153" title="F[scalaz.\/[A,B]]">ar</a><span class="delimiter">)</span> <a href="#402173" title="scalaz.\/[A,B]" class="delimiter">{</a> 
            <span class="keyword">case</span> -\/<a href="#1679428" title="A" class="delimiter">(</a><a href="Either.scala.html#50471" title="A" id="402177">a</a><span class="delimiter">)</span> =&gt; <a href="#1679431" title="(x: A)A">a</a>
            <span class="keyword">case</span> _ =&gt; sys.<span title="(message: String)Nothing">error</span><a href="#1679431" title="(x: A)A" class="delimiter">(</a><span title="String(&quot;broken residual handling in a Nondeterminism instance&quot;)" class="string">&quot;broken residual handling in a Nondeterminism instance&quot;</span><span class="delimiter">)</span> 
          <span class="delimiter">}</span>, <a href="#402138" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt; sys.<span title="(message: String)Nothing">error</span><a href="#1679448" title="(x: scalaz.\/[(A, F[B]),(F[A], B)])scalaz.\/[(A, F[B]),(F[A], B)]" class="delimiter">(</a><span title="String(&quot;broken Nondeterminism instance tossed out a residual&quot;)" class="string">&quot;broken Nondeterminism instance tossed out a residual&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  /** 
   * A commutative operation which chooses nondeterministically to obtain 
   * a value from any of the elements of `as`. In the language of posets, this
   * constructs an antichain (a set of elements which are all incomparable) in 
   * the effect poset for this computation.
   * 
   * @return `None`, if the input is empty.  
   */
  <span class="keyword">def</span> <a title="[A](a: Seq[F[A]])Option[F[(A, Seq[F[A]])]]" id="48529">chooseAny</a><span class="delimiter">[</span><a title="" id="48531">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[F[A]]" id="48614">a</a>: <span title="Seq[F[A]]">Seq</span><span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[F[(A, Seq[F[A]])]]">Option</span><span class="delimiter">[</span>F<span class="delimiter">[</span><span class="delimiter">(</span>A, Seq<span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span> = 
    <span title="Option[F[(A, Seq[F[A]])]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#48614" title="Seq[F[A]]">a</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="None.type">None</span>
    <span class="keyword">else</span> <span title="(x: F[(A, Seq[F[A]])])Some[F[(A, Seq[F[A]])]]">Some</span><span class="delimiter">(</span><a href="#48532" title="(head: F[A], tail: Seq[F[A]])F[(A, Seq[F[A]])]">chooseAny</a><span class="delimiter">(</span><a href="#48614" title="Seq[F[A]]">a</a>.<span title="=&gt; F[A]">head</span>, <a href="#48614" title="Seq[F[A]]">a</a>.<span title="=&gt; Seq[F[A]]">tail</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[A](head: F[A], tail: Seq[F[A]])F[(A, Seq[F[A]])]" id="48532">chooseAny</a><span class="delimiter">[</span><a title="" id="48534">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="48623">head</a>: <a href="#23549" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="Seq[F[A]]" id="48624">tail</a>: <span title="Seq[F[A]]">Seq</span><span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23549" title="F[(A, Seq[F[A]])]">F</a><span class="delimiter">[</span><span class="delimiter">(</span>A, Seq<span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>

  // derived functions
  
  /** 
   * Apply a function to the results of `a` and `b`, nondeterminstically 
   * ordering their effects. 
   */
  <span class="keyword">def</span> <a title="[A, B, C](a: F[A], b: F[B])(f: (A, B) =&gt; C)F[C]" id="48535">mapBoth</a><span class="delimiter">[</span><a title="" id="48539">A</a>,<a title="" id="48540">B</a>,<a title="" id="48541">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="402213">a</a>: <a href="#23549" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="F[B]" id="402214">b</a>: <a href="#23549" title="F[B]">F</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="402215">f</a>: <span class="delimiter">(</span>A,B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#23549" title="F[C]">F</a><span class="delimiter">[</span>C<span class="delimiter">]</span> = 
    <a href="Bind.scala.html#34574" title="(fa: F[scalaz.\/[(A, F[B]),(F[A], B)]])(f: scalaz.\/[(A, F[B]),(F[A], B)] =&gt; F[C])F[C]">bind</a><span class="delimiter">(</span><a href="#48524" title="(a: F[A], b: F[B])F[scalaz.\/[(A, F[B]),(F[A], B)]]">choose</a><span class="delimiter">(</span><a href="#402213" title="F[A]">a</a>, <a href="#402214" title="F[B]">b</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#402237" title="scalaz.\/[(A, F[B]),(F[A], B)]" class="delimiter">{</a>
      <span class="keyword">case</span> -\/<a href="#1679482" title="F[C]" class="delimiter">(</a><a href="Either.scala.html#50471" title="=&gt; (A, F[B])" class="delimiter">(</a><a href="#1679483" title="A" id="402244">a</a>,<a href="#1679483" title="F[B]" id="402245">rb</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="Monad.scala.html#34563" title="(fa: F[B])(f: B =&gt; C)F[C]">map</a><span class="delimiter">(</span><a href="#402245" title="F[B]">rb</a><span class="delimiter">)</span><a href="#1679488" title="(x: F[C])F[C]" class="delimiter">(</a><a title="B" id="402259">b</a> =&gt; <a href="#402215" title="(v1: A, v2: B)C">f</a><span class="delimiter">(</span><a href="#402244" title="A">a</a>,<a href="#402259" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span> 
      <span class="keyword">case</span> \/-<a href="#1679482" title="F[C]" class="delimiter">(</a><a href="Either.scala.html#50507" title="=&gt; (F[A], B)" class="delimiter">(</a><a href="#1679485" title="F[A]" id="402270">ra</a>,<a href="#1679485" title="B" id="402271">b</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="Monad.scala.html#34563" title="(fa: F[A])(f: A =&gt; C)F[C]">map</a><span class="delimiter">(</span><a href="#402270" title="F[A]">ra</a><span class="delimiter">)</span><a href="#1679488" title="(x: F[C])F[C]" class="delimiter">(</a><a title="A" id="402285">a</a> =&gt; <a href="#402215" title="(v1: A, v2: B)C">f</a><span class="delimiter">(</span><a href="#402285" title="A">a</a>,<a href="#402271" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span> 
    <span class="delimiter">}</span>

  /** 
   * Obtain results from both `a` and `b`, nondeterministically ordering 
   * their effects. 
   */
  <span class="keyword">def</span> <a title="[A, B](a: F[A], b: F[B])F[(A, B)]" id="48542">both</a><span class="delimiter">[</span><a title="" id="48545">A</a>,<a title="" id="48546">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[A]" id="402290">a</a>: <a href="#23549" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="F[B]" id="402291">b</a>: <a href="#23549" title="F[B]">F</a><span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23549" title="F[(A, B)]">F</a><span class="delimiter">[</span><span class="delimiter">(</span>A,B<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#48535" title="(a: F[A], b: F[B])(f: (A, B) =&gt; (A, B))F[(A, B)]">mapBoth</a><span class="delimiter">(</span><a href="#402290" title="F[A]">a</a>,<a href="#402291" title="F[B]">b</a><span class="delimiter">)</span><span class="delimiter">(</span><span title="(_1: A, _2: B)(A, B)" class="delimiter">(</span><a href="#402307" title="A">_</a>,<a href="#402308" title="B">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    
  /**
   * Nondeterministically gather results from the given sequence of actions. 
   * The resulting list will be arbitrarily reordered, depending on the order
   * results come back in a sequence of calls to `chooseAny`. 
   * 
   * To preserve the order of the output list while allowing nondetermininstic 
   * ordering of effects, use `gather`. 
   */
  <span class="keyword">def</span> <a title="[A](fs: Seq[F[A]])F[List[A]]" id="48547">gatherUnordered</a><span class="delimiter">[</span><a title="" id="48549">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[F[A]]" id="48641">fs</a>: <span title="Seq[F[A]]">Seq</span><span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23549" title="F[List[A]]">F</a><span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    <span title="F[List[A]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#48641" title="Seq[F[A]]">fs</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="Applicative.scala.html#34510" title="(a: =&gt; List[A])F[List[A]]">point</a><span class="delimiter">(</span>List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">else</span> <a href="Bind.scala.html#34574" title="(fa: F[(A, Seq[F[A]])])(f: ((A, Seq[F[A]])) =&gt; F[List[A]])F[List[A]]">bind</a><span class="delimiter">(</span><a href="#48532" title="(head: F[A], tail: Seq[F[A]])F[(A, Seq[F[A]])]">chooseAny</a><span class="delimiter">(</span><a href="#48641" title="Seq[F[A]]">fs</a>.<span title="=&gt; F[A]">head</span>, <a href="#48641" title="Seq[F[A]]">fs</a>.<span title="=&gt; Seq[F[A]]">tail</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#402361" title="(A, Seq[F[A]])" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1679493" title="A" id="402365">a</a>, <a href="#1679493" title="Seq[F[A]]" id="402366">residuals</a><span class="delimiter">)</span> =&gt; 
      <a href="Monad.scala.html#34563" title="(fa: F[List[A]])(f: List[A] =&gt; List[A])F[List[A]]">map</a><span class="delimiter">(</span><a href="#48547" title="(fs: Seq[F[A]])F[List[A]]">gatherUnordered</a><span class="delimiter">(</span><a href="#402366" title="Seq[F[A]]">residuals</a><span class="delimiter">)</span><span class="delimiter">)</span><a href="#1679495" title="(x: F[List[A]])F[List[A]]" class="delimiter">(</a><a href="#402365" title="A">a</a> <a href="#402392" title="(x: A)List[A]">::</a> <a href="#402391" title="List[A]">_</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  /**
   * Nondeterministically gather results from the given sequence of actions. 
   * This function is the nondeterministic analogue of `sequence` and should
   * behave identically to `sequence` so long as there is no interaction between
   * the effects being gathered. However, unlike `sequence`, which decides on
   * a total order of effects, the effects in a `gather` are unordered with 
   * respect to each other.
   * 
   * Although the effects are unordered, we ensure the order of results
   * matches the order of the input sequence. Also see `gatherUnordered`. 
   */
  <span class="keyword">def</span> <a title="[A](fs: Seq[F[A]])F[List[A]]" id="48550">gather</a><span class="delimiter">[</span><a title="" id="48552">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[F[A]]" id="402402">fs</a>: <span title="Seq[F[A]]">Seq</span><span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23549" title="F[List[A]]">F</a><span class="delimiter">[</span>List<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = 
    <a href="Monad.scala.html#34563" title="(fa: F[List[(A, Int)]])(f: List[(A, Int)] =&gt; List[A])F[List[A]]">map</a><span class="delimiter">(</span><a href="#48547" title="(fs: Seq[F[(A, Int)]])F[List[(A, Int)]]">gatherUnordered</a><span class="delimiter">(</span><a href="#402402" title="Seq[F[A]]">fs</a>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[Seq[F[A]],(F[A], Int),Seq[(F[A], Int)]])Seq[(F[A], Int)]">zipWithIndex</span>.<span title="(f: ((F[A], Int)) =&gt; F[(A, Int)])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(F[A], Int)],F[(A, Int)],Seq[F[(A, Int)]]])Seq[F[(A, Int)]]">map</span> <a href="#402468" title="(F[A], Int)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a href="#1679499" title="F[A]" id="402471">f</a>,<a href="#1679499" title="Int" id="402472">i</a><span class="delimiter">)</span> =&gt; <a href="Functor.scala.html#33435" title="(f: F[A], b: Int)F[(A, Int)]">strengthR</a><a href="#1679501" title="(x: F[(A, Int)])F[(A, Int)]" class="delimiter">(</a><a href="#402471" title="F[A]">f</a>,<a href="#402472" title="Int">i</a><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span>
      <a title="List[(A, Int)]" id="402516">ais</a> =&gt; <a href="#402516" title="List[(A, Int)]">ais</a>.<span title="(f: ((A, Int)) =&gt; Int)(implicit ord: scala.math.Ordering[Int])List[(A, Int)]">sortBy</span><span title="scala.math.Ordering.Int.type" class="delimiter">(</span><a href="#402523" title="(A, Int)">_</a>.<span title="=&gt; Int">_2</span><span class="delimiter">)</span>.<span title="(f: ((A, Int)) =&gt; A)(implicit bf: scala.collection.generic.CanBuildFrom[List[(A, Int)],A,List[A]])List[A]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,A,List[A]]" class="delimiter">(</span><a href="#402602" title="(A, Int)">_</a>.<span title="=&gt; A">_1</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** 
   * Nondeterministically sequence `fs`, collecting the results using a `Monoid`. 
   */
  <span class="keyword">def</span> <a title="[A, M](fs: Seq[F[A]])(m: scalaz.Monoid[A])F[A]" id="48553">aggregate</a><span class="delimiter">[</span><a title="" id="48556">A</a>,<a title="" id="48557">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[F[A]]" id="402645">fs</a>: <span title="Seq[F[A]]">Seq</span><span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Monoid[A]" id="402646">m</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[A]">Monoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23549" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = 
    <a href="Monad.scala.html#34563" title="(fa: F[List[A]])(f: List[A] =&gt; A)F[A]">map</a><span class="delimiter">(</span><a href="#48550" title="(fs: Seq[F[A]])F[List[A]]">gather</a><span class="delimiter">(</span><a href="#402645" title="Seq[F[A]]">fs</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#402674" title="List[A]">_</a>.<span title="(z: A)(f: (A, A) =&gt; A)A">foldLeft</span><span class="delimiter">(</span><a href="#402646" title="scalaz.Monoid[A]">m</a>.<a href="Monoid.scala.html#51158" title="=&gt; A">zero</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="402690">a</a>,<a title="A" id="402691">b</a><span class="delimiter">)</span> =&gt; <a href="#402646" title="scalaz.Monoid[A]">m</a>.<a href="Semigroup.scala.html#51147" title="(f1: A, f2: =&gt; A)A">append</a><span class="delimiter">(</span><a href="#402690" title="A">a</a>,<a href="#402691" title="A">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  /** 
   * Nondeterministically sequence `fs`, collecting the results using 
   * a commutative `Monoid`. 
   */
  <span class="keyword">def</span> <a title="[A, M](fs: Seq[F[A]])(m: scalaz.Monoid[A])F[A]" id="48558">aggregateCommutative</a><span class="delimiter">[</span><a title="" id="48561">A</a>,<a title="" id="48562">M</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Seq[F[A]]" id="402696">fs</a>: <span title="Seq[F[A]]">Seq</span><span class="delimiter">[</span>F<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Monoid[A]" id="402697">m</a>: <a href="Monoid.scala.html#12518" title="scalaz.Monoid[A]">Monoid</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23549" title="F[A]">F</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = 
    <a href="Monad.scala.html#34563" title="(fa: F[List[A]])(f: List[A] =&gt; A)F[A]">map</a><span class="delimiter">(</span><a href="#48547" title="(fs: Seq[F[A]])F[List[A]]">gatherUnordered</a><span class="delimiter">(</span><a href="#402696" title="Seq[F[A]]">fs</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#402725" title="List[A]">_</a>.<span title="(z: A)(f: (A, A) =&gt; A)A">foldLeft</span><span class="delimiter">(</span><a href="#402697" title="scalaz.Monoid[A]">m</a>.<a href="Monoid.scala.html#51158" title="=&gt; A">zero</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="A" id="402741">a</a>,<a title="A" id="402742">b</a><span class="delimiter">)</span> =&gt; <a href="#402697" title="scalaz.Monoid[A]">m</a>.<a href="Semigroup.scala.html#51147" title="(f1: A, f2: =&gt; A)A">append</a><span class="delimiter">(</span><a href="#402741" title="A">a</a>,<a href="#402742" title="A">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  ////
  <span class="keyword">val</span> <a title="nondeterminismSyntax extends AnyRef with scalaz.syntax.NondeterminismSyntax[F]" id="48563">nondeterminismSyntax</a> = <a href="#401963" title="scalaz.syntax.NondeterminismSyntax[F]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with scalaz.syntax.NondeterminismSyntax[F]" id="401963">scalaz</a>.syntax.<a href="syntax/NondeterminismSyntax.scala.html#27682" title="scalaz.syntax.NondeterminismSyntax[F]">NondeterminismSyntax</a><span class="delimiter">[</span>F<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Nondeterminism[F]" id="401970">F</a> = <a href="#10886" title="scalaz.Nondeterminism[F]">Nondeterminism</a>.<span class="keyword">this</span> <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="scalaz.Nondeterminism.type" id="10887">Nondeterminism</a> <a href="#10888" title="scalaz.Nondeterminism.type" class="delimiter">{</a>
  @inline <span class="keyword">def</span> <a title="[F[_]](implicit F: scalaz.Nondeterminism[F])scalaz.Nondeterminism[F]" id="72085">apply</a><span class="delimiter">[</span><a title="[_]" id="72087">F</a><span class="delimiter">[</span><a title="" id="72089">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Nondeterminism[F]" id="72088">F</a>: <a href="#10886" title="scalaz.Nondeterminism[F]">Nondeterminism</a><span class="delimiter">[</span>F<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#10886" title="scalaz.Nondeterminism[F]">Nondeterminism</a><span class="delimiter">[</span>F<span class="delimiter">]</span> = <a href="#72088" title="scalaz.Nondeterminism[F]">F</a>

  ////

  ////
<span class="delimiter">}</span>

        </pre>
    </body>
</html>