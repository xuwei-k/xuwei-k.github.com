<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>example/example/WordCount.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz.example

/**
 * Character/Line/Word Count from &quot;The Essence of the Iterator Pattern&quot;.
 *
 * @see [[http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf]]
 */
<span class="keyword">object</span> <a title="scalaz.example.WordCount.type" id="30060">WordCount</a> <a href="#30061" title="scalaz.example.WordCount.type" class="delimiter">{</a>
  <span class="keyword">def</span> <a title="(args: Array[String])Unit" id="855706">main</a><span class="delimiter">(</span><a title="Array[String]" id="855709">args</a>: <span title="Array[String]">Array</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#855707" title="=&gt; Unit">wordCount</a>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="=&gt; Unit" id="855707">wordCount</a> <span class="delimiter">{</span>
    <span class="keyword">import</span> scalaz.typelevel.<span class="delimiter">{</span>AppFunc, AppFuncU, HList, HNil<span class="delimiter">}</span>,
      scalaz.syntax.typelevel.<span title="scalaz.syntax.typelevel.hlist.type">hlist</span>._,
      scalaz.<a href="../../core/package.scala.html#30741" title="scalaz.State.type">State</a>._, scalaz.std.<a href="../../core/std/AnyVal.scala.html#24509" title="scalaz.std.anyVal.type">anyVal</a>._, scalaz.std.<a href="../../core/std/List.scala.html#25475" title="scalaz.std.list.type">list</a>._,
      scalaz.std.<a href="../../core/std/AnyVal.scala.html#25322" title="scalaz.std.boolean.type">boolean</a>.test, scalaz.syntax.<a href="../../core/syntax/Syntax.scala.html#30921" title="scalaz.syntax.equal.type">equal</a>._

    <span class="keyword">val</span> <a title="List[Char]" id="855717">text</a> = <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;the cat in the hat\n sat on the mat\n&quot;</span>.<span title="=&gt; List[Char]">toList</span>

    // To count characters, treat Int as monoidal applicative
    <span class="keyword">val</span> <a title="scalaz.typelevel.Func[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int]" id="855718">countChar</a> = <span title="(f: Char =&gt; Int)(implicit F0: scalaz.Unapply[scalaz.Applicative,Int])scalaz.typelevel.Func[F0.M,scalaz.Applicative,Char,F0.A]">AppFuncU</span> <a href="../../core/Unapply.scala.html#72919" title="(implicit TC0: scalaz.Applicative[[α]Int])scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}" class="delimiter">{</a> <span class="delimiter">(</span>c: <span title="Char">Char</span><span class="delimiter">)</span> =&gt; <span title="Int(1)" class="int">1</span> <span class="delimiter">}</span>

    // To count lines, treat Int as monoidal applicative
    <span class="keyword">val</span> <a title="scalaz.typelevel.Func[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int]" id="855719">countLine</a> = <span title="(f: Char =&gt; Int)(implicit F0: scalaz.Unapply[scalaz.Applicative,Int])scalaz.typelevel.Func[F0.M,scalaz.Applicative,Char,F0.A]">AppFuncU</span> <a href="../../core/Unapply.scala.html#72919" title="(implicit TC0: scalaz.Applicative[[α]Int])scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}" class="delimiter">{</a> <span class="delimiter">(</span>c: <span title="Char">Char</span><span class="delimiter">)</span> =&gt; <a href="../../core/std/AnyVal.scala.html#258605" title="(p: Boolean)Int">test</a><span class="delimiter">(</span><a href="../../core/syntax/EqualSyntax.scala.html#45106" title="(v: Char)(implicit F0: scalaz.Equal[Char])scalaz.syntax.EqualOps[Char]">c</a> <a href="../../core/syntax/EqualSyntax.scala.html#156816" title="(other: Char)Boolean">===</a> <span title="Char('\n')" class="char">'\n'</span><span class="delimiter">)</span> <span class="delimiter">}</span>

    // To count words, we need to detect transitions from whitespace to non-whitespace.
    <span class="keyword">val</span> <a title="scalaz.typelevel.Func[[α]scalaz.Unapply[scalaz.Applicative,scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,Int]]{type M[X] = scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.Applicative,Char,Int]" id="855720">countWord</a> = <span title="(f: Char =&gt; scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,Int])(implicit F0: scalaz.Unapply[scalaz.Applicative,scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,Int]])scalaz.typelevel.Func[F0.M,scalaz.Applicative,Char,F0.A]">AppFuncU</span> <a href="../../core/Unapply.scala.html#72936" title="(implicit TC0: scalaz.Applicative[[ɣ]scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,ɣ]])scalaz.Unapply[scalaz.Applicative,scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,Int]]{type M[X] = scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,X]; type A = Int}" class="delimiter">{</a> <span class="delimiter">(</span>c: <span title="Char">Char</span><span class="delimiter">)</span> =&gt;
      <span class="keyword">for</span> <span class="delimiter">{</span>
        <a title="Boolean" id="858144">x</a> &lt;- <a href="../../core/State.scala.html#45076" title="[S]=&gt; scalaz.State[S,S]">get</a><a href="../../core/StateT.scala.html#70604" title="(f: Boolean =&gt; (Boolean, Boolean))(implicit F: scalaz.Functor[scalaz.Id.Id])scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,(Boolean, Boolean)]" class="delimiter">[</a><span title="Boolean">Boolean</span><span class="delimiter">]</span>
        <a title="Boolean" id="858145">y</a> = <a href="../../core/syntax/EqualSyntax.scala.html#45106" title="(v: Char)(implicit F0: scalaz.Equal[Char])scalaz.syntax.EqualOps[Char]">c</a> <a href="../../core/syntax/EqualSyntax.scala.html#156818" title="(other: Char)Boolean">=/=</a> <span title="Char(' ')" class="char">' '</span>
        <a title="Unit" id="858154">_</a> &lt;- <a href="../../core/State.scala.html#45084" title="(s: Boolean)scalaz.State[Boolean,Unit]">put</a><a href="../../core/StateT.scala.html#70604" title="(f: Unit =&gt; Int)(implicit F: scalaz.Functor[scalaz.Id.Id])scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,Int]" class="delimiter">(</a><a href="#858145" title="Boolean">y</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">yield</span> <a href="../../core/std/AnyVal.scala.html#258605" title="(p: Boolean)Int">test</a><span class="delimiter">(</span><a href="#858145" title="Boolean">y</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#858144" title="Boolean">x</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span title="(g: scalaz.typelevel.Func[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Int,Int])scalaz.typelevel.Func[[α]scalaz.Unapply[scalaz.Applicative,scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,Int]]{type M[X] = scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.Applicative,Char,Int]">@&gt;&gt;&gt;</span> <span title="(f: Int =&gt; Int)(implicit F0: scalaz.Unapply[scalaz.Applicative,Int])scalaz.typelevel.Func[F0.M,scalaz.Applicative,Int,F0.A]">AppFuncU</span> <a href="../../core/Unapply.scala.html#72919" title="(implicit TC0: scalaz.Applicative[[α]Int])scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}" class="delimiter">{</a> <span class="delimiter">(</span>x: <span title="Int">Int</span><span class="delimiter">)</span> =&gt; <a href="#859236" title="Int">x</a> <span class="delimiter">}</span>

    // Compose applicative functions in parallel
    <span class="keyword">val</span> <a title="scalaz.typelevel.HConsFunc[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int,scalaz.typelevel.HConsFunc[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int,scalaz.typelevel.HConsFunc[[α]scalaz.Unapply[scalaz.Applicative,scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,Int]]{type M[X] = scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.Applicative,Char,Int,scalaz.typelevel.HNilFunc[scalaz.Applicative,Char,Int]]]]" id="855721">countAll</a> = <a href="#855718" title="scalaz.typelevel.Func[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int]">countChar</a> <a href="#861155" title="(g: scalaz.typelevel.Func[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int])scalaz.typelevel.HConsFunc[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int,scalaz.typelevel.HConsFunc[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int,scalaz.typelevel.HConsFunc[[α]scalaz.Unapply[scalaz.Applicative,scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,Int]]{type M[X] = scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.Applicative,Char,Int,scalaz.typelevel.HNilFunc[scalaz.Applicative,Char,Int]]]]">::</a> <a href="#855719" title="scalaz.typelevel.Func[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int]">countLine</a> <a href="#861156" title="(g: scalaz.typelevel.Func[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int])scalaz.typelevel.HConsFunc[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M,scalaz.Applicative,Char,Int,scalaz.typelevel.HConsFunc[[α]scalaz.Unapply[scalaz.Applicative,scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,Int]]{type M[X] = scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.Applicative,Char,Int,scalaz.typelevel.HNilFunc[scalaz.Applicative,Char,Int]]]">::</a> <span class="delimiter">(</span><a href="#855720" title="scalaz.typelevel.Func[[α]scalaz.Unapply[scalaz.Applicative,scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,Int]]{type M[X] = scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.Applicative,Char,Int]">countWord</a> <span title="(tail: scalaz.typelevel.HNilFunc[scalaz.Applicative,Char,Int])scalaz.typelevel.HConsFunc[[α]scalaz.Unapply[scalaz.Applicative,scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,Int]]{type M[X] = scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[α]],scalaz.Applicative,Char,Int,scalaz.typelevel.HNilFunc[scalaz.Applicative,Char,Int]]">consA</span> <span title="scalaz.typelevel.AppFunc.type">AppFunc</span>.<span title="[A, B]=&gt; scalaz.typelevel.HNilFunc[scalaz.Applicative,A,B]">HNil</span><span title="scalaz.typelevel.HNilFunc[scalaz.Applicative,Char,Int]" class="delimiter">[</span><span title="Char">Char</span>, <span title="Int">Int</span><span class="delimiter">]</span><span class="delimiter">)</span>
    
    // ... and execute them in a single traversal 
    <span class="keyword">val</span> <a href="#855722" title="scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]" id="855723">charCount</a> <a href="#1692115" title="(list: scalaz.typelevel.HCons[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]],countAll.tail.L#Product[List[Int]]])Option[(scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]], countAll.tail.L#Product[List[Int]])]">::</a> <a href="#855722" title="scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]" id="855724">lineCount</a> <a href="#1692116" title="=&gt; countAll.tail.L#Product[List[Int]]">::</a>  <a href="#855722" title="scalaz.Unapply[scalaz.Applicative,scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,Int]]{type M[X] = scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]]" id="855725">wordCountState</a> <a href="#1692118" title="=&gt; countAll.tail.tail.L#Product[List[Int]]">::</a> <a href="#1692120" title="=&gt; countAll.tail.tail.tail.L#Product[List[Int]]">HNil</a> = <a href="#855721" title="(h: scalaz.typelevel.HListFunc[scalaz.Applicative,Char,Int])scalaz.typelevel.Func[h.L#Product,scalaz.Applicative,Char,Int]">countAll</a> <a href="../../core/std/List.scala.html#45739" title="(value: List[Char])(implicit G: scalaz.Traverse[List], implicit ev: =:=[scalaz.Applicative[countAll.L#Product],scalaz.Applicative[countAll.L#Product]])countAll.L#Product[List[Int]]">traverse</a> <a href="#855717" title="List[Char]">text</a>
    <span class="keyword">val</span> <a title="scalaz.Id.Id[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]]" id="855726">wordCount</a> = <a href="#855725" title="scalaz.Unapply[scalaz.Applicative,scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,Int]]{type M[X] = scalaz.IndexedStateT[scalaz.Id.Id,Boolean,Boolean,X]; type A = Int}#M[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]]">wordCountState</a>.<a href="../../core/StateT.scala.html#70596" title="(initial: Boolean)(implicit F: scalaz.Functor[scalaz.Id.Id])scalaz.Id.Id[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]]">eval</a><a href="../../core/package.scala.html#30683" title="=&gt; scalaz.Traverse1[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]" class="delimiter">(</a><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

    <span title="(x: Any)Unit">println</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%d\t%d\t%d\t&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#855724" title="scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]">lineCount</a>, <a href="#855726" title="scalaz.Id.Id[scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]]">wordCount</a>, <a href="#855723" title="scalaz.Unapply[scalaz.Applicative,Int]{type M[X] = Int; type A = Int}#M[List[Int]]">charCount</a><span class="delimiter">)</span><span class="delimiter">)</span> // 2	9	35
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>