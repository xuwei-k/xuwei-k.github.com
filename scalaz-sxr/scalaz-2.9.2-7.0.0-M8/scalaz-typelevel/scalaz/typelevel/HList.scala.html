<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scalaz-typelevel/scalaz/typelevel/HList.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz
<span class="keyword">package</span> typelevel

<span class="keyword">import</span> <a href="../../../scalaz-core/scalaz/Kleisli.scala.html#23920" title="object scalaz.Kleisli">Kleisli</a>._

<span class="keyword">import</span> <a href="../../../scalaz-core/scalaz/Id.scala.html#11827" title="object scalaz.Id">Id</a>._

<span class="keyword">object</span> <a title="object scalaz.typelevel.HLists" id="39625">HLists</a> <span title="ScalaObject" class="delimiter">{</span>

  <span class="keyword">import</span> <a href="#520245" title="object scalaz.typelevel.HLists.KleisliProof">KleisliProof</a>._

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class IdOps[T &lt;: scalaz.typelevel.package.HList] extends java.lang.Object with ScalaObject" id="520242">IdOps</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="520243">T</a> &lt;: HList<span class="delimiter">]</span><a href="#520242" title="ScalaObject" class="delimiter">(</a><a title="T" id="1477198">list</a>: <a href="#520243" title="T">T</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/** Prepends a value to this list. */</span>
    <span class="keyword">def</span> <a title="[A](elem: A)scalaz.typelevel.package.HCons[A,T]" id="520278">::</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="520280">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="520297">elem</a>: <a href="#520280" title="A">A</a><span class="delimiter">)</span>: <a href="GenericList.scala.html#39615" title="scalaz.typelevel.package.HCons[A,T]">HCons</a><span class="delimiter">[</span>A, T<span class="delimiter">]</span> = <a href="GenericList.scala.html#520617" title="[M[_], H, T &lt;: scalaz.typelevel.GenericList[M]](head: M[H], tail: T)scalaz.typelevel.GenericCons[M,H,T]">GenericCons</a><span title="(head: scalaz.Id.Id[A], tail: T)scalaz.typelevel.GenericCons[scalaz.Id.Id,A,T]" class="delimiter">[</span><a href="../../../scalaz-core/scalaz/Id.scala.html#43732" title="scalaz.Id.Id">Id</a>, <a href="#520280" title="A">A</a>, <a href="#520243" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#520297" title="A">elem</a>, <a href="#1477198" title="T">list</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Composes a list of functions of the shape `A =&gt; F[B]` using
     * [[scalaz.Kleisli]]. This operation can be seen as a fold with `compose`.
     */</span>
    <span class="keyword">def</span> <a title="[M[+_], H, R](implicit ev: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,R,T], implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]" id="520281">compose</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="520285">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="744166">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="520286">H</a>, <a title="&gt;: Nothing &lt;: Any" id="520287">R</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,R,T]" id="744164">ev</a>: <a href="#520247" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,R,T]">KleisliProof</a><span class="delimiter">[</span>Forward, M, H, R, T<span class="delimiter">]</span>, <a title="scalaz.Bind[M]" id="744165">b</a>: <a href="../../../scalaz-core/scalaz/Bind.scala.html#22995" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../scalaz-core/scalaz/Kleisli.scala.html#23919" title="scalaz.Kleisli[M,H,R]">Kleisli</a><span class="delimiter">[</span>M, H, R<span class="delimiter">]</span> =
      <a href="#741219" title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]">ev</a><a href="#744165" title="scalaz.Bind[M]" class="delimiter">(</a><a href="#1477198" title="T">list</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Composes a list of functions of the shape `A =&gt; F[B]` using
     * [[scalaz.Kleisli]]. This operation can be seen as a fold with `andThen`.
     */</span>
    <span class="keyword">def</span> <a title="[M[+_], H, R](implicit ev: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,H,R,T], implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]" id="520288">reverseCompose</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="520292">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="740614">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="520293">H</a>, <a title="&gt;: Nothing &lt;: Any" id="520294">R</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,H,R,T]" id="740612">ev</a>: <a href="#520247" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,H,R,T]">KleisliProof</a><span class="delimiter">[</span>Reverse, M, H, R, T<span class="delimiter">]</span>, <a title="scalaz.Bind[M]" id="740613">b</a>: <a href="../../../scalaz-core/scalaz/Bind.scala.html#22995" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../scalaz-core/scalaz/Kleisli.scala.html#23919" title="scalaz.Kleisli[M,H,R]">Kleisli</a><span class="delimiter">[</span>M, H, R<span class="delimiter">]</span> =
      <a href="#741219" title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]">ev</a><a href="#740613" title="scalaz.Bind[M]" class="delimiter">(</a><a href="#1477198" title="T">list</a><span class="delimiter">)</span>

  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait KleisliProof0 extends java.lang.Object with ScalaObject" id="520244">KleisliProof0</a> <span title="ScalaObject" class="delimiter">{</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[D &lt;: scalaz.typelevel.HLists.KleisliProof.Direction, H, R]=&gt; scalaz.typelevel.HLists.KleisliProof[D,scalaz.Id.Id,H,R,scalaz.typelevel.package.HCons[H =&gt; scalaz.Id.Id[R],scalaz.typelevel.package.HNil]]" id="520299">baseComposeProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scalaz.typelevel.HLists.KleisliProof.Direction" id="520303">D</a> &lt;: Direction, <a title="&gt;: Nothing &lt;: Any" id="520304">H</a>, <a title="&gt;: Nothing &lt;: Any" id="520305">R</a><span class="delimiter">]</span> =
      <a href="#520328" title="[D &lt;: scalaz.typelevel.HLists.KleisliProof.Direction, M[+_], H, R]=&gt; scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]">baseKleisliProof</a><span title="scalaz.typelevel.HLists.KleisliProof[D,scalaz.Id.Id,H,R,scalaz.typelevel.package.HCons[H =&gt; scalaz.Id.Id[R],scalaz.typelevel.package.HNil]]" class="delimiter">[</span><a href="#520303" title="D">D</a>, <a href="../../../scalaz-core/scalaz/Id.scala.html#43732" title="scalaz.Id.Id">Id</a>, <a href="#520304" title="H">H</a>, <a href="#520305" title="R">R</a><span class="delimiter">]</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[OH, IH, R, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,OH,R,scalaz.typelevel.package.HCons[OH =&gt; scalaz.Id.Id[IH],T]]" id="520306">consComposeRevProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="520311">OH</a>, <a title="&gt;: Nothing &lt;: Any" id="520312">IH</a>, <a title="&gt;: Nothing &lt;: Any" id="520313">R</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="520314">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T]" id="741556">proof</a>: <a href="#520247" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T]">KleisliProof</a><span class="delimiter">[</span>Reverse, Id, IH, R, T<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#520337" title="[M[+_], OH, IH, R, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,IH,R,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]">consKleisliRevProof</a><span title="(implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,OH,R,scalaz.typelevel.package.HCons[OH =&gt; scalaz.Id.Id[IH],T]]" class="delimiter">[</span><a href="../../../scalaz-core/scalaz/Id.scala.html#43732" title="scalaz.Id.Id">Id</a>, <a href="#520311" title="OH">OH</a>, <a href="#520312" title="IH">IH</a>, <a href="#520313" title="R">R</a>, <a href="#520314" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#741556" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,scalaz.Id.Id,IH,R,T]">proof</a><span class="delimiter">)</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[H, OR, IR, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,OR,scalaz.typelevel.package.HCons[IR =&gt; scalaz.Id.Id[OR],T]]" id="520315">consComposeProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="520320">H</a>, <a title="&gt;: Nothing &lt;: Any" id="520321">OR</a>, <a title="&gt;: Nothing &lt;: Any" id="520322">IR</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="520323">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T]" id="741550">proof</a>: <a href="#520247" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T]">KleisliProof</a><span class="delimiter">[</span>Forward, Id, H, IR, T<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#520348" title="[M[+_], H, OR, IR, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,IR,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]">consKleisliProof</a><span title="(implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,OR,scalaz.typelevel.package.HCons[IR =&gt; scalaz.Id.Id[OR],T]]" class="delimiter">[</span><a href="../../../scalaz-core/scalaz/Id.scala.html#43732" title="scalaz.Id.Id">Id</a>, <a href="#520320" title="H">H</a>, <a href="#520321" title="OR">OR</a>, <a href="#520322" title="IR">IR</a>, <a href="#520323" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#741550" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,scalaz.Id.Id,H,IR,T]">proof</a><span class="delimiter">)</span>

  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object scalaz.typelevel.HLists.KleisliProof" id="520245">KleisliProof</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#520244" title="scalaz.typelevel.HLists.KleisliProof0">KleisliProof0</a> <span class="delimiter">{</span>

    <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Direction extends java.lang.Object" id="520325">Direction</a>
    <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Forward extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof.Direction with ScalaObject" id="520326">Forward</a> <a href="#520326" title="ScalaObject" class="keyword">extends</a> <a href="#520325" title="scalaz.typelevel.HLists.KleisliProof.Direction">Direction</a>
    <span class="keyword">final</span> <span class="keyword">class</span> <a title="class Reverse extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof.Direction with ScalaObject" id="520327">Reverse</a> <a href="#520327" title="ScalaObject" class="keyword">extends</a> <a href="#520325" title="scalaz.typelevel.HLists.KleisliProof.Direction">Direction</a>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[D &lt;: scalaz.typelevel.HLists.KleisliProof.Direction, M[+_], H, R]=&gt; scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]" id="520328">baseKleisliProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scalaz.typelevel.HLists.KleisliProof.Direction" id="520333">D</a> &lt;: Direction, <a title="[+_]&gt;: Nothing &lt;: Any" id="520334">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="741542">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="520335">H</a>, <a title="&gt;: Nothing &lt;: Any" id="520336">R</a><span class="delimiter">]</span>: <a href="#520247" title="scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]">KleisliProof</a><span class="delimiter">[</span>D, M, H, R, HCons<span class="delimiter">[</span>H =&gt; M<span class="delimiter">[</span>R<span class="delimiter">]</span>, HNil<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#1477687" title="java.lang.Object with scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof[D,M,H,R,scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]]" id="1477687">KleisliProof</a><span class="delimiter">[</span>D, M, H, R, HCons<span class="delimiter">[</span>H =&gt; M<span class="delimiter">[</span>R<span class="delimiter">]</span>, HNil<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(list: scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]" id="1477691">apply</a><span class="delimiter">(</span><a title="scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]" id="1477692">list</a>: <a href="GenericList.scala.html#39615" title="scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]">HCons</a><span class="delimiter">[</span>H =&gt; M<span class="delimiter">[</span>R<span class="delimiter">]</span>, HNil<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bind[M]" id="1477693">b</a>: <a href="../../../scalaz-core/scalaz/Bind.scala.html#22995" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="../../../scalaz-core/scalaz/Kleisli.scala.html#54259" title="(f: H =&gt; M[R])scalaz.Kleisli[M,H,R]">kleisli</a><span class="delimiter">(</span><a href="#1477692" title="scalaz.typelevel.package.HCons[H =&gt; M[R],scalaz.typelevel.package.HNil]">list</a>.<a href="GenericList.scala.html#520182" title="=&gt; H =&gt; M[R]">head</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[M[+_], OH, IH, R, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,IH,R,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]" id="520337">consKleisliRevProof</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="520343">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="741537">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="520344">OH</a>, <a title="&gt;: Nothing &lt;: Any" id="520345">IH</a>, <a title="&gt;: Nothing &lt;: Any" id="520346">R</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="520347">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>
      <span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,IH,R,T]" id="741536">proof</a>: <a href="#520247" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,IH,R,T]">KleisliProof</a><span class="delimiter">[</span>Reverse, M, IH, R, T<span class="delimiter">]</span>
    <span class="delimiter">)</span>: <a href="#520247" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]">KleisliProof</a><span class="delimiter">[</span>Reverse, M, OH, R, HCons<span class="delimiter">[</span>OH =&gt; M<span class="delimiter">[</span>IH<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#1477716" title="java.lang.Object with scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Reverse,M,OH,R,scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]]" id="1477716">KleisliProof</a><span class="delimiter">[</span>Reverse, M, OH, R, HCons<span class="delimiter">[</span>OH =&gt; M<span class="delimiter">[</span>IH<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(list: scalaz.typelevel.package.HCons[OH =&gt; M[IH],T])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,OH,R]" id="1477720">apply</a><span class="delimiter">(</span><a title="scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]" id="1477721">list</a>: <a href="GenericList.scala.html#39615" title="scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]">HCons</a><span class="delimiter">[</span>OH =&gt; M<span class="delimiter">[</span>IH<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bind[M]" id="1477722">b</a>: <a href="../../../scalaz-core/scalaz/Bind.scala.html#22995" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="../../../scalaz-core/scalaz/Kleisli.scala.html#54259" title="(f: OH =&gt; M[IH])scalaz.Kleisli[M,OH,IH]">kleisli</a><span class="delimiter">(</span><a href="#1477721" title="scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]">list</a>.<a href="GenericList.scala.html#520182" title="=&gt; OH =&gt; M[IH]">head</a><span class="delimiter">)</span> <a href="../../../scalaz-core/scalaz/Kleisli.scala.html#111651" title="(k: scalaz.Kleisli[M,IH,R])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,OH,R]">&gt;=&gt;</a> <a href="#741219" title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,IH,R]">proof</a><a href="#1477722" title="scalaz.Bind[M]" class="delimiter">(</a><a href="#1477721" title="scalaz.typelevel.package.HCons[OH =&gt; M[IH],T]">list</a>.<a href="GenericList.scala.html#520184" title="=&gt; T">tail</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[M[+_], H, OR, IR, T &lt;: scalaz.typelevel.package.HList](implicit proof: scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,IR,T])scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]" id="520348">consKleisliProof</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="520354">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="741530">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="520355">H</a>, <a title="&gt;: Nothing &lt;: Any" id="520356">OR</a>, <a title="&gt;: Nothing &lt;: Any" id="520357">IR</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="520358">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>
      <span class="keyword">implicit</span> <a title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,IR,T]" id="741529">proof</a>: <a href="#520247" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,IR,T]">KleisliProof</a><span class="delimiter">[</span>Forward, M, H, IR, T<span class="delimiter">]</span>
    <span class="delimiter">)</span>: <a href="#520247" title="scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]">KleisliProof</a><span class="delimiter">[</span>Forward, M, H, OR, HCons<span class="delimiter">[</span>IR =&gt; M<span class="delimiter">[</span>OR<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">]</span> =
      <a href="#1477793" title="java.lang.Object with scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.typelevel.HLists.KleisliProof[scalaz.typelevel.HLists.KleisliProof.Forward,M,H,OR,scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]]" id="1477793">KleisliProof</a><span class="delimiter">[</span>Forward, M, H, OR, HCons<span class="delimiter">[</span>IR =&gt; M<span class="delimiter">[</span>OR<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(list: scalaz.typelevel.package.HCons[IR =&gt; M[OR],T])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,OR]" id="1477797">apply</a><span class="delimiter">(</span><a title="scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]" id="1477798">list</a>: <a href="GenericList.scala.html#39615" title="scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]">HCons</a><span class="delimiter">[</span>IR =&gt; M<span class="delimiter">[</span>OR<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bind[M]" id="1477799">b</a>: <a href="../../../scalaz-core/scalaz/Bind.scala.html#22995" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="../../../scalaz-core/scalaz/Kleisli.scala.html#54259" title="(f: IR =&gt; M[OR])scalaz.Kleisli[M,IR,OR]">kleisli</a><span class="delimiter">(</span><a href="#1477798" title="scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]">list</a>.<a href="GenericList.scala.html#520182" title="=&gt; IR =&gt; M[OR]">head</a><span class="delimiter">)</span> <a href="../../../scalaz-core/scalaz/Kleisli.scala.html#111663" title="(k: scalaz.Kleisli[M,H,IR])(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,OR]">&lt;=&lt;</a> <a href="#741219" title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,IR]">proof</a><a href="#1477799" title="scalaz.Bind[M]" class="delimiter">(</a><a href="#1477798" title="scalaz.typelevel.package.HCons[IR =&gt; M[OR],T]">list</a>.<a href="GenericList.scala.html#520184" title="=&gt; T">tail</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  @annotation.implicitNotFound<span class="delimiter">(</span>msg = <span class="string">&quot;Could not compose HList ${T} in ${D} direction&quot;</span><span class="delimiter">)</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait KleisliProof[D &lt;: scalaz.typelevel.HLists.KleisliProof.Direction, M[+_], H, R, T &lt;: scalaz.typelevel.package.HList] extends java.lang.Object" id="520247">KleisliProof</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: scalaz.typelevel.HLists.KleisliProof.Direction" id="520248">D</a> &lt;: Direction, <a title="[+_]&gt;: Nothing &lt;: Any" id="520249">M</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="1477869">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="520250">H</a>, <a title="&gt;: Nothing &lt;: Any" id="520251">R</a>, <a title="&gt;: Nothing &lt;: scalaz.typelevel.package.HList" id="520252">T</a> &lt;: HList<span class="delimiter">]</span> <span title="java.lang.Object" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(list: T)(implicit b: scalaz.Bind[M])scalaz.Kleisli[M,H,R]" id="741219">apply</a><span class="delimiter">(</span><a title="T" id="1477632">list</a>: <a href="#520252" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Bind[M]" id="1477633">b</a>: <a href="../../../scalaz-core/scalaz/Bind.scala.html#22995" title="scalaz.Bind[M]">Bind</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../../../scalaz-core/scalaz/Kleisli.scala.html#23919" title="scalaz.Kleisli[M,H,R]">Kleisli</a><span class="delimiter">[</span>M, H, R<span class="delimiter">]</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>


<span class="comment">// vim: expandtab:ts=2:sw=2</span>

        </pre>
    </body>
</html>