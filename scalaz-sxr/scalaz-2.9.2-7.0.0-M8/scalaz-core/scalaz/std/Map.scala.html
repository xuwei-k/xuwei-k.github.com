<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scalaz-core/scalaz/std/Map.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz
<span class="keyword">package</span> std

<span class="keyword">trait</span> <a title="trait MapInstances0 extends java.lang.Object with ScalaObject" id="28124">MapInstances0</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">private</span><span class="delimiter">[</span>std<span class="delimiter">]</span> <span class="keyword">trait</span> <a title="trait MapEqual[K, V] extends java.lang.Object with scalaz.Equal[Map[K,V]] with ScalaObject" id="55668">MapEqual</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="55669">K</a>, <a title="&gt;: Nothing &lt;: Any" id="55670">V</a><span class="delimiter">]</span> <span title="ScalaObject" class="keyword">extends</span> <a href="../Equal.scala.html#20661" title="scalaz.Equal[Map[K,V]]">Equal</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Order[K]" id="457597">OK</a>: <a href="../Order.scala.html#20778" title="scalaz.Order[K]">Order</a><span class="delimiter">[</span>K<span class="delimiter">]</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="=&gt; scalaz.Equal[V]" id="457598">OV</a>: <a href="../Equal.scala.html#20661" title="scalaz.Equal[V]">Equal</a><span class="delimiter">[</span>V<span class="delimiter">]</span>

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(a1: Map[K,V], a2: Map[K,V])Boolean" id="457599">equal</a><span class="delimiter">(</span><a title="Map[K,V]" id="457608">a1</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="Map[K,V]" id="457609">a2</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="keyword">import</span> <a href="Set.scala.html#28059" title="object scalaz.std.set">set</a>._
      <span title="Boolean" class="keyword">if</span> <span class="delimiter">(</span><a href="#457600" title="=&gt; Boolean">equalIsNatural</a><span class="delimiter">)</span> <a href="#457608" title="Map[K,V]">a1</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#457609" title="Map[K,V]">a2</a>
      <span class="keyword">else</span> <a href="../Equal.scala.html#104208" title="[F](implicit F: scalaz.Equal[F])scalaz.Equal[F]">Equal</a><a href="Set.scala.html#55756" title="(implicit F: scalaz.Equal[Set[K]])scalaz.Equal[Set[K]]" class="delimiter">[</a><span title="Set[K]">Set</span><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">]</span>.<a href="../Equal.scala.html#57597" title="(a1: Set[K], a2: Set[K])Boolean">equal</a><span class="delimiter">(</span><a href="#457608" title="Map[K,V]">a1</a>.<span title="=&gt; scala.collection.immutable.Set[K]">keySet</span>, <a href="#457608" title="Map[K,V]">a1</a>.<span title="=&gt; scala.collection.immutable.Set[K]">keySet</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <a href="#457608" title="Map[K,V]">a1</a>.<span title="(p: ((K, V)) =&gt; Boolean)Boolean">forall</span> <a href="#457639" title="Boolean" class="delimiter">{</a>
          <span class="keyword">case</span> <span title="Boolean" class="delimiter">(</span><a title="K" id="457642">k</a>, <a title="V" id="457643">v</a><span class="delimiter">)</span> =&gt; <a href="../Equal.scala.html#104208" title="[F](implicit F: scalaz.Equal[F])scalaz.Equal[F]">Equal</a><a href="#457598" title="(implicit F: scalaz.Equal[V])scalaz.Equal[V]" class="delimiter">[</a><a href="#55670" title="V">V</a><span class="delimiter">]</span>.<a href="../Equal.scala.html#57597" title="(a1: V, a2: V)Boolean">equal</a><span class="delimiter">(</span><a href="#457643" title="V">v</a>, <a href="#457609" title="(key: K)V">a2</a><span class="delimiter">(</span><a href="#457642" title="K">k</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="457600">equalIsNatural</a>: <span title="Boolean">Boolean</span> = <a href="../Equal.scala.html#104208" title="[F](implicit F: scalaz.Equal[F])scalaz.Equal[F]">Equal</a><a href="#457597" title="(implicit F: scalaz.Equal[K])scalaz.Equal[K]" class="delimiter">[</a><a href="#55669" title="K">K</a><span class="delimiter">]</span>.<a href="../Equal.scala.html#57601" title="=&gt; Boolean">equalIsNatural</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="../Equal.scala.html#104208" title="[F](implicit F: scalaz.Equal[F])scalaz.Equal[F]">Equal</a><a href="#457598" title="(implicit F: scalaz.Equal[V])scalaz.Equal[V]" class="delimiter">[</a><a href="#55670" title="V">V</a><span class="delimiter">]</span>.<a href="../Equal.scala.html#57601" title="=&gt; Boolean">equalIsNatural</a>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V](implicit evidence$1: scalaz.Order[K], implicit evidence$2: scalaz.Equal[V])scalaz.Equal[Map[K,V]]" id="101113">mapEqual</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="55674">K</a>: Order, <a title="&gt;: Nothing &lt;: Any" id="55675">V</a>: Equal<span class="delimiter">]</span>: <a href="../Equal.scala.html#20661" title="scalaz.Equal[Map[K,V]]">Equal</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#457675" title="java.lang.Object with MapInstances0.this.MapEqual[K,V]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with MapInstances0.this.MapEqual[K,V]" id="457675">MapEqual</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Order[K]" id="457679">OK</a> = <a href="../Order.scala.html#57574" title="[F](implicit F: scalaz.Order[F])scalaz.Order[F]">Order</a><a href="#101113" title="(implicit F: scalaz.Order[K])scalaz.Order[K]" class="delimiter">[</a><a href="#55674" title="K">K</a><span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Equal[V]" id="457680">OV</a> = <a href="../Equal.scala.html#104208" title="[F](implicit F: scalaz.Equal[F])scalaz.Equal[F]">Equal</a><a href="#101113" title="(implicit F: scalaz.Equal[V])scalaz.Equal[V]" class="delimiter">[</a><a href="#55675" title="V">V</a><span class="delimiter">]</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait MapInstances extends java.lang.Object with scalaz.std.MapInstances0 with ScalaObject" id="28121">MapInstances</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#28124" title="scalaz.std.MapInstances0">MapInstances0</a> <span class="delimiter">{</span>
  <span class="keyword">import</span> syntax.std.<a href="../syntax/std/package.scala.html#40648" title="object scalaz.syntax.std.package.function2">function2</a>._

  <span class="comment">/** Covariant over the value parameter, where `plus` applies the
    * `Last` semigroup to values.
    */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K]=&gt; java.lang.Object with scalaz.Traverse[[V]scala.collection.immutable.Map[K,V]] with scalaz.IsEmpty[[V]scala.collection.immutable.Map[K,V]]" id="55678">mapInstance</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="55680">K</a><span class="delimiter">]</span> = <a href="#97600" title="java.lang.Object with scalaz.Traverse[[V]scala.collection.immutable.Map[K,V]] with scalaz.IsEmpty[[V]scala.collection.immutable.Map[K,V]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Traverse[[V]scala.collection.immutable.Map[K,V]] with scalaz.IsEmpty[[V]scala.collection.immutable.Map[K,V]]" id="97600">Traverse</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> F<span class="delimiter">[</span>V<span class="delimiter">]</span> = Map<span class="delimiter">[</span>K,V<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#F<span class="delimiter">]</span> <span class="keyword">with</span> <a href="../IsEmpty.scala.html#19353" title="scalaz.IsEmpty[[V]scala.collection.immutable.Map[K,V]]">IsEmpty</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> F<span class="delimiter">[</span>V<span class="delimiter">]</span> = Map<span class="delimiter">[</span>K,V<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#F<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[V]=&gt; scala.collection.immutable.Map[K,V]" id="97612">empty</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="97614">V</a><span class="delimiter">]</span> = <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[K,V]" class="delimiter">[</span><a href="#55680" title="K">K</a>, <a href="#97614" title="V">V</a><span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="[V](a: Map[K,V], b: =&gt; Map[K,V])scala.collection.immutable.Map[K,V]" id="97615">plus</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="97617">V</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,V]" id="97683">a</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="=&gt; Map[K,V]" id="97684">b</a>: =&gt; Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#97683" title="Map[K,V]">a</a> <span title="(xs: scala.collection.GenTraversableOnce[(K, V)])scala.collection.immutable.Map[K,V]">++</span> <a href="#97684" title="=&gt; Map[K,V]">b</a>
    <span class="keyword">def</span> <a title="[V](fa: Map[K,V])Boolean" id="97618">isEmpty</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="97620">V</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,V]" id="98091">fa</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#98091" title="Map[K,V]">fa</a>.<span title="=&gt; Boolean">isEmpty</span>

    <span class="keyword">def</span> <a title="[G[_], A, B](m: Map[K,A])(f: A =&gt; G[B])(implicit G: scalaz.Applicative[G])G[Map[K,B]]" id="97621">traverseImpl</a><span class="delimiter">[</span><a title="[_]&gt;: Nothing &lt;: Any" id="97625">G</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="98114">_</a><span class="delimiter">]</span>,<a title="&gt;: Nothing &lt;: Any" id="97626">A</a>,<a title="&gt;: Nothing &lt;: Any" id="97627">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="98111">m</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K,A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; G[B]" id="98112">f</a>: A =&gt; G<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[G]" id="98113">G</a>: <a href="../Applicative.scala.html#20205" title="scalaz.Applicative[G]">Applicative</a><span class="delimiter">[</span>G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#97625" title="G[Map[K,B]]">G</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K,B<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">import</span> <a href="#98113" title="scalaz.Applicative[G]">G</a>.<a href="../Functor.scala.html#43790" title="=&gt; java.lang.Object with scalaz.syntax.FunctorSyntax[G]">functorSyntax</a>._
      <a href="List.scala.html#27759" title="object scalaz.std.list">list</a>.<a href="List.scala.html#55656" title="=&gt; java.lang.Object with scalaz.Traverse[List] with scalaz.MonadPlus[List] with scalaz.Each[List] with scalaz.Index[List] with scalaz.Length[List] with scalaz.Zip[List] with scalaz.Unzip[List] with scalaz.IsEmpty[List]{def empty[A]: List[Nothing]}">listInstance</a>.<a href="../Traverse.scala.html#43794" title="(fa: List[(K, A)])(f: ((K, A)) =&gt; G[(K, B)])(implicit evidence$1: scalaz.Applicative[G])G[List[(K, B)]]">traverseImpl</a><span class="delimiter">(</span><a href="#98111" title="Map[K,A]">m</a>.<span title="=&gt; List[(K, A)]">toList</span><span class="delimiter">)</span><a href="../syntax/FunctorSyntax.scala.html#98166" title="(v: G[List[(K, B)]])scalaz.syntax.FunctorOps[G,List[(K, B)]]" class="delimiter">(</a><a href="#101011" title="G[(K, B)]" class="delimiter">{</a> <span class="keyword">case</span> <span title="G[(K, B)]" class="delimiter">(</span><a title="K" id="101014">k</a>, <a title="A" id="101015">v</a><span class="delimiter">)</span> =&gt; <a href="#98112" title="(v1: A)G[B]">f</a><a href="../syntax/FunctorSyntax.scala.html#98166" title="(v: G[B])scalaz.syntax.FunctorOps[G,B]" class="delimiter">(</a><a href="#101015" title="A">v</a><span class="delimiter">)</span> <a href="../syntax/FunctorSyntax.scala.html#101032" title="(f: B =&gt; (K, B))G[(K, B)]">map</a> <span class="delimiter">(</span><a href="#101014" title="(x: K)ArrowAssoc[K]">k</a> <span title="(y: B)(K, B)">-&gt;</span> <a href="#102263" title="B">_</a><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span> <a href="../syntax/FunctorSyntax.scala.html#101032" title="(f: List[(K, B)] =&gt; scala.collection.immutable.Map[K,B])G[scala.collection.immutable.Map[K,B]]">map</a> <span class="delimiter">(</span><a href="#102664" title="List[(K, B)]">_</a>.<span title="(implicit ev: &lt;:&lt;[(K, B),(K, B)])scala.collection.immutable.Map[K,B]">toMap</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Map union monoid, unifying values with `V`'s `append`. */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V](implicit evidence$3: scalaz.Semigroup[V])scalaz.Monoid[Map[K,V]]" id="97594">mapMonoid</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="55684">K</a>, <a title="&gt;: Nothing &lt;: Any" id="55685">V</a>: Semigroup<span class="delimiter">]</span>: <a href="../Monoid.scala.html#19695" title="scalaz.Monoid[Map[K,V]]">Monoid</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#457696" title="java.lang.Object with scalaz.Monoid[Map[K,V]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Monoid[Map[K,V]]" id="457696">Monoid</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; scala.collection.immutable.Map[K,V]" id="457700">zero</a> = <span title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</span><span title="(elems: (K, V)*)scala.collection.immutable.Map[K,V]" class="delimiter">[</span><a href="#55684" title="K">K</a>, <a href="#55685" title="V">V</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(m1: Map[K,V], m2: =&gt; Map[K,V])Map[K,V]" id="457701">append</a><span class="delimiter">(</span><a title="Map[K,V]" id="457706">m1</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="=&gt; Map[K,V]" id="457707">m2</a>: =&gt; Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="comment">// Eagerly consume m2 as the value is used more than once.</span>
      <span class="keyword">val</span> <a title="Map[K,V]" id="457712">m2Instance</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span> = <a href="#457707" title="=&gt; Map[K,V]">m2</a>
      <span class="comment">// semigroups are not commutative, so order may matter.</span>
      <span class="keyword">val</span> <a href="#457714" title="(Map[K,V], Map[K,V], (V, V) =&gt; V)" class="delimiter">(</a><a href="#457713" title="Map[K,V]" id="457714">from</a>, <a href="#457713" title="Map[K,V]" id="457715">to</a>, <a href="#457713" title="(V, V) =&gt; V" id="457716">semigroup</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <span title="(Map[K,V], Map[K,V], (V, V) =&gt; V)" class="keyword">if</span> <span class="delimiter">(</span><a href="#457706" title="Map[K,V]">m1</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&gt;</span> <a href="#457712" title="Map[K,V]">m2Instance</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span> <span title="(_1: Map[K,V], _2: Map[K,V], _3: (V, V) =&gt; V)(Map[K,V], Map[K,V], (V, V) =&gt; V)" class="delimiter">(</span><a href="#457712" title="Map[K,V]">m2Instance</a>, <a href="#457706" title="Map[K,V]">m1</a>, <a href="../Semigroup.scala.html#58714" title="[F](implicit F: scalaz.Semigroup[F])scalaz.Semigroup[F]">Semigroup</a><a href="#97594" title="(implicit F: scalaz.Semigroup[V])scalaz.Semigroup[V]" class="delimiter">[</a><a href="#55685" title="V">V</a><span class="delimiter">]</span>.<a href="../Semigroup.scala.html#58655" title="(f1: V, f2: =&gt; V)V">append</a><span class="delimiter">(</span><a href="#457728" title="V">_</a>: <a href="#55685" title="V">V</a>, <a href="#457729" title="V">_</a>: <a href="#55685" title="V">V</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="(_1: Map[K,V], _2: Map[K,V], _3: (V, V) =&gt; V)(Map[K,V], Map[K,V], (V, V) =&gt; V)" class="delimiter">(</span><a href="#457706" title="Map[K,V]">m1</a>, <a href="#457712" title="Map[K,V]">m2Instance</a>, <span class="delimiter">(</span><a href="../Semigroup.scala.html#58714" title="[F](implicit F: scalaz.Semigroup[F])scalaz.Semigroup[F]">Semigroup</a><a href="#97594" title="(implicit F: scalaz.Semigroup[V])scalaz.Semigroup[V]" class="delimiter">[</a><a href="#55685" title="V">V</a><span class="delimiter">]</span>.<a href="../Semigroup.scala.html#58655" title="(f1: V, f2: =&gt; V)V">append</a><a href="../syntax/std/Function2Ops.scala.html#56858" title="(f: (V, V) =&gt; V)java.lang.Object with scalaz.syntax.std.Function2Ops[V,V,V]" class="delimiter">(</a><a href="#457754" title="V">_</a>: <a href="#55685" title="V">V</a>, <a href="#457755" title="V">_</a>: <a href="#55685" title="V">V</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../syntax/std/Function2Ops.scala.html#101086" title="=&gt; (V, V) =&gt; V">flip</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <a href="#457714" title="Map[K,V]">from</a>.<span title="(z: Map[K,V])(op: (Map[K,V], (K, V)) =&gt; Map[K,V])Map[K,V]">foldLeft</span><span class="delimiter">(</span><a href="#457715" title="Map[K,V]">to</a><span class="delimiter">)</span> <a href="#457813" title="Map[K,V]" class="delimiter">{</a>
        <span class="keyword">case</span> <span title="scala.collection.immutable.Map[K,V]" class="delimiter">(</span><a title="Map[K,V]" id="457823">to</a>, <span class="delimiter">(</span><a title="K" id="457826">k</a>, <a title="V" id="457827">v</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#457823" title="Map[K,V]">to</a> <span title="(kv: (K, V))scala.collection.immutable.Map[K,V]">+</span> <span class="delimiter">(</span><a href="#457826" title="(x: K)ArrowAssoc[K]">k</a> <span title="(y: V)(K, V)">-&gt;</span> <a href="#457823" title="Map[K,V]">to</a>.<span title="(key: K)Option[V]">get</span><span class="delimiter">(</span><a href="#457826" title="K">k</a><span class="delimiter">)</span>.<span title="(f: V =&gt; V)Option[V]">map</span><span class="delimiter">(</span><a href="#457716" title="(v1: V, v2: V)V">semigroup</a><span class="delimiter">(</span><a href="#457906" title="V">_</a>, <a href="#457827" title="V">v</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(default: =&gt; V)V">getOrElse</span><span class="delimiter">(</span><a href="#457827" title="V">v</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V](implicit K: scalaz.Show[K], implicit V: scalaz.Show[V])scalaz.Show[Map[K,V]]" id="55686">mapShow</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="55689">K</a>, <a title="&gt;: Nothing &lt;: Any" id="55690">V</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Show[K]" id="97589">K</a>: <a href="../Show.scala.html#19311" title="scalaz.Show[K]">Show</a><span class="delimiter">[</span>K<span class="delimiter">]</span>, <a title="scalaz.Show[V]" id="97590">V</a>: <a href="../Show.scala.html#19311" title="scalaz.Show[V]">Show</a><span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Show.scala.html#19311" title="scalaz.Show[Map[K,V]]">Show</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="../Show.scala.html#19312" title="object scalaz.Show">Show</a>.<a href="../Show.scala.html#141826" title="(f: Map[K,V] =&gt; scalaz.Cord)scalaz.Show[Map[K,V]]">show</a><span class="delimiter">(</span><a title="Map[K,V]" id="457932">m</a> =&gt; <span title="java.lang.String(&quot;Map[&quot;)" class="string">&quot;Map[&quot;</span> <a href="../Cord.scala.html#91640" title="(x: =&gt; String)scalaz.Cord">+:</a>
                <a href="../Cord.scala.html#14899" title="object scalaz.Cord">Cord</a>.<a href="../Cord.scala.html#93887" title="(sep: scalaz.Cord, as: scalaz.Cord*)scalaz.Cord">mkCord</a><span class="delimiter">(</span><a href="../Cord.scala.html#93879" title="implicit scalaz.Cord.stringToCord : (s: String)scalaz.Cord" class="string">&quot;, &quot;</a>, <a href="#457932" title="Map[K,V]">m</a>.<span title="=&gt; Seq[(K, V)]">toSeq</span>.<span title="=&gt; java.lang.Object with scala.collection.SeqView[(K, V),Seq[(K, V)]]">view</span>.<span title="(f: ((K, V)) =&gt; scalaz.Cord)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.SeqView[(K, V),Seq[(K, V)]],scalaz.Cord,scala.collection.SeqView[scalaz.Cord,Seq[_]]])scala.collection.SeqView[scalaz.Cord,Seq[_]]">map</span><a href="#458913" title="scalaz.Cord" class="delimiter">{</a>
                  <span class="keyword">case</span> <span title="scalaz.Cord" class="delimiter">(</span><a title="K" id="458916">k</a>, <a title="V" id="458917">v</a><span class="delimiter">)</span> =&gt; <a href="../Cord.scala.html#93882" title="(as: scalaz.Cord*)scalaz.Cord">Cord</a><span class="delimiter">(</span><a href="#97589" title="scalaz.Show[K]">K</a> <a href="../Show.scala.html#66266" title="(f: K)scalaz.Cord">show</a> <a href="#458916" title="K">k</a>, <a href="../Cord.scala.html#93879" title="implicit scalaz.Cord.stringToCord : (s: String)scalaz.Cord" class="string">&quot;-&gt;&quot;</a>, <a href="#97590" title="scalaz.Show[V]">V</a> <a href="../Show.scala.html#66266" title="(f: V)scalaz.Cord">show</a> <a href="#458917" title="V">v</a><span class="delimiter">)</span>
                <span class="delimiter">}</span>: _*<span class="delimiter">)</span> <a href="../Cord.scala.html#91639" title="(x: =&gt; String)scalaz.Cord">:+</a> <span title="java.lang.String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[K, V](implicit evidence$4: scalaz.Order[K], implicit evidence$5: scalaz.Order[V])scalaz.Order[Map[K,V]]" id="97377">mapOrder</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="55694">K</a>: Order, <a title="&gt;: Nothing &lt;: Any" id="55695">V</a>: Order<span class="delimiter">]</span>: <a href="../Order.scala.html#20778" title="scalaz.Order[Map[K,V]]">Order</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#459502" title="java.lang.Object with scalaz.Order[Map[K,V]] with MapInstances.this.MapEqual[K,V]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Order[Map[K,V]] with MapInstances.this.MapEqual[K,V]" id="459502">Order</a><span class="delimiter">[</span>Map<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span> <span class="keyword">with</span> <a href="#55668" title="MapInstances.this.MapEqual[K,V]">MapEqual</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Order[K]" id="459514">OK</a> = <a href="../Order.scala.html#57574" title="[F](implicit F: scalaz.Order[F])scalaz.Order[F]">Order</a><a href="#97377" title="(implicit F: scalaz.Order[K])scalaz.Order[K]" class="delimiter">[</a><a href="#55694" title="K">K</a><span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="=&gt; scalaz.Equal[V]" id="459515">OV</a> = <a href="../Equal.scala.html#104208" title="[F](implicit F: scalaz.Equal[F])scalaz.Equal[F]">Equal</a><a href="#97377" title="(implicit F: scalaz.Equal[V])scalaz.Equal[V]" class="delimiter">[</a><a href="#55695" title="V">V</a><span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="(x: Map[K,V], y: Map[K,V])scalaz.Ordering" id="459516">order</a><span class="delimiter">(</span><a title="Map[K,V]" id="459534">x</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, <a title="Map[K,V]" id="459535">y</a>: <span title="Map[K,V]">Map</span><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../Ordering.scala.html#12459" title="scalaz.Ordering">Ordering</a> = <span class="delimiter">{</span>
      <span class="keyword">import</span> collection.immutable.IndexedSeq
      <span class="keyword">import</span> <a href="IndexedSeq.scala.html#27528" title="object scalaz.std.indexedSeq">indexedSeq</a>._
      <span class="keyword">import</span> <a href="Tuple.scala.html#28266" title="object scalaz.std.tuple">tuple</a>._
      <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scala.math.Ordering[K]" id="459544">ok</a> = <a href="../Order.scala.html#57574" title="[F](implicit F: scalaz.Order[F])scalaz.Order[F]">Order</a><a href="#97377" title="(implicit F: scalaz.Order[K])scalaz.Order[K]" class="delimiter">[</a><a href="#55694" title="K">K</a><span class="delimiter">]</span>.<a href="../Order.scala.html#57620" title="=&gt; scala.math.Ordering[K]">toScalaOrdering</a>
      <a href="../Semigroup.scala.html#58714" title="[F](implicit F: scalaz.Semigroup[F])scalaz.Semigroup[F]">Semigroup</a><a href="../Ordering.scala.html#57658" title="(implicit F: scalaz.Semigroup[scalaz.Ordering])scalaz.Semigroup[scalaz.Ordering]" class="delimiter">[</a><a href="../Ordering.scala.html#12459" title="scalaz.Ordering">Ordering</a><span class="delimiter">]</span>
       .<a href="../Semigroup.scala.html#58655" title="(f1: scalaz.Ordering, f2: =&gt; scalaz.Ordering)scalaz.Ordering">append</a><span class="delimiter">(</span><a href="../Order.scala.html#57574" title="[F](implicit F: scalaz.Order[F])scalaz.Order[F]">Order</a><a href="../Order.scala.html#57579" title="(implicit F: scalaz.Order[Int])scalaz.Order[Int]" class="delimiter">[</a><span title="Int">Int</span><span class="delimiter">]</span>.<a href="../Order.scala.html#57609" title="(x: Int, y: Int)scalaz.Ordering">order</a><span class="delimiter">(</span><a href="#459534" title="Map[K,V]">x</a>.<span title="=&gt; Int">size</span>, <a href="#459535" title="Map[K,V]">y</a>.<span title="=&gt; Int">size</span><span class="delimiter">)</span>,
               <a href="../Order.scala.html#57574" title="[F](implicit F: scalaz.Order[F])scalaz.Order[F]">Order</a><a href="IndexedSeq.scala.html#147820" title="(implicit F: scalaz.Order[scala.collection.immutable.IndexedSeq[(K, V)]])scalaz.Order[scala.collection.immutable.IndexedSeq[(K, V)]]" class="delimiter">[</a><span title="scala.collection.immutable.IndexedSeq[(K, V)]">IndexedSeq</span><span class="delimiter">[</span><span class="delimiter">(</span>K, V<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span>
                .<a href="../Order.scala.html#57609" title="(x: scala.collection.immutable.IndexedSeq[(K, V)], y: scala.collection.immutable.IndexedSeq[(K, V)])scalaz.Ordering">order</a><span class="delimiter">(</span><a href="#459534" title="Map[K,V]">x</a>.<span title="scala.collection.immutable.IndexedSeq[(K, V)]">toIndexedSeq</span>.<span title="(f: ((K, V)) =&gt; K)(implicit ord: scala.math.Ordering[K])scala.collection.immutable.IndexedSeq[(K, V)]">sortBy</span><a href="#459544" title="scala.math.Ordering[K]" class="delimiter">(</a><span class="delimiter">(</span><a href="#461463" title="(K, V)">_</a>:<span title="(K, V)" class="delimiter">(</span>K,V<span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; K">_1</span><span class="delimiter">)</span>,
                       <a href="#459535" title="Map[K,V]">y</a>.<span title="scala.collection.immutable.IndexedSeq[(K, V)]">toIndexedSeq</span>.<span title="(f: ((K, V)) =&gt; K)(implicit ord: scala.math.Ordering[K])scala.collection.immutable.IndexedSeq[(K, V)]">sortBy</span><a href="#459544" title="scala.math.Ordering[K]" class="delimiter">(</a><span class="delimiter">(</span><a href="#461702" title="(K, V)">_</a>:<span title="(K, V)" class="delimiter">(</span>K,V<span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; K">_1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait MapFunctions extends java.lang.Object with ScalaObject" id="28466">MapFunctions</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="comment">/** Vary the value of `m get k`. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[K, A](m: Map[K,A], k: K)(f: Option[A] =&gt; Option[A])Map[K,A]" id="461935">alter</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461938">K</a>, <a title="&gt;: Nothing &lt;: Any" id="461939">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="461982">m</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span>, <a title="K" id="461983">k</a>: <a href="#461938" title="K">K</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="Option[A] =&gt; Option[A]" id="461984">f</a>: <span class="delimiter">(</span>Option<span class="delimiter">[</span>A<span class="delimiter">]</span> =&gt; Option<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span> =
    <a href="#461984" title="(v1: Option[A])Option[A]">f</a><span class="delimiter">(</span><a href="#461982" title="Map[K,A]">m</a> <span title="(key: K)Option[A]">get</span> <a href="#461983" title="K">k</a><span class="delimiter">)</span> <span title="(f: A =&gt; scala.collection.immutable.Map[K,A])Option[scala.collection.immutable.Map[K,A]]">map</span> <span class="delimiter">(</span><a href="#461982" title="Map[K,A]">m</a>.<span title="(key: K, value: A)scala.collection.immutable.Map[K,A]">updated</span><span class="delimiter">(</span><a href="#461983" title="K">k</a>, <a href="#461996" title="A">_</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(default: =&gt; scala.collection.immutable.Map[K,A])scala.collection.immutable.Map[K,A]">getOrElse</span> <span class="delimiter">(</span><a href="#461982" title="Map[K,A]">m</a> <span title="(key: K)scala.collection.immutable.Map[K,A]">-</span> <a href="#461983" title="K">k</a><span class="delimiter">)</span>

  <span class="comment">/** Like `intersectWith`, but tell `f` about the key. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[K, A, B, C](m1: Map[K,A], m2: Map[K,B])(f: (K, A, B) =&gt; C)Map[K,C]" id="461940">intersectWithKey</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461945">K</a>,<a title="&gt;: Nothing &lt;: Any" id="461946">A</a>,<a title="&gt;: Nothing &lt;: Any" id="461947">B</a>,<a title="&gt;: Nothing &lt;: Any" id="461948">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="462047">m1</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span>, <a title="Map[K,B]" id="462048">m2</a>: <span title="Map[K,B]">Map</span><span class="delimiter">[</span>K, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(K, A, B) =&gt; C" id="462049">f</a>: <span class="delimiter">(</span>K, A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <span title="Map[K,C]">Map</span><span class="delimiter">[</span>K, C<span class="delimiter">]</span> = <a href="#462047" title="Map[K,A]">m1</a> <span title="(pf: PartialFunction[(K, A),(K, C)])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[K,A],(K, C),Map[K,C]])Map[K,C]">collect</span> <a href="#462074" title="(K, C)" class="delimiter">{</a>
    <span class="keyword">case</span> <span title="(K, C)" class="delimiter">(</span><a title="K" id="462077">k</a>, <a title="A" id="462078">v</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#462048" title="Map[K,B]">m2</a> <span title="(key: K)Boolean">contains</span> <a href="#462077" title="K">k</a> =&gt; <a href="#462077" title="(x: K)ArrowAssoc[K]">k</a> <span title="(y: C)(K, C)">-&gt;</span> <a href="#462049" title="(v1: K, v2: A, v3: B)C">f</a><span class="delimiter">(</span><a href="#462077" title="K">k</a>, <a href="#462078" title="A">v</a>, <a href="#462048" title="(key: K)B">m2</a><span class="delimiter">(</span><a href="#462077" title="K">k</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Collect only elements with matching keys, joining their
    * associated values with `f`.
    */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[K, A, B, C](m1: Map[K,A], m2: Map[K,B])(f: (A, B) =&gt; C)Map[K,C]" id="461949">intersectWith</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461954">K</a>,<a title="&gt;: Nothing &lt;: Any" id="461955">A</a>,<a title="&gt;: Nothing &lt;: Any" id="461956">B</a>,<a title="&gt;: Nothing &lt;: Any" id="461957">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="462152">m1</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span>, <a title="Map[K,B]" id="462153">m2</a>: <span title="Map[K,B]">Map</span><span class="delimiter">[</span>K, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="462154">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <span title="Map[K,C]">Map</span><span class="delimiter">[</span>K, C<span class="delimiter">]</span> =
    <a href="#461940" title="(m1: Map[K,A], m2: Map[K,B])(f: (K, A, B) =&gt; C)Map[K,C]">intersectWithKey</a><span class="delimiter">(</span><a href="#462152" title="Map[K,A]">m1</a>, <a href="#462153" title="Map[K,B]">m2</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="K" id="462204">_</a>, <a title="A" id="462205">x</a>, <a title="B" id="462206">y</a><span class="delimiter">)</span> =&gt; <a href="#462154" title="(v1: A, v2: B)C">f</a><span class="delimiter">(</span><a href="#462205" title="A">x</a>, <a href="#462206" title="B">y</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Exchange keys of `m` according to `f`.  Result may be smaller if
    * `f` maps two or more `K`s to the same `K2`, in which case the
    * resulting associated value is an arbitrary choice.
    */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[K, K2, A](m: Map[K,A])(f: K =&gt; K2)Map[K2,A]" id="461958">mapKeys</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461962">K</a>, <a title="&gt;: Nothing &lt;: Any" id="461963">K2</a>, <a title="&gt;: Nothing &lt;: Any" id="461964">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="462211">m</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="K =&gt; K2" id="462212">f</a>: K =&gt; K2<span class="delimiter">)</span>: <span title="Map[K2,A]">Map</span><span class="delimiter">[</span>K2, A<span class="delimiter">]</span> =
    <a href="#462211" title="Map[K,A]">m</a> <span title="(f: ((K, A)) =&gt; (K2, A))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[K,A],(K2, A),Map[K2,A]])Map[K2,A]">map</span> <a href="#462240" title="(K2, A)" class="delimiter">{</a><span class="keyword">case</span> <span title="(K2, A)" class="delimiter">(</span><a title="K" id="462243">k</a>, <a title="A" id="462244">v</a><span class="delimiter">)</span> =&gt; <a href="#462212" title="(v1: K)K2">f</a><span title="(x: K2)ArrowAssoc[K2]" class="delimiter">(</span><a href="#462243" title="K">k</a><span class="delimiter">)</span> <span title="(y: A)(K2, A)">-&gt;</span> <a href="#462244" title="A">v</a><span class="delimiter">}</span>

  <span class="comment">/** Like `unionWith`, but telling `f` about the key. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[K, A](m1: Map[K,A], m2: Map[K,A])(f: (K, A, A) =&gt; A)Map[K,A]" id="461965">unionWithKey</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461968">K</a>,<a title="&gt;: Nothing &lt;: Any" id="461969">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="462296">m1</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span>, <a title="Map[K,A]" id="462297">m2</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(K, A, A) =&gt; A" id="462298">f</a>: <span class="delimiter">(</span>K, A, A<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.Map[K,A]" id="462303">diff</a> = <a href="#462297" title="Map[K,A]">m2</a> <span title="(xs: scala.collection.GenTraversableOnce[K])scala.collection.immutable.Map[K,A]">--</span> <a href="#462296" title="Map[K,A]">m1</a>.<span title="=&gt; scala.collection.immutable.Set[K]">keySet</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.Map[K,A]" id="462304">aug</a> = <a href="#462296" title="Map[K,A]">m1</a> <span title="(f: ((K, A)) =&gt; (K, A))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[K,A],(K, A),scala.collection.immutable.Map[K,A]])scala.collection.immutable.Map[K,A]">map</span> <a href="#462322" title="(K, A)" class="delimiter">{</a>
      <span class="keyword">case</span> <span title="(K, A)" class="delimiter">(</span><a title="K" id="462325">k</a>, <a title="A" id="462326">v</a><span class="delimiter">)</span> =&gt; <span title="(K, A)" class="keyword">if</span> <span class="delimiter">(</span><a href="#462297" title="Map[K,A]">m2</a> <span title="(key: K)Boolean">contains</span> <a href="#462325" title="K">k</a><span class="delimiter">)</span> <a href="#462325" title="(x: K)ArrowAssoc[K]">k</a> <span title="(y: A)(K, A)">-&gt;</span> <a href="#462298" title="(v1: K, v2: A, v3: A)A">f</a><span class="delimiter">(</span><a href="#462325" title="K">k</a>, <a href="#462326" title="A">v</a>, <a href="#462297" title="(key: K)A">m2</a><span class="delimiter">(</span><a href="#462325" title="K">k</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <span title="(_1: K, _2: A)(K, A)" class="delimiter">(</span><a href="#462325" title="K">k</a>, <a href="#462326" title="A">v</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#462304" title="scala.collection.immutable.Map[K,A]">aug</a> <span title="(xs: scala.collection.GenTraversableOnce[(K, A)])scala.collection.immutable.Map[K,A]">++</span> <a href="#462303" title="scala.collection.immutable.Map[K,A]">diff</a>
  <span class="delimiter">}</span>

  <span class="comment">/** Union, resolving collisions with `f`, where the first arg is
    * guaranteed to be from `m1`, the second from `m2`.
    *
    * @note iff `f` gives rise to a [[scalaz.Semigroup]], so does
    *       `unionWith(_, _)(f)`.*/</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[K, A](m1: Map[K,A], m2: Map[K,A])(f: (A, A) =&gt; A)Map[K,A]" id="461970">unionWith</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461973">K</a>,<a title="&gt;: Nothing &lt;: Any" id="461974">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="462583">m1</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span>, <a title="Map[K,A]" id="462584">m2</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, A) =&gt; A" id="462585">f</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span> =
    <a href="#461965" title="(m1: Map[K,A], m2: Map[K,A])(f: (K, A, A) =&gt; A)Map[K,A]">unionWithKey</a><span class="delimiter">(</span><a href="#462583" title="Map[K,A]">m1</a>, <a href="#462584" title="Map[K,A]">m2</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="K" id="462617">_</a>, <a title="A" id="462618">x</a>, <a title="A" id="462619">y</a><span class="delimiter">)</span> =&gt; <a href="#462585" title="(v1: A, v2: A)A">f</a><span class="delimiter">(</span><a href="#462618" title="A">x</a>, <a href="#462619" title="A">y</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** As with `Map.updated`, but resolve a collision with `f`.  The
    * first argument is guaranteed to be from `m1`.
    */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[K, A](m1: Map[K,A], k: K, v: A)(f: (A, A) =&gt; A)Map[K,A]" id="461975">insertWith</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="461978">K</a>,<a title="&gt;: Nothing &lt;: Any" id="461979">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[K,A]" id="462622">m1</a>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span>, <a title="K" id="462623">k</a>: <a href="#461978" title="K">K</a>, <a title="A" id="462624">v</a>: <a href="#461979" title="A">A</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, A) =&gt; A" id="462625">f</a>: <span class="delimiter">(</span>A, A<span class="delimiter">)</span> =&gt; A<span class="delimiter">)</span>: <span title="Map[K,A]">Map</span><span class="delimiter">[</span>K, A<span class="delimiter">]</span> =
    <span title="Map[K,A]" class="keyword">if</span><span class="delimiter">(</span><a href="#462622" title="Map[K,A]">m1</a> <span title="(key: K)Boolean">contains</span> <a href="#462623" title="K">k</a><span class="delimiter">)</span> <a href="#462622" title="Map[K,A]">m1</a> <span title="(kv: (K, A))scala.collection.immutable.Map[K,A]">+</span> <span class="delimiter">(</span><a href="#462623" title="(x: K)ArrowAssoc[K]">k</a> <span title="(y: A)(K, A)">-&gt;</span> <a href="#462625" title="(v1: A, v2: A)A">f</a><span class="delimiter">(</span><a href="#462622" title="(key: K)A">m1</a><span class="delimiter">(</span><a href="#462623" title="K">k</a><span class="delimiter">)</span>, <a href="#462624" title="A">v</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#462622" title="Map[K,A]">m1</a> <span title="(kv: (K, A))scala.collection.immutable.Map[K,A]">+</span> <span class="delimiter">(</span><a href="#462623" title="(x: K)ArrowAssoc[K]">k</a> <span title="(y: A)(K, A)">-&gt;</span> <a href="#462624" title="A">v</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="object scalaz.std.map" id="27906">map</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#28121" title="scalaz.std.MapInstances">MapInstances</a> <span class="keyword">with</span> <a href="#28466" title="scalaz.std.MapFunctions">MapFunctions</a>


        </pre>
    </body>
</html>