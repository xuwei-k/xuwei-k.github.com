<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scalaz-core/scalaz/Free.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="keyword">package</span> scalaz

<span class="keyword">import</span> annotation.tailrec
<span class="keyword">import</span> <a href="#23599" title="object scalaz.Free">Free</a>._
<span class="keyword">import</span> std.<a href="std/Function.scala.html#27447" title="object scalaz.std.function">function</a>._
<span class="keyword">import</span> std.<a href="std/Tuple.scala.html#28266" title="object scalaz.std.tuple">tuple</a>._

<span class="comment">// TODO report compiler bug when this appears just above FreeInstances:</span>
<span class="comment">//      &quot;java.lang.Error: typeConstructor inapplicable for &lt;none&gt;&quot;</span>
<span class="keyword">object</span> <a title="object scalaz.Free" id="23599">Free</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#23145" title="scalaz.FreeFunctions">FreeFunctions</a> <span class="keyword">with</span> <a href="#21114" title="scalaz.FreeInstances">FreeInstances</a> <span class="delimiter">{</span>

  <span class="comment">/** Return from the computation with the given value. */</span>
  case <span class="keyword">class</span> <a title="class Return[S[+_], +A] extends scalaz.Free[S,A] with ScalaObject with Product with Serializable" id="285840">Return</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="284906">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="285834">_</a><span class="delimiter">]</span>: Functor, +<a title="&gt;: Nothing &lt;: Any" id="284907">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="285832">a</a>: <a href="#284907" title="A">A</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#23598" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span>

  <span class="comment">/** Suspend the computation with the given suspension. */</span>
  case <span class="keyword">class</span> <a title="class Suspend[S[+_], +A] extends scalaz.Free[S,A] with ScalaObject with Product with Serializable" id="285828">Suspend</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="285310">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="285822">_</a><span class="delimiter">]</span>: Functor, +<a title="&gt;: Nothing &lt;: Any" id="285311">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="285820">a</a>: <a href="#285310" title="S[scalaz.Free[S,A]]">S</a><span class="delimiter">[</span>Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#23598" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span>

  <span class="comment">/** Call a subroutine and continue with the given function. */</span>
  case <span class="keyword">class</span> <a title="class Gosub[S[+_], A, +B] extends scalaz.Free[S,B] with ScalaObject with Product with Serializable" id="285816">Gosub</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="285742">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="285808">_</a><span class="delimiter">]</span>: Functor, <a title="&gt;: Nothing &lt;: Any" id="285743">A</a>, +<a title="&gt;: Nothing &lt;: Any" id="285744">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="() =&gt; scalaz.Free[S,A]" id="285805">a</a>: <span class="delimiter">(</span><span class="delimiter">)</span> =&gt; Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span>,
                                          <a title="A =&gt; scalaz.Free[S,B]" id="285806">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#23598" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span>

  <span class="comment">/** A computation that can be stepped through, suspended, and paused */</span>
  <span class="keyword">type</span> <a title="[+A]scalaz.Free[Function0,A]" id="54423">Trampoline</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="54424">A</a><span class="delimiter">]</span> = <a href="#23598" title="scalaz.Free[Function0,A]">Free</a><span class="delimiter">[</span>Function0, A<span class="delimiter">]</span>

  <span class="comment">/** A computation that produces values of type `A`, eventually resulting in a value of type `B`. */</span>
  <span class="keyword">type</span> <a title="[A, +B]scalaz.Free[[+x](A, x),B]" id="54425">Source</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="54426">A</a>, +<a title="&gt;: Nothing &lt;: Any" id="54427">B</a><span class="delimiter">]</span> = <a href="#23598" title="scalaz.Free[[+x](A, x),B]">Free</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>A, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#f, B<span class="delimiter">]</span>

  <span class="comment">/** A computation that accepts values of type `A`, eventually resulting in a value of type `B`.
    * Note the similarity to an [[scalaz.iteratee.Iteratee]].
    */</span>
  <span class="keyword">type</span> <a title="[A, +B]scalaz.Free[[+x]=&gt; A =&gt; x,B]" id="54428">Sink</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="54429">A</a>, +<a title="&gt;: Nothing &lt;: Any" id="54430">B</a><span class="delimiter">]</span> = <a href="#23598" title="scalaz.Free[[+x]=&gt; A =&gt; x,B]">Free</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; A<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#f, B<span class="delimiter">]</span>
<span class="delimiter">}</span>

<span class="comment">/** A free operational monad for some functor `S`. Binding is done using the heap instead of the stack,
  * allowing tail-call elimination. */</span>
<span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Free[S[+_], +A] extends java.lang.Object with ScalaObject" id="23598">Free</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="26475">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="285841">_</a><span class="delimiter">]</span>, +<a title="&gt;: Nothing &lt;: Any" id="26476">A</a><span class="delimiter">]</span><a href="#23598" title="ScalaObject" class="delimiter">(</a><span class="keyword">implicit</span> <a title="scalaz.Functor[S]" id="284532">S</a>: <a href="Functor.scala.html#14874" title="scalaz.Functor[S]">Functor</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B](f: A =&gt; B)scalaz.Free[S,B]" id="115534">map</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="115536">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="115604">f</a>: A =&gt; B<span class="delimiter">)</span>: <a href="#23598" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> =
    <a href="#115540" title="(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]">flatMap</a><span class="delimiter">(</span><a title="A" id="285850">a</a> =&gt; <a href="#285840" title="(a: B)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,B]">Return</a><a href="#284532" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#115604" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#285850" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Alias for `flatMap` */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B](f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]" id="115537">&gt;&gt;=</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="115539">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free[S,B]" id="150566">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23598" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> = <a href="#23598" title="Free.this.type" class="keyword">this</a> <a href="#115540" title="(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]">flatMap</a> <a href="#150566" title="A =&gt; scalaz.Free[S,B]">f</a>

  <span class="comment">/** Binds the given continuation to the result of this computation.
    * All left-associated binds are reassociated to the right. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B](f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]" id="115540">flatMap</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="115542">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free[S,B]" id="285844">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23598" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span> = <a href="#23598" title="scalaz.Free[S,A]" class="keyword">this</a> <span title="scalaz.Free[S,B]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="scalaz.Free.Gosub[S,Any,B]">Gosub</span><span class="delimiter">(</span><a title="() =&gt; scalaz.Free[S,Any]" id="286182">a</a>, <a title="Any =&gt; scalaz.Free[S,A]" id="286183">g</a><span class="delimiter">)</span> =&gt; <a href="#285816" title="(a: () =&gt; scalaz.Free[S,Any], f: Any =&gt; scalaz.Free[S,B])(implicit evidence$3: scalaz.Functor[S])scalaz.Free.Gosub[S,Any,B]">Gosub</a><a href="#284532" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#286182" title="() =&gt; scalaz.Free[S,Any]">a</a>, <span class="delimiter">(</span>x: <span title="Any">Any</span><span class="delimiter">)</span> =&gt; <a href="#285816" title="(a: () =&gt; scalaz.Free[S,A], f: A =&gt; scalaz.Free[S,B])(implicit evidence$3: scalaz.Functor[S])scalaz.Free.Gosub[S,A,B]">Gosub</a><a href="#284532" title="scalaz.Functor[S]" class="delimiter">(</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#286183" title="(v1: Any)scalaz.Free[S,A]">g</a><span class="delimiter">(</span><a href="#286195" title="Any">x</a><span class="delimiter">)</span>, <a href="#285844" title="A =&gt; scalaz.Free[S,B]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="scalaz.Free.Gosub[S,A,B]" id="286844">a</a>           =&gt; <a href="#285816" title="(a: () =&gt; scalaz.Free[S,A], f: A =&gt; scalaz.Free[S,B])(implicit evidence$3: scalaz.Functor[S])scalaz.Free.Gosub[S,A,B]">Gosub</a><a href="#284532" title="scalaz.Functor[S]" class="delimiter">(</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <a href="#286844" title="scalaz.Free[S,A]">a</a>, <a href="#285844" title="A =&gt; scalaz.Free[S,B]">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Evaluates a single layer of the free monad. */</span>
  @tailrec <span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]" id="115543">resume</a>: <span class="delimiter">(</span>S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">]</span> <a href="Either.scala.html#10410" title="scalaz.\/[S[scalaz.Free[S,A]],A]">\/</a> A<span class="delimiter">)</span> = <a href="#23598" title="scalaz.Free[S,A]" class="keyword">this</a> <span title="scalaz.\/[S[scalaz.Free[S,A]],A]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="scalaz.\/[Nothing,A]">Return</span><span class="delimiter">(</span><a title="A" id="287180">a</a><span class="delimiter">)</span>  =&gt; <a href="Either.scala.html#10411" title="object scalaz.\/">\/</a>.<a href="Either.scala.html#130391" title="(v1: A)scalaz.\/[Nothing,A]">right</a><span class="delimiter">(</span><a href="#287180" title="A">a</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="scalaz.\/[S[scalaz.Free[S,A]],Nothing]">Suspend</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="287189">t</a><span class="delimiter">)</span> =&gt; <a href="Either.scala.html#10411" title="object scalaz.\/">\/</a>.<a href="Either.scala.html#130386" title="(v1: S[scalaz.Free[S,A]])scalaz.\/[S[scalaz.Free[S,A]],Nothing]">left</a><span class="delimiter">(</span><a href="#287189" title="S[scalaz.Free[S,A]]">t</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="scalaz.\/[S[scalaz.Free[S,A]],A]" id="287199">a</a> Gosub <a title="Any =&gt; scalaz.Free[S,A]" id="287200">f</a>  =&gt; <a href="#287199" title="()scalaz.Free[S,Any]">a</a><span class="delimiter">(</span><span class="delimiter">)</span> <span title="scalaz.\/[S[scalaz.Free[S,A]],A]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scalaz.\/[S[scalaz.Free[S,A]],A]">Return</span><span class="delimiter">(</span><a title="Any" id="287205">a</a><span class="delimiter">)</span>  =&gt; <a href="#287200" title="(v1: Any)scalaz.Free[S,A]">f</a><span class="delimiter">(</span><a href="#287205" title="Any">a</a><span class="delimiter">)</span>.<a href="#115543" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a>
      <span class="keyword">case</span> <span title="scalaz.\/[S[scalaz.Free[S,A]],Nothing]">Suspend</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,Any]]" id="287211">t</a><span class="delimiter">)</span> =&gt; <a href="Either.scala.html#10411" title="object scalaz.\/">\/</a>.<a href="Either.scala.html#130386" title="(v1: S[scalaz.Free[S,A]])scalaz.\/[S[scalaz.Free[S,A]],Nothing]">left</a><span class="delimiter">(</span><a href="#284532" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#43741" title="(fa: S[scalaz.Free[S,Any]])(f: scalaz.Free[S,Any] =&gt; scalaz.Free[S,A])S[scalaz.Free[S,A]]">map</a><span class="delimiter">(</span><a href="#287211" title="S[scalaz.Free[S,Any]]">t</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#287225" title="scalaz.Free[S,Any]">_</a>: <a href="#23598" title="scalaz.Free[S,Any]">Free</a><span class="delimiter">[</span>S, Any<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#115540" title="(f: Any =&gt; scalaz.Free[S,A])scalaz.Free[S,A]">flatMap</a> <a href="#287200" title="Any =&gt; scalaz.Free[S,A]">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="scalaz.\/[S[scalaz.Free[S,A]],A]" id="287238">b</a> Gosub <a title="Any =&gt; scalaz.Free[S,Any]" id="287239">g</a>  =&gt; <a href="#287238" title="()scalaz.Free[S,Any]">b</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="#115540" title="(f: Any =&gt; scalaz.Free[S,A])scalaz.Free[S,A]">flatMap</a><span class="delimiter">(</span><span class="delimiter">(</span>x: <span title="Any">Any</span><span class="delimiter">)</span> =&gt; <a href="#287239" title="(v1: Any)scalaz.Free[S,Any]">g</a><span class="delimiter">(</span><a href="#287243" title="Any">x</a><span class="delimiter">)</span> <a href="#115540" title="(f: Any =&gt; scalaz.Free[S,A])scalaz.Free[S,A]">flatMap</a> <a href="#287200" title="Any =&gt; scalaz.Free[S,A]">f</a><span class="delimiter">)</span>.<a href="#115543" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Changes the suspension functor by the given natural transformation. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[T[+_]](f: scalaz.package.~&gt;[S,T])(implicit evidence$4: scalaz.Functor[T])scalaz.Free[T,A]" id="287250">mapSuspension</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="115546">T</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="287251">_</a><span class="delimiter">]</span>:Functor<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.package.~&gt;[S,T]" id="287249">f</a>: S <a href="NaturalTransformation.scala.html#17343" title="scalaz.package.~&gt;[S,T]">~&gt;</a> T<span class="delimiter">)</span>: <a href="#23598" title="scalaz.Free[T,A]">Free</a><span class="delimiter">[</span>T, A<span class="delimiter">]</span> =
    <a href="#115543" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a> <span title="scalaz.Free[T,A]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Suspend[T,A]">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="287256">s</a><span class="delimiter">)</span>  =&gt; <a href="#285828" title="(a: T[scalaz.Free[T,A]])(implicit evidence$2: scalaz.Functor[T])scalaz.Free.Suspend[T,A]">Suspend</a><a href="#287250" title="scalaz.Functor[T]" class="delimiter">(</a><a href="NaturalTransformation.scala.html#142794" title="(fa: S[scalaz.Free[T,A]])T[scalaz.Free[T,A]]">f</a><span class="delimiter">(</span><a href="#284532" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#43741" title="(fa: S[scalaz.Free[S,A]])(f: scalaz.Free[S,A] =&gt; scalaz.Free[T,A])S[scalaz.Free[T,A]]">map</a><span class="delimiter">(</span><a href="#287256" title="S[scalaz.Free[S,A]]">s</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">(</span><a href="#287277" title="scalaz.Free[S,A]">_</a>: <a href="#23598" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span> <a href="#287250" title="(f: scalaz.package.~&gt;[S,T])(implicit evidence$4: scalaz.Functor[T])scalaz.Free[T,A]">mapSuspension</a> <a href="#287249" title="scalaz.package.~&gt;[S,T]">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Return[T,A]">\/-</span><span class="delimiter">(</span><a title="A" id="287920">r</a><span class="delimiter">)</span> =&gt; <a href="#285840" title="(a: A)(implicit evidence$1: scalaz.Functor[T])scalaz.Free.Return[T,A]">Return</a><a href="#287250" title="scalaz.Functor[T]" class="delimiter">(</a><a href="#287920" title="A">r</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/** Modifies the first suspension with the given natural transformation. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(f: scalaz.package.~&gt;[S,S])scalaz.Free[S,A]" id="115547">mapFirstSuspension</a><span class="delimiter">(</span><a title="scalaz.package.~&gt;[S,S]" id="288243">f</a>: S <a href="NaturalTransformation.scala.html#17343" title="scalaz.package.~&gt;[S,S]">~&gt;</a> S<span class="delimiter">)</span>: <a href="#23598" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> = <a href="#115543" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a> <span title="scalaz.Free[S,A]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="scalaz.Free.Suspend[S,A]">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="288246">s</a><span class="delimiter">)</span> =&gt; <a href="#285828" title="(a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><a href="#284532" title="scalaz.Functor[S]" class="delimiter">(</a><a href="NaturalTransformation.scala.html#142794" title="(fa: S[scalaz.Free[S,A]])S[scalaz.Free[S,A]]">f</a><span class="delimiter">(</span><a href="#288246" title="S[scalaz.Free[S,A]]">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="scalaz.Free.Return[S,A]">\/-</span><span class="delimiter">(</span><a title="A" id="288575">r</a><span class="delimiter">)</span> =&gt; <a href="#285840" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><a href="#284532" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#288575" title="A">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Applies a function `f` to a value in this monad and a corresponding value in the dual comonad, annihilating both. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[G[+_], B, C](bs: scalaz.Cofree[G,B])(f: (A, B) =&gt; C)(implicit G: scalaz.Functor[G], implicit d: scalaz.Zap[S,G])C" id="115548">zapWith</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="115552">G</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="288902">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="115553">B</a>, <a title="&gt;: Nothing &lt;: Any" id="115554">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Cofree[G,B]" id="288897">bs</a>: <a href="Cofree.scala.html#21600" title="scalaz.Cofree[G,B]">Cofree</a><span class="delimiter">[</span>G, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="(A, B) =&gt; C" id="288898">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[G]" id="288899">G</a>: <a href="Functor.scala.html#14874" title="scalaz.Functor[G]">Functor</a><span class="delimiter">[</span>G<span class="delimiter">]</span>, <a title="scalaz.Zap[S,G]" id="288900">d</a>: <a href="Zap.scala.html#12054" title="scalaz.Zap[S,G]">Zap</a><span class="delimiter">[</span>S, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#115554" title="C">C</a> =
    <a href="Zap.scala.html#12055" title="object scalaz.Zap">Zap</a>.<a href="Zap.scala.html#142974" title="(implicit d: scalaz.Zap[S,G], implicit F: scalaz.Functor[S], implicit G: scalaz.Functor[G])scalaz.Zap[[α]scalaz.Free[S,α],[α]scalaz.Cofree[G,α]]">monadComonadZap</a>.<a href="Zap.scala.html#64639" title="(fa: scalaz.Free[S,A], gb: scalaz.Cofree[G,B])(f: (A, B) =&gt; C)C">zapWith</a><span class="delimiter">(</span><a href="#23598" title="scalaz.Free[S,A]" class="keyword">this</a>, <a href="#288897" title="scalaz.Cofree[G,B]">bs</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#288898" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span>

  <span class="comment">/** Applies a function in a comonad to the corresponding value in this monad, annihilating both. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[G[+_], B](fs: scalaz.Cofree[G,A =&gt; B])(implicit G: scalaz.Functor[G], implicit d: scalaz.Zap[S,G])B" id="115555">zap</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="115558">G</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="289822">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="115559">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Cofree[G,A =&gt; B]" id="289818">fs</a>: <a href="Cofree.scala.html#21600" title="scalaz.Cofree[G,A =&gt; B]">Cofree</a><span class="delimiter">[</span>G, A =&gt; B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Functor[G]" id="289819">G</a>: <a href="Functor.scala.html#14874" title="scalaz.Functor[G]">Functor</a><span class="delimiter">[</span>G<span class="delimiter">]</span>, <a title="scalaz.Zap[S,G]" id="289820">d</a>: <a href="Zap.scala.html#12054" title="scalaz.Zap[S,G]">Zap</a><span class="delimiter">[</span>S, G<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#115559" title="B">B</a> =
    <a href="#115548" title="(bs: scalaz.Cofree[G,A =&gt; B])(f: (A, A =&gt; B) =&gt; B)(implicit G: scalaz.Functor[G], implicit d: scalaz.Zap[S,G])B">zapWith</a><span class="delimiter">(</span><a href="#289818" title="scalaz.Cofree[G,A =&gt; B]">fs</a><span class="delimiter">)</span><a href="#289819" title="scalaz.Functor[G]" class="delimiter">(</a><span class="delimiter">(</span><a title="A" id="289847">a</a>, <a title="A =&gt; B" id="289848">f</a><span class="delimiter">)</span> =&gt; <a href="#289848" title="(v1: A)B">f</a><span class="delimiter">(</span><a href="#289847" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Runs a single step, using a function that extracts the resumption from its suspension functor. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[AA &gt;: A](f: S[scalaz.Free[S,A]] =&gt; scalaz.Free[S,AA])scalaz.Free[S,AA]" id="115560">bounce</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="115562">AA</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]] =&gt; scalaz.Free[S,AA]" id="290399">f</a>: S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">]</span> =&gt; Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23598" title="scalaz.Free[S,AA]">Free</a><span class="delimiter">[</span>S, AA<span class="delimiter">]</span> = <a href="#115543" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a> <span title="scalaz.Free[S,AA]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="scalaz.Free[S,AA]">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="290403">s</a><span class="delimiter">)</span> =&gt; <a href="#290399" title="(v1: S[scalaz.Free[S,A]])scalaz.Free[S,AA]">f</a><span class="delimiter">(</span><a href="#290403" title="S[scalaz.Free[S,A]]">s</a><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="scalaz.Free.Return[S,A]">\/-</span><span class="delimiter">(</span><a title="A" id="290406">r</a><span class="delimiter">)</span> =&gt; <a href="#285840" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><a href="#284532" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#290406" title="A">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Runs to completion, using a function that extracts the resumption from its suspension functor. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[AA &gt;: A](f: S[scalaz.Free[S,AA]] =&gt; scalaz.Free[S,AA])AA" id="115563">go</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="115565">AA</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,AA]] =&gt; scalaz.Free[S,AA]" id="290728">f</a>: S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">]</span> =&gt; Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#115565" title="AA">AA</a> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(t: scalaz.Free[S,AA])AA" id="290731">go2</a><span class="delimiter">(</span><a title="scalaz.Free[S,AA]" id="290732">t</a>: <a href="#23598" title="scalaz.Free[S,AA]">Free</a><span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#115565" title="AA">AA</a> = <a href="#290732" title="scalaz.Free[S,AA]">t</a>.<a href="#115543" title="=&gt; scalaz.\/[S[scalaz.Free[S,AA]],AA]">resume</a> <span title="AA" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="AA">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,AA]]" id="290734">s</a><span class="delimiter">)</span> =&gt; <a href="#290731" title="(t: scalaz.Free[S,AA])AA">go2</a><span class="delimiter">(</span><a href="#290728" title="(v1: S[scalaz.Free[S,AA]])scalaz.Free[S,AA]">f</a><span class="delimiter">(</span><a href="#290734" title="S[scalaz.Free[S,AA]]">s</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="AA">\/-</span><span class="delimiter">(</span><a title="AA" id="290737">r</a><span class="delimiter">)</span> =&gt; <a href="#290737" title="AA">r</a>
    <span class="delimiter">}</span>
    <a href="#290731" title="(t: scalaz.Free[S,AA])AA">go2</a><span class="delimiter">(</span><a href="#23598" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Runs to completion, allowing the resumption function to thread an arbitrary state of type `B`. */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[B, AA &gt;: A](b: B)(f: (B, S[scalaz.Free[S,AA]]) =&gt; (B, scalaz.Free[S,AA]))(B, AA)" id="115566">foldRun</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="115569">B</a>, <a title="&gt;: A &lt;: Any" id="115570">AA</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="B" id="290738">b</a>: <a href="#115569" title="B">B</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(B, S[scalaz.Free[S,AA]]) =&gt; (B, scalaz.Free[S,AA])" id="290739">f</a>: <span class="delimiter">(</span>B, S<span class="delimiter">[</span>Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>B, Free<span class="delimiter">[</span>S, AA<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(B, AA)" class="delimiter">(</span>B, AA<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(t: scalaz.Free[S,AA], z: B)(B, AA)" id="290743">foldRun2</a><span class="delimiter">(</span><a title="scalaz.Free[S,AA]" id="290744">t</a>: <a href="#23598" title="scalaz.Free[S,AA]">Free</a><span class="delimiter">[</span>S, AA<span class="delimiter">]</span>, <a title="B" id="290745">z</a>: <a href="#115569" title="B">B</a><span class="delimiter">)</span>: <span title="(B, AA)" class="delimiter">(</span>B, AA<span class="delimiter">)</span> = <a href="#290744" title="scalaz.Free[S,AA]">t</a>.<a href="#115543" title="=&gt; scalaz.\/[S[scalaz.Free[S,AA]],AA]">resume</a> <span title="(B, AA)" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="(B, AA)">-\/</span><span class="delimiter">(</span><a title="S[scalaz.Free[S,AA]]" id="290747">s</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
        <span class="keyword">val</span> <a href="#290749" title="(B, scalaz.Free[S,AA])" class="delimiter">(</a><a href="#290748" title="B" id="290749">b1</a>, <a href="#290748" title="scalaz.Free[S,AA]" id="290750">s1</a><span class="delimiter">)</span> = <a href="#290739" title="(v1: B, v2: S[scalaz.Free[S,AA]])(B, scalaz.Free[S,AA])">f</a><span title="(B, scalaz.Free[S,AA]) @unchecked" class="delimiter">(</span><a href="#290745" title="B">z</a>, <a href="#290747" title="S[scalaz.Free[S,AA]]">s</a><span class="delimiter">)</span>
        <a href="#290743" title="(t: scalaz.Free[S,AA], z: B)(B, AA)">foldRun2</a><span class="delimiter">(</span><a href="#290750" title="scalaz.Free[S,AA]">s1</a>, <a href="#290749" title="B">b1</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <span class="keyword">case</span> <span title="(B, AA)">\/-</span><span class="delimiter">(</span><a title="AA" id="290764">r</a><span class="delimiter">)</span> =&gt; <span title="(_1: B, _2: AA)(B, AA)" class="delimiter">(</span><a href="#290745" title="B">z</a>, <a href="#290764" title="AA">r</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#290743" title="(t: scalaz.Free[S,AA], z: B)(B, AA)">foldRun2</a><span class="delimiter">(</span><a href="#23598" title="scalaz.Free[S,A]" class="keyword">this</a>, <a href="#290738" title="B">b</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">import</span> <a href="Liskov.scala.html#10498" title="object scalaz.Liskov">Liskov</a>._

  <span class="comment">/** Runs a trampoline all the way to the end, tail-recursively. */</span>
  <span class="keyword">def</span> <a title="[B &gt;: A](implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,B],scalaz.Free.Trampoline[B]])B" id="115572">run</a><span class="delimiter">[</span><a title="&gt;: A &lt;: Any" id="115574">B</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,B],scalaz.Free.Trampoline[B]]" id="115669">ev</a>: Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span> <a href="Liskov.scala.html#10497" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,B],scalaz.Free.Trampoline[B]]">&lt;~&lt;</a> Trampoline<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#115574" title="B">B</a> =
    <a href="Liskov.scala.html#116039" title="(a: scalaz.Free[S,B])scalaz.Free.Trampoline[B]">ev</a><span class="delimiter">(</span><a href="#23598" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>.<a href="#115563" title="(f: (() =&gt; scalaz.Free[Function0,B]) =&gt; scalaz.Free[Function0,B])B">go</a><span class="delimiter">(</span><a href="#290782" title="()scalaz.Free[Function0,B]">_</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** Interleave this computation with another, combining the results with the given function. */</span>
  <span class="keyword">def</span> <a title="[B, C](tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]" id="115575">zipWith</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="115578">B</a>, <a title="&gt;: Nothing &lt;: Any" id="115579">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[S,B]" id="290783">tb</a>: <a href="#23598" title="scalaz.Free[S,B]">Free</a><span class="delimiter">[</span>S, B<span class="delimiter">]</span>, <a title="(A, B) =&gt; C" id="290784">f</a>: <span class="delimiter">(</span>A, B<span class="delimiter">)</span> =&gt; C<span class="delimiter">)</span>: <a href="#23598" title="scalaz.Free[S,C]">Free</a><span class="delimiter">[</span>S, C<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="(_1: scalaz.\/[S[scalaz.Free[S,A]],A], _2: scalaz.\/[S[scalaz.Free[S,B]],B])(scalaz.\/[S[scalaz.Free[S,A]],A], scalaz.\/[S[scalaz.Free[S,B]],B])" class="delimiter">(</span><a href="#115543" title="=&gt; scalaz.\/[S[scalaz.Free[S,A]],A]">resume</a>, <a href="#290783" title="scalaz.Free[S,B]">tb</a>.<a href="#115543" title="=&gt; scalaz.\/[S[scalaz.Free[S,B]],B]">resume</a><span class="delimiter">)</span> <span title="scalaz.Free[S,C]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Suspend[S,C]" class="delimiter">(</span>-\/<span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="290797">a</a><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="S[scalaz.Free[S,B]]" id="290799">b</a><span class="delimiter">)</span><span class="delimiter">)</span>   =&gt; <a href="#285828" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#284532" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#284532" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#43741" title="(fa: S[scalaz.Free[S,A]])(f: scalaz.Free[S,A] =&gt; scalaz.Free.Suspend[S,C])S[scalaz.Free.Suspend[S,C]]">map</a><span class="delimiter">(</span><a href="#290797" title="S[scalaz.Free[S,A]]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="290817">x</a> =&gt; <a href="#285828" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#284532" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#284532" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#43741" title="(fa: S[scalaz.Free[S,B]])(f: scalaz.Free[S,B] =&gt; scalaz.Free[S,C])S[scalaz.Free[S,C]]">map</a><span class="delimiter">(</span><a href="#290799" title="S[scalaz.Free[S,B]]">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,B]" id="290835">y</a> =&gt; <a href="#290817" title="scalaz.Free[S,A]">x</a> <a href="#115575" title="(tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]">zipWith</a><span class="delimiter">(</span><a href="#290835" title="scalaz.Free[S,B]">y</a>, <a href="#290784" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Suspend[S,C]" class="delimiter">(</span>-\/<span class="delimiter">(</span><a title="S[scalaz.Free[S,A]]" id="291480">a</a><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="B" id="291482">b</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#285828" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#284532" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#284532" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#43741" title="(fa: S[scalaz.Free[S,A]])(f: scalaz.Free[S,A] =&gt; scalaz.Free[S,C])S[scalaz.Free[S,C]]">map</a><span class="delimiter">(</span><a href="#291480" title="S[scalaz.Free[S,A]]">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="291500">x</a> =&gt; <a href="#291500" title="scalaz.Free[S,A]">x</a> <a href="#115575" title="(tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]">zipWith</a><span class="delimiter">(</span><a href="#285840" title="(a: B)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,B]">Return</a><a href="#284532" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#291482" title="B">b</a><span class="delimiter">)</span>, <a href="#290784" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Suspend[S,C]" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="A" id="292148">a</a><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="S[scalaz.Free[S,B]]" id="292150">b</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#285828" title="(a: S[scalaz.Free[S,C]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,C]">Suspend</a><a href="#284532" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#284532" title="scalaz.Functor[S]">S</a>.<a href="Functor.scala.html#43741" title="(fa: S[scalaz.Free[S,B]])(f: scalaz.Free[S,B] =&gt; scalaz.Free[S,C])S[scalaz.Free[S,C]]">map</a><span class="delimiter">(</span><a href="#292150" title="S[scalaz.Free[S,B]]">b</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="scalaz.Free[S,B]" id="292168">y</a> =&gt; <a href="#285840" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span class="delimiter">(</span><a href="#292148" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#284532" title="scalaz.Functor[S]">S</a><span class="delimiter">)</span> <a href="#115575" title="(tb: scalaz.Free[S,B], f: (A, B) =&gt; C)scalaz.Free[S,C]">zipWith</a><span class="delimiter">(</span><a href="#292168" title="scalaz.Free[S,B]">y</a>, <a href="#290784" title="(A, B) =&gt; C">f</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="scalaz.Free.Return[S,C]" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="A" id="292507">a</a><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="B" id="292509">b</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#285840" title="(a: C)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,C]">Return</a><a href="#284532" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#290784" title="(v1: A, v2: B)C">f</a><span class="delimiter">(</span><a href="#292507" title="A">a</a>, <a href="#292509" title="B">b</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Runs a `Source` all the way to the end, tail-recursively, collecting the produced values. */</span>
  <span class="keyword">def</span> <a title="[B, C &gt;: A](implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[B,C]])(Vector[B], C)" id="115580">collect</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="115583">B</a>, <a title="&gt;: A &lt;: Any" id="115584">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[B,C]]" id="292833">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#10497" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[B,C]]">&lt;~&lt;</a> Source<span class="delimiter">[</span>B, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Vector[B], C)" class="delimiter">(</span>Vector<span class="delimiter">[</span>B<span class="delimiter">]</span>, C<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(c: scalaz.Free.Source[B,C], v: Vector[B])(Vector[B], C)" id="292836">go</a><span class="delimiter">(</span><a title="scalaz.Free.Source[B,C]" id="292837">c</a>: <a href="#23598" title="scalaz.Free.Source[B,C]">Source</a><span class="delimiter">[</span>B, C<span class="delimiter">]</span>, <a title="Vector[B]" id="292839">v</a>: <span title="Vector[B]">Vector</span><span class="delimiter">[</span>B<span class="delimiter">]</span> = <span title="(elems: Nothing*)scala.collection.immutable.Vector[Nothing]">Vector</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>: <span title="(Vector[B], C)" class="delimiter">(</span>Vector<span class="delimiter">[</span>B<span class="delimiter">]</span>, C<span class="delimiter">)</span> =
      <a href="#292837" title="scalaz.Free.Source[B,C]">c</a>.<a href="#115543" title="=&gt; scalaz.\/[(B, scalaz.Free[[+x](B, x),C]),C]">resume</a> <span title="(Vector[B], C)" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="(Vector[B], C)">-\/</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="B" id="292846">b</a>, <a title="scalaz.Free[[+x](B, x),C]" id="292847">cont</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#292836" title="(c: scalaz.Free.Source[B,C], v: Vector[B])(Vector[B], C)">go</a><span class="delimiter">(</span><a href="#292847" title="scalaz.Free[[+x](B, x),C]">cont</a>, <a href="#292839" title="Vector[B]">v</a> <span title="(elem: B)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[B],B,Vector[B]])Vector[B]">:+</span> <a href="#292846" title="B">b</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="(Vector[B], C)">\/-</span><span class="delimiter">(</span><a title="C" id="293150">r</a><span class="delimiter">)</span>        =&gt; <span title="(_1: Vector[B], _2: C)(Vector[B], C)" class="delimiter">(</span><a href="#292839" title="Vector[B]">v</a>, <a href="#293150" title="C">r</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#292836" title="(c: scalaz.Free.Source[B,C], v: Vector[B])(Vector[B], C)">go</a><span class="delimiter">(</span><a href="Liskov.scala.html#116039" title="(a: scalaz.Free[S,C])scalaz.Free.Source[B,C]">ev</a><span class="delimiter">(</span><a href="#23598" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Drive this `Source` with the given Sink. */</span>
  <span class="keyword">def</span> <a title="[E, B, C &gt;: A](sink: scalaz.Free.Sink[Option[E],B])(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[E,C]])(C, B)" id="115585">drive</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="115589">E</a>, <a title="&gt;: Nothing &lt;: Any" id="115590">B</a>, <a title="&gt;: A &lt;: Any" id="115591">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Sink[Option[E],B]" id="293161">sink</a>: <a href="#23598" title="scalaz.Free.Sink[Option[E],B]">Sink</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>E<span class="delimiter">]</span>, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[E,C]]" id="293162">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#10497" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Source[E,C]]">&lt;~&lt;</a> Source<span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)" id="293166">go</a><span class="delimiter">(</span><a title="scalaz.Free.Source[E,C]" id="293167">src</a>: <a href="#23598" title="scalaz.Free.Source[E,C]">Source</a><span class="delimiter">[</span>E, C<span class="delimiter">]</span>, <a title="scalaz.Free.Sink[Option[E],B]" id="293168">snk</a>: <a href="#23598" title="scalaz.Free.Sink[Option[E],B]">Sink</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>E<span class="delimiter">]</span>, B<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> =
      <span title="(_1: scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C], _2: scalaz.\/[=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B],B])(scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C], scalaz.\/[=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B],B])" class="delimiter">(</span><a href="#293167" title="scalaz.Free.Source[E,C]">src</a>.<a href="#115543" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),C]),C]">resume</a>, <a href="#293168" title="scalaz.Free.Sink[Option[E],B]">snk</a>.<a href="#115543" title="=&gt; scalaz.\/[=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B],B]">resume</a><span class="delimiter">)</span> <span title="(C, B)" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>-\/<span class="delimiter">(</span><span class="delimiter">(</span><a title="E" id="293180">e</a>, <a title="scalaz.Free[[+x](E, x),C]" id="293181">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]" id="293183">f</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#293166" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><span class="delimiter">(</span><a href="#293181" title="scalaz.Free[[+x](E, x),C]">c</a>, <a href="#293183" title="(v1: =&gt; Option[E])scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]">f</a><span class="delimiter">(</span><span title="(x: E)Some[E]">Some</span><span class="delimiter">(</span><a href="#293180" title="E">e</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>-\/<span class="delimiter">(</span><span class="delimiter">(</span><a title="E" id="293193">e</a>, <a title="scalaz.Free[[+x](E, x),C]" id="293194">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="B" id="293196">y</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#293166" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><span class="delimiter">(</span><a href="#293194" title="scalaz.Free[[+x](E, x),C]">c</a>, <a href="#12082" title="object scalaz.Sink">Sink</a>.<a href="#54439" title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]">sinkMonad</a><span title="scalaz.Monad[[x]scalaz.Free[[+x]=&gt; Option[E] =&gt; x,x]]" class="delimiter">[</span><span title="Option[E]">Option</span><span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">]</span>.<a href="Applicative.scala.html#44826" title="(a: =&gt; B)scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]">pure</a><span class="delimiter">(</span><a href="#293196" title="B">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="C" id="293208">x</a><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; Option[E] =&gt; scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]" id="293210">f</a><span class="delimiter">)</span><span class="delimiter">)</span>      =&gt; <a href="#293166" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><span class="delimiter">(</span><a href="#24193" title="object scalaz.Source">Source</a>.<a href="#54443" title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]">sourceMonad</a><span title="scalaz.Monad[[x]scalaz.Free[[+x](E, x),x]]" class="delimiter">[</span><a href="#115589" title="E">E</a><span class="delimiter">]</span>.<a href="Applicative.scala.html#44826" title="(a: =&gt; C)scalaz.Free[[+x](E, x),C]">pure</a><span class="delimiter">(</span><a href="#293208" title="C">x</a><span class="delimiter">)</span>, <a href="#293210" title="(v1: =&gt; Option[E])scalaz.Free[[+x]=&gt; Option[E] =&gt; x,B]">f</a><span class="delimiter">(</span><span title="object None">None</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="C" id="293223">x</a><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="B" id="293225">y</a><span class="delimiter">)</span><span class="delimiter">)</span>     =&gt; <span title="(_1: C, _2: B)(C, B)" class="delimiter">(</span><a href="#293223" title="C">x</a>, <a href="#293225" title="B">y</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <a href="#293166" title="(src: scalaz.Free.Source[E,C], snk: scalaz.Free.Sink[Option[E],B])(C, B)">go</a><span class="delimiter">(</span><a href="Liskov.scala.html#116039" title="(a: scalaz.Free[S,C])scalaz.Free.Source[E,C]">ev</a><span class="delimiter">(</span><a href="#23598" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>, <a href="#293161" title="scalaz.Free.Sink[Option[E],B]">sink</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Feed the given stream to this `Source`. */</span>
  <span class="keyword">def</span> <a title="[E, C &gt;: A](ss: Stream[E])(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]])C" id="115592">feed</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="115595">E</a>, <a title="&gt;: A &lt;: Any" id="115596">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="Stream[E]" id="293233">ss</a>: <span title="Stream[E]">Stream</span><span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]" id="293234">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#10497" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]">&lt;~&lt;</a> Sink<span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#115596" title="C">C</a> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C" id="293238">go</a><span class="delimiter">(</span><a title="scalaz.Free.Sink[E,C]" id="293239">snk</a>: <a href="#23598" title="scalaz.Free.Sink[E,C]">Sink</a><span class="delimiter">[</span>E, C<span class="delimiter">]</span>, <a title="Stream[E]" id="293240">rest</a>: <span title="Stream[E]">Stream</span><span class="delimiter">[</span>E<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#115596" title="C">C</a> = <span title="(_1: Stream[E], _2: scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C])(Stream[E], scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C])" class="delimiter">(</span><a href="#293240" title="Stream[E]">rest</a>, <a href="#293239" title="scalaz.Free.Sink[E,C]">snk</a>.<a href="#115543" title="=&gt; scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C]">resume</a><span class="delimiter">)</span> <span title="C" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="C" class="delimiter">(</span><a title="E" id="293275">x</a> <a href="#293257" title="(xs: scala.collection.immutable.Stream[E])Option[(E, scala.collection.immutable.Stream[E])]">#::</a> <a title="scala.collection.immutable.Stream[E]" id="293276">xs</a>, -\/<span class="delimiter">(</span><a title="=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C]" id="293278">f</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#293238" title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C">go</a><span class="delimiter">(</span><a href="#293278" title="(v1: =&gt; E)scalaz.Free[[+x]=&gt; E =&gt; x,C]">f</a><span class="delimiter">(</span><a href="#293275" title="E">x</a><span class="delimiter">)</span>, <a href="#293276" title="scala.collection.immutable.Stream[E]">xs</a><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="C" class="delimiter">(</span><a href="#293283" title="(x: scala.collection.immutable.Stream[E])Some[scala.collection.immutable.Stream[E]]">Stream</a><span class="delimiter">(</span><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C]" id="293303">f</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#293238" title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C">go</a><span class="delimiter">(</span><a href="#293303" title="(v1: =&gt; E)scalaz.Free[[+x]=&gt; E =&gt; x,C]">f</a><span class="delimiter">(</span>sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="java.lang.String(&quot;No more values.&quot;)" class="string">&quot;No more values.&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="(xs: Nothing*)scala.collection.immutable.Stream[Nothing]">Stream</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="C" class="delimiter">(</span>_, \/-<span class="delimiter">(</span><a title="C" id="293315">r</a><span class="delimiter">)</span><span class="delimiter">)</span>       =&gt; <a href="#293315" title="C">r</a>
    <span class="delimiter">}</span>
    <a href="#293238" title="(snk: scalaz.Free.Sink[E,C], rest: Stream[E])C">go</a><span class="delimiter">(</span><a href="Liskov.scala.html#116039" title="(a: scalaz.Free[S,C])scalaz.Free.Sink[E,C]">ev</a><span class="delimiter">(</span><a href="#23598" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span>, <a href="#293233" title="Stream[E]">ss</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Feed the given source to this `Sink`. */</span>
  <span class="keyword">def</span> <a title="[E, B, C &gt;: A](source: scalaz.Free.Source[E,B])(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]])(C, B)" id="115597">drain</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="115601">E</a>, <a title="&gt;: Nothing &lt;: Any" id="115602">B</a>, <a title="&gt;: A &lt;: Any" id="115603">C</a> &gt;: A<span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Source[E,B]" id="293317">source</a>: <a href="#23598" title="scalaz.Free.Source[E,B]">Source</a><span class="delimiter">[</span>E, B<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]" id="293318">ev</a>: Free<span class="delimiter">[</span>S, C<span class="delimiter">]</span> <a href="Liskov.scala.html#10497" title="scalaz.Liskov.&lt;~&lt;[scalaz.Free[S,C],scalaz.Free.Sink[E,C]]">&lt;~&lt;</a> Sink<span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> = <span class="delimiter">{</span>
    @tailrec <span class="keyword">def</span> <a title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)" id="293322">go</a><span class="delimiter">(</span><a title="scalaz.Free.Source[E,B]" id="293323">src</a>: <a href="#23598" title="scalaz.Free.Source[E,B]">Source</a><span class="delimiter">[</span>E, B<span class="delimiter">]</span>, <a title="scalaz.Free.Sink[E,C]" id="293324">snk</a>: <a href="#23598" title="scalaz.Free.Sink[E,C]">Sink</a><span class="delimiter">[</span>E, C<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(C, B)" class="delimiter">(</span>C, B<span class="delimiter">)</span> = <span title="(_1: scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B], _2: scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C])(scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B], scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C])" class="delimiter">(</span><a href="#293323" title="scalaz.Free.Source[E,B]">src</a>.<a href="#115543" title="=&gt; scalaz.\/[(E, scalaz.Free[[+x](E, x),B]),B]">resume</a>, <a href="#293324" title="scalaz.Free.Sink[E,C]">snk</a>.<a href="#115543" title="=&gt; scalaz.\/[=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C],C]">resume</a><span class="delimiter">)</span> <span title="(C, B)" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>-\/<span class="delimiter">(</span><span class="delimiter">(</span><a title="E" id="293336">e</a>, <a title="scalaz.Free[[+x](E, x),B]" id="293337">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C]" id="293339">f</a><span class="delimiter">)</span><span class="delimiter">)</span>  =&gt; <a href="#293322" title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)">go</a><span class="delimiter">(</span><a href="#293337" title="scalaz.Free[[+x](E, x),B]">c</a>, <a href="#293339" title="(v1: =&gt; E)scalaz.Free[[+x]=&gt; E =&gt; x,C]">f</a><span class="delimiter">(</span><a href="#293336" title="E">e</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>-\/<span class="delimiter">(</span><span class="delimiter">(</span><a title="E" id="293346">e</a>, <a title="scalaz.Free[[+x](E, x),B]" id="293347">c</a><span class="delimiter">)</span><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="C" id="293349">y</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#293322" title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)">go</a><span class="delimiter">(</span><a href="#293347" title="scalaz.Free[[+x](E, x),B]">c</a>, <a href="#12082" title="object scalaz.Sink">Sink</a>.<a href="#54439" title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]">sinkMonad</a><span title="scalaz.Monad[[x]scalaz.Free[[+x]=&gt; E =&gt; x,x]]" class="delimiter">[</span><a href="#115601" title="E">E</a><span class="delimiter">]</span>.<a href="Applicative.scala.html#44826" title="(a: =&gt; C)scalaz.Free[[+x]=&gt; E =&gt; x,C]">pure</a><span class="delimiter">(</span><a href="#293349" title="C">y</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="Nothing" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="B" id="293360">x</a><span class="delimiter">)</span>, -\/<span class="delimiter">(</span><a title="=&gt; E =&gt; scalaz.Free[[+x]=&gt; E =&gt; x,C]" id="293362">f</a><span class="delimiter">)</span><span class="delimiter">)</span>      =&gt; sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="java.lang.String(&quot;Not enough values in source.&quot;)" class="string">&quot;Not enough values in source.&quot;</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="(C, B)" class="delimiter">(</span>\/-<span class="delimiter">(</span><a title="B" id="293366">x</a><span class="delimiter">)</span>, \/-<span class="delimiter">(</span><a title="C" id="293368">y</a><span class="delimiter">)</span><span class="delimiter">)</span>     =&gt; <span title="(_1: C, _2: B)(C, B)" class="delimiter">(</span><a href="#293368" title="C">y</a>, <a href="#293366" title="B">x</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#293322" title="(src: scalaz.Free.Source[E,B], snk: scalaz.Free.Sink[E,C])(C, B)">go</a><span class="delimiter">(</span><a href="#293317" title="scalaz.Free.Source[E,B]">source</a>, <a href="Liskov.scala.html#116039" title="(a: scalaz.Free[S,C])scalaz.Free.Sink[E,C]">ev</a><span class="delimiter">(</span><a href="#23598" title="scalaz.Free[S,A]" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="object scalaz.Trampoline" id="13849">Trampoline</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24420" title="scalaz.TrampolineInstances">TrampolineInstances</a>

<span class="keyword">trait</span> <a title="trait TrampolineInstances extends java.lang.Object with ScalaObject" id="24420">TrampolineInstances</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scalaz.Monad[scalaz.Free.Trampoline]" id="54432">trampolineMonad</a>: <a href="Monad.scala.html#22710" title="scalaz.Monad[scalaz.Free.Trampoline]">Monad</a><span class="delimiter">[</span>Trampoline<span class="delimiter">]</span> = <a href="#293380" title="java.lang.Object with scalaz.Monad[scalaz.Free.Trampoline]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Monad[scalaz.Free.Trampoline]" id="293380">Monad</a><span class="delimiter">[</span>Trampoline<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free[Function0,A]" id="293421">point</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="293423">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="293429">a</a>: =&gt; A<span class="delimiter">)</span> = <a href="#54389" title="[S[+_], A](value: =&gt; A)(implicit S: scalaz.Applicative[S])scalaz.Free[S,A]">return_</a><span title="(value: =&gt; A)(implicit S: scalaz.Applicative[Function0])scalaz.Free[Function0,A]" class="delimiter">[</span><span title="Function0">Function0</span>, <a href="#293423" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#54464" title="function0Instance extends java.lang.Object with scalaz.Traverse[Function0] with scalaz.Monad[Function0] with scalaz.Comonad[Function0] with scalaz.Distributive[Function0]" class="delimiter">(</a><a href="#293429" title="=&gt; A">a</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[A, B](ta: scalaz.Free.Trampoline[A])(f: A =&gt; scalaz.Free.Trampoline[B])scalaz.Free[Function0,B]" id="293424">bind</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="293427">A</a>, <a title="&gt;: Nothing &lt;: Any" id="293428">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Trampoline[A]" id="293731">ta</a>: <a href="#23598" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free.Trampoline[B]" id="293732">f</a>: A =&gt; Trampoline<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#293731" title="scalaz.Free.Trampoline[A]">ta</a> <a href="#115540" title="(f: A =&gt; scalaz.Free[Function0,B])scalaz.Free[Function0,B]">flatMap</a> <a href="#293732" title="A =&gt; scalaz.Free.Trampoline[B]">f</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="object scalaz.Sink" id="12082">Sink</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#15624" title="scalaz.SinkInstances">SinkInstances</a>

<span class="keyword">trait</span> <a title="trait SinkInstances extends java.lang.Object with ScalaObject" id="15624">SinkInstances</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]" id="54439">sinkMonad</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="54441">S</a><span class="delimiter">]</span>: <a href="Monad.scala.html#22710" title="scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Sink<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> =
    <a href="#293771" title="java.lang.Object with scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Monad[[x]scalaz.Free[[+x]=&gt; S =&gt; x,x]]" id="293771">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Sink<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free.Suspend[[+x]=&gt; S =&gt; x,A]" id="293817">point</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="293819">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="293825">a</a>: =&gt; A<span class="delimiter">)</span> =
        <a href="#285828" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: =&gt; S =&gt; scalaz.Free[[+x]=&gt; S =&gt; x,A])(implicit evidence$2: scalaz.Functor[[+x]=&gt; S =&gt; x])scalaz.Free.Suspend[[+x]=&gt; S =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; S<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x]=&gt; S =&gt; x">f</span>, <a href="#293819" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#54471" title="FunctionInstances extends scalaz.Monad[[a]=&gt; S =&gt; a] with scalaz.Zip[[a]=&gt; S =&gt; a] with scalaz.Unzip[[a]=&gt; S =&gt; a] with scalaz.Distributive[[a]=&gt; S =&gt; a]" class="delimiter">(</a><a title="=&gt; S" id="293841">s</a> =&gt;
          <a href="#285840" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[[+x]=&gt; S =&gt; x])scalaz.Free.Return[[+x]=&gt; S =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; S<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x]=&gt; S =&gt; x">f</span>, <a href="#293819" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#54471" title="FunctionInstances extends scalaz.Monad[[a]=&gt; S =&gt; a] with scalaz.Zip[[a]=&gt; S =&gt; a] with scalaz.Unzip[[a]=&gt; S =&gt; a] with scalaz.Distributive[[a]=&gt; S =&gt; a]" class="delimiter">(</a><a href="#293825" title="=&gt; A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="[A, B](s: scalaz.Free.Sink[S,A])(f: A =&gt; scalaz.Free.Sink[S,B])scalaz.Free[[+x]=&gt; S =&gt; x,B]" id="293820">bind</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="293823">A</a>, <a title="&gt;: Nothing &lt;: Any" id="293824">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Sink[S,A]" id="294557">s</a>: <a href="#23598" title="scalaz.Free.Sink[S,A]">Sink</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free.Sink[S,B]" id="294558">f</a>: A =&gt; Sink<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#294557" title="scalaz.Free.Sink[S,A]">s</a> <a href="#115540" title="(f: A =&gt; scalaz.Free[[+x]=&gt; S =&gt; x,B])scalaz.Free[[+x]=&gt; S =&gt; x,B]">flatMap</a> <a href="#294558" title="A =&gt; scalaz.Free.Sink[S,B]">f</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="object scalaz.Source" id="24193">Source</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#14799" title="scalaz.SourceInstances">SourceInstances</a>

<span class="keyword">trait</span> <a title="trait SourceInstances extends java.lang.Object with ScalaObject" id="14799">SourceInstances</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S]=&gt; scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]" id="54443">sourceMonad</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="54445">S</a><span class="delimiter">]</span>: <a href="Monad.scala.html#22710" title="scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Source<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> =
    <a href="#294609" title="java.lang.Object with scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Monad[[x]scalaz.Free[[+x](S, x),x]]" id="294609">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Source<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free.Return[[+x](S, x),A]" id="294655">point</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="294657">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="294663">a</a>: =&gt; A<span class="delimiter">)</span> = <a href="#285840" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[[+x](S, x)])scalaz.Free.Return[[+x](S, x),A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>S, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](S, x)">f</span>, <a href="#294657" title="A">A</a><span class="delimiter">]</span><a href="std/Tuple.scala.html#55870" title="TupleInstances0 extends scalaz.Traverse[[x](S, x)] with scalaz.Comonad[[x](S, x)]" class="delimiter">(</a><a href="#294663" title="=&gt; A">a</a><span class="delimiter">)</span>
      <span class="keyword">def</span> <a title="[A, B](s: scalaz.Free.Source[S,A])(f: A =&gt; scalaz.Free.Source[S,B])scalaz.Free[[+x](S, x),B]" id="294658">bind</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="294661">A</a>, <a title="&gt;: Nothing &lt;: Any" id="294662">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Source[S,A]" id="295253">s</a>: <a href="#23598" title="scalaz.Free.Source[S,A]">Source</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free.Source[S,B]" id="295254">f</a>: A =&gt; Source<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#295253" title="scalaz.Free.Source[S,A]">s</a> <a href="#115540" title="(f: A =&gt; scalaz.Free[[+x](S, x),B])scalaz.Free[[+x](S, x),B]">flatMap</a> <a href="#295254" title="A =&gt; scalaz.Free.Source[S,B]">f</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">// Trampoline, Sink, and Source are type aliases. We need to add their type class instances</span>
<span class="comment">// to Free to be part of the implicit scope.</span>
<span class="keyword">trait</span> <a title="trait FreeInstances extends java.lang.Object with scalaz.TrampolineInstances with scalaz.SinkInstances with scalaz.SourceInstances with ScalaObject" id="21114">FreeInstances</a> <span title="ScalaObject" class="keyword">extends</span> <a href="#24420" title="scalaz.TrampolineInstances">TrampolineInstances</a> <span class="keyword">with</span> <a href="#15624" title="scalaz.SinkInstances">SinkInstances</a> <span class="keyword">with</span> <a href="#14799" title="scalaz.SourceInstances">SourceInstances</a> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[S[+_]](implicit evidence$5: scalaz.Functor[S])scalaz.Monad[[x]scalaz.Free[S,x]]" id="116067">freeMonad</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="54437">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="116071">_</a><span class="delimiter">]</span>:Functor<span class="delimiter">]</span>: <a href="Monad.scala.html#22710" title="scalaz.Monad[[x]scalaz.Free[S,x]]">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Free<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> =
    <a href="#295304" title="java.lang.Object with scalaz.Monad[[x]scalaz.Free[S,x]]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.Monad[[x]scalaz.Free[S,x]]" id="295304">Monad</a><span class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>x<span class="delimiter">]</span> = Free<span class="delimiter">[</span>S, x<span class="delimiter">]</span><span class="delimiter">}</span><span class="delimiter">)</span>#f<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="[A](a: =&gt; A)scalaz.Free.Return[S,A]" id="295350">point</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="295352">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="295363">a</a>: =&gt; A<span class="delimiter">)</span> = <a href="#285840" title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><a href="#116067" title="scalaz.Functor[S]" class="delimiter">(</a><a href="#295363" title="=&gt; A">a</a><span class="delimiter">)</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="[A, B](fa: scalaz.Free[S,A])(f: A =&gt; B)scalaz.Free[S,B]" id="295353">map</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="295356">A</a>, <a title="&gt;: Nothing &lt;: Any" id="295357">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="295700">fa</a>: <a href="#23598" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; B" id="295701">f</a>: A =&gt; B<span class="delimiter">)</span> = <a href="#295700" title="scalaz.Free[S,A]">fa</a> <a href="#115534" title="(f: A =&gt; B)scalaz.Free[S,B]">map</a> <a href="#295701" title="A =&gt; B">f</a>
      <span class="keyword">def</span> <a title="[A, B](a: scalaz.Free[S,A])(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]" id="295358">bind</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="295361">A</a>, <a title="&gt;: Nothing &lt;: Any" id="295362">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free[S,A]" id="295748">a</a>: <a href="#23598" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="A =&gt; scalaz.Free[S,B]" id="295749">f</a>: A =&gt; Free<span class="delimiter">[</span>S, B<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#295748" title="scalaz.Free[S,A]">a</a> <a href="#115540" title="(f: A =&gt; scalaz.Free[S,B])scalaz.Free[S,B]">flatMap</a> <a href="#295749" title="A =&gt; scalaz.Free[S,B]">f</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">trait</span> <a title="trait FreeFunctions extends java.lang.Object with ScalaObject" id="23145">FreeFunctions</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="comment">/** Collapse a trampoline to a single step. */</span>
  <span class="keyword">def</span> <a title="[A](r: scalaz.Free.Trampoline[A])scalaz.Free.Trampoline[A]" id="54386">reset</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="54388">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scalaz.Free.Trampoline[A]" id="295818">r</a>: <a href="#23598" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23598" title="scalaz.Free.Trampoline[A]">Trampoline</a><span class="delimiter">[</span>A<span class="delimiter">]</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a title="A" id="295821">a</a> = <a href="#295818" title="scalaz.Free.Trampoline[A]">r</a>.<a href="#115572" title="(implicit ev: scalaz.Liskov.&lt;~&lt;[scalaz.Free[Function0,A],scalaz.Free.Trampoline[A]])A">run</a>; <a href="#54389" title="(value: =&gt; A)(implicit S: scalaz.Applicative[Function0])scalaz.Free[Function0,A]">return_</a><a href="std/Function.scala.html#54464" title="function0Instance extends java.lang.Object with scalaz.Traverse[Function0] with scalaz.Monad[Function0] with scalaz.Comonad[Function0] with scalaz.Distributive[Function0]" class="delimiter">(</a><a href="#295821" title="A">a</a><span class="delimiter">)</span> <span class="delimiter">}</span>

  <span class="comment">/** Suspend the given computation in a single step. */</span>
  <span class="keyword">def</span> <a title="[S[+_], A](value: =&gt; A)(implicit S: scalaz.Applicative[S])scalaz.Free[S,A]" id="54389">return_</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="54392">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="150607">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="54393">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; A" id="150605">value</a>: =&gt; A<span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[S]" id="150606">S</a>: <a href="Applicative.scala.html#20205" title="scalaz.Applicative[S]">Applicative</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23598" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> =
    <a href="#285828" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]" class="delimiter">[</span><a href="#54392" title="S">S</a>, <a href="#54393" title="A">A</a><span class="delimiter">]</span><a href="#150606" title="scalaz.Applicative[S]" class="delimiter">(</a><a href="#150606" title="scalaz.Applicative[S]">S</a>.<a href="Applicative.scala.html#44823" title="(a: =&gt; scalaz.Free.Return[S,A])S[scalaz.Free.Return[S,A]]">point</a><span class="delimiter">(</span><a href="#285840" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]" class="delimiter">[</span><a href="#54392" title="S">S</a>, <a href="#54393" title="A">A</a><span class="delimiter">]</span><a href="#150606" title="scalaz.Applicative[S]" class="delimiter">(</a><a href="#150605" title="=&gt; A">value</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[S[+_], A](value: =&gt; scalaz.Free[S,A])(implicit S: scalaz.Applicative[S])scalaz.Free[S,A]" id="54394">suspend</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="54397">S</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="150434">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="54398">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scalaz.Free[S,A]" id="150432">value</a>: =&gt; Free<span class="delimiter">[</span>S, A<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="scalaz.Applicative[S]" id="150433">S</a>: <a href="Applicative.scala.html#20205" title="scalaz.Applicative[S]">Applicative</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#23598" title="scalaz.Free[S,A]">Free</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> =
    <a href="#285828" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]" class="delimiter">[</span><a href="#54397" title="S">S</a>, <a href="#54398" title="A">A</a><span class="delimiter">]</span><a href="#150433" title="scalaz.Applicative[S]" class="delimiter">(</a><a href="#150433" title="scalaz.Applicative[S]">S</a>.<a href="Applicative.scala.html#44823" title="(a: =&gt; scalaz.Free[S,A])S[scalaz.Free[S,A]]">point</a><span class="delimiter">(</span><a href="#150432" title="=&gt; scalaz.Free[S,A]">value</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A trampoline step that doesn't do anything. */</span>
  <span class="keyword">def</span> <a title="=&gt; scalaz.Free.Trampoline[Unit]" id="54399">pause</a>: <a href="#23598" title="scalaz.Free.Trampoline[Unit]">Trampoline</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> =
    <a href="#54389" title="(value: =&gt; Unit)(implicit S: scalaz.Applicative[Function0])scalaz.Free[Function0,Unit]">return_</a><a href="std/Function.scala.html#54464" title="function0Instance extends java.lang.Object with scalaz.Traverse[Function0] with scalaz.Monad[Function0] with scalaz.Comonad[Function0] with scalaz.Distributive[Function0]" class="delimiter">(</a><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A source that produces the given value. */</span>
  <span class="keyword">def</span> <a title="[A](a: A)scalaz.Free.Source[A,Unit]" id="54400">produce</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="54402">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A" id="297614">a</a>: <a href="#54402" title="A">A</a><span class="delimiter">)</span>: <a href="#23598" title="scalaz.Free.Source[A,Unit]">Source</a><span class="delimiter">[</span>A, Unit<span class="delimiter">]</span> =
    <a href="#285828" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: (A, scalaz.Free[[+x](A, x),Unit]))(implicit evidence$2: scalaz.Functor[[+x](A, x)])scalaz.Free.Suspend[[+x](A, x),Unit]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>A, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](A, x)">f</span>, <span title="Unit">Unit</span><span class="delimiter">]</span><a href="std/Tuple.scala.html#55870" title="TupleInstances0 extends scalaz.Traverse[[x](A, x)] with scalaz.Comonad[[x](A, x)]" class="delimiter">(</a><a href="#297614" title="(x: A)ArrowAssoc[A]">a</a> <span title="(y: scalaz.Free.Return[[+x](A, x),Unit])(A, scalaz.Free.Return[[+x](A, x),Unit])">-&gt;</span> <a href="#285840" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: Unit)(implicit evidence$1: scalaz.Functor[[+x](A, x)])scalaz.Free.Return[[+x](A, x),Unit]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>A, x<span class="delimiter">)</span><span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x](A, x)">f</span>, <span title="Unit">Unit</span><span class="delimiter">]</span><a href="std/Tuple.scala.html#55870" title="TupleInstances0 extends scalaz.Traverse[[x](A, x)] with scalaz.Comonad[[x](A, x)]" class="delimiter">(</a><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** A sink that waits for a single value and returns it. */</span>
  <span class="keyword">def</span> <a title="[A]=&gt; scalaz.Free.Sink[A,A]" id="54403">await</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="54405">A</a><span class="delimiter">]</span>: <a href="#23598" title="scalaz.Free.Sink[A,A]">Sink</a><span class="delimiter">[</span>A, A<span class="delimiter">]</span> =
    <a href="#285828" title="[S[+_], A](a: S[scalaz.Free[S,A]])(implicit evidence$2: scalaz.Functor[S])scalaz.Free.Suspend[S,A]">Suspend</a><span title="(a: =&gt; A =&gt; scalaz.Free[[+x]=&gt; A =&gt; x,A])(implicit evidence$2: scalaz.Functor[[+x]=&gt; A =&gt; x])scalaz.Free.Suspend[[+x]=&gt; A =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; A<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x]=&gt; A =&gt; x">f</span>, <a href="#54405" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#54471" title="FunctionInstances extends scalaz.Monad[[a]=&gt; A =&gt; a] with scalaz.Zip[[a]=&gt; A =&gt; a] with scalaz.Unzip[[a]=&gt; A =&gt; a] with scalaz.Distributive[[a]=&gt; A =&gt; a]" class="delimiter">(</a><a title="=&gt; A" id="299055">a</a> =&gt; <a href="#285840" title="[S[+_], A](a: A)(implicit evidence$1: scalaz.Functor[S])scalaz.Free.Return[S,A]">Return</a><span title="(a: A)(implicit evidence$1: scalaz.Functor[[+x]=&gt; A =&gt; x])scalaz.Free.Return[[+x]=&gt; A =&gt; x,A]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">{</span><span class="keyword">type</span> f<span class="delimiter">[</span>+x<span class="delimiter">]</span> = <span class="delimiter">(</span>=&gt; A<span class="delimiter">)</span> =&gt; x<span class="delimiter">}</span><span class="delimiter">)</span>#<span title="[+x]=&gt; A =&gt; x">f</span>, <a href="#54405" title="A">A</a><span class="delimiter">]</span><a href="std/Function.scala.html#54471" title="FunctionInstances extends scalaz.Monad[[a]=&gt; A =&gt; a] with scalaz.Zip[[a]=&gt; A =&gt; a] with scalaz.Unzip[[a]=&gt; A =&gt; a] with scalaz.Distributive[[a]=&gt; A =&gt; a]" class="delimiter">(</a><a href="#299055" title="=&gt; A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>