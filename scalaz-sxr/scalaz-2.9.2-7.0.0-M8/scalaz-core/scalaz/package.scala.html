<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scalaz-core/scalaz/package.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * '''Scalaz''': Type classes and pure functional data structures for Scala.
 *
 * This package, [[scalaz]], contains:
 *  - type class definitions
 *  - data structures
 *  - related functions
 *
 * Type class instances and other functions related to the Scala and Java standard library
 * are in scalaz.[[scalaz.std]]
 *
 * Implicit conversions and wrapper classes that provide a more convenient syntax for accessing
 * the functionality of the library are in scalaz.[[scalaz.syntax]].
 *
 * '''Type Classes Index'''
 *
 *  - [[scalaz.Semigroup]]
 *  - [[scalaz.Monoid]] extends [[scalaz.Semigroup]]
 *  - [[scalaz.Equal]]
 *  - [[scalaz.Length]]
 *  - [[scalaz.Show]]
 *  - [[scalaz.Order]] extends [[scalaz.Equal]]
 *  - [[scalaz.Enum]] extends [[scalaz.Order]]
 *
 *  - [[scalaz.MetricSpace]]
 *  - [[scalaz.Plus]]
 *  - [[scalaz.PlusEmpty]] extends [[scalaz.Plus]]
 *  - [[scalaz.IsEmpty]] extends [[scalaz.PlusEmpty]]
 *  - [[scalaz.Each]]
 *  - [[scalaz.Index]]
 *  - [[scalaz.Functor]]
 *  - [[scalaz.Contravariant]]
 *  - [[scalaz.Apply]] extends [[scalaz.Functor]]
 *  - [[scalaz.Applicative]] extends [[scalaz.Apply]]
 *  - [[scalaz.Zip]]
 *  - [[scalaz.Unzip]]
 *  - [[scalaz.Cozip]]
 *  - [[scalaz.Bind]] extends [[scalaz.Apply]]
 *  - [[scalaz.Monad]] extends [[scalaz.Applicative]] with [[scalaz.Bind]]
 *  - [[scalaz.Cojoin]] extends [[scalaz.Functor]]
 *  - [[scalaz.Cobind]] extends [[scalaz.Functor]]
 *  - [[scalaz.Comonad]] extends [[scalaz.Cojoin]] with [[scalaz.Cobind]]
 *  - [[scalaz.ApplicativePlus]] extends [[scalaz.Applicative]] with [[scalaz.PlusEmpty]]
 *  - [[scalaz.MonadPlus]] extends [[scalaz.Monad]] with [[scalaz.ApplicativePlus]]
 *  - [[scalaz.Foldable]]
 *  - [[scalaz.Traverse]] extends [[scalaz.Functor]] with [[scalaz.Foldable]]
 *
 *  - [[scalaz.Bifunctor]]
 *  - [[scalaz.Bifoldable]]
 *  - [[scalaz.Bitraverse]] extends [[scalaz.Bifunctor]] with [[scalaz.Bifoldable]]
 *  - [[scalaz.Compose]]
 *  - [[scalaz.Category]] extends [[scalaz.Compose]]
 *  - [[scalaz.Choice]] extends [[scalaz.Category]]
 *  - [[scalaz.Split]] extends [[scalaz.Category]]
 *  - [[scalaz.Arrow]] extends [[scalaz.Category]]
 *
 *  '''Data Structures Index'''
 *  - [[scalaz.Validation]] Represent computations that may succeed or fail, accumulating multiple errors.
 *  - [[scalaz.NonEmptyList]] A list containing at least one element.
 *  - [[scalaz.DList]] A difference list, supporting efficient append and prepend.
 *  - [[scalaz.EphemeralStream]] A stream that holds weak references to its elements, and recomputes them if needed
 *    if reclaimed by the garbage collector.
 *  - [[scalaz.Heap]] A priority queue, implemented with bootstrapped skew binomial heaps.
 *  - [[scalaz.Endo]] Represents functions from `A =&gt; A`.
 *  - [[scalaz.FingerTree]] A tree containing elements at it's leaves, and measures at the nodes. Can be adapted to
 *    various purposes by choosing a different measure, for example [[scalaz.IndSeq]] and [[scalaz.OrdSeq]].
 *  - [[scalaz.Lens]] Composable, functional alternative to getters and setters
 *  - [[scalaz.Tree]] A multiway tree. Each node contains a single element, and a `Stream` of sub-trees.
 *  - [[scalaz.TreeLoc]] A cursor over a [[scalaz.Tree]].
 *  - [[scalaz.Zipper]] A functional cursor over a List.
 *
 *  - [[scalaz.Kleisli]] Represents a function `A =&gt; M[B]`, allowing chaining. Also known, and aliased, as `scalaz.ReaderT`.
 *  - [[scalaz.StateT]] Computations that modify state.
 *  - [[scalaz.WriterT]] Computations that log a value
 *  - [[scalaz.OptionT]] Represents computations of type `F[Option[A]]`
 *  - [[scalaz.EitherT]] Represents computations of type `F[A \/ B]`
 */</span>
<span class="keyword">package</span> <span class="keyword">object</span> <a title="object scalaz.package" id="13276">scalaz</a> <span title="ScalaObject" class="delimiter">{</span>
  <span class="keyword">import</span> <a href="Id.scala.html#11827" title="object scalaz.Id">Id</a>._

  <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="package extends scalaz.Traverse1[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]" id="40348">idInstance</a>: <a href="#43738" title="package extends scalaz.Traverse1[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]">Traverse1</a><span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Each<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Monad<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Comonad<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Cojoin<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Distributive<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Zip<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Unzip<span class="delimiter">[</span>Id<span class="delimiter">]</span> <span class="keyword">with</span> Cozip<span class="delimiter">[</span>Id<span class="delimiter">]</span> = <a href="Id.scala.html#11827" title="object scalaz.Id">Id</a>.<a href="Id.scala.html#43735" title="=&gt; scalaz.Traverse1[scalaz.Id.Id] with scalaz.Each[scalaz.Id.Id] with scalaz.Monad[scalaz.Id.Id] with scalaz.Comonad[scalaz.Id.Id] with scalaz.Cojoin[scalaz.Id.Id] with scalaz.Distributive[scalaz.Id.Id] with scalaz.Zip[scalaz.Id.Id] with scalaz.Unzip[scalaz.Id.Id] with scalaz.Cozip[scalaz.Id.Id]">id</a>

  <span class="keyword">type</span> <a title="package[T] extends AnyRef" id="40350">Tagged</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40351">T</a><span class="delimiter">]</span> = <a href="#58760" title="package extends AnyRef" class="delimiter">{</a><span class="keyword">type</span> Tag = T<span class="delimiter">}</span>

  <span class="comment">/**
   * Tag a type `T` with `Tag`. The resulting type is a subtype of `T`.
   *
   * The resulting type is used to discriminate between type class instances.
   *
   * @see [[scalaz.Tag]] and [[scalaz.Tags]]
   *
   * Credit to Miles Sabin for the idea.
   */</span>
  <span class="keyword">type</span> <a title="package[T, Tag] extends T with scalaz.package.Tagged[Tag]" id="40352">@@</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40353">T</a>, <a title="&gt;: Nothing &lt;: Any" id="40354">Tag</a><span class="delimiter">]</span> = <a href="#58765" title="package extends T with scalaz.package.Tagged[Tag]">T</a> <span class="keyword">with</span> Tagged<span class="delimiter">[</span>Tag<span class="delimiter">]</span>

  <span class="comment">/** A [[scalaz.NaturalTransformation]][F, G]. */</span>
  <span class="keyword">type</span> <a title="[-F[_], +G[_]]scalaz.NaturalTransformation[F,G]" id="40355">~&gt;</a><span class="delimiter">[</span>-<a title="[_]&gt;: Nothing &lt;: Any" id="40356">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="142790">_</a><span class="delimiter">]</span>, +<a title="[_]&gt;: Nothing &lt;: Any" id="40357">G</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="142791">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="NaturalTransformation.scala.html#17343" title="scalaz.NaturalTransformation[F,G]">NaturalTransformation</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span>
  <span class="comment">/** A [[scalaz.NaturalTransformation]][G, F]. */</span>
  <span class="keyword">type</span> <a title="[+F[_], -G[_]]scalaz.NaturalTransformation[G,F]" id="40358">&lt;~</a><span class="delimiter">[</span>+<a title="[_]&gt;: Nothing &lt;: Any" id="40359">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="436716">_</a><span class="delimiter">]</span>, -<a title="[_]&gt;: Nothing &lt;: Any" id="40360">G</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="436717">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="NaturalTransformation.scala.html#17343" title="scalaz.NaturalTransformation[G,F]">NaturalTransformation</a><span class="delimiter">[</span>G, F<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[-F[_,_], +G[_,_]]scalaz.BiNaturalTransformation[F,G]" id="40361">~~&gt;</a><span class="delimiter">[</span>-<a title="[_, _]&gt;: Nothing &lt;: Any" id="40362">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="368370">_</a>,<a title="&gt;: Nothing &lt;: Any" id="368371">_</a><span class="delimiter">]</span>, +<a title="[_, _]&gt;: Nothing &lt;: Any" id="40363">G</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="368372">_</a>,<a title="&gt;: Nothing &lt;: Any" id="368373">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="NaturalTransformation.scala.html#18003" title="scalaz.BiNaturalTransformation[F,G]">BiNaturalTransformation</a><span class="delimiter">[</span>F, G<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="Nothing" id="40364">⊥</a> = <span title="Nothing">Nothing</span>
  <span class="keyword">type</span> <a title="Any" id="40365">⊤</a> = <span title="Any">Any</span>

  <span class="keyword">type</span> <a title="[G[_], F[_]]scalaz.MonadPartialOrder[G,F]" id="40366">|&gt;=|</a><span class="delimiter">[</span><a title="[_]&gt;: Nothing &lt;: Any" id="40367">G</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="436718">_</a><span class="delimiter">]</span>, <a title="[_]&gt;: Nothing &lt;: Any" id="40368">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="436719">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="MonadTrans.scala.html#17169" title="scalaz.MonadPartialOrder[G,F]">MonadPartialOrder</a><span class="delimiter">[</span>G, F<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[F[+_], -E, +A]scalaz.Kleisli[F,E,A]" id="40369">ReaderT</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="40370">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="112880">_</a><span class="delimiter">]</span>, -<a title="&gt;: Nothing &lt;: Any" id="40371">E</a>, +<a title="&gt;: Nothing &lt;: Any" id="40372">A</a><span class="delimiter">]</span> = <a href="Kleisli.scala.html#23919" title="scalaz.Kleisli[F,E,A]">Kleisli</a><span class="delimiter">[</span>F, E, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[-E, +A]scalaz.Kleisli[Option,E,A]" id="40373">=?&gt;</a><span class="delimiter">[</span>-<a title="&gt;: Nothing &lt;: Any" id="40374">E</a>, +<a title="&gt;: Nothing &lt;: Any" id="40375">A</a><span class="delimiter">]</span> = <a href="Kleisli.scala.html#23919" title="scalaz.Kleisli[Option,E,A]">Kleisli</a><span class="delimiter">[</span>Option, E, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[-E, +A]scalaz.package.ReaderT[scalaz.Id.Id,E,A]" id="40376">Reader</a><span class="delimiter">[</span>-<a title="&gt;: Nothing &lt;: Any" id="40377">E</a>, +<a title="&gt;: Nothing &lt;: Any" id="40378">A</a><span class="delimiter">]</span> = <a href="Kleisli.scala.html#23919" title="scalaz.package.ReaderT[scalaz.Id.Id,E,A]">ReaderT</a><span class="delimiter">[</span>Id, E, A<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[+W, +A]scalaz.WriterT[scalaz.Id.Id,W,A]" id="40379">Writer</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="40380">W</a>, +<a title="&gt;: Nothing &lt;: Any" id="40381">A</a><span class="delimiter">]</span> = <a href="WriterT.scala.html#12393" title="scalaz.WriterT[scalaz.Id.Id,W,A]">WriterT</a><span class="delimiter">[</span>Id, W, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[+W, +A]scalaz.UnwriterT[scalaz.Id.Id,W,A]" id="40382">Unwriter</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="40383">W</a>, +<a title="&gt;: Nothing &lt;: Any" id="40384">A</a><span class="delimiter">]</span> = <a href="UnwriterT.scala.html#16254" title="scalaz.UnwriterT[scalaz.Id.Id,W,A]">UnwriterT</a><span class="delimiter">[</span>Id, W, A<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="object scalaz.package.Reader" id="40385">Reader</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[E, A](f: E =&gt; A)scalaz.package.Reader[E,A]" id="112882">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="112885">E</a>, <a title="&gt;: Nothing &lt;: Any" id="112886">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="E =&gt; A" id="112887">f</a>: E =&gt; A<span class="delimiter">)</span>: <a href="Kleisli.scala.html#23919" title="scalaz.package.Reader[E,A]">Reader</a><span class="delimiter">[</span>E, A<span class="delimiter">]</span> = <a href="Kleisli.scala.html#54286" title="[M[+_], A, B](f: A =&gt; M[B])scalaz.Kleisli[M,A,B]">Kleisli</a><span title="(f: E =&gt; scalaz.Id.Id[A])scalaz.Kleisli[scalaz.Id.Id,E,A]" class="delimiter">[</span><a href="Id.scala.html#43732" title="scalaz.Id.Id">Id</a>, <a href="#112885" title="E">E</a>, <a href="#112886" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#112887" title="E =&gt; A">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object scalaz.package.Writer" id="40387">Writer</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[W, A](w: W, a: A)scalaz.WriterT[scalaz.Id.Id,W,A]" id="112897">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="112900">W</a>, <a title="&gt;: Nothing &lt;: Any" id="112901">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="W" id="112902">w</a>: <a href="#112900" title="W">W</a>, <a title="A" id="112903">a</a>: <a href="#112901" title="A">A</a><span class="delimiter">)</span>: <a href="WriterT.scala.html#12393" title="scalaz.WriterT[scalaz.Id.Id,W,A]">WriterT</a><span class="delimiter">[</span>Id, W, A<span class="delimiter">]</span> = <a href="WriterT.scala.html#110515" title="[F[+_], W, A](v: F[(W, A)])scalaz.WriterT[F,W,A]">WriterT</a><span title="(v: (W, A))scalaz.WriterT[scalaz.Id.Id,W,A]" class="delimiter">[</span><a href="Id.scala.html#43732" title="scalaz.Id.Id">Id</a>, <a href="#112900" title="W">W</a>, <a href="#112901" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="(_1: W, _2: A)(W, A)" class="delimiter">(</span><a href="#112902" title="W">w</a>, <a href="#112903" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="object scalaz.package.Unwriter" id="40389">Unwriter</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[U, A](u: U, a: A)scalaz.UnwriterT[scalaz.Id.Id,U,A]" id="428897">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="428900">U</a>, <a title="&gt;: Nothing &lt;: Any" id="428901">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="428902">u</a>: <a href="#428900" title="U">U</a>, <a title="A" id="428903">a</a>: <a href="#428901" title="A">A</a><span class="delimiter">)</span>: <a href="UnwriterT.scala.html#16254" title="scalaz.UnwriterT[scalaz.Id.Id,U,A]">UnwriterT</a><span class="delimiter">[</span>Id, U, A<span class="delimiter">]</span> = <a href="UnwriterT.scala.html#425520" title="[F[+_], W, A](v: F[(W, A)])scalaz.UnwriterT[F,W,A]">UnwriterT</a><span title="(v: (U, A))scalaz.UnwriterT[scalaz.Id.Id,U,A]" class="delimiter">[</span><a href="Id.scala.html#43732" title="scalaz.Id.Id">Id</a>, <a href="#428900" title="U">U</a>, <a href="#428901" title="A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><span title="(_1: U, _2: A)(U, A)" class="delimiter">(</span><a href="#428902" title="U">u</a>, <a href="#428903" title="A">a</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * StateT Monad Transformer
   *
   * [[http://www.youtube.com/watch?feature=player_detailpage&amp;v=XVmhK8WbRLY#t=585s An introduction to the State Monad]]
   */</span>
  <span class="keyword">type</span> <a title="[F[+_], S, +A]scalaz.IndexedStateT[F,S,S,A]" id="40391">StateT</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="40392">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="86007">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="40393">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="40394">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#18774" title="scalaz.IndexedStateT[F,S,S,A]">IndexedStateT</a><span class="delimiter">[</span>F, S, S, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[-S1, +S2, +A]scalaz.IndexedStateT[scalaz.Id.Id,S1,S2,A]" id="40395">IndexedState</a><span class="delimiter">[</span>-<a title="&gt;: Nothing &lt;: Any" id="40396">S1</a>, +<a title="&gt;: Nothing &lt;: Any" id="40397">S2</a>, +<a title="&gt;: Nothing &lt;: Any" id="40398">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#18774" title="scalaz.IndexedStateT[scalaz.Id.Id,S1,S2,A]">IndexedStateT</a><span class="delimiter">[</span>Id, S1, S2, A<span class="delimiter">]</span>
  <span class="comment">/** A state transition, representing a function `S =&gt; (A, S)`. */</span>
  <span class="keyword">type</span> <a title="[S, +A]scalaz.package.StateT[scalaz.Id.Id,S,A]" id="40399">State</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40400">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="40401">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#18774" title="scalaz.package.StateT[scalaz.Id.Id,S,A]">StateT</a><span class="delimiter">[</span>Id, S, A<span class="delimiter">]</span>

  <span class="comment">// important to define here, rather than at the top-level, to avoid Scala 2.9.2 bug</span>
  <span class="keyword">object</span> <a title="object scalaz.package.StateT" id="40402">StateT</a> <span title="ScalaObject" class="keyword">extends</span> <a href="StateT.scala.html#14643" title="scalaz.StateTFunctions">StateTFunctions</a> <span class="keyword">with</span> <a href="StateT.scala.html#10272" title="scalaz.StateTInstances">StateTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[F[+_], S, A](f: S =&gt; F[(S, A)])scalaz.package.StateT[F,S,A]" id="140369">apply</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="140373">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="370495">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="140374">S</a>, <a title="&gt;: Nothing &lt;: Any" id="140375">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; F[(S, A)]" id="370494">f</a>: S =&gt; F<span class="delimiter">[</span><span class="delimiter">(</span>S, A<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="StateT.scala.html#18774" title="scalaz.package.StateT[F,S,A]">StateT</a><span class="delimiter">[</span>F, S, A<span class="delimiter">]</span> = <a href="#436739" title="java.lang.Object with scalaz.package.StateT[F,S,A]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.package.StateT[F,S,A]" id="436739">StateT</a><span class="delimiter">[</span>F, S, A<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(s: S)F[(S, A)]" id="436743">apply</a><span class="delimiter">(</span><a title="S" id="436744">s</a>: <a href="#140374" title="S">S</a><span class="delimiter">)</span> = <a href="#370494" title="(v1: S)F[(S, A)]">f</a><span class="delimiter">(</span><a href="#436744" title="S">s</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object scalaz.package.IndexedState" id="40404">IndexedState</a> <span title="ScalaObject" class="keyword">extends</span> <a href="State.scala.html#19302" title="scalaz.StateFunctions">StateFunctions</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[S1, S2, A](f: S1 =&gt; (S2, A))scalaz.package.IndexedState[S1,S2,A]" id="383064">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="383068">S1</a>, <a title="&gt;: Nothing &lt;: Any" id="383069">S2</a>, <a title="&gt;: Nothing &lt;: Any" id="383070">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S1 =&gt; (S2, A)" id="383071">f</a>: S1 =&gt; <span class="delimiter">(</span>S2, A<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="StateT.scala.html#18774" title="scalaz.package.IndexedState[S1,S2,A]">IndexedState</a><span class="delimiter">[</span>S1, S2, A<span class="delimiter">]</span> = <a href="#436752" title="java.lang.Object with scalaz.package.IndexedState[S1,S2,A]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.package.IndexedState[S1,S2,A]" id="436752">IndexedState</a><span class="delimiter">[</span>S1, S2, A<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(s: S1)(S2, A)" id="436756">apply</a><span class="delimiter">(</span><a title="S1" id="436757">s</a>: <a href="#383068" title="S1">S1</a><span class="delimiter">)</span> = <a href="#383071" title="(v1: S1)(S2, A)">f</a><span class="delimiter">(</span><a href="#436757" title="S1">s</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object scalaz.package.State" id="40406">State</a> <span title="ScalaObject" class="keyword">extends</span> <a href="State.scala.html#19302" title="scalaz.StateFunctions">StateFunctions</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[S, A](f: S =&gt; (S, A))scalaz.package.State[S,A]" id="86091">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="86094">S</a>, <a title="&gt;: Nothing &lt;: Any" id="86095">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="S =&gt; (S, A)" id="86096">f</a>: S =&gt; <span class="delimiter">(</span>S, A<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="StateT.scala.html#18774" title="scalaz.package.State[S,A]">State</a><span class="delimiter">[</span>S, A<span class="delimiter">]</span> = <a href="#436765" title="java.lang.Object with scalaz.package.StateT[scalaz.Id.Id,S,A]" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with scalaz.package.StateT[scalaz.Id.Id,S,A]" id="436765">StateT</a><span class="delimiter">[</span>Id, S, A<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(s: S)(S, A)" id="436769">apply</a><span class="delimiter">(</span><a title="S" id="436770">s</a>: <a href="#86094" title="S">S</a><span class="delimiter">)</span> = <a href="#86096" title="(v1: S)(S, A)">f</a><span class="delimiter">(</span><a href="#436770" title="S">s</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[F[+_], A, +B]scalaz.IndexedStoreT[F,A,A,B]" id="40408">StoreT</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="40409">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="383907">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="40410">A</a>, +<a title="&gt;: Nothing &lt;: Any" id="40411">B</a><span class="delimiter">]</span> = <a href="StoreT.scala.html#22515" title="scalaz.IndexedStoreT[F,A,A,B]">IndexedStoreT</a><span class="delimiter">[</span>F, A, A, B<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[+I, -A, +B]scalaz.IndexedStoreT[scalaz.Id.Id,I,A,B]" id="40412">IndexedStore</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="40413">I</a>, -<a title="&gt;: Nothing &lt;: Any" id="40414">A</a>, +<a title="&gt;: Nothing &lt;: Any" id="40415">B</a><span class="delimiter">]</span> = <a href="StoreT.scala.html#22515" title="scalaz.IndexedStoreT[scalaz.Id.Id,I,A,B]">IndexedStoreT</a><span class="delimiter">[</span>Id, I, A, B<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[A, +B]scalaz.package.StoreT[scalaz.Id.Id,A,B]" id="40416">Store</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40417">A</a>, +<a title="&gt;: Nothing &lt;: Any" id="40418">B</a><span class="delimiter">]</span> = <a href="StoreT.scala.html#22515" title="scalaz.package.StoreT[scalaz.Id.Id,A,B]">StoreT</a><span class="delimiter">[</span>Id, A, B<span class="delimiter">]</span>
  <span class="comment">// flipped</span>
  <span class="keyword">type</span> <a title="[+A, B]scalaz.package.Store[B,A]" id="40419">|--&gt;</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="40420">A</a>, <a title="&gt;: Nothing &lt;: Any" id="40421">B</a><span class="delimiter">]</span> = <a href="StoreT.scala.html#22515" title="scalaz.package.Store[B,A]">Store</a><span class="delimiter">[</span>B, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="object scalaz.package.StoreT" id="40422">StoreT</a> <span title="ScalaObject" class="keyword">extends</span> <a href="StoreT.scala.html#19488" title="scalaz.StoreTFunctions">StoreTFunctions</a> <span class="keyword">with</span> <a href="StoreT.scala.html#24348" title="scalaz.StoreTInstances">StoreTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[F[+_], A, B](r: (F[A =&gt; B], A))scalaz.package.StoreT[F,A,B]" id="382273">apply</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="382277">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="413691">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="382278">A</a>, <a title="&gt;: Nothing &lt;: Any" id="382279">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(F[A =&gt; B], A)" id="413690">r</a>: <span title="(F[A =&gt; B], A)" class="delimiter">(</span>F<span class="delimiter">[</span>A =&gt; B<span class="delimiter">]</span>, A<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="StoreT.scala.html#22515" title="scalaz.package.StoreT[F,A,B]">StoreT</a><span class="delimiter">[</span>F, A, B<span class="delimiter">]</span> =
      <a href="StoreT.scala.html#382260" title="(r: (F[A =&gt; B], A))scalaz.package.StoreT[F,A,B]">storeT</a><span class="delimiter">(</span><a href="#413690" title="(F[A =&gt; B], A)">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object scalaz.package.IndexedStore" id="40424">IndexedStore</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[I, A, B](f: A =&gt; B, i: I)scalaz.package.IndexedStore[I,A,B]" id="383322">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="383326">I</a>, <a title="&gt;: Nothing &lt;: Any" id="383327">A</a>, <a title="&gt;: Nothing &lt;: Any" id="383328">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="383329">f</a>: A =&gt; B, <a title="I" id="383330">i</a>: <a href="#383326" title="I">I</a><span class="delimiter">)</span>: <a href="StoreT.scala.html#22515" title="scalaz.package.IndexedStore[I,A,B]">IndexedStore</a><span class="delimiter">[</span>I, A, B<span class="delimiter">]</span> = <a href="StoreT.scala.html#22516" title="object scalaz.IndexedStoreT">IndexedStoreT</a>.<a href="StoreT.scala.html#382252" title="(i: I)(f: A =&gt; B)scalaz.package.IndexedStore[I,A,B]">indexedStore</a><span class="delimiter">(</span><a href="#383330" title="I">i</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#383329" title="A =&gt; B">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="keyword">object</span> <a title="object scalaz.package.Store" id="40426">Store</a> <span title="ScalaObject" class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](f: A =&gt; B, a: A)scalaz.package.Store[A,B]" id="126081">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="126084">A</a>, <a title="&gt;: Nothing &lt;: Any" id="126085">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; B" id="126086">f</a>: A =&gt; B, <a title="A" id="126087">a</a>: <a href="#126084" title="A">A</a><span class="delimiter">)</span>: <a href="StoreT.scala.html#22515" title="scalaz.package.Store[A,B]">Store</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> = <a href="#40422" title="object scalaz.package.StoreT">StoreT</a>.<a href="StoreT.scala.html#382267" title="(a: A)(f: A =&gt; B)scalaz.package.Store[A,B]">store</a><span class="delimiter">(</span><a href="#126087" title="A">a</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#126086" title="A =&gt; B">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>


  <span class="keyword">type</span> <a title="[F[+_], -R, +W, S, +A]scalaz.IndexedReaderWriterStateT[F,R,W,S,S,A]" id="40428">ReaderWriterStateT</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="40429">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="370305">_</a><span class="delimiter">]</span>, -<a title="&gt;: Nothing &lt;: Any" id="40430">R</a>, +<a title="&gt;: Nothing &lt;: Any" id="40431">W</a>, <a title="&gt;: Nothing &lt;: Any" id="40432">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="40433">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#15486" title="scalaz.IndexedReaderWriterStateT[F,R,W,S,S,A]">IndexedReaderWriterStateT</a><span class="delimiter">[</span>F, R, W, S, S, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="object scalaz.package.ReaderWriterStateT" id="40434">ReaderWriterStateT</a> <span title="ScalaObject" class="keyword">extends</span> <a href="ReaderWriterStateT.scala.html#19824" title="scalaz.ReaderWriterStateTFunctions">ReaderWriterStateTFunctions</a> <span class="keyword">with</span> <a href="ReaderWriterStateT.scala.html#17868" title="scalaz.ReaderWriterStateTInstances">ReaderWriterStateTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[F[+_], R, W, S, A](f: (R, S) =&gt; F[(W, A, S)])scalaz.package.ReaderWriterStateT[F,R,W,S,A]" id="370323">apply</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="370329">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="370364">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="370330">R</a>, <a title="&gt;: Nothing &lt;: Any" id="370331">W</a>, <a title="&gt;: Nothing &lt;: Any" id="370332">S</a>, <a title="&gt;: Nothing &lt;: Any" id="370333">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(R, S) =&gt; F[(W, A, S)]" id="370363">f</a>: <span class="delimiter">(</span>R, S<span class="delimiter">)</span> =&gt; F<span class="delimiter">[</span><span class="delimiter">(</span>W, A, S<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="ReaderWriterStateT.scala.html#15486" title="scalaz.package.ReaderWriterStateT[F,R,W,S,A]">ReaderWriterStateT</a><span class="delimiter">[</span>F, R, W, S, A<span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#407368" title="[F[+_], R, W, S1, S2, A](f: (R, S1) =&gt; F[(W, A, S2)])scalaz.IndexedReaderWriterStateT[F,R,W,S1,S2,A]">IndexedReaderWriterStateT</a><span title="(f: (R, S) =&gt; F[(W, A, S)])scalaz.IndexedReaderWriterStateT[F,R,W,S,S,A]" class="delimiter">[</span><a href="#370329" title="F">F</a>, <a href="#370330" title="R">R</a>, <a href="#370331" title="W">W</a>, <a href="#370332" title="S">S</a>, <a href="#370332" title="S">S</a>, <a href="#370333" title="A">A</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="delimiter">(</span>r: <a href="#370330" title="R">R</a>, s: <a href="#370332" title="S">S</a><span class="delimiter">)</span> =&gt; <a href="#370363" title="(v1: R, v2: S)F[(W, A, S)]">f</a><span class="delimiter">(</span><a href="#436813" title="R">r</a>, <a href="#436814" title="S">s</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[-R, +W, -S1, +S2, +A]scalaz.IndexedReaderWriterStateT[scalaz.Id.Id,R,W,S1,S2,A]" id="40436">IndexedReaderWriterState</a><span class="delimiter">[</span>-<a title="&gt;: Nothing &lt;: Any" id="40437">R</a>, +<a title="&gt;: Nothing &lt;: Any" id="40438">W</a>, -<a title="&gt;: Nothing &lt;: Any" id="40439">S1</a>, +<a title="&gt;: Nothing &lt;: Any" id="40440">S2</a>, +<a title="&gt;: Nothing &lt;: Any" id="40441">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#15486" title="scalaz.IndexedReaderWriterStateT[scalaz.Id.Id,R,W,S1,S2,A]">IndexedReaderWriterStateT</a><span class="delimiter">[</span>Id, R, W, S1, S2, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="object scalaz.package.IndexedReaderWriterState" id="40442">IndexedReaderWriterState</a> <span title="ScalaObject" class="keyword">extends</span> <a href="ReaderWriterStateT.scala.html#19824" title="scalaz.ReaderWriterStateTFunctions">ReaderWriterStateTFunctions</a> <span class="keyword">with</span> <a href="ReaderWriterStateT.scala.html#17868" title="scalaz.ReaderWriterStateTInstances">ReaderWriterStateTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[R, W, S1, S2, A](f: (R, S1) =&gt; (W, A, S2))scalaz.package.IndexedReaderWriterState[R,W,S1,S2,A]" id="436692">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="436698">R</a>, <a title="&gt;: Nothing &lt;: Any" id="436699">W</a>, <a title="&gt;: Nothing &lt;: Any" id="436700">S1</a>, <a title="&gt;: Nothing &lt;: Any" id="436701">S2</a>, <a title="&gt;: Nothing &lt;: Any" id="436702">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(R, S1) =&gt; (W, A, S2)" id="436818">f</a>: <span class="delimiter">(</span>R, S1<span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>W, A, S2<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="ReaderWriterStateT.scala.html#15486" title="scalaz.package.IndexedReaderWriterState[R,W,S1,S2,A]">IndexedReaderWriterState</a><span class="delimiter">[</span>R, W, S1, S2, A<span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#407368" title="[F[+_], R, W, S1, S2, A](f: (R, S1) =&gt; F[(W, A, S2)])scalaz.IndexedReaderWriterStateT[F,R,W,S1,S2,A]">IndexedReaderWriterStateT</a><span title="(f: (R, S1) =&gt; (W, A, S2))scalaz.IndexedReaderWriterStateT[scalaz.Id.Id,R,W,S1,S2,A]" class="delimiter">[</span><a href="Id.scala.html#43732" title="scalaz.Id.Id">Id</a>, <a href="#436698" title="R">R</a>, <a href="#436699" title="W">W</a>, <a href="#436700" title="S1">S1</a>, <a href="#436701" title="S2">S2</a>, <a href="#436702" title="A">A</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="delimiter">(</span>r: <a href="#436698" title="R">R</a>, s: <a href="#436700" title="S1">S1</a><span class="delimiter">)</span> =&gt; <a href="#436818" title="(v1: R, v2: S1)(W, A, S2)">f</a><span class="delimiter">(</span><a href="#436823" title="R">r</a>, <a href="#436824" title="S1">s</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[-R, +W, S, +A]scalaz.package.ReaderWriterStateT[scalaz.Id.Id,R,W,S,A]" id="40444">ReaderWriterState</a><span class="delimiter">[</span>-<a title="&gt;: Nothing &lt;: Any" id="40445">R</a>, +<a title="&gt;: Nothing &lt;: Any" id="40446">W</a>, <a title="&gt;: Nothing &lt;: Any" id="40447">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="40448">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#15486" title="scalaz.package.ReaderWriterStateT[scalaz.Id.Id,R,W,S,A]">ReaderWriterStateT</a><span class="delimiter">[</span>Id, R, W, S, A<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="object scalaz.package.ReaderWriterState" id="40449">ReaderWriterState</a> <span title="ScalaObject" class="keyword">extends</span> <a href="ReaderWriterStateT.scala.html#19824" title="scalaz.ReaderWriterStateTFunctions">ReaderWriterStateTFunctions</a> <span class="keyword">with</span> <a href="ReaderWriterStateT.scala.html#17868" title="scalaz.ReaderWriterStateTInstances">ReaderWriterStateTInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[R, W, S, A](f: (R, S) =&gt; (W, A, S))scalaz.package.ReaderWriterState[R,W,S,A]" id="436704">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="436709">R</a>, <a title="&gt;: Nothing &lt;: Any" id="436710">W</a>, <a title="&gt;: Nothing &lt;: Any" id="436711">S</a>, <a title="&gt;: Nothing &lt;: Any" id="436712">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(R, S) =&gt; (W, A, S)" id="436828">f</a>: <span class="delimiter">(</span>R, S<span class="delimiter">)</span> =&gt; <span class="delimiter">(</span>W, A, S<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="ReaderWriterStateT.scala.html#15486" title="scalaz.package.ReaderWriterState[R,W,S,A]">ReaderWriterState</a><span class="delimiter">[</span>R, W, S, A<span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#407368" title="[F[+_], R, W, S1, S2, A](f: (R, S1) =&gt; F[(W, A, S2)])scalaz.IndexedReaderWriterStateT[F,R,W,S1,S2,A]">IndexedReaderWriterStateT</a><span title="(f: (R, S) =&gt; (W, A, S))scalaz.IndexedReaderWriterStateT[scalaz.Id.Id,R,W,S,S,A]" class="delimiter">[</span><a href="Id.scala.html#43732" title="scalaz.Id.Id">Id</a>, <a href="#436709" title="R">R</a>, <a href="#436710" title="W">W</a>, <a href="#436711" title="S">S</a>, <a href="#436711" title="S">S</a>, <a href="#436712" title="A">A</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="delimiter">(</span>r: <a href="#436709" title="R">R</a>, s: <a href="#436711" title="S">S</a><span class="delimiter">)</span> =&gt; <a href="#436828" title="(v1: R, v2: S)(W, A, S)">f</a><span class="delimiter">(</span><a href="#436833" title="R">r</a>, <a href="#436834" title="S">s</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="keyword">type</span> <a title="[F[+_], -R, +W, -S1, +S2, +A]scalaz.IndexedReaderWriterStateT[F,R,W,S1,S2,A]" id="40451">IRWST</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="40452">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="436837">_</a><span class="delimiter">]</span>, -<a title="&gt;: Nothing &lt;: Any" id="40453">R</a>, +<a title="&gt;: Nothing &lt;: Any" id="40454">W</a>, -<a title="&gt;: Nothing &lt;: Any" id="40455">S1</a>, +<a title="&gt;: Nothing &lt;: Any" id="40456">S2</a>, +<a title="&gt;: Nothing &lt;: Any" id="40457">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#15486" title="scalaz.IndexedReaderWriterStateT[F,R,W,S1,S2,A]">IndexedReaderWriterStateT</a><span class="delimiter">[</span>F, R, W, S1, S2, A<span class="delimiter">]</span>
  <span class="keyword">val</span> <a title="scalaz.IndexedReaderWriterStateT.type" id="40458">IRWST</a>: IndexedReaderWriterStateT.<span class="keyword">type</span> = <a href="ReaderWriterStateT.scala.html#15487" title="object scalaz.IndexedReaderWriterStateT">IndexedReaderWriterStateT</a>
  <span class="keyword">type</span> <a title="[-R, +W, -S1, +S2, +A]scalaz.package.IndexedReaderWriterState[R,W,S1,S2,A]" id="40460">IRWS</a><span class="delimiter">[</span>-<a title="&gt;: Nothing &lt;: Any" id="40461">R</a>, +<a title="&gt;: Nothing &lt;: Any" id="40462">W</a>, -<a title="&gt;: Nothing &lt;: Any" id="40463">S1</a>, +<a title="&gt;: Nothing &lt;: Any" id="40464">S2</a>, +<a title="&gt;: Nothing &lt;: Any" id="40465">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#15486" title="scalaz.package.IndexedReaderWriterState[R,W,S1,S2,A]">IndexedReaderWriterState</a><span class="delimiter">[</span>R, W, S1, S2, A<span class="delimiter">]</span>
  <span class="keyword">val</span> <a title="scalaz.package.IndexedReaderWriterState.type" id="40466">IRWS</a>: IndexedReaderWriterState.<span class="keyword">type</span> = <a href="#40442" title="object scalaz.package.IndexedReaderWriterState">IndexedReaderWriterState</a>
  <span class="keyword">type</span> <a title="[F[+_], -R, +W, S, +A]scalaz.package.ReaderWriterStateT[F,R,W,S,A]" id="40468">RWST</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="40469">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="436838">_</a><span class="delimiter">]</span>, -<a title="&gt;: Nothing &lt;: Any" id="40470">R</a>, +<a title="&gt;: Nothing &lt;: Any" id="40471">W</a>, <a title="&gt;: Nothing &lt;: Any" id="40472">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="40473">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#15486" title="scalaz.package.ReaderWriterStateT[F,R,W,S,A]">ReaderWriterStateT</a><span class="delimiter">[</span>F, R, W, S, A<span class="delimiter">]</span>
  <span class="keyword">val</span> <a title="scalaz.package.ReaderWriterStateT.type" id="40474">RWST</a>: ReaderWriterStateT.<span class="keyword">type</span> = <a href="#40434" title="object scalaz.package.ReaderWriterStateT">ReaderWriterStateT</a>
  <span class="keyword">type</span> <a title="[-R, +W, S, +A]scalaz.package.ReaderWriterState[R,W,S,A]" id="40476">RWS</a><span class="delimiter">[</span>-<a title="&gt;: Nothing &lt;: Any" id="40477">R</a>, +<a title="&gt;: Nothing &lt;: Any" id="40478">W</a>, <a title="&gt;: Nothing &lt;: Any" id="40479">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="40480">A</a><span class="delimiter">]</span> = <a href="ReaderWriterStateT.scala.html#15486" title="scalaz.package.ReaderWriterState[R,W,S,A]">ReaderWriterState</a><span class="delimiter">[</span>R, W, S, A<span class="delimiter">]</span>
  <span class="keyword">val</span> <a title="scalaz.package.ReaderWriterState.type" id="40481">RWS</a>: ReaderWriterState.<span class="keyword">type</span> = <a href="#40449" title="object scalaz.package.ReaderWriterState">ReaderWriterState</a>

  <span class="keyword">type</span> <a title="[F[_]]scalaz.ApplicativePlus[F]" id="40483">Alternative</a><span class="delimiter">[</span><a title="[_]&gt;: Nothing &lt;: Any" id="40484">F</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="436839">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="ApplicativePlus.scala.html#17922" title="scalaz.ApplicativePlus[F]">ApplicativePlus</a><span class="delimiter">[</span>F<span class="delimiter">]</span>

  <span class="comment">/**
   * An [[scalaz.Validation]] with a [[scalaz.NonEmptyList]] as the failure type.
   *
   * Useful for accumulating errors through the corresponding [[scalaz.Applicative]] instance.
   */</span>
  <span class="keyword">type</span> <a title="[+E, +X]scalaz.Validation[scalaz.NonEmptyList[E],X]" id="40485">ValidationNEL</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="40486">E</a>, +<a title="&gt;: Nothing &lt;: Any" id="40487">X</a><span class="delimiter">]</span> = <a href="Validation.scala.html#12261" title="scalaz.Validation[scalaz.NonEmptyList[E],X]">Validation</a><span class="delimiter">[</span>NonEmptyList<span class="delimiter">[</span>E<span class="delimiter">]</span>, X<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[A,scalaz.Tags.FirstVal]" id="40488">FirstOf</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40489">A</a><span class="delimiter">]</span> = A <a href="#436840" title="scalaz.package.@@[A,scalaz.Tags.FirstVal]">@@</a> Tags.FirstVal
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[A,scalaz.Tags.LastVal]" id="40490">LastOf</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40491">A</a><span class="delimiter">]</span> = A <a href="#436845" title="scalaz.package.@@[A,scalaz.Tags.LastVal]">@@</a> Tags.LastVal
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[A,scalaz.Tags.MinVal]" id="40492">MinOf</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40493">A</a><span class="delimiter">]</span> = A <a href="#436850" title="scalaz.package.@@[A,scalaz.Tags.MinVal]">@@</a> Tags.MinVal
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[A,scalaz.Tags.MaxVal]" id="40494">MaxOf</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40495">A</a><span class="delimiter">]</span> = A <a href="#436855" title="scalaz.package.@@[A,scalaz.Tags.MaxVal]">@@</a> Tags.MaxVal

  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.First]" id="40496">FirstOption</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40497">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#96093" title="scalaz.package.@@[Option[A],scalaz.Tags.First]">@@</a> Tags.First
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.Last]" id="40498">LastOption</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40499">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#96237" title="scalaz.package.@@[Option[A],scalaz.Tags.Last]">@@</a> Tags.Last
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.Min]" id="40500">MinOption</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40501">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#96367" title="scalaz.package.@@[Option[A],scalaz.Tags.Min]">@@</a> Tags.Min
  <span class="keyword">type</span> <a title="[A]scalaz.package.@@[Option[A],scalaz.Tags.Max]" id="40502">MaxOption</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40503">A</a><span class="delimiter">]</span> = Option<span class="delimiter">[</span>A<span class="delimiter">]</span> <a href="#94470" title="scalaz.package.@@[Option[A],scalaz.Tags.Max]">@@</a> Tags.Max

  <span class="comment">//</span>
  <span class="comment">// Lens type aliases</span>
  <span class="comment">//</span>
  <span class="comment">/** A lens that doesn't transform the type of the record. */</span>
  <span class="keyword">type</span> <a title="[A, B]scalaz.LensFamily[A,A,B,B]" id="40504">Lens</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40505">A</a>, <a title="&gt;: Nothing &lt;: Any" id="40506">B</a><span class="delimiter">]</span> = <a href="Lens.scala.html#12153" title="scalaz.LensFamily[A,A,B,B]">LensFamily</a><span class="delimiter">[</span>A, A, B, B<span class="delimiter">]</span>

  <span class="comment">// important to define here, rather than at the top-level, to avoid Scala 2.9.2 bug</span>
  <span class="keyword">object</span> <a title="object scalaz.package.Lens" id="40507">Lens</a> <span title="ScalaObject" class="keyword">extends</span> <a href="Lens.scala.html#12594" title="scalaz.LensFunctions">LensFunctions</a> <span class="keyword">with</span> <a href="Lens.scala.html#10563" title="scalaz.LensInstances">LensInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](r: A =&gt; scalaz.package.Store[B,A])scalaz.package.Lens[A,B]" id="125785">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="125788">A</a>, <a title="&gt;: Nothing &lt;: Any" id="125789">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; scalaz.package.Store[B,A]" id="126071">r</a>: A =&gt; Store<span class="delimiter">[</span>B, A<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Lens.scala.html#12153" title="scalaz.package.Lens[A,B]">Lens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
      <a href="Lens.scala.html#125707" title="(r: A =&gt; scalaz.package.Store[B,A])scalaz.package.Lens[A,B]">lens</a><span class="delimiter">(</span><a href="#126071" title="A =&gt; scalaz.package.Store[B,A]">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[A, B]scalaz.package.Lens[A,B]" id="40509">@&gt;</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40510">A</a>, <a title="&gt;: Nothing &lt;: Any" id="40511">B</a><span class="delimiter">]</span> = <a href="Lens.scala.html#12153" title="scalaz.package.Lens[A,B]">Lens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>

  <span class="comment">//</span>
  <span class="comment">// Partial Lens type aliases</span>
  <span class="comment">//</span>
  <span class="comment">/** A partial lens that doesn't transform the type of the record. */</span>
  <span class="keyword">type</span> <a title="[A, B]scalaz.PLensFamily[A,A,B,B]" id="40512">PLens</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40513">A</a>, <a title="&gt;: Nothing &lt;: Any" id="40514">B</a><span class="delimiter">]</span> = <a href="PLens.scala.html#10521" title="scalaz.PLensFamily[A,A,B,B]">PLensFamily</a><span class="delimiter">[</span>A, A, B, B<span class="delimiter">]</span>

  <span class="comment">// important to define here, rather than at the top-level, to avoid Scala 2.9.2 bug</span>
  <span class="keyword">object</span> <a title="object scalaz.package.PLens" id="40515">PLens</a> <span title="ScalaObject" class="keyword">extends</span> <a href="PLens.scala.html#19716" title="scalaz.PLensFunctions">PLensFunctions</a> <span class="keyword">with</span> <a href="PLens.scala.html#9801" title="scalaz.PLensInstances">PLensInstances</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[A, B](r: A =&gt; Option[scalaz.package.Store[B,A]])scalaz.package.PLens[A,B]" id="364770">apply</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="364773">A</a>, <a title="&gt;: Nothing &lt;: Any" id="364774">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="A =&gt; Option[scalaz.package.Store[B,A]]" id="436882">r</a>: A =&gt; Option<span class="delimiter">[</span>Store<span class="delimiter">[</span>B, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="PLens.scala.html#10521" title="scalaz.package.PLens[A,B]">PLens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span> =
      <a href="PLens.scala.html#80211" title="(r: A =&gt; Option[scalaz.package.Store[B,A]])scalaz.package.PLens[A,B]">plens</a><span class="delimiter">(</span><a href="#436882" title="A =&gt; Option[scalaz.package.Store[B,A]]">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[A, B]scalaz.package.PLens[A,B]" id="40517">@?&gt;</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40518">A</a>, <a title="&gt;: Nothing &lt;: Any" id="40519">B</a><span class="delimiter">]</span> = <a href="PLens.scala.html#10521" title="scalaz.package.PLens[A,B]">PLens</a><span class="delimiter">[</span>A, B<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[F[+_], -S1, +S2, +A]scalaz.IndexedStateT[F,S1,S2,Option[A]]" id="40520">PIndexedStateT</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="40521">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="401681">_</a><span class="delimiter">]</span>, -<a title="&gt;: Nothing &lt;: Any" id="40522">S1</a>, +<a title="&gt;: Nothing &lt;: Any" id="40523">S2</a>, +<a title="&gt;: Nothing &lt;: Any" id="40524">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#18774" title="scalaz.IndexedStateT[F,S1,S2,Option[A]]">IndexedStateT</a><span class="delimiter">[</span>F, S1, S2, Option<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[F[+_], S, +A]scalaz.package.PIndexedStateT[F,S,S,A]" id="40525">PStateT</a><span class="delimiter">[</span><a title="[+_]&gt;: Nothing &lt;: Any" id="40526">F</a><span class="delimiter">[</span>+<a title="&gt;: Nothing &lt;: Any" id="401680">_</a><span class="delimiter">]</span>, <a title="&gt;: Nothing &lt;: Any" id="40527">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="40528">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#18774" title="scalaz.package.PIndexedStateT[F,S,S,A]">PIndexedStateT</a><span class="delimiter">[</span>F, S, S, A<span class="delimiter">]</span>

  <span class="keyword">type</span> <a title="[-S1, +S2, +A]scalaz.package.PIndexedStateT[scalaz.Id.Id,S1,S2,A]" id="40529">PIndexedState</a><span class="delimiter">[</span>-<a title="&gt;: Nothing &lt;: Any" id="40530">S1</a>, +<a title="&gt;: Nothing &lt;: Any" id="40531">S2</a>, +<a title="&gt;: Nothing &lt;: Any" id="40532">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#18774" title="scalaz.package.PIndexedStateT[scalaz.Id.Id,S1,S2,A]">PIndexedStateT</a><span class="delimiter">[</span>Id, S1, S2, A<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="[S, +A]scalaz.package.PStateT[scalaz.Id.Id,S,A]" id="40533">PState</a><span class="delimiter">[</span><a title="&gt;: Nothing &lt;: Any" id="40534">S</a>, +<a title="&gt;: Nothing &lt;: Any" id="40535">A</a><span class="delimiter">]</span> = <a href="StateT.scala.html#18774" title="scalaz.package.PStateT[scalaz.Id.Id,S,A]">PStateT</a><span class="delimiter">[</span>Id, S, A<span class="delimiter">]</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>