<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>org/parboiled2/RuleDSLCombinators.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (C) 2009-2013 Mathias Doenitz, Alexander Myltsev
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package org.parboiled2

import scala.annotation.compileTimeOnly
import scala.collection.immutable
import org.parboiled2.support._
import shapeless._

trait <a title="trait RuleDSLCombinators extends AnyRef" id="org.parboiled2;RuleDSLCombinators">RuleDSLCombinators</a> <span title="Unit" class="delimiter">{</span>

  <span class="comment">/**
   * Runs its inner rule and succeeds even if the inner rule doesn't.
   * Resulting rule type is
   *   Rule0             if r == Rule0
   *   Rule1[Option[T]]  if r == Rule1[T]
   *   Rule[I, O]        if r == Rule[I, O &lt;: I] // so called &quot;reduction&quot;, which leaves the value stack unchanged on a type level
   */</span>
  @compileTimeOnly<span class="delimiter">(</span><span class="string">&quot;Calls to `optional` must be inside `rule` macro&quot;</span><span class="delimiter">)</span>
  def <a title="[I &lt;: shapeless.HList, O &lt;: shapeless.HList](r: org.parboiled2.Rule[I,O])(implicit o: org.parboiled2.support.Lifter[Option,I,O])org.parboiled2.Rule[o.In,o.Out]" id="org.parboiled2;RuleDSLCombinators.optional">optional</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2;RuleDSLCombinators.optional;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2;RuleDSLCombinators.optional;O">O</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="org.parboiled2.Rule[I,O]" id="org.parboiled2;RuleDSLCombinators.optional.r">r</a>: <a href="Rule.scala.html#org.parboiled2;Rule" title="org.parboiled2.Rule[I,O]">Rule</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Lifter[Option,I,O]" id="org.parboiled2;RuleDSLCombinators.optional.o">o</a>: <a href="support/Lifter.scala.html#org.parboiled2.support;Lifter" title="org.parboiled2.support.Lifter[Option,I,O]">Lifter</a><span class="delimiter">[</span>Option, I, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Rule.scala.html#org.parboiled2;Rule" title="org.parboiled2.Rule[o.In,o.Out]">Rule</a><span class="delimiter">[</span>o.In, o.Out<span class="delimiter">]</span> = <a href="support/package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>

  <span class="comment">/**
   * Runs its inner rule until it fails, always succeeds.
   * Resulting rule type is
   *   Rule0          if r == Rule0
   *   Rule1[Seq[T]]  if r == Rule1[T]
   *   Rule[I, O]     if r == Rule[I, O &lt;: I] // so called &quot;reduction&quot;, which leaves the value stack unchanged on a type level
   */</span>
  @compileTimeOnly<span class="delimiter">(</span><span class="string">&quot;Calls to `zeroOrMore` must be inside `rule` macro&quot;</span><span class="delimiter">)</span>
  def <a title="[I &lt;: shapeless.HList, O &lt;: shapeless.HList](r: org.parboiled2.Rule[I,O])(implicit s: org.parboiled2.support.Lifter[scala.collection.immutable.Seq,I,O])org.parboiled2.Rule[s.In,s.Out] with RuleDSLCombinators.this.Repeated" id="org.parboiled2;RuleDSLCombinators.zeroOrMore">zeroOrMore</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2;RuleDSLCombinators.zeroOrMore;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2;RuleDSLCombinators.zeroOrMore;O">O</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="org.parboiled2.Rule[I,O]" id="org.parboiled2;RuleDSLCombinators.zeroOrMore.r">r</a>: <a href="Rule.scala.html#org.parboiled2;Rule" title="org.parboiled2.Rule[I,O]">Rule</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Lifter[scala.collection.immutable.Seq,I,O]" id="org.parboiled2;RuleDSLCombinators.zeroOrMore.s">s</a>: <a href="support/Lifter.scala.html#org.parboiled2.support;Lifter" title="org.parboiled2.support.Lifter[scala.collection.immutable.Seq,I,O]">Lifter</a><span class="delimiter">[</span>immutable.Seq, I, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2;RuleDSLCombinators;<refinement>" title="&lt;refinement of org.parboiled2.Rule[s.In,s.Out] with RuleDSLCombinators.this.Repeated&gt; extends org.parboiled2.Rule[s.In,s.Out] with RuleDSLCombinators.this.Repeated">Rule</a><span class="delimiter">[</span>s.In, s.Out<span class="delimiter">]</span> with Repeated = <a href="support/package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>

  <span class="comment">/**
   * Runs its inner rule until it fails, succeeds if its inner rule succeeded at least once.
   * Resulting rule type is
   *   Rule0          if r == Rule0
   *   Rule1[Seq[T]]  if r == Rule1[T]
   *   Rule[I, O]     if r == Rule[I, O &lt;: I] // so called &quot;reduction&quot;, which leaves the value stack unchanged on a type level
   */</span>
  @compileTimeOnly<span class="delimiter">(</span><span class="string">&quot;Calls to `oneOrMore` must be inside `rule` macro&quot;</span><span class="delimiter">)</span>
  def <a title="[I &lt;: shapeless.HList, O &lt;: shapeless.HList](r: org.parboiled2.Rule[I,O])(implicit s: org.parboiled2.support.Lifter[scala.collection.immutable.Seq,I,O])org.parboiled2.Rule[s.In,s.Out] with RuleDSLCombinators.this.Repeated" id="org.parboiled2;RuleDSLCombinators.oneOrMore">oneOrMore</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2;RuleDSLCombinators.oneOrMore;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2;RuleDSLCombinators.oneOrMore;O">O</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="org.parboiled2.Rule[I,O]" id="org.parboiled2;RuleDSLCombinators.oneOrMore.r">r</a>: <a href="Rule.scala.html#org.parboiled2;Rule" title="org.parboiled2.Rule[I,O]">Rule</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Lifter[scala.collection.immutable.Seq,I,O]" id="org.parboiled2;RuleDSLCombinators.oneOrMore.s">s</a>: <a href="support/Lifter.scala.html#org.parboiled2.support;Lifter" title="org.parboiled2.support.Lifter[scala.collection.immutable.Seq,I,O]">Lifter</a><span class="delimiter">[</span>immutable.Seq, I, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2;RuleDSLCombinators;<refinement>" title="&lt;refinement of org.parboiled2.Rule[s.In,s.Out] with RuleDSLCombinators.this.Repeated&gt; extends org.parboiled2.Rule[s.In,s.Out] with RuleDSLCombinators.this.Repeated">Rule</a><span class="delimiter">[</span>s.In, s.Out<span class="delimiter">]</span> with Repeated = <a href="support/package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>

  <span class="comment">/**
   * Runs its inner rule but resets the parser (cursor and value stack) afterwards,
   * succeeds only if its inner rule succeeded.
   */</span>
  @compileTimeOnly<span class="delimiter">(</span><span class="string">&quot;Calls to `&amp;` must be inside `rule` macro&quot;</span><span class="delimiter">)</span>
  def <a title="(r: org.parboiled2.Rule[_, _])org.parboiled2.Rule0" id="org.parboiled2;RuleDSLCombinators.&">&amp;</a><span class="delimiter">(</span><a title="org.parboiled2.Rule[_, _]" id="org.parboiled2;RuleDSLCombinators.&.r">r</a>: <a href="Rule.scala.html#org.parboiled2;Rule" title="org.parboiled2.Rule[_, _]">Rule</a><span class="delimiter">[</span>_, _<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Rule.scala.html#org.parboiled2;Rule" title="org.parboiled2.Rule0">Rule0</a> = <a href="support/package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>

  <span class="comment">/**
   * Allows creation of a sub parser and running of one of its rules as part of the current parsing process.
   * The subparser will start parsing at the current input position and the outer parser (this parser)
   * will continue where the sub-parser stopped.
   */</span>
  @compileTimeOnly<span class="delimiter">(</span><span class="string">&quot;Calls to `runSubParser` must be inside `rule` macro&quot;</span><span class="delimiter">)</span>
  def <a title="[I &lt;: shapeless.HList, O &lt;: shapeless.HList](f: org.parboiled2.ParserInput =&gt; org.parboiled2.Rule[I,O])org.parboiled2.Rule[I,O]" id="org.parboiled2;RuleDSLCombinators.runSubParser">runSubParser</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2;RuleDSLCombinators.runSubParser;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2;RuleDSLCombinators.runSubParser;O">O</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="org.parboiled2.ParserInput =&gt; org.parboiled2.Rule[I,O]" id="org.parboiled2;RuleDSLCombinators.runSubParser.f">f</a>: ParserInput ⇒ Rule<span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Rule.scala.html#org.parboiled2;Rule" title="org.parboiled2.Rule[I,O]">Rule</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> = <a href="support/package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>

  @compileTimeOnly<span class="delimiter">(</span><span class="string">&quot;Calls to `int2NTimes` must be inside `rule` macro&quot;</span><span class="delimiter">)</span>
  implicit def <a title="implicit org.parboiled2.RuleDSLCombinators.int2NTimes : (i: Int)RuleDSLCombinators.this.NTimes" id="org.parboiled2;RuleDSLCombinators.int2NTimes">int2NTimes</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;RuleDSLCombinators.int2NTimes.i">i</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#org.parboiled2;RuleDSLCombinators;NTimes" title="RuleDSLCombinators.this.NTimes">NTimes</a> = <a href="support/package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>
  @compileTimeOnly<span class="delimiter">(</span><span class="string">&quot;Calls to `range2NTimes` must be inside `rule` macro&quot;</span><span class="delimiter">)</span>
  implicit def <a title="implicit org.parboiled2.RuleDSLCombinators.range2NTimes : (range: Range)RuleDSLCombinators.this.NTimes" id="org.parboiled2;RuleDSLCombinators.range2NTimes">range2NTimes</a><span class="delimiter">(</span><a title="Range" id="org.parboiled2;RuleDSLCombinators.range2NTimes.range">range</a>: <span title="Range">Range</span><span class="delimiter">)</span>: <a href="#org.parboiled2;RuleDSLCombinators;NTimes" title="RuleDSLCombinators.this.NTimes">NTimes</a> = <a href="support/package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>
  sealed trait <a title="trait NTimes extends AnyRef" id="org.parboiled2;RuleDSLCombinators;NTimes">NTimes</a> <span class="delimiter">{</span>
    <span class="comment">/**
     * Repeats the given sub rule `r` the given number of times.
     * Both bounds of the range must be non-negative and the upper bound must be &gt;= the lower bound.
     * If the upper bound is zero the rule is equivalent to `MATCH`.
     *
     * Resulting rule type is
     *   Rule0          if r == Rule0
     *   Rule1[Seq[T]]  if r == Rule1[T]
     *   Rule[I, O]     if r == Rule[I, O &lt;: I] // so called &quot;reduction&quot;, which leaves the value stack unchanged on a type level
     */</span>
    @compileTimeOnly<span class="delimiter">(</span><span class="string">&quot;Calls to `times` must be inside `rule` macro&quot;</span><span class="delimiter">)</span>
    def <a title="[I &lt;: shapeless.HList, O &lt;: shapeless.HList](r: org.parboiled2.Rule[I,O])(implicit s: org.parboiled2.support.Lifter[scala.collection.immutable.Seq,I,O])org.parboiled2.Rule[s.In,s.Out] with RuleDSLCombinators.this.Repeated" id="org.parboiled2;RuleDSLCombinators;NTimes.times">times</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2;RuleDSLCombinators;NTimes.times;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2;RuleDSLCombinators;NTimes.times;O">O</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="org.parboiled2.Rule[I,O]" id="org.parboiled2;RuleDSLCombinators;NTimes.times.r">r</a>: <a href="Rule.scala.html#org.parboiled2;Rule" title="org.parboiled2.Rule[I,O]">Rule</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Lifter[scala.collection.immutable.Seq,I,O]" id="org.parboiled2;RuleDSLCombinators;NTimes.times.s">s</a>: <a href="support/Lifter.scala.html#org.parboiled2.support;Lifter" title="org.parboiled2.support.Lifter[scala.collection.immutable.Seq,I,O]">Lifter</a><span class="delimiter">[</span>immutable.Seq, I, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2;RuleDSLCombinators;NTimes;<refinement>" title="&lt;refinement of org.parboiled2.Rule[s.In,s.Out] with RuleDSLCombinators.this.Repeated&gt; extends org.parboiled2.Rule[s.In,s.Out] with RuleDSLCombinators.this.Repeated">Rule</a><span class="delimiter">[</span>s.In, s.Out<span class="delimiter">]</span> with Repeated
  <span class="delimiter">}</span>

  <span class="comment">// phantom type for WithSeparatedBy pimp</span>
  trait <a title="trait Repeated extends AnyRef" id="org.parboiled2;RuleDSLCombinators;Repeated">Repeated</a>

  @compileTimeOnly<span class="delimiter">(</span><span class="string">&quot;Calls to `rule2WithSeparatedBy` constructor must be inside `rule` macro&quot;</span><span class="delimiter">)</span>
  implicit def <a title="[I &lt;: shapeless.HList, O &lt;: shapeless.HList](r: org.parboiled2.Rule[I,O] with RuleDSLCombinators.this.Repeated)RuleDSLCombinators.this.WithSeparatedBy[I,O]" id="org.parboiled2;RuleDSLCombinators.rule2WithSeparatedBy">rule2WithSeparatedBy</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2;RuleDSLCombinators.rule2WithSeparatedBy;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2;RuleDSLCombinators.rule2WithSeparatedBy;O">O</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="&lt;refinement of org.parboiled2.Rule[I,O] with RuleDSLCombinators.this.Repeated&gt; extends org.parboiled2.Rule[I,O] with RuleDSLCombinators.this.Repeated" id="org.parboiled2;RuleDSLCombinators.rule2WithSeparatedBy.r">r</a>: <a href="#org.parboiled2;RuleDSLCombinators;<refinement>" title="&lt;refinement of org.parboiled2.Rule[I,O] with RuleDSLCombinators.this.Repeated&gt; extends org.parboiled2.Rule[I,O] with RuleDSLCombinators.this.Repeated">Rule</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> with Repeated<span class="delimiter">)</span>: <a href="#org.parboiled2;RuleDSLCombinators;WithSeparatedBy" title="RuleDSLCombinators.this.WithSeparatedBy[I,O]">WithSeparatedBy</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> = <a href="support/package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>
  trait <a title="trait WithSeparatedBy[I &lt;: shapeless.HList, O &lt;: shapeless.HList] extends AnyRef" id="org.parboiled2;RuleDSLCombinators;WithSeparatedBy">WithSeparatedBy</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2;RuleDSLCombinators;WithSeparatedBy;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2;RuleDSLCombinators;WithSeparatedBy;O">O</a> &lt;: HList<span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>
    def <a title="(separator: org.parboiled2.Rule0)org.parboiled2.Rule[I,O]" id="org.parboiled2;RuleDSLCombinators;WithSeparatedBy.separatedBy">separatedBy</a><span class="delimiter">(</span><a title="org.parboiled2.Rule0" id="org.parboiled2;RuleDSLCombinators;WithSeparatedBy.separatedBy.separator">separator</a>: <a href="Rule.scala.html#org.parboiled2;Rule" title="org.parboiled2.Rule0">Rule0</a><span class="delimiter">)</span>: <a href="Rule.scala.html#org.parboiled2;Rule" title="org.parboiled2.Rule[I,O]">Rule</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> = <a href="support/package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>
  <span class="delimiter">}</span>
<span title="AnyRef" class="delimiter">}</span>
        </pre>
    </body>
</html>
