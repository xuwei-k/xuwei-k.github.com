<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>org/parboiled2/ParseError.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (C) 2009-2013 Mathias Doenitz, Alexander Myltsev
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package org.parboiled2

import <a href="CharUtils.scala.html#org.parboiled2.CharUtils" title="org.parboiled2.CharUtils.type">CharUtils</a>.escape

case class <a title="class ParseError extends RuntimeException with Product with Serializable" id="org.parboiled2.ParseError.readResolve">ParseError</a><span title="Product" class="delimiter">(</span><a title="org.parboiled2.Position" id="org.parboiled2;ParseError.position">position</a>: <a href="#org.parboiled2.Position.readResolve" title="org.parboiled2.Position">Position</a>, <a title="Seq[org.parboiled2.RuleTrace]" id="org.parboiled2;ParseError.traces">traces</a>: <span title="Seq[org.parboiled2.RuleTrace]">Seq</span><span class="delimiter">[</span>RuleTrace<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.ParseError.readResolve" title="RuntimeException">RuntimeException</a> <span class="delimiter">{</span>
  def <a title="=&gt; String" id="org.parboiled2;ParseError.formatExpectedAsString">formatExpectedAsString</a>: <span title="String">String</span> = <span class="delimiter">{</span>
    val <a title="Seq[String]" id="org.parboiled2;ParseError.formatExpectedAsString.expected">expected</a> = <a href="#org.parboiled2;ParseError.formatExpectedAsSeq" title="=&gt; Seq[String]">formatExpectedAsSeq</a>
    <a href="#org.parboiled2;ParseError.formatExpectedAsString.expected" title="Seq[String]">expected</a>.<span title="=&gt; Int">size</span> match <span class="delimiter">{</span>
      case <span title="Int(0)" class="int">0</span> ⇒ <span title="String(&quot;??&quot;)" class="string">&quot;??&quot;</span>
      case <span title="Int(1)" class="int">1</span> ⇒ <a href="#org.parboiled2;ParseError.formatExpectedAsString.expected" title="Seq[String]">expected</a>.<span title="=&gt; String">head</span>
      case _ ⇒ <a href="#org.parboiled2;ParseError.formatExpectedAsString.expected" title="Seq[String]">expected</a>.<span title="=&gt; Seq[String]">init</span>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot; or &quot;)" class="string">&quot; or &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#org.parboiled2;ParseError.formatExpectedAsString.expected" title="Seq[String]">expected</a>.<span title="=&gt; String">last</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  def <a title="=&gt; Seq[String]" id="org.parboiled2;ParseError.formatExpectedAsSeq">formatExpectedAsSeq</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span> =
    <a href="#org.parboiled2;ParseError.traces" title="=&gt; Seq[org.parboiled2.RuleTrace]">traces</a>.<span title="(f: org.parboiled2.RuleTrace =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[org.parboiled2.RuleTrace],String,Seq[String]])Seq[String]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">{</span> <a title="org.parboiled2.RuleTrace" id="org.parboiled2;ParseError.formatExpectedAsSeq.$anonfun.trace">trace</a> ⇒
      if <span class="delimiter">(</span><a href="#org.parboiled2;ParseError.formatExpectedAsSeq.$anonfun.trace" title="org.parboiled2.RuleTrace">trace</a>.<a href="#org.parboiled2;RuleTrace.frames" title="=&gt; Seq[org.parboiled2.RuleFrame]">frames</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="String" id="org.parboiled2;ParseError.formatExpectedAsSeq.$anonfun.exp">exp</a> = <a href="#org.parboiled2;ParseError.formatExpectedAsSeq.$anonfun.trace" title="org.parboiled2.RuleTrace">trace</a>.<a href="#org.parboiled2;RuleTrace.frames" title="=&gt; Seq[org.parboiled2.RuleFrame]">frames</a>.<span title="=&gt; org.parboiled2.RuleFrame">last</span>.<a href="#org.parboiled2;RuleFrame.format" title="=&gt; String">format</a>
        val <a title="String" id="org.parboiled2;ParseError.formatExpectedAsSeq.$anonfun.nonEmptyExp">nonEmptyExp</a> = if <span class="delimiter">(</span><a href="#org.parboiled2;ParseError.formatExpectedAsSeq.$anonfun.exp" title="String">exp</a>.<span title="()Boolean">isEmpty</span><span class="delimiter">)</span> <span title="String(&quot;?&quot;)" class="string">&quot;?&quot;</span> else <a href="#org.parboiled2;ParseError.formatExpectedAsSeq.$anonfun.exp" title="String">exp</a>
        if <span class="delimiter">(</span><a href="#org.parboiled2;ParseError.formatExpectedAsSeq.$anonfun.trace" title="org.parboiled2.RuleTrace">trace</a>.<a href="#org.parboiled2;RuleTrace.isNegated" title="=&gt; Boolean">isNegated</a><span class="delimiter">)</span> <span title="String(&quot;!&quot;)" class="string">&quot;!&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#org.parboiled2;ParseError.formatExpectedAsSeq.$anonfun.nonEmptyExp" title="String">nonEmptyExp</a> else <a href="#org.parboiled2;ParseError.formatExpectedAsSeq.$anonfun.nonEmptyExp" title="String">nonEmptyExp</a>
      <span class="delimiter">}</span> else <span title="String(&quot;???&quot;)" class="string">&quot;???&quot;</span>
    <span class="delimiter">}</span>.<span title="=&gt; Seq[String]">distinct</span>

  def <a title="=&gt; String" id="org.parboiled2;ParseError.formatTraces">formatTraces</a>: <span title="String">String</span> =
    <a href="#org.parboiled2;ParseError.traces" title="=&gt; Seq[org.parboiled2.RuleTrace]">traces</a>.<span title="(f: org.parboiled2.RuleTrace =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[org.parboiled2.RuleTrace],String,Seq[String]])Seq[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a href="#org.parboiled2;ParseError.formatTraces.$anonfun.x$1" title="org.parboiled2.RuleTrace">_</a>.<a href="#org.parboiled2;RuleTrace.format" title="=&gt; String">format</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><a href="#org.parboiled2;ParseError.traces" title="=&gt; Seq[org.parboiled2.RuleTrace]">traces</a>.<span title="=&gt; Int">size</span> <span title="(x: String)String">+</span> <span title="String(&quot; rule&quot;)" class="string">&quot; rule&quot;</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span>if <span class="delimiter">(</span><a href="#org.parboiled2;ParseError.traces" title="=&gt; Seq[org.parboiled2.RuleTrace]">traces</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">!=</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="String(&quot;s&quot;)" class="string">&quot;s&quot;</span> else <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span>
      <span title="String(&quot; mismatched at error location:\n  &quot;)" class="string">&quot; mismatched at error location:\n  &quot;</span>, <span title="String(&quot;\n  &quot;)" class="string">&quot;\n  &quot;</span>, <span title="String(&quot;\n&quot;)" class="string">&quot;\n&quot;</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

case class <a title="class Position extends AnyRef with Product with Serializable" id="org.parboiled2.Position.readResolve">Position</a><a href="#org.parboiled2.Position.readResolve" title="Product" class="delimiter">(</a><a title="Int" id="org.parboiled2;Position.index">index</a>: <span title="Int">Int</span>, <a title="Int" id="org.parboiled2;Position.line">line</a>: <span title="Int">Int</span>, <a title="Int" id="org.parboiled2;Position.column">column</a>: <span title="Int">Int</span><span class="delimiter">)</span>

<span class="comment">// outermost (i.e. highest-level) rule first</span>
case class <a title="class RuleTrace extends AnyRef with Product with Serializable" id="org.parboiled2.RuleTrace.readResolve">RuleTrace</a><a href="#org.parboiled2.RuleTrace.readResolve" title="Product" class="delimiter">(</a><a title="Seq[org.parboiled2.RuleFrame]" id="org.parboiled2;RuleTrace.frames">frames</a>: <span title="Seq[org.parboiled2.RuleFrame]">Seq</span><span class="delimiter">[</span>RuleFrame<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  def <a title="=&gt; String" id="org.parboiled2;RuleTrace.format">format</a>: <span title="String">String</span> =
    <a href="#org.parboiled2;RuleTrace.frames" title="=&gt; Seq[org.parboiled2.RuleFrame]">frames</a>.<span title="=&gt; Int">size</span> match <span class="delimiter">{</span>
      case <span title="Int(0)" class="int">0</span> ⇒ <span title="String(&quot;&lt;empty&gt;&quot;)" class="string">&quot;&lt;empty&gt;&quot;</span>
      case <span title="Int(1)" class="int">1</span> ⇒ <a href="#org.parboiled2;RuleTrace.frames" title="=&gt; Seq[org.parboiled2.RuleFrame]">frames</a>.<span title="=&gt; org.parboiled2.RuleFrame">head</span>.<a href="#org.parboiled2;RuleFrame.format" title="=&gt; String">format</a>
      case _ ⇒
        <span class="comment">// we don't want to show intermediate Sequence and RuleCall frames in the trace</span>
        def <a title="(frame: org.parboiled2.RuleFrame)Boolean" id="org.parboiled2;RuleTrace.format.show">show</a><span class="delimiter">(</span><a title="org.parboiled2.RuleFrame" id="org.parboiled2;RuleTrace.format.show.frame">frame</a>: <a href="#org.parboiled2;RuleFrame" title="org.parboiled2.RuleFrame">RuleFrame</a><span class="delimiter">)</span> = <span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#org.parboiled2;RuleTrace.format.show.frame" title="org.parboiled2.RuleFrame">frame</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span>RuleFrame.<a href="#org.parboiled2.RuleFrame.Sequence.readResolve" title="org.parboiled2.RuleFrame.Sequence">Sequence</a><span class="delimiter">]</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.parboiled2;RuleTrace.format.show.frame" title="org.parboiled2.RuleFrame">frame</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span>RuleFrame.<a href="#org.parboiled2.RuleFrame.RuleCall.readResolve" title="org.parboiled2.RuleFrame.RuleCall">RuleCall</a><span class="delimiter">]</span><span class="delimiter">)</span>
        <a href="#org.parboiled2;RuleTrace.frames" title="=&gt; Seq[org.parboiled2.RuleFrame]">frames</a>.<span title="=&gt; Seq[org.parboiled2.RuleFrame]">init</span>.<span title="(p: org.parboiled2.RuleFrame =&gt; Boolean)Seq[org.parboiled2.RuleFrame]">filter</span><span class="delimiter">(</span><a href="#org.parboiled2;RuleTrace.format.show" title="(frame: org.parboiled2.RuleFrame)Boolean">show</a><span class="delimiter">)</span>.<span title="(f: org.parboiled2.RuleFrame =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[org.parboiled2.RuleFrame],String,Seq[String]])Seq[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a href="#org.parboiled2;RuleTrace.format.$anonfun.x$2" title="org.parboiled2.RuleFrame">_</a>.<a href="#org.parboiled2;RuleFrame.format" title="=&gt; String">format</a><span class="delimiter">)</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="String(&quot; / &quot;)" class="string">&quot; / &quot;</span>, <span title="String(&quot; / &quot;)" class="string">&quot; / &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#org.parboiled2;RuleTrace.frames" title="=&gt; Seq[org.parboiled2.RuleFrame]">frames</a>.<span title="=&gt; org.parboiled2.RuleFrame">last</span>.<a href="#org.parboiled2;RuleFrame.format" title="=&gt; String">format</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  def <a title="=&gt; Boolean" id="org.parboiled2;RuleTrace.isNegated">isNegated</a>: <span title="Boolean">Boolean</span> = <span class="delimiter">(</span><a href="#org.parboiled2;RuleTrace.frames" title="=&gt; Seq[org.parboiled2.RuleFrame]">frames</a>.<span title="(p: org.parboiled2.RuleFrame =&gt; Boolean)Int">count</span><span class="delimiter">(</span><a href="#org.parboiled2;RuleTrace.isNegated.$anonfun.x$3" title="org.parboiled2.RuleFrame">_</a>.<a href="#org.parboiled2;RuleFrame.anon" title="=&gt; org.parboiled2.RuleFrame.Anonymous">anon</a> <span title="(x$1: Any)Boolean">==</span> <a href="#org.parboiled2.RuleFrame" title="org.parboiled2.RuleFrame.type">RuleFrame</a>.<a href="#org.parboiled2.RuleFrame.NotPredicate.readResolve" title="org.parboiled2.RuleFrame.NotPredicate.type">NotPredicate</a><span class="delimiter">)</span> <span title="(x: Int)Int">&amp;</span> <span title="Int(1)" class="int">0x01</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span>
<span class="delimiter">}</span>

sealed abstract class <a title="class RuleFrame extends AnyRef" id="org.parboiled2;RuleFrame">RuleFrame</a> <a href="#org.parboiled2;RuleFrame" title="org.parboiled2.RuleFrame" class="delimiter">{</a>
  import <a href="#org.parboiled2.RuleFrame" title="org.parboiled2.RuleFrame.type">RuleFrame</a>._
  def <a title="=&gt; org.parboiled2.RuleFrame.Anonymous" id="org.parboiled2;RuleFrame.anon">anon</a>: RuleFrame.<a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>

  def <a title="=&gt; String" id="org.parboiled2;RuleFrame.format">format</a>: <span title="String">String</span> =
    this match <span class="delimiter">{</span>
      case Named<span class="delimiter">(</span><span title="String">name</span>, _<span class="delimiter">)</span>              ⇒ <span title="String">name</span>
      case Sequence<span class="delimiter">(</span>_<span class="delimiter">)</span>                 ⇒ <span title="String(&quot;~&quot;)" class="string">&quot;~&quot;</span>
      case FirstOf<span class="delimiter">(</span>_<span class="delimiter">)</span>                  ⇒ <span title="String(&quot;|&quot;)" class="string">&quot;|&quot;</span>
      case CharMatch<span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span>                ⇒ <span title="String(&quot;\'&quot;)" class="string">&quot;'&quot;</span> <span title="(x$1: Any)String">+</span> <a href="CharUtils.scala.html#org.parboiled2.CharUtils.escape(330dead26b)" title="(c: Char)String">escape</a><span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="Char('\'')" class="char">'\''</span>
      case StringMatch<span class="delimiter">(</span><span title="String">s</span><span class="delimiter">)</span>              ⇒ <span title="Char('\&quot;')" class="char">'&quot;'</span> <span title="(x: String)String">+</span> <a href="CharUtils.scala.html#org.parboiled2.CharUtils.escape(eba93c96a6)" title="(s: String)String">escape</a><span class="delimiter">(</span><span title="String">s</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="Char('\&quot;')" class="char">'&quot;'</span>
      case MapMatch<span class="delimiter">(</span><a title="Map[String,Any]" id="org.parboiled2;RuleFrame.format.m">m</a><span class="delimiter">)</span>                 ⇒ <a href="#org.parboiled2;RuleFrame.format.m" title="Map[String,Any]">m</a>.<span title="()String">toString</span><span class="delimiter">(</span><span class="delimiter">)</span>
      case IgnoreCaseChar<span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span>           ⇒ <span title="String(&quot;\'&quot;)" class="string">&quot;'&quot;</span> <span title="(x$1: Any)String">+</span> <a href="CharUtils.scala.html#org.parboiled2.CharUtils.escape(330dead26b)" title="(c: Char)String">escape</a><span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="Char('\'')" class="char">'\''</span>
      case IgnoreCaseString<span class="delimiter">(</span><span title="String">s</span><span class="delimiter">)</span>         ⇒ <span title="Char('\&quot;')" class="char">'&quot;'</span> <span title="(x: String)String">+</span> <a href="CharUtils.scala.html#org.parboiled2.CharUtils.escape(eba93c96a6)" title="(s: String)String">escape</a><span class="delimiter">(</span><span title="String">s</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="Char('\&quot;')" class="char">'&quot;'</span>
      case CharPredicateMatch<span class="delimiter">(</span>_, <span title="String">name</span><span class="delimiter">)</span> ⇒ if <span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">name</span>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span title="String">name</span> else <span title="String(&quot;&lt;anon predicate&gt;&quot;)" class="string">&quot;&lt;anon predicate&gt;&quot;</span>
      case RuleCall<span class="delimiter">(</span><a title="String" id="org.parboiled2;RuleFrame.format.callee">callee</a><span class="delimiter">)</span>            ⇒ <span title="Char('(')" class="char">'('</span> <span title="(x: String)String">+</span> <a href="#org.parboiled2;RuleFrame.format.callee" title="String">callee</a> <span title="(x$1: Any)String">+</span> <span title="Char(')')" class="char">')'</span>
      case AnyOf<span class="delimiter">(</span><span title="String">s</span><span class="delimiter">)</span>                    ⇒ <span title="Char('[')" class="char">'['</span> <span title="(x: String)String">+</span> <a href="CharUtils.scala.html#org.parboiled2.CharUtils.escape(eba93c96a6)" title="(s: String)String">escape</a><span class="delimiter">(</span><span title="String">s</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="Char(']')" class="char">']'</span>
      case NoneOf<span class="delimiter">(</span><span title="String">s</span><span class="delimiter">)</span>                   ⇒ <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;[^&quot;)">[^$</span><span class="delimiter">{</span><a href="CharUtils.scala.html#org.parboiled2.CharUtils.escape(eba93c96a6)" title="(s: String)String">escape</a><span class="delimiter">(</span><span title="String">s</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;]&quot;)" class="string">]&quot;</span>
      case Times<span class="delimiter">(</span>_, _<span class="delimiter">)</span>                 ⇒ <span title="String(&quot;times&quot;)" class="string">&quot;times&quot;</span>
      case CharRange<span class="delimiter">(</span><a title="Char" id="org.parboiled2;RuleFrame.format.from">from</a>, <a title="Char" id="org.parboiled2;RuleFrame.format.to">to</a><span class="delimiter">)</span>         ⇒ <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;\'&quot;)">'$</span><span class="delimiter">{</span><a href="CharUtils.scala.html#org.parboiled2.CharUtils.escape(330dead26b)" title="(c: Char)String">escape</a><span class="delimiter">(</span><a href="#org.parboiled2;RuleFrame.format.from" title="Char">from</a><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;\'-\'&quot;)">'-'$</span><span class="delimiter">{</span><a href="CharUtils.scala.html#org.parboiled2.CharUtils.escape(330dead26b)" title="(c: Char)String">escape</a><span class="delimiter">(</span><a href="#org.parboiled2;RuleFrame.format.to" title="Char">to</a><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;\'&quot;)" class="string">'&quot;</span>
      case <a href="#org.parboiled2.RuleFrame.AndPredicate.readResolve" title="org.parboiled2.RuleFrame.AndPredicate.type">AndPredicate</a>                ⇒ <span title="String(&quot;&amp;&quot;)" class="string">&quot;&amp;&quot;</span>
      case <a href="#org.parboiled2.RuleFrame.NotPredicate.readResolve" title="org.parboiled2.RuleFrame.NotPredicate.type">NotPredicate</a>                ⇒ <span title="String(&quot;!&quot;)" class="string">&quot;!&quot;</span>
      case <a href="#org.parboiled2.RuleFrame.SemanticPredicate.readResolve" title="org.parboiled2.RuleFrame.SemanticPredicate.type">SemanticPredicate</a>           ⇒ <span title="String(&quot;test&quot;)" class="string">&quot;test&quot;</span>
      case <a href="#org.parboiled2.RuleFrame.ANY.readResolve" title="org.parboiled2.RuleFrame.ANY.type">ANY</a>                         ⇒ <span title="String(&quot;ANY&quot;)" class="string">&quot;ANY&quot;</span>
      case _ ⇒ <span class="delimiter">{</span>
        val <span title="String">s</span> = <a href="#org.parboiled2;RuleFrame" title="()String">toString</a>
        <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">s</span>.<span title="(index: Int, elem: Char)(implicit bf: scala.collection.generic.CanBuildFrom[String,Char,String])String">updated</span><span title="=&gt; scala.collection.generic.CanBuildFrom[String,Char,String]" class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <span title="String">s</span>.<span title="(x$1: Int)Char">charAt</span><span title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar" class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>.<span title="=&gt; Char">toLower</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

object <a title="org.parboiled2.RuleFrame.type" id="org.parboiled2.RuleFrame">RuleFrame</a> <a href="#org.parboiled2.RuleFrame" title="org.parboiled2.RuleFrame.type" class="delimiter">{</a>
  def <a title="(frame: org.parboiled2.RuleFrame.Anonymous, name: String)org.parboiled2.RuleFrame" id="org.parboiled2.RuleFrame.apply">apply</a><span class="delimiter">(</span><a title="org.parboiled2.RuleFrame.Anonymous" id="org.parboiled2.RuleFrame.apply.frame">frame</a>: <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>, <a title="String" id="org.parboiled2.RuleFrame.apply.name">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#org.parboiled2;RuleFrame" title="org.parboiled2.RuleFrame">RuleFrame</a> =
    if <span class="delimiter">(</span><a href="#org.parboiled2.RuleFrame.apply.name" title="String">name</a>.<span title="()Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#org.parboiled2.RuleFrame.apply.frame" title="org.parboiled2.RuleFrame.Anonymous">frame</a> else <a href="#org.parboiled2.RuleFrame.Named.readResolve" title="(name: String, anon: org.parboiled2.RuleFrame.Anonymous)org.parboiled2.RuleFrame.Named">Named</a><span class="delimiter">(</span><a href="#org.parboiled2.RuleFrame.apply.name" title="String">name</a>, <a href="#org.parboiled2.RuleFrame.apply.frame" title="org.parboiled2.RuleFrame.Anonymous">frame</a><span class="delimiter">)</span>

  case class <a title="class Named extends org.parboiled2.RuleFrame with Product with Serializable" id="org.parboiled2.RuleFrame.Named.readResolve">Named</a><span title="Product" class="delimiter">(</span><a title="String" id="org.parboiled2.RuleFrame;Named.name">name</a>: <span title="String">String</span>, <a title="org.parboiled2.RuleFrame.Anonymous" id="org.parboiled2.RuleFrame;Named.anon">anon</a>: <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a><span class="delimiter">)</span> extends <a href="#org.parboiled2;RuleFrame" title="org.parboiled2.RuleFrame">RuleFrame</a>

  sealed abstract class <a title="class Anonymous extends org.parboiled2.RuleFrame" id="org.parboiled2.RuleFrame;Anonymous">Anonymous</a> extends <a href="#org.parboiled2;RuleFrame" title="org.parboiled2.RuleFrame">RuleFrame</a> <span class="delimiter">{</span>
    def <a title="=&gt; org.parboiled2.RuleFrame.Anonymous" id="org.parboiled2.RuleFrame;Anonymous.anon">anon</a>: <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a> = this
  <span class="delimiter">}</span>
  case class <a title="class Sequence extends org.parboiled2.RuleFrame.Anonymous with Product with Serializable" id="org.parboiled2.RuleFrame.Sequence.readResolve">Sequence</a><span title="Product" class="delimiter">(</span><a title="Int" id="org.parboiled2.RuleFrame;Sequence.subs">subs</a>: <span title="Int">Int</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case class <a title="class FirstOf extends org.parboiled2.RuleFrame.Anonymous with Product with Serializable" id="org.parboiled2.RuleFrame.FirstOf.readResolve">FirstOf</a><span title="Product" class="delimiter">(</span><a title="Int" id="org.parboiled2.RuleFrame;FirstOf.subs">subs</a>: <span title="Int">Int</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case class <a title="class CharMatch extends org.parboiled2.RuleFrame.Anonymous with Product with Serializable" id="org.parboiled2.RuleFrame.CharMatch.readResolve">CharMatch</a><span title="Product" class="delimiter">(</span><a title="Char" id="org.parboiled2.RuleFrame;CharMatch.char">char</a>: <span title="Char">Char</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case class <a title="class StringMatch extends org.parboiled2.RuleFrame.Anonymous with Product with Serializable" id="org.parboiled2.RuleFrame.StringMatch.readResolve">StringMatch</a><span title="Product" class="delimiter">(</span><a title="String" id="org.parboiled2.RuleFrame;StringMatch.string">string</a>: <span title="String">String</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case class <a title="class MapMatch extends org.parboiled2.RuleFrame.Anonymous with Product with Serializable" id="org.parboiled2.RuleFrame.MapMatch.readResolve">MapMatch</a><span title="Product" class="delimiter">(</span><a title="Map[String,Any]" id="org.parboiled2.RuleFrame;MapMatch.map">map</a>: <span title="Map[String,Any]">Map</span><span class="delimiter">[</span>String, Any<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case class <a title="class IgnoreCaseChar extends org.parboiled2.RuleFrame.Anonymous with Product with Serializable" id="org.parboiled2.RuleFrame.IgnoreCaseChar.readResolve">IgnoreCaseChar</a><span title="Product" class="delimiter">(</span><a title="Char" id="org.parboiled2.RuleFrame;IgnoreCaseChar.char">char</a>: <span title="Char">Char</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case class <a title="class IgnoreCaseString extends org.parboiled2.RuleFrame.Anonymous with Product with Serializable" id="org.parboiled2.RuleFrame.IgnoreCaseString.readResolve">IgnoreCaseString</a><span title="Product" class="delimiter">(</span><a title="String" id="org.parboiled2.RuleFrame;IgnoreCaseString.string">string</a>: <span title="String">String</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case class <a title="class CharPredicateMatch extends org.parboiled2.RuleFrame.Anonymous with Product with Serializable" id="org.parboiled2.RuleFrame.CharPredicateMatch.readResolve">CharPredicateMatch</a><span title="Product" class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.RuleFrame;CharPredicateMatch.predicate">predicate</a>: <a href="CharPredicate.scala.html#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a>, <a title="String" id="org.parboiled2.RuleFrame;CharPredicateMatch.name">name</a>: <span title="String">String</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case class <a title="class AnyOf extends org.parboiled2.RuleFrame.Anonymous with Product with Serializable" id="org.parboiled2.RuleFrame.AnyOf.readResolve">AnyOf</a><span title="Product" class="delimiter">(</span><a title="String" id="org.parboiled2.RuleFrame;AnyOf.string">string</a>: <span title="String">String</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case class <a title="class NoneOf extends org.parboiled2.RuleFrame.Anonymous with Product with Serializable" id="org.parboiled2.RuleFrame.NoneOf.readResolve">NoneOf</a><span title="Product" class="delimiter">(</span><a title="String" id="org.parboiled2.RuleFrame;NoneOf.string">string</a>: <span title="String">String</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case class <a title="class Times extends org.parboiled2.RuleFrame.Anonymous with Product with Serializable" id="org.parboiled2.RuleFrame.Times.readResolve">Times</a><span title="Product" class="delimiter">(</span><a title="Int" id="org.parboiled2.RuleFrame;Times.min">min</a>: <span title="Int">Int</span>, <a title="Int" id="org.parboiled2.RuleFrame;Times.max">max</a>: <span title="Int">Int</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case class <a title="class RuleCall extends org.parboiled2.RuleFrame.Anonymous with Product with Serializable" id="org.parboiled2.RuleFrame.RuleCall.readResolve">RuleCall</a><span title="Product" class="delimiter">(</span><a title="String" id="org.parboiled2.RuleFrame;RuleCall.callee">callee</a>: <span title="String">String</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case class <a title="class CharRange extends org.parboiled2.RuleFrame.Anonymous with Product with Serializable" id="org.parboiled2.RuleFrame.CharRange.readResolve">CharRange</a><span title="Product" class="delimiter">(</span><a title="Char" id="org.parboiled2.RuleFrame;CharRange.from">from</a>: <span title="Char">Char</span>, <a title="Char" id="org.parboiled2.RuleFrame;CharRange.to">to</a>: <span title="Char">Char</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case object <a href="#org.parboiled2.RuleFrame.ANY.productElement.x$1" title="org.parboiled2.RuleFrame.ANY.type" id="org.parboiled2.RuleFrame.ANY.readResolve">ANY</a> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case object <a href="#org.parboiled2.RuleFrame.Optional.productElement.x$1" title="org.parboiled2.RuleFrame.Optional.type" id="org.parboiled2.RuleFrame.Optional.readResolve">Optional</a> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case object <a href="#org.parboiled2.RuleFrame.ZeroOrMore.productElement.x$1" title="org.parboiled2.RuleFrame.ZeroOrMore.type" id="org.parboiled2.RuleFrame.ZeroOrMore.readResolve">ZeroOrMore</a> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case object <a href="#org.parboiled2.RuleFrame.OneOrMore.productElement.x$1" title="org.parboiled2.RuleFrame.OneOrMore.type" id="org.parboiled2.RuleFrame.OneOrMore.readResolve">OneOrMore</a> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case object <a href="#org.parboiled2.RuleFrame.AndPredicate.productElement.x$1" title="org.parboiled2.RuleFrame.AndPredicate.type" id="org.parboiled2.RuleFrame.AndPredicate.readResolve">AndPredicate</a> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case object <a href="#org.parboiled2.RuleFrame.NotPredicate.productElement.x$1" title="org.parboiled2.RuleFrame.NotPredicate.type" id="org.parboiled2.RuleFrame.NotPredicate.readResolve">NotPredicate</a> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case object <a href="#org.parboiled2.RuleFrame.SemanticPredicate.productElement.x$1" title="org.parboiled2.RuleFrame.SemanticPredicate.type" id="org.parboiled2.RuleFrame.SemanticPredicate.readResolve">SemanticPredicate</a> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case object <a href="#org.parboiled2.RuleFrame.Capture.productElement.x$1" title="org.parboiled2.RuleFrame.Capture.type" id="org.parboiled2.RuleFrame.Capture.readResolve">Capture</a> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case object <a href="#org.parboiled2.RuleFrame.Run.productElement.x$1" title="org.parboiled2.RuleFrame.Run.type" id="org.parboiled2.RuleFrame.Run.readResolve">Run</a> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case object <a href="#org.parboiled2.RuleFrame.Push.productElement.x$1" title="org.parboiled2.RuleFrame.Push.type" id="org.parboiled2.RuleFrame.Push.readResolve">Push</a> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case object <a href="#org.parboiled2.RuleFrame.Drop.productElement.x$1" title="org.parboiled2.RuleFrame.Drop.type" id="org.parboiled2.RuleFrame.Drop.readResolve">Drop</a> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case object <a href="#org.parboiled2.RuleFrame.Action.productElement.x$1" title="org.parboiled2.RuleFrame.Action.type" id="org.parboiled2.RuleFrame.Action.readResolve">Action</a> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
  case object <a href="#org.parboiled2.RuleFrame.RunSubParser.productElement.x$1" title="org.parboiled2.RuleFrame.RunSubParser.type" id="org.parboiled2.RuleFrame.RunSubParser.readResolve">RunSubParser</a> extends <a href="#org.parboiled2.RuleFrame;Anonymous" title="org.parboiled2.RuleFrame.Anonymous">Anonymous</a>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
