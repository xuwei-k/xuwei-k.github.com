<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>org/parboiled2/Parser.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (C) 2009-2013 Mathias Doenitz, Alexander Myltsev
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package org.parboiled2

import scala.annotation.tailrec
import scala.collection.immutable.VectorBuilder
import scala.util.<span class="delimiter">{</span> Failure, Success, Try <span class="delimiter">}</span>
import scala.util.control.<span class="delimiter">{</span> NonFatal, NoStackTrace <span class="delimiter">}</span>
import shapeless._
import org.parboiled2.support._

abstract class <a title="class Parser extends org.parboiled2.RuleDSL" id="org.parboiled2;Parser">Parser</a><a href="#org.parboiled2;Parser" title="org.parboiled2.Parser" class="delimiter">(</a><a title="Int" id="org.parboiled2.Parser.<init>$default$1">initialValueStackSize</a>: <span title="Int">Int</span> = <span title="Int(16)" class="int">16</span>,
                      <a title="Int" id="org.parboiled2.Parser.<init>$default$2">maxValueStackSize</a>: <span title="Int">Int</span> = <span title="Int(1024)" class="int">1024</span><span class="delimiter">)</span> extends <a href="Rule.scala.html#org.parboiled2;RuleDSL" title="org.parboiled2.RuleDSL">RuleDSL</a> <span class="delimiter">{</span>
  import <a href="#org.parboiled2.Parser" title="org.parboiled2.Parser.type">Parser</a>._

  <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#org.parboiled2.Parser.<init>$default$2" title="Int">maxValueStackSize</a> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(65536)" class="int">65536</span>, <span title="String(&quot;`maxValueStackSize` &gt; 2^16 is not supported&quot;)" class="string">&quot;`maxValueStackSize` &gt; 2^16 is not supported&quot;</span><span class="delimiter">)</span> <span class="comment">// due to current snapshot design</span>

  <span class="comment">/**
   * The input this parser instance is running against.
   */</span>
  def <a title="=&gt; org.parboiled2.ParserInput" id="org.parboiled2;Parser.input">input</a>: <a href="ParserInput.scala.html#org.parboiled2;ParserInput" title="org.parboiled2.ParserInput">ParserInput</a>

  <span class="comment">/**
   * Converts a compile-time only rule definition into the corresponding rule method implementation.
   */</span>
  def <a title="[I &lt;: shapeless.HList, O &lt;: shapeless.HList](r: org.parboiled2.Rule[I,O])org.parboiled2.Rule[I,O]" id="org.parboiled2;Parser.rule">rule</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2;Parser.rule;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2;Parser.rule;O">O</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="org.parboiled2.Rule[I,O]" id="org.parboiled2;Parser.rule.r">r</a>: <a href="Rule.scala.html#org.parboiled2;Rule" title="org.parboiled2.Rule[I,O]">Rule</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Rule.scala.html#org.parboiled2;Rule" title="org.parboiled2.Rule[I,O]">Rule</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> = macro <a href="#org.parboiled2.ParserMacros" title="org.parboiled2.ParserMacros.type">ParserMacros</a>.<a href="#org.parboiled2.ParserMacros.ruleImpl" title="[I &lt;: shapeless.HList, O &lt;: shapeless.HList](ctx: org.parboiled2.ParserMacros.ParserContext)(r: ctx.Expr[org.parboiled2.Rule[I,O]])(implicit evidence$2: ctx.WeakTypeTag[I], implicit evidence$3: ctx.WeakTypeTag[O])ctx.Expr[org.parboiled2.Rule[I,O]]">ruleImpl</a><span title="(ctx: org.parboiled2.ParserMacros.ParserContext)(r: ctx.Expr[org.parboiled2.Rule[I,O]])(implicit evidence$2: ctx.WeakTypeTag[I], implicit evidence$3: ctx.WeakTypeTag[O])ctx.Expr[org.parboiled2.Rule[I,O]]" class="delimiter">[</span><a href="#org.parboiled2;Parser.rule;I" title="I">I</a>, <a href="#org.parboiled2;Parser.rule;O" title="O">O</a><span class="delimiter">]</span>

  <span class="comment">/**
   * Converts a compile-time only rule definition into the corresponding rule method implementation
   * with an explicitly given name.
   */</span>
  def <a title="[I &lt;: shapeless.HList, O &lt;: shapeless.HList](name: String)(r: org.parboiled2.Rule[I,O])org.parboiled2.Rule[I,O]" id="org.parboiled2;Parser.namedRule">namedRule</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2;Parser.namedRule;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2;Parser.namedRule;O">O</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="org.parboiled2;Parser.namedRule.name">name</a>: <span title="String">String</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="org.parboiled2.Rule[I,O]" id="org.parboiled2;Parser.namedRule.r">r</a>: <a href="Rule.scala.html#org.parboiled2;Rule" title="org.parboiled2.Rule[I,O]">Rule</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Rule.scala.html#org.parboiled2;Rule" title="org.parboiled2.Rule[I,O]">Rule</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> = macro <a href="#org.parboiled2.ParserMacros" title="org.parboiled2.ParserMacros.type">ParserMacros</a>.<a href="#org.parboiled2.ParserMacros.namedRuleImpl" title="[I &lt;: shapeless.HList, O &lt;: shapeless.HList](ctx: org.parboiled2.ParserMacros.ParserContext)(name: ctx.Expr[String])(r: ctx.Expr[org.parboiled2.Rule[I,O]])(implicit evidence$4: ctx.WeakTypeTag[I], implicit evidence$5: ctx.WeakTypeTag[O])ctx.Expr[org.parboiled2.Rule[I,O]]">namedRuleImpl</a><span title="(ctx: org.parboiled2.ParserMacros.ParserContext)(name: ctx.Expr[String])(r: ctx.Expr[org.parboiled2.Rule[I,O]])(implicit evidence$4: ctx.WeakTypeTag[I], implicit evidence$5: ctx.WeakTypeTag[O])ctx.Expr[org.parboiled2.Rule[I,O]]" class="delimiter">[</span><a href="#org.parboiled2;Parser.namedRule;I" title="I">I</a>, <a href="#org.parboiled2;Parser.namedRule;O" title="O">O</a><span class="delimiter">]</span>

  <span class="comment">/**
   * The index of the next (yet unmatched) input character.
   * Might be equal to `input.length`!
   */</span>
  def <a title="=&gt; Int" id="org.parboiled2;Parser.cursor">cursor</a>: <span title="Int">Int</span> = <a href="#org.parboiled2;Parser._cursor_=" title="=&gt; Int">_cursor</a>

  <span class="comment">/**
   * The next (yet unmatched) input character, i.e. the one at the `cursor` index.
   * Identical to `if (cursor &lt; input.length) input.charAt(cursor) else EOI` but more efficient.
   */</span>
  def <a title="=&gt; Char" id="org.parboiled2;Parser.cursorChar">cursorChar</a>: <span title="Char">Char</span> = <a href="#org.parboiled2;Parser._cursorChar_=" title="=&gt; Char">_cursorChar</a>

  <span class="comment">/**
   * Returns the last character that was matched, i.e. the one at index cursor - 1
   * Note: for performance optimization this method does *not* do a range check,
   * i.e. depending on the ParserInput implementation you might get an exception
   * when calling this method before any character was matched by the parser.
   */</span>
  def <a title="=&gt; Char" id="org.parboiled2;Parser.lastChar">lastChar</a>: <span title="Char">Char</span> = <a href="#org.parboiled2;Parser.charAt" title="(offset: Int)Char">charAt</a><span class="delimiter">(</span>-<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the character at the input index with the given delta to the cursor.
   * Note: for performance optimization this method does *not* do a range check,
   * i.e. depending on the ParserInput implementation you might get an exception
   * when calling this method before any character was matched by the parser.
   */</span>
  def <a title="(offset: Int)Char" id="org.parboiled2;Parser.charAt">charAt</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;Parser.charAt.offset">offset</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Char">Char</span> = <a href="#org.parboiled2;Parser.input" title="=&gt; org.parboiled2.ParserInput">input</a>.<a href="ParserInput.scala.html#org.parboiled2;ParserInput.charAt" title="(ix: Int)Char">charAt</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.cursor" title="=&gt; Int">cursor</a> <span title="(x: Int)Int">+</span> <a href="#org.parboiled2;Parser.charAt.offset" title="Int">offset</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Same as `charAt` but range-checked.
   * Returns the input character at the index with the given offset from the cursor.
   * If this index is out of range the method returns `EOI`.
   */</span>
  def <a title="(offset: Int)Char" id="org.parboiled2;Parser.charAtRC">charAtRC</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;Parser.charAtRC.offset">offset</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Char">Char</span> = <span class="delimiter">{</span>
    val ix = <a href="#org.parboiled2;Parser.cursor" title="=&gt; Int">cursor</a> <a title="Int" id="org.parboiled2;Parser.charAtRC.ix">+</a> <a href="#org.parboiled2;Parser.charAtRC.offset" title="Int">offset</a>
    if <span class="delimiter">(</span><span title="Int(0)" class="int">0</span> <span title="(x: Int)Boolean">&lt;=</span> <a href="#org.parboiled2;Parser.charAtRC.ix" title="Int">ix</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#org.parboiled2;Parser.charAtRC.ix" title="Int">ix</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#org.parboiled2;Parser.input" title="=&gt; org.parboiled2.ParserInput">input</a>.<a href="ParserInput.scala.html#org.parboiled2;ParserInput.length" title="=&gt; Int">length</a><span class="delimiter">)</span> <a href="#org.parboiled2;Parser.input" title="=&gt; org.parboiled2.ParserInput">input</a>.<a href="ParserInput.scala.html#org.parboiled2;ParserInput.charAt" title="(ix: Int)Char">charAt</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.charAtRC.ix" title="Int">ix</a><span class="delimiter">)</span> else <a href="RuleDSLBasics.scala.html#org.parboiled2;RuleDSLBasics.EOI" title="=&gt; Char">EOI</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Allows &quot;raw&quot; (i.e. untyped) access to the `ValueStack`.
   * In most cases you shouldn't need to access the value stack directly from your code.
   * Use only if you know what you are doing!
   */</span>
  def <a title="=&gt; org.parboiled2.ValueStack" id="org.parboiled2;Parser.valueStack">valueStack</a>: <a href="ValueStack.scala.html#org.parboiled2;ValueStack" title="org.parboiled2.ValueStack">ValueStack</a> = <a href="#org.parboiled2;Parser._valueStack_=" title="=&gt; org.parboiled2.ValueStack">_valueStack</a>

  <span class="comment">/**
   * Pretty prints the given `ParseError` instance in the context of the `ParserInput` of this parser.
   */</span>
  def <a title="(error: org.parboiled2.ParseError, showExpected: Boolean, showPosition: Boolean, showLine: Boolean, showTraces: Boolean)String" id="org.parboiled2;Parser.formatError">formatError</a><span class="delimiter">(</span><a title="org.parboiled2.ParseError" id="org.parboiled2;Parser.formatError.error">error</a>: <a href="ParseError.scala.html#org.parboiled2;ParseError" title="org.parboiled2.ParseError">ParseError</a>, <a title="Boolean" id="org.parboiled2;Parser.formatError$default$2">showExpected</a>: <span title="Boolean">Boolean</span> = true, <a title="Boolean" id="org.parboiled2;Parser.formatError$default$3">showPosition</a>: <span title="Boolean">Boolean</span> = true,
                  <a title="Boolean" id="org.parboiled2;Parser.formatError$default$4">showLine</a>: <span title="Boolean">Boolean</span> = true, <a title="Boolean" id="org.parboiled2;Parser.formatError$default$5">showTraces</a>: <span title="Boolean">Boolean</span> = false<span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
    val <a title="StringBuilder" id="org.parboiled2;Parser.formatError.sb">sb</a> = new java.lang.<span title="StringBuilder">StringBuilder</span><span class="delimiter">(</span><a href="#org.parboiled2;Parser.formatErrorProblem" title="(error: org.parboiled2.ParseError)String">formatErrorProblem</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.formatError.error" title="org.parboiled2.ParseError">error</a><span class="delimiter">)</span><span class="delimiter">)</span>
    import <a href="#org.parboiled2;Parser.formatError.error" title="org.parboiled2.ParseError">error</a>._
    if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.formatError$default$2" title="Boolean">showExpected</a><span class="delimiter">)</span> <a href="#org.parboiled2;Parser.formatError.sb" title="StringBuilder">sb</a>.<span title="(x$1: String)StringBuilder">append</span><span class="delimiter">(</span><span title="String(&quot;, expected &quot;)" class="string">&quot;, expected &quot;</span><span class="delimiter">)</span>.<span title="(x$1: String)StringBuilder">append</span><span class="delimiter">(</span><a href="ParseError.scala.html#org.parboiled2;ParseError.formatExpectedAsString" title="=&gt; String">formatExpectedAsString</a><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.formatError$default$3" title="Boolean">showPosition</a><span class="delimiter">)</span> <a href="#org.parboiled2;Parser.formatError.sb" title="StringBuilder">sb</a>.<span title="(x$1: String)StringBuilder">append</span><span class="delimiter">(</span><span title="String(&quot; (line &quot;)" class="string">&quot; (line &quot;</span><span class="delimiter">)</span>.<span title="(x$1: Int)StringBuilder">append</span><span class="delimiter">(</span><a href="ParseError.scala.html#org.parboiled2;ParseError.position" title="=&gt; org.parboiled2.Position">position</a>.<a href="ParseError.scala.html#org.parboiled2;Position.line" title="=&gt; Int">line</a><span class="delimiter">)</span>.<span title="(x$1: String)StringBuilder">append</span><span class="delimiter">(</span><span title="String(&quot;, column &quot;)" class="string">&quot;, column &quot;</span><span class="delimiter">)</span>.<span title="(x$1: Int)StringBuilder">append</span><span class="delimiter">(</span><a href="ParseError.scala.html#org.parboiled2;ParseError.position" title="=&gt; org.parboiled2.Position">position</a>.<a href="ParseError.scala.html#org.parboiled2;Position.column" title="=&gt; Int">column</a><span class="delimiter">)</span>.<span title="(x$1: Char)StringBuilder">append</span><span class="delimiter">(</span><span title="Char(')')" class="char">')'</span><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.formatError$default$4" title="Boolean">showLine</a><span class="delimiter">)</span> <a href="#org.parboiled2;Parser.formatError.sb" title="StringBuilder">sb</a>.<span title="(x$1: Char)StringBuilder">append</span><span class="delimiter">(</span><span title="Char(':')" class="char">':'</span><span class="delimiter">)</span>.<span title="(x$1: Char)StringBuilder">append</span><span class="delimiter">(</span><span title="Char('\n')" class="char">'\n'</span><span class="delimiter">)</span>.<span title="(x$1: String)StringBuilder">append</span><span class="delimiter">(</span><a href="#org.parboiled2;Parser.formatErrorLine" title="(error: org.parboiled2.ParseError)String">formatErrorLine</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.formatError.error" title="org.parboiled2.ParseError">error</a><span class="delimiter">)</span><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.formatError$default$5" title="Boolean">showTraces</a><span class="delimiter">)</span> <a href="#org.parboiled2;Parser.formatError.sb" title="StringBuilder">sb</a>.<span title="(x$1: Char)StringBuilder">append</span><span class="delimiter">(</span><span title="Char('\n')" class="char">'\n'</span><span class="delimiter">)</span>.<span title="(x$1: Char)StringBuilder">append</span><span class="delimiter">(</span><span title="Char('\n')" class="char">'\n'</span><span class="delimiter">)</span>.<span title="(x$1: String)StringBuilder">append</span><span class="delimiter">(</span><a href="ParseError.scala.html#org.parboiled2;ParseError.formatTraces" title="=&gt; String">formatTraces</a><span class="delimiter">)</span>
    <a href="#org.parboiled2;Parser.formatError.sb" title="StringBuilder">sb</a>.<span title="()String">toString</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Pretty prints the input line in which the error occurred and underlines the error position in the line
   * with a caret.
   */</span>
  def <a title="(error: org.parboiled2.ParseError)String" id="org.parboiled2;Parser.formatErrorProblem">formatErrorProblem</a><span class="delimiter">(</span><a title="org.parboiled2.ParseError" id="org.parboiled2;Parser.formatErrorProblem.error">error</a>: <a href="ParseError.scala.html#org.parboiled2;ParseError" title="org.parboiled2.ParseError">ParseError</a><span class="delimiter">)</span>: <span title="String">String</span> =
    if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.formatErrorProblem.error" title="org.parboiled2.ParseError">error</a>.<a href="ParseError.scala.html#org.parboiled2;ParseError.position" title="=&gt; org.parboiled2.Position">position</a>.<a href="ParseError.scala.html#org.parboiled2;Position.index" title="=&gt; Int">index</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#org.parboiled2;Parser.input" title="=&gt; org.parboiled2.ParserInput">input</a>.<a href="ParserInput.scala.html#org.parboiled2;ParserInput.length" title="=&gt; Int">length</a><span class="delimiter">)</span> <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Invalid input \'&quot;)">Invalid input '$</span><span class="delimiter">{</span><a href="CharUtils.scala.html#org.parboiled2.CharUtils" title="org.parboiled2.CharUtils.type">CharUtils</a>.<a href="CharUtils.scala.html#org.parboiled2.CharUtils.escape(330dead26b)" title="(c: Char)String">escape</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.input" title="=&gt; org.parboiled2.ParserInput">input</a> <a href="ParserInput.scala.html#org.parboiled2;ParserInput.charAt" title="(ix: Int)Char">charAt</a> <a href="#org.parboiled2;Parser.formatErrorProblem.error" title="org.parboiled2.ParseError">error</a>.<a href="ParseError.scala.html#org.parboiled2;ParseError.position" title="=&gt; org.parboiled2.Position">position</a>.<a href="ParseError.scala.html#org.parboiled2;Position.index" title="=&gt; Int">index</a><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;\'&quot;)" class="string">'&quot;</span>
    else <span title="String(&quot;Unexpected end of input&quot;)" class="string">&quot;Unexpected end of input&quot;</span>

  <span class="comment">/**
   * Pretty prints the input line in which the error occurred and underlines the error position in the line
   * with a caret.
   */</span>
  def <a title="(error: org.parboiled2.ParseError)String" id="org.parboiled2;Parser.formatErrorLine">formatErrorLine</a><span class="delimiter">(</span><a title="org.parboiled2.ParseError" id="org.parboiled2;Parser.formatErrorLine.error">error</a>: <a href="ParseError.scala.html#org.parboiled2;ParseError" title="org.parboiled2.ParseError">ParseError</a><span class="delimiter">)</span>: <span title="String">String</span> =
    <span class="delimiter">(</span><a href="#org.parboiled2;Parser.input" title="=&gt; org.parboiled2.ParserInput">input</a> <a href="ParserInput.scala.html#org.parboiled2;ParserInput.getLine" title="(line: Int)String">getLine</a> <a href="#org.parboiled2;Parser.formatErrorLine.error" title="org.parboiled2.ParseError">error</a>.<a href="ParseError.scala.html#org.parboiled2;ParseError.position" title="=&gt; org.parboiled2.Position">position</a>.<a href="ParseError.scala.html#org.parboiled2;Position.line" title="=&gt; Int">line</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="Char('\n')" class="char">'\n'</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot; &quot;</span> <span title="(n: Int)String">*</span> <span class="delimiter">(</span><a href="#org.parboiled2;Parser.formatErrorLine.error" title="org.parboiled2.ParseError">error</a>.<a href="ParseError.scala.html#org.parboiled2;ParseError.position" title="=&gt; org.parboiled2.Position">position</a>.<a href="ParseError.scala.html#org.parboiled2;Position.column" title="=&gt; Int">column</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="Char('^')" class="char">'^'</span><span class="delimiter">)</span>

  <span class="comment">////////////////////// INTERNAL /////////////////////////</span>

  <span class="comment">// the char at the current input index</span>
  private var <a title="Char" id="org.parboiled2;Parser._cursorChar_=">_cursorChar</a>: <span title="Char">Char</span> = _

  <span class="comment">// the index of the current input char</span>
  private var <a title="Int" id="org.parboiled2;Parser._cursor_=">_cursor</a>: <span title="Int">Int</span> = _

  <span class="comment">// the value stack instance we operate on</span>
  private var <a title="org.parboiled2.ValueStack" id="org.parboiled2;Parser._valueStack_=">_valueStack</a>: <a href="ValueStack.scala.html#org.parboiled2;ValueStack" title="org.parboiled2.ValueStack">ValueStack</a> = _

  <span class="comment">// the highest input index we have seen in the current run</span>
  <span class="comment">// special value: -1 (not collecting errors)</span>
  private var <a title="Int" id="org.parboiled2;Parser.maxCursor_=">maxCursor</a>: <span title="Int">Int</span> = _

  <span class="comment">// the number of times we have already seen a character mismatch at the error index</span>
  private var <a title="Int" id="org.parboiled2;Parser.mismatchesAtErrorCursor_=">mismatchesAtErrorCursor</a>: <span title="Int">Int</span> = _

  <span class="comment">// the index of the RuleStack we are currently constructing</span>
  <span class="comment">// for the ParseError to be (potentially) returned in the current parser run,</span>
  <span class="comment">// special value: -1 (during the run to establish the error location (maxCursor))</span>
  private var <a title="Int" id="org.parboiled2;Parser.currentErrorRuleStackIx_=">currentErrorRuleStackIx</a>: <span title="Int">Int</span> = _

  def <a title="(other: org.parboiled2.Parser, offset: Int)Unit" id="org.parboiled2;Parser.copyStateFrom">copyStateFrom</a><span class="delimiter">(</span><a title="org.parboiled2.Parser" id="org.parboiled2;Parser.copyStateFrom.other">other</a>: <a href="#org.parboiled2;Parser" title="org.parboiled2.Parser">Parser</a>, <a title="Int" id="org.parboiled2;Parser.copyStateFrom.offset">offset</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <a href="#org.parboiled2;Parser._cursorChar_=" title="(x$1: Char)Unit">_cursorChar</a> = <a href="#org.parboiled2;Parser.copyStateFrom.other" title="org.parboiled2.Parser">other</a>.<a href="#org.parboiled2;Parser._cursorChar_=" title="=&gt; Char">_cursorChar</a>
    <a href="#org.parboiled2;Parser._cursor_=" title="(x$1: Int)Unit">_cursor</a> = <a href="#org.parboiled2;Parser.copyStateFrom.other" title="org.parboiled2.Parser">other</a>.<a href="#org.parboiled2;Parser._cursor_=" title="=&gt; Int">_cursor</a> <span title="(x: Int)Int">-</span> <a href="#org.parboiled2;Parser.copyStateFrom.offset" title="Int">offset</a>
    <a href="#org.parboiled2;Parser._valueStack_=" title="(x$1: org.parboiled2.ValueStack)Unit">_valueStack</a> = <a href="#org.parboiled2;Parser.copyStateFrom.other" title="org.parboiled2.Parser">other</a>.<a href="#org.parboiled2;Parser._valueStack_=" title="=&gt; org.parboiled2.ValueStack">_valueStack</a>
    <a href="#org.parboiled2;Parser.maxCursor_=" title="(x$1: Int)Unit">maxCursor</a> = <a href="#org.parboiled2;Parser.copyStateFrom.other" title="org.parboiled2.Parser">other</a>.<a href="#org.parboiled2;Parser.maxCursor_=" title="=&gt; Int">maxCursor</a> <span title="(x: Int)Int">-</span> <a href="#org.parboiled2;Parser.copyStateFrom.offset" title="Int">offset</a>
    <a href="#org.parboiled2;Parser.mismatchesAtErrorCursor_=" title="(x$1: Int)Unit">mismatchesAtErrorCursor</a> = <a href="#org.parboiled2;Parser.copyStateFrom.other" title="org.parboiled2.Parser">other</a>.<a href="#org.parboiled2;Parser.mismatchesAtErrorCursor_=" title="=&gt; Int">mismatchesAtErrorCursor</a>
    <a href="#org.parboiled2;Parser.currentErrorRuleStackIx_=" title="(x$1: Int)Unit">currentErrorRuleStackIx</a> = <a href="#org.parboiled2;Parser.copyStateFrom.other" title="org.parboiled2.Parser">other</a>.<a href="#org.parboiled2;Parser.currentErrorRuleStackIx_=" title="=&gt; Int">currentErrorRuleStackIx</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  def <a title="=&gt; Boolean" id="org.parboiled2;Parser.__collectingErrors">__collectingErrors</a> = <a href="#org.parboiled2;Parser.maxCursor_=" title="=&gt; Int">maxCursor</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  def <a title="[L &lt;: shapeless.HList](rule: =&gt; org.parboiled2.RuleN[L])(implicit scheme: org.parboiled2.Parser.DeliveryScheme[L])scheme.Result" id="org.parboiled2;Parser.__run">__run</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2;Parser.__run;L">L</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; org.parboiled2.RuleN[L]" id="org.parboiled2;Parser.__run.rule">rule</a>: ⇒ RuleN<span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.Parser.DeliveryScheme[L]" id="org.parboiled2;Parser.__run.scheme">scheme</a>: Parser.<a href="#org.parboiled2.Parser;DeliveryScheme" title="org.parboiled2.Parser.DeliveryScheme[L]">DeliveryScheme</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span>: scheme.<a href="#org.parboiled2.Parser;DeliveryScheme;Result" title="scheme.Result">Result</a> = <span class="delimiter">{</span>
    def <a title="(errorRuleStackIx: Int)Boolean" id="org.parboiled2;Parser.__run.runRule">runRule</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;Parser.__run.runRule$default$1">errorRuleStackIx</a>: <span title="Int">Int</span> = -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <a href="#org.parboiled2;Parser._cursor_=" title="(x$1: Int)Unit">_cursor</a> = -<span title="Int(-1)" class="int">1</span>
      <a href="#org.parboiled2;Parser.__advance" title="()Boolean">__advance</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#org.parboiled2;Parser.valueStack" title="=&gt; org.parboiled2.ValueStack">valueStack</a>.<a href="ValueStack.scala.html#org.parboiled2;ValueStack.clear" title="()Unit">clear</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#org.parboiled2;Parser.mismatchesAtErrorCursor_=" title="(x$1: Int)Unit">mismatchesAtErrorCursor</a> = <span title="Int(0)" class="int">0</span>
      <a href="#org.parboiled2;Parser.currentErrorRuleStackIx_=" title="(x$1: Int)Unit">currentErrorRuleStackIx</a> = <a href="#org.parboiled2;Parser.__run.runRule$default$1" title="Int">errorRuleStackIx</a>
      <a href="#org.parboiled2;Parser.__run.rule" title="=&gt; org.parboiled2.RuleN[L]">rule</a> <span title="(x$1: AnyRef)Boolean">ne</span> null
    <span class="delimiter">}</span>

    @tailrec
    def <a title="(ix: Int, line: Int, col: Int)org.parboiled2.Position" id="org.parboiled2;Parser.__run.errorPosition">errorPosition</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;Parser.__run.errorPosition$default$1">ix</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>, <a title="Int" id="org.parboiled2;Parser.__run.errorPosition$default$2">line</a>: <span title="Int">Int</span> = <span title="Int(1)" class="int">1</span>, <a title="Int" id="org.parboiled2;Parser.__run.errorPosition$default$3">col</a>: <span title="Int">Int</span> = <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>: <a href="ParseError.scala.html#org.parboiled2;Position" title="org.parboiled2.Position">Position</a> =
      if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__run.errorPosition$default$1" title="Int">ix</a> <span title="(x: Int)Boolean">&gt;=</span> <a href="#org.parboiled2;Parser.maxCursor_=" title="=&gt; Int">maxCursor</a><span class="delimiter">)</span> <a href="ParseError.scala.html#org.parboiled2;Position" title="(index: Int, line: Int, column: Int)org.parboiled2.Position">Position</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.maxCursor_=" title="=&gt; Int">maxCursor</a>, <a href="#org.parboiled2;Parser.__run.errorPosition$default$2" title="Int">line</a>, <a href="#org.parboiled2;Parser.__run.errorPosition$default$3" title="Int">col</a><span class="delimiter">)</span>
      else if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__run.errorPosition$default$1" title="Int">ix</a> <span title="(x: Int)Boolean">&gt;=</span> <a href="#org.parboiled2;Parser.input" title="=&gt; org.parboiled2.ParserInput">input</a>.<a href="ParserInput.scala.html#org.parboiled2;ParserInput.length" title="=&gt; Int">length</a> <span title="(x: Boolean)Boolean">||</span> <a href="#org.parboiled2;Parser.input" title="=&gt; org.parboiled2.ParserInput">input</a>.<a href="ParserInput.scala.html#org.parboiled2;ParserInput.charAt" title="(ix: Int)Char">charAt</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__run.errorPosition$default$1" title="Int">ix</a><span class="delimiter">)</span> <span title="(x: Char)Boolean">!=</span> <span title="Char('\n')" class="char">'\n'</span><span class="delimiter">)</span> <a href="#org.parboiled2;Parser.__run.errorPosition" title="(ix: Int, line: Int, col: Int)org.parboiled2.Position">errorPosition</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__run.errorPosition$default$1" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#org.parboiled2;Parser.__run.errorPosition$default$2" title="Int">line</a>, <a href="#org.parboiled2;Parser.__run.errorPosition$default$3" title="Int">col</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      else <a href="#org.parboiled2;Parser.__run.errorPosition" title="(ix: Int, line: Int, col: Int)org.parboiled2.Position">errorPosition</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__run.errorPosition$default$1" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#org.parboiled2;Parser.__run.errorPosition$default$2" title="Int">line</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>

    @tailrec
    def <a title="(errorRuleIx: Int, traces: scala.collection.immutable.VectorBuilder[org.parboiled2.RuleTrace])org.parboiled2.ParseError" id="org.parboiled2;Parser.__run.buildParseError">buildParseError</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;Parser.__run.buildParseError$default$1">errorRuleIx</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>, <a title="scala.collection.immutable.VectorBuilder[org.parboiled2.RuleTrace]" id="org.parboiled2;Parser.__run.buildParseError$default$2">traces</a>: <span title="scala.collection.immutable.VectorBuilder[org.parboiled2.RuleTrace]">VectorBuilder</span><span class="delimiter">[</span>RuleTrace<span class="delimiter">]</span> = new <span title="scala.collection.immutable.VectorBuilder[org.parboiled2.RuleTrace]">VectorBuilder</span><span class="delimiter">)</span>: <a href="ParseError.scala.html#org.parboiled2;ParseError" title="org.parboiled2.ParseError">ParseError</a> = <span class="delimiter">{</span>
      val <a title="List[org.parboiled2.RuleFrame]" id="org.parboiled2;Parser.__run.buildParseError.ruleFrames">ruleFrames</a>: <span title="List[org.parboiled2.RuleFrame]">List</span><span class="delimiter">[</span>RuleFrame<span class="delimiter">]</span> =
        try <span class="delimiter">{</span>
          <a href="#org.parboiled2;Parser.__run.runRule" title="(errorRuleStackIx: Int)Boolean">runRule</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__run.buildParseError$default$1" title="Int">errorRuleIx</a><span class="delimiter">)</span>
          <span title="scala.collection.immutable.Nil.type">Nil</span> <span class="comment">// we managed to complete the run w/o exception, i.e. we have collected all frames</span>
        <span class="delimiter">}</span> catch <span class="delimiter">{</span>
          case <a title="org.parboiled2.Parser.CollectingRuleStackException" id="org.parboiled2;Parser.__run.buildParseError.ruleFrames.e">e</a>: Parser.<a href="#org.parboiled2.Parser;CollectingRuleStackException" title="org.parboiled2.Parser.CollectingRuleStackException">CollectingRuleStackException</a> ⇒ <a href="#org.parboiled2;Parser.__run.buildParseError.ruleFrames.e" title="org.parboiled2.Parser.CollectingRuleStackException">e</a>.<a href="#org.parboiled2.Parser;CollectingRuleStackException.ruleFrames" title="=&gt; List[org.parboiled2.RuleFrame]">ruleFrames</a>
        <span class="delimiter">}</span>
      if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__run.buildParseError.ruleFrames" title="List[org.parboiled2.RuleFrame]">ruleFrames</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="ParseError.scala.html#org.parboiled2;ParseError" title="(position: org.parboiled2.Position, traces: Seq[org.parboiled2.RuleTrace])org.parboiled2.ParseError">ParseError</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__run.errorPosition" title="(ix: Int, line: Int, col: Int)org.parboiled2.Position">errorPosition</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#org.parboiled2;Parser.__run.buildParseError$default$2" title="scala.collection.immutable.VectorBuilder[org.parboiled2.RuleTrace]">traces</a>.<span title="()scala.collection.immutable.Vector[org.parboiled2.RuleTrace]">result</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      else <a href="#org.parboiled2;Parser.__run.buildParseError" title="(errorRuleIx: Int, traces: scala.collection.immutable.VectorBuilder[org.parboiled2.RuleTrace])org.parboiled2.ParseError">buildParseError</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__run.buildParseError$default$1" title="Int">errorRuleIx</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#org.parboiled2;Parser.__run.buildParseError$default$2" title="scala.collection.immutable.VectorBuilder[org.parboiled2.RuleTrace]">traces</a> <span title="(elem: org.parboiled2.RuleTrace)traces.type">+=</span> <a href="ParseError.scala.html#org.parboiled2;RuleTrace" title="(frames: Seq[org.parboiled2.RuleFrame])org.parboiled2.RuleTrace">RuleTrace</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__run.buildParseError.ruleFrames" title="List[org.parboiled2.RuleFrame]">ruleFrames</a>.<span title="=&gt; Vector[org.parboiled2.RuleFrame]">toVector</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#org.parboiled2;Parser._valueStack_=" title="(x$1: org.parboiled2.ValueStack)Unit">_valueStack</a> = new <a href="ValueStack.scala.html#org.parboiled2;ValueStack" title="org.parboiled2.ValueStack">ValueStack</a><span class="delimiter">(</span><a href="#org.parboiled2.Parser.<init>$default$1" title="Int">initialValueStackSize</a>, <a href="#org.parboiled2.Parser.<init>$default$2" title="Int">maxValueStackSize</a><span class="delimiter">)</span>
    try <span class="delimiter">{</span>
      <a href="#org.parboiled2;Parser.maxCursor_=" title="(x$1: Int)Unit">maxCursor</a> = -<span title="Int(-1)" class="int">1</span>
      if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__run.runRule" title="(errorRuleStackIx: Int)Boolean">runRule</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#org.parboiled2;Parser.__run.scheme" title="org.parboiled2.Parser.DeliveryScheme[L]">scheme</a>.<a href="#org.parboiled2.Parser;DeliveryScheme.success" title="(result: L)scheme.Result">success</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.valueStack" title="org.parboiled2.ValueStack" id="org.parboiled2;Parser.__run.qual$1">valueStack</a>.<a href="ValueStack.scala.html#org.parboiled2;ValueStack.toHList" title="[L &lt;: shapeless.HList](start: Int, end: Int, prependTo: shapeless.HList)L">toHList</a><a href="ValueStack.scala.html#org.parboiled2;ValueStack.toHList$default$1" title="Int" id="org.parboiled2;Parser.__run.x$6" class="delimiter">[</a><a href="#org.parboiled2;Parser.__run;L" title="L">L</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      else <span class="delimiter">{</span>
        <a href="#org.parboiled2;Parser.maxCursor_=" title="(x$1: Int)Unit">maxCursor</a> = <span title="Int(0)" class="int">0</span> <span class="comment">// establish the error location with the next run</span>
        if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__run.runRule" title="(errorRuleStackIx: Int)Boolean">runRule</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;Parsing unexpectedly succeeded while trying to establish the error location&quot;)" class="string">&quot;Parsing unexpectedly succeeded while trying to establish the error location&quot;</span><span class="delimiter">)</span>
        <span class="comment">// now maxCursor holds the error location, we can now build the parser error info</span>
        <a href="#org.parboiled2;Parser.__run.scheme" title="org.parboiled2.Parser.DeliveryScheme[L]">scheme</a>.<a href="#org.parboiled2.Parser;DeliveryScheme.parseError" title="(error: org.parboiled2.ParseError)scheme.Result">parseError</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__run.buildParseError" title="(errorRuleIx: Int, traces: scala.collection.immutable.VectorBuilder[org.parboiled2.RuleTrace])org.parboiled2.ParseError">buildParseError</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> catch <span class="delimiter">{</span>
      case <a href="#org.parboiled2;Parser.__run.<unapply-selector>" title="(t: Throwable)Option[Throwable]">NonFatal</a><span class="delimiter">(</span><a title="Throwable" id="org.parboiled2;Parser.__run.e">e</a><span class="delimiter">)</span> ⇒ <a href="#org.parboiled2;Parser.__run.scheme" title="org.parboiled2.Parser.DeliveryScheme[L]">scheme</a>.<a href="#org.parboiled2.Parser;DeliveryScheme.failure" title="(error: Throwable)scheme.Result">failure</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__run.e" title="Throwable">e</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  def <a title="()Boolean" id="org.parboiled2;Parser.__advance">__advance</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    var <a title="Int" id="org.parboiled2;Parser.__advance.c">c</a> = <a href="#org.parboiled2;Parser._cursor_=" title="=&gt; Int">_cursor</a>
    val <a title="Int" id="org.parboiled2;Parser.__advance.max">max</a> = <a href="#org.parboiled2;Parser.input" title="=&gt; org.parboiled2.ParserInput">input</a>.<a href="ParserInput.scala.html#org.parboiled2;ParserInput.length" title="=&gt; Int">length</a>
    if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__advance.c" title="Int">c</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#org.parboiled2;Parser.__advance.max" title="Int">max</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#org.parboiled2;Parser.__advance.c" title="Int">c</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
      <a href="#org.parboiled2;Parser._cursor_=" title="(x$1: Int)Unit">_cursor</a> = <a href="#org.parboiled2;Parser.__advance.c" title="Int">c</a>
      <a href="#org.parboiled2;Parser._cursorChar_=" title="(x$1: Char)Unit">_cursorChar</a> = if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__advance.c" title="Int">c</a> <span title="(x: Int)Boolean">==</span> <a href="#org.parboiled2;Parser.__advance.max" title="Int">max</a><span class="delimiter">)</span> <a href="RuleDSLBasics.scala.html#org.parboiled2;RuleDSLBasics.EOI" title="=&gt; Char">EOI</a> else <a href="#org.parboiled2;Parser.input" title="=&gt; org.parboiled2.ParserInput">input</a> <a href="ParserInput.scala.html#org.parboiled2;ParserInput.charAt" title="(ix: Int)Char">charAt</a> <a href="#org.parboiled2;Parser.__advance.c" title="Int">c</a>
    <span class="delimiter">}</span>
    true
  <span class="delimiter">}</span>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  def <a title="()Boolean" id="org.parboiled2;Parser.__updateMaxCursor">__updateMaxCursor</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#org.parboiled2;Parser._cursor_=" title="=&gt; Int">_cursor</a> <span title="(x: Int)Boolean">&gt;</span> <a href="#org.parboiled2;Parser.maxCursor_=" title="=&gt; Int">maxCursor</a><span class="delimiter">)</span> <a href="#org.parboiled2;Parser.maxCursor_=" title="(x$1: Int)Unit">maxCursor</a> = <a href="#org.parboiled2;Parser._cursor_=" title="=&gt; Int">_cursor</a>
    true
  <span class="delimiter">}</span>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  def <a title="=&gt; org.parboiled2.Parser.Mark" id="org.parboiled2;Parser.__saveState">__saveState</a>: <a href="#org.parboiled2.Parser.Mark" title="org.parboiled2.Parser.Mark">Mark</a> = new <a href="#org.parboiled2.Parser.Mark" title="org.parboiled2.Parser.Mark">Mark</a><span class="delimiter">(</span><span class="delimiter">(</span><a href="#org.parboiled2;Parser._cursor_=" title="=&gt; Int">_cursor</a>.<span title="=&gt; Long">toLong</span> <span title="(x: Int)Long">&lt;&lt;</span> <span title="Int(32)" class="int">32</span><span class="delimiter">)</span> <span title="(x: Long)Long">+</span> <span class="delimiter">(</span><a href="#org.parboiled2;Parser._cursorChar_=" title="=&gt; Char">_cursorChar</a>.<span title="=&gt; Long">toLong</span> <span title="(x: Int)Long">&lt;&lt;</span> <span title="Int(16)" class="int">16</span><span class="delimiter">)</span> <span title="(x: Int)Long">+</span> <a href="#org.parboiled2;Parser.valueStack" title="=&gt; org.parboiled2.ValueStack">valueStack</a>.<a href="ValueStack.scala.html#org.parboiled2;ValueStack.size" title="=&gt; Int">size</a><span class="delimiter">)</span>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  def <a title="(mark: org.parboiled2.Parser.Mark)Unit" id="org.parboiled2;Parser.__restoreState">__restoreState</a><span class="delimiter">(</span><a title="org.parboiled2.Parser.Mark" id="org.parboiled2;Parser.__restoreState.mark">mark</a>: <a href="#org.parboiled2.Parser.Mark" title="org.parboiled2.Parser.Mark">Mark</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <a href="#org.parboiled2;Parser._cursor_=" title="(x$1: Int)Unit">_cursor</a> = <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__restoreState.mark" title="org.parboiled2.Parser.Mark">mark</a>.<a href="#org.parboiled2.Parser;Mark.value" title="=&gt; Long">value</a> <span title="(x: Int)Long">&gt;&gt;&gt;</span> <span title="Int(32)" class="int">32</span><span class="delimiter">)</span>.<span title="=&gt; Int">toInt</span>
    <a href="#org.parboiled2;Parser._cursorChar_=" title="(x$1: Char)Unit">_cursorChar</a> = <span class="delimiter">(</span><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__restoreState.mark" title="org.parboiled2.Parser.Mark">mark</a>.<a href="#org.parboiled2.Parser;Mark.value" title="=&gt; Long">value</a> <span title="(x: Int)Long">&gt;&gt;&gt;</span> <span title="Int(16)" class="int">16</span><span class="delimiter">)</span> <span title="(x: Int)Long">&amp;</span> <span title="Int(65535)" class="int">0x000000000000FFFF</span><span class="delimiter">)</span>.<span title="=&gt; Char">toChar</span>
    <a href="#org.parboiled2;Parser.valueStack" title="=&gt; org.parboiled2.ValueStack">valueStack</a>.<a href="ValueStack.scala.html#org.parboiled2;ValueStack.size_=" title="(newSize: Int)Unit">size</a> = <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__restoreState.mark" title="org.parboiled2.Parser.Mark">mark</a>.<a href="#org.parboiled2.Parser;Mark.value" title="=&gt; Long">value</a> <span title="(x: Int)Long">&amp;</span> <span title="Int(65535)" class="int">0x000000000000FFFF</span><span class="delimiter">)</span>.<span title="=&gt; Int">toInt</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  def <a title="=&gt; Int" id="org.parboiled2;Parser.__enterNotPredicate">__enterNotPredicate</a>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    val <a title="Int" id="org.parboiled2;Parser.__enterNotPredicate.saved">saved</a> = <a href="#org.parboiled2;Parser.maxCursor_=" title="=&gt; Int">maxCursor</a>
    <a href="#org.parboiled2;Parser.maxCursor_=" title="(x$1: Int)Unit">maxCursor</a> = -<span title="Int(-1)" class="int">1</span> <span class="comment">// disables maxCursor update as well as error rulestack collection</span>
    <a href="#org.parboiled2;Parser.__enterNotPredicate.saved" title="Int">saved</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  def <a title="(saved: Int)Unit" id="org.parboiled2;Parser.__exitNotPredicate">__exitNotPredicate</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;Parser.__exitNotPredicate.saved">saved</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#org.parboiled2;Parser.maxCursor_=" title="(x$1: Int)Unit">maxCursor</a> = <a href="#org.parboiled2;Parser.__exitNotPredicate.saved" title="Int">saved</a>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  def <a title="()Boolean" id="org.parboiled2;Parser.__registerMismatch">__registerMismatch</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.currentErrorRuleStackIx_=" title="=&gt; Int">currentErrorRuleStackIx</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#org.parboiled2;Parser._cursor_=" title="=&gt; Int">_cursor</a> <span title="(x: Int)Boolean">==</span> <a href="#org.parboiled2;Parser.maxCursor_=" title="=&gt; Int">maxCursor</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.mismatchesAtErrorCursor_=" title="=&gt; Int">mismatchesAtErrorCursor</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#org.parboiled2;Parser.currentErrorRuleStackIx_=" title="=&gt; Int">currentErrorRuleStackIx</a><span class="delimiter">)</span> <a href="#org.parboiled2;Parser.mismatchesAtErrorCursor_=" title="(x$1: Int)Unit">mismatchesAtErrorCursor</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
      else throw new <a href="#org.parboiled2.Parser" title="org.parboiled2.Parser.type">Parser</a>.<a href="#org.parboiled2.Parser;CollectingRuleStackException" title="org.parboiled2.Parser.CollectingRuleStackException">CollectingRuleStackException</a>
    <span class="delimiter">}</span>
    false
  <span class="delimiter">}</span>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  def <a title="(value: Any)Boolean" id="org.parboiled2;Parser.__push">__push</a><span class="delimiter">(</span><a title="Any" id="org.parboiled2;Parser.__push.value">value</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <a href="#org.parboiled2;Parser.__push.value" title="Any">value</a> match <span class="delimiter">{</span>
      case <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>       ⇒
      case <span title="shapeless.HList">x</span>: <span title="shapeless.HList">HList</span> ⇒ <a href="#org.parboiled2;Parser.valueStack" title="=&gt; org.parboiled2.ValueStack">valueStack</a>.<a href="ValueStack.scala.html#org.parboiled2;ValueStack.pushAll" title="(hlist: shapeless.HList)Unit">pushAll</a><span class="delimiter">(</span><span title="shapeless.HList">x</span><span class="delimiter">)</span>
      case <span title="Any">x</span>        ⇒ <a href="#org.parboiled2;Parser.valueStack" title="=&gt; org.parboiled2.ValueStack">valueStack</a>.<a href="ValueStack.scala.html#org.parboiled2;ValueStack.push" title="(value: Any)Unit">push</a><span class="delimiter">(</span><span title="Any">x</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    true
  <span class="delimiter">}</span>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  @tailrec final def <a title="(string: String, ix: Int)Boolean" id="org.parboiled2;Parser.__matchString">__matchString</a><span class="delimiter">(</span><a title="String" id="org.parboiled2;Parser.__matchString.string">string</a>: <span title="String">String</span>, <a title="Int" id="org.parboiled2;Parser.__matchString$default$2">ix</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchString$default$2" title="Int">ix</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#org.parboiled2;Parser.__matchString.string" title="String">string</a>.<span title="()Int">length</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.cursorChar" title="=&gt; Char">cursorChar</a> <span title="(x: Char)Boolean">==</span> <a href="#org.parboiled2;Parser.__matchString.string" title="String">string</a>.<span title="(x$1: Int)Char">charAt</span><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchString$default$2" title="Int">ix</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#org.parboiled2;Parser.__advance" title="()Boolean">__advance</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#org.parboiled2;Parser.__matchString" title="(string: String, ix: Int)Boolean">__matchString</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchString.string" title="String">string</a>, <a href="#org.parboiled2;Parser.__matchString$default$2" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else false
    else true

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  @tailrec final def <a title="(string: String, ruleName: String, ix: Int)Boolean" id="org.parboiled2;Parser.__matchStringWrapped">__matchStringWrapped</a><span class="delimiter">(</span><a title="String" id="org.parboiled2;Parser.__matchStringWrapped.string">string</a>: <span title="String">String</span>, <a title="String" id="org.parboiled2;Parser.__matchStringWrapped.ruleName">ruleName</a>: <span title="String">String</span>, <a title="Int" id="org.parboiled2;Parser.__matchStringWrapped$default$3">ix</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchStringWrapped$default$3" title="Int">ix</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#org.parboiled2;Parser.__matchStringWrapped.string" title="String">string</a>.<span title="()Int">length</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.cursorChar" title="=&gt; Char">cursorChar</a> <span title="(x: Char)Boolean">==</span> <a href="#org.parboiled2;Parser.__matchStringWrapped.string" title="String">string</a>.<span title="(x$1: Int)Char">charAt</span><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchStringWrapped$default$3" title="Int">ix</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#org.parboiled2;Parser.__advance" title="()Boolean">__advance</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#org.parboiled2;Parser.__updateMaxCursor" title="()Boolean">__updateMaxCursor</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#org.parboiled2;Parser.__matchStringWrapped" title="(string: String, ruleName: String, ix: Int)Boolean">__matchStringWrapped</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchStringWrapped.string" title="String">string</a>, <a href="#org.parboiled2;Parser.__matchStringWrapped.ruleName" title="String">ruleName</a>, <a href="#org.parboiled2;Parser.__matchStringWrapped$default$3" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        try <a href="#org.parboiled2;Parser.__registerMismatch" title="()Boolean">__registerMismatch</a><span class="delimiter">(</span><span class="delimiter">)</span>
        catch <span class="delimiter">{</span>
          case <a title="org.parboiled2.Parser.CollectingRuleStackException" id="org.parboiled2;Parser.__matchStringWrapped.e">e</a>: Parser.<a href="#org.parboiled2.Parser;CollectingRuleStackException" title="org.parboiled2.Parser.CollectingRuleStackException">CollectingRuleStackException</a> ⇒
            <a href="#org.parboiled2;Parser.__matchStringWrapped.e" title="org.parboiled2.Parser.CollectingRuleStackException">e</a>.<a href="#org.parboiled2.Parser;CollectingRuleStackException.save" title="(newFrames: org.parboiled2.RuleFrame*)Nothing">save</a><span class="delimiter">(</span><a href="ParseError.scala.html#org.parboiled2.RuleFrame.apply" title="(frame: org.parboiled2.RuleFrame.Anonymous, name: String)org.parboiled2.RuleFrame">RuleFrame</a><span class="delimiter">(</span><a href="ParseError.scala.html#org.parboiled2.RuleFrame" title="org.parboiled2.RuleFrame.type">RuleFrame</a>.<a href="ParseError.scala.html#org.parboiled2.RuleFrame;StringMatch" title="(string: String)org.parboiled2.RuleFrame.StringMatch">StringMatch</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchStringWrapped.string" title="String">string</a><span class="delimiter">)</span>, <a href="#org.parboiled2;Parser.__matchStringWrapped.ruleName" title="String">ruleName</a><span class="delimiter">)</span>, <a href="ParseError.scala.html#org.parboiled2.RuleFrame" title="org.parboiled2.RuleFrame.type">RuleFrame</a>.<a href="ParseError.scala.html#org.parboiled2.RuleFrame;CharMatch" title="(char: Char)org.parboiled2.RuleFrame.CharMatch">CharMatch</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchStringWrapped.string" title="String">string</a> <span title="(x$1: Int)Char">charAt</span> <a href="#org.parboiled2;Parser.__matchStringWrapped$default$3" title="Int">ix</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    else true

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  @tailrec final def <a title="(string: String, ix: Int)Boolean" id="org.parboiled2;Parser.__matchIgnoreCaseString">__matchIgnoreCaseString</a><span class="delimiter">(</span><a title="String" id="org.parboiled2;Parser.__matchIgnoreCaseString.string">string</a>: <span title="String">String</span>, <a title="Int" id="org.parboiled2;Parser.__matchIgnoreCaseString$default$2">ix</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchIgnoreCaseString$default$2" title="Int">ix</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#org.parboiled2;Parser.__matchIgnoreCaseString.string" title="String">string</a>.<span title="()Int">length</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span><span title="Character.type">Character</span>.<span title="(x$1: Char)Char">toLowerCase</span><span class="delimiter">(</span><a href="#org.parboiled2;Parser.cursorChar" title="=&gt; Char">cursorChar</a><span class="delimiter">)</span> <span title="(x: Char)Boolean">==</span> <a href="#org.parboiled2;Parser.__matchIgnoreCaseString.string" title="String">string</a>.<span title="(x$1: Int)Char">charAt</span><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchIgnoreCaseString$default$2" title="Int">ix</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#org.parboiled2;Parser.__advance" title="()Boolean">__advance</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#org.parboiled2;Parser.__matchIgnoreCaseString" title="(string: String, ix: Int)Boolean">__matchIgnoreCaseString</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchIgnoreCaseString.string" title="String">string</a>, <a href="#org.parboiled2;Parser.__matchIgnoreCaseString$default$2" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else false
    else true

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  @tailrec final def <a title="(string: String, ruleName: String, ix: Int)Boolean" id="org.parboiled2;Parser.__matchIgnoreCaseStringWrapped">__matchIgnoreCaseStringWrapped</a><span class="delimiter">(</span><a title="String" id="org.parboiled2;Parser.__matchIgnoreCaseStringWrapped.string">string</a>: <span title="String">String</span>, <a title="String" id="org.parboiled2;Parser.__matchIgnoreCaseStringWrapped.ruleName">ruleName</a>: <span title="String">String</span>, <a title="Int" id="org.parboiled2;Parser.__matchIgnoreCaseStringWrapped$default$3">ix</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchIgnoreCaseStringWrapped$default$3" title="Int">ix</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#org.parboiled2;Parser.__matchIgnoreCaseStringWrapped.string" title="String">string</a>.<span title="()Int">length</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span><span title="Character.type">Character</span>.<span title="(x$1: Char)Char">toLowerCase</span><span class="delimiter">(</span><a href="#org.parboiled2;Parser.cursorChar" title="=&gt; Char">cursorChar</a><span class="delimiter">)</span> <span title="(x: Char)Boolean">==</span> <a href="#org.parboiled2;Parser.__matchIgnoreCaseStringWrapped.string" title="String">string</a>.<span title="(x$1: Int)Char">charAt</span><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchIgnoreCaseStringWrapped$default$3" title="Int">ix</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#org.parboiled2;Parser.__advance" title="()Boolean">__advance</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#org.parboiled2;Parser.__updateMaxCursor" title="()Boolean">__updateMaxCursor</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#org.parboiled2;Parser.__matchIgnoreCaseStringWrapped" title="(string: String, ruleName: String, ix: Int)Boolean">__matchIgnoreCaseStringWrapped</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchIgnoreCaseStringWrapped.string" title="String">string</a>, <a href="#org.parboiled2;Parser.__matchIgnoreCaseStringWrapped.ruleName" title="String">ruleName</a>, <a href="#org.parboiled2;Parser.__matchIgnoreCaseStringWrapped$default$3" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        try <a href="#org.parboiled2;Parser.__registerMismatch" title="()Boolean">__registerMismatch</a><span class="delimiter">(</span><span class="delimiter">)</span>
        catch <span class="delimiter">{</span>
          case <a title="org.parboiled2.Parser.CollectingRuleStackException" id="org.parboiled2;Parser.__matchIgnoreCaseStringWrapped.e">e</a>: Parser.<a href="#org.parboiled2.Parser;CollectingRuleStackException" title="org.parboiled2.Parser.CollectingRuleStackException">CollectingRuleStackException</a> ⇒
            <a href="#org.parboiled2;Parser.__matchIgnoreCaseStringWrapped.e" title="org.parboiled2.Parser.CollectingRuleStackException">e</a>.<a href="#org.parboiled2.Parser;CollectingRuleStackException.save" title="(newFrames: org.parboiled2.RuleFrame*)Nothing">save</a><span class="delimiter">(</span><a href="ParseError.scala.html#org.parboiled2.RuleFrame.apply" title="(frame: org.parboiled2.RuleFrame.Anonymous, name: String)org.parboiled2.RuleFrame">RuleFrame</a><span class="delimiter">(</span><a href="ParseError.scala.html#org.parboiled2.RuleFrame" title="org.parboiled2.RuleFrame.type">RuleFrame</a>.<a href="ParseError.scala.html#org.parboiled2.RuleFrame;IgnoreCaseString" title="(string: String)org.parboiled2.RuleFrame.IgnoreCaseString">IgnoreCaseString</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchIgnoreCaseStringWrapped.string" title="String">string</a><span class="delimiter">)</span>, <a href="#org.parboiled2;Parser.__matchIgnoreCaseStringWrapped.ruleName" title="String">ruleName</a><span class="delimiter">)</span>, <a href="ParseError.scala.html#org.parboiled2.RuleFrame" title="org.parboiled2.RuleFrame.type">RuleFrame</a>.<a href="ParseError.scala.html#org.parboiled2.RuleFrame;IgnoreCaseChar" title="(char: Char)org.parboiled2.RuleFrame.IgnoreCaseChar">IgnoreCaseChar</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchIgnoreCaseStringWrapped.string" title="String">string</a> <span title="(x$1: Int)Char">charAt</span> <a href="#org.parboiled2;Parser.__matchIgnoreCaseStringWrapped$default$3" title="Int">ix</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    else true

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  @tailrec final def <a title="(string: String, ix: Int)Boolean" id="org.parboiled2;Parser.__matchAnyOf">__matchAnyOf</a><span class="delimiter">(</span><a title="String" id="org.parboiled2;Parser.__matchAnyOf.string">string</a>: <span title="String">String</span>, <a title="Int" id="org.parboiled2;Parser.__matchAnyOf$default$2">ix</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchAnyOf$default$2" title="Int">ix</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#org.parboiled2;Parser.__matchAnyOf.string" title="String">string</a>.<span title="()Int">length</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchAnyOf.string" title="String">string</a>.<span title="(x$1: Int)Char">charAt</span><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchAnyOf$default$2" title="Int">ix</a><span class="delimiter">)</span> <span title="(x: Char)Boolean">==</span> <a href="#org.parboiled2;Parser.cursorChar" title="=&gt; Char">cursorChar</a><span class="delimiter">)</span> <a href="#org.parboiled2;Parser.__advance" title="()Boolean">__advance</a><span class="delimiter">(</span><span class="delimiter">)</span>
      else <a href="#org.parboiled2;Parser.__matchAnyOf" title="(string: String, ix: Int)Boolean">__matchAnyOf</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchAnyOf.string" title="String">string</a>, <a href="#org.parboiled2;Parser.__matchAnyOf$default$2" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    else false

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  @tailrec final def <a title="(string: String, ix: Int)Boolean" id="org.parboiled2;Parser.__matchNoneOf">__matchNoneOf</a><span class="delimiter">(</span><a title="String" id="org.parboiled2;Parser.__matchNoneOf.string">string</a>: <span title="String">String</span>, <a title="Int" id="org.parboiled2;Parser.__matchNoneOf$default$2">ix</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchNoneOf$default$2" title="Int">ix</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#org.parboiled2;Parser.__matchNoneOf.string" title="String">string</a>.<span title="()Int">length</span><span class="delimiter">)</span>
      <a href="#org.parboiled2;Parser.cursorChar" title="=&gt; Char">cursorChar</a> <span title="(x: Char)Boolean">!=</span> <a href="RuleDSLBasics.scala.html#org.parboiled2;RuleDSLBasics.EOI" title="=&gt; Char">EOI</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#org.parboiled2;Parser.__matchNoneOf.string" title="String">string</a>.<span title="(x$1: Int)Char">charAt</span><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchNoneOf$default$2" title="Int">ix</a><span class="delimiter">)</span> <span title="(x: Char)Boolean">!=</span> <a href="#org.parboiled2;Parser.cursorChar" title="=&gt; Char">cursorChar</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#org.parboiled2;Parser.__matchNoneOf" title="(string: String, ix: Int)Boolean">__matchNoneOf</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchNoneOf.string" title="String">string</a>, <a href="#org.parboiled2;Parser.__matchNoneOf$default$2" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    else <a href="#org.parboiled2;Parser.__advance" title="()Boolean">__advance</a><span class="delimiter">(</span><span class="delimiter">)</span>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  def <a title="(m: Map[String,Any])Boolean" id="org.parboiled2;Parser.__matchMap">__matchMap</a><span class="delimiter">(</span><a title="Map[String,Any]" id="org.parboiled2;Parser.__matchMap.m">m</a>: <span title="Map[String,Any]">Map</span><span class="delimiter">[</span>String, Any<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    val <a title="Iterator[String]" id="org.parboiled2;Parser.__matchMap.keys">keys</a> = <a href="#org.parboiled2;Parser.__matchMap.m" title="Map[String,Any]">m</a>.<span title="=&gt; Iterator[String]">keysIterator</span>
    while <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchMap.keys" title="Iterator[String]">keys</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <a href="#org.parboiled2;Parser.__matchMap.while$1" title="()Unit" class="delimiter">{</a>
      val <a title="org.parboiled2.Parser.Mark" id="org.parboiled2;Parser.__matchMap.mark">mark</a> = <a href="#org.parboiled2;Parser.__saveState" title="=&gt; org.parboiled2.Parser.Mark">__saveState</a>
      val <a title="String" id="org.parboiled2;Parser.__matchMap.key">key</a> = <a href="#org.parboiled2;Parser.__matchMap.keys" title="Iterator[String]">keys</a>.<span title="()String">next</span><span class="delimiter">(</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchString" title="(string: String, ix: Int)Boolean">__matchString</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchMap.key" title="String">key</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#org.parboiled2;Parser.__push" title="(value: Any)Boolean">__push</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchMap.m" title="(key: String)Any">m</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchMap.key" title="String">key</a><span class="delimiter">)</span><span class="delimiter">)</span>
        return true
      <span class="delimiter">}</span> else <a href="#org.parboiled2;Parser.__restoreState" title="(mark: org.parboiled2.Parser.Mark)Unit">__restoreState</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchMap.mark" title="org.parboiled2.Parser.Mark">mark</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    false
  <span class="delimiter">}</span>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  def <a title="(m: Map[String,Any], ruleName: String)Boolean" id="org.parboiled2;Parser.__matchMapWrapped">__matchMapWrapped</a><span class="delimiter">(</span><a title="Map[String,Any]" id="org.parboiled2;Parser.__matchMapWrapped.m">m</a>: <span title="Map[String,Any]">Map</span><span class="delimiter">[</span>String, Any<span class="delimiter">]</span>, <a title="String" id="org.parboiled2;Parser.__matchMapWrapped.ruleName">ruleName</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    val <a title="Iterator[String]" id="org.parboiled2;Parser.__matchMapWrapped.keys">keys</a> = <a href="#org.parboiled2;Parser.__matchMapWrapped.m" title="Map[String,Any]">m</a>.<span title="=&gt; Iterator[String]">keysIterator</span>
    try <span class="delimiter">{</span>
      while <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchMapWrapped.keys" title="Iterator[String]">keys</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <a href="#org.parboiled2;Parser.__matchMapWrapped.while$2" title="()Unit" class="delimiter">{</a>
        val <a title="org.parboiled2.Parser.Mark" id="org.parboiled2;Parser.__matchMapWrapped.mark">mark</a> = <a href="#org.parboiled2;Parser.__saveState" title="=&gt; org.parboiled2.Parser.Mark">__saveState</a>
        val <a title="String" id="org.parboiled2;Parser.__matchMapWrapped.key">key</a> = <a href="#org.parboiled2;Parser.__matchMapWrapped.keys" title="Iterator[String]">keys</a>.<span title="()String">next</span><span class="delimiter">(</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchStringWrapped" title="(string: String, ruleName: String, ix: Int)Boolean">__matchStringWrapped</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchMapWrapped.key" title="String">key</a>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#org.parboiled2;Parser.__push" title="(value: Any)Boolean">__push</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchMapWrapped.m" title="(key: String)Any">m</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchMapWrapped.key" title="String">key</a><span class="delimiter">)</span><span class="delimiter">)</span>
          return true
        <span class="delimiter">}</span> else <a href="#org.parboiled2;Parser.__restoreState" title="(mark: org.parboiled2.Parser.Mark)Unit">__restoreState</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchMapWrapped.mark" title="org.parboiled2.Parser.Mark">mark</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      false
    <span class="delimiter">}</span> catch <span class="delimiter">{</span>
      case <a title="org.parboiled2.Parser.CollectingRuleStackException" id="org.parboiled2;Parser.__matchMapWrapped.e">e</a>: Parser.<a href="#org.parboiled2.Parser;CollectingRuleStackException" title="org.parboiled2.Parser.CollectingRuleStackException">CollectingRuleStackException</a> ⇒ <a href="#org.parboiled2;Parser.__matchMapWrapped.e" title="org.parboiled2.Parser.CollectingRuleStackException">e</a>.<a href="#org.parboiled2.Parser;CollectingRuleStackException.save" title="(newFrames: org.parboiled2.RuleFrame*)Nothing">save</a><span class="delimiter">(</span><a href="ParseError.scala.html#org.parboiled2.RuleFrame.apply" title="(frame: org.parboiled2.RuleFrame.Anonymous, name: String)org.parboiled2.RuleFrame">RuleFrame</a><span class="delimiter">(</span><a href="ParseError.scala.html#org.parboiled2.RuleFrame" title="org.parboiled2.RuleFrame.type">RuleFrame</a>.<a href="ParseError.scala.html#org.parboiled2.RuleFrame;MapMatch" title="(map: Map[String,Any])org.parboiled2.RuleFrame.MapMatch">MapMatch</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser.__matchMapWrapped.m" title="Map[String,Any]">m</a><span class="delimiter">)</span>, <a href="#org.parboiled2;Parser.__matchMapWrapped.ruleName" title="String">ruleName</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  protected class <a title="class __SubParserInput extends AnyRef with org.parboiled2.ParserInput" id="org.parboiled2;Parser;__SubParserInput">__SubParserInput</a> extends <a href="ParserInput.scala.html#org.parboiled2;ParserInput" title="org.parboiled2.ParserInput">ParserInput</a> <span class="delimiter">{</span>
    val <a title="Int" id="org.parboiled2;Parser;__SubParserInput.offset">offset</a> = <a href="#org.parboiled2;Parser.cursor" title="=&gt; Int">cursor</a> <span class="comment">// the number of chars the input the sub-parser sees is offset from the outer input start</span>
    def <a title="(line: Int)String" id="org.parboiled2;Parser;__SubParserInput.getLine">getLine</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;Parser;__SubParserInput.getLine.line">line</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="String">String</span> = <span title="=&gt; Nothing">???</span> <span class="comment">// TODO</span>
    def <a title="(start: Int, end: Int)Array[Char]" id="org.parboiled2;Parser;__SubParserInput.sliceCharArray">sliceCharArray</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;Parser;__SubParserInput.sliceCharArray.start">start</a>: <span title="Int">Int</span>, <a title="Int" id="org.parboiled2;Parser;__SubParserInput.sliceCharArray.end">end</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Array[Char]">Array</span><span class="delimiter">[</span>Char<span class="delimiter">]</span> = <a href="#org.parboiled2;Parser.input" title="=&gt; org.parboiled2.ParserInput">input</a>.<a href="ParserInput.scala.html#org.parboiled2;ParserInput.sliceCharArray" title="(start: Int, end: Int)Array[Char]">sliceCharArray</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser;__SubParserInput.sliceCharArray.start" title="Int">start</a> <span title="(x: Int)Int">+</span> <a href="#org.parboiled2;Parser;__SubParserInput.offset" title="=&gt; Int">offset</a>, <a href="#org.parboiled2;Parser;__SubParserInput.sliceCharArray.end" title="Int">end</a> <span title="(x: Int)Int">+</span> <a href="#org.parboiled2;Parser;__SubParserInput.offset" title="=&gt; Int">offset</a><span class="delimiter">)</span>
    def <a title="(start: Int, end: Int)String" id="org.parboiled2;Parser;__SubParserInput.sliceString">sliceString</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;Parser;__SubParserInput.sliceString.start">start</a>: <span title="Int">Int</span>, <a title="Int" id="org.parboiled2;Parser;__SubParserInput.sliceString.end">end</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="String">String</span> = <a href="#org.parboiled2;Parser.input" title="=&gt; org.parboiled2.ParserInput">input</a>.<a href="ParserInput.scala.html#org.parboiled2;ParserInput.sliceString" title="(start: Int, end: Int)String">sliceString</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser;__SubParserInput.sliceString.start" title="Int">start</a> <span title="(x: Int)Int">+</span> <a href="#org.parboiled2;Parser;__SubParserInput.offset" title="=&gt; Int">offset</a>, <a href="#org.parboiled2;Parser;__SubParserInput.sliceString.end" title="Int">end</a> <span title="(x: Int)Int">+</span> <a href="#org.parboiled2;Parser;__SubParserInput.offset" title="=&gt; Int">offset</a><span class="delimiter">)</span>
    def <a title="=&gt; Int" id="org.parboiled2;Parser;__SubParserInput.length">length</a>: <span title="Int">Int</span> = <a href="#org.parboiled2;Parser.input" title="=&gt; org.parboiled2.ParserInput">input</a>.<a href="ParserInput.scala.html#org.parboiled2;ParserInput.length" title="=&gt; Int">length</a> <span title="(x: Int)Int">-</span> <a href="#org.parboiled2;Parser;__SubParserInput.offset" title="=&gt; Int">offset</a>
    def <a title="(ix: Int)Char" id="org.parboiled2;Parser;__SubParserInput.charAt">charAt</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;Parser;__SubParserInput.charAt.ix">ix</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Char">Char</span> = <a href="#org.parboiled2;Parser.input" title="=&gt; org.parboiled2.ParserInput">input</a>.<a href="ParserInput.scala.html#org.parboiled2;ParserInput.charAt" title="(ix: Int)Char">charAt</a><span class="delimiter">(</span><a href="#org.parboiled2;Parser;__SubParserInput.offset" title="=&gt; Int">offset</a> <span title="(x: Int)Int">+</span> <a href="#org.parboiled2;Parser;__SubParserInput.charAt.ix" title="Int">ix</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

object <a title="org.parboiled2.Parser.type" id="org.parboiled2.Parser">Parser</a> <a href="#org.parboiled2.Parser" title="org.parboiled2.Parser.type" class="delimiter">{</a>

  trait <a title="trait DeliveryScheme[L &lt;: shapeless.HList] extends AnyRef" id="org.parboiled2.Parser;DeliveryScheme">DeliveryScheme</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.Parser;DeliveryScheme;L">L</a> &lt;: HList<span class="delimiter">]</span> <span class="delimiter">{</span>
    type <a title="" id="org.parboiled2.Parser;DeliveryScheme;Result">Result</a>
    def <a title="(result: L)DeliveryScheme.this.Result" id="org.parboiled2.Parser;DeliveryScheme.success">success</a><span class="delimiter">(</span><a title="L" id="org.parboiled2.Parser;DeliveryScheme.success.result">result</a>: <a href="#org.parboiled2.Parser;DeliveryScheme;L" title="L">L</a><span class="delimiter">)</span>: <a href="#org.parboiled2.Parser;DeliveryScheme;Result" title="DeliveryScheme.this.Result">Result</a>
    def <a title="(error: org.parboiled2.ParseError)DeliveryScheme.this.Result" id="org.parboiled2.Parser;DeliveryScheme.parseError">parseError</a><span class="delimiter">(</span><a title="org.parboiled2.ParseError" id="org.parboiled2.Parser;DeliveryScheme.parseError.error">error</a>: <a href="ParseError.scala.html#org.parboiled2;ParseError" title="org.parboiled2.ParseError">ParseError</a><span class="delimiter">)</span>: <a href="#org.parboiled2.Parser;DeliveryScheme;Result" title="DeliveryScheme.this.Result">Result</a>
    def <a title="(error: Throwable)DeliveryScheme.this.Result" id="org.parboiled2.Parser;DeliveryScheme.failure">failure</a><span class="delimiter">(</span><a title="Throwable" id="org.parboiled2.Parser;DeliveryScheme.failure.error">error</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span>: <a href="#org.parboiled2.Parser;DeliveryScheme;Result" title="DeliveryScheme.this.Result">Result</a>
  <span class="delimiter">}</span>

  object <a title="org.parboiled2.Parser.DeliveryScheme.type" id="org.parboiled2.Parser.DeliveryScheme">DeliveryScheme</a> extends <a href="#org.parboiled2.Parser;AlternativeDeliverySchemes" title="org.parboiled2.Parser.AlternativeDeliverySchemes">AlternativeDeliverySchemes</a> <span class="delimiter">{</span>
    implicit def <a title="[L &lt;: shapeless.HList, Out](implicit unpack: org.parboiled2.support.Unpack.Aux[L,Out])org.parboiled2.Parser.DeliveryScheme[L]{type Result = scala.util.Try[Out]; def success(result: L): scala.util.Success[Out]; def parseError(error: org.parboiled2.ParseError): scala.util.Failure[Nothing]; def failure(error: Throwable): scala.util.Failure[Nothing]}" id="org.parboiled2.Parser.DeliveryScheme.Try">Try</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.Parser.DeliveryScheme.Try;L">L</a> &lt;: HList, <a title="" id="org.parboiled2.Parser.DeliveryScheme.Try;Out">Out</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Unpack.Aux[L,Out]" id="org.parboiled2.Parser.DeliveryScheme.Try.unpack">unpack</a>: Unpack.<a href="support/Unpack.scala.html#org.parboiled2.support.Unpack;Aux" title="org.parboiled2.support.Unpack.Aux[L,Out]">Aux</a><span class="delimiter">[</span>L, Out<span class="delimiter">]</span><span class="delimiter">)</span> =
      new <a title="&lt;$anon: org.parboiled2.Parser.DeliveryScheme[L]&gt; extends AnyRef with org.parboiled2.Parser.DeliveryScheme[L]" id="org.parboiled2.Parser.DeliveryScheme.Try;$anon">DeliveryScheme</a><span class="delimiter">[</span>L<span class="delimiter">]</span> <span class="delimiter">{</span>
        type <a title="scala.util.Try[Out]" id="org.parboiled2.Parser.DeliveryScheme.Try;$anon;Result">Result</a> = <span title="scala.util.Try[Out]">Try</span><span class="delimiter">[</span>Out<span class="delimiter">]</span>
        def <a title="(result: L)scala.util.Success[Out]" id="org.parboiled2.Parser.DeliveryScheme.Try;$anon.success">success</a><span class="delimiter">(</span><a title="L" id="org.parboiled2.Parser.DeliveryScheme.Try;$anon.success.result">result</a>: <a href="#org.parboiled2.Parser.DeliveryScheme.Try;L" title="L">L</a><span class="delimiter">)</span> = <span title="(value: Out)scala.util.Success[Out]">Success</span><span class="delimiter">(</span><a href="support/Unpack.scala.html#org.parboiled2.support.Unpack;Aux.apply" title="(hlist: L)Out">unpack</a><span class="delimiter">(</span><a href="#org.parboiled2.Parser.DeliveryScheme.Try;$anon.success.result" title="L">result</a><span class="delimiter">)</span><span class="delimiter">)</span>
        def <a title="(error: org.parboiled2.ParseError)scala.util.Failure[Nothing]" id="org.parboiled2.Parser.DeliveryScheme.Try;$anon.parseError">parseError</a><span class="delimiter">(</span><a title="org.parboiled2.ParseError" id="org.parboiled2.Parser.DeliveryScheme.Try;$anon.parseError.error">error</a>: <a href="ParseError.scala.html#org.parboiled2;ParseError" title="org.parboiled2.ParseError">ParseError</a><span class="delimiter">)</span> = <span title="(exception: Throwable)scala.util.Failure[Nothing]">Failure</span><span class="delimiter">(</span><a href="#org.parboiled2.Parser.DeliveryScheme.Try;$anon.parseError.error" title="org.parboiled2.ParseError">error</a><span class="delimiter">)</span>
        def <a title="(error: Throwable)scala.util.Failure[Nothing]" id="org.parboiled2.Parser.DeliveryScheme.Try;$anon.failure">failure</a><span class="delimiter">(</span><a title="Throwable" id="org.parboiled2.Parser.DeliveryScheme.Try;$anon.failure.error">error</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span> = <span title="(exception: Throwable)scala.util.Failure[Nothing]">Failure</span><span class="delimiter">(</span><a href="#org.parboiled2.Parser.DeliveryScheme.Try;$anon.failure.error" title="Throwable">error</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  sealed abstract class <a title="class AlternativeDeliverySchemes extends AnyRef" id="org.parboiled2.Parser;AlternativeDeliverySchemes">AlternativeDeliverySchemes</a> <a href="#org.parboiled2.Parser;AlternativeDeliverySchemes" title="org.parboiled2.Parser.AlternativeDeliverySchemes" class="delimiter">{</a>
    implicit def <a title="[L &lt;: shapeless.HList, Out](implicit unpack: org.parboiled2.support.Unpack.Aux[L,Out])org.parboiled2.Parser.DeliveryScheme[L]{type Result = Either[org.parboiled2.ParseError,Out]; def success(result: L): scala.util.Right[Nothing,Out]; def parseError(error: org.parboiled2.ParseError): scala.util.Left[org.parboiled2.ParseError,Nothing]; def failure(error: Throwable): Nothing}" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Either">Either</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Either;L">L</a> &lt;: HList, <a title="" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Either;Out">Out</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Unpack.Aux[L,Out]" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Either.unpack">unpack</a>: Unpack.<a href="support/Unpack.scala.html#org.parboiled2.support.Unpack;Aux" title="org.parboiled2.support.Unpack.Aux[L,Out]">Aux</a><span class="delimiter">[</span>L, Out<span class="delimiter">]</span><span class="delimiter">)</span> =
      new <a title="&lt;$anon: org.parboiled2.Parser.DeliveryScheme[L]&gt; extends AnyRef with org.parboiled2.Parser.DeliveryScheme[L]" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Either;$anon">DeliveryScheme</a><span class="delimiter">[</span>L<span class="delimiter">]</span> <span class="delimiter">{</span>
        type <a title="Either[org.parboiled2.ParseError,Out]" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Either;$anon;Result">Result</a> = <span title="Either[org.parboiled2.ParseError,Out]">Either</span><span class="delimiter">[</span>ParseError, Out<span class="delimiter">]</span>
        def <a title="(result: L)scala.util.Right[Nothing,Out]" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Either;$anon.success">success</a><span class="delimiter">(</span><a title="L" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Either;$anon.success.result">result</a>: <a href="#org.parboiled2.Parser;AlternativeDeliverySchemes.Either;L" title="L">L</a><span class="delimiter">)</span> = <span title="(b: Out)scala.util.Right[Nothing,Out]">Right</span><span class="delimiter">(</span><a href="support/Unpack.scala.html#org.parboiled2.support.Unpack;Aux.apply" title="(hlist: L)Out">unpack</a><span class="delimiter">(</span><a href="#org.parboiled2.Parser;AlternativeDeliverySchemes.Either;$anon.success.result" title="L">result</a><span class="delimiter">)</span><span class="delimiter">)</span>
        def <a title="(error: org.parboiled2.ParseError)scala.util.Left[org.parboiled2.ParseError,Nothing]" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Either;$anon.parseError">parseError</a><span class="delimiter">(</span><a title="org.parboiled2.ParseError" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Either;$anon.parseError.error">error</a>: <a href="ParseError.scala.html#org.parboiled2;ParseError" title="org.parboiled2.ParseError">ParseError</a><span class="delimiter">)</span> = <span title="(a: org.parboiled2.ParseError)scala.util.Left[org.parboiled2.ParseError,Nothing]">Left</span><span class="delimiter">(</span><a href="#org.parboiled2.Parser;AlternativeDeliverySchemes.Either;$anon.parseError.error" title="org.parboiled2.ParseError">error</a><span class="delimiter">)</span>
        def <a title="(error: Throwable)Nothing" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Either;$anon.failure">failure</a><span class="delimiter">(</span><a title="Throwable" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Either;$anon.failure.error">error</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span> = throw <a href="#org.parboiled2.Parser;AlternativeDeliverySchemes.Either;$anon.failure.error" title="Throwable">error</a>
      <span class="delimiter">}</span>
    implicit def <a title="[L &lt;: shapeless.HList, Out](implicit unpack: org.parboiled2.support.Unpack.Aux[L,Out])org.parboiled2.Parser.DeliveryScheme[L]{type Result = Out; def parseError(error: org.parboiled2.ParseError): Nothing; def failure(error: Throwable): Nothing}" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Throw">Throw</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;L">L</a> &lt;: HList, <a title="" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;Out">Out</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Unpack.Aux[L,Out]" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Throw.unpack">unpack</a>: Unpack.<a href="support/Unpack.scala.html#org.parboiled2.support.Unpack;Aux" title="org.parboiled2.support.Unpack.Aux[L,Out]">Aux</a><span class="delimiter">[</span>L, Out<span class="delimiter">]</span><span class="delimiter">)</span> =
      new <a title="&lt;$anon: org.parboiled2.Parser.DeliveryScheme[L]&gt; extends AnyRef with org.parboiled2.Parser.DeliveryScheme[L]" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;$anon">DeliveryScheme</a><span class="delimiter">[</span>L<span class="delimiter">]</span> <span class="delimiter">{</span>
        type <a title="Out" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;$anon;Result">Result</a> = <a href="#org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;Out" title="Out">Out</a>
        def <a title="(result: L)Out" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;$anon.success">success</a><span class="delimiter">(</span><a title="L" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;$anon.success.result">result</a>: <a href="#org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;L" title="L">L</a><span class="delimiter">)</span> = <a href="support/Unpack.scala.html#org.parboiled2.support.Unpack;Aux.apply" title="(hlist: L)Out">unpack</a><span class="delimiter">(</span><a href="#org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;$anon.success.result" title="L">result</a><span class="delimiter">)</span>
        def <a title="(error: org.parboiled2.ParseError)Nothing" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;$anon.parseError">parseError</a><span class="delimiter">(</span><a title="org.parboiled2.ParseError" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;$anon.parseError.error">error</a>: <a href="ParseError.scala.html#org.parboiled2;ParseError" title="org.parboiled2.ParseError">ParseError</a><span class="delimiter">)</span> = throw <a href="#org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;$anon.parseError.error" title="org.parboiled2.ParseError">error</a>
        def <a title="(error: Throwable)Nothing" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;$anon.failure">failure</a><span class="delimiter">(</span><a title="Throwable" id="org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;$anon.failure.error">error</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span> = throw <a href="#org.parboiled2.Parser;AlternativeDeliverySchemes.Throw;$anon.failure.error" title="Throwable">error</a>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  class <a href="#org.parboiled2.Parser;Mark.value" title="class Mark extends AnyVal" id="org.parboiled2.Parser.Mark">Mark</a> private<span class="delimiter">[</span>Parser<span class="delimiter">]</span> <span class="delimiter">(</span>val <a title="Long" id="org.parboiled2.Parser;Mark.value">value</a>: <span title="Long">Long</span><span class="delimiter">)</span> extends <a href="#org.parboiled2.Parser.Mark" title="AnyVal">AnyVal</a>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  class <a title="class CollectingRuleStackException extends RuntimeException with scala.util.control.NoStackTrace" id="org.parboiled2.Parser;CollectingRuleStackException">CollectingRuleStackException</a> extends <a href="#org.parboiled2.Parser;CollectingRuleStackException" title="RuntimeException">RuntimeException</a> with <span title="scala.util.control.NoStackTrace">NoStackTrace</span> <span class="delimiter">{</span>
    private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="List[org.parboiled2.RuleFrame]" id="org.parboiled2.Parser;CollectingRuleStackException.frames">frames</a> = <span title="scala.collection.immutable.List.type">List</span>.<span title="[A]=&gt; List[A]">empty</span><span title="List[org.parboiled2.RuleFrame]" class="delimiter">[</span><a href="ParseError.scala.html#org.parboiled2;RuleFrame" title="org.parboiled2.RuleFrame">RuleFrame</a><span class="delimiter">]</span>
    def <a title="(newFrames: org.parboiled2.RuleFrame*)Nothing" id="org.parboiled2.Parser;CollectingRuleStackException.save">save</a><span class="delimiter">(</span><a title="org.parboiled2.RuleFrame*" id="org.parboiled2.Parser;CollectingRuleStackException.save.newFrames">newFrames</a>: <span title="org.parboiled2.RuleFrame*">RuleFrame</span>*<span class="delimiter">)</span>: <span title="Nothing">Nothing</span> = <span class="delimiter">{</span>
      <a href="#org.parboiled2.Parser;CollectingRuleStackException.frames" title="List[org.parboiled2.RuleFrame]">frames</a> = <a href="#org.parboiled2.Parser;CollectingRuleStackException.save.newFrames" title="org.parboiled2.RuleFrame*">newFrames</a>.<span title="(z: List[org.parboiled2.RuleFrame])(op: (org.parboiled2.RuleFrame, List[org.parboiled2.RuleFrame]) =&gt; List[org.parboiled2.RuleFrame])List[org.parboiled2.RuleFrame]">foldRight</span><span class="delimiter">(</span><a href="#org.parboiled2.Parser;CollectingRuleStackException.frames" title="List[org.parboiled2.RuleFrame]">frames</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#org.parboiled2.Parser;CollectingRuleStackException.save.$anonfun.x$1" title="org.parboiled2.RuleFrame">_</a> <a href="#org.parboiled2.Parser;CollectingRuleStackException.save.$anonfun.x$3" title="(x: org.parboiled2.RuleFrame)List[org.parboiled2.RuleFrame]">::</a> <a href="#org.parboiled2.Parser;CollectingRuleStackException.save.$anonfun.x$2" title="List[org.parboiled2.RuleFrame]">_</a><span class="delimiter">)</span>
      throw this
    <span class="delimiter">}</span>
    def <a title="=&gt; List[org.parboiled2.RuleFrame]" id="org.parboiled2.Parser;CollectingRuleStackException.ruleFrames">ruleFrames</a>: <span title="List[org.parboiled2.RuleFrame]">List</span><span class="delimiter">[</span>RuleFrame<span class="delimiter">]</span> = <a href="#org.parboiled2.Parser;CollectingRuleStackException.frames" title="List[org.parboiled2.RuleFrame]">frames</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

object <a title="org.parboiled2.ParserMacros.type" id="org.parboiled2.ParserMacros">ParserMacros</a> <a href="#org.parboiled2.ParserMacros" title="org.parboiled2.ParserMacros.type" class="delimiter">{</a>
  import scala.reflect.macros.whitebox.Context

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  type <a title="&lt;refinement of scala.reflect.macros.whitebox.Context&gt;[L &lt;: shapeless.HList] extends scala.reflect.macros.whitebox.Context" id="org.parboiled2.ParserMacros;RunnableRuleContext">RunnableRuleContext</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.ParserMacros;RunnableRuleContext;L">L</a> &lt;: HList<span class="delimiter">]</span> = <a href="#org.parboiled2.ParserMacros;<refinement>" title="&lt;refinement of scala.reflect.macros.whitebox.Context&gt; extends scala.reflect.macros.whitebox.Context">Context</a> <span class="delimiter">{</span> type PrefixType = Rule.Runnable<span class="delimiter">[</span>L<span class="delimiter">]</span> <span class="delimiter">}</span>

  def <a title="[L &lt;: shapeless.HList](c: org.parboiled2.ParserMacros.RunnableRuleContext[L])()(scheme: c.Expr[org.parboiled2.Parser.DeliveryScheme[L]])(implicit evidence$1: c.WeakTypeTag[L])c.Expr[scheme.value.Result]" id="org.parboiled2.ParserMacros.runImpl">runImpl</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.ParserMacros.runImpl;L">L</a> &lt;: HList: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="org.parboiled2.ParserMacros.RunnableRuleContext[L]" id="org.parboiled2.ParserMacros.runImpl.c">c</a>: <a href="#org.parboiled2.ParserMacros;<refinement>" title="org.parboiled2.ParserMacros.RunnableRuleContext[L]">RunnableRuleContext</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[org.parboiled2.Parser.DeliveryScheme[L]]" id="org.parboiled2.ParserMacros.runImpl.scheme">scheme</a>: c.<span title="c.Expr[org.parboiled2.Parser.DeliveryScheme[L]]">Expr</span><span class="delimiter">[</span>Parser.DeliveryScheme<span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[scheme.value.Result]">Expr</span><span class="delimiter">[</span>scheme.value.Result<span class="delimiter">]</span> = <span class="delimiter">{</span>
    import <a href="#org.parboiled2.ParserMacros.runImpl.c" title="org.parboiled2.ParserMacros.RunnableRuleContext[L]">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
    val <a title="c.universe.Tree" id="org.parboiled2.ParserMacros.runImpl.runCall">runCall</a> = <a href="#org.parboiled2.ParserMacros.runImpl.c" title="org.parboiled2.ParserMacros.RunnableRuleContext[L]">c</a>.<span title="=&gt; c.Expr[c.PrefixType]">prefix</span>.<span title="=&gt; c.universe.Tree">tree</span> match <span class="delimiter">{</span>
      case <a title="(val tree: Any)Option[(c.universe.Tree, c.universe.Tree)]" id="org.parboiled2.ParserMacros.runImpl.runCall;$anon.unapply.qq$203dffef$macro$14">q</a>&quot;parboiled2.this.Rule.Runnable[$<a title="c.universe.Tree" id="org.parboiled2.ParserMacros.runImpl.runCall.l">l</a>]($<a title="c.universe.Tree" id="org.parboiled2.ParserMacros.runImpl.runCall.ruleExpr">ruleExpr</a><span class="string">)&quot;</span> ⇒ <a href="#org.parboiled2.ParserMacros.runImpl.runCall.ruleExpr" title="c.universe.Tree">ruleExpr</a> match <span class="delimiter">{</span>
        case <a title="(val tree: Any)Option[(c.universe.Tree, c.universe.TermName)]" id="org.parboiled2.ParserMacros.runImpl.runCall;$anon.unapply.qq$9a0bb486$macro$16">q</a>&quot;$<span title="c.universe.Tree">p</span>.$<span title="c.universe.TermName">r</span><span class="string">&quot;</span> if <span title="c.universe.Tree">p</span>.<span title="=&gt; c.universe.Type">tpe</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#org.parboiled2.ParserMacros.runImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#org.parboiled2.ParserMacros.runImpl.c" title="(implicit ttag: c.universe.TypeTag[org.parboiled2.Parser])c.universe.Type" id="org.parboiled2.ParserMacros.runImpl.runCall;$typecreator1.apply.$m" class="delimiter">[</a><a href="#org.parboiled2;Parser" title="org.parboiled2.Parser">Parser</a><span class="delimiter">]</span> ⇒ <a href="#org.parboiled2.ParserMacros.runImpl.c" title="(stats: List[c.universe.Tree])c.universe.Tree">q</a>&quot;val p = $<span title="c.universe.Tree">p</span>; p.__run[$<a href="#org.parboiled2.ParserMacros.runImpl.runCall.l" title="c.universe.Tree">l</a>](p.$<span title="c.universe.TermName">r</span>)($<a href="#org.parboiled2.ParserMacros.runImpl.scheme" title="c.Expr[org.parboiled2.Parser.DeliveryScheme[L]]">scheme</a><span class="string">)&quot;</span>
        case <a title="(val tree: Any)Option[(c.universe.Tree, c.universe.TermName, c.universe.Tree)]" id="org.parboiled2.ParserMacros.runImpl.runCall;$anon.unapply.qq$daf373e7$macro$23">q</a>&quot;$<span title="c.universe.Tree">p</span>.$<span title="c.universe.TermName">r</span>($<a title="c.universe.Tree" id="org.parboiled2.ParserMacros.runImpl.runCall.args">args</a><span class="string">)&quot;</span> if <span title="c.universe.Tree">p</span>.<span title="=&gt; c.universe.Type">tpe</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#org.parboiled2.ParserMacros.runImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#org.parboiled2.ParserMacros.runImpl.c" title="(implicit ttag: c.universe.TypeTag[org.parboiled2.Parser])c.universe.Type" id="org.parboiled2.ParserMacros.runImpl.runCall;$typecreator2.apply.$m" class="delimiter">[</a><a href="#org.parboiled2;Parser" title="org.parboiled2.Parser">Parser</a><span class="delimiter">]</span> ⇒ <a href="#org.parboiled2.ParserMacros.runImpl.c" title="(stats: List[c.universe.Tree])c.universe.Tree">q</a>&quot;val p = $<span title="c.universe.Tree">p</span>; p.__run[$<a href="#org.parboiled2.ParserMacros.runImpl.runCall.l" title="c.universe.Tree">l</a>](p.$<span title="c.universe.TermName">r</span>($<a href="#org.parboiled2.ParserMacros.runImpl.runCall.args" title="c.universe.Tree">args</a>))($<a href="#org.parboiled2.ParserMacros.runImpl.scheme" title="c.Expr[org.parboiled2.Parser.DeliveryScheme[L]]">scheme</a><span class="string">)&quot;</span>
        case <a title="(val tree: Any)Option[(c.universe.Tree, c.universe.TermName, c.universe.Tree)]" id="org.parboiled2.ParserMacros.runImpl.runCall;$anon.unapply.qq$abae8d08$macro$31">q</a>&quot;$<span title="c.universe.Tree">p</span>.$<span title="c.universe.TermName">r</span>[$<span title="c.universe.Tree">t</span><span class="string">]&quot;</span> if <span title="c.universe.Tree">p</span>.<span title="=&gt; c.universe.Type">tpe</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#org.parboiled2.ParserMacros.runImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#org.parboiled2.ParserMacros.runImpl.c" title="(implicit ttag: c.universe.TypeTag[org.parboiled2.Parser])c.universe.Type" id="org.parboiled2.ParserMacros.runImpl.runCall;$typecreator3.apply.$m" class="delimiter">[</a><a href="#org.parboiled2;Parser" title="org.parboiled2.Parser">Parser</a><span class="delimiter">]</span> ⇒ <a href="#org.parboiled2.ParserMacros.runImpl.c" title="(stats: List[c.universe.Tree])c.universe.Tree">q</a>&quot;val p = $<span title="c.universe.Tree">p</span>; p.__run[$<a href="#org.parboiled2.ParserMacros.runImpl.runCall.l" title="c.universe.Tree">l</a>](p.$<span title="c.universe.TermName">r</span>[$<span title="c.universe.Tree">t</span>])($<a href="#org.parboiled2.ParserMacros.runImpl.scheme" title="c.Expr[org.parboiled2.Parser.DeliveryScheme[L]]">scheme</a><span class="string">)&quot;</span>
        case <a title="(val tree: Any)Option[(c.universe.Tree, c.universe.TermName, c.universe.Tree)]" id="org.parboiled2.ParserMacros.runImpl.runCall;$anon.unapply.qq$81b58ad6$macro$39">q</a>&quot;$<span title="c.universe.Tree">p</span>.$<span title="c.universe.TermName">r</span>[$<span title="c.universe.Tree">t</span><span class="string">]&quot;</span> if <span title="c.universe.Tree">p</span>.<span title="=&gt; c.universe.Type">tpe</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#org.parboiled2.ParserMacros.runImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#org.parboiled2.ParserMacros.runImpl.c" title="(implicit ttag: c.universe.TypeTag[org.parboiled2.RuleX])c.universe.Type" id="org.parboiled2.ParserMacros.runImpl.runCall;$typecreator4.apply.$m" class="delimiter">[</a><a href="Rule.scala.html#org.parboiled2;RuleX" title="org.parboiled2.RuleX">RuleX</a><span class="delimiter">]</span> ⇒ <a href="#org.parboiled2.ParserMacros.runImpl.c" title="(tree: c.universe.Tree, argss: List[List[c.universe.Tree]])c.universe.Tree">q</a>&quot;__run[$<a href="#org.parboiled2.ParserMacros.runImpl.runCall.l" title="c.universe.Tree">l</a>]($<a href="#org.parboiled2.ParserMacros.runImpl.runCall.ruleExpr" title="c.universe.Tree">ruleExpr</a>)($<a href="#org.parboiled2.ParserMacros.runImpl.scheme" title="c.Expr[org.parboiled2.Parser.DeliveryScheme[L]]">scheme</a><span class="string">)&quot;</span>
        case <span title="c.universe.Tree">x</span> ⇒ <a href="#org.parboiled2.ParserMacros.runImpl.c" title="org.parboiled2.ParserMacros.RunnableRuleContext[L]">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><span title="c.universe.Tree">x</span>.<span title="=&gt; c.universe.Position">pos</span>, <span title="String(&quot;Illegal `.run()` call base: &quot;)" class="string">&quot;Illegal `.run()` call base: &quot;</span> <span title="(x$1: Any)String">+</span> <span title="c.universe.Tree">x</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      case <span title="c.universe.Tree">x</span> ⇒ <a href="#org.parboiled2.ParserMacros.runImpl.c" title="org.parboiled2.ParserMacros.RunnableRuleContext[L]">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><span title="c.universe.Tree">x</span>.<span title="=&gt; c.universe.Position">pos</span>, <span title="String(&quot;Illegal `Runnable.apply` call: &quot;)" class="string">&quot;Illegal `Runnable.apply` call: &quot;</span> <span title="(x$1: Any)String">+</span> <span title="c.universe.Tree">x</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#org.parboiled2.ParserMacros.runImpl.c" title="org.parboiled2.ParserMacros.RunnableRuleContext[L]">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[scheme.value.Result])c.Expr[scheme.value.Result]" class="delimiter">[</span>scheme.value.<a href="#org.parboiled2.Parser;DeliveryScheme;Result" title="scheme.value.Result">Result</a><span class="delimiter">]</span><a href="#org.parboiled2.ParserMacros.runImpl.c" title="c.universe.type" id="org.parboiled2.ParserMacros.runImpl;$typecreator5.apply.free$c1" class="delimiter">(</a><a href="#org.parboiled2.ParserMacros.runImpl.runCall" title="c.universe.Tree">runCall</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * THIS IS NOT PUBLIC API and might become hidden in future. Use only if you know what you are doing!
   */</span>
  type <a title="&lt;refinement of scala.reflect.macros.whitebox.Context&gt; extends scala.reflect.macros.whitebox.Context" id="org.parboiled2.ParserMacros;ParserContext">ParserContext</a> = <a href="#org.parboiled2.ParserMacros;<refinement>" title="&lt;refinement of scala.reflect.macros.whitebox.Context&gt; extends scala.reflect.macros.whitebox.Context">Context</a> <span class="delimiter">{</span> type PrefixType = Parser <span class="delimiter">}</span>

  def <a title="[I &lt;: shapeless.HList, O &lt;: shapeless.HList](ctx: org.parboiled2.ParserMacros.ParserContext)(r: ctx.Expr[org.parboiled2.Rule[I,O]])(implicit evidence$2: ctx.WeakTypeTag[I], implicit evidence$3: ctx.WeakTypeTag[O])ctx.Expr[org.parboiled2.Rule[I,O]]" id="org.parboiled2.ParserMacros.ruleImpl">ruleImpl</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.ParserMacros.ruleImpl;I">I</a> &lt;: HList: ctx.WeakTypeTag, <a title=" &lt;: shapeless.HList" id="org.parboiled2.ParserMacros.ruleImpl;O">O</a> &lt;: HList: ctx.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="org.parboiled2.ParserMacros.ParserContext" id="org.parboiled2.ParserMacros.ruleImpl.ctx">ctx</a>: <a href="#org.parboiled2.ParserMacros;<refinement>" title="org.parboiled2.ParserMacros.ParserContext">ParserContext</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="ctx.Expr[org.parboiled2.Rule[I,O]]" id="org.parboiled2.ParserMacros.ruleImpl.r">r</a>: ctx.<span title="ctx.Expr[org.parboiled2.Rule[I,O]]">Expr</span><span class="delimiter">[</span>Rule<span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: ctx.<span title="ctx.Expr[org.parboiled2.Rule[I,O]]">Expr</span><span class="delimiter">[</span>Rule<span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    import <a href="#org.parboiled2.ParserMacros.ruleImpl.ctx" title="org.parboiled2.ParserMacros.ParserContext">ctx</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
    <a href="#org.parboiled2.ParserMacros.namedRuleImpl" title="(ctx: org.parboiled2.ParserMacros.ParserContext)(name: ctx.Expr[String])(r: ctx.Expr[org.parboiled2.Rule[I,O]])(implicit evidence$4: ctx.WeakTypeTag[I], implicit evidence$5: ctx.WeakTypeTag[O])ctx.Expr[org.parboiled2.Rule[I,O]]">namedRuleImpl</a><span class="delimiter">(</span><a href="#org.parboiled2.ParserMacros.ruleImpl.ctx" title="org.parboiled2.ParserMacros.ParserContext">ctx</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#org.parboiled2.ParserMacros.ruleImpl.ctx" title="org.parboiled2.ParserMacros.ParserContext">ctx</a>.<span title="[T](tree: ctx.Tree)(implicit evidence$1: ctx.WeakTypeTag[T])ctx.Expr[T]">Expr</span><span title="(tree: ctx.Tree)(implicit evidence$1: ctx.WeakTypeTag[String])ctx.Expr[String]" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span><a href="#org.parboiled2.ParserMacros.ruleImpl.ctx" title="ctx.universe.type" id="org.parboiled2.ParserMacros.ruleImpl;$typecreator6.apply.$m" class="delimiter">(</a><a href="#org.parboiled2.ParserMacros.ruleImpl.ctx" title="(value: ctx.universe.Constant)ctx.universe.Literal">Literal</a><span class="delimiter">(</span><a href="#org.parboiled2.ParserMacros.ruleImpl.ctx" title="(value: Any)ctx.universe.Constant">Constant</a><span class="delimiter">(</span><a href="#org.parboiled2.ParserMacros.ruleImpl.ctx" title="org.parboiled2.ParserMacros.ParserContext">ctx</a>.<span title="=&gt; ctx.ContextInternalApi">internal</span>.<span title="=&gt; ctx.Symbol">enclosingOwner</span>.<span title="=&gt; ctx.universe.Symbol#NameType">name</span>.<span title="=&gt; ctx.universe.Name">decodedName</span>.<span title="()String">toString</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><a href="#org.parboiled2.ParserMacros.ruleImpl.evidence$2" title="ctx.WeakTypeTag[I]" class="delimiter">(</a><a href="#org.parboiled2.ParserMacros.ruleImpl.r" title="ctx.Expr[org.parboiled2.Rule[I,O]]">r</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="[I &lt;: shapeless.HList, O &lt;: shapeless.HList](ctx: org.parboiled2.ParserMacros.ParserContext)(name: ctx.Expr[String])(r: ctx.Expr[org.parboiled2.Rule[I,O]])(implicit evidence$4: ctx.WeakTypeTag[I], implicit evidence$5: ctx.WeakTypeTag[O])ctx.Expr[org.parboiled2.Rule[I,O]]" id="org.parboiled2.ParserMacros.namedRuleImpl">namedRuleImpl</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.ParserMacros.namedRuleImpl;I">I</a> &lt;: HList: ctx.WeakTypeTag, <a title=" &lt;: shapeless.HList" id="org.parboiled2.ParserMacros.namedRuleImpl;O">O</a> &lt;: HList: ctx.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="org.parboiled2.ParserMacros.ParserContext" id="org.parboiled2.ParserMacros.namedRuleImpl.ctx">ctx</a>: <a href="#org.parboiled2.ParserMacros;<refinement>" title="org.parboiled2.ParserMacros.ParserContext">ParserContext</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="ctx.Expr[String]" id="org.parboiled2.ParserMacros.namedRuleImpl.name">name</a>: ctx.<span title="ctx.Expr[String]">Expr</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="ctx.Expr[org.parboiled2.Rule[I,O]]" id="org.parboiled2.ParserMacros.namedRuleImpl.r">r</a>: ctx.<span title="ctx.Expr[org.parboiled2.Rule[I,O]]">Expr</span><span class="delimiter">[</span>Rule<span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: ctx.<span title="ctx.Expr[org.parboiled2.Rule[I,O]]">Expr</span><span class="delimiter">[</span>Rule<span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="&lt;refinement of org.parboiled2.support.OpTreeContext[org.parboiled2.ParserMacros.&lt;refinement&gt;.type]&gt; extends AnyRef with org.parboiled2.support.OpTreeContext[org.parboiled2.ParserMacros.&lt;refinement&gt;.type]" id="org.parboiled2.ParserMacros.namedRuleImpl.opTreeCtx">opTreeCtx</a> = new <a title="&lt;$anon: org.parboiled2.support.OpTreeContext[org.parboiled2.ParserMacros.&lt;refinement&gt;.type]&gt; extends AnyRef with org.parboiled2.support.OpTreeContext[org.parboiled2.ParserMacros.&lt;refinement&gt;.type]" id="org.parboiled2.ParserMacros.namedRuleImpl.opTreeCtx;$anon">OpTreeContext</a><span class="delimiter">[</span>ctx.type<span class="delimiter">]</span> <span class="delimiter">{</span> val <a title="org.parboiled2.ParserMacros.&lt;refinement&gt;.type" id="org.parboiled2.ParserMacros.namedRuleImpl.opTreeCtx;$anon.c">c</a>: ctx.type = <a href="#org.parboiled2.ParserMacros.namedRuleImpl.ctx" title="org.parboiled2.ParserMacros.ParserContext">ctx</a> <span class="delimiter">}</span>
    val <a title="opTreeCtx.OpTree" id="org.parboiled2.ParserMacros.namedRuleImpl.opTree">opTree</a> = <a href="#org.parboiled2.ParserMacros.namedRuleImpl.opTreeCtx" title="&lt;refinement of org.parboiled2.support.OpTreeContext[org.parboiled2.ParserMacros.&lt;refinement&gt;.type]&gt; extends AnyRef with org.parboiled2.support.OpTreeContext[org.parboiled2.ParserMacros.&lt;refinement&gt;.type]">opTreeCtx</a>.<a href="support/OpTreeContext.scala.html#org.parboiled2.support;OpTreeContext.OpTree" title="(tree: opTreeCtx.c.universe.Tree)opTreeCtx.OpTree">OpTree</a><span class="delimiter">(</span><a href="#org.parboiled2.ParserMacros.namedRuleImpl.r" title="ctx.Expr[org.parboiled2.Rule[I,O]]">r</a>.<span title="=&gt; ctx.universe.Tree">tree</span><span class="delimiter">)</span>
    import <a href="#org.parboiled2.ParserMacros.namedRuleImpl.ctx" title="org.parboiled2.ParserMacros.ParserContext">ctx</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
    <a href="#org.parboiled2.ParserMacros.namedRuleImpl.ctx" title="=&gt; scala.reflect.macros.Universe">reify</a> <a title="ctx.universe.type" id="org.parboiled2.ParserMacros.namedRuleImpl;$typecreator9.apply.$m" class="delimiter">{</a>
      <a href="#org.parboiled2.ParserMacros.namedRuleImpl.ctx" title="org.parboiled2.ParserMacros.ParserContext">ctx</a>.<span title="[T](tree: ctx.Tree)(implicit evidence$1: ctx.WeakTypeTag[T])ctx.Expr[T]">Expr</span><span title="(tree: ctx.Tree)(implicit evidence$1: ctx.WeakTypeTag[org.parboiled2.RuleX])ctx.Expr[org.parboiled2.RuleX]" class="delimiter">[</span><a href="Rule.scala.html#org.parboiled2;RuleX" title="org.parboiled2.RuleX">RuleX</a><span class="delimiter">]</span><a href="#org.parboiled2.ParserMacros.namedRuleImpl.ctx" title="(implicit e: ctx.WeakTypeTag[org.parboiled2.RuleX])ctx.WeakTypeTag[org.parboiled2.RuleX]" id="org.parboiled2.ParserMacros.namedRuleImpl;$treecreator1.apply;$typecreator10.apply.$m" class="delimiter">(</a><a href="#org.parboiled2.ParserMacros.namedRuleImpl.opTree" title="opTreeCtx.OpTree">opTree</a>.<a href="support/OpTreeContext.scala.html#org.parboiled2.support;OpTreeContext;OpTree.renderRule" title="(ruleName: opTreeCtx.c.universe.Tree)opTreeCtx.c.universe.Tree">renderRule</a><span class="delimiter">(</span><a href="#org.parboiled2.ParserMacros.namedRuleImpl.name" title="ctx.Expr[String]">name</a>.<span title="=&gt; ctx.universe.Tree">tree</span><span class="delimiter">)</span><span class="delimiter">)</span>.splice.asInstanceOf<span class="delimiter">[</span>Rule<span class="delimiter">[</span><a href="#org.parboiled2.ParserMacros.namedRuleImpl.evidence$4" title="ctx.WeakTypeTag[I]">I</a>, <a href="#org.parboiled2.ParserMacros.namedRuleImpl.evidence$5" title="ctx.WeakTypeTag[O]">O</a><span class="delimiter">]</span><span class="delimiter">]</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>
        </pre>
    </body>
</html>
