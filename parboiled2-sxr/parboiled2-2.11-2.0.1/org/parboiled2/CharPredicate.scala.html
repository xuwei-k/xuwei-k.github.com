<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>org/parboiled2/CharPredicate.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (C) 2009-2013 Mathias Doenitz, Alexander Myltsev
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package org.parboiled2

import scala.annotation.tailrec
import scala.collection.immutable.NumericRange

sealed abstract class <a title="class CharPredicate extends AnyRef with Char =&gt; Boolean" id="org.parboiled2;CharPredicate">CharPredicate</a> extends <span class="delimiter">(</span>Char ⇒ Boolean<span class="delimiter">)</span> <span class="delimiter">{</span>
  import <a href="#org.parboiled2.CharPredicate" title="org.parboiled2.CharPredicate.type">CharPredicate</a>._

  <span class="comment">/**
   * Determines wether this CharPredicate is an instance of the high-performance,
   * constant-time `CharPredicate.MaskBased` implementation.
   */</span>
  def <a title="=&gt; Boolean" id="org.parboiled2;CharPredicate.isMaskBased">isMaskBased</a>: <span title="Boolean">Boolean</span> = this.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#org.parboiled2.CharPredicate.MaskBased.readResolve" title="org.parboiled2.CharPredicate.MaskBased">MaskBased</a><span class="delimiter">]</span>

  def <a title="=&gt; org.parboiled2.CharPredicate.MaskBased" id="org.parboiled2;CharPredicate.asMaskBased">asMaskBased</a>: <a href="#org.parboiled2.CharPredicate.MaskBased.readResolve" title="org.parboiled2.CharPredicate.MaskBased">MaskBased</a> =
    this match <span class="delimiter">{</span>
      case <a title="org.parboiled2.CharPredicate.MaskBased" id="org.parboiled2;CharPredicate.asMaskBased.x">x</a>: <a href="#org.parboiled2.CharPredicate.MaskBased.readResolve" title="org.parboiled2.CharPredicate.MaskBased">MaskBased</a> ⇒ <a href="#org.parboiled2;CharPredicate.asMaskBased.x" title="org.parboiled2.CharPredicate.MaskBased">x</a>
      case _            ⇒ sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;CharPredicate is not MaskBased&quot;)" class="string">&quot;CharPredicate is not MaskBased&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.++(43717f9371)">++</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.++(43717f9371).that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a>
  def <a title="(chars: Seq[Char])org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.++(b384d6b92a)">++</a><span class="delimiter">(</span><a title="Seq[Char]" id="org.parboiled2;CharPredicate.++(b384d6b92a).chars">chars</a>: <span title="Seq[Char]">Seq</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a>
  def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.--(43717f9371)">--</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.--(43717f9371).that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a>
  def <a title="(chars: Seq[Char])org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.--(b384d6b92a)">--</a><span class="delimiter">(</span><a title="Seq[Char]" id="org.parboiled2;CharPredicate.--(b384d6b92a).chars">chars</a>: <span title="Seq[Char]">Seq</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a>

  def <a title="(char: Char)org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.++(7830bcf9ab)">++</a><span class="delimiter">(</span><a title="Char" id="org.parboiled2;CharPredicate.++(7830bcf9ab).char">char</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = this <a href="#org.parboiled2;CharPredicate.++(b384d6b92a)" title="(chars: Seq[Char])org.parboiled2.CharPredicate">++</a> <span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.++(7830bcf9ab).char" title="Char">char</a> <a href="#org.parboiled2;CharPredicate.++(7830bcf9ab).x$1" title="(x: Char)List[Char]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
  def <a title="(char: Char)org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.--(7830bcf9ab)">--</a><span class="delimiter">(</span><a title="Char" id="org.parboiled2;CharPredicate.--(7830bcf9ab).char">char</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = this <a href="#org.parboiled2;CharPredicate.--(b384d6b92a)" title="(chars: Seq[Char])org.parboiled2.CharPredicate">--</a> <span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.--(7830bcf9ab).char" title="Char">char</a> <a href="#org.parboiled2;CharPredicate.--(7830bcf9ab).x$2" title="(x: Char)List[Char]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
  def <a title="(chars: String)org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.++(e8b287228a)">++</a><span class="delimiter">(</span><a title="String" id="org.parboiled2;CharPredicate.++(e8b287228a).chars">chars</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = this <a href="#org.parboiled2;CharPredicate.++(b384d6b92a)" title="(chars: Seq[Char])org.parboiled2.CharPredicate">++</a> <a href="#org.parboiled2;CharPredicate.++(e8b287228a).chars" title="String">chars</a>.<span title="implicit scala.LowPriorityImplicits.wrapCharArray : (xs: Array[Char])scala.collection.mutable.WrappedArray[Char]">toCharArray</span>
  def <a title="(chars: String)org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.--(e8b287228a)">--</a><span class="delimiter">(</span><a title="String" id="org.parboiled2;CharPredicate.--(e8b287228a).chars">chars</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = this <a href="#org.parboiled2;CharPredicate.--(b384d6b92a)" title="(chars: Seq[Char])org.parboiled2.CharPredicate">--</a> <a href="#org.parboiled2;CharPredicate.--(e8b287228a).chars" title="String">chars</a>.<span title="implicit scala.LowPriorityImplicits.wrapCharArray : (xs: Array[Char])scala.collection.mutable.WrappedArray[Char]">toCharArray</span>

  def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.intersect">intersect</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.intersect.that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a>

  def <a title="=&gt; org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.negated">negated</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = this match <span class="delimiter">{</span>
    case <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a> ⇒ <a href="#org.parboiled2.CharPredicate.All" title="=&gt; org.parboiled2.CharPredicate">All</a>
    case <a href="#org.parboiled2.CharPredicate.All" title="=&gt; org.parboiled2.CharPredicate">All</a>   ⇒ <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>
    case <a title="org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.negated.x">x</a>     ⇒ <a href="#org.parboiled2.CharPredicate.from" title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate">from</a><span class="delimiter">(</span><a title="Char" id="org.parboiled2;CharPredicate.negated.$anonfun.c">c</a> ⇒ <span title="=&gt; Boolean">!</span><a href="#org.parboiled2;CharPredicate.negated.x" title="(v1: Char)Boolean">x</a><span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.negated.$anonfun.c" title="Char">c</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(string: String)Boolean" id="org.parboiled2;CharPredicate.matchesAny">matchesAny</a><span class="delimiter">(</span><a title="String" id="org.parboiled2;CharPredicate.matchesAny.string">string</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    @tailrec def <a title="(ix: Int)Boolean" id="org.parboiled2;CharPredicate.matchesAny.rec">rec</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;CharPredicate.matchesAny.rec.ix">ix</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      if <span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.matchesAny.rec.ix" title="Int">ix</a> <span title="(x: Int)Boolean">==</span> <a href="#org.parboiled2;CharPredicate.matchesAny.string" title="String">string</a>.<span title="()Int">length</span><span class="delimiter">)</span> false else if <span class="delimiter">(</span>this<span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.matchesAny.string" title="String">string</a> <span title="(x$1: Int)Char">charAt</span> <a href="#org.parboiled2;CharPredicate.matchesAny.rec.ix" title="Int">ix</a><span class="delimiter">)</span><span class="delimiter">)</span> true else <a href="#org.parboiled2;CharPredicate.matchesAny.rec" title="(ix: Int)Boolean">rec</a><span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.matchesAny.rec.ix" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <a href="#org.parboiled2;CharPredicate.matchesAny.rec" title="(ix: Int)Boolean">rec</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(string: String)Boolean" id="org.parboiled2;CharPredicate.matchesAll">matchesAll</a><span class="delimiter">(</span><a title="String" id="org.parboiled2;CharPredicate.matchesAll.string">string</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    @tailrec def <a title="(ix: Int)Boolean" id="org.parboiled2;CharPredicate.matchesAll.rec">rec</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;CharPredicate.matchesAll.rec.ix">ix</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
      if <span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.matchesAll.rec.ix" title="Int">ix</a> <span title="(x: Int)Boolean">==</span> <a href="#org.parboiled2;CharPredicate.matchesAll.string" title="String">string</a>.<span title="()Int">length</span><span class="delimiter">)</span> true else if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span>this<span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.matchesAll.string" title="String">string</a> <span title="(x$1: Int)Char">charAt</span> <a href="#org.parboiled2;CharPredicate.matchesAll.rec.ix" title="Int">ix</a><span class="delimiter">)</span><span class="delimiter">)</span> false else <a href="#org.parboiled2;CharPredicate.matchesAll.rec" title="(ix: Int)Boolean">rec</a><span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.matchesAll.rec.ix" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <a href="#org.parboiled2;CharPredicate.matchesAll.rec" title="(ix: Int)Boolean">rec</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(string: String)Int" id="org.parboiled2;CharPredicate.indexOfFirstMatch">indexOfFirstMatch</a><span class="delimiter">(</span><a title="String" id="org.parboiled2;CharPredicate.indexOfFirstMatch.string">string</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    @tailrec def <a title="(ix: Int)Int" id="org.parboiled2;CharPredicate.indexOfFirstMatch.rec">rec</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;CharPredicate.indexOfFirstMatch.rec.ix">ix</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> =
      if <span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.indexOfFirstMatch.rec.ix" title="Int">ix</a> <span title="(x: Int)Boolean">==</span> <a href="#org.parboiled2;CharPredicate.indexOfFirstMatch.string" title="String">string</a>.<span title="()Int">length</span><span class="delimiter">)</span> -<span title="Int(-1)" class="int">1</span> else if <span class="delimiter">(</span>this<span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.indexOfFirstMatch.string" title="String">string</a> <span title="(x$1: Int)Char">charAt</span> <a href="#org.parboiled2;CharPredicate.indexOfFirstMatch.rec.ix" title="Int">ix</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#org.parboiled2;CharPredicate.indexOfFirstMatch.rec.ix" title="Int">ix</a> else <a href="#org.parboiled2;CharPredicate.indexOfFirstMatch.rec" title="(ix: Int)Int">rec</a><span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.indexOfFirstMatch.rec.ix" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <a href="#org.parboiled2;CharPredicate.indexOfFirstMatch.rec" title="(ix: Int)Int">rec</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(string: String)Int" id="org.parboiled2;CharPredicate.indexOfFirstMismatch">indexOfFirstMismatch</a><span class="delimiter">(</span><a title="String" id="org.parboiled2;CharPredicate.indexOfFirstMismatch.string">string</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
    @tailrec def <a title="(ix: Int)Int" id="org.parboiled2;CharPredicate.indexOfFirstMismatch.rec">rec</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2;CharPredicate.indexOfFirstMismatch.rec.ix">ix</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> =
      if <span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.indexOfFirstMismatch.rec.ix" title="Int">ix</a> <span title="(x: Int)Boolean">==</span> <a href="#org.parboiled2;CharPredicate.indexOfFirstMismatch.string" title="String">string</a>.<span title="()Int">length</span><span class="delimiter">)</span> -<span title="Int(-1)" class="int">1</span> else if <span class="delimiter">(</span>this<span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.indexOfFirstMismatch.string" title="String">string</a> <span title="(x$1: Int)Char">charAt</span> <a href="#org.parboiled2;CharPredicate.indexOfFirstMismatch.rec.ix" title="Int">ix</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#org.parboiled2;CharPredicate.indexOfFirstMismatch.rec" title="(ix: Int)Int">rec</a><span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.indexOfFirstMismatch.rec.ix" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> else <a href="#org.parboiled2;CharPredicate.indexOfFirstMismatch.rec.ix" title="Int">ix</a>
    <a href="#org.parboiled2;CharPredicate.indexOfFirstMismatch.rec" title="(ix: Int)Int">rec</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="(string: String)Option[Char]" id="org.parboiled2;CharPredicate.firstMatch">firstMatch</a><span class="delimiter">(</span><a title="String" id="org.parboiled2;CharPredicate.firstMatch.string">string</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Option[Char]">Option</span><span class="delimiter">[</span>Char<span class="delimiter">]</span> =
    <a href="#org.parboiled2;CharPredicate.indexOfFirstMatch" title="(string: String)Int">indexOfFirstMatch</a><span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.firstMatch.string" title="String">string</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case <span title="Int(-1)">-</span><span class="int">1</span> ⇒ <span title="None.type">None</span>
      case <a title="Int" id="org.parboiled2;CharPredicate.firstMatch.ix">ix</a> ⇒ <span title="(x: Char)Some[Char]">Some</span><span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.firstMatch.string" title="String">string</a> <span title="(x$1: Int)Char">charAt</span> <a href="#org.parboiled2;CharPredicate.firstMatch.ix" title="Int">ix</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  def <a title="(string: String)Option[Char]" id="org.parboiled2;CharPredicate.firstMismatch">firstMismatch</a><span class="delimiter">(</span><a title="String" id="org.parboiled2;CharPredicate.firstMismatch.string">string</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Option[Char]">Option</span><span class="delimiter">[</span>Char<span class="delimiter">]</span> =
    <a href="#org.parboiled2;CharPredicate.indexOfFirstMismatch" title="(string: String)Int">indexOfFirstMismatch</a><span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.firstMismatch.string" title="String">string</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case <span title="Int(-1)">-</span><span class="int">1</span> ⇒ <span title="None.type">None</span>
      case <a title="Int" id="org.parboiled2;CharPredicate.firstMismatch.ix">ix</a> ⇒ <span title="(x: Char)Some[Char]">Some</span><span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.firstMismatch.string" title="String">string</a> <span title="(x$1: Int)Char">charAt</span> <a href="#org.parboiled2;CharPredicate.firstMismatch.ix" title="Int">ix</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  protected def <a title="(that: Char =&gt; Boolean)org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.or">or</a><span class="delimiter">(</span><a title="Char =&gt; Boolean" id="org.parboiled2;CharPredicate.or.that">that</a>: Char ⇒ Boolean<span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> =
    <a href="#org.parboiled2.CharPredicate.from" title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate">from</a><span class="delimiter">(</span>if <span class="delimiter">(</span>this <span title="(x$1: Any)Boolean">==</span> <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a><span class="delimiter">)</span> <a href="#org.parboiled2;CharPredicate.or.that" title="Char =&gt; Boolean">that</a> else <a title="Char" id="org.parboiled2;CharPredicate.or.$anonfun.c">c</a> ⇒ this<span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.or.$anonfun.c" title="Char">c</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.parboiled2;CharPredicate.or.that" title="(v1: Char)Boolean">that</a><span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.or.$anonfun.c" title="Char">c</a><span class="delimiter">)</span><span class="delimiter">)</span>
  protected def <a title="(that: Char =&gt; Boolean)org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.and">and</a><span class="delimiter">(</span><a title="Char =&gt; Boolean" id="org.parboiled2;CharPredicate.and.that">that</a>: Char ⇒ Boolean<span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> =
    if <span class="delimiter">(</span>this <span title="(x$1: Any)Boolean">==</span> <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a><span class="delimiter">)</span> <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a> else <a href="#org.parboiled2.CharPredicate.from" title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate">from</a><span class="delimiter">(</span><a title="Char" id="org.parboiled2;CharPredicate.and.$anonfun.c">c</a> ⇒ this<span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.and.$anonfun.c" title="Char">c</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#org.parboiled2;CharPredicate.and.that" title="(v1: Char)Boolean">that</a><span class="delimiter">(</span><a href="#org.parboiled2;CharPredicate.and.$anonfun.c" title="Char">c</a><span class="delimiter">)</span><span class="delimiter">)</span>
  protected def <a title="(that: Char =&gt; Boolean)org.parboiled2.CharPredicate" id="org.parboiled2;CharPredicate.andNot">andNot</a><span class="delimiter">(</span><a title="Char =&gt; Boolean" id="org.parboiled2;CharPredicate.andNot.that">that</a>: Char ⇒ Boolean<span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> =
    <a href="#org.parboiled2.CharPredicate.from" title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate">from</a><span class="delimiter">(</span>if <span class="delimiter">(</span>this <span title="(x$1: Any)Boolean">==</span> <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a><span class="delimiter">)</span> <span title="Char">c</span> ⇒ <span title="=&gt; Boolean">!</span><a href="#org.parboiled2;CharPredicate.andNot.that" title="(v1: Char)Boolean">that</a><span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span> else <span title="Char">c</span> ⇒ this<span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#org.parboiled2;CharPredicate.andNot.that" title="(v1: Char)Boolean">that</a><span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

object <a title="org.parboiled2.CharPredicate.type" id="org.parboiled2.CharPredicate">CharPredicate</a> <a href="#org.parboiled2.CharPredicate" title="org.parboiled2.CharPredicate.type" class="delimiter">{</a>
  val <a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.Empty">Empty</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = <a href="#org.parboiled2.CharPredicate.MaskBased.readResolve" title="(lowMask: Long, highMask: Long)org.parboiled2.CharPredicate.MaskBased">MaskBased</a><span class="delimiter">(</span><span title="Long(0L)" class="long">0L</span>, <span title="Long(0L)" class="long">0L</span><span class="delimiter">)</span>
  val <a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.All">All</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = <a href="#org.parboiled2.CharPredicate.from" title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate">from</a><span class="delimiter">(</span><a title="Char" id="org.parboiled2.CharPredicate.All.$anonfun.x$3">_</a> ⇒ true<span class="delimiter">)</span>
  val <a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.LowerAlpha">LowerAlpha</a> = <a href="#org.parboiled2.CharPredicate.apply" title="(magnets: org.parboiled2.CharPredicate.ApplyMagnet*)org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">(</span><span title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar" class="char">'a'</span> <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars" title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromChars : (chars: Seq[Char])org.parboiled2.CharPredicate.ApplyMagnet">to</a> <span title="Char('z')" class="char">'z'</span><span class="delimiter">)</span>
  val <a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.UpperAlpha">UpperAlpha</a> = <a href="#org.parboiled2.CharPredicate.apply" title="(magnets: org.parboiled2.CharPredicate.ApplyMagnet*)org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">(</span><span title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar" class="char">'A'</span> <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars" title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromChars : (chars: Seq[Char])org.parboiled2.CharPredicate.ApplyMagnet">to</a> <span title="Char('Z')" class="char">'Z'</span><span class="delimiter">)</span>
  val Alpha = <a href="#org.parboiled2.CharPredicate.LowerAlpha" title="=&gt; org.parboiled2.CharPredicate">LowerAlpha</a> <a href="#org.parboiled2;CharPredicate.++(43717f9371)" title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.Alpha">++</a> <a href="#org.parboiled2.CharPredicate.UpperAlpha" title="=&gt; org.parboiled2.CharPredicate">UpperAlpha</a>
  val <a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.Digit">Digit</a> = <a href="#org.parboiled2.CharPredicate.apply" title="(magnets: org.parboiled2.CharPredicate.ApplyMagnet*)org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">(</span><span title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar" class="char">'0'</span> <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars" title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromChars : (chars: Seq[Char])org.parboiled2.CharPredicate.ApplyMagnet">to</a> <span title="Char('9')" class="char">'9'</span><span class="delimiter">)</span>
  val <a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.Digit19">Digit19</a> = <a href="#org.parboiled2.CharPredicate.apply" title="(magnets: org.parboiled2.CharPredicate.ApplyMagnet*)org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">(</span><span title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar" class="char">'1'</span> <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars" title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromChars : (chars: Seq[Char])org.parboiled2.CharPredicate.ApplyMagnet">to</a> <span title="Char('9')" class="char">'9'</span><span class="delimiter">)</span>
  val AlphaNum = <a href="#org.parboiled2.CharPredicate.Alpha" title="=&gt; org.parboiled2.CharPredicate">Alpha</a> <a href="#org.parboiled2;CharPredicate.++(43717f9371)" title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.AlphaNum">++</a> <a href="#org.parboiled2.CharPredicate.Digit" title="=&gt; org.parboiled2.CharPredicate">Digit</a>
  val <a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.LowerHexLetter">LowerHexLetter</a> = <a href="#org.parboiled2.CharPredicate.apply" title="(magnets: org.parboiled2.CharPredicate.ApplyMagnet*)org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">(</span><span title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar" class="char">'a'</span> <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars" title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromChars : (chars: Seq[Char])org.parboiled2.CharPredicate.ApplyMagnet">to</a> <span title="Char('f')" class="char">'f'</span><span class="delimiter">)</span>
  val <a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.UpperHexLetter">UpperHexLetter</a> = <a href="#org.parboiled2.CharPredicate.apply" title="(magnets: org.parboiled2.CharPredicate.ApplyMagnet*)org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">(</span><span title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar" class="char">'A'</span> <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars" title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromChars : (chars: Seq[Char])org.parboiled2.CharPredicate.ApplyMagnet">to</a> <span title="Char('F')" class="char">'F'</span><span class="delimiter">)</span>
  val HexLetter = <a href="#org.parboiled2.CharPredicate.LowerHexLetter" title="=&gt; org.parboiled2.CharPredicate">LowerHexLetter</a> <a href="#org.parboiled2;CharPredicate.++(43717f9371)" title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.HexLetter">++</a> <a href="#org.parboiled2.CharPredicate.UpperHexLetter" title="=&gt; org.parboiled2.CharPredicate">UpperHexLetter</a>
  val HexDigit = <a href="#org.parboiled2.CharPredicate.Digit" title="=&gt; org.parboiled2.CharPredicate">Digit</a> <a href="#org.parboiled2;CharPredicate.++(43717f9371)" title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.HexDigit">++</a> <a href="#org.parboiled2.CharPredicate.HexLetter" title="=&gt; org.parboiled2.CharPredicate">HexLetter</a>
  val <a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.Visible">Visible</a> = <a href="#org.parboiled2.CharPredicate.apply" title="(magnets: org.parboiled2.CharPredicate.ApplyMagnet*)org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">(</span><span title="implicit scala.LowPriorityImplicits.charWrapper : (c: Char)scala.runtime.RichChar" class="char">'\u0021'</span> <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars" title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromChars : (chars: Seq[Char])org.parboiled2.CharPredicate.ApplyMagnet">to</a> <span title="Char('~')" class="char">'\u007e'</span><span class="delimiter">)</span>
  val Printable = <a href="#org.parboiled2.CharPredicate.Visible" title="=&gt; org.parboiled2.CharPredicate">Visible</a> <a href="#org.parboiled2;CharPredicate.++(7830bcf9ab)" title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.Printable">++</a> <span title="Char(' ')" class="char">' '</span>

  def <a title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.from">from</a><span class="delimiter">(</span><a title="Char =&gt; Boolean" id="org.parboiled2.CharPredicate.from.predicate">predicate</a>: Char ⇒ Boolean<span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> =
    <a href="#org.parboiled2.CharPredicate.from.predicate" title="Char =&gt; Boolean">predicate</a> match <span class="delimiter">{</span>
      case <span title="org.parboiled2.CharPredicate">x</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> ⇒ <span title="org.parboiled2.CharPredicate">x</span>
      case <span title="Char =&gt; Boolean">x</span>                ⇒ <a href="#org.parboiled2.CharPredicate.General.readResolve" title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate.General">General</a><span class="delimiter">(</span><span title="Char =&gt; Boolean">x</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  def <a title="(magnets: org.parboiled2.CharPredicate.ApplyMagnet*)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.apply">apply</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate.ApplyMagnet*" id="org.parboiled2.CharPredicate.apply.magnets">magnets</a>: <span title="org.parboiled2.CharPredicate.ApplyMagnet*">ApplyMagnet</span>*<span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = <span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a> <a href="#org.parboiled2.CharPredicate.apply.x$4" title="(z: org.parboiled2.CharPredicate)(op: (org.parboiled2.CharPredicate, org.parboiled2.CharPredicate.ApplyMagnet) =&gt; org.parboiled2.CharPredicate)org.parboiled2.CharPredicate">/:</a> <a href="#org.parboiled2.CharPredicate.apply.magnets" title="org.parboiled2.CharPredicate.ApplyMagnet*">magnets</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.apply.$anonfun.a">a</a>, <a title="org.parboiled2.CharPredicate.ApplyMagnet" id="org.parboiled2.CharPredicate.apply.$anonfun.m">m</a><span class="delimiter">)</span> ⇒ <a href="#org.parboiled2.CharPredicate.apply.$anonfun.a" title="org.parboiled2.CharPredicate">a</a> <a href="#org.parboiled2;CharPredicate.++(43717f9371)" title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate">++</a> <a href="#org.parboiled2.CharPredicate.apply.$anonfun.m" title="org.parboiled2.CharPredicate.ApplyMagnet">m</a>.<a href="#org.parboiled2.CharPredicate;ApplyMagnet.predicate" title="=&gt; org.parboiled2.CharPredicate">predicate</a> <span class="delimiter">}</span>

  class <a title="class ApplyMagnet extends AnyRef" id="org.parboiled2.CharPredicate;ApplyMagnet">ApplyMagnet</a><a href="#org.parboiled2.CharPredicate;ApplyMagnet" title="org.parboiled2.CharPredicate.ApplyMagnet" class="delimiter">(</a>val <a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;ApplyMagnet.predicate">predicate</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>
  object <a title="org.parboiled2.CharPredicate.ApplyMagnet.type" id="org.parboiled2.CharPredicate.ApplyMagnet">ApplyMagnet</a> <a href="#org.parboiled2.CharPredicate.ApplyMagnet" title="org.parboiled2.CharPredicate.ApplyMagnet.type" class="delimiter">{</a>
    implicit def <a title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromPredicate : (predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate.ApplyMagnet" id="org.parboiled2.CharPredicate.ApplyMagnet.fromPredicate">fromPredicate</a><span class="delimiter">(</span><a title="Char =&gt; Boolean" id="org.parboiled2.CharPredicate.ApplyMagnet.fromPredicate.predicate">predicate</a>: Char ⇒ Boolean<span class="delimiter">)</span>: <a href="#org.parboiled2.CharPredicate;ApplyMagnet" title="org.parboiled2.CharPredicate.ApplyMagnet">ApplyMagnet</a> = new <a href="#org.parboiled2.CharPredicate;ApplyMagnet" title="org.parboiled2.CharPredicate.ApplyMagnet">ApplyMagnet</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.from" title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate">from</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromPredicate.predicate" title="Char =&gt; Boolean">predicate</a><span class="delimiter">)</span><span class="delimiter">)</span>
    implicit def <a title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromChar : (c: Char)org.parboiled2.CharPredicate.ApplyMagnet" id="org.parboiled2.CharPredicate.ApplyMagnet.fromChar">fromChar</a><span class="delimiter">(</span><a title="Char" id="org.parboiled2.CharPredicate.ApplyMagnet.fromChar.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <a href="#org.parboiled2.CharPredicate;ApplyMagnet" title="org.parboiled2.CharPredicate.ApplyMagnet">ApplyMagnet</a> = <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars" title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromChars : (chars: Seq[Char])org.parboiled2.CharPredicate.ApplyMagnet">fromChars</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChar.c" title="Char">c</a> <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChar.x$5" title="(x: Char)List[Char]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
    implicit def <a title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromCharArray : (array: Array[Char])org.parboiled2.CharPredicate.ApplyMagnet" id="org.parboiled2.CharPredicate.ApplyMagnet.fromCharArray">fromCharArray</a><span class="delimiter">(</span><a title="Array[Char]" id="org.parboiled2.CharPredicate.ApplyMagnet.fromCharArray.array">array</a>: <span title="Array[Char]">Array</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2.CharPredicate;ApplyMagnet" title="org.parboiled2.CharPredicate.ApplyMagnet">ApplyMagnet</a> = <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars" title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromChars : (chars: Seq[Char])org.parboiled2.CharPredicate.ApplyMagnet">fromChars</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromCharArray.array" title="implicit scala.LowPriorityImplicits.wrapCharArray : (xs: Array[Char])scala.collection.mutable.WrappedArray[Char]">array</a><span class="delimiter">)</span>
    implicit def <a title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromString : (chars: String)org.parboiled2.CharPredicate.ApplyMagnet" id="org.parboiled2.CharPredicate.ApplyMagnet.fromString">fromString</a><span class="delimiter">(</span><a title="String" id="org.parboiled2.CharPredicate.ApplyMagnet.fromString.chars">chars</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#org.parboiled2.CharPredicate;ApplyMagnet" title="org.parboiled2.CharPredicate.ApplyMagnet">ApplyMagnet</a> = <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars" title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromChars : (chars: Seq[Char])org.parboiled2.CharPredicate.ApplyMagnet">fromChars</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromString.chars" title="implicit scala.LowPriorityImplicits.wrapString : (s: String)scala.collection.immutable.WrappedString">chars</a><span class="delimiter">)</span>
    implicit def <a title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromChars : (chars: Seq[Char])org.parboiled2.CharPredicate.ApplyMagnet" id="org.parboiled2.CharPredicate.ApplyMagnet.fromChars">fromChars</a><span class="delimiter">(</span><a title="Seq[Char]" id="org.parboiled2.CharPredicate.ApplyMagnet.fromChars.chars">chars</a>: <span title="Seq[Char]">Seq</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2.CharPredicate;ApplyMagnet" title="org.parboiled2.CharPredicate.ApplyMagnet">ApplyMagnet</a> =
      <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars.chars" title="Seq[Char]">chars</a> match <span class="delimiter">{</span>
        case _ if <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars.chars" title="Seq[Char]">chars</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(128)" class="int">128</span> <span title="(x: Boolean)Boolean">&amp;</span> <span title="=&gt; Boolean">!</span><a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars.chars" title="Seq[Char]">chars</a>.<span title="(p: Char =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.unmaskable" title="(c: Char)Boolean">unmaskable</a><span class="delimiter">)</span> ⇒
          @tailrec def <a title="(ix: Int, result: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.ApplyMagnet.fromChars.rec">rec</a><span class="delimiter">(</span><a title="Int" id="org.parboiled2.CharPredicate.ApplyMagnet.fromChars.rec.ix">ix</a>: <span title="Int">Int</span>, <a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate.ApplyMagnet.fromChars.rec.result">result</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> =
            if <span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars.rec.ix" title="Int">ix</a> <span title="(x: Int)Boolean">==</span> <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars.chars" title="Seq[Char]">chars</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars.rec.result" title="org.parboiled2.CharPredicate">result</a> else <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars.rec" title="(ix: Int, result: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate">rec</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars.rec.ix" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars.rec.result" title="org.parboiled2.CharPredicate">result</a> <a href="#org.parboiled2;CharPredicate.++(7830bcf9ab)" title="(char: Char)org.parboiled2.CharPredicate">++</a> <a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars.chars" title="(idx: Int)Char">chars</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars.rec.ix" title="Int">ix</a><span class="delimiter">)</span><span class="delimiter">)</span>
          new <a href="#org.parboiled2.CharPredicate;ApplyMagnet" title="org.parboiled2.CharPredicate.ApplyMagnet">ApplyMagnet</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars.rec" title="(ix: Int, result: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate">rec</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span>, <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case <a title="scala.collection.immutable.NumericRange[Char]" id="org.parboiled2.CharPredicate.ApplyMagnet.fromChars.r">r</a>: <span title="scala.collection.immutable.NumericRange[Char]">NumericRange</span><span class="delimiter">[</span>Char<span class="delimiter">]</span> ⇒ new <a href="#org.parboiled2.CharPredicate;ApplyMagnet" title="org.parboiled2.CharPredicate.ApplyMagnet">ApplyMagnet</a><span class="delimiter">(</span>new <a href="#org.parboiled2.CharPredicate;RangeBased" title="org.parboiled2.CharPredicate.RangeBased">RangeBased</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars.r" title="scala.collection.immutable.NumericRange[Char]">r</a><span class="delimiter">)</span><span class="delimiter">)</span>
        case _                     ⇒ new <a href="#org.parboiled2.CharPredicate;ApplyMagnet" title="org.parboiled2.CharPredicate.ApplyMagnet">ApplyMagnet</a><span class="delimiter">(</span>new <a href="#org.parboiled2.CharPredicate;ArrayBased" title="org.parboiled2.CharPredicate.ArrayBased">ArrayBased</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars.chars" title="Seq[Char]">chars</a>.<span title="(implicit evidence$1: scala.reflect.ClassTag[Char])Array[Char]">toArray</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">///////////////////////// PRIVATE ////////////////////////////</span>

  private def <a title="(c: Char)Boolean" id="org.parboiled2.CharPredicate.unmaskable">unmaskable</a><span class="delimiter">(</span><a title="Char" id="org.parboiled2.CharPredicate.unmaskable.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#org.parboiled2.CharPredicate.unmaskable.c" title="Char">c</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(128)" class="int">128</span>

  <span class="comment">// efficient handling of 7bit-ASCII chars</span>
  case class <a title="class MaskBased extends org.parboiled2.CharPredicate with Product with Serializable" id="org.parboiled2.CharPredicate.MaskBased.readResolve">MaskBased</a> private<span class="delimiter">[</span>CharPredicate<span class="delimiter">]</span> <span class="delimiter">(</span><a title="Long" id="org.parboiled2.CharPredicate;MaskBased.lowMask">lowMask</a>: <span title="Long">Long</span>, <a title="Long" id="org.parboiled2.CharPredicate;MaskBased.highMask">highMask</a>: <span title="Long">Long</span><span class="delimiter">)</span> extends <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> <span class="delimiter">{</span>
    def <a title="(c: Char)Boolean" id="org.parboiled2.CharPredicate;MaskBased.apply">apply</a><span class="delimiter">(</span><a title="Char" id="org.parboiled2.CharPredicate;MaskBased.apply.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      val <a title="Long" id="org.parboiled2.CharPredicate;MaskBased.apply.mask">mask</a> = if <span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.apply.c" title="Char">c</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(64)" class="int">64</span><span class="delimiter">)</span> <a href="#org.parboiled2.CharPredicate;MaskBased.lowMask" title="=&gt; Long">lowMask</a> else <a href="#org.parboiled2.CharPredicate;MaskBased.highMask" title="=&gt; Long">highMask</a>
      <span class="delimiter">(</span><span class="delimiter">(</span><span title="Long(1L)" class="long">1L</span> <span title="(x: Int)Long">&lt;&lt;</span> <a href="#org.parboiled2.CharPredicate;MaskBased.apply.c" title="=&gt; Int">c</a><span class="delimiter">)</span> <span title="(x: Int)Long">&amp;</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.apply.c" title="Char">c</a> <span title="(x: Int)Int">-</span> <span title="Int(128)" class="int">128</span><span class="delimiter">)</span> <span title="(x: Int)Int">&gt;&gt;</span> <span title="Int(31)" class="int">31</span><span class="delimiter">)</span> <span title="(x: Long)Long">&amp;</span> <a href="#org.parboiled2.CharPredicate;MaskBased.apply.mask" title="Long">mask</a><span class="delimiter">)</span> <span title="(x: Long)Boolean">!=</span> <span title="Long(0L)" class="long">0L</span> <span class="comment">// branchless for `(c &lt; 128) &amp;&amp; (mask &amp; (1L &lt;&lt; c) != 0)`</span>
    <span class="delimiter">}</span>

    def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;MaskBased.++(43717f9371)">++</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;MaskBased.++(43717f9371).that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = <a href="#org.parboiled2.CharPredicate;MaskBased.++(43717f9371).that" title="org.parboiled2.CharPredicate">that</a> match <span class="delimiter">{</span>
      case <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>                ⇒ this
      case _ if this <span title="(x$1: Any)Boolean">==</span> <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>   ⇒ <a href="#org.parboiled2.CharPredicate;MaskBased.++(43717f9371).that" title="org.parboiled2.CharPredicate">that</a>
      case MaskBased<span class="delimiter">(</span><a title="Long" id="org.parboiled2.CharPredicate;MaskBased.++(43717f9371).low">low</a>, <a title="Long" id="org.parboiled2.CharPredicate;MaskBased.++(43717f9371).high">high</a><span class="delimiter">)</span> ⇒ <a href="#org.parboiled2.CharPredicate.MaskBased.readResolve" title="(lowMask: Long, highMask: Long)org.parboiled2.CharPredicate.MaskBased">MaskBased</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.lowMask" title="=&gt; Long">lowMask</a> <span title="(x: Long)Long">|</span> <a href="#org.parboiled2.CharPredicate;MaskBased.++(43717f9371).low" title="Long">low</a>, <a href="#org.parboiled2.CharPredicate;MaskBased.highMask" title="=&gt; Long">highMask</a> <span title="(x: Long)Long">|</span> <a href="#org.parboiled2.CharPredicate;MaskBased.++(43717f9371).high" title="Long">high</a><span class="delimiter">)</span>
      case _                    ⇒ this <a href="#org.parboiled2;CharPredicate.or" title="(that: Char =&gt; Boolean)org.parboiled2.CharPredicate">or</a> <a href="#org.parboiled2.CharPredicate;MaskBased.++(43717f9371).that" title="org.parboiled2.CharPredicate">that</a>
    <span class="delimiter">}</span>

    def <a title="(chars: Seq[Char])org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;MaskBased.++(b384d6b92a)">++</a><span class="delimiter">(</span><a title="Seq[Char]" id="org.parboiled2.CharPredicate;MaskBased.++(b384d6b92a).chars">chars</a>: <span title="Seq[Char]">Seq</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = <a href="#org.parboiled2.CharPredicate;MaskBased.++(b384d6b92a).chars" title="Seq[Char]">chars</a>.<span title="(z: org.parboiled2.CharPredicate)(op: (org.parboiled2.CharPredicate, Char) =&gt; org.parboiled2.CharPredicate)org.parboiled2.CharPredicate">foldLeft</span><span class="delimiter">(</span>this: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span> <a href="#org.parboiled2.CharPredicate;MaskBased.++(b384d6b92a).$anonfun.x0$1" title="org.parboiled2.CharPredicate" class="delimiter">{</a>
      case <span class="delimiter">(</span>_: <a href="#org.parboiled2.CharPredicate.MaskBased.readResolve" title="org.parboiled2.CharPredicate.MaskBased">MaskBased</a>, <span title="Char">c</span><span class="delimiter">)</span> if <a href="#org.parboiled2.CharPredicate.unmaskable" title="(c: Char)Boolean">unmaskable</a><span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span>  ⇒ new <a href="#org.parboiled2.CharPredicate;ArrayBased" title="org.parboiled2.CharPredicate.ArrayBased">ArrayBased</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.++(b384d6b92a).chars" title="Seq[Char]">chars</a>.<span title="(implicit evidence$1: scala.reflect.ClassTag[Char])Array[Char]">toArray</span><span class="delimiter">)</span> <a href="#org.parboiled2.CharPredicate;ArrayBased.++(43717f9371)" title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate">++</a> new <a href="#org.parboiled2.CharPredicate;ArrayBased" title="org.parboiled2.CharPredicate.ArrayBased">ArrayBased</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.toArray" title="=&gt; Array[Char]">toArray</a><span class="delimiter">)</span>
      case <span class="delimiter">(</span>MaskBased<span class="delimiter">(</span><span title="Long">low</span>, <span title="Long">high</span><span class="delimiter">)</span>, <span title="Char">c</span><span class="delimiter">)</span> if <span title="Char">c</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(64)" class="int">64</span> ⇒ <a href="#org.parboiled2.CharPredicate.MaskBased.readResolve" title="(lowMask: Long, highMask: Long)org.parboiled2.CharPredicate.MaskBased">MaskBased</a><span class="delimiter">(</span><span title="Long">low</span> <span title="(x: Long)Long">|</span> <span title="Long(1L)" class="long">1L</span> <span title="(x: Int)Long">&lt;&lt;</span> <span title="=&gt; Int">c</span>, <span title="Long">high</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span>MaskBased<span class="delimiter">(</span><span title="Long">low</span>, <span title="Long">high</span><span class="delimiter">)</span>, <span title="Char">c</span><span class="delimiter">)</span>           ⇒ <a href="#org.parboiled2.CharPredicate.MaskBased.readResolve" title="(lowMask: Long, highMask: Long)org.parboiled2.CharPredicate.MaskBased">MaskBased</a><span class="delimiter">(</span><span title="Long">low</span>, <span title="Long">high</span> <span title="(x: Long)Long">|</span> <span title="Long(1L)" class="long">1L</span> <span title="(x: Int)Long">&lt;&lt;</span> <span title="=&gt; Int">c</span><span class="delimiter">)</span>
      case <span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;MaskBased.++(b384d6b92a).$anonfun.x">x</a>, _<span class="delimiter">)</span>                              ⇒ <a href="#org.parboiled2.CharPredicate;MaskBased.++(b384d6b92a).$anonfun.x" title="org.parboiled2.CharPredicate">x</a> <span class="comment">// once the fold acc is not a MaskBased we are done</span>
    <span class="delimiter">}</span>

    def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;MaskBased.--(43717f9371)">--</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;MaskBased.--(43717f9371).that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = <a href="#org.parboiled2.CharPredicate;MaskBased.--(43717f9371).that" title="org.parboiled2.CharPredicate">that</a> match <span class="delimiter">{</span>
      case <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>                ⇒ this
      case _ if this <span title="(x$1: Any)Boolean">==</span> <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>   ⇒ this
      case MaskBased<span class="delimiter">(</span><a title="Long" id="org.parboiled2.CharPredicate;MaskBased.--(43717f9371).low">low</a>, <a title="Long" id="org.parboiled2.CharPredicate;MaskBased.--(43717f9371).high">high</a><span class="delimiter">)</span> ⇒ <a href="#org.parboiled2.CharPredicate.MaskBased.readResolve" title="(lowMask: Long, highMask: Long)org.parboiled2.CharPredicate.MaskBased">MaskBased</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.lowMask" title="=&gt; Long">lowMask</a> <span title="(x: Long)Long">&amp;</span> <span title="=&gt; Long">~</span><a href="#org.parboiled2.CharPredicate;MaskBased.--(43717f9371).low" title="Long">low</a>, <a href="#org.parboiled2.CharPredicate;MaskBased.highMask" title="=&gt; Long">highMask</a> <span title="(x: Long)Long">&amp;</span> <span title="=&gt; Long">~</span><a href="#org.parboiled2.CharPredicate;MaskBased.--(43717f9371).high" title="Long">high</a><span class="delimiter">)</span>
      case _                    ⇒ this <a href="#org.parboiled2;CharPredicate.andNot" title="(that: Char =&gt; Boolean)org.parboiled2.CharPredicate">andNot</a> <a href="#org.parboiled2.CharPredicate;MaskBased.--(43717f9371).that" title="org.parboiled2.CharPredicate">that</a>
    <span class="delimiter">}</span>

    def <a title="(chars: Seq[Char])org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;MaskBased.--(b384d6b92a)">--</a><span class="delimiter">(</span><a title="Seq[Char]" id="org.parboiled2.CharPredicate;MaskBased.--(b384d6b92a).chars">chars</a>: <span title="Seq[Char]">Seq</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> =
      if <span class="delimiter">(</span>this <span title="(x$1: Any)Boolean">!=</span> <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#org.parboiled2.CharPredicate;MaskBased.--(b384d6b92a).chars" title="Seq[Char]">chars</a>.<span title="(z: org.parboiled2.CharPredicate)(op: (org.parboiled2.CharPredicate, Char) =&gt; org.parboiled2.CharPredicate)org.parboiled2.CharPredicate">foldLeft</span><span class="delimiter">(</span>this: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span> <a href="#org.parboiled2.CharPredicate;MaskBased.--(b384d6b92a).$anonfun.x0$2" title="org.parboiled2.CharPredicate" class="delimiter">{</a>
          case <span class="delimiter">(</span>_: <a href="#org.parboiled2.CharPredicate.MaskBased.readResolve" title="org.parboiled2.CharPredicate.MaskBased">MaskBased</a>, <span title="Char">c</span><span class="delimiter">)</span> if <a href="#org.parboiled2.CharPredicate.unmaskable" title="(c: Char)Boolean">unmaskable</a><span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span>  ⇒ this <a href="#org.parboiled2;CharPredicate.andNot" title="(that: Char =&gt; Boolean)org.parboiled2.CharPredicate">andNot</a> new <a href="#org.parboiled2.CharPredicate;ArrayBased" title="org.parboiled2.CharPredicate.ArrayBased">ArrayBased</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.--(b384d6b92a).chars" title="Seq[Char]">chars</a>.<span title="(implicit evidence$1: scala.reflect.ClassTag[Char])Array[Char]">toArray</span><span class="delimiter">)</span>
          case <span class="delimiter">(</span>MaskBased<span class="delimiter">(</span><span title="Long">low</span>, <span title="Long">high</span><span class="delimiter">)</span>, <span title="Char">c</span><span class="delimiter">)</span> if <span title="Char">c</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(64)" class="int">64</span> ⇒ <a href="#org.parboiled2.CharPredicate.MaskBased.readResolve" title="(lowMask: Long, highMask: Long)org.parboiled2.CharPredicate.MaskBased">MaskBased</a><span class="delimiter">(</span><span title="Long">low</span> <span title="(x: Long)Long">&amp;</span> <span title="=&gt; Long">~</span><span class="delimiter">(</span><span title="Long(1L)" class="long">1L</span> <span title="(x: Int)Long">&lt;&lt;</span> <span title="=&gt; Int">c</span><span class="delimiter">)</span>, <span title="Long">high</span><span class="delimiter">)</span>
          case <span class="delimiter">(</span>MaskBased<span class="delimiter">(</span><span title="Long">low</span>, <span title="Long">high</span><span class="delimiter">)</span>, <span title="Char">c</span><span class="delimiter">)</span>           ⇒ <a href="#org.parboiled2.CharPredicate.MaskBased.readResolve" title="(lowMask: Long, highMask: Long)org.parboiled2.CharPredicate.MaskBased">MaskBased</a><span class="delimiter">(</span><span title="Long">low</span>, <span title="Long">high</span> <span title="(x: Long)Long">&amp;</span> <span title="=&gt; Long">~</span><span class="delimiter">(</span><span title="Long(1L)" class="long">1L</span> <span title="(x: Int)Long">&lt;&lt;</span> <span title="=&gt; Int">c</span><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;MaskBased.--(b384d6b92a).$anonfun.x">x</a>, _<span class="delimiter">)</span>                              ⇒ <a href="#org.parboiled2.CharPredicate;MaskBased.--(b384d6b92a).$anonfun.x" title="org.parboiled2.CharPredicate">x</a> <span class="comment">// once the fold acc is not a MaskBased we are done</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span> else this

    def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;MaskBased.intersect">intersect</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;MaskBased.intersect.that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span> = <a href="#org.parboiled2.CharPredicate;MaskBased.intersect.that" title="org.parboiled2.CharPredicate">that</a> match <span class="delimiter">{</span>
      case <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>                ⇒ <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>
      case _ if this <span title="(x$1: Any)Boolean">==</span> <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>   ⇒ <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>
      case MaskBased<span class="delimiter">(</span><a title="Long" id="org.parboiled2.CharPredicate;MaskBased.intersect.low">low</a>, <a title="Long" id="org.parboiled2.CharPredicate;MaskBased.intersect.high">high</a><span class="delimiter">)</span> ⇒ <a href="#org.parboiled2.CharPredicate.MaskBased.readResolve" title="(lowMask: Long, highMask: Long)org.parboiled2.CharPredicate.MaskBased">MaskBased</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.lowMask" title="=&gt; Long">lowMask</a> <span title="(x: Long)Long">&amp;</span> <a href="#org.parboiled2.CharPredicate;MaskBased.intersect.low" title="Long">low</a>, <a href="#org.parboiled2.CharPredicate;MaskBased.highMask" title="=&gt; Long">highMask</a> <span title="(x: Long)Long">&amp;</span> <a href="#org.parboiled2.CharPredicate;MaskBased.intersect.high" title="Long">high</a><span class="delimiter">)</span>
      case _                    ⇒ this <a href="#org.parboiled2;CharPredicate.and" title="(that: Char =&gt; Boolean)org.parboiled2.CharPredicate">and</a> <a href="#org.parboiled2.CharPredicate;MaskBased.intersect.that" title="org.parboiled2.CharPredicate">that</a>
    <span class="delimiter">}</span>

    def <a title="=&gt; Int" id="org.parboiled2.CharPredicate;MaskBased.size">size</a>: <span title="Int">Int</span> = java.lang.<span title="Long.type">Long</span>.<span title="(x$1: Long)Int">bitCount</span><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.lowMask" title="=&gt; Long">lowMask</a><span class="delimiter">)</span> <span title="(x: Int)Int">+</span> java.lang.<span title="Long.type">Long</span>.<span title="(x$1: Long)Int">bitCount</span><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.highMask" title="=&gt; Long">highMask</a><span class="delimiter">)</span>

    def <a title="=&gt; Array[Char]" id="org.parboiled2.CharPredicate;MaskBased.toArray">toArray</a>: <span title="Array[Char]">Array</span><span class="delimiter">[</span>Char<span class="delimiter">]</span> = <span class="delimiter">{</span>
      val <a title="Array[Char]" id="org.parboiled2.CharPredicate;MaskBased.toArray.array">array</a> = new <span title="Array[Char]">Array</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.size" title="=&gt; Int">size</a><span class="delimiter">)</span>
      <a href="#org.parboiled2.CharPredicate;MaskBased.getChars" title="(array: Array[Char], startIx: Int)Unit">getChars</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.toArray.array" title="Array[Char]">array</a>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
      <a href="#org.parboiled2.CharPredicate;MaskBased.toArray.array" title="Array[Char]">array</a>
    <span class="delimiter">}</span>

    def <a title="(array: Array[Char], startIx: Int)Unit" id="org.parboiled2.CharPredicate;MaskBased.getChars">getChars</a><span class="delimiter">(</span><a title="Array[Char]" id="org.parboiled2.CharPredicate;MaskBased.getChars.array">array</a>: <span title="Array[Char]">Array</span><span class="delimiter">[</span>Char<span class="delimiter">]</span>, <a title="Int" id="org.parboiled2.CharPredicate;MaskBased.getChars.startIx">startIx</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
      @tailrec def <a title="(mask: Long, offset: Int, bit: Int, ix: Int)Int" id="org.parboiled2.CharPredicate;MaskBased.getChars.rec">rec</a><span class="delimiter">(</span><a title="Long" id="org.parboiled2.CharPredicate;MaskBased.getChars.rec.mask">mask</a>: <span title="Long">Long</span>, <a title="Int" id="org.parboiled2.CharPredicate;MaskBased.getChars.rec.offset">offset</a>: <span title="Int">Int</span>, <a title="Int" id="org.parboiled2.CharPredicate;MaskBased.getChars.rec.bit">bit</a>: <span title="Int">Int</span>, <a title="Int" id="org.parboiled2.CharPredicate;MaskBased.getChars.rec.ix">ix</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <span title="Int">Int</span> =
        if <span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.bit" title="Int">bit</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(64)" class="int">64</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.ix" title="Int">ix</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.array" title="Array[Char]">array</a>.<span title="=&gt; Int">length</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          if <span class="delimiter">(</span><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.mask" title="Long">mask</a> <span title="(x: Long)Long">&amp;</span> <span class="delimiter">(</span><span title="Long(1L)" class="long">1L</span> <span title="(x: Int)Long">&lt;&lt;</span> <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.bit" title="Int">bit</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.array" title="(i: Int, x: Char)Unit">array</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.ix" title="Int">ix</a><span class="delimiter">)</span> = <span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.offset" title="Int">offset</a> <span title="(x: Int)Int">+</span> <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.bit" title="Int">bit</a><span class="delimiter">)</span>.<span title="=&gt; Char">toChar</span>
            <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec" title="(mask: Long, offset: Int, bit: Int, ix: Int)Int">rec</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.mask" title="Long">mask</a>, <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.offset" title="Int">offset</a>, <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.bit" title="Int">bit</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.ix" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
          <span class="delimiter">}</span> else <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec" title="(mask: Long, offset: Int, bit: Int, ix: Int)Int">rec</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.mask" title="Long">mask</a>, <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.offset" title="Int">offset</a>, <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.bit" title="Int">bit</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.ix" title="Int">ix</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> else <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec.ix" title="Int">ix</a>
      <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec" title="(mask: Long, offset: Int, bit: Int, ix: Int)Int">rec</a><span title="Unit" class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.highMask" title="=&gt; Long">highMask</a>, <span title="Int(64)" class="int">64</span>, java.lang.<span title="Long.type">Long</span>.<span title="(x$1: Long)Int">numberOfTrailingZeros</span><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.highMask" title="=&gt; Long">highMask</a><span class="delimiter">)</span>,
        <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.rec" title="(mask: Long, offset: Int, bit: Int, ix: Int)Int">rec</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.lowMask" title="=&gt; Long">lowMask</a>, <span title="Int(0)" class="int">0</span>, java.lang.<span title="Long.type">Long</span>.<span title="(x$1: Long)Int">numberOfTrailingZeros</span><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.lowMask" title="=&gt; Long">lowMask</a><span class="delimiter">)</span>, <a href="#org.parboiled2.CharPredicate;MaskBased.getChars.startIx" title="Int">startIx</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    override def <a title="()String" id="org.parboiled2.CharPredicate;MaskBased.toString">toString</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="String">String</span> = <span title="String(&quot;CharPredicate.MaskBased(&quot;)" class="string">&quot;CharPredicate.MaskBased(&quot;</span> <span title="(x$1: Any)String">+</span> new <span title="String">String</span><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;MaskBased.toArray" title="=&gt; Array[Char]">toArray</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="Char(')')" class="char">')'</span>
  <span class="delimiter">}</span>

  class <a title="class RangeBased extends org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;RangeBased">RangeBased</a> private<span class="delimiter">[</span>CharPredicate<span class="delimiter">]</span> <span class="delimiter">(</span>private val <a title="scala.collection.immutable.NumericRange[Char]" id="org.parboiled2.CharPredicate;RangeBased.range">range</a>: <span title="scala.collection.immutable.NumericRange[Char]">NumericRange</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> <span class="delimiter">{</span>
    def <a title="(c: Char)Boolean" id="org.parboiled2.CharPredicate;RangeBased.apply">apply</a><span class="delimiter">(</span><a title="Char" id="org.parboiled2.CharPredicate;RangeBased.apply.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#org.parboiled2.CharPredicate;RangeBased.range" title="=&gt; scala.collection.immutable.NumericRange[Char]">range</a> <span title="(x: Char)Boolean">contains</span> <a href="#org.parboiled2.CharPredicate;RangeBased.apply.c" title="Char">c</a>

    def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;RangeBased.++(43717f9371)">++</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;RangeBased.++(43717f9371).that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = <a href="#org.parboiled2.CharPredicate;RangeBased.++(43717f9371).that" title="org.parboiled2.CharPredicate">that</a> match <span class="delimiter">{</span>
      case <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a> ⇒ this
      case _     ⇒ this <a href="#org.parboiled2;CharPredicate.or" title="(that: Char =&gt; Boolean)org.parboiled2.CharPredicate">or</a> <a href="#org.parboiled2.CharPredicate;RangeBased.++(43717f9371).that" title="org.parboiled2.CharPredicate">that</a>
    <span class="delimiter">}</span>

    def <a title="(other: Seq[Char])org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;RangeBased.++(e71c101a7c)">++</a><span class="delimiter">(</span><a title="Seq[Char]" id="org.parboiled2.CharPredicate;RangeBased.++(e71c101a7c).other">other</a>: <span title="Seq[Char]">Seq</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = if <span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;RangeBased.++(e71c101a7c).other" title="Seq[Char]">other</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> this <a href="#org.parboiled2.CharPredicate;RangeBased.++(43717f9371)" title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate">++</a> <a href="#org.parboiled2.CharPredicate.apply" title="(magnets: org.parboiled2.CharPredicate.ApplyMagnet*)org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars" title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromChars : (chars: Seq[Char])org.parboiled2.CharPredicate.ApplyMagnet">other</a><span class="delimiter">)</span> else this

    def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;RangeBased.--(43717f9371)">--</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;RangeBased.--(43717f9371).that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = <a href="#org.parboiled2.CharPredicate;RangeBased.--(43717f9371).that" title="org.parboiled2.CharPredicate">that</a> match <span class="delimiter">{</span>
      case <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a> ⇒ this
      case _     ⇒ this <a href="#org.parboiled2;CharPredicate.andNot" title="(that: Char =&gt; Boolean)org.parboiled2.CharPredicate">andNot</a> <a href="#org.parboiled2.CharPredicate;RangeBased.--(43717f9371).that" title="org.parboiled2.CharPredicate">that</a>
    <span class="delimiter">}</span>

    def <a title="(other: Seq[Char])org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;RangeBased.--(e71c101a7c)">--</a><span class="delimiter">(</span><a title="Seq[Char]" id="org.parboiled2.CharPredicate;RangeBased.--(e71c101a7c).other">other</a>: <span title="Seq[Char]">Seq</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = if <span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;RangeBased.--(e71c101a7c).other" title="Seq[Char]">other</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> this <a href="#org.parboiled2.CharPredicate;RangeBased.--(43717f9371)" title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate">--</a> <a href="#org.parboiled2.CharPredicate.apply" title="(magnets: org.parboiled2.CharPredicate.ApplyMagnet*)org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate.ApplyMagnet.fromChars" title="implicit org.parboiled2.CharPredicate.ApplyMagnet.fromChars : (chars: Seq[Char])org.parboiled2.CharPredicate.ApplyMagnet">other</a><span class="delimiter">)</span> else this

    def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;RangeBased.intersect">intersect</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;RangeBased.intersect.that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = <a href="#org.parboiled2.CharPredicate;RangeBased.intersect.that" title="org.parboiled2.CharPredicate">that</a> match <span class="delimiter">{</span>
      case <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a> ⇒ <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>
      case _     ⇒ this <a href="#org.parboiled2;CharPredicate.and" title="(that: Char =&gt; Boolean)org.parboiled2.CharPredicate">and</a> <a href="#org.parboiled2.CharPredicate;RangeBased.intersect.that" title="org.parboiled2.CharPredicate">that</a>
    <span class="delimiter">}</span>

    override def <a title="()String" id="org.parboiled2.CharPredicate;RangeBased.toString">toString</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="String">String</span> = <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;CharPredicate.RangeBased(start = &quot;)">CharPredicate.RangeBased(start = $</span><span class="delimiter">{</span><a href="#org.parboiled2.CharPredicate;RangeBased.range" title="=&gt; scala.collection.immutable.NumericRange[Char]">range</a>.<span title="=&gt; Char">start</span><span class="delimiter">}</span><span title="String(&quot;, end = &quot;)">, end = $</span><span class="delimiter">{</span><a href="#org.parboiled2.CharPredicate;RangeBased.range" title="=&gt; scala.collection.immutable.NumericRange[Char]">range</a>.<span title="=&gt; Char">end</span><span class="delimiter">}</span><span title="String(&quot;, &quot;)" class="string">, &quot;</span> <span title="(x$1: Any)String">+</span>
      <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;step = &quot;)">step = $</span><span class="delimiter">{</span><a href="#org.parboiled2.CharPredicate;RangeBased.range" title="=&gt; scala.collection.immutable.NumericRange[Char]">range</a>.<span title="=&gt; Char">step</span>.<span title="=&gt; Int">toInt</span><span class="delimiter">}</span><span title="String(&quot;, inclusive = &quot;)">, inclusive = $</span><span class="delimiter">{</span><a href="#org.parboiled2.CharPredicate;RangeBased.range" title="=&gt; scala.collection.immutable.NumericRange[Char]">range</a>.<span title="=&gt; Boolean">isInclusive</span><span class="delimiter">}</span><span title="String(&quot;)&quot;)" class="string">)&quot;</span>
  <span class="delimiter">}</span>

  class <a title="class ArrayBased extends org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;ArrayBased">ArrayBased</a> private<span class="delimiter">[</span>CharPredicate<span class="delimiter">]</span> <span class="delimiter">(</span>private val <a title="Array[Char]" id="org.parboiled2.CharPredicate;ArrayBased.chars">chars</a>: <span title="Array[Char]">Array</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> <span class="delimiter">{</span>
    import java.util.<span title="java.util.Arrays.type">Arrays</span>._
    <span title="(x$1: Array[Char])Unit">sort</span><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;ArrayBased.chars" title="=&gt; Array[Char]">chars</a><span class="delimiter">)</span>

    <span class="comment">// TODO: switch to faster binary search algorithm with an adaptive pivot, e.g. http://ochafik.com/blog/?p=106</span>
    def <a title="(c: Char)Boolean" id="org.parboiled2.CharPredicate;ArrayBased.apply">apply</a><span class="delimiter">(</span><a title="Char" id="org.parboiled2.CharPredicate;ArrayBased.apply.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <span title="(x$1: Array[Char], x$2: Char)Int">binarySearch</span><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;ArrayBased.chars" title="=&gt; Array[Char]">chars</a>, <a href="#org.parboiled2.CharPredicate;ArrayBased.apply.c" title="Char">c</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span>

    def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;ArrayBased.++(43717f9371)">++</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;ArrayBased.++(43717f9371).that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = <a href="#org.parboiled2.CharPredicate;ArrayBased.++(43717f9371).that" title="org.parboiled2.CharPredicate">that</a> match <span class="delimiter">{</span>
      case <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>         ⇒ this
      case <a title="org.parboiled2.CharPredicate.ArrayBased" id="org.parboiled2.CharPredicate;ArrayBased.++(43717f9371).x">x</a>: <a href="#org.parboiled2.CharPredicate;ArrayBased" title="org.parboiled2.CharPredicate.ArrayBased">ArrayBased</a> ⇒ this <a href="#org.parboiled2.CharPredicate;ArrayBased.++(e71c101a7c)" title="(other: Seq[Char])org.parboiled2.CharPredicate">++</a> <a href="#org.parboiled2.CharPredicate;ArrayBased.++(43717f9371).x" title="org.parboiled2.CharPredicate.ArrayBased">x</a>.<a href="#org.parboiled2.CharPredicate;ArrayBased.chars" title="implicit scala.LowPriorityImplicits.wrapCharArray : (xs: Array[Char])scala.collection.mutable.WrappedArray[Char]">chars</a>
      case _             ⇒ this <a href="#org.parboiled2;CharPredicate.or" title="(that: Char =&gt; Boolean)org.parboiled2.CharPredicate">or</a> <a href="#org.parboiled2.CharPredicate;ArrayBased.++(43717f9371).that" title="org.parboiled2.CharPredicate">that</a>
    <span class="delimiter">}</span>

    def <a title="(other: Seq[Char])org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;ArrayBased.++(e71c101a7c)">++</a><span class="delimiter">(</span><a title="Seq[Char]" id="org.parboiled2.CharPredicate;ArrayBased.++(e71c101a7c).other">other</a>: <span title="Seq[Char]">Seq</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> =
      if <span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;ArrayBased.++(e71c101a7c).other" title="Seq[Char]">other</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> new <a href="#org.parboiled2.CharPredicate;ArrayBased" title="org.parboiled2.CharPredicate.ArrayBased">ArrayBased</a><span class="delimiter">(</span><span class="delimiter">(</span>this <a href="#org.parboiled2.CharPredicate;ArrayBased.--(638896923c)" title="(other: Seq[Char])org.parboiled2.CharPredicate.ArrayBased">--</a> <a href="#org.parboiled2.CharPredicate;ArrayBased.++(e71c101a7c).other" title="Seq[Char]">other</a><span class="delimiter">)</span>.<a href="#org.parboiled2.CharPredicate;ArrayBased.chars" title="implicit scala.Predef.charArrayOps : (xs: Array[Char])scala.collection.mutable.ArrayOps[Char]">chars</a> <span title="(that: scala.collection.GenTraversableOnce[Char])(implicit bf: scala.collection.generic.CanBuildFrom[Array[Char],Char,Array[Char]])Array[Char]">++</span> <a href="#org.parboiled2.CharPredicate;ArrayBased.++(e71c101a7c).other" title="Seq[Char]">other</a>.<span title="[B &gt;: Char](implicit evidence$1: scala.reflect.ClassTag[B])Array[B]">toArray</span><span title="implicit scala.Predef.charArrayOps : (xs: Array[Char])scala.collection.mutable.ArrayOps[Char]" class="delimiter">[</span><span title="Char">Char</span><span class="delimiter">]</span><span class="delimiter">)</span>
      else this

    def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;ArrayBased.--(43717f9371)">--</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;ArrayBased.--(43717f9371).that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = <a href="#org.parboiled2.CharPredicate;ArrayBased.--(43717f9371).that" title="org.parboiled2.CharPredicate">that</a> match <span class="delimiter">{</span>
      case <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>         ⇒ this
      case <a title="org.parboiled2.CharPredicate.ArrayBased" id="org.parboiled2.CharPredicate;ArrayBased.--(43717f9371).x">x</a>: <a href="#org.parboiled2.CharPredicate;ArrayBased" title="org.parboiled2.CharPredicate.ArrayBased">ArrayBased</a> ⇒ this <a href="#org.parboiled2.CharPredicate;ArrayBased.--(638896923c)" title="(other: Seq[Char])org.parboiled2.CharPredicate.ArrayBased">--</a> <a href="#org.parboiled2.CharPredicate;ArrayBased.--(43717f9371).x" title="org.parboiled2.CharPredicate.ArrayBased">x</a>.<a href="#org.parboiled2.CharPredicate;ArrayBased.chars" title="implicit scala.LowPriorityImplicits.wrapCharArray : (xs: Array[Char])scala.collection.mutable.WrappedArray[Char]">chars</a>
      case _             ⇒ this <a href="#org.parboiled2;CharPredicate.andNot" title="(that: Char =&gt; Boolean)org.parboiled2.CharPredicate">andNot</a> <a href="#org.parboiled2.CharPredicate;ArrayBased.--(43717f9371).that" title="org.parboiled2.CharPredicate">that</a>
    <span class="delimiter">}</span>

    def <a title="(other: Seq[Char])org.parboiled2.CharPredicate.ArrayBased" id="org.parboiled2.CharPredicate;ArrayBased.--(638896923c)">--</a><span class="delimiter">(</span><a title="Seq[Char]" id="org.parboiled2.CharPredicate;ArrayBased.--(638896923c).other">other</a>: <span title="Seq[Char]">Seq</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2.CharPredicate;ArrayBased" title="org.parboiled2.CharPredicate.ArrayBased">ArrayBased</a> =
      if <span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;ArrayBased.--(638896923c).other" title="Seq[Char]">other</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="Array[Char]" id="org.parboiled2.CharPredicate;ArrayBased.--(638896923c).otherChars">otherChars</a> = <a href="#org.parboiled2.CharPredicate;ArrayBased.--(638896923c).other" title="Seq[Char]">other</a>.<span title="(implicit evidence$1: scala.reflect.ClassTag[Char])Array[Char]">toArray</span>
        new <a href="#org.parboiled2.CharPredicate;ArrayBased" title="org.parboiled2.CharPredicate.ArrayBased">ArrayBased</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;ArrayBased.chars" title="implicit scala.Predef.charArrayOps : (xs: Array[Char])scala.collection.mutable.ArrayOps[Char]">chars</a>.<span title="(p: Char =&gt; Boolean)Array[Char]">filter</span><span class="delimiter">(</span><span title="(x$1: Array[Char], x$2: Char)Int">binarySearch</span><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;ArrayBased.--(638896923c).otherChars" title="Array[Char]">otherChars</a>, <a href="#org.parboiled2.CharPredicate;ArrayBased.--(638896923c).$anonfun.x$6" title="Char">_</a><span class="delimiter">)</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else this

    def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;ArrayBased.intersect">intersect</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;ArrayBased.intersect.that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = <a href="#org.parboiled2.CharPredicate;ArrayBased.intersect.that" title="org.parboiled2.CharPredicate">that</a> match <span class="delimiter">{</span>
      case <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>         ⇒ <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>
      case <a title="org.parboiled2.CharPredicate.ArrayBased" id="org.parboiled2.CharPredicate;ArrayBased.intersect.x">x</a>: <a href="#org.parboiled2.CharPredicate;ArrayBased" title="org.parboiled2.CharPredicate.ArrayBased">ArrayBased</a> ⇒ new <a href="#org.parboiled2.CharPredicate;ArrayBased" title="org.parboiled2.CharPredicate.ArrayBased">ArrayBased</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;ArrayBased.chars" title="implicit scala.Predef.charArrayOps : (xs: Array[Char])scala.collection.mutable.ArrayOps[Char]">chars</a>.<span title="(that: scala.collection.GenSeq[Char])Array[Char]">intersect</span><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;ArrayBased.intersect.x" title="org.parboiled2.CharPredicate.ArrayBased">x</a>.<a href="#org.parboiled2.CharPredicate;ArrayBased.chars" title="implicit scala.LowPriorityImplicits.wrapCharArray : (xs: Array[Char])scala.collection.mutable.WrappedArray[Char]">chars</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case _             ⇒ this <a href="#org.parboiled2;CharPredicate.and" title="(that: Char =&gt; Boolean)org.parboiled2.CharPredicate">and</a> <a href="#org.parboiled2.CharPredicate;ArrayBased.intersect.that" title="org.parboiled2.CharPredicate">that</a>
    <span class="delimiter">}</span>

    override def <a title="()String" id="org.parboiled2.CharPredicate;ArrayBased.toString">toString</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="String">String</span> = <span title="String(&quot;CharPredicate.ArrayBased(&quot;)" class="string">&quot;CharPredicate.ArrayBased(&quot;</span> <span title="(x$1: Any)String">+</span> new <span title="String">String</span><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;ArrayBased.chars" title="=&gt; Array[Char]">chars</a><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="Char(')')" class="char">')'</span>
  <span class="delimiter">}</span>

  case class <a title="class General extends org.parboiled2.CharPredicate with Product with Serializable" id="org.parboiled2.CharPredicate.General.readResolve">General</a> private<span class="delimiter">[</span>CharPredicate<span class="delimiter">]</span> <span class="delimiter">(</span><a title="Char =&gt; Boolean" id="org.parboiled2.CharPredicate;General.predicate">predicate</a>: Char ⇒ Boolean<span class="delimiter">)</span> extends <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> <span class="delimiter">{</span>
    def <a title="(c: Char)Boolean" id="org.parboiled2.CharPredicate;General.apply">apply</a><span class="delimiter">(</span><a title="Char" id="org.parboiled2.CharPredicate;General.apply.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#org.parboiled2.CharPredicate;General.predicate" title="(v1: Char)Boolean">predicate</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;General.apply.c" title="Char">c</a><span class="delimiter">)</span>

    def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;General.++(43717f9371)">++</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;General.++(43717f9371).that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = <a href="#org.parboiled2.CharPredicate;General.++(43717f9371).that" title="org.parboiled2.CharPredicate">that</a> match <span class="delimiter">{</span>
      case <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>                  ⇒ this
      case General<span class="delimiter">(</span><a title="Char =&gt; Boolean" id="org.parboiled2.CharPredicate;General.++(43717f9371).thatPredicate">thatPredicate</a><span class="delimiter">)</span> ⇒ <a href="#org.parboiled2.CharPredicate.from" title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate">from</a><span class="delimiter">(</span><span title="Char">c</span> ⇒ <a href="#org.parboiled2.CharPredicate;General.predicate" title="(v1: Char)Boolean">predicate</a><span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.parboiled2.CharPredicate;General.++(43717f9371).thatPredicate" title="(v1: Char)Boolean">thatPredicate</a><span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case _                      ⇒ <a href="#org.parboiled2.CharPredicate.from" title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate">from</a><span class="delimiter">(</span><span title="Char">c</span> ⇒ <a href="#org.parboiled2.CharPredicate;General.predicate" title="(v1: Char)Boolean">predicate</a><span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.parboiled2.CharPredicate;General.++(43717f9371).that" title="(v1: Char)Boolean">that</a><span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    def <a title="(chars: Seq[Char])org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;General.++(b384d6b92a)">++</a><span class="delimiter">(</span><a title="Seq[Char]" id="org.parboiled2.CharPredicate;General.++(b384d6b92a).chars">chars</a>: <span title="Seq[Char]">Seq</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> =
      if <span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;General.++(b384d6b92a).chars" title="Seq[Char]">chars</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="org.parboiled2.CharPredicate.ArrayBased" id="org.parboiled2.CharPredicate;General.++(b384d6b92a).abp">abp</a> = new <a href="#org.parboiled2.CharPredicate;ArrayBased" title="org.parboiled2.CharPredicate.ArrayBased">ArrayBased</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;General.++(b384d6b92a).chars" title="Seq[Char]">chars</a>.<span title="(implicit evidence$1: scala.reflect.ClassTag[Char])Array[Char]">toArray</span><span class="delimiter">)</span>
        <a href="#org.parboiled2.CharPredicate.from" title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate">from</a><span class="delimiter">(</span><a title="Char" id="org.parboiled2.CharPredicate;General.++(b384d6b92a).$anonfun.c">c</a> ⇒ <a href="#org.parboiled2.CharPredicate;General.predicate" title="(v1: Char)Boolean">predicate</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;General.++(b384d6b92a).$anonfun.c" title="Char">c</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#org.parboiled2.CharPredicate;ArrayBased.apply" title="(c: Char)Boolean">abp</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;General.++(b384d6b92a).$anonfun.c" title="Char">c</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else this

    def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;General.--(43717f9371)">--</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;General.--(43717f9371).that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> = <a href="#org.parboiled2.CharPredicate;General.--(43717f9371).that" title="org.parboiled2.CharPredicate">that</a> match <span class="delimiter">{</span>
      case <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>                  ⇒ this
      case General<span class="delimiter">(</span><a title="Char =&gt; Boolean" id="org.parboiled2.CharPredicate;General.--(43717f9371).thatPredicate">thatPredicate</a><span class="delimiter">)</span> ⇒ <a href="#org.parboiled2.CharPredicate.from" title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate">from</a><span class="delimiter">(</span><span title="Char">c</span> ⇒ <a href="#org.parboiled2.CharPredicate;General.predicate" title="(v1: Char)Boolean">predicate</a><span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#org.parboiled2.CharPredicate;General.--(43717f9371).thatPredicate" title="(v1: Char)Boolean">thatPredicate</a><span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case _                      ⇒ <a href="#org.parboiled2.CharPredicate.from" title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate">from</a><span class="delimiter">(</span><span title="Char">c</span> ⇒ <a href="#org.parboiled2.CharPredicate;General.predicate" title="(v1: Char)Boolean">predicate</a><span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#org.parboiled2.CharPredicate;General.--(43717f9371).that" title="(v1: Char)Boolean">that</a><span class="delimiter">(</span><span title="Char">c</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    def <a title="(chars: Seq[Char])org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;General.--(b384d6b92a)">--</a><span class="delimiter">(</span><a title="Seq[Char]" id="org.parboiled2.CharPredicate;General.--(b384d6b92a).chars">chars</a>: <span title="Seq[Char]">Seq</span><span class="delimiter">[</span>Char<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a> =
      if <span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;General.--(b384d6b92a).chars" title="Seq[Char]">chars</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="org.parboiled2.CharPredicate.ArrayBased" id="org.parboiled2.CharPredicate;General.--(b384d6b92a).abp">abp</a> = new <a href="#org.parboiled2.CharPredicate;ArrayBased" title="org.parboiled2.CharPredicate.ArrayBased">ArrayBased</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;General.--(b384d6b92a).chars" title="Seq[Char]">chars</a>.<span title="(implicit evidence$1: scala.reflect.ClassTag[Char])Array[Char]">toArray</span><span class="delimiter">)</span>
        <a href="#org.parboiled2.CharPredicate.from" title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate">from</a><span class="delimiter">(</span><a title="Char" id="org.parboiled2.CharPredicate;General.--(b384d6b92a).$anonfun.c">c</a> ⇒ <a href="#org.parboiled2.CharPredicate;General.predicate" title="(v1: Char)Boolean">predicate</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;General.--(b384d6b92a).$anonfun.c" title="Char">c</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#org.parboiled2.CharPredicate;ArrayBased.apply" title="(c: Char)Boolean">abp</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;General.--(b384d6b92a).$anonfun.c" title="Char">c</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else this

    def <a title="(that: org.parboiled2.CharPredicate)org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;General.intersect">intersect</a><span class="delimiter">(</span><a title="org.parboiled2.CharPredicate" id="org.parboiled2.CharPredicate;General.intersect.that">that</a>: <a href="#org.parboiled2;CharPredicate" title="org.parboiled2.CharPredicate">CharPredicate</a><span class="delimiter">)</span> = <a href="#org.parboiled2.CharPredicate;General.intersect.that" title="org.parboiled2.CharPredicate">that</a> match <span class="delimiter">{</span>
      case <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>                  ⇒ <a href="#org.parboiled2.CharPredicate.Empty" title="=&gt; org.parboiled2.CharPredicate">Empty</a>
      case General<span class="delimiter">(</span><a title="Char =&gt; Boolean" id="org.parboiled2.CharPredicate;General.intersect.thatPredicate">thatPredicate</a><span class="delimiter">)</span> ⇒ <a href="#org.parboiled2.CharPredicate.from" title="(predicate: Char =&gt; Boolean)org.parboiled2.CharPredicate">from</a><span class="delimiter">(</span><a title="Char" id="org.parboiled2.CharPredicate;General.intersect.$anonfun.c">c</a> ⇒ <a href="#org.parboiled2.CharPredicate;General.predicate" title="(v1: Char)Boolean">predicate</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;General.intersect.$anonfun.c" title="Char">c</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#org.parboiled2.CharPredicate;General.intersect.that" title="(v1: Char)Boolean">that</a><span class="delimiter">(</span><a href="#org.parboiled2.CharPredicate;General.intersect.$anonfun.c" title="Char">c</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case _                      ⇒ this <a href="#org.parboiled2;CharPredicate.and" title="(that: Char =&gt; Boolean)org.parboiled2.CharPredicate">and</a> <a href="#org.parboiled2.CharPredicate;General.intersect.that" title="org.parboiled2.CharPredicate">that</a>
    <span class="delimiter">}</span>

    override def <a title="()String" id="org.parboiled2.CharPredicate;General.toString">toString</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="String">String</span> = <span title="String(&quot;CharPredicate.General@&quot;)" class="string">&quot;CharPredicate.General@&quot;</span> <span title="(x$1: Any)String">+</span> <span title="System.type">System</span>.<span title="(x$1: Any)Int">identityHashCode</span><span class="delimiter">(</span>this<span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
