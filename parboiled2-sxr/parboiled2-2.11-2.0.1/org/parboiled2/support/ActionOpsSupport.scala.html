<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>org/parboiled2/support/ActionOpsSupport.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (C) 2009-2013 Mathias Doenitz, Alexander Myltsev
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package org.parboiled2.support

import shapeless._
import org.parboiled2.Rule
import shapeless.ops.<span title="shapeless.ops.hlist.type">hlist</span>.ReversePrepend

<span class="comment">/*
 * The main ActionOps boilerplate is generated by a custom SBT sourceGenerator.
 * This file only contains support types.
 */</span>

<span class="comment">// we want to support the &quot;short case class notation&quot; `... ~&gt; Foo`</span>
<span class="comment">// unfortunately the Tree for the function argument to the `apply` overloads above does *not* allow us to inspect the</span>
<span class="comment">// function type which is why we capture it separately with this helper type</span>
sealed trait <a title="trait FCapture[T] extends AnyRef" id="org.parboiled2.support;FCapture">FCapture</a><span class="delimiter">[</span><a title="" id="org.parboiled2.support;FCapture;T">T</a><span class="delimiter">]</span>
object <a title="org.parboiled2.support.FCapture.type" id="org.parboiled2.support.FCapture">FCapture</a> <a href="#org.parboiled2.support.FCapture" title="org.parboiled2.support.FCapture.type" class="delimiter">{</a>
  implicit def <a title="[T]=&gt; org.parboiled2.support.FCapture[T]" id="org.parboiled2.support.FCapture.apply">apply</a><span class="delimiter">[</span><a title="" id="org.parboiled2.support.FCapture.apply;T">T</a><span class="delimiter">]</span>: <a href="#org.parboiled2.support;FCapture" title="org.parboiled2.support.FCapture[T]">FCapture</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>
<span class="delimiter">}</span>

<span class="comment">// builds `In` and `Out` types according to this logic:</span>
<span class="comment">//  if (R == Unit)</span>
<span class="comment">//    In = I, Out = L1 ::: L2</span>
<span class="comment">//  else if (R &lt;: HList)</span>
<span class="comment">//    In = I, Out = L1 ::: L2 ::: R</span>
<span class="comment">//  else if (R &lt;: Rule[I2, O2])</span>
<span class="comment">//    In = TailSwitch[I2, L1 ::: L2, I], Out = TailSwitch[L1 ::: L2, I2, O2]</span>
<span class="comment">//  else</span>
<span class="comment">//    In = I, Out = L1 ::: L2 ::: R :: HNil</span>
sealed trait <a title="trait Join[I &lt;: shapeless.HList, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList, R] extends AnyRef" id="org.parboiled2.support;Join">Join</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support;Join;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support;Join;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support;Join;L2">L2</a> &lt;: HList, <a title="" id="org.parboiled2.support;Join;R">R</a><span class="delimiter">]</span> <span class="delimiter">{</span>
  type <a title=" &lt;: shapeless.HList" id="org.parboiled2.support;Join;In">In</a> &lt;: HList
  type <a title=" &lt;: shapeless.HList" id="org.parboiled2.support;Join;Out">Out</a> &lt;: HList
<span class="delimiter">}</span>
object <a title="org.parboiled2.support.Join.type" id="org.parboiled2.support.Join">Join</a> <a href="#org.parboiled2.support.Join" title="org.parboiled2.support.Join.type" class="delimiter">{</a>
  implicit def <a title="[I &lt;: shapeless.HList, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList, R, In0 &lt;: shapeless.HList, Out0 &lt;: shapeless.HList](implicit x: org.parboiled2.support.Join.Aux[I,L1,L2,R,shapeless.HNil,In0,Out0])org.parboiled2.support.Join[I,L1,L2,R]{type In = In0; type Out = Out0}" id="org.parboiled2.support.Join.join">join</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.join;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.join;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.join;L2">L2</a> &lt;: HList, <a title="" id="org.parboiled2.support.Join.join;R">R</a>, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.join;In0">In0</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.join;Out0">Out0</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Join.Aux[I,L1,L2,R,shapeless.HNil,In0,Out0]" id="org.parboiled2.support.Join.join.x">x</a>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,L1,L2,R,shapeless.HNil,In0,Out0]">Aux</a><span class="delimiter">[</span>I, L1, L2, R, HNil, In0, Out0<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2.support.Join;<refinement>" title="&lt;refinement of org.parboiled2.support.Join[I,L1,L2,R]&gt; extends org.parboiled2.support.Join[I,L1,L2,R]">Join</a><span class="delimiter">[</span>I, L1, L2, R<span class="delimiter">]</span> <span class="delimiter">{</span> type In = In0; type Out = Out0 <span class="delimiter">}</span> = <a href="package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>

  sealed trait <a title="trait Aux[I &lt;: shapeless.HList, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList, R, Acc &lt;: shapeless.HList, In &lt;: shapeless.HList, Out &lt;: shapeless.HList] extends AnyRef" id="org.parboiled2.support.Join;Aux">Aux</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join;Aux;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join;Aux;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join;Aux;L2">L2</a> &lt;: HList, <a title="" id="org.parboiled2.support.Join;Aux;R">R</a>, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join;Aux;Acc">Acc</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join;Aux;In">In</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join;Aux;Out">Out</a> &lt;: HList<span class="delimiter">]</span>
  object <a title="org.parboiled2.support.Join.Aux.type" id="org.parboiled2.support.Join.Aux">Aux</a> extends <a href="#org.parboiled2.support.Join;Aux1" title="org.parboiled2.support.Join.Aux1">Aux1</a> <span class="delimiter">{</span>
    <span class="comment">// if R == Unit convert to HNil</span>
    implicit def <a title="[I &lt;: shapeless.HList, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList, Acc &lt;: shapeless.HList, Out &lt;: shapeless.HList](implicit x: org.parboiled2.support.Join.Aux[I,L1,L2,shapeless.HNil,Acc,I,Out])org.parboiled2.support.Join.Aux[I,L1,L2,Unit,Acc,I,Out]" id="org.parboiled2.support.Join.Aux.forUnit">forUnit</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.forUnit;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.forUnit;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.forUnit;L2">L2</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.forUnit;Acc">Acc</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.forUnit;Out">Out</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Join.Aux[I,L1,L2,shapeless.HNil,Acc,I,Out]" id="org.parboiled2.support.Join.Aux.forUnit.x">x</a>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,L1,L2,shapeless.HNil,Acc,I,Out]">Aux</a><span class="delimiter">[</span>I, L1, L2, HNil, Acc, I, Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,L1,L2,Unit,Acc,I,Out]">Aux</a><span class="delimiter">[</span>I, L1, L2, Unit, Acc, I, Out<span class="delimiter">]</span> = <a href="package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>

    <span class="comment">// if R &lt;: HList and L1 non-empty move head of L1 to Acc</span>
    implicit def <a title="[I &lt;: shapeless.HList, H, T &lt;: shapeless.HList, L2 &lt;: shapeless.HList, R &lt;: shapeless.HList, Acc &lt;: shapeless.HList, Out &lt;: shapeless.HList](implicit x: org.parboiled2.support.Join.Aux[I,T,L2,R,shapeless.::[H,Acc],I,Out])org.parboiled2.support.Join.Aux[I,shapeless.::[H,T],L2,R,Acc,I,Out]" id="org.parboiled2.support.Join.Aux.iter1">iter1</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iter1;I">I</a> &lt;: HList, <a title="" id="org.parboiled2.support.Join.Aux.iter1;H">H</a>, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iter1;T">T</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iter1;L2">L2</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iter1;R">R</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iter1;Acc">Acc</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iter1;Out">Out</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Join.Aux[I,T,L2,R,shapeless.::[H,Acc],I,Out]" id="org.parboiled2.support.Join.Aux.iter1.x">x</a>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,T,L2,R,shapeless.::[H,Acc],I,Out]">Aux</a><span class="delimiter">[</span>I, T, L2, R, H :: Acc, I, Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,shapeless.::[H,T],L2,R,Acc,I,Out]">Aux</a><span class="delimiter">[</span>I, H :: T, L2, R, Acc, I, Out<span class="delimiter">]</span> = <a href="package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>

    <span class="comment">// if R &lt;: HList and L1 empty and L2 non-empty move head of L2 to Acc</span>
    implicit def <a title="[I &lt;: shapeless.HList, H, T &lt;: shapeless.HList, R &lt;: shapeless.HList, Acc &lt;: shapeless.HList, Out &lt;: shapeless.HList](implicit x: org.parboiled2.support.Join.Aux[I,shapeless.HNil,T,R,shapeless.::[H,Acc],I,Out])org.parboiled2.support.Join.Aux[I,shapeless.HNil,shapeless.::[H,T],R,Acc,I,Out]" id="org.parboiled2.support.Join.Aux.iter2">iter2</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iter2;I">I</a> &lt;: HList, <a title="" id="org.parboiled2.support.Join.Aux.iter2;H">H</a>, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iter2;T">T</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iter2;R">R</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iter2;Acc">Acc</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iter2;Out">Out</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Join.Aux[I,shapeless.HNil,T,R,shapeless.::[H,Acc],I,Out]" id="org.parboiled2.support.Join.Aux.iter2.x">x</a>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,shapeless.HNil,T,R,shapeless.::[H,Acc],I,Out]">Aux</a><span class="delimiter">[</span>I, HNil, T, R, H :: Acc, I, Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,shapeless.HNil,shapeless.::[H,T],R,Acc,I,Out]">Aux</a><span class="delimiter">[</span>I, HNil, H :: T, R, Acc, I, Out<span class="delimiter">]</span> = <a href="package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>

    <span class="comment">// if R &lt;: HList and L1 and L2 empty set Out = reversePrepend Acc before R</span>
    implicit def <a title="[I &lt;: shapeless.HList, R &lt;: shapeless.HList, Acc &lt;: shapeless.HList, Out &lt;: shapeless.HList](implicit x: shapeless.ops.hlist.ReversePrepend.Aux[Acc,R,Out])org.parboiled2.support.Join.Aux[I,shapeless.HNil,shapeless.HNil,R,Acc,I,Out]" id="org.parboiled2.support.Join.Aux.terminate">terminate</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.terminate;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.terminate;R">R</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.terminate;Acc">Acc</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.terminate;Out">Out</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="shapeless.ops.hlist.ReversePrepend.Aux[Acc,R,Out]" id="org.parboiled2.support.Join.Aux.terminate.x">x</a>: ReversePrepend.<span title="shapeless.ops.hlist.ReversePrepend.Aux[Acc,R,Out]">Aux</span><span class="delimiter">[</span>Acc, R, Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,shapeless.HNil,shapeless.HNil,R,Acc,I,Out]">Aux</a><span class="delimiter">[</span>I, HNil, HNil, R, Acc, I, Out<span class="delimiter">]</span> = <a href="package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>

    <span class="comment">// if R &lt;: Rule and L1 non-empty move head of L1 to Acc</span>
    implicit def <a title="[I &lt;: shapeless.HList, L2 &lt;: shapeless.HList, I2 &lt;: shapeless.HList, O2 &lt;: shapeless.HList, In0 &lt;: shapeless.HList, Acc &lt;: shapeless.HList, Out0 &lt;: shapeless.HList, H, T &lt;: shapeless.HList](implicit x: org.parboiled2.support.Join.Aux[I,T,L2,org.parboiled2.Rule[I2,O2],shapeless.::[H,Acc],In0,Out0])org.parboiled2.support.Join.Aux[I,shapeless.::[H,T],L2,org.parboiled2.Rule[I2,O2],shapeless.HNil,In0,Out0]" id="org.parboiled2.support.Join.Aux.iterRule1">iterRule1</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule1;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule1;L2">L2</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule1;I2">I2</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule1;O2">O2</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule1;In0">In0</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule1;Acc">Acc</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule1;Out0">Out0</a> &lt;: HList, <a title="" id="org.parboiled2.support.Join.Aux.iterRule1;H">H</a>, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule1;T">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Join.Aux[I,T,L2,org.parboiled2.Rule[I2,O2],shapeless.::[H,Acc],In0,Out0]" id="org.parboiled2.support.Join.Aux.iterRule1.x">x</a>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,T,L2,org.parboiled2.Rule[I2,O2],shapeless.::[H,Acc],In0,Out0]">Aux</a><span class="delimiter">[</span>I, T, L2, Rule<span class="delimiter">[</span>I2, O2<span class="delimiter">]</span>, H :: Acc, In0, Out0<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,shapeless.::[H,T],L2,org.parboiled2.Rule[I2,O2],shapeless.HNil,In0,Out0]">Aux</a><span class="delimiter">[</span>I, H :: T, L2, Rule<span class="delimiter">[</span>I2, O2<span class="delimiter">]</span>, HNil, In0, Out0<span class="delimiter">]</span> = <a href="package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>

    <span class="comment">// if R &lt;: Rule and L1 empty and Acc non-empty move head of Acc to L2</span>
    implicit def <a title="[I &lt;: shapeless.HList, L2 &lt;: shapeless.HList, I2 &lt;: shapeless.HList, O2 &lt;: shapeless.HList, In0 &lt;: shapeless.HList, Out0 &lt;: shapeless.HList, H, T &lt;: shapeless.HList](implicit x: org.parboiled2.support.Join.Aux[I,shapeless.HNil,shapeless.::[H,L2],org.parboiled2.Rule[I2,O2],T,In0,Out0])org.parboiled2.support.Join.Aux[I,shapeless.HNil,L2,org.parboiled2.Rule[I2,O2],shapeless.::[H,T],In0,Out0]" id="org.parboiled2.support.Join.Aux.iterRule2">iterRule2</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule2;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule2;L2">L2</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule2;I2">I2</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule2;O2">O2</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule2;In0">In0</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule2;Out0">Out0</a> &lt;: HList, <a title="" id="org.parboiled2.support.Join.Aux.iterRule2;H">H</a>, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.iterRule2;T">T</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Join.Aux[I,shapeless.HNil,shapeless.::[H,L2],org.parboiled2.Rule[I2,O2],T,In0,Out0]" id="org.parboiled2.support.Join.Aux.iterRule2.x">x</a>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,shapeless.HNil,shapeless.::[H,L2],org.parboiled2.Rule[I2,O2],T,In0,Out0]">Aux</a><span class="delimiter">[</span>I, HNil, H :: L2, Rule<span class="delimiter">[</span>I2, O2<span class="delimiter">]</span>, T, In0, Out0<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,shapeless.HNil,L2,org.parboiled2.Rule[I2,O2],shapeless.::[H,T],In0,Out0]">Aux</a><span class="delimiter">[</span>I, HNil, L2, Rule<span class="delimiter">[</span>I2, O2<span class="delimiter">]</span>, H :: T, In0, Out0<span class="delimiter">]</span> = <a href="package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>

    <span class="comment">// if R &lt;: Rule and L1 and Acc empty set In and Out to tailswitches result</span>
    implicit def <a title="[I &lt;: shapeless.HList, O &lt;: shapeless.HList, I2 &lt;: shapeless.HList, O2 &lt;: shapeless.HList, In &lt;: shapeless.HList, Out &lt;: shapeless.HList](implicit i: org.parboiled2.support.TailSwitch.Aux[I2,I2,O,O,I,shapeless.HNil,In], implicit o: org.parboiled2.support.TailSwitch.Aux[O,O,I2,I2,O2,shapeless.HNil,Out])org.parboiled2.support.Join.Aux[I,shapeless.HNil,O,org.parboiled2.Rule[I2,O2],shapeless.HNil,In,Out]" id="org.parboiled2.support.Join.Aux.terminateRule">terminateRule</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.terminateRule;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.terminateRule;O">O</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.terminateRule;I2">I2</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.terminateRule;O2">O2</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.terminateRule;In">In</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join.Aux.terminateRule;Out">Out</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.TailSwitch.Aux[I2,I2,O,O,I,shapeless.HNil,In]" id="org.parboiled2.support.Join.Aux.terminateRule.i">i</a>: TailSwitch.<a href="TailSwitch.scala.html#org.parboiled2.support.TailSwitch;Aux" title="org.parboiled2.support.TailSwitch.Aux[I2,I2,O,O,I,shapeless.HNil,In]">Aux</a><span class="delimiter">[</span>I2, I2, O, O, I, HNil, In<span class="delimiter">]</span>, <a title="org.parboiled2.support.TailSwitch.Aux[O,O,I2,I2,O2,shapeless.HNil,Out]" id="org.parboiled2.support.Join.Aux.terminateRule.o">o</a>: TailSwitch.<a href="TailSwitch.scala.html#org.parboiled2.support.TailSwitch;Aux" title="org.parboiled2.support.TailSwitch.Aux[O,O,I2,I2,O2,shapeless.HNil,Out]">Aux</a><span class="delimiter">[</span>O, O, I2, I2, O2, HNil, Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,shapeless.HNil,O,org.parboiled2.Rule[I2,O2],shapeless.HNil,In,Out]">Aux</a><span class="delimiter">[</span>I, HNil, O, Rule<span class="delimiter">[</span>I2, O2<span class="delimiter">]</span>, HNil, In, Out<span class="delimiter">]</span> = <a href="package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>
  <span class="delimiter">}</span>
  abstract class <a title="class Aux1 extends AnyRef" id="org.parboiled2.support.Join;Aux1">Aux1</a> <a href="#org.parboiled2.support.Join;Aux1" title="org.parboiled2.support.Join.Aux1" class="delimiter">{</a>
    <span class="comment">// convert R to R :: HNil</span>
    implicit def <a title="[I &lt;: shapeless.HList, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList, R, Acc &lt;: shapeless.HList, Out &lt;: shapeless.HList](implicit x: org.parboiled2.support.Join.Aux[I,L1,L2,shapeless.::[R,shapeless.HNil],Acc,I,Out])org.parboiled2.support.Join.Aux[I,L1,L2,R,Acc,I,Out]" id="org.parboiled2.support.Join;Aux1.forAny">forAny</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join;Aux1.forAny;I">I</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join;Aux1.forAny;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join;Aux1.forAny;L2">L2</a> &lt;: HList, <a title="" id="org.parboiled2.support.Join;Aux1.forAny;R">R</a>, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join;Aux1.forAny;Acc">Acc</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Join;Aux1.forAny;Out">Out</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Join.Aux[I,L1,L2,shapeless.::[R,shapeless.HNil],Acc,I,Out]" id="org.parboiled2.support.Join;Aux1.forAny.x">x</a>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,L1,L2,shapeless.::[R,shapeless.HNil],Acc,I,Out]">Aux</a><span class="delimiter">[</span>I, L1, L2, R :: HNil, Acc, I, Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#org.parboiled2.support.Join;Aux" title="org.parboiled2.support.Join.Aux[I,L1,L2,R,Acc,I,Out]">Aux</a><span class="delimiter">[</span>I, L1, L2, R, Acc, I, Out<span class="delimiter">]</span> = <a href="package.scala.html#org.parboiled2.support.package.n/a" title="=&gt; Nothing">`n/a`</a>
  <span class="delimiter">}</span>
<a href="#org.parboiled2.support.Join;Aux1" title="AnyRef" class="delimiter">}</a>
        </pre>
    </body>
</html>
