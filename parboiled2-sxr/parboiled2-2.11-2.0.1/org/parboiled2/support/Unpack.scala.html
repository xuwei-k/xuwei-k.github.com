<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>org/parboiled2/support/Unpack.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (C) 2009-2013 Mathias Doenitz, Alexander Myltsev
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

package org.parboiled2.support

import shapeless._

<span class="comment">/**
 * &quot;Unpacks&quot; an HList if it has only zero or one element(s).
 *   Out =
 *     Unit  if L == HNil
 *     T     if L == T :: HNil
 *     L     otherwise
 *
 *  You can `import Unpack.dontUnpack` if you'd like to circumvent this unpacking logic.
 */</span>
sealed trait <a title="trait Unpack[L &lt;: shapeless.HList] extends AnyRef" id="org.parboiled2.support;Unpack">Unpack</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support;Unpack;L">L</a> &lt;: HList<span class="delimiter">]</span> <span class="delimiter">{</span>
  type <a title="" id="org.parboiled2.support;Unpack;Out">Out</a>
  def <a title="(hlist: L)Unpack.this.Out" id="org.parboiled2.support;Unpack.apply">apply</a><span class="delimiter">(</span><a title="L" id="org.parboiled2.support;Unpack.apply.hlist">hlist</a>: <a href="#org.parboiled2.support;Unpack;L" title="L">L</a><span class="delimiter">)</span>: <a href="#org.parboiled2.support;Unpack;Out" title="Unpack.this.Out">Out</a>
<span class="delimiter">}</span>

object <a title="org.parboiled2.support.Unpack.type" id="org.parboiled2.support.Unpack">Unpack</a> extends <a href="#org.parboiled2.support;AlternativeUnpacks" title="org.parboiled2.support.AlternativeUnpacks">AlternativeUnpacks</a> <span class="delimiter">{</span>

  implicit def <a title="[L &lt;: shapeless.HList, Out0](implicit aux: org.parboiled2.support.Unpack.Aux[L,Out0])org.parboiled2.support.Unpack[L]{type Out = Out0}" id="org.parboiled2.support.Unpack.fromAux">fromAux</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Unpack.fromAux;L">L</a> &lt;: HList, <a title="" id="org.parboiled2.support.Unpack.fromAux;Out0">Out0</a><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="org.parboiled2.support.Unpack.Aux[L,Out0]" id="org.parboiled2.support.Unpack.fromAux.aux">aux</a>: <a href="#org.parboiled2.support.Unpack;Aux" title="org.parboiled2.support.Unpack.Aux[L,Out0]">Aux</a><span class="delimiter">[</span>L, Out0<span class="delimiter">]</span><span class="delimiter">)</span> = new <a title="&lt;$anon: org.parboiled2.support.Unpack[L]&gt; extends AnyRef with org.parboiled2.support.Unpack[L]" id="org.parboiled2.support.Unpack.fromAux;$anon">Unpack</a><span class="delimiter">[</span>L<span class="delimiter">]</span> <span class="delimiter">{</span>
    type <a title="Out0" id="org.parboiled2.support.Unpack.fromAux;$anon;Out">Out</a> = <a href="#org.parboiled2.support.Unpack.fromAux;Out0" title="Out0">Out0</a>
    def <a title="(hlist: L)Out0" id="org.parboiled2.support.Unpack.fromAux;$anon.apply">apply</a><span class="delimiter">(</span><a title="L" id="org.parboiled2.support.Unpack.fromAux;$anon.apply.hlist">hlist</a>: <a href="#org.parboiled2.support.Unpack.fromAux;L" title="L">L</a><span class="delimiter">)</span> = <a href="#org.parboiled2.support.Unpack;Aux.apply" title="(hlist: L)Out0">aux</a><span class="delimiter">(</span><a href="#org.parboiled2.support.Unpack.fromAux;$anon.apply.hlist" title="L">hlist</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  sealed trait <a title="trait Aux[L &lt;: shapeless.HList, Out0] extends AnyRef" id="org.parboiled2.support.Unpack;Aux">Aux</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support.Unpack;Aux;L">L</a> &lt;: HList, <a title="" id="org.parboiled2.support.Unpack;Aux;Out0">Out0</a><span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="(hlist: L)Out0" id="org.parboiled2.support.Unpack;Aux.apply">apply</a><span class="delimiter">(</span><a title="L" id="org.parboiled2.support.Unpack;Aux.apply.hlist">hlist</a>: <a href="#org.parboiled2.support.Unpack;Aux;L" title="L">L</a><span class="delimiter">)</span>: <a href="#org.parboiled2.support.Unpack;Aux;Out0" title="Out0">Out0</a>
  <span class="delimiter">}</span>

  implicit def <a title="[L &lt;: shapeless.HNil]=&gt; org.parboiled2.support.Unpack.Aux[L,Unit]" id="org.parboiled2.support.Unpack.hnil">hnil</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HNil" id="org.parboiled2.support.Unpack.hnil;L">L</a> &lt;: HNil<span class="delimiter">]</span>: <a href="#org.parboiled2.support.Unpack;Aux" title="org.parboiled2.support.Unpack.Aux[L,Unit]">Aux</a><span class="delimiter">[</span>L, Unit<span class="delimiter">]</span> = <a href="#org.parboiled2.support.Unpack.HNilUnpack" title="org.parboiled2.support.Unpack.HNilUnpack.type">HNilUnpack</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="org.parboiled2.support.Unpack.Aux[L,Unit]" class="delimiter">[</span><a href="#org.parboiled2.support.Unpack;Aux" title="org.parboiled2.support.Unpack.Aux[L,Unit]">Aux</a><span class="delimiter">[</span>L, Unit<span class="delimiter">]</span><span class="delimiter">]</span>
  implicit object <a title="org.parboiled2.support.Unpack.HNilUnpack.type" id="org.parboiled2.support.Unpack.HNilUnpack">HNilUnpack</a> extends <a href="#org.parboiled2.support.Unpack;Aux" title="org.parboiled2.support.Unpack.Aux[shapeless.HNil,Unit]">Aux</a><span class="delimiter">[</span>HNil, Unit<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="(hlist: shapeless.HNil)Unit" id="org.parboiled2.support.Unpack.HNilUnpack.apply">apply</a><span class="delimiter">(</span><a title="shapeless.HNil" id="org.parboiled2.support.Unpack.HNilUnpack.apply.hlist">hlist</a>: <span title="shapeless.HNil">HNil</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  implicit def <a title="[T]=&gt; org.parboiled2.support.Unpack.Aux[shapeless.::[T,shapeless.HNil],T]" id="org.parboiled2.support.Unpack.single">single</a><span class="delimiter">[</span><a title="" id="org.parboiled2.support.Unpack.single;T">T</a><span class="delimiter">]</span>: <a href="#org.parboiled2.support.Unpack;Aux" title="org.parboiled2.support.Unpack.Aux[shapeless.::[T,shapeless.HNil],T]">Aux</a><span class="delimiter">[</span>T :: HNil, T<span class="delimiter">]</span> = <a href="#org.parboiled2.support.Unpack.SingleUnpack" title="org.parboiled2.support.Unpack.SingleUnpack.type">SingleUnpack</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="org.parboiled2.support.Unpack.Aux[shapeless.::[T,shapeless.HNil],T]" class="delimiter">[</span><a href="#org.parboiled2.support.Unpack;Aux" title="org.parboiled2.support.Unpack.Aux[shapeless.::[T,shapeless.HNil],T]">Aux</a><span class="delimiter">[</span>T :: HNil, T<span class="delimiter">]</span><span class="delimiter">]</span>
  private object <a title="org.parboiled2.support.Unpack.SingleUnpack.type" id="org.parboiled2.support.Unpack.SingleUnpack">SingleUnpack</a> extends <a href="#org.parboiled2.support.Unpack;Aux" title="org.parboiled2.support.Unpack.Aux[shapeless.::[Any,shapeless.HList],Any]">Aux</a><span class="delimiter">[</span>Any :: HList, Any<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="(hlist: shapeless.::[Any,shapeless.HList])Any" id="org.parboiled2.support.Unpack.SingleUnpack.apply">apply</a><span class="delimiter">(</span><a title="shapeless.::[Any,shapeless.HList]" id="org.parboiled2.support.Unpack.SingleUnpack.apply.hlist">hlist</a>: Any <span title="shapeless.::[Any,shapeless.HList]">::</span> HList<span class="delimiter">)</span>: <span title="Any">Any</span> = <a href="#org.parboiled2.support.Unpack.SingleUnpack.apply.hlist" title="shapeless.::[Any,shapeless.HList]">hlist</a>.<span title="=&gt; Any">head</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

sealed abstract class <a title="class AlternativeUnpacks extends AnyRef" id="org.parboiled2.support;AlternativeUnpacks">AlternativeUnpacks</a> <a href="#org.parboiled2.support;AlternativeUnpacks" title="org.parboiled2.support.AlternativeUnpacks" class="delimiter">{</a>
  <span class="comment">/**
   * Import if you'd like to *always* deliver the valueStack as an `HList`
   * at the end of the parsing run, even if it has only zero or one element(s).
   */</span>
  implicit def <a title="[L &lt;: shapeless.HList]=&gt; org.parboiled2.support.Unpack.Aux[L,L]" id="org.parboiled2.support;AlternativeUnpacks.dontUnpack">dontUnpack</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="org.parboiled2.support;AlternativeUnpacks.dontUnpack;L">L</a> &lt;: HList<span class="delimiter">]</span>: Unpack.<a href="#org.parboiled2.support.Unpack;Aux" title="org.parboiled2.support.Unpack.Aux[L,L]">Aux</a><span class="delimiter">[</span>L, L<span class="delimiter">]</span> = <a href="#org.parboiled2.support;AlternativeUnpacks.DontUnpack" title="AlternativeUnpacks.this.DontUnpack.type">DontUnpack</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="org.parboiled2.support.Unpack.Aux[L,L]" class="delimiter">[</span>Unpack.<a href="#org.parboiled2.support.Unpack;Aux" title="org.parboiled2.support.Unpack.Aux[L,L]">Aux</a><span class="delimiter">[</span>L, L<span class="delimiter">]</span><span class="delimiter">]</span>
  private object <a title="AlternativeUnpacks.this.DontUnpack.type" id="org.parboiled2.support;AlternativeUnpacks.DontUnpack">DontUnpack</a> extends Unpack.<a href="#org.parboiled2.support.Unpack;Aux" title="org.parboiled2.support.Unpack.Aux[shapeless.HList,shapeless.HList]">Aux</a><span class="delimiter">[</span>HList, HList<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="(hlist: shapeless.HList)shapeless.HList" id="org.parboiled2.support;AlternativeUnpacks.DontUnpack.apply">apply</a><span class="delimiter">(</span><a title="shapeless.HList" id="org.parboiled2.support;AlternativeUnpacks.DontUnpack.apply.hlist">hlist</a>: <span title="shapeless.HList">HList</span><span class="delimiter">)</span>: <span title="shapeless.HList">HList</span> = <a href="#org.parboiled2.support;AlternativeUnpacks.DontUnpack.apply.hlist" title="shapeless.HList">hlist</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>


        </pre>
    </body>
</html>
