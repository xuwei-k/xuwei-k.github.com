<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>akka/http/server/PathMatcher.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (C) 2009-2014 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>

package akka.http.server

import java.util.UUID
import scala.util.matching.Regex
import scala.annotation.tailrec
import akka.http.server.util.Tuple
import akka.http.server.util.<a href="util/TupleOps.scala.html#akka.http.server.util.TupleOps" title="akka.http.server.util.TupleOps.type">TupleOps</a>._
import akka.http.common.NameOptionReceptacle
import akka.http.model.<a href="../model/Uri.scala.html#akka.http.model.Uri" title="akka.http.model.Uri.type">Uri</a>.Path
import akka.http.util._

<span class="comment">/**
 * A PathMatcher tries to match a prefix of a given string and returns either a PathMatcher.Matched instance
 * if matched, otherwise PathMatcher.Unmatched.
 */</span>
abstract class <a title="class PathMatcher[L] extends AnyRef with akka.http.model.Uri.Path =&gt; akka.http.server.PathMatcher.Matching[L]" id="akka.http.server;PathMatcher">PathMatcher</a><span class="delimiter">[</span><a title="" id="akka.http.server;PathMatcher;L">L</a><span class="delimiter">]</span><a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[L]" class="delimiter">(</a>implicit val <a title="akka.http.server.util.Tuple[L]" id="akka.http.server;PathMatcher.ev">ev</a>: <a href="util/Tuple.scala.html#akka.http.server.util;Tuple" title="akka.http.server.util.Tuple[L]">Tuple</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> extends <span class="delimiter">(</span>Path ⇒ PathMatcher.Matching<span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span> self ⇒
  import <a href="#akka.http.server.PathMatcher" title="akka.http.server.PathMatcher.type">PathMatcher</a>._

  def <a title="=&gt; akka.http.server.PathMatcher[L]" id="akka.http.server;PathMatcher./(005a077027)">/</a> : <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[L]">PathMatcher</a><span class="delimiter">[</span>L<span class="delimiter">]</span> = this <a href="#akka.http.server;PathMatcher.~" title="(other: akka.http.server.PathMatcher[Unit])(implicit join: akka.http.server.util.TupleOps.Join[L,Unit])akka.http.server.PathMatcher[join.Out]">~</a> <a href="#akka.http.server.PathMatchers" title="akka.http.server.PathMatchers.type">PathMatchers</a>.<a href="#akka.http.server;PathMatchers.Slash" title="akka.http.server.PathMatchers.Slash.type">Slash</a>

  def <a title="[R](other: akka.http.server.PathMatcher[R])(implicit join: akka.http.server.util.TupleOps.Join[L,R])akka.http.server.PathMatcher[join.Out]" id="akka.http.server;PathMatcher./(e066621251)">/</a><span class="delimiter">[</span><a title="" id="akka.http.server;PathMatcher./(e066621251);R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.http.server.PathMatcher[R]" id="akka.http.server;PathMatcher./(e066621251).other">other</a>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[R]">PathMatcher</a><span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="akka.http.server.util.TupleOps.Join[L,R]" id="akka.http.server;PathMatcher./(e066621251).join">join</a>: <a href="util/TupleOps.scala.html#akka.http.server.util.TupleOps;Join" title="akka.http.server.util.TupleOps.Join[L,R]">Join</a><span class="delimiter">[</span>L, R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[join.Out]">PathMatcher</a><span class="delimiter">[</span>join.Out<span class="delimiter">]</span> =
    this <a href="#akka.http.server;PathMatcher.~" title="(other: akka.http.server.PathMatcher[Unit])(implicit join: akka.http.server.util.TupleOps.Join[L,Unit])akka.http.server.PathMatcher[join.Out]">~</a> <a href="#akka.http.server.PathMatchers" title="akka.http.server.PathMatchers.type">PathMatchers</a>.<a href="#akka.http.server;PathMatchers.Slash" title="akka.http.server.PathMatchers.Slash.type">Slash</a> <a href="#akka.http.server;PathMatcher.~" title="(other: akka.http.server.PathMatcher[R])(implicit join: akka.http.server.util.TupleOps.Join[L,R])akka.http.server.PathMatcher[join.Out]">~</a> <a href="#akka.http.server;PathMatcher./(e066621251).other" title="akka.http.server.PathMatcher[R]">other</a>

  def <a title="[R &gt;: L](other: akka.http.server.PathMatcher[_ &lt;: R])(implicit evidence$1: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher[R]" id="akka.http.server;PathMatcher.|">|</a><span class="delimiter">[</span><a title=" &gt;: L" id="akka.http.server;PathMatcher.|;R">R</a> &gt;: L: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.http.server.PathMatcher[_ &lt;: R]" id="akka.http.server;PathMatcher.|.other">other</a>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[_ &lt;: R]">PathMatcher</a><span class="delimiter">[</span>_ &lt;: R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[R]">PathMatcher</a><span class="delimiter">[</span>R<span class="delimiter">]</span> =
    new <a title="&lt;$anon: akka.http.model.Uri.Path =&gt; akka.http.server.PathMatcher.Matching[R]&gt; extends akka.http.server.PathMatcher[R]" id="akka.http.server;PathMatcher.|;$anon">PathMatcher</a><span class="delimiter">[</span>R<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[R]" id="akka.http.server;PathMatcher.|;$anon.apply">apply</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatcher.|;$anon.apply.path">path</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = <a href="#akka.http.server;PathMatcher" title="(v1: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[L]">self</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.|;$anon.apply.path" title="akka.http.model.Uri.Path">path</a><span class="delimiter">)</span> <a href="#akka.http.server.PathMatcher;Matching.orElse" title="(other: =&gt; akka.http.server.PathMatcher.Matching[R])akka.http.server.PathMatcher.Matching[R]">orElse</a> <a href="#akka.http.server;PathMatcher.|.other" title="(v1: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[R]">other</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.|;$anon.apply.path" title="akka.http.model.Uri.Path">path</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  def <a title="[R](other: akka.http.server.PathMatcher[R])(implicit join: akka.http.server.util.TupleOps.Join[L,R])akka.http.server.PathMatcher[join.Out]" id="akka.http.server;PathMatcher.~">~</a><span class="delimiter">[</span><a title="" id="akka.http.server;PathMatcher.~;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.http.server.PathMatcher[R]" id="akka.http.server;PathMatcher.~.other">other</a>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[R]">PathMatcher</a><span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="akka.http.server.util.TupleOps.Join[L,R]" id="akka.http.server;PathMatcher.~.join">join</a>: <a href="util/TupleOps.scala.html#akka.http.server.util.TupleOps;Join" title="akka.http.server.util.TupleOps.Join[L,R]">Join</a><span class="delimiter">[</span>L, R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[join.Out]">PathMatcher</a><span class="delimiter">[</span>join.Out<span class="delimiter">]</span> = <span class="delimiter">{</span>
    implicit def <a title="=&gt; akka.http.server.util.Tuple[join.Out]" id="akka.http.server;PathMatcher.~.joinProducesTuple">joinProducesTuple</a> = <a href="util/Tuple.scala.html#akka.http.server.util.Tuple" title="akka.http.server.util.Tuple.type">Tuple</a>.<a href="util/Tuple.scala.html#akka.http.server.util.Tuple.yes" title="[T]=&gt; akka.http.server.util.Tuple[T]">yes</a><span title="akka.http.server.util.Tuple[join.Out]" class="delimiter">[</span>join.<a href="util/TupleOps.scala.html#akka.http.server.util.TupleOps;Join;Out" title="join.Out">Out</a><span class="delimiter">]</span>
    <a href="#akka.http.server;PathMatcher.transform" title="(f: akka.http.server.PathMatcher.Matching[L] =&gt; akka.http.server.PathMatcher.Matching[join.Out])(implicit evidence$2: akka.http.server.util.Tuple[join.Out])akka.http.server.PathMatcher[join.Out]">transform</a><a href="#akka.http.server;PathMatcher.~.joinProducesTuple" title="=&gt; akka.http.server.util.Tuple[join.Out]" class="delimiter">(</a><a href="#akka.http.server;PathMatcher.~.$anonfun.x$1" title="akka.http.server.PathMatcher.Matching[L]">_</a>.<a href="#akka.http.server.PathMatcher;Matching.andThen" title="(f: (akka.http.model.Uri.Path, L) =&gt; akka.http.server.PathMatcher.Matching[join.Out])(implicit evidence$8: akka.http.server.util.Tuple[join.Out])akka.http.server.PathMatcher.Matching[join.Out]">andThen</a><a href="#akka.http.server;PathMatcher.~.joinProducesTuple" title="=&gt; akka.http.server.util.Tuple[join.Out]" class="delimiter">(</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatcher.~.$anonfun.$anonfun.restL">restL</a>, <a title="L" id="akka.http.server;PathMatcher.~.$anonfun.$anonfun.valuesL">valuesL</a><span class="delimiter">)</span> ⇒ <a href="#akka.http.server;PathMatcher.~.other" title="(v1: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[R]">other</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.~.$anonfun.$anonfun.restL" title="akka.http.model.Uri.Path">restL</a><span class="delimiter">)</span>.<a href="#akka.http.server.PathMatcher;Matching.map" title="(f: R =&gt; join.Out)(implicit evidence$6: akka.http.server.util.Tuple[join.Out])akka.http.server.PathMatcher.Matching[join.Out]">map</a><a href="#akka.http.server;PathMatcher.~.joinProducesTuple" title="=&gt; akka.http.server.util.Tuple[join.Out]" class="delimiter">(</a><a href="util/TupleOps.scala.html#akka.http.server.util.TupleOps;Join.apply" title="(prefix: L, suffix: R)join.Out">join</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.~.$anonfun.$anonfun.valuesL" title="L">valuesL</a>, <a href="#akka.http.server;PathMatcher.~.$anonfun.$anonfun.$anonfun.x$2" title="R">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="()akka.http.server.PathMatcher0" id="akka.http.server;PathMatcher.unary_!">unary_!</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher0">PathMatcher0</a> =
    new <a title="&lt;$anon: akka.http.model.Uri.Path =&gt; akka.http.server.PathMatcher.Matching[Unit]&gt; extends akka.http.server.PathMatcher[Unit]" id="akka.http.server;PathMatcher.unary_!;$anon">PathMatcher</a><span class="delimiter">[</span>Unit<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[Unit]" id="akka.http.server;PathMatcher.unary_!;$anon.apply">apply</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatcher.unary_!;$anon.apply.path">path</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = if <span class="delimiter">(</span><a href="#akka.http.server;PathMatcher" title="(v1: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[L]">self</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.unary_!;$anon.apply.path" title="akka.http.model.Uri.Path">path</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a><span class="delimiter">)</span> <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: Unit)(implicit evidence$9: akka.http.server.util.Tuple[Unit])akka.http.server.PathMatcher.Matched[Unit]">Matched</a><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[Unit]" class="delimiter">(</a><a href="#akka.http.server;PathMatcher.unary_!;$anon.apply.path" title="akka.http.model.Uri.Path">path</a>, <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> else <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>
    <span class="delimiter">}</span>

  def <a title="[R](f: akka.http.server.PathMatcher.Matching[L] =&gt; akka.http.server.PathMatcher.Matching[R])(implicit evidence$2: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher[R]" id="akka.http.server;PathMatcher.transform">transform</a><span class="delimiter">[</span><a title="" id="akka.http.server;PathMatcher.transform;R">R</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.http.server.PathMatcher.Matching[L] =&gt; akka.http.server.PathMatcher.Matching[R]" id="akka.http.server;PathMatcher.transform.f">f</a>: Matching<span class="delimiter">[</span>L<span class="delimiter">]</span> ⇒ Matching<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[R]">PathMatcher</a><span class="delimiter">[</span>R<span class="delimiter">]</span> =
    new <a title="&lt;$anon: akka.http.model.Uri.Path =&gt; akka.http.server.PathMatcher.Matching[R]&gt; extends akka.http.server.PathMatcher[R]" id="akka.http.server;PathMatcher.transform;$anon">PathMatcher</a><span class="delimiter">[</span>R<span class="delimiter">]</span> <span class="delimiter">{</span> def <a title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[R]" id="akka.http.server;PathMatcher.transform;$anon.apply">apply</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatcher.transform;$anon.apply.path">path</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = <a href="#akka.http.server;PathMatcher.transform.f" title="(v1: akka.http.server.PathMatcher.Matching[L])akka.http.server.PathMatcher.Matching[R]">f</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher" title="(v1: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[L]">self</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.transform;$anon.apply.path" title="akka.http.model.Uri.Path">path</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>

  def <a title="[R](f: L =&gt; R)(implicit evidence$3: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher[R]" id="akka.http.server;PathMatcher.tmap">tmap</a><span class="delimiter">[</span><a title="" id="akka.http.server;PathMatcher.tmap;R">R</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="L =&gt; R" id="akka.http.server;PathMatcher.tmap.f">f</a>: L ⇒ R<span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[R]">PathMatcher</a><span class="delimiter">[</span>R<span class="delimiter">]</span> = <a href="#akka.http.server;PathMatcher.transform" title="(f: akka.http.server.PathMatcher.Matching[L] =&gt; akka.http.server.PathMatcher.Matching[R])(implicit evidence$2: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher[R]">transform</a><a href="#akka.http.server;PathMatcher.tmap.evidence$3" title="akka.http.server.util.Tuple[R]" class="delimiter">(</a><a href="#akka.http.server;PathMatcher.tmap.$anonfun.x$3" title="akka.http.server.PathMatcher.Matching[L]">_</a>.<a href="#akka.http.server.PathMatcher;Matching.map" title="(f: L =&gt; R)(implicit evidence$6: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher.Matching[R]">map</a><a href="#akka.http.server;PathMatcher.tmap.evidence$3" title="akka.http.server.util.Tuple[R]" class="delimiter">(</a><a href="#akka.http.server;PathMatcher.tmap.f" title="L =&gt; R">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  def <a title="[R](f: L =&gt; Option[R])(implicit evidence$4: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher[R]" id="akka.http.server;PathMatcher.tflatMap">tflatMap</a><span class="delimiter">[</span><a title="" id="akka.http.server;PathMatcher.tflatMap;R">R</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="L =&gt; Option[R]" id="akka.http.server;PathMatcher.tflatMap.f">f</a>: L ⇒ Option<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[R]">PathMatcher</a><span class="delimiter">[</span>R<span class="delimiter">]</span> = <a href="#akka.http.server;PathMatcher.transform" title="(f: akka.http.server.PathMatcher.Matching[L] =&gt; akka.http.server.PathMatcher.Matching[R])(implicit evidence$2: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher[R]">transform</a><a href="#akka.http.server;PathMatcher.tflatMap.evidence$4" title="akka.http.server.util.Tuple[R]" class="delimiter">(</a><a href="#akka.http.server;PathMatcher.tflatMap.$anonfun.x$4" title="akka.http.server.PathMatcher.Matching[L]">_</a>.<a href="#akka.http.server.PathMatcher;Matching.flatMap" title="(f: L =&gt; Option[R])(implicit evidence$7: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher.Matching[R]">flatMap</a><a href="#akka.http.server;PathMatcher.tflatMap.evidence$4" title="akka.http.server.util.Tuple[R]" class="delimiter">(</a><a href="#akka.http.server;PathMatcher.tflatMap.f" title="L =&gt; Option[R]">f</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Turns this ``PathMatcher`` into one that always matches, consumes zero or more times (with the given separator)
   * and potentially extracts a ``List`` of the underlying matcher's extractions.
   * The result type depends on the type of the underlying matcher:
   *
   * &lt;table&gt;
   * &lt;th&gt;&lt;td&gt;If a ``matcher`` is of type&lt;/td&gt;&lt;td&gt;then ``matcher.repeat(...)`` is of type&lt;/td&gt;&lt;/th&gt;
   * &lt;tr&gt;&lt;td&gt;``PathMatcher0``&lt;/td&gt;&lt;td&gt;``PathMatcher0``&lt;/td&gt;&lt;/tr&gt;
   * &lt;tr&gt;&lt;td&gt;``PathMatcher1[T]``&lt;/td&gt;&lt;td&gt;``PathMatcher1[List[T]``&lt;/td&gt;&lt;/tr&gt;
   * &lt;tr&gt;&lt;td&gt;``PathMatcher[L :Tuple]``&lt;/td&gt;&lt;td&gt;``PathMatcher[List[L]]``&lt;/td&gt;&lt;/tr&gt;
   * &lt;/table&gt;
   */</span>
  def <a title="(maxIterations: Int, separator: akka.http.server.PathMatcher0)(implicit lift: akka.http.server.PathMatcher.Lift[L,List])akka.http.server.PathMatcher[lift.Out]" id="akka.http.server;PathMatcher.repeat">repeat</a><span class="delimiter">(</span><a title="Int" id="akka.http.server;PathMatcher.repeat.maxIterations">maxIterations</a>: <span title="Int">Int</span>, <a title="akka.http.server.PathMatcher0" id="akka.http.server;PathMatcher.repeat$default$2">separator</a>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher0">PathMatcher0</a> = <a href="#akka.http.server.PathMatchers" title="akka.http.server.PathMatchers.type">PathMatchers</a>.<a href="#akka.http.server;PathMatchers.Neutral" title="=&gt; akka.http.server.PathMatcher0">Neutral</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="akka.http.server.PathMatcher.Lift[L,List]" id="akka.http.server;PathMatcher.repeat.lift">lift</a>: PathMatcher.<a href="#akka.http.server.PathMatcher;Lift" title="akka.http.server.PathMatcher.Lift[L,List]">Lift</a><span class="delimiter">[</span>L, List<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[lift.Out]">PathMatcher</a><span class="delimiter">[</span>lift.Out<span class="delimiter">]</span> =
    new <a title="&lt;$anon: akka.http.model.Uri.Path =&gt; akka.http.server.PathMatcher.Matching[lift.Out]&gt; extends akka.http.server.PathMatcher[lift.Out]" id="akka.http.server;PathMatcher.repeat;$anon">PathMatcher</a><span class="delimiter">[</span>lift.Out<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.repeat.lift" title="akka.http.server.PathMatcher.Lift[L,List]">lift</a>.<a href="#akka.http.server.PathMatcher;Lift.OutIsTuple" title="=&gt; akka.http.server.util.Tuple[lift.Out]">OutIsTuple</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      def <a title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[lift.Out]" id="akka.http.server;PathMatcher.repeat;$anon.apply">apply</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatcher.repeat;$anon.apply.path">path</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = <a href="#akka.http.server;PathMatcher.repeat;$anon.rec" title="(path: akka.http.model.Uri.Path, iterationsLeft: Int)akka.http.server.PathMatcher.Matching[lift.Out]">rec</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.repeat;$anon.apply.path" title="akka.http.model.Uri.Path">path</a>, <a href="#akka.http.server;PathMatcher.repeat.maxIterations" title="Int">maxIterations</a><span class="delimiter">)</span>
      def <a title="(path: akka.http.model.Uri.Path, iterationsLeft: Int)akka.http.server.PathMatcher.Matching[lift.Out]" id="akka.http.server;PathMatcher.repeat;$anon.rec">rec</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatcher.repeat;$anon.rec.path">path</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a>, <a title="Int" id="akka.http.server;PathMatcher.repeat;$anon.rec.iterationsLeft">iterationsLeft</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#akka.http.server.PathMatcher;Matching" title="akka.http.server.PathMatcher.Matching[lift.Out]">Matching</a><span class="delimiter">[</span>lift.Out<span class="delimiter">]</span> = <span class="delimiter">{</span>
        def <a title="=&gt; akka.http.server.PathMatcher.Matched[lift.Out]" id="akka.http.server;PathMatcher.repeat;$anon.rec.done">done</a> = <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: lift.Out)(implicit evidence$9: akka.http.server.util.Tuple[lift.Out])akka.http.server.PathMatcher.Matched[lift.Out]">Matched</a><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[lift.Out]" class="delimiter">(</a><a href="#akka.http.server;PathMatcher.repeat;$anon.rec.path" title="akka.http.model.Uri.Path">path</a>, <a href="#akka.http.server.PathMatcher;Lift.apply(604f2ffd57)" title="()lift.Out">lift</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.repeat;$anon.rec.iterationsLeft" title="Int">iterationsLeft</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#akka.http.server;PathMatcher" title="(v1: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[L]">self</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.repeat;$anon.rec.path" title="akka.http.model.Uri.Path">path</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
            case Matched<span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatcher.repeat;$anon.rec.remaining">remaining</a>, <a title="L" id="akka.http.server;PathMatcher.repeat;$anon.rec.extractions">extractions</a><span class="delimiter">)</span> ⇒
              def <a title="=&gt; akka.http.server.PathMatcher.Matched[lift.Out]" id="akka.http.server;PathMatcher.repeat;$anon.rec.result1">result1</a> = <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: lift.Out)(implicit evidence$9: akka.http.server.util.Tuple[lift.Out])akka.http.server.PathMatcher.Matched[lift.Out]">Matched</a><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[lift.Out]" class="delimiter">(</a><a href="#akka.http.server;PathMatcher.repeat;$anon.rec.remaining" title="akka.http.model.Uri.Path">remaining</a>, <a href="#akka.http.server.PathMatcher;Lift.apply(adff6ad3ee)" title="(value: L)lift.Out">lift</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.repeat;$anon.rec.extractions" title="L">extractions</a><span class="delimiter">)</span><span class="delimiter">)</span>
              <a href="#akka.http.server;PathMatcher.repeat$default$2" title="(v1: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[Unit]">separator</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.repeat;$anon.rec.remaining" title="akka.http.model.Uri.Path">remaining</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
                case Matched<span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatcher.repeat;$anon.rec.remaining2">remaining2</a>, _<span class="delimiter">)</span> ⇒ <a href="#akka.http.server;PathMatcher.repeat;$anon.rec" title="(path: akka.http.model.Uri.Path, iterationsLeft: Int)akka.http.server.PathMatcher.Matching[lift.Out]">rec</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.repeat;$anon.rec.remaining2" title="akka.http.model.Uri.Path">remaining2</a>, <a href="#akka.http.server;PathMatcher.repeat;$anon.rec.iterationsLeft" title="Int">iterationsLeft</a> <span title="(x: Int)Int">-</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> match <span class="delimiter">{</span>
                  case Matched<span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.repeat;$anon.rec.remaining2" title="akka.http.model.Uri.Path">`remaining2`</a>, _<span class="delimiter">)</span> ⇒ <a href="#akka.http.server;PathMatcher.repeat;$anon.rec.result1" title="=&gt; akka.http.server.PathMatcher.Matched[lift.Out]">result1</a> <span class="comment">// we made no progress, so &quot;go back&quot; to before the separator</span>
                  case Matched<span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatcher.repeat;$anon.rec.rest">rest</a>, <a title="lift.Out" id="akka.http.server;PathMatcher.repeat;$anon.rec.result">result</a><span class="delimiter">)</span>    ⇒ <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: lift.Out)(implicit evidence$9: akka.http.server.util.Tuple[lift.Out])akka.http.server.PathMatcher.Matched[lift.Out]">Matched</a><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[lift.Out]" class="delimiter">(</a><a href="#akka.http.server;PathMatcher.repeat;$anon.rec.rest" title="akka.http.model.Uri.Path">rest</a>, <a href="#akka.http.server.PathMatcher;Lift.apply(2328c70ada)" title="(value: L, more: lift.Out)lift.Out">lift</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.repeat;$anon.rec.extractions" title="L">extractions</a>, <a href="#akka.http.server;PathMatcher.repeat;$anon.rec.result" title="lift.Out">result</a><span class="delimiter">)</span><span class="delimiter">)</span>
                  case <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>                ⇒ throw new <span title="IllegalStateException">IllegalStateException</span>
                <span class="delimiter">}</span>
                case <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a> ⇒ <a href="#akka.http.server;PathMatcher.repeat;$anon.rec.result1" title="=&gt; akka.http.server.PathMatcher.Matched[lift.Out]">result1</a>
              <span class="delimiter">}</span>
            case <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a> ⇒ <a href="#akka.http.server;PathMatcher.repeat;$anon.rec.done" title="=&gt; akka.http.server.PathMatcher.Matched[lift.Out]">done</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span> else <a href="#akka.http.server;PathMatcher.repeat;$anon.rec.done" title="=&gt; akka.http.server.PathMatcher.Matched[lift.Out]">done</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

object <a title="akka.http.server.PathMatcher.type" id="akka.http.server.PathMatcher">PathMatcher</a> extends <a href="#akka.http.server;ImplicitPathMatcherConstruction" title="akka.http.server.ImplicitPathMatcherConstruction">ImplicitPathMatcherConstruction</a> <span class="delimiter">{</span>
  sealed abstract class <a title="class Matching[+L] extends AnyRef" id="akka.http.server.PathMatcher;Matching">Matching</a><span class="delimiter">[</span>+<a title="" id="akka.http.server.PathMatcher;Matching;L">L</a>: Tuple<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="[R](f: L =&gt; R)(implicit evidence$6: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher.Matching[R]" id="akka.http.server.PathMatcher;Matching.map">map</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher;Matching.map;R">R</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="L =&gt; R" id="akka.http.server.PathMatcher;Matching.map.f">f</a>: L ⇒ R<span class="delimiter">)</span>: <a href="#akka.http.server.PathMatcher;Matching" title="akka.http.server.PathMatcher.Matching[R]">Matching</a><span class="delimiter">[</span>R<span class="delimiter">]</span>
    def <a title="[R](f: L =&gt; Option[R])(implicit evidence$7: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher.Matching[R]" id="akka.http.server.PathMatcher;Matching.flatMap">flatMap</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher;Matching.flatMap;R">R</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="L =&gt; Option[R]" id="akka.http.server.PathMatcher;Matching.flatMap.f">f</a>: L ⇒ Option<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server.PathMatcher;Matching" title="akka.http.server.PathMatcher.Matching[R]">Matching</a><span class="delimiter">[</span>R<span class="delimiter">]</span>
    def <a title="[R](f: (akka.http.model.Uri.Path, L) =&gt; akka.http.server.PathMatcher.Matching[R])(implicit evidence$8: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher.Matching[R]" id="akka.http.server.PathMatcher;Matching.andThen">andThen</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher;Matching.andThen;R">R</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="(akka.http.model.Uri.Path, L) =&gt; akka.http.server.PathMatcher.Matching[R]" id="akka.http.server.PathMatcher;Matching.andThen.f">f</a>: <span class="delimiter">(</span>Path, L<span class="delimiter">)</span> ⇒ Matching<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server.PathMatcher;Matching" title="akka.http.server.PathMatcher.Matching[R]">Matching</a><span class="delimiter">[</span>R<span class="delimiter">]</span>
    def <a title="[R &gt;: L](other: =&gt; akka.http.server.PathMatcher.Matching[R])akka.http.server.PathMatcher.Matching[R]" id="akka.http.server.PathMatcher;Matching.orElse">orElse</a><span class="delimiter">[</span><a title=" &gt;: L" id="akka.http.server.PathMatcher;Matching.orElse;R">R</a> &gt;: L<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; akka.http.server.PathMatcher.Matching[R]" id="akka.http.server.PathMatcher;Matching.orElse.other">other</a>: ⇒ Matching<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server.PathMatcher;Matching" title="akka.http.server.PathMatcher.Matching[R]">Matching</a><span class="delimiter">[</span>R<span class="delimiter">]</span>
  <span class="delimiter">}</span>
  case class <a href="#akka.http.server.PathMatcher;Matched.productElement.x$1" title="class Matched[L] extends akka.http.server.PathMatcher.Matching[L] with Product with Serializable" id="akka.http.server.PathMatcher;Matched">Matched</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher;Matched;L">L</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server.PathMatcher;Matched.pathRest">pathRest</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a>, <a title="L" id="akka.http.server.PathMatcher;Matched.extractions">extractions</a>: <a href="#akka.http.server.PathMatcher;Matched;L" title="L">L</a><span class="delimiter">)</span> extends <a href="#akka.http.server.PathMatcher;Matching" title="akka.http.server.PathMatcher.Matching[L]">Matching</a><span class="delimiter">[</span>L<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="[R](f: L =&gt; R)(implicit evidence$10: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher.Matched[R]" id="akka.http.server.PathMatcher;Matched.map">map</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher;Matched.map;R">R</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="L =&gt; R" id="akka.http.server.PathMatcher;Matched.map.f">f</a>: L ⇒ R<span class="delimiter">)</span> = <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: R)(implicit evidence$9: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher.Matched[R]">Matched</a><a href="#akka.http.server.PathMatcher;Matched.map.evidence$10" title="akka.http.server.util.Tuple[R]" class="delimiter">(</a><a href="#akka.http.server.PathMatcher;Matched.pathRest" title="=&gt; akka.http.model.Uri.Path">pathRest</a>, <a href="#akka.http.server.PathMatcher;Matched.map.f" title="(v1: L)R">f</a><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher;Matched.extractions" title="=&gt; L">extractions</a><span class="delimiter">)</span><span class="delimiter">)</span>
    def <a title="[R](f: L =&gt; Option[R])(implicit evidence$11: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher.Matching[R]" id="akka.http.server.PathMatcher;Matched.flatMap">flatMap</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher;Matched.flatMap;R">R</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="L =&gt; Option[R]" id="akka.http.server.PathMatcher;Matched.flatMap.f">f</a>: L ⇒ Option<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#akka.http.server.PathMatcher;Matched.flatMap.f" title="(v1: L)Option[R]">f</a><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher;Matched.extractions" title="=&gt; L">extractions</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
      case Some<span class="delimiter">(</span><a title="R" id="akka.http.server.PathMatcher;Matched.flatMap.valuesR">valuesR</a><span class="delimiter">)</span> ⇒ <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: R)(implicit evidence$9: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher.Matched[R]">Matched</a><a href="#akka.http.server.PathMatcher;Matched.flatMap.evidence$11" title="akka.http.server.util.Tuple[R]" class="delimiter">(</a><a href="#akka.http.server.PathMatcher;Matched.pathRest" title="=&gt; akka.http.model.Uri.Path">pathRest</a>, <a href="#akka.http.server.PathMatcher;Matched.flatMap.valuesR" title="R">valuesR</a><span class="delimiter">)</span>
      case <span title="None.type">None</span>          ⇒ <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>
    <span class="delimiter">}</span>
    def <a title="[R](f: (akka.http.model.Uri.Path, L) =&gt; akka.http.server.PathMatcher.Matching[R])(implicit evidence$12: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher.Matching[R]" id="akka.http.server.PathMatcher;Matched.andThen">andThen</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher;Matched.andThen;R">R</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="(akka.http.model.Uri.Path, L) =&gt; akka.http.server.PathMatcher.Matching[R]" id="akka.http.server.PathMatcher;Matched.andThen.f">f</a>: <span class="delimiter">(</span>Path, L<span class="delimiter">)</span> ⇒ Matching<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#akka.http.server.PathMatcher;Matched.andThen.f" title="(v1: akka.http.model.Uri.Path, v2: L)akka.http.server.PathMatcher.Matching[R]">f</a><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher;Matched.pathRest" title="=&gt; akka.http.model.Uri.Path">pathRest</a>, <a href="#akka.http.server.PathMatcher;Matched.extractions" title="=&gt; L">extractions</a><span class="delimiter">)</span>
    def <a title="[R &gt;: L](other: =&gt; akka.http.server.PathMatcher.Matching[R])akka.http.server.PathMatcher.Matched[L]" id="akka.http.server.PathMatcher;Matched.orElse">orElse</a><span class="delimiter">[</span><a title=" &gt;: L" id="akka.http.server.PathMatcher;Matched.orElse;R">R</a> &gt;: L<span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; akka.http.server.PathMatcher.Matching[R]" id="akka.http.server.PathMatcher;Matched.orElse.other">other</a>: ⇒ Matching<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span> = this
  <span class="delimiter">}</span>
  object <a title="akka.http.server.PathMatcher.Matched.type" id="akka.http.server.PathMatcher.Matched.readResolve">Matched</a> <a href="#akka.http.server.PathMatcher.Matched.readResolve" title="akka.http.server.PathMatcher.Matched.type" class="delimiter">{</a> val <a title="akka.http.server.PathMatcher.Matched[Unit]" id="akka.http.server.PathMatcher.Matched.Empty">Empty</a> = <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: Unit)(implicit evidence$9: akka.http.server.util.Tuple[Unit])akka.http.server.PathMatcher.Matched[Unit]">Matched</a><a href="util/Tuple.scala.html#akka.http.server.util.Tuple.forUnit" title="akka.http.server.util.Tuple[Unit]" class="delimiter">(</a><a href="../model/Uri.scala.html#akka.http.model.Uri.Path" title="akka.http.model.Uri.Path.type">Path</a>.<a href="../model/Uri.scala.html#akka.http.model.Uri.Path.Empty" title="akka.http.model.Uri.Path.Empty.type">Empty</a>, <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  case object <a href="#akka.http.server.PathMatcher.Unmatched.productElement.x$1" title="akka.http.server.PathMatcher.Unmatched.type" id="akka.http.server.PathMatcher.Unmatched.readResolve">Unmatched</a> extends <a href="#akka.http.server.PathMatcher;Matching" title="akka.http.server.PathMatcher.Matching[Nothing]">Matching</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="[R](f: Nothing =&gt; R)(implicit evidence$13: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher.Unmatched.type" id="akka.http.server.PathMatcher.Unmatched.map">map</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.Unmatched.map;R">R</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="Nothing =&gt; R" id="akka.http.server.PathMatcher.Unmatched.map.f">f</a>: Nothing ⇒ R<span class="delimiter">)</span> = this
    def <a title="[R](f: Nothing =&gt; Option[R])(implicit evidence$14: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher.Unmatched.type" id="akka.http.server.PathMatcher.Unmatched.flatMap">flatMap</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.Unmatched.flatMap;R">R</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="Nothing =&gt; Option[R]" id="akka.http.server.PathMatcher.Unmatched.flatMap.f">f</a>: Nothing ⇒ Option<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span> = this
    def <a title="[R](f: (akka.http.model.Uri.Path, Nothing) =&gt; akka.http.server.PathMatcher.Matching[R])(implicit evidence$15: akka.http.server.util.Tuple[R])akka.http.server.PathMatcher.Unmatched.type" id="akka.http.server.PathMatcher.Unmatched.andThen">andThen</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.Unmatched.andThen;R">R</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="(akka.http.model.Uri.Path, Nothing) =&gt; akka.http.server.PathMatcher.Matching[R]" id="akka.http.server.PathMatcher.Unmatched.andThen.f">f</a>: <span class="delimiter">(</span>Path, Nothing<span class="delimiter">)</span> ⇒ Matching<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span> = this
    def <a title="[R](other: =&gt; akka.http.server.PathMatcher.Matching[R])akka.http.server.PathMatcher.Matching[R]" id="akka.http.server.PathMatcher.Unmatched.orElse">orElse</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.Unmatched.orElse;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; akka.http.server.PathMatcher.Matching[R]" id="akka.http.server.PathMatcher.Unmatched.orElse.other">other</a>: ⇒ Matching<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#akka.http.server.PathMatcher.Unmatched.orElse.other" title="=&gt; akka.http.server.PathMatcher.Matching[R]">other</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Creates a PathMatcher that always matches, consumes nothing and extracts the given Tuple of values.
   */</span>
  def <a title="[L](extractions: L)(implicit evidence$16: akka.http.server.util.Tuple[L])akka.http.server.PathMatcher[L]" id="akka.http.server.PathMatcher.provide">provide</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.provide;L">L</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="L" id="akka.http.server.PathMatcher.provide.extractions">extractions</a>: <a href="#akka.http.server.PathMatcher.provide;L" title="L">L</a><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[L]">PathMatcher</a><span class="delimiter">[</span>L<span class="delimiter">]</span> =
    new <a title="&lt;$anon: akka.http.model.Uri.Path =&gt; akka.http.server.PathMatcher.Matching[L]&gt; extends akka.http.server.PathMatcher[L]" id="akka.http.server.PathMatcher.provide;$anon">PathMatcher</a><span class="delimiter">[</span>L<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matched[L]" id="akka.http.server.PathMatcher.provide;$anon.apply">apply</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server.PathMatcher.provide;$anon.apply.path">path</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: L)(implicit evidence$9: akka.http.server.util.Tuple[L])akka.http.server.PathMatcher.Matched[L]">Matched</a><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher.provide;$anon.apply.path" title="akka.http.model.Uri.Path">path</a>, <a href="#akka.http.server.PathMatcher.provide.extractions" title="L">extractions</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[L]">ev</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Creates a PathMatcher that matches and consumes the given path prefix and extracts the given list of extractions.
   * If the given prefix is empty the returned PathMatcher matches always and consumes nothing.
   */</span>
  def <a title="[L](prefix: akka.http.model.Uri.Path, extractions: L)(implicit evidence$17: akka.http.server.util.Tuple[L])akka.http.server.PathMatcher[L]" id="akka.http.server.PathMatcher.apply(9c45d37167)">apply</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.apply(9c45d37167);L">L</a>: Tuple<span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server.PathMatcher.apply(9c45d37167).prefix">prefix</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a>, <a title="L" id="akka.http.server.PathMatcher.apply(9c45d37167).extractions">extractions</a>: <a href="#akka.http.server.PathMatcher.apply(9c45d37167);L" title="L">L</a><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[L]">PathMatcher</a><span class="delimiter">[</span>L<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#akka.http.server.PathMatcher.apply(9c45d37167).prefix" title="akka.http.model.Uri.Path">prefix</a>.<a href="../model/Uri.scala.html#akka.http.model.Uri;Path.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <a href="#akka.http.server.PathMatcher.provide" title="(extractions: L)(implicit evidence$16: akka.http.server.util.Tuple[L])akka.http.server.PathMatcher[L]">provide</a><a href="#akka.http.server.PathMatcher.apply(9c45d37167).evidence$17" title="akka.http.server.util.Tuple[L]" class="delimiter">(</a><a href="#akka.http.server.PathMatcher.apply(9c45d37167).extractions" title="L">extractions</a><span class="delimiter">)</span>
    else new <a title="&lt;$anon: akka.http.model.Uri.Path =&gt; akka.http.server.PathMatcher.Matching[L]&gt; extends akka.http.server.PathMatcher[L]" id="akka.http.server.PathMatcher.apply(9c45d37167);$anon">PathMatcher</a><span class="delimiter">[</span>L<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[L]" id="akka.http.server.PathMatcher.apply(9c45d37167);$anon.apply">apply</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server.PathMatcher.apply(9c45d37167);$anon.apply.path">path</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> =
        if <span class="delimiter">(</span><a href="#akka.http.server.PathMatcher.apply(9c45d37167);$anon.apply.path" title="akka.http.model.Uri.Path">path</a> <a href="../model/Uri.scala.html#akka.http.model.Uri;Path.startsWith" title="(that: akka.http.model.Uri.Path)Boolean">startsWith</a> <a href="#akka.http.server.PathMatcher.apply(9c45d37167).prefix" title="akka.http.model.Uri.Path">prefix</a><span class="delimiter">)</span> <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: L)(implicit evidence$9: akka.http.server.util.Tuple[L])akka.http.server.PathMatcher.Matched[L]">Matched</a><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher.apply(9c45d37167);$anon.apply.path" title="akka.http.model.Uri.Path">path</a> <a href="../model/Uri.scala.html#akka.http.model.Uri;Path.dropChars" title="(count: Int)akka.http.model.Uri.Path">dropChars</a> <a href="#akka.http.server.PathMatcher.apply(9c45d37167).prefix" title="akka.http.model.Uri.Path">prefix</a>.<a href="../model/Uri.scala.html#akka.http.model.Uri;Path.charCount" title="=&gt; Int">charCount</a>, <a href="#akka.http.server.PathMatcher.apply(9c45d37167).extractions" title="L">extractions</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[L]">ev</a><span class="delimiter">)</span>
        else <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>
    <span class="delimiter">}</span>

  def <a title="[L](magnet: akka.http.server.PathMatcher[L])akka.http.server.PathMatcher[L]" id="akka.http.server.PathMatcher.apply(2bcbf921fb)">apply</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.apply(2bcbf921fb);L">L</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.http.server.PathMatcher[L]" id="akka.http.server.PathMatcher.apply(2bcbf921fb).magnet">magnet</a>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[L]">PathMatcher</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[L]">PathMatcher</a><span class="delimiter">[</span>L<span class="delimiter">]</span> = <a href="#akka.http.server.PathMatcher.apply(2bcbf921fb).magnet" title="akka.http.server.PathMatcher[L]">magnet</a>

  implicit class <a href="#akka.http.server.PathMatcher.PathMatcher1Ops.matcher" title="class PathMatcher1Ops[T] extends AnyRef" id="akka.http.server.PathMatcher.PathMatcher1Ops">PathMatcher1Ops</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.PathMatcher1Ops;T">T</a><span class="delimiter">]</span><a href="#akka.http.server.PathMatcher.PathMatcher1Ops" title="akka.http.server.PathMatcher.PathMatcher1Ops[T]" class="delimiter">(</a><a title="akka.http.server.PathMatcher1[T]" id="akka.http.server.PathMatcher.PathMatcher1Ops.matcher">matcher</a>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher1[T]">PathMatcher1</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="[R](f: T =&gt; R)akka.http.server.PathMatcher1[R]" id="akka.http.server.PathMatcher;PathMatcher1Ops.map">map</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher;PathMatcher1Ops.map;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; R" id="akka.http.server.PathMatcher;PathMatcher1Ops.map.f">f</a>: T ⇒ R<span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher1[R]">PathMatcher1</a><span class="delimiter">[</span>R<span class="delimiter">]</span> = <a href="#akka.http.server.PathMatcher.PathMatcher1Ops.matcher" title="akka.http.server.PathMatcher1[T]">matcher</a>.<a href="#akka.http.server;PathMatcher.tmap" title="(f: ((T,)) =&gt; (R,))(implicit evidence$3: akka.http.server.util.Tuple[(R,)])akka.http.server.PathMatcher[(R,)]">tmap</a> <a href="#akka.http.server.PathMatcher;PathMatcher1Ops.map.$anonfun.x0$1" title="(R,)" class="delimiter">{</a> case Tuple1<span class="delimiter">(</span><a title="T" id="akka.http.server.PathMatcher;PathMatcher1Ops.map.$anonfun.e">e</a><span class="delimiter">)</span> ⇒ <span title="(_1: R)(R,)">Tuple1</span><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher;PathMatcher1Ops.map.f" title="(v1: T)R">f</a><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher;PathMatcher1Ops.map.$anonfun.e" title="T">e</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    def <a title="[R](f: T =&gt; Option[R])akka.http.server.PathMatcher1[R]" id="akka.http.server.PathMatcher;PathMatcher1Ops.flatMap">flatMap</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher;PathMatcher1Ops.flatMap;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; Option[R]" id="akka.http.server.PathMatcher;PathMatcher1Ops.flatMap.f">f</a>: T ⇒ Option<span class="delimiter">[</span>R<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher1[R]">PathMatcher1</a><span class="delimiter">[</span>R<span class="delimiter">]</span> =
      <a href="#akka.http.server.PathMatcher.PathMatcher1Ops.matcher" title="akka.http.server.PathMatcher1[T]">matcher</a>.<a href="#akka.http.server;PathMatcher.tflatMap" title="(f: ((T,)) =&gt; Option[(R,)])(implicit evidence$4: akka.http.server.util.Tuple[(R,)])akka.http.server.PathMatcher[(R,)]">tflatMap</a> <a href="#akka.http.server.PathMatcher;PathMatcher1Ops.flatMap.$anonfun.x0$2" title="Option[(R,)]" class="delimiter">{</a> case Tuple1<span class="delimiter">(</span><a title="T" id="akka.http.server.PathMatcher;PathMatcher1Ops.flatMap.$anonfun.e">e</a><span class="delimiter">)</span> ⇒ <a href="#akka.http.server.PathMatcher;PathMatcher1Ops.flatMap.f" title="(v1: T)Option[R]">f</a><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher;PathMatcher1Ops.flatMap.$anonfun.e" title="T">e</a><span class="delimiter">)</span>.<span title="(f: R =&gt; (R,))Option[(R,)]">map</span><span class="delimiter">(</span><a title="R" id="akka.http.server.PathMatcher;PathMatcher1Ops.flatMap.$anonfun.$anonfun.x">x</a> ⇒ <span title="(_1: R)(R,)">Tuple1</span><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher;PathMatcher1Ops.flatMap.$anonfun.$anonfun.x" title="R">x</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  implicit class <a href="#akka.http.server.PathMatcher.EnhancedPathMatcher.underlying" title="class EnhancedPathMatcher[L] extends AnyRef" id="akka.http.server.PathMatcher.EnhancedPathMatcher">EnhancedPathMatcher</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.EnhancedPathMatcher;L">L</a><span class="delimiter">]</span><a href="#akka.http.server.PathMatcher.EnhancedPathMatcher" title="akka.http.server.PathMatcher.EnhancedPathMatcher[L]" class="delimiter">(</a><a title="akka.http.server.PathMatcher[L]" id="akka.http.server.PathMatcher.EnhancedPathMatcher.underlying">underlying</a>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[L]">PathMatcher</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="(implicit lift: akka.http.server.PathMatcher.Lift[L,Option])akka.http.server.PathMatcher[lift.Out]" id="akka.http.server.PathMatcher;EnhancedPathMatcher.?">?</a><span class="delimiter">(</span>implicit <a title="akka.http.server.PathMatcher.Lift[L,Option]" id="akka.http.server.PathMatcher;EnhancedPathMatcher.?.lift">lift</a>: PathMatcher.<a href="#akka.http.server.PathMatcher;Lift" title="akka.http.server.PathMatcher.Lift[L,Option]">Lift</a><span class="delimiter">[</span>L, Option<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[lift.Out]">PathMatcher</a><span class="delimiter">[</span>lift.Out<span class="delimiter">]</span> =
      new <a title="&lt;$anon: akka.http.model.Uri.Path =&gt; akka.http.server.PathMatcher.Matching[lift.Out]&gt; extends akka.http.server.PathMatcher[lift.Out]" id="akka.http.server.PathMatcher;EnhancedPathMatcher.?;$anon">PathMatcher</a><span class="delimiter">[</span>lift.Out<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher;EnhancedPathMatcher.?.lift" title="akka.http.server.PathMatcher.Lift[L,Option]">lift</a>.<a href="#akka.http.server.PathMatcher;Lift.OutIsTuple" title="=&gt; akka.http.server.util.Tuple[lift.Out]">OutIsTuple</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        def <a title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[lift.Out]" id="akka.http.server.PathMatcher;EnhancedPathMatcher.?;$anon.apply">apply</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server.PathMatcher;EnhancedPathMatcher.?;$anon.apply.path">path</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = <a href="#akka.http.server.PathMatcher.EnhancedPathMatcher.underlying" title="(v1: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[L]">underlying</a><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher;EnhancedPathMatcher.?;$anon.apply.path" title="akka.http.model.Uri.Path">path</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
          case Matched<span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server.PathMatcher;EnhancedPathMatcher.?;$anon.apply.rest">rest</a>, <a title="L" id="akka.http.server.PathMatcher;EnhancedPathMatcher.?;$anon.apply.extractions">extractions</a><span class="delimiter">)</span> ⇒ <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: lift.Out)(implicit evidence$9: akka.http.server.util.Tuple[lift.Out])akka.http.server.PathMatcher.Matched[lift.Out]">Matched</a><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[lift.Out]" class="delimiter">(</a><a href="#akka.http.server.PathMatcher;EnhancedPathMatcher.?;$anon.apply.rest" title="akka.http.model.Uri.Path">rest</a>, <a href="#akka.http.server.PathMatcher;Lift.apply(adff6ad3ee)" title="(value: L)lift.Out">lift</a><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher;EnhancedPathMatcher.?;$anon.apply.extractions" title="L">extractions</a><span class="delimiter">)</span><span class="delimiter">)</span>
          case <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>                  ⇒ <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: lift.Out)(implicit evidence$9: akka.http.server.util.Tuple[lift.Out])akka.http.server.PathMatcher.Matched[lift.Out]">Matched</a><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[lift.Out]" class="delimiter">(</a><a href="#akka.http.server.PathMatcher;EnhancedPathMatcher.?;$anon.apply.path" title="akka.http.model.Uri.Path">path</a>, <a href="#akka.http.server.PathMatcher;Lift.apply(604f2ffd57)" title="()lift.Out">lift</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  sealed trait <a title="trait Lift[L, M[+_]] extends AnyRef" id="akka.http.server.PathMatcher;Lift">Lift</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher;Lift;L">L</a>, <a title="[+_]" id="akka.http.server.PathMatcher;Lift;M">M</a><span class="delimiter">[</span>+<a title="" id="akka.http.server.PathMatcher;Lift;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
    type <a title="" id="akka.http.server.PathMatcher;Lift;Out">Out</a>
    def <a title="=&gt; akka.http.server.util.Tuple[Lift.this.Out]" id="akka.http.server.PathMatcher;Lift.OutIsTuple">OutIsTuple</a>: <a href="util/Tuple.scala.html#akka.http.server.util;Tuple" title="akka.http.server.util.Tuple[Lift.this.Out]">Tuple</a><span class="delimiter">[</span>Out<span class="delimiter">]</span>
    def <a title="()Lift.this.Out" id="akka.http.server.PathMatcher;Lift.apply(604f2ffd57)">apply</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.http.server.PathMatcher;Lift;Out" title="Lift.this.Out">Out</a>
    def <a title="(value: L)Lift.this.Out" id="akka.http.server.PathMatcher;Lift.apply(adff6ad3ee)">apply</a><span class="delimiter">(</span><a title="L" id="akka.http.server.PathMatcher;Lift.apply(adff6ad3ee).value">value</a>: <a href="#akka.http.server.PathMatcher;Lift;L" title="L">L</a><span class="delimiter">)</span>: <a href="#akka.http.server.PathMatcher;Lift;Out" title="Lift.this.Out">Out</a>
    def <a title="(value: L, more: Lift.this.Out)Lift.this.Out" id="akka.http.server.PathMatcher;Lift.apply(2328c70ada)">apply</a><span class="delimiter">(</span><a title="L" id="akka.http.server.PathMatcher;Lift.apply(2328c70ada).value">value</a>: <a href="#akka.http.server.PathMatcher;Lift;L" title="L">L</a>, <a title="Lift.this.Out" id="akka.http.server.PathMatcher;Lift.apply(2328c70ada).more">more</a>: <a href="#akka.http.server.PathMatcher;Lift;Out" title="Lift.this.Out">Out</a><span class="delimiter">)</span>: <a href="#akka.http.server.PathMatcher;Lift;Out" title="Lift.this.Out">Out</a>
  <span class="delimiter">}</span>
  object <a title="akka.http.server.PathMatcher.Lift.type" id="akka.http.server.PathMatcher.Lift">Lift</a> extends <a href="#akka.http.server.PathMatcher;LowLevelLiftImplicits" title="akka.http.server.PathMatcher.LowLevelLiftImplicits">LowLevelLiftImplicits</a> <span class="delimiter">{</span>
    trait <a title="trait MOps[M[+_]] extends AnyRef" id="akka.http.server.PathMatcher.Lift;MOps">MOps</a><span class="delimiter">[</span><a title="[+_]" id="akka.http.server.PathMatcher.Lift;MOps;M">M</a><span class="delimiter">[</span>+<a title="" id="akka.http.server.PathMatcher.Lift;MOps;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="()M[Nothing]" id="akka.http.server.PathMatcher.Lift;MOps.apply(5093332704)">apply</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.http.server.PathMatcher.Lift;MOps;M" title="M[Nothing]">M</a><span class="delimiter">[</span>Nothing<span class="delimiter">]</span>
      def <a title="[T](value: T)M[T]" id="akka.http.server.PathMatcher.Lift;MOps.apply(4864451f2f)">apply</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.Lift;MOps.apply(4864451f2f);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="akka.http.server.PathMatcher.Lift;MOps.apply(4864451f2f).value">value</a>: <a href="#akka.http.server.PathMatcher.Lift;MOps.apply(4864451f2f);T" title="T">T</a><span class="delimiter">)</span>: <a href="#akka.http.server.PathMatcher.Lift;MOps;M" title="M[T]">M</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
      def <a title="[T](value: T, more: M[T])M[T]" id="akka.http.server.PathMatcher.Lift;MOps.apply(256dbceff8)">apply</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.Lift;MOps.apply(256dbceff8);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="akka.http.server.PathMatcher.Lift;MOps.apply(256dbceff8).value">value</a>: <a href="#akka.http.server.PathMatcher.Lift;MOps.apply(256dbceff8);T" title="T">T</a>, <a title="M[T]" id="akka.http.server.PathMatcher.Lift;MOps.apply(256dbceff8).more">more</a>: <a href="#akka.http.server.PathMatcher.Lift;MOps;M" title="M[T]">M</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server.PathMatcher.Lift;MOps;M" title="M[T]">M</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
    <span class="delimiter">}</span>
    object <a title="akka.http.server.PathMatcher.Lift.MOps.type" id="akka.http.server.PathMatcher.Lift.MOps">MOps</a> <a href="#akka.http.server.PathMatcher.Lift.MOps" title="akka.http.server.PathMatcher.Lift.MOps.type" class="delimiter">{</a>
      implicit object <a title="akka.http.server.PathMatcher.Lift.MOps.OptionMOps.type" id="akka.http.server.PathMatcher.Lift.MOps.OptionMOps">OptionMOps</a> extends <a href="#akka.http.server.PathMatcher.Lift;MOps" title="akka.http.server.PathMatcher.Lift.MOps[Option]">MOps</a><span class="delimiter">[</span>Option<span class="delimiter">]</span> <span class="delimiter">{</span>
        def <a title="()Option[Nothing]" id="akka.http.server.PathMatcher.Lift.MOps.OptionMOps.apply(0560bfe344)">apply</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Option[Nothing]">Option</span><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> = <span title="None.type">None</span>
        def <a title="[T](value: T)Option[T]" id="akka.http.server.PathMatcher.Lift.MOps.OptionMOps.apply(b3ddbe236c)">apply</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.Lift.MOps.OptionMOps.apply(b3ddbe236c);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="akka.http.server.PathMatcher.Lift.MOps.OptionMOps.apply(b3ddbe236c).value">value</a>: <a href="#akka.http.server.PathMatcher.Lift.MOps.OptionMOps.apply(b3ddbe236c);T" title="T">T</a><span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="(x: T)Some[T]">Some</span><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher.Lift.MOps.OptionMOps.apply(b3ddbe236c).value" title="T">value</a><span class="delimiter">)</span>
        def <a title="[T](value: T, more: Option[T])Option[T]" id="akka.http.server.PathMatcher.Lift.MOps.OptionMOps.apply(de8af8d59e)">apply</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.Lift.MOps.OptionMOps.apply(de8af8d59e);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="akka.http.server.PathMatcher.Lift.MOps.OptionMOps.apply(de8af8d59e).value">value</a>: <a href="#akka.http.server.PathMatcher.Lift.MOps.OptionMOps.apply(de8af8d59e);T" title="T">T</a>, <a title="Option[T]" id="akka.http.server.PathMatcher.Lift.MOps.OptionMOps.apply(de8af8d59e).more">more</a>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span title="(x: T)Some[T]">Some</span><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher.Lift.MOps.OptionMOps.apply(de8af8d59e).value" title="T">value</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      implicit object <a title="akka.http.server.PathMatcher.Lift.MOps.ListMOps.type" id="akka.http.server.PathMatcher.Lift.MOps.ListMOps">ListMOps</a> extends <a href="#akka.http.server.PathMatcher.Lift;MOps" title="akka.http.server.PathMatcher.Lift.MOps[List]">MOps</a><span class="delimiter">[</span>List<span class="delimiter">]</span> <span class="delimiter">{</span>
        def <a title="()List[Nothing]" id="akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(7b7e140b3c)">apply</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="List[Nothing]">List</span><span class="delimiter">[</span>Nothing<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>
        def <a title="[T](value: T)List[T]" id="akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(a7fb727a2a)">apply</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(a7fb727a2a);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(a7fb727a2a).value">value</a>: <a href="#akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(a7fb727a2a);T" title="T">T</a><span class="delimiter">)</span>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(a7fb727a2a).value" title="T">value</a> <a href="#akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(a7fb727a2a).x$5" title="(x: T)List[T]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>
        def <a title="[T](value: T, more: List[T])List[T]" id="akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(36bf74b179)">apply</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(36bf74b179);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(36bf74b179).value">value</a>: <a href="#akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(36bf74b179);T" title="T">T</a>, <a title="List[T]" id="akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(36bf74b179).more">more</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(36bf74b179).value" title="T">value</a> <a href="#akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(36bf74b179).x$6" title="(x: T)List[T]">::</a> <a href="#akka.http.server.PathMatcher.Lift.MOps.ListMOps.apply(36bf74b179).more" title="List[T]">more</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    implicit def <a title="[M[+_]]=&gt; akka.http.server.PathMatcher.Lift[Unit,M]{type Out = Unit}" id="akka.http.server.PathMatcher.Lift.liftUnit">liftUnit</a><span class="delimiter">[</span><a title="[+_]" id="akka.http.server.PathMatcher.Lift.liftUnit;M">M</a><span class="delimiter">[</span>+<a title="" id="akka.http.server.PathMatcher.Lift.liftUnit;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> = new <a title="&lt;$anon: akka.http.server.PathMatcher.Lift[Unit,M]&gt; extends AnyRef with akka.http.server.PathMatcher.Lift[Unit,M]" id="akka.http.server.PathMatcher.Lift.liftUnit;$anon">Lift</a><span class="delimiter">[</span>Unit, M<span class="delimiter">]</span> <span class="delimiter">{</span>
      type <a title="Unit" id="akka.http.server.PathMatcher.Lift.liftUnit;$anon;Out">Out</a> = <span title="Unit">Unit</span>
      def <a title="=&gt; akka.http.server.util.Tuple[this.Out]" id="akka.http.server.PathMatcher.Lift.liftUnit;$anon.OutIsTuple">OutIsTuple</a> = <span title="[T](implicit e: T)T">implicitly</span><a href="util/Tuple.scala.html#akka.http.server.util.Tuple.forUnit" title="(implicit e: akka.http.server.util.Tuple[this.Out])akka.http.server.util.Tuple[this.Out]" class="delimiter">[</a><a href="util/Tuple.scala.html#akka.http.server.util;Tuple" title="akka.http.server.util.Tuple[this.Out]">Tuple</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">]</span>
      def <a title="()Unit" id="akka.http.server.PathMatcher.Lift.liftUnit;$anon.apply(aa97cb1b3d)">apply</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
      def <a title="(value: Unit)Unit" id="akka.http.server.PathMatcher.Lift.liftUnit;$anon.apply(9bdfa33009)">apply</a><span class="delimiter">(</span><a title="Unit" id="akka.http.server.PathMatcher.Lift.liftUnit;$anon.apply(9bdfa33009).value">value</a>: <span title="Unit">Unit</span><span class="delimiter">)</span> = <a href="#akka.http.server.PathMatcher.Lift.liftUnit;$anon.apply(9bdfa33009).value" title="Unit">value</a>
      def <a title="(value: Unit, more: this.Out)Unit" id="akka.http.server.PathMatcher.Lift.liftUnit;$anon.apply(b6c9e862f4)">apply</a><span class="delimiter">(</span><a title="Unit" id="akka.http.server.PathMatcher.Lift.liftUnit;$anon.apply(b6c9e862f4).value">value</a>: <span title="Unit">Unit</span>, <a title="this.Out" id="akka.http.server.PathMatcher.Lift.liftUnit;$anon.apply(b6c9e862f4).more">more</a>: <span title="this.Out">Out</span><span class="delimiter">)</span> = <a href="#akka.http.server.PathMatcher.Lift.liftUnit;$anon.apply(b6c9e862f4).value" title="Unit">value</a>
    <span class="delimiter">}</span>
    implicit def <a title="[A, M[+_]](implicit mops: akka.http.server.PathMatcher.Lift.MOps[M])akka.http.server.PathMatcher.Lift[(A,),M]{type Out = (M[A],); def apply(): (M[Nothing],)}" id="akka.http.server.PathMatcher.Lift.liftSingleElement">liftSingleElement</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher.Lift.liftSingleElement;A">A</a>, <a title="[+_]" id="akka.http.server.PathMatcher.Lift.liftSingleElement;M">M</a><span class="delimiter">[</span>+<a title="" id="akka.http.server.PathMatcher.Lift.liftSingleElement;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="akka.http.server.PathMatcher.Lift.MOps[M]" id="akka.http.server.PathMatcher.Lift.liftSingleElement.mops">mops</a>: <a href="#akka.http.server.PathMatcher.Lift;MOps" title="akka.http.server.PathMatcher.Lift.MOps[M]">MOps</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = new <a title="&lt;$anon: akka.http.server.PathMatcher.Lift[(A,),M]&gt; extends AnyRef with akka.http.server.PathMatcher.Lift[(A,),M]" id="akka.http.server.PathMatcher.Lift.liftSingleElement;$anon">Lift</a><span class="delimiter">[</span>Tuple1<span class="delimiter">[</span>A<span class="delimiter">]</span>, M<span class="delimiter">]</span> <span class="delimiter">{</span>
      type <a title="(M[A],)" id="akka.http.server.PathMatcher.Lift.liftSingleElement;$anon;Out">Out</a> = <span title="(M[A],)">Tuple1</span><span class="delimiter">[</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>
      def <a title="=&gt; akka.http.server.util.Tuple[this.Out]" id="akka.http.server.PathMatcher.Lift.liftSingleElement;$anon.OutIsTuple">OutIsTuple</a> = <span title="[T](implicit e: T)T">implicitly</span><a href="util/Tuple.scala.html#akka.http.server.util.Tuple.forTuple1" title="(implicit e: akka.http.server.util.Tuple[this.Out])akka.http.server.util.Tuple[this.Out]" class="delimiter">[</a><a href="util/Tuple.scala.html#akka.http.server.util;Tuple" title="akka.http.server.util.Tuple[this.Out]">Tuple</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">]</span>
      def <a title="()(M[Nothing],)" id="akka.http.server.PathMatcher.Lift.liftSingleElement;$anon.apply(80b9bf6834)">apply</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span title="(_1: M[Nothing])(M[Nothing],)">Tuple1</span><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher.Lift;MOps.apply(5093332704)" title="()M[Nothing]">mops</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      def <a title="(value: (A,))(M[A],)" id="akka.http.server.PathMatcher.Lift.liftSingleElement;$anon.apply(9d5726ef77)">apply</a><span class="delimiter">(</span><a title="(A,)" id="akka.http.server.PathMatcher.Lift.liftSingleElement;$anon.apply(9d5726ef77).value">value</a>: <span title="(A,)">Tuple1</span><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span> = <span title="(_1: M[A])(M[A],)">Tuple1</span><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher.Lift;MOps.apply(4864451f2f)" title="(value: A)M[A]">mops</a><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher.Lift.liftSingleElement;$anon.apply(9d5726ef77).value" title="(A,)">value</a>.<span title="=&gt; A">_1</span><span class="delimiter">)</span><span class="delimiter">)</span>
      def <a title="(value: (A,), more: this.Out)(M[A],)" id="akka.http.server.PathMatcher.Lift.liftSingleElement;$anon.apply(f80f6b8c50)">apply</a><span class="delimiter">(</span><a title="(A,)" id="akka.http.server.PathMatcher.Lift.liftSingleElement;$anon.apply(f80f6b8c50).value">value</a>: <span title="(A,)">Tuple1</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="this.Out" id="akka.http.server.PathMatcher.Lift.liftSingleElement;$anon.apply(f80f6b8c50).more">more</a>: <span title="this.Out">Out</span><span class="delimiter">)</span> = <span title="(_1: M[A])(M[A],)">Tuple1</span><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher.Lift;MOps.apply(256dbceff8)" title="(value: A, more: M[A])M[A]">mops</a><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher.Lift.liftSingleElement;$anon.apply(f80f6b8c50).value" title="(A,)">value</a>.<span title="=&gt; A">_1</span>, <a href="#akka.http.server.PathMatcher.Lift.liftSingleElement;$anon.apply(f80f6b8c50).more" title="this.Out">more</a>.<span title="=&gt; M[A]">_1</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  trait <a title="trait LowLevelLiftImplicits extends AnyRef" id="akka.http.server.PathMatcher;LowLevelLiftImplicits">LowLevelLiftImplicits</a> <span title="Unit" class="delimiter">{</span>
    import <a href="#akka.http.server.PathMatcher.Lift" title="akka.http.server.PathMatcher.Lift.type">Lift</a>._
    implicit def <a title="[T, M[+_]](implicit mops: akka.http.server.PathMatcher.Lift.MOps[M])akka.http.server.PathMatcher.Lift[T,M]{type Out = (M[T],); def apply(): (M[Nothing],)}" id="akka.http.server.PathMatcher;LowLevelLiftImplicits.default">default</a><span class="delimiter">[</span><a title="" id="akka.http.server.PathMatcher;LowLevelLiftImplicits.default;T">T</a>, <a title="[+_]" id="akka.http.server.PathMatcher;LowLevelLiftImplicits.default;M">M</a><span class="delimiter">[</span>+<a title="" id="akka.http.server.PathMatcher;LowLevelLiftImplicits.default;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span>implicit <a title="akka.http.server.PathMatcher.Lift.MOps[M]" id="akka.http.server.PathMatcher;LowLevelLiftImplicits.default.mops">mops</a>: <a href="#akka.http.server.PathMatcher.Lift;MOps" title="akka.http.server.PathMatcher.Lift.MOps[M]">MOps</a><span class="delimiter">[</span>M<span class="delimiter">]</span><span class="delimiter">)</span> = new <a title="&lt;$anon: akka.http.server.PathMatcher.Lift[T,M]&gt; extends AnyRef with akka.http.server.PathMatcher.Lift[T,M]" id="akka.http.server.PathMatcher;LowLevelLiftImplicits.default;$anon">Lift</a><span class="delimiter">[</span>T, M<span class="delimiter">]</span> <span class="delimiter">{</span>
      type <a title="(M[T],)" id="akka.http.server.PathMatcher;LowLevelLiftImplicits.default;$anon;Out">Out</a> = <span title="(M[T],)">Tuple1</span><span class="delimiter">[</span>M<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
      def <a title="=&gt; akka.http.server.util.Tuple[this.Out]" id="akka.http.server.PathMatcher;LowLevelLiftImplicits.default;$anon.OutIsTuple">OutIsTuple</a> = <span title="[T](implicit e: T)T">implicitly</span><a href="util/Tuple.scala.html#akka.http.server.util.Tuple.forTuple1" title="(implicit e: akka.http.server.util.Tuple[this.Out])akka.http.server.util.Tuple[this.Out]" class="delimiter">[</a><a href="util/Tuple.scala.html#akka.http.server.util;Tuple" title="akka.http.server.util.Tuple[this.Out]">Tuple</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">]</span>
      def <a title="()(M[Nothing],)" id="akka.http.server.PathMatcher;LowLevelLiftImplicits.default;$anon.apply(80b9bf6834)">apply</a><span class="delimiter">(</span><span class="delimiter">)</span> = <span title="(_1: M[Nothing])(M[Nothing],)">Tuple1</span><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher.Lift;MOps.apply(5093332704)" title="()M[Nothing]">mops</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      def <a title="(value: T)(M[T],)" id="akka.http.server.PathMatcher;LowLevelLiftImplicits.default;$anon.apply(a7b48a87e4)">apply</a><span class="delimiter">(</span><a title="T" id="akka.http.server.PathMatcher;LowLevelLiftImplicits.default;$anon.apply(a7b48a87e4).value">value</a>: <a href="#akka.http.server.PathMatcher;LowLevelLiftImplicits.default;T" title="T">T</a><span class="delimiter">)</span> = <span title="(_1: M[T])(M[T],)">Tuple1</span><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher.Lift;MOps.apply(4864451f2f)" title="(value: T)M[T]">mops</a><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher;LowLevelLiftImplicits.default;$anon.apply(a7b48a87e4).value" title="T">value</a><span class="delimiter">)</span><span class="delimiter">)</span>
      def <a title="(value: T, more: this.Out)(M[T],)" id="akka.http.server.PathMatcher;LowLevelLiftImplicits.default;$anon.apply(d6cb7a4579)">apply</a><span class="delimiter">(</span><a title="T" id="akka.http.server.PathMatcher;LowLevelLiftImplicits.default;$anon.apply(d6cb7a4579).value">value</a>: <a href="#akka.http.server.PathMatcher;LowLevelLiftImplicits.default;T" title="T">T</a>, <a title="this.Out" id="akka.http.server.PathMatcher;LowLevelLiftImplicits.default;$anon.apply(d6cb7a4579).more">more</a>: <span title="this.Out">Out</span><span class="delimiter">)</span> = <span title="(_1: M[T])(M[T],)">Tuple1</span><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher.Lift;MOps.apply(256dbceff8)" title="(value: T, more: M[T])M[T]">mops</a><span class="delimiter">(</span><a href="#akka.http.server.PathMatcher;LowLevelLiftImplicits.default;$anon.apply(d6cb7a4579).value" title="T">value</a>, <a href="#akka.http.server.PathMatcher;LowLevelLiftImplicits.default;$anon.apply(d6cb7a4579).more" title="this.Out">more</a>.<span title="=&gt; M[T]">_1</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span title="AnyRef" class="delimiter">}</span>

trait <a title="trait ImplicitPathMatcherConstruction extends AnyRef" id="akka.http.server;ImplicitPathMatcherConstruction">ImplicitPathMatcherConstruction</a> <span title="Unit" class="delimiter">{</span>
  import <a href="#akka.http.server.PathMatcher" title="akka.http.server.PathMatcher.type">PathMatcher</a>._

  <span class="comment">/**
   * Creates a PathMatcher that consumes (a prefix of) the first path segment
   * (if the path begins with a segment) and extracts a given value.
   */</span>
  implicit def <a title="[T](tuple: (String, T))akka.http.server.PathMatcher1[T]" id="akka.http.server;ImplicitPathMatcherConstruction.stringExtractionPair2PathMatcher">stringExtractionPair2PathMatcher</a><span class="delimiter">[</span><a title="" id="akka.http.server;ImplicitPathMatcherConstruction.stringExtractionPair2PathMatcher;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(String, T)" id="akka.http.server;ImplicitPathMatcherConstruction.stringExtractionPair2PathMatcher.tuple">tuple</a>: <span title="(String, T)" class="delimiter">(</span>String, T<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher1[T]">PathMatcher1</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#akka.http.server.PathMatcher.apply(9c45d37167)" title="(prefix: akka.http.model.Uri.Path, extractions: (T,))(implicit evidence$17: akka.http.server.util.Tuple[(T,)])akka.http.server.PathMatcher[(T,)]">PathMatcher</a><a href="util/Tuple.scala.html#akka.http.server.util.Tuple.forTuple1" title="akka.http.server.util.Tuple[(T,)]" class="delimiter">(</a><a href="#akka.http.server;ImplicitPathMatcherConstruction.stringExtractionPair2PathMatcher.tuple" title="(String, T)">tuple</a>.<span title="=&gt; String">_1</span> <a href="../model/Uri.scala.html#akka.http.model.Uri.Path.Empty.::(c8ba4e91e7)" title="(segment: String)akka.http.model.Uri.Path">::</a> <a href="../model/Uri.scala.html#akka.http.model.Uri.Path" title="akka.http.model.Uri.Path.type">Path</a>.<a href="../model/Uri.scala.html#akka.http.model.Uri.Path.Empty" title="akka.http.model.Uri.Path.Empty.type">Empty</a>, <span title="(_1: T)(T,)">Tuple1</span><span class="delimiter">(</span><a href="#akka.http.server;ImplicitPathMatcherConstruction.stringExtractionPair2PathMatcher.tuple" title="(String, T)">tuple</a>.<span title="=&gt; T">_2</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Creates a PathMatcher that consumes (a prefix of) the first path segment
   * (if the path begins with a segment).
   */</span>
  implicit def <a title="implicit akka.http.server.ImplicitPathMatcherConstruction.segmentStringToPathMatcher : (segment: String)akka.http.server.PathMatcher0" id="akka.http.server;ImplicitPathMatcherConstruction.segmentStringToPathMatcher">segmentStringToPathMatcher</a><span class="delimiter">(</span><a title="String" id="akka.http.server;ImplicitPathMatcherConstruction.segmentStringToPathMatcher.segment">segment</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher0">PathMatcher0</a> =
    <a href="#akka.http.server.PathMatcher.apply(9c45d37167)" title="(prefix: akka.http.model.Uri.Path, extractions: Unit)(implicit evidence$17: akka.http.server.util.Tuple[Unit])akka.http.server.PathMatcher[Unit]">PathMatcher</a><a href="util/Tuple.scala.html#akka.http.server.util.Tuple.forUnit" title="akka.http.server.util.Tuple[Unit]" class="delimiter">(</a><a href="#akka.http.server;ImplicitPathMatcherConstruction.segmentStringToPathMatcher.segment" title="String">segment</a> <a href="../model/Uri.scala.html#akka.http.model.Uri.Path.Empty.::(c8ba4e91e7)" title="(segment: String)akka.http.model.Uri.Path">::</a> <a href="../model/Uri.scala.html#akka.http.model.Uri.Path" title="akka.http.model.Uri.Path.type">Path</a>.<a href="../model/Uri.scala.html#akka.http.model.Uri.Path.Empty" title="akka.http.model.Uri.Path.Empty.type">Empty</a>, <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  implicit def <a title="implicit akka.http.server.ImplicitPathMatcherConstruction.stringNameOptionReceptacle2PathMatcher : (nr: akka.http.common.NameOptionReceptacle[String])akka.http.server.PathMatcher0" id="akka.http.server;ImplicitPathMatcherConstruction.stringNameOptionReceptacle2PathMatcher">stringNameOptionReceptacle2PathMatcher</a><span class="delimiter">(</span><a title="akka.http.common.NameOptionReceptacle[String]" id="akka.http.server;ImplicitPathMatcherConstruction.stringNameOptionReceptacle2PathMatcher.nr">nr</a>: <a href="../common/NameReceptacle.scala.html#akka.http.common;NameOptionReceptacle" title="akka.http.common.NameOptionReceptacle[String]">NameOptionReceptacle</a><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher0">PathMatcher0</a> =
    <a href="#akka.http.server.PathMatcher.apply(2bcbf921fb)" title="(magnet: akka.http.server.PathMatcher[Unit])akka.http.server.PathMatcher[Unit]">PathMatcher</a><a href="#akka.http.server.PathMatcher.EnhancedPathMatcher" title="(underlying: akka.http.server.PathMatcher[Unit])akka.http.server.PathMatcher.EnhancedPathMatcher[Unit]" class="delimiter">(</a><a href="#akka.http.server;ImplicitPathMatcherConstruction.stringNameOptionReceptacle2PathMatcher.nr" title="akka.http.common.NameOptionReceptacle[String]">nr</a>.<a href="#akka.http.server;ImplicitPathMatcherConstruction.segmentStringToPathMatcher" title="implicit akka.http.server.ImplicitPathMatcherConstruction.segmentStringToPathMatcher : (segment: String)akka.http.server.PathMatcher0">name</a><span class="delimiter">)</span>.<a href="#akka.http.server.PathMatcher;EnhancedPathMatcher.?" title="(implicit lift: akka.http.server.PathMatcher.Lift[Unit,Option])akka.http.server.PathMatcher[lift.Out]">?</a>

  <span class="comment">/**
   * Creates a PathMatcher that consumes (a prefix of) the first path segment
   * if the path begins with a segment (a prefix of) which matches the given regex.
   * Extracts either the complete match (if the regex doesn't contain a capture group) or
   * the capture group (if the regex contains exactly one).
   * If the regex contains more than one capture group the method throws an IllegalArgumentException.
   */</span>
  implicit def <a title="implicit akka.http.server.ImplicitPathMatcherConstruction.regex2PathMatcher : (regex: scala.util.matching.Regex)akka.http.server.PathMatcher1[String]" id="akka.http.server;ImplicitPathMatcherConstruction.regex2PathMatcher">regex2PathMatcher</a><span class="delimiter">(</span><a title="scala.util.matching.Regex" id="akka.http.server;ImplicitPathMatcherConstruction.regex2PathMatcher.regex">regex</a>: <span title="scala.util.matching.Regex">Regex</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher1[String]">PathMatcher1</a><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="../util/package.scala.html#akka.http.util.package.enhanceRegex" title="implicit akka.http.util.package.enhanceRegex : (regex: scala.util.matching.Regex)akka.http.util.EnhancedRegex">regex</a>.<a href="../util/EnhancedRegex.scala.html#akka.http.util;EnhancedRegex.groupCount" title="=&gt; Int">groupCount</a> match <span class="delimiter">{</span>
    case <span title="Int(0)" class="int">0</span> ⇒ new <span title="&lt;$anon: akka.http.model.Uri.Path =&gt; akka.http.server.PathMatcher.Matching[(String,)]&gt; extends akka.http.server.PathMatcher1[String]">PathMatcher1</span><span class="delimiter">[</span>String<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <span title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[(String,)]">apply</span><span class="delimiter">(</span><span title="akka.http.model.Uri.Path">path</span>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = <span title="akka.http.model.Uri.Path">path</span> match <span class="delimiter">{</span>
        case Path.Segment<span class="delimiter">(</span><span title="String">segment</span>, <span title="akka.http.model.Uri.Path.SlashOrEmpty">tail</span><span class="delimiter">)</span> ⇒ <a href="#akka.http.server;ImplicitPathMatcherConstruction.regex2PathMatcher.regex" title="scala.util.matching.Regex">regex</a> <span title="(source: CharSequence)Option[String]">findPrefixOf</span> <span title="String">segment</span> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><span title="String">m</span><span class="delimiter">)</span> ⇒ <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: (String,))(implicit evidence$9: akka.http.server.util.Tuple[(String,)])akka.http.server.PathMatcher.Matched[(String,)]">Matched</a><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[(String,)]" class="delimiter">(</a><span title="String">segment</span>.<span title="(x$1: Int)String">substring</span><span class="delimiter">(</span><span title="String">m</span>.<span title="()Int">length</span><span class="delimiter">)</span> <a href="../model/Uri.scala.html#akka.http.model.Uri;Path.::(c8ba4e91e7)" title="(segment: String)akka.http.model.Uri.Path">::</a> <span title="akka.http.model.Uri.Path.SlashOrEmpty">tail</span>, <span title="(_1: String)(String,)">Tuple1</span><span class="delimiter">(</span><span title="String">m</span><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span title="None.type">None</span>    ⇒ <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>
        <span class="delimiter">}</span>
        case _ ⇒ <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    case <span title="Int(1)" class="int">1</span> ⇒ new <span title="&lt;$anon: akka.http.model.Uri.Path =&gt; akka.http.server.PathMatcher.Matching[(String,)]&gt; extends akka.http.server.PathMatcher1[String]">PathMatcher1</span><span class="delimiter">[</span>String<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <span title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[(String,)]">apply</span><span class="delimiter">(</span><span title="akka.http.model.Uri.Path">path</span>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = <span title="akka.http.model.Uri.Path">path</span> match <span class="delimiter">{</span>
        case Path.Segment<span class="delimiter">(</span><span title="String">segment</span>, <span title="akka.http.model.Uri.Path.SlashOrEmpty">tail</span><span class="delimiter">)</span> ⇒ <a href="#akka.http.server;ImplicitPathMatcherConstruction.regex2PathMatcher.regex" title="scala.util.matching.Regex">regex</a> <span title="(source: CharSequence)Option[scala.util.matching.Regex.Match]">findPrefixMatchOf</span> <span title="String">segment</span> match <span class="delimiter">{</span>
          case Some<span class="delimiter">(</span><span title="scala.util.matching.Regex.Match">m</span><span class="delimiter">)</span> ⇒ <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: (String,))(implicit evidence$9: akka.http.server.util.Tuple[(String,)])akka.http.server.PathMatcher.Matched[(String,)]">Matched</a><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[(String,)]" class="delimiter">(</a><span title="String">segment</span>.<span title="(x$1: Int)String">substring</span><span class="delimiter">(</span><span title="scala.util.matching.Regex.Match">m</span>.<span title="=&gt; Int">end</span><span class="delimiter">)</span> <a href="../model/Uri.scala.html#akka.http.model.Uri;Path.::(c8ba4e91e7)" title="(segment: String)akka.http.model.Uri.Path">::</a> <span title="akka.http.model.Uri.Path.SlashOrEmpty">tail</span>, <span title="(_1: String)(String,)">Tuple1</span><span class="delimiter">(</span><span title="scala.util.matching.Regex.Match">m</span>.<span title="(i: Int)String">group</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          case <span title="None.type">None</span>    ⇒ <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>
        <span class="delimiter">}</span>
        case _ ⇒ <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    case _ ⇒ throw new <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="String(&quot;Path regex \'&quot;)" class="string">&quot;Path regex '&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.http.server;ImplicitPathMatcherConstruction.regex2PathMatcher.regex" title="scala.util.matching.Regex">regex</a>.<span title="=&gt; java.util.regex.Pattern">pattern</span>.<span title="()String">pattern</span> <span title="(x$1: Any)String">+</span>
      <span title="String(&quot;\' must not contain more than one capturing group&quot;)" class="string">&quot;' must not contain more than one capturing group&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * Creates a PathMatcher from the given Map of path segments (prefixes) to extracted values.
   * If the unmatched path starts with a segment having one of the maps keys as a prefix
   * the matcher consumes this path segment (prefix) and extracts the corresponding map value.
   */</span>
  implicit def <a title="[T](valueMap: Map[String,T])akka.http.server.PathMatcher1[T]" id="akka.http.server;ImplicitPathMatcherConstruction.valueMap2PathMatcher">valueMap2PathMatcher</a><span class="delimiter">[</span><a title="" id="akka.http.server;ImplicitPathMatcherConstruction.valueMap2PathMatcher;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Map[String,T]" id="akka.http.server;ImplicitPathMatcherConstruction.valueMap2PathMatcher.valueMap">valueMap</a>: <span title="Map[String,T]">Map</span><span class="delimiter">[</span>String, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher1[T]">PathMatcher1</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    if <span class="delimiter">(</span><a href="#akka.http.server;ImplicitPathMatcherConstruction.valueMap2PathMatcher.valueMap" title="Map[String,T]">valueMap</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#akka.http.server.PathMatchers" title="akka.http.server.PathMatchers.type">PathMatchers</a>.<a href="#akka.http.server;PathMatchers.nothingMatcher" title="(implicit evidence$18: akka.http.server.util.Tuple[(T,)])akka.http.server.PathMatcher[(T,)]">nothingMatcher</a>
    else <a href="#akka.http.server;ImplicitPathMatcherConstruction.valueMap2PathMatcher.valueMap" title="Map[String,T]">valueMap</a>.<span title="(f: ((String, T)) =&gt; akka.http.server.PathMatcher1[T])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[String,T],akka.http.server.PathMatcher1[T],scala.collection.immutable.Iterable[akka.http.server.PathMatcher1[T]]])scala.collection.immutable.Iterable[akka.http.server.PathMatcher1[T]]">map</span> <a href="#akka.http.server;ImplicitPathMatcherConstruction.valueMap2PathMatcher.$anonfun.x0$3" title="akka.http.server.PathMatcher1[T]" class="delimiter">{</a> case <span class="delimiter">(</span><a title="String" id="akka.http.server;ImplicitPathMatcherConstruction.valueMap2PathMatcher.$anonfun.prefix">prefix</a>, <a title="T" id="akka.http.server;ImplicitPathMatcherConstruction.valueMap2PathMatcher.$anonfun.value">value</a><span class="delimiter">)</span> ⇒ <a href="#akka.http.server;ImplicitPathMatcherConstruction.stringExtractionPair2PathMatcher" title="(tuple: (String, T))akka.http.server.PathMatcher1[T]">stringExtractionPair2PathMatcher</a><span title="(_1: String, _2: T)(String, T)" class="delimiter">(</span><a href="#akka.http.server;ImplicitPathMatcherConstruction.valueMap2PathMatcher.$anonfun.prefix" title="String">prefix</a>, <a href="#akka.http.server;ImplicitPathMatcherConstruction.valueMap2PathMatcher.$anonfun.value" title="T">value</a><span class="delimiter">)</span> <span class="delimiter">}</span>.<span title="(op: (akka.http.server.PathMatcher1[T], akka.http.server.PathMatcher1[T]) =&gt; akka.http.server.PathMatcher1[T])akka.http.server.PathMatcher1[T]">reduceLeft</span><span class="delimiter">(</span><a href="#akka.http.server;ImplicitPathMatcherConstruction.valueMap2PathMatcher.$anonfun.x$11" title="akka.http.server.PathMatcher1[T]">_</a> <a href="#akka.http.server;PathMatcher.|" title="(other: akka.http.server.PathMatcher[_ &lt;: (T,)])(implicit evidence$1: akka.http.server.util.Tuple[(T,)])akka.http.server.PathMatcher[(T,)]">|</a> <a href="#akka.http.server;ImplicitPathMatcherConstruction.valueMap2PathMatcher.$anonfun.x$12" title="akka.http.server.PathMatcher1[T]">_</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

trait <a title="trait PathMatchers extends AnyRef" id="akka.http.server;PathMatchers">PathMatchers</a> <span title="Unit" class="delimiter">{</span>
  import <a href="#akka.http.server.PathMatcher" title="akka.http.server.PathMatcher.type">PathMatcher</a>._

  <span class="comment">/**
   * Converts a path string containing slashes into a PathMatcher that interprets slashes as
   * path segment separators.
   */</span>
  def <a title="(string: String)akka.http.server.PathMatcher0" id="akka.http.server;PathMatchers.separateOnSlashes">separateOnSlashes</a><span class="delimiter">(</span><a title="String" id="akka.http.server;PathMatchers.separateOnSlashes.string">string</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher0">PathMatcher0</a> = <span class="delimiter">{</span>
    @tailrec def <a title="(ix: Int, matcher: akka.http.server.PathMatcher0)akka.http.server.PathMatcher0" id="akka.http.server;PathMatchers.separateOnSlashes.split">split</a><span class="delimiter">(</span><a title="Int" id="akka.http.server;PathMatchers.separateOnSlashes.split$default$1">ix</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>, <a title="akka.http.server.PathMatcher0" id="akka.http.server;PathMatchers.separateOnSlashes.split$default$2">matcher</a>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher0">PathMatcher0</a> = null<span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher0">PathMatcher0</a> = <span class="delimiter">{</span>
      val <a title="Int" id="akka.http.server;PathMatchers.separateOnSlashes.split.nextIx">nextIx</a> = <a href="#akka.http.server;PathMatchers.separateOnSlashes.string" title="String">string</a>.<span title="(x$1: Int, x$2: Int)Int">indexOf</span><span class="delimiter">(</span><span title="Int(47)" class="char">'/'</span>, <a href="#akka.http.server;PathMatchers.separateOnSlashes.split$default$1" title="Int">ix</a><span class="delimiter">)</span>
      def <a title="(m: akka.http.server.PathMatcher0)akka.http.server.PathMatcher0" id="akka.http.server;PathMatchers.separateOnSlashes.split.append">append</a><span class="delimiter">(</span><a title="akka.http.server.PathMatcher0" id="akka.http.server;PathMatchers.separateOnSlashes.split.append.m">m</a>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher0">PathMatcher0</a><span class="delimiter">)</span> = if <span class="delimiter">(</span><a href="#akka.http.server;PathMatchers.separateOnSlashes.split$default$2" title="akka.http.server.PathMatcher0">matcher</a> <span title="(x$1: AnyRef)Boolean">eq</span> null<span class="delimiter">)</span> <a href="#akka.http.server;PathMatchers.separateOnSlashes.split.append.m" title="akka.http.server.PathMatcher0">m</a> else <a href="#akka.http.server;PathMatchers.separateOnSlashes.split$default$2" title="akka.http.server.PathMatcher0">matcher</a> <a href="#akka.http.server;PathMatcher./(e066621251)" title="(other: akka.http.server.PathMatcher[Unit])(implicit join: akka.http.server.util.TupleOps.Join[Unit,Unit])akka.http.server.PathMatcher[join.Out]">/</a> <a href="#akka.http.server;PathMatchers.separateOnSlashes.split.append.m" title="akka.http.server.PathMatcher0">m</a>
      if <span class="delimiter">(</span><a href="#akka.http.server;PathMatchers.separateOnSlashes.split.nextIx" title="Int">nextIx</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <a href="#akka.http.server;PathMatchers.separateOnSlashes.split.append" title="(m: akka.http.server.PathMatcher0)akka.http.server.PathMatcher0">append</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers.separateOnSlashes.string" title="String">string</a>.<span title="(x$1: Int)String">substring</span><a href="#akka.http.server;ImplicitPathMatcherConstruction.segmentStringToPathMatcher" title="implicit akka.http.server.ImplicitPathMatcherConstruction.segmentStringToPathMatcher : (segment: String)akka.http.server.PathMatcher0" class="delimiter">(</a><a href="#akka.http.server;PathMatchers.separateOnSlashes.split$default$1" title="Int">ix</a><span class="delimiter">)</span><span class="delimiter">)</span>
      else <a href="#akka.http.server;PathMatchers.separateOnSlashes.split" title="(ix: Int, matcher: akka.http.server.PathMatcher0)akka.http.server.PathMatcher0">split</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers.separateOnSlashes.split.nextIx" title="Int">nextIx</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#akka.http.server;PathMatchers.separateOnSlashes.split.append" title="(m: akka.http.server.PathMatcher0)akka.http.server.PathMatcher0">append</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers.separateOnSlashes.string" title="String">string</a>.<span title="(x$1: Int, x$2: Int)String">substring</span><a href="#akka.http.server;ImplicitPathMatcherConstruction.segmentStringToPathMatcher" title="implicit akka.http.server.ImplicitPathMatcherConstruction.segmentStringToPathMatcher : (segment: String)akka.http.server.PathMatcher0" class="delimiter">(</a><a href="#akka.http.server;PathMatchers.separateOnSlashes.split$default$1" title="Int">ix</a>, <a href="#akka.http.server;PathMatchers.separateOnSlashes.split.nextIx" title="Int">nextIx</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#akka.http.server;PathMatchers.separateOnSlashes.split" title="(ix: Int, matcher: akka.http.server.PathMatcher0)akka.http.server.PathMatcher0">split</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A PathMatcher that matches a single slash character ('/').
   */</span>
  object <a title="PathMatchers.this.Slash.type" id="akka.http.server;PathMatchers.Slash">Slash</a> extends <a href="package.scala.html#akka.http.server.package;PathMatcher0" title="akka.http.server.PathMatcher0">PathMatcher0</a> <span class="delimiter">{</span>
    def <a title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[Unit]" id="akka.http.server;PathMatchers.Slash.apply">apply</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatchers.Slash.apply.path">path</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = <a href="#akka.http.server;PathMatchers.Slash.apply.path" title="akka.http.model.Uri.Path">path</a> match <span class="delimiter">{</span>
      case Path.Slash<span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatchers.Slash.apply.tail">tail</a><span class="delimiter">)</span> ⇒ <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: Unit)(implicit evidence$9: akka.http.server.util.Tuple[Unit])akka.http.server.PathMatcher.Matched[Unit]">Matched</a><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[Unit]" class="delimiter">(</a><a href="#akka.http.server;PathMatchers.Slash.apply.tail" title="akka.http.model.Uri.Path">tail</a>, <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      case _                ⇒ <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A PathMatcher that matches the very end of the requests URI path.
   */</span>
  object <a title="PathMatchers.this.PathEnd.type" id="akka.http.server;PathMatchers.PathEnd">PathEnd</a> extends <a href="package.scala.html#akka.http.server.package;PathMatcher0" title="akka.http.server.PathMatcher0">PathMatcher0</a> <span class="delimiter">{</span>
    def <a title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[Unit]" id="akka.http.server;PathMatchers.PathEnd.apply">apply</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatchers.PathEnd.apply.path">path</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = <a href="#akka.http.server;PathMatchers.PathEnd.apply.path" title="akka.http.model.Uri.Path">path</a> match <span class="delimiter">{</span>
      case <a href="../model/Uri.scala.html#akka.http.model.Uri.Path" title="akka.http.model.Uri.Path.type">Path</a>.<a href="../model/Uri.scala.html#akka.http.model.Uri.Path.Empty" title="akka.http.model.Uri.Path.Empty.type">Empty</a> ⇒ <a href="#akka.http.server.PathMatcher.Matched.readResolve" title="akka.http.server.PathMatcher.Matched.type">Matched</a>.<a href="#akka.http.server.PathMatcher.Matched.Empty" title="=&gt; akka.http.server.PathMatcher.Matched[Unit]">Empty</a>
      case _          ⇒ <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A PathMatcher that matches and extracts the complete remaining,
   * unmatched part of the request's URI path as an (encoded!) String.
   * If you need access to the remaining unencoded elements of the path
   * use the `RestPath` matcher!
   */</span>
  object <a title="PathMatchers.this.Rest.type" id="akka.http.server;PathMatchers.Rest">Rest</a> extends <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher1[String]">PathMatcher1</a><span class="delimiter">[</span>String<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matched[(String,)]" id="akka.http.server;PathMatchers.Rest.apply">apply</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatchers.Rest.apply.path">path</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: (String,))(implicit evidence$9: akka.http.server.util.Tuple[(String,)])akka.http.server.PathMatcher.Matched[(String,)]">Matched</a><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[(String,)]" class="delimiter">(</a><a href="../model/Uri.scala.html#akka.http.model.Uri.Path" title="akka.http.model.Uri.Path.type">Path</a>.<a href="../model/Uri.scala.html#akka.http.model.Uri.Path.Empty" title="akka.http.model.Uri.Path.Empty.type">Empty</a>, <span title="(_1: String)(String,)">Tuple1</span><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers.Rest.apply.path" title="akka.http.model.Uri.Path">path</a>.<a href="../model/Uri.scala.html#akka.http.model.Uri;Path.toString" title="()String">toString</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A PathMatcher that matches and extracts the complete remaining,
   * unmatched part of the request's URI path.
   */</span>
  object <a title="PathMatchers.this.RestPath.type" id="akka.http.server;PathMatchers.RestPath">RestPath</a> extends <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher1[akka.http.model.Uri.Path]">PathMatcher1</a><span class="delimiter">[</span>Path<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matched[(akka.http.model.Uri.Path,)]" id="akka.http.server;PathMatchers.RestPath.apply">apply</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatchers.RestPath.apply.path">path</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: (akka.http.model.Uri.Path,))(implicit evidence$9: akka.http.server.util.Tuple[(akka.http.model.Uri.Path,)])akka.http.server.PathMatcher.Matched[(akka.http.model.Uri.Path,)]">Matched</a><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[(akka.http.model.Uri.Path,)]" class="delimiter">(</a><a href="../model/Uri.scala.html#akka.http.model.Uri.Path" title="akka.http.model.Uri.Path.type">Path</a>.<a href="../model/Uri.scala.html#akka.http.model.Uri.Path.Empty" title="akka.http.model.Uri.Path.Empty.type">Empty</a>, <span title="(_1: akka.http.model.Uri.Path)(akka.http.model.Uri.Path,)">Tuple1</span><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers.RestPath.apply.path" title="akka.http.model.Uri.Path">path</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A PathMatcher that efficiently matches a number of digits and extracts their (non-negative) Int value.
   * The matcher will not match 0 digits or a sequence of digits that would represent an Int value larger
   * than Int.MaxValue.
   */</span>
  object <a title="PathMatchers.this.IntNumber.type" id="akka.http.server;PathMatchers.IntNumber">IntNumber</a> extends <a href="#akka.http.server;PathMatchers;NumberMatcher" title="PathMatchers.this.NumberMatcher[Int]">NumberMatcher</a><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">(</span>Int.<span title="Int(2147483647)">MaxValue</span>, <span title="Int(10)" class="int">10</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="(c: Char)Int" id="akka.http.server;PathMatchers.IntNumber.fromChar">fromChar</a><span class="delimiter">(</span><a title="Char" id="akka.http.server;PathMatchers.IntNumber.fromChar.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#akka.http.server;PathMatchers;NumberMatcher.fromDecimalChar" title="(c: Char)Int">fromDecimalChar</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers.IntNumber.fromChar.c" title="Char">c</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A PathMatcher that efficiently matches a number of digits and extracts their (non-negative) Long value.
   * The matcher will not match 0 digits or a sequence of digits that would represent an Long value larger
   * than Long.MaxValue.
   */</span>
  object <a title="PathMatchers.this.LongNumber.type" id="akka.http.server;PathMatchers.LongNumber">LongNumber</a> extends <a href="#akka.http.server;PathMatchers;NumberMatcher" title="PathMatchers.this.NumberMatcher[Long]">NumberMatcher</a><span class="delimiter">[</span>Long<span class="delimiter">]</span><span class="delimiter">(</span>Long.<span title="Long(9223372036854775807L)">MaxValue</span>, <span title="Long(10L)" class="int">10</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="(c: Char)Long" id="akka.http.server;PathMatchers.LongNumber.fromChar">fromChar</a><span class="delimiter">(</span><a title="Char" id="akka.http.server;PathMatchers.LongNumber.fromChar.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#akka.http.server;PathMatchers;NumberMatcher.fromDecimalChar" title="(c: Char)Long">fromDecimalChar</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers.LongNumber.fromChar.c" title="Char">c</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A PathMatcher that efficiently matches a number of hex-digits and extracts their (non-negative) Int value.
   * The matcher will not match 0 digits or a sequence of digits that would represent an Int value larger
   * than Int.MaxValue.
   */</span>
  object <a title="PathMatchers.this.HexIntNumber.type" id="akka.http.server;PathMatchers.HexIntNumber">HexIntNumber</a> extends <a href="#akka.http.server;PathMatchers;NumberMatcher" title="PathMatchers.this.NumberMatcher[Int]">NumberMatcher</a><span class="delimiter">[</span>Int<span class="delimiter">]</span><span class="delimiter">(</span>Int.<span title="Int(2147483647)">MaxValue</span>, <span title="Int(16)" class="int">16</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="(c: Char)Int" id="akka.http.server;PathMatchers.HexIntNumber.fromChar">fromChar</a><span class="delimiter">(</span><a title="Char" id="akka.http.server;PathMatchers.HexIntNumber.fromChar.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#akka.http.server;PathMatchers;NumberMatcher.fromHexChar" title="(c: Char)Int">fromHexChar</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers.HexIntNumber.fromChar.c" title="Char">c</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A PathMatcher that efficiently matches a number of hex-digits and extracts their (non-negative) Long value.
   * The matcher will not match 0 digits or a sequence of digits that would represent an Long value larger
   * than Long.MaxValue.
   */</span>
  object <a title="PathMatchers.this.HexLongNumber.type" id="akka.http.server;PathMatchers.HexLongNumber">HexLongNumber</a> extends <a href="#akka.http.server;PathMatchers;NumberMatcher" title="PathMatchers.this.NumberMatcher[Long]">NumberMatcher</a><span class="delimiter">[</span>Long<span class="delimiter">]</span><span class="delimiter">(</span>Long.<span title="Long(9223372036854775807L)">MaxValue</span>, <span title="Long(16L)" class="int">16</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    def <a title="(c: Char)Long" id="akka.http.server;PathMatchers.HexLongNumber.fromChar">fromChar</a><span class="delimiter">(</span><a title="Char" id="akka.http.server;PathMatchers.HexLongNumber.fromChar.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span> = <a href="#akka.http.server;PathMatchers;NumberMatcher.fromHexChar" title="(c: Char)Long">fromHexChar</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers.HexLongNumber.fromChar.c" title="Char">c</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">// common implementation of Number matchers</span>
  abstract class <a title="class NumberMatcher[T] extends akka.http.server.PathMatcher1[T]" id="akka.http.server;PathMatchers;NumberMatcher">NumberMatcher</a><span class="delimiter">[</span>@specialized<span class="delimiter">(</span>Int, Long<span class="delimiter">)</span> <a title="" id="akka.http.server;PathMatchers;NumberMatcher;T">T</a><span class="delimiter">]</span><a href="#akka.http.server;PathMatchers;NumberMatcher" title="PathMatchers.this.NumberMatcher[T]" class="delimiter">(</a><a title="T" id="akka.http.server;PathMatchers;NumberMatcher.max">max</a>: <a href="#akka.http.server;PathMatchers;NumberMatcher;T" title="T">T</a>, <a title="T" id="akka.http.server;PathMatchers;NumberMatcher.base">base</a>: <a href="#akka.http.server;PathMatchers;NumberMatcher;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="Integral[T]" id="akka.http.server;PathMatchers;NumberMatcher.x">x</a>: <span title="Integral[T]">Integral</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>
    extends <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher1[T]">PathMatcher1</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>

    import <a href="#akka.http.server;PathMatchers;NumberMatcher.x" title="Integral[T]">x</a>._ <span class="comment">// import implicit conversions for numeric operators</span>
    val minusOne = <a href="#akka.http.server;PathMatchers;NumberMatcher.x" title="Integral[T]">x</a>.<a href="#akka.http.server;PathMatchers;NumberMatcher.x" title="implicit scala.math.Integral.mkNumericOps : (lhs: T)NumberMatcher.this.x.IntegralOps">zero</a> <a title="T" id="akka.http.server;PathMatchers;NumberMatcher.minusOne">-</a> <a href="#akka.http.server;PathMatchers;NumberMatcher.x" title="Integral[T]">x</a>.<span title="=&gt; T">one</span>
    val maxDivBase = <a href="#akka.http.server;PathMatchers;NumberMatcher.x" title="implicit scala.math.Integral.mkNumericOps : (lhs: T)NumberMatcher.this.x.IntegralOps">max</a> <a title="T" id="akka.http.server;PathMatchers;NumberMatcher.maxDivBase">/</a> <a href="#akka.http.server;PathMatchers;NumberMatcher.base" title="T">base</a>

    def <a title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[(T,)]" id="akka.http.server;PathMatchers;NumberMatcher.apply">apply</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatchers;NumberMatcher.apply.path">path</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = <a href="#akka.http.server;PathMatchers;NumberMatcher.apply.path" title="akka.http.model.Uri.Path">path</a> match <span class="delimiter">{</span>
      case Path.Segment<span class="delimiter">(</span><a title="String" id="akka.http.server;PathMatchers;NumberMatcher.apply.segment">segment</a>, <a title="akka.http.model.Uri.Path.SlashOrEmpty" id="akka.http.server;PathMatchers;NumberMatcher.apply.tail">tail</a><span class="delimiter">)</span> ⇒
        @tailrec def <a title="(ix: Int, value: T)akka.http.server.PathMatcher.Matching[(T,)]" id="akka.http.server;PathMatchers;NumberMatcher.apply.digits">digits</a><span class="delimiter">(</span><a title="Int" id="akka.http.server;PathMatchers;NumberMatcher.apply.digits$default$1">ix</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>, <a title="T" id="akka.http.server;PathMatchers;NumberMatcher.apply.digits$default$2">value</a>: <a href="#akka.http.server;PathMatchers;NumberMatcher;T" title="T">T</a> = <a href="#akka.http.server;PathMatchers;NumberMatcher.minusOne" title="=&gt; T">minusOne</a><span class="delimiter">)</span>: <a href="#akka.http.server.PathMatcher;Matching" title="akka.http.server.PathMatcher.Matching[(T,)]">Matching</a><span class="delimiter">[</span>Tuple1<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
          val <a title="T" id="akka.http.server;PathMatchers;NumberMatcher.apply.digits.a">a</a> = if <span class="delimiter">(</span><a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits$default$1" title="Int">ix</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.apply.segment" title="String">segment</a>.<span title="()Int">length</span><span class="delimiter">)</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.fromChar" title="(c: Char)T">fromChar</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers;NumberMatcher.apply.segment" title="String">segment</a> <span title="(x$1: Int)Char">charAt</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits$default$1" title="Int">ix</a><span class="delimiter">)</span> else <a href="#akka.http.server;PathMatchers;NumberMatcher.minusOne" title="=&gt; T">minusOne</a>
          if <span class="delimiter">(</span><a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits.a" title="T">a</a> <span title="(x$1: Any)Boolean">==</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.minusOne" title="=&gt; T">minusOne</a><span class="delimiter">)</span> <span class="delimiter">{</span>
            if <span class="delimiter">(</span><a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits$default$2" title="T">value</a> <span title="(x$1: Any)Boolean">==</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.minusOne" title="=&gt; T">minusOne</a><span class="delimiter">)</span> <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>
            else <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: (T,))(implicit evidence$9: akka.http.server.util.Tuple[(T,)])akka.http.server.PathMatcher.Matched[(T,)]">Matched</a><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[(T,)]" class="delimiter">(</a>if <span class="delimiter">(</span><a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits$default$1" title="Int">ix</a> <span title="(x: Int)Boolean">&lt;</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.apply.segment" title="String">segment</a>.<span title="()Int">length</span><span class="delimiter">)</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.apply.segment" title="String">segment</a>.<span title="(x$1: Int)String">substring</span><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits$default$1" title="Int">ix</a><span class="delimiter">)</span> <a href="../model/Uri.scala.html#akka.http.model.Uri;Path.::(c8ba4e91e7)" title="(segment: String)akka.http.model.Uri.Path">::</a> <a href="#akka.http.server;PathMatchers;NumberMatcher.apply.tail" title="akka.http.model.Uri.Path.SlashOrEmpty">tail</a> else <a href="#akka.http.server;PathMatchers;NumberMatcher.apply.tail" title="akka.http.model.Uri.Path.SlashOrEmpty">tail</a>, <span title="(_1: T)(T,)">Tuple1</span><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits$default$2" title="T">value</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">}</span> else <span class="delimiter">{</span>
            if <span class="delimiter">(</span><a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits$default$2" title="T">value</a> <span title="(x$1: Any)Boolean">==</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.minusOne" title="=&gt; T">minusOne</a><span class="delimiter">)</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits" title="(ix: Int, value: T)akka.http.server.PathMatcher.Matching[(T,)]">digits</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits$default$1" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits.a" title="T">a</a><span class="delimiter">)</span>
            else if <span class="delimiter">(</span><a href="#akka.http.server;PathMatchers;NumberMatcher.x" title="implicit scala.math.Ordering.mkOrderingOps : (lhs: T)NumberMatcher.this.x.Ops">value</a> <span title="(rhs: T)Boolean">&lt;=</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.maxDivBase" title="=&gt; T">maxDivBase</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.x" title="implicit scala.math.Integral.mkNumericOps : (lhs: T)NumberMatcher.this.x.IntegralOps">value</a> <a href="#akka.http.server;PathMatchers;NumberMatcher.x" title="implicit scala.math.Ordering.mkOrderingOps : (lhs: T)NumberMatcher.this.x.Ops">*</a> <a href="#akka.http.server;PathMatchers;NumberMatcher.base" title="T">base</a> <span title="(rhs: T)Boolean">&lt;=</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.x" title="implicit scala.math.Integral.mkNumericOps : (lhs: T)NumberMatcher.this.x.IntegralOps">max</a> <span title="(rhs: T)T">-</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits.a" title="T">a</a><span class="delimiter">)</span> <span class="comment">// protect from overflow</span>
              <a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits" title="(ix: Int, value: T)akka.http.server.PathMatcher.Matching[(T,)]">digits</a><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits$default$1" title="Int">ix</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>, <a href="#akka.http.server;PathMatchers;NumberMatcher.x" title="implicit scala.math.Integral.mkNumericOps : (lhs: T)NumberMatcher.this.x.IntegralOps">value</a> <a href="#akka.http.server;PathMatchers;NumberMatcher.x" title="implicit scala.math.Integral.mkNumericOps : (lhs: T)NumberMatcher.this.x.IntegralOps">*</a> <a href="#akka.http.server;PathMatchers;NumberMatcher.base" title="T">base</a> <span title="(rhs: T)T">+</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits.a" title="T">a</a><span class="delimiter">)</span>
            else <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
        <a href="#akka.http.server;PathMatchers;NumberMatcher.apply.digits" title="(ix: Int, value: T)akka.http.server.PathMatcher.Matching[(T,)]">digits</a><span class="delimiter">(</span><span class="delimiter">)</span>

      case _ ⇒ <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>
    <span class="delimiter">}</span>

    def <a title="(c: Char)T" id="akka.http.server;PathMatchers;NumberMatcher.fromChar">fromChar</a><span class="delimiter">(</span><a title="Char" id="akka.http.server;PathMatchers;NumberMatcher.fromChar.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatchers;NumberMatcher;T" title="T">T</a>

    def <a title="(c: Char)T" id="akka.http.server;PathMatchers;NumberMatcher.fromDecimalChar">fromDecimalChar</a><span class="delimiter">(</span><a title="Char" id="akka.http.server;PathMatchers;NumberMatcher.fromDecimalChar.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatchers;NumberMatcher;T" title="T">T</a> = if <span class="delimiter">(</span><span title="Char('0')" class="char">'0'</span> <span title="(x: Char)Boolean">&lt;=</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.fromDecimalChar.c" title="Char">c</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.fromDecimalChar.c" title="Char">c</a> <span title="(x: Char)Boolean">&lt;=</span> <span title="Char('9')" class="char">'9'</span><span class="delimiter">)</span> <span class="delimiter">(</span><a href="#akka.http.server;PathMatchers;NumberMatcher.fromDecimalChar.c" title="Char">c</a> <span title="(x: Char)Int">-</span> <span title="Char('0')" class="char">'0'</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#akka.http.server;PathMatchers;NumberMatcher;T" title="T">T</a><span class="delimiter">]</span> else <a href="#akka.http.server;PathMatchers;NumberMatcher.minusOne" title="=&gt; T">minusOne</a>

    def <a title="(c: Char)T" id="akka.http.server;PathMatchers;NumberMatcher.fromHexChar">fromHexChar</a><span class="delimiter">(</span><a title="Char" id="akka.http.server;PathMatchers;NumberMatcher.fromHexChar.c">c</a>: <span title="Char">Char</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatchers;NumberMatcher;T" title="T">T</a> =
      if <span class="delimiter">(</span><span title="Char('0')" class="char">'0'</span> <span title="(x: Char)Boolean">&lt;=</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.fromHexChar.c" title="Char">c</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.fromHexChar.c" title="Char">c</a> <span title="(x: Char)Boolean">&lt;=</span> <span title="Char('9')" class="char">'9'</span><span class="delimiter">)</span> <span class="delimiter">(</span><a href="#akka.http.server;PathMatchers;NumberMatcher.fromHexChar.c" title="Char">c</a> <span title="(x: Char)Int">-</span> <span title="Char('0')" class="char">'0'</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#akka.http.server;PathMatchers;NumberMatcher;T" title="T">T</a><span class="delimiter">]</span> else <span class="delimiter">{</span>
        val cn = <a href="#akka.http.server;PathMatchers;NumberMatcher.fromHexChar.c" title="Char">c</a> <a title="Int" id="akka.http.server;PathMatchers;NumberMatcher.fromHexChar.cn">|</a> <span title="Int(32)" class="int">0x20</span> <span class="comment">// normalize to lowercase</span>
        if <span class="delimiter">(</span><span title="Char('a')" class="char">'a'</span> <span title="(x: Int)Boolean">&lt;=</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.fromHexChar.cn" title="Int">cn</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#akka.http.server;PathMatchers;NumberMatcher.fromHexChar.cn" title="Int">cn</a> <span title="(x: Char)Boolean">&lt;=</span> <span title="Char('f')" class="char">'f'</span><span class="delimiter">)</span> <span class="delimiter">(</span><a href="#akka.http.server;PathMatchers;NumberMatcher.fromHexChar.cn" title="Int">cn</a> <span title="(x: Char)Int">-</span> <span title="Char('a')" class="char">'a'</span> <span title="(x: Int)Int">+</span> <span title="Int(10)" class="int">10</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#akka.http.server;PathMatchers;NumberMatcher;T" title="T">T</a><span class="delimiter">]</span> else
          <a href="#akka.http.server;PathMatchers;NumberMatcher.minusOne" title="=&gt; T">minusOne</a>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A PathMatcher that matches and extracts a Double value. The matched string representation is the pure decimal,
   * optionally signed form of a double value, i.e. without exponent.
   */</span>
  val DoubleNumber: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher1[Double]">PathMatcher1</a><span class="delimiter">[</span>Double<span class="delimiter">]</span> =
    <a href="#akka.http.server.PathMatcher.apply(2bcbf921fb)" title="(magnet: akka.http.server.PathMatcher[(String,)])akka.http.server.PathMatcher[(String,)]">PathMatcher</a><a href="#akka.http.server.PathMatcher.PathMatcher1Ops" title="(matcher: akka.http.server.PathMatcher1[String])akka.http.server.PathMatcher.PathMatcher1Ops[String]" class="delimiter">(</a><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;&quot;&quot;[+-]?\d*\.?\d*&quot;&quot;&quot;</span>.<a href="#akka.http.server;ImplicitPathMatcherConstruction.regex2PathMatcher" title="implicit akka.http.server.ImplicitPathMatcherConstruction.regex2PathMatcher : (regex: scala.util.matching.Regex)akka.http.server.PathMatcher1[String]">r</a><span class="delimiter">)</span> <a href="#akka.http.server.PathMatcher;PathMatcher1Ops.flatMap" title="akka.http.server.PathMatcher1[Double]" id="akka.http.server;PathMatchers.DoubleNumber">flatMap</a> <span class="delimiter">{</span> <a title="String" id="akka.http.server;PathMatchers.DoubleNumber.$anonfun.string">string</a> ⇒
      try <span title="(x: Double)Some[Double]">Some</span><span class="delimiter">(</span>java.lang.<span title="Double.type">Double</span>.<span title="(x$1: String)Double">parseDouble</span><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers.DoubleNumber.$anonfun.string" title="String">string</a><span class="delimiter">)</span><span class="delimiter">)</span>
      catch <span class="delimiter">{</span> case _: <span title="NumberFormatException">NumberFormatException</span> ⇒ <span title="None.type">None</span> <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * A PathMatcher that matches and extracts a java.util.UUID instance.
   */</span>
  val JavaUUID: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher1[java.util.UUID]">PathMatcher1</a><span class="delimiter">[</span>UUID<span class="delimiter">]</span> =
    <a href="#akka.http.server.PathMatcher.apply(2bcbf921fb)" title="(magnet: akka.http.server.PathMatcher[(String,)])akka.http.server.PathMatcher[(String,)]">PathMatcher</a><a href="#akka.http.server.PathMatcher.PathMatcher1Ops" title="(matcher: akka.http.server.PathMatcher1[String])akka.http.server.PathMatcher.PathMatcher1Ops[String]" class="delimiter">(</a><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;&quot;&quot;[\da-fA-F]{8}-[\da-fA-F]{4}-[\da-fA-F]{4}-[\da-fA-F]{4}-[\da-fA-F]{12}&quot;&quot;&quot;</span>.<a href="#akka.http.server;ImplicitPathMatcherConstruction.regex2PathMatcher" title="implicit akka.http.server.ImplicitPathMatcherConstruction.regex2PathMatcher : (regex: scala.util.matching.Regex)akka.http.server.PathMatcher1[String]">r</a><span class="delimiter">)</span> <a href="#akka.http.server.PathMatcher;PathMatcher1Ops.flatMap" title="akka.http.server.PathMatcher1[java.util.UUID]" id="akka.http.server;PathMatchers.JavaUUID">flatMap</a> <span class="delimiter">{</span> <a title="String" id="akka.http.server;PathMatchers.JavaUUID.$anonfun.string">string</a> ⇒
      try <span title="(x: java.util.UUID)Some[java.util.UUID]">Some</span><span class="delimiter">(</span><span title="java.util.UUID.type">UUID</span>.<span title="(x$1: String)java.util.UUID">fromString</span><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers.JavaUUID.$anonfun.string" title="String">string</a><span class="delimiter">)</span><span class="delimiter">)</span>
      catch <span class="delimiter">{</span> case _: <span title="IllegalArgumentException">IllegalArgumentException</span> ⇒ <span title="None.type">None</span> <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * A PathMatcher that always matches, doesn't consume anything and extracts nothing.
   * Serves mainly as a neutral element in PathMatcher composition.
   */</span>
  val <a title="akka.http.server.PathMatcher0" id="akka.http.server;PathMatchers.Neutral">Neutral</a>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher0">PathMatcher0</a> = <a href="#akka.http.server.PathMatcher" title="akka.http.server.PathMatcher.type">PathMatcher</a>.<a href="#akka.http.server.PathMatcher.provide" title="(extractions: Unit)(implicit evidence$16: akka.http.server.util.Tuple[Unit])akka.http.server.PathMatcher[Unit]">provide</a><a href="util/Tuple.scala.html#akka.http.server.util.Tuple.forUnit" title="akka.http.server.util.Tuple[Unit]" class="delimiter">(</a><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * A PathMatcher that matches if the unmatched path starts with a path segment.
   * If so the path segment is extracted as a String.
   */</span>
  object <a title="PathMatchers.this.Segment.type" id="akka.http.server;PathMatchers.Segment">Segment</a> extends <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher1[String]">PathMatcher1</a><span class="delimiter">[</span>String<span class="delimiter">]</span> <span class="delimiter">{</span>
    def <a title="(path: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Matching[(String,)]" id="akka.http.server;PathMatchers.Segment.apply">apply</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatchers.Segment.apply.path">path</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = <a href="#akka.http.server;PathMatchers.Segment.apply.path" title="akka.http.model.Uri.Path">path</a> match <span class="delimiter">{</span>
      case Path.Segment<span class="delimiter">(</span><a title="String" id="akka.http.server;PathMatchers.Segment.apply.segment">segment</a>, <a title="akka.http.model.Uri.Path.SlashOrEmpty" id="akka.http.server;PathMatchers.Segment.apply.tail">tail</a><span class="delimiter">)</span> ⇒ <a href="#akka.http.server.PathMatcher;Matched" title="(pathRest: akka.http.model.Uri.Path, extractions: (String,))(implicit evidence$9: akka.http.server.util.Tuple[(String,)])akka.http.server.PathMatcher.Matched[(String,)]">Matched</a><a href="#akka.http.server;PathMatcher.ev" title="=&gt; akka.http.server.util.Tuple[(String,)]" class="delimiter">(</a><a href="#akka.http.server;PathMatchers.Segment.apply.tail" title="akka.http.model.Uri.Path.SlashOrEmpty">tail</a>, <span title="(_1: String)(String,)">Tuple1</span><span class="delimiter">(</span><a href="#akka.http.server;PathMatchers.Segment.apply.segment" title="String">segment</a><span class="delimiter">)</span><span class="delimiter">)</span>
      case _                           ⇒ <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A PathMatcher that matches up to 128 remaining segments as a List[String].
   * This can also be no segments resulting in the empty list.
   * If the path has a trailing slash this slash will *not* be matched.
   */</span>
  val <a title="akka.http.server.PathMatcher1[List[String]]" id="akka.http.server;PathMatchers.Segments(209a375110)">Segments</a>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher1[List[String]]">PathMatcher1</a><span class="delimiter">[</span>List<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#akka.http.server;PathMatchers.Segments(680827b3fa)" title="(maxSegments: Int)akka.http.server.PathMatcher1[List[String]]">Segments</a><span class="delimiter">(</span><span title="Int(128)" class="int">128</span><span class="delimiter">)</span>

  <span class="comment">/**
   * A PathMatcher that matches up to the configured number of remaining segments as a List[String].
   * This can also be no segments resulting in the empty list.
   * If the path has a trailing slash this slash will *not* be matched.
   */</span>
  def <a title="(maxSegments: Int)akka.http.server.PathMatcher1[List[String]]" id="akka.http.server;PathMatchers.Segments(680827b3fa)">Segments</a><span class="delimiter">(</span><a title="Int" id="akka.http.server;PathMatchers.Segments(680827b3fa).maxSegments">maxSegments</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher1[List[String]]">PathMatcher1</a><span class="delimiter">[</span>List<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#akka.http.server;PathMatchers.Segment" title="PathMatchers.this.Segment.type">Segment</a>.<a href="#akka.http.server;PathMatcher.repeat" title="(maxIterations: Int, separator: akka.http.server.PathMatcher0)(implicit lift: akka.http.server.PathMatcher.Lift[(String,),List])akka.http.server.PathMatcher[lift.Out]">repeat</a><a href="#akka.http.server.PathMatcher.Lift.liftSingleElement" title="(implicit mops: akka.http.server.PathMatcher.Lift.MOps[List])akka.http.server.PathMatcher.Lift[(String,),List]{type Out = (List[String],); def apply(): (List[Nothing],)}" class="delimiter">(</a>maxIterations = <a href="#akka.http.server;PathMatchers.Segments(680827b3fa).maxSegments" title="Int">maxSegments</a>, separator = <a href="#akka.http.server;PathMatchers.Slash" title="PathMatchers.this.Slash.type">Slash</a><span class="delimiter">)</span>

  <span class="comment">/**
   * A PathMatcher that never matches anything.
   */</span>
  def <a title="[L](implicit evidence$18: akka.http.server.util.Tuple[L])akka.http.server.PathMatcher[L]" id="akka.http.server;PathMatchers.nothingMatcher">nothingMatcher</a><span class="delimiter">[</span><a title="" id="akka.http.server;PathMatchers.nothingMatcher;L">L</a>: Tuple<span class="delimiter">]</span>: <a href="#akka.http.server;PathMatcher" title="akka.http.server.PathMatcher[L]">PathMatcher</a><span class="delimiter">[</span>L<span class="delimiter">]</span> =
    new <a title="&lt;$anon: akka.http.model.Uri.Path =&gt; akka.http.server.PathMatcher.Matching[L]&gt; extends akka.http.server.PathMatcher[L]" id="akka.http.server;PathMatchers.nothingMatcher;$anon">PathMatcher</a><span class="delimiter">[</span>L<span class="delimiter">]</span> <span class="delimiter">{</span>
      def <a title="(p: akka.http.model.Uri.Path)akka.http.server.PathMatcher.Unmatched.type" id="akka.http.server;PathMatchers.nothingMatcher;$anon.apply">apply</a><span class="delimiter">(</span><a title="akka.http.model.Uri.Path" id="akka.http.server;PathMatchers.nothingMatcher;$anon.apply.p">p</a>: <a href="../model/Uri.scala.html#akka.http.model.Uri;Path" title="akka.http.model.Uri.Path">Path</a><span class="delimiter">)</span> = <a href="#akka.http.server.PathMatcher.Unmatched.readResolve" title="akka.http.server.PathMatcher.Unmatched.type">Unmatched</a>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

object <a title="akka.http.server.PathMatchers.type" id="akka.http.server.PathMatchers">PathMatchers</a> extends <a href="#akka.http.server;PathMatchers" title="akka.http.server.PathMatchers">PathMatchers</a>

        </pre>
    </body>
</html>
