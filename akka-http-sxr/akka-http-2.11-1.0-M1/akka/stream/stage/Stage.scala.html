<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>akka/stream/stage/Stage.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Copyright (C) 2014 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
package akka.stream.stage

<span class="comment">/**
 * General interface for stream transformation.
 *
 * Custom `Stage` implementations are intended to be used with
 * [[akka.stream.scaladsl.FlowOps#transform]] or
 * [[akka.stream.javadsl.Flow#transform]] to extend the `Flow` API when there
 * is no specialized operator that performs the transformation.
 *
 * Custom implementations are subclasses of [[PushPullStage]] or
 * [[DetachedStage]]. Sometimes it is convenient to extend
 * [[StatefulStage]] for support of become like behavior.
 *
 * It is possible to keep state in the concrete `Stage` instance with
 * ordinary instance variables. The `Transformer` is executed by an actor and
 * therefore you don not have to add any additional thread safety or memory
 * visibility constructs to access the state from the callback methods.
 *
 * @see [[akka.stream.scaladsl.Flow#transform]]
 * @see [[akka.stream.javadsl.Flow#transform]]
 */</span>
sealed trait <a title="trait Stage[-In, Out] extends AnyRef" id="akka.stream.stage;Stage">Stage</a><span class="delimiter">[</span>-<a title="" id="akka.stream.stage;Stage;In">In</a>, <a title="" id="akka.stream.stage;Stage;Out">Out</a><span class="delimiter">]</span>

private<span class="delimiter">[</span>stream<span class="delimiter">]</span> abstract class <a title="class AbstractStage[-In, Out, PushD &lt;: akka.stream.stage.Directive, PullD &lt;: akka.stream.stage.Directive, Ctx &lt;: akka.stream.stage.Context[Out]] extends AnyRef with akka.stream.stage.Stage[In,Out]" id="akka.stream.stage;AbstractStage">AbstractStage</a><span class="delimiter">[</span>-<a title="" id="akka.stream.stage;AbstractStage;In">In</a>, <a title="" id="akka.stream.stage;AbstractStage;Out">Out</a>, <a title=" &lt;: akka.stream.stage.Directive" id="akka.stream.stage;AbstractStage;PushD">PushD</a> &lt;: Directive, <a title=" &lt;: akka.stream.stage.Directive" id="akka.stream.stage;AbstractStage;PullD">PullD</a> &lt;: Directive, <a title=" &lt;: akka.stream.stage.Context[Out]" id="akka.stream.stage;AbstractStage;Ctx">Ctx</a> &lt;: Context<span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">]</span> extends <a href="#akka.stream.stage;Stage" title="akka.stream.stage.Stage[In,Out]">Stage</a><span class="delimiter">[</span>In, Out<span class="delimiter">]</span> <span class="delimiter">{</span>
  private<span class="delimiter">[</span>stream<span class="delimiter">]</span> var <a title="Boolean" id="akka.stream.stage;AbstractStage.holding_=">holding</a> = false
  private<span class="delimiter">[</span>stream<span class="delimiter">]</span> var <a title="Boolean" id="akka.stream.stage;AbstractStage.allowedToPush_=">allowedToPush</a> = false
  private<span class="delimiter">[</span>stream<span class="delimiter">]</span> var <a title="Boolean" id="akka.stream.stage;AbstractStage.terminationPending_=">terminationPending</a> = false

  <span class="comment">/**
   * `onPush` is called when an element from upstream is available and there is demand from downstream, i.e.
   * in `onPush` you are allowed to call [[akka.stream.stage.Context#push]] to emit one element downstreams,
   * or you can absorb the element by calling [[akka.stream.stage.Context#pull]]. Note that you can only
   * emit zero or one element downstream from `onPull`.
   *
   * To emit more than one element you have to push the remaining elements from [[#onPull]], one-by-one.
   * `onPush` is not called again until `onPull` has requested more elements with
   * [[akka.stream.stage.Context#pull]].
   */</span>
  def <a title="(elem: In, ctx: Ctx)PushD" id="akka.stream.stage;AbstractStage.onPush">onPush</a><span class="delimiter">(</span><a title="In" id="akka.stream.stage;AbstractStage.onPush.elem">elem</a>: <a href="#akka.stream.stage;AbstractStage;In" title="In">In</a>, <a title="Ctx" id="akka.stream.stage;AbstractStage.onPush.ctx">ctx</a>: <a href="#akka.stream.stage;AbstractStage;Ctx" title="Ctx">Ctx</a><span class="delimiter">)</span>: <a href="#akka.stream.stage;AbstractStage;PushD" title="PushD">PushD</a>

  <span class="comment">/**
   * `onPull` is called when there is demand from downstream, i.e. you are allowed to push one element
   * downstreams with [[akka.stream.stage.Context#push]], or request elements from upstreams with
   * [[akka.stream.stage.Context#pull]]
   */</span>
  def <a title="(ctx: Ctx)PullD" id="akka.stream.stage;AbstractStage.onPull">onPull</a><span class="delimiter">(</span><a title="Ctx" id="akka.stream.stage;AbstractStage.onPull.ctx">ctx</a>: <a href="#akka.stream.stage;AbstractStage;Ctx" title="Ctx">Ctx</a><span class="delimiter">)</span>: <a href="#akka.stream.stage;AbstractStage;PullD" title="PullD">PullD</a>

  <span class="comment">/**
   * `onUpstreamFinish` is called when upstream has signaled that the stream is
   * successfully completed. Here you cannot call [[akka.stream.stage.Context#push]],
   * because there might not be any demand from downstream. To emit additional elements before
   * terminating you can use [[akka.stream.stage.Context#absorbTermination]] and push final elements
   * from [[#onPull]]. The stage will then be in finishing state, which can be checked
   * with [[akka.stream.stage.Context#isFinishing]].
   *
   * By default the finish signal is immediately propagated with [[akka.stream.stage.Context#finish]].
   */</span>
  def <a title="(ctx: Ctx)akka.stream.stage.TerminationDirective" id="akka.stream.stage;AbstractStage.onUpstreamFinish">onUpstreamFinish</a><span class="delimiter">(</span><a title="Ctx" id="akka.stream.stage;AbstractStage.onUpstreamFinish.ctx">ctx</a>: <a href="#akka.stream.stage;AbstractStage;Ctx" title="Ctx">Ctx</a><span class="delimiter">)</span>: <a href="#akka.stream.stage;TerminationDirective" title="akka.stream.stage.TerminationDirective">TerminationDirective</a> = <a href="#akka.stream.stage;AbstractStage.onUpstreamFinish.ctx" title="Ctx">ctx</a>.<a href="#akka.stream.stage;Context.finish" title="()akka.stream.stage.FreeDirective">finish</a><span class="delimiter">(</span><span class="delimiter">)</span>

  <span class="comment">/**
   * `onDownstreamFinish` is called when downstream has cancelled.
   *
   * By default the cancel signal is immediately propagated with [[akka.stream.stage.Context#finish]].
   */</span>
  def <a title="(ctx: Ctx)akka.stream.stage.TerminationDirective" id="akka.stream.stage;AbstractStage.onDownstreamFinish">onDownstreamFinish</a><span class="delimiter">(</span><a title="Ctx" id="akka.stream.stage;AbstractStage.onDownstreamFinish.ctx">ctx</a>: <a href="#akka.stream.stage;AbstractStage;Ctx" title="Ctx">Ctx</a><span class="delimiter">)</span>: <a href="#akka.stream.stage;TerminationDirective" title="akka.stream.stage.TerminationDirective">TerminationDirective</a> = <a href="#akka.stream.stage;AbstractStage.onDownstreamFinish.ctx" title="Ctx">ctx</a>.<a href="#akka.stream.stage;Context.finish" title="()akka.stream.stage.FreeDirective">finish</a><span class="delimiter">(</span><span class="delimiter">)</span>

  <span class="comment">/**
   * `onUpstreamFailure` is called when upstream has signaled that the stream is completed
   * with error. It is not called if [[#onPull]] or [[#onPush]] of the stage itself
   * throws an exception.
   *
   * Note that elements that were emitted by upstream before the error happened might
   * not have been received by this stage when `onUpstreamFailure` is called, i.e.
   * errors are not backpressured and might be propagated as soon as possible.
   *
   * Here you cannot call [[akka.stream.stage.Context#push]], because there might not
   * be any demand from  downstream. To emit additional elements before terminating you
   * can use [[akka.stream.stage.Context#absorbTermination]] and push final elements
   * from [[#onPull]]. The stage will then be in finishing state, which can be checked
   * with [[akka.stream.stage.Context#isFinishing]].
   */</span>
  def <a title="(cause: Throwable, ctx: Ctx)akka.stream.stage.TerminationDirective" id="akka.stream.stage;AbstractStage.onUpstreamFailure">onUpstreamFailure</a><span class="delimiter">(</span><a title="Throwable" id="akka.stream.stage;AbstractStage.onUpstreamFailure.cause">cause</a>: <span title="Throwable">Throwable</span>, <a title="Ctx" id="akka.stream.stage;AbstractStage.onUpstreamFailure.ctx">ctx</a>: <a href="#akka.stream.stage;AbstractStage;Ctx" title="Ctx">Ctx</a><span class="delimiter">)</span>: <a href="#akka.stream.stage;TerminationDirective" title="akka.stream.stage.TerminationDirective">TerminationDirective</a> = <a href="#akka.stream.stage;AbstractStage.onUpstreamFailure.ctx" title="Ctx">ctx</a>.<a href="#akka.stream.stage;Context.fail" title="(cause: Throwable)akka.stream.stage.FreeDirective">fail</a><span class="delimiter">(</span><a href="#akka.stream.stage;AbstractStage.onUpstreamFailure.cause" title="Throwable">cause</a><span class="delimiter">)</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * `PushPullStage` implementations participate in 1-bounded regions. For every external non-completion signal these
 * stages produce *exactly one* push or pull signal.
 *
 * [[#onPush]] is called when an element from upstream is available and there is demand from downstream, i.e.
 * in `onPush` you are allowed to call [[Context#push]] to emit one element downstreams, or you can absorb the
 * element by calling [[Context#pull]]. Note that you can only emit zero or one element downstream from `onPull`.
 * To emit more than one element you have to push the remaining elements from [[#onPull]], one-by-one.
 * `onPush` is not called again until `onPull` has requested more elements with [[Context#pull]].
 *
 * [[StatefulStage]] has support for making it easy to emit more than one element from `onPush`.
 *
 * [[#onPull]] is called when there is demand from downstream, i.e. you are allowed to push one element
 * downstreams with [[Context#push]], or request elements from upstreams with [[Context#pull]]. If you
 * always perform transitive pull by calling `ctx.pull` from `onPull` you can use [[PushStage]] instead of
 * `PushPullStage`.
 *
 * Stages are allowed to do early completion of downstream and cancel of upstream. This is done with [[Context#finish]],
 * which is a combination of cancel/complete.
 *
 * Since onComplete is not a backpressured signal it is sometimes preferable to push a final element and then
 * immediately finish. This combination is exposed as [[Context#pushAndFinish]] which enables stages to
 * propagate completion events without waiting for an extra round of pull.
 *
 * Another peculiarity is how to convert termination events (complete/failure) into elements. The problem
 * here is that the termination events are not backpressured while elements are. This means that simply calling
 * [[Context#push]] as a response to [[#onUpstreamFinish]] or [[#onUpstreamFailure]] will very likely break boundedness
 * and result in a buffer overflow somewhere. Therefore the only allowed command in this case is
 * [[Context#absorbTermination]] which stops the propagation of the termination signal, and puts the stage in a
 * [[akka.stream.stage.Context#isFinishing]] state. Depending on whether the stage has a pending pull signal it
 * has not yet &quot;consumed&quot; by a push its [[#onPull]] handler might be called immediately or later. From
 * [[#onPull]] final elements can be pushed before completing downstream with [[Context#finish]] or
 * [[Context#pushAndFinish]].
 *
 * [[StatefulStage]] has support for making it easy to emit final elements.
 *
 * All these rules are enforced by types and runtime checks where needed. Always return the `Directive`
 * from the call to the [[Context]] method, and do only call [[Context]] commands once per callback.
 *
 * @see [[DetachedStage]]
 * @see [[StatefulStage]]
 * @see [[PushStage]]
 */</span>
abstract class <a title="class PushPullStage[In, Out] extends akka.stream.stage.AbstractStage[In,Out,akka.stream.stage.Directive,akka.stream.stage.Directive,akka.stream.stage.Context[Out]]" id="akka.stream.stage;PushPullStage">PushPullStage</a><span class="delimiter">[</span><a title="" id="akka.stream.stage;PushPullStage;In">In</a>, <a title="" id="akka.stream.stage;PushPullStage;Out">Out</a><span class="delimiter">]</span> extends <a href="#akka.stream.stage;AbstractStage" title="akka.stream.stage.AbstractStage[In,Out,akka.stream.stage.Directive,akka.stream.stage.Directive,akka.stream.stage.Context[Out]]">AbstractStage</a><span class="delimiter">[</span>In, Out, Directive, Directive, Context<span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">]</span>

<span class="comment">/**
 * `PushStage` is a [[PushPullStage]] that always perform transitive pull by calling `ctx.pull` from `onPull`.
 */</span>
abstract class <a title="class PushStage[In, Out] extends akka.stream.stage.PushPullStage[In,Out]" id="akka.stream.stage;PushStage">PushStage</a><span class="delimiter">[</span><a title="" id="akka.stream.stage;PushStage;In">In</a>, <a title="" id="akka.stream.stage;PushStage;Out">Out</a><span class="delimiter">]</span> extends <a href="#akka.stream.stage;PushPullStage" title="akka.stream.stage.PushPullStage[In,Out]">PushPullStage</a><span class="delimiter">[</span>In, Out<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="comment">/**
   * Always pulls from upstream.
   */</span>
  final override def <a title="(ctx: akka.stream.stage.Context[Out])akka.stream.stage.Directive" id="akka.stream.stage;PushStage.onPull">onPull</a><span class="delimiter">(</span><a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;PushStage.onPull.ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a> = <a href="#akka.stream.stage;PushStage.onPull.ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.pull" title="()akka.stream.stage.UpstreamDirective">pull</a><span class="delimiter">(</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * `DetachedStage` can be used to implement operations similar to [[akka.stream.scaladsl.FlowOps#buffer buffer]],
 * [[akka.stream.scaladsl.FlowOps#expand expand]] and [[akka.stream.scaladsl.FlowOps#conflate conflate]].
 *
 * `DetachedStage` implementations are boundaries between 1-bounded regions. This means that they need to enforce the
 * &quot;exactly one&quot; property both on their upstream and downstream regions. As a consequence a `DetachedStage` can never
 * answer an [[#onPull]] with a [[Context#pull]] or answer an [[#onPush]] with a [[Context#push]] since such an action
 * would &quot;steal&quot; the event from one region (resulting in zero signals) and would inject it to the other region
 * (resulting in two signals).
 *
 * However, DetachedStages have the ability to call [[akka.stream.stage.DetachedContext#hold]] as a response to
 * [[#onPush]] and [[akka.stream.stage.DetachedContext##onPull]] which temporarily takes the signal off and
 * stops execution, at the same time putting the stage in an [[akka.stream.stage.DetachedContext#isHolding]] state.
 * If the stage is in a holding state it contains one absorbed signal, therefore in this state the only possible
 * command to call is [[akka.stream.stage.DetachedContext#pushAndPull]] which results in two events making the
 * balance right again: 1 hold + 1 external event = 2 external event
 *
 * This mechanism allows synchronization between the upstream and downstream regions which otherwise can progress
 * independently.
 *
 * @see [[PushPullStage]]
 */</span>
abstract class <a title="class DetachedStage[In, Out] extends akka.stream.stage.AbstractStage[In,Out,akka.stream.stage.UpstreamDirective,akka.stream.stage.DownstreamDirective,akka.stream.stage.DetachedContext[Out]]" id="akka.stream.stage;DetachedStage">DetachedStage</a><span class="delimiter">[</span><a title="" id="akka.stream.stage;DetachedStage;In">In</a>, <a title="" id="akka.stream.stage;DetachedStage;Out">Out</a><span class="delimiter">]</span> extends <a href="#akka.stream.stage;AbstractStage" title="akka.stream.stage.AbstractStage[In,Out,akka.stream.stage.UpstreamDirective,akka.stream.stage.DownstreamDirective,akka.stream.stage.DetachedContext[Out]]">AbstractStage</a><span class="delimiter">[</span>In, Out, UpstreamDirective, DownstreamDirective, DetachedContext<span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">]</span>

<span class="comment">/**
 * The behavior of [[StatefulStage]] is defined by these two methods, which
 * has the same sematics as corresponding methods in [[PushPullStage]].
 */</span>
abstract class <a title="class StageState[In, Out] extends AnyRef" id="akka.stream.stage;StageState">StageState</a><span class="delimiter">[</span><a title="" id="akka.stream.stage;StageState;In">In</a>, <a title="" id="akka.stream.stage;StageState;Out">Out</a><span class="delimiter">]</span> <a href="#akka.stream.stage;StageState" title="akka.stream.stage.StageState[In,Out]" class="delimiter">{</a>
  def <a title="(elem: In, ctx: akka.stream.stage.Context[Out])akka.stream.stage.Directive" id="akka.stream.stage;StageState.onPush">onPush</a><span class="delimiter">(</span><a title="In" id="akka.stream.stage;StageState.onPush.elem">elem</a>: <a href="#akka.stream.stage;StageState;In" title="In">In</a>, <a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StageState.onPush.ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a>
  def <a title="(ctx: akka.stream.stage.Context[Out])akka.stream.stage.Directive" id="akka.stream.stage;StageState.onPull">onPull</a><span class="delimiter">(</span><a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StageState.onPull.ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a> = <a href="#akka.stream.stage;StageState.onPull.ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.pull" title="()akka.stream.stage.UpstreamDirective">pull</a><span class="delimiter">(</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * INTERNAL API
 */</span>
private<span class="delimiter">[</span>akka<span class="delimiter">]</span> object <a title="akka.stream.stage.StatefulStage.type" id="akka.stream.stage.StatefulStage">StatefulStage</a> <a href="#akka.stream.stage.StatefulStage" title="akka.stream.stage.StatefulStage.type" class="delimiter">{</a>
  sealed trait <a title="trait AndThen extends AnyRef" id="akka.stream.stage.StatefulStage;AndThen">AndThen</a>
  case object <a href="#akka.stream.stage.StatefulStage.Finish.productElement.x$1" title="akka.stream.stage.StatefulStage.Finish.type" id="akka.stream.stage.StatefulStage.Finish.readResolve">Finish</a> extends <a href="#akka.stream.stage.StatefulStage;AndThen" title="akka.stream.stage.StatefulStage.AndThen">AndThen</a>
  final case class <a title="class Become extends AnyRef with akka.stream.stage.StatefulStage.AndThen with Product with Serializable" id="akka.stream.stage.StatefulStage.Become.readResolve">Become</a><span title="Product" class="delimiter">(</span><a title="akka.stream.stage.StageState[Any,Any]" id="akka.stream.stage.StatefulStage;Become.state">state</a>: <a href="#akka.stream.stage;StageState" title="akka.stream.stage.StageState[Any,Any]">StageState</a><span class="delimiter">[</span>Any, Any<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#akka.stream.stage.StatefulStage;AndThen" title="akka.stream.stage.StatefulStage.AndThen">AndThen</a>
  case object <a href="#akka.stream.stage.StatefulStage.Stay.productElement.x$1" title="akka.stream.stage.StatefulStage.Stay.type" id="akka.stream.stage.StatefulStage.Stay.readResolve">Stay</a> extends <a href="#akka.stream.stage.StatefulStage;AndThen" title="akka.stream.stage.StatefulStage.AndThen">AndThen</a>
<span class="delimiter">}</span>

<span class="comment">/**
 * `StatefulStage` is a [[PushPullStage]] that provides convenience to make some things easier.
 *
 * The behavior is defined in [[StageState]] instances. The initial behavior is specified
 * by subclass implementing the [[#initial]] method. The behavior can be changed by using [[#become]].
 *
 * Use [[#emit]] or [[#emitAndFinish]] to push more than one element from [[StageState#onPush]] or
 * [[StageState#onPull]].
 *
 * Use [[#terminationEmit]] to push final elements from [[#onUpstreamFinish]] or [[#onUpstreamFailure]].
 */</span>
abstract class <a title="class StatefulStage[In, Out] extends akka.stream.stage.PushPullStage[In,Out]" id="akka.stream.stage;StatefulStage">StatefulStage</a><span class="delimiter">[</span><a title="" id="akka.stream.stage;StatefulStage;In">In</a>, <a title="" id="akka.stream.stage;StatefulStage;Out">Out</a><span class="delimiter">]</span> extends <a href="#akka.stream.stage;PushPullStage" title="akka.stream.stage.PushPullStage[In,Out]">PushPullStage</a><span class="delimiter">[</span>In, Out<span class="delimiter">]</span> <span class="delimiter">{</span>
  import <a href="#akka.stream.stage.StatefulStage" title="akka.stream.stage.StatefulStage.type">StatefulStage</a>._

  <span class="comment">/**
   * Scala API
   */</span>
  abstract class <a title="class State extends akka.stream.stage.StageState[In,Out]" id="akka.stream.stage;StatefulStage;State">State</a> extends <a href="#akka.stream.stage;StageState" title="akka.stream.stage.StageState[In,Out]">StageState</a><span class="delimiter">[</span>In, Out<span class="delimiter">]</span>

  private var <a title="Boolean" id="akka.stream.stage;StatefulStage.emitting_=">emitting</a> = false
  private var <a title="akka.stream.stage.StageState[In,Out]" id="akka.stream.stage;StatefulStage._current_=">_current</a>: <a href="#akka.stream.stage;StageState" title="akka.stream.stage.StageState[In,Out]">StageState</a><span class="delimiter">[</span>In, Out<span class="delimiter">]</span> = _
  <a href="#akka.stream.stage;StatefulStage.become" title="(state: akka.stream.stage.StageState[In,Out])Unit">become</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.initial" title="=&gt; akka.stream.stage.StageState[In,Out]">initial</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Concrete subclass must return the initial behavior from this method.
   */</span>
  def <a title="=&gt; akka.stream.stage.StageState[In,Out]" id="akka.stream.stage;StatefulStage.initial">initial</a>: <a href="#akka.stream.stage;StageState" title="akka.stream.stage.StageState[In,Out]">StageState</a><span class="delimiter">[</span>In, Out<span class="delimiter">]</span>

  <span class="comment">/**
   * Current state.
   */</span>
  final def <a title="=&gt; akka.stream.stage.StageState[In,Out]" id="akka.stream.stage;StatefulStage.current">current</a>: <a href="#akka.stream.stage;StageState" title="akka.stream.stage.StageState[In,Out]">StageState</a><span class="delimiter">[</span>In, Out<span class="delimiter">]</span> = <a href="#akka.stream.stage;StatefulStage._current_=" title="=&gt; akka.stream.stage.StageState[In,Out]">_current</a>

  <span class="comment">/**
   * Change the behavior to another [[StageState]].
   */</span>
  final def <a title="(state: akka.stream.stage.StageState[In,Out])Unit" id="akka.stream.stage;StatefulStage.become">become</a><span class="delimiter">(</span><a title="akka.stream.stage.StageState[In,Out]" id="akka.stream.stage;StatefulStage.become.state">state</a>: <a href="#akka.stream.stage;StageState" title="akka.stream.stage.StageState[In,Out]">StageState</a><span class="delimiter">[</span>In, Out<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.become.state" title="akka.stream.stage.StageState[In,Out]">state</a> <span title="(x$1: AnyRef)Boolean">ne</span> null, <span title="String(&quot;New state must not be null&quot;)" class="string">&quot;New state must not be null&quot;</span><span class="delimiter">)</span>
    <a href="#akka.stream.stage;StatefulStage._current_=" title="(x$1: akka.stream.stage.StageState[In,Out])Unit">_current</a> = <a href="#akka.stream.stage;StatefulStage.become.state" title="akka.stream.stage.StageState[In,Out]">state</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Invokes current state.
   */</span>
  final override def <a title="(elem: In, ctx: akka.stream.stage.Context[Out])akka.stream.stage.Directive" id="akka.stream.stage;StatefulStage.onPush">onPush</a><span class="delimiter">(</span><a title="In" id="akka.stream.stage;StatefulStage.onPush.elem">elem</a>: <a href="#akka.stream.stage;StatefulStage;In" title="In">In</a>, <a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StatefulStage.onPush.ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a> = <a href="#akka.stream.stage;StatefulStage._current_=" title="=&gt; akka.stream.stage.StageState[In,Out]">_current</a>.<a href="#akka.stream.stage;StageState.onPush" title="(elem: In, ctx: akka.stream.stage.Context[Out])akka.stream.stage.Directive">onPush</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.onPush.elem" title="In">elem</a>, <a href="#akka.stream.stage;StatefulStage.onPush.ctx" title="akka.stream.stage.Context[Out]">ctx</a><span class="delimiter">)</span>
  <span class="comment">/**
   * Invokes current state.
   */</span>
  final override def <a title="(ctx: akka.stream.stage.Context[Out])akka.stream.stage.Directive" id="akka.stream.stage;StatefulStage.onPull">onPull</a><span class="delimiter">(</span><a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StatefulStage.onPull.ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a> = <a href="#akka.stream.stage;StatefulStage._current_=" title="=&gt; akka.stream.stage.StageState[In,Out]">_current</a>.<a href="#akka.stream.stage;StageState.onPull" title="(ctx: akka.stream.stage.Context[Out])akka.stream.stage.Directive">onPull</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.onPull.ctx" title="akka.stream.stage.Context[Out]">ctx</a><span class="delimiter">)</span>

  override def <a title="(ctx: akka.stream.stage.Context[Out])akka.stream.stage.TerminationDirective" id="akka.stream.stage;StatefulStage.onUpstreamFinish">onUpstreamFinish</a><span class="delimiter">(</span><a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StatefulStage.onUpstreamFinish.ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;TerminationDirective" title="akka.stream.stage.TerminationDirective">TerminationDirective</a> =
    if <span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emitting_=" title="=&gt; Boolean">emitting</a><span class="delimiter">)</span> <a href="#akka.stream.stage;StatefulStage.onUpstreamFinish.ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.absorbTermination" title="()akka.stream.stage.TerminationDirective">absorbTermination</a><span class="delimiter">(</span><span class="delimiter">)</span>
    else <a href="#akka.stream.stage;StatefulStage.onUpstreamFinish.ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.finish" title="()akka.stream.stage.FreeDirective">finish</a><span class="delimiter">(</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Scala API: Can be used from [[StageState#onPush]] or [[StageState#onPull]] to push more than one
   * element downstreams.
   */</span>
  final def <a title="(iter: Iterator[Out], ctx: akka.stream.stage.Context[Out])akka.stream.stage.Directive" id="akka.stream.stage;StatefulStage.emit(d580ccb06c)">emit</a><span class="delimiter">(</span><a title="Iterator[Out]" id="akka.stream.stage;StatefulStage.emit(d580ccb06c).iter">iter</a>: <span title="Iterator[Out]">Iterator</span><span class="delimiter">[</span>Out<span class="delimiter">]</span>, <a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StatefulStage.emit(d580ccb06c).ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a> = <a href="#akka.stream.stage;StatefulStage.emit(381ff48dc6)" title="(iter: Iterator[Out], ctx: akka.stream.stage.Context[Out], nextState: akka.stream.stage.StageState[In,Out])akka.stream.stage.Directive">emit</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emit(d580ccb06c).iter" title="Iterator[Out]">iter</a>, <a href="#akka.stream.stage;StatefulStage.emit(d580ccb06c).ctx" title="akka.stream.stage.Context[Out]">ctx</a>, <a href="#akka.stream.stage;StatefulStage._current_=" title="=&gt; akka.stream.stage.StageState[In,Out]">_current</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Java API: Can be used from [[StageState#onPush]] or [[StageState#onPull]] to push more than one
   * element downstreams.
   */</span>
  final def <a title="(iter: java.util.Iterator[Out], ctx: akka.stream.stage.Context[Out])akka.stream.stage.Directive" id="akka.stream.stage;StatefulStage.emit(519f678ceb)">emit</a><span class="delimiter">(</span><a title="java.util.Iterator[Out]" id="akka.stream.stage;StatefulStage.emit(519f678ceb).iter">iter</a>: java.util.<span title="java.util.Iterator[Out]">Iterator</span><span class="delimiter">[</span>Out<span class="delimiter">]</span>, <a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StatefulStage.emit(519f678ceb).ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a> = <span class="delimiter">{</span>
    import scala.collection.<span title="scala.collection.JavaConverters.type">JavaConverters</span>._
    <a href="#akka.stream.stage;StatefulStage.emit(d580ccb06c)" title="(iter: Iterator[Out], ctx: akka.stream.stage.Context[Out])akka.stream.stage.Directive">emit</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emit(519f678ceb).iter" title="(i: java.util.Iterator[Out])scala.collection.convert.Decorators.AsScala[Iterator[Out]]">iter</a>.<span title="=&gt; Iterator[Out]">asScala</span>, <a href="#akka.stream.stage;StatefulStage.emit(519f678ceb).ctx" title="akka.stream.stage.Context[Out]">ctx</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Scala API: Can be used from [[StageState#onPush]] or [[StageState#onPull]] to push more than one
   * element downstreams and after that change behavior.
   */</span>
  final def <a title="(iter: Iterator[Out], ctx: akka.stream.stage.Context[Out], nextState: akka.stream.stage.StageState[In,Out])akka.stream.stage.Directive" id="akka.stream.stage;StatefulStage.emit(381ff48dc6)">emit</a><span class="delimiter">(</span><a title="Iterator[Out]" id="akka.stream.stage;StatefulStage.emit(381ff48dc6).iter">iter</a>: <span title="Iterator[Out]">Iterator</span><span class="delimiter">[</span>Out<span class="delimiter">]</span>, <a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StatefulStage.emit(381ff48dc6).ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span>, <a title="akka.stream.stage.StageState[In,Out]" id="akka.stream.stage;StatefulStage.emit(381ff48dc6).nextState">nextState</a>: <a href="#akka.stream.stage;StageState" title="akka.stream.stage.StageState[In,Out]">StageState</a><span class="delimiter">[</span>In, Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emitting_=" title="=&gt; Boolean">emitting</a><span class="delimiter">)</span> throw new <span title="IllegalStateException">IllegalStateException</span><span class="delimiter">(</span><span title="String(&quot;already in emitting state&quot;)" class="string">&quot;already in emitting state&quot;</span><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emit(381ff48dc6).iter" title="Iterator[Out]">iter</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#akka.stream.stage;StatefulStage.become" title="(state: akka.stream.stage.StageState[In,Out])Unit">become</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emit(381ff48dc6).nextState" title="akka.stream.stage.StageState[In,Out]">nextState</a><span class="delimiter">)</span>
      <a href="#akka.stream.stage;StatefulStage.emit(381ff48dc6).ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.pull" title="()akka.stream.stage.UpstreamDirective">pull</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <span class="delimiter">{</span>
      val <a title="Out" id="akka.stream.stage;StatefulStage.emit(381ff48dc6).elem">elem</a> = <a href="#akka.stream.stage;StatefulStage.emit(381ff48dc6).iter" title="Iterator[Out]">iter</a>.<span title="()Out">next</span><span class="delimiter">(</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emit(381ff48dc6).iter" title="Iterator[Out]">iter</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#akka.stream.stage;StatefulStage.emitting_=" title="(x$1: Boolean)Unit">emitting</a> = true
        <a href="#akka.stream.stage;StatefulStage.become" title="(state: akka.stream.stage.StageState[In,Out])Unit">become</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emittingState" title="(iter: Iterator[Out], andThen: akka.stream.stage.StatefulStage.AndThen)StatefulStage.this.State{def onPush(elem: In,ctx: akka.stream.stage.Context[Out]): Nothing}">emittingState</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emit(381ff48dc6).iter" title="Iterator[Out]">iter</a>, andThen = <a href="#akka.stream.stage.StatefulStage.Become.readResolve" title="(state: akka.stream.stage.StageState[Any,Any])akka.stream.stage.StatefulStage.Become">Become</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emit(381ff48dc6).nextState" title="akka.stream.stage.StageState[In,Out]">nextState</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="akka.stream.stage.StageState[Any,Any]" class="delimiter">[</span><a href="#akka.stream.stage;StageState" title="akka.stream.stage.StageState[Any,Any]">StageState</a><span class="delimiter">[</span>Any, Any<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#akka.stream.stage;StatefulStage.emit(381ff48dc6).ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.push" title="(elem: Out)akka.stream.stage.DownstreamDirective">push</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emit(381ff48dc6).elem" title="Out">elem</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Java API: Can be used from [[StageState#onPush]] or [[StageState#onPull]] to push more than one
   * element downstreams and after that change behavior.
   */</span>
  final def <a title="(iter: java.util.Iterator[Out], ctx: akka.stream.stage.Context[Out], nextState: akka.stream.stage.StageState[In,Out])akka.stream.stage.Directive" id="akka.stream.stage;StatefulStage.emit(4af09c3607)">emit</a><span class="delimiter">(</span><a title="java.util.Iterator[Out]" id="akka.stream.stage;StatefulStage.emit(4af09c3607).iter">iter</a>: java.util.<span title="java.util.Iterator[Out]">Iterator</span><span class="delimiter">[</span>Out<span class="delimiter">]</span>, <a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StatefulStage.emit(4af09c3607).ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span>, <a title="akka.stream.stage.StageState[In,Out]" id="akka.stream.stage;StatefulStage.emit(4af09c3607).nextState">nextState</a>: <a href="#akka.stream.stage;StageState" title="akka.stream.stage.StageState[In,Out]">StageState</a><span class="delimiter">[</span>In, Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a> = <span class="delimiter">{</span>
    import scala.collection.<span title="scala.collection.JavaConverters.type">JavaConverters</span>._
    <a href="#akka.stream.stage;StatefulStage.emit(381ff48dc6)" title="(iter: Iterator[Out], ctx: akka.stream.stage.Context[Out], nextState: akka.stream.stage.StageState[In,Out])akka.stream.stage.Directive">emit</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emit(4af09c3607).iter" title="(i: java.util.Iterator[Out])scala.collection.convert.Decorators.AsScala[Iterator[Out]]">iter</a>.<span title="=&gt; Iterator[Out]">asScala</span>, <a href="#akka.stream.stage;StatefulStage.emit(4af09c3607).ctx" title="akka.stream.stage.Context[Out]">ctx</a>, <a href="#akka.stream.stage;StatefulStage.emit(4af09c3607).nextState" title="akka.stream.stage.StageState[In,Out]">nextState</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Scala API: Can be used from [[StageState#onPush]] or [[StageState#onPull]] to push more than one
   * element downstreams and after that finish (complete downstreams, cancel upstreams).
   */</span>
  final def <a title="(iter: Iterator[Out], ctx: akka.stream.stage.Context[Out])akka.stream.stage.Directive" id="akka.stream.stage;StatefulStage.emitAndFinish(d580ccb06c)">emitAndFinish</a><span class="delimiter">(</span><a title="Iterator[Out]" id="akka.stream.stage;StatefulStage.emitAndFinish(d580ccb06c).iter">iter</a>: <span title="Iterator[Out]">Iterator</span><span class="delimiter">[</span>Out<span class="delimiter">]</span>, <a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StatefulStage.emitAndFinish(d580ccb06c).ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emitting_=" title="=&gt; Boolean">emitting</a><span class="delimiter">)</span> throw new <span title="IllegalStateException">IllegalStateException</span><span class="delimiter">(</span><span title="String(&quot;already in emitting state&quot;)" class="string">&quot;already in emitting state&quot;</span><span class="delimiter">)</span>
    if <span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emitAndFinish(d580ccb06c).iter" title="Iterator[Out]">iter</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
      <a href="#akka.stream.stage;StatefulStage.emitAndFinish(d580ccb06c).ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.finish" title="()akka.stream.stage.FreeDirective">finish</a><span class="delimiter">(</span><span class="delimiter">)</span>
    else <span class="delimiter">{</span>
      val <a title="Out" id="akka.stream.stage;StatefulStage.emitAndFinish(d580ccb06c).elem">elem</a> = <a href="#akka.stream.stage;StatefulStage.emitAndFinish(d580ccb06c).iter" title="Iterator[Out]">iter</a>.<span title="()Out">next</span><span class="delimiter">(</span><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emitAndFinish(d580ccb06c).iter" title="Iterator[Out]">iter</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#akka.stream.stage;StatefulStage.emitting_=" title="(x$1: Boolean)Unit">emitting</a> = true
        <a href="#akka.stream.stage;StatefulStage.become" title="(state: akka.stream.stage.StageState[In,Out])Unit">become</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emittingState" title="(iter: Iterator[Out], andThen: akka.stream.stage.StatefulStage.AndThen)StatefulStage.this.State{def onPush(elem: In,ctx: akka.stream.stage.Context[Out]): Nothing}">emittingState</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emitAndFinish(d580ccb06c).iter" title="Iterator[Out]">iter</a>, andThen = <a href="#akka.stream.stage.StatefulStage.Finish.readResolve" title="akka.stream.stage.StatefulStage.Finish.type">Finish</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#akka.stream.stage;StatefulStage.emitAndFinish(d580ccb06c).ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.push" title="(elem: Out)akka.stream.stage.DownstreamDirective">push</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emitAndFinish(d580ccb06c).elem" title="Out">elem</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else
        <a href="#akka.stream.stage;StatefulStage.emitAndFinish(d580ccb06c).ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.pushAndFinish" title="(elem: Out)akka.stream.stage.DownstreamDirective">pushAndFinish</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emitAndFinish(d580ccb06c).elem" title="Out">elem</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Java API: Can be used from [[StageState#onPush]] or [[StageState#onPull]] to push more than one
   * element downstreams and after that finish (complete downstreams, cancel upstreams).
   */</span>
  final def <a title="(iter: java.util.Iterator[Out], ctx: akka.stream.stage.Context[Out])akka.stream.stage.Directive" id="akka.stream.stage;StatefulStage.emitAndFinish(519f678ceb)">emitAndFinish</a><span class="delimiter">(</span><a title="java.util.Iterator[Out]" id="akka.stream.stage;StatefulStage.emitAndFinish(519f678ceb).iter">iter</a>: java.util.<span title="java.util.Iterator[Out]">Iterator</span><span class="delimiter">[</span>Out<span class="delimiter">]</span>, <a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StatefulStage.emitAndFinish(519f678ceb).ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a> = <span class="delimiter">{</span>
    import scala.collection.<span title="scala.collection.JavaConverters.type">JavaConverters</span>._
    <a href="#akka.stream.stage;StatefulStage.emitAndFinish(d580ccb06c)" title="(iter: Iterator[Out], ctx: akka.stream.stage.Context[Out])akka.stream.stage.Directive">emitAndFinish</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emitAndFinish(519f678ceb).iter" title="(i: java.util.Iterator[Out])scala.collection.convert.Decorators.AsScala[Iterator[Out]]">iter</a>.<span title="=&gt; Iterator[Out]">asScala</span>, <a href="#akka.stream.stage;StatefulStage.emitAndFinish(519f678ceb).ctx" title="akka.stream.stage.Context[Out]">ctx</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Scala API: Can be used from [[#onUpstreamFinish]] to push final elements downstreams
   * before completing the stream successfully. Note that if this is used from
   * [[#onUpstreamFailure]] the error will be absorbed and the stream will be completed
   * successfully.
   */</span>
  final def <a title="(iter: Iterator[Out], ctx: akka.stream.stage.Context[Out])akka.stream.stage.TerminationDirective" id="akka.stream.stage;StatefulStage.terminationEmit(6a279f2ca5)">terminationEmit</a><span class="delimiter">(</span><a title="Iterator[Out]" id="akka.stream.stage;StatefulStage.terminationEmit(6a279f2ca5).iter">iter</a>: <span title="Iterator[Out]">Iterator</span><span class="delimiter">[</span>Out<span class="delimiter">]</span>, <a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StatefulStage.terminationEmit(6a279f2ca5).ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;TerminationDirective" title="akka.stream.stage.TerminationDirective">TerminationDirective</a> = <span class="delimiter">{</span>
    val <a title="Boolean" id="akka.stream.stage;StatefulStage.terminationEmit(6a279f2ca5).empty">empty</a> = <a href="#akka.stream.stage;StatefulStage.terminationEmit(6a279f2ca5).iter" title="Iterator[Out]">iter</a>.<span title="=&gt; Boolean">isEmpty</span>
    if <span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.terminationEmit(6a279f2ca5).empty" title="Boolean">empty</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#akka.stream.stage;StatefulStage.emitting_=" title="=&gt; Boolean">emitting</a><span class="delimiter">)</span> <a href="#akka.stream.stage;StatefulStage.terminationEmit(6a279f2ca5).ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.absorbTermination" title="()akka.stream.stage.TerminationDirective">absorbTermination</a><span class="delimiter">(</span><span class="delimiter">)</span>
    else if <span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.terminationEmit(6a279f2ca5).empty" title="Boolean">empty</a><span class="delimiter">)</span> <a href="#akka.stream.stage;StatefulStage.terminationEmit(6a279f2ca5).ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.finish" title="()akka.stream.stage.FreeDirective">finish</a><span class="delimiter">(</span><span class="delimiter">)</span>
    else <span class="delimiter">{</span>
      <a href="#akka.stream.stage;StatefulStage.become" title="(state: akka.stream.stage.StageState[In,Out])Unit">become</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emittingState" title="(iter: Iterator[Out], andThen: akka.stream.stage.StatefulStage.AndThen)StatefulStage.this.State{def onPush(elem: In,ctx: akka.stream.stage.Context[Out]): Nothing}">emittingState</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.terminationEmit(6a279f2ca5).iter" title="Iterator[Out]">iter</a>, andThen = <a href="#akka.stream.stage.StatefulStage.Finish.readResolve" title="akka.stream.stage.StatefulStage.Finish.type">Finish</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#akka.stream.stage;StatefulStage.terminationEmit(6a279f2ca5).ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.absorbTermination" title="()akka.stream.stage.TerminationDirective">absorbTermination</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Java API: Can be used from [[#onUpstreamFinish]] or [[#onUpstreamFailure]] to push final
   * elements downstreams.
   */</span>
  final def <a title="(iter: java.util.Iterator[Out], ctx: akka.stream.stage.Context[Out])akka.stream.stage.TerminationDirective" id="akka.stream.stage;StatefulStage.terminationEmit(0129718452)">terminationEmit</a><span class="delimiter">(</span><a title="java.util.Iterator[Out]" id="akka.stream.stage;StatefulStage.terminationEmit(0129718452).iter">iter</a>: java.util.<span title="java.util.Iterator[Out]">Iterator</span><span class="delimiter">[</span>Out<span class="delimiter">]</span>, <a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StatefulStage.terminationEmit(0129718452).ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;TerminationDirective" title="akka.stream.stage.TerminationDirective">TerminationDirective</a> = <span class="delimiter">{</span>
    import scala.collection.<span title="scala.collection.JavaConverters.type">JavaConverters</span>._
    <a href="#akka.stream.stage;StatefulStage.terminationEmit(6a279f2ca5)" title="(iter: Iterator[Out], ctx: akka.stream.stage.Context[Out])akka.stream.stage.TerminationDirective">terminationEmit</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.terminationEmit(0129718452).iter" title="(i: java.util.Iterator[Out])scala.collection.convert.Decorators.AsScala[Iterator[Out]]">iter</a>.<span title="=&gt; Iterator[Out]">asScala</span>, <a href="#akka.stream.stage;StatefulStage.terminationEmit(0129718452).ctx" title="akka.stream.stage.Context[Out]">ctx</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private def <a title="(iter: Iterator[Out], andThen: akka.stream.stage.StatefulStage.AndThen)StatefulStage.this.State{def onPush(elem: In,ctx: akka.stream.stage.Context[Out]): Nothing}" id="akka.stream.stage;StatefulStage.emittingState">emittingState</a><span class="delimiter">(</span><a title="Iterator[Out]" id="akka.stream.stage;StatefulStage.emittingState.iter">iter</a>: <span title="Iterator[Out]">Iterator</span><span class="delimiter">[</span>Out<span class="delimiter">]</span>, <a title="akka.stream.stage.StatefulStage.AndThen" id="akka.stream.stage;StatefulStage.emittingState.andThen">andThen</a>: <a href="#akka.stream.stage.StatefulStage;AndThen" title="akka.stream.stage.StatefulStage.AndThen">AndThen</a><span class="delimiter">)</span> = new <a href="#akka.stream.stage;StatefulStage;State" title="&lt;$anon: StatefulStage.this.State&gt; extends StatefulStage.this.State" id="akka.stream.stage;StatefulStage.emittingState;$anon">State</a> <span class="delimiter">{</span>
    override def <a title="(elem: In, ctx: akka.stream.stage.Context[Out])Nothing" id="akka.stream.stage;StatefulStage.emittingState;$anon.onPush">onPush</a><span class="delimiter">(</span><a title="In" id="akka.stream.stage;StatefulStage.emittingState;$anon.onPush.elem">elem</a>: <a href="#akka.stream.stage;StatefulStage;In" title="In">In</a>, <a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StatefulStage.emittingState;$anon.onPush.ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span> = throw new <span title="IllegalStateException">IllegalStateException</span><span class="delimiter">(</span><span title="String(&quot;onPush not allowed in emittingState&quot;)" class="string">&quot;onPush not allowed in emittingState&quot;</span><span class="delimiter">)</span>
    override def <a title="(ctx: akka.stream.stage.Context[Out])akka.stream.stage.Directive" id="akka.stream.stage;StatefulStage.emittingState;$anon.onPull">onPull</a><span class="delimiter">(</span><a title="akka.stream.stage.Context[Out]" id="akka.stream.stage;StatefulStage.emittingState;$anon.onPull.ctx">ctx</a>: <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emittingState.iter" title="Iterator[Out]">iter</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="Out" id="akka.stream.stage;StatefulStage.emittingState;$anon.onPull.elem">elem</a> = <a href="#akka.stream.stage;StatefulStage.emittingState.iter" title="Iterator[Out]">iter</a>.<span title="()Out">next</span><span class="delimiter">(</span><span class="delimiter">)</span>
        if <span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emittingState.iter" title="Iterator[Out]">iter</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span>
          <a href="#akka.stream.stage;StatefulStage.emittingState;$anon.onPull.ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.push" title="(elem: Out)akka.stream.stage.DownstreamDirective">push</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emittingState;$anon.onPull.elem" title="Out">elem</a><span class="delimiter">)</span>
        else if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#akka.stream.stage;StatefulStage.emittingState;$anon.onPull.ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.isFinishing" title="=&gt; Boolean">isFinishing</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#akka.stream.stage;StatefulStage.emitting_=" title="(x$1: Boolean)Unit">emitting</a> = false
          <a href="#akka.stream.stage;StatefulStage.emittingState.andThen" title="akka.stream.stage.StatefulStage.AndThen">andThen</a> match <span class="delimiter">{</span>
            case <a href="#akka.stream.stage.StatefulStage.Stay.readResolve" title="akka.stream.stage.StatefulStage.Stay.type">Stay</a>             ⇒ <span class="comment">// ok</span>
            case Become<span class="delimiter">(</span><a title="akka.stream.stage.StageState[Any,Any]" id="akka.stream.stage;StatefulStage.emittingState;$anon.onPull.newState">newState</a><span class="delimiter">)</span> ⇒ <a href="#akka.stream.stage;StatefulStage.become" title="(state: akka.stream.stage.StageState[In,Out])Unit">become</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emittingState;$anon.onPull.newState" title="akka.stream.stage.StageState[Any,Any]">newState</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="akka.stream.stage.StageState[In,Out]" class="delimiter">[</span><a href="#akka.stream.stage;StageState" title="akka.stream.stage.StageState[In,Out]">StageState</a><span class="delimiter">[</span>In, Out<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
            case <a href="#akka.stream.stage.StatefulStage.Finish.readResolve" title="akka.stream.stage.StatefulStage.Finish.type">Finish</a>           ⇒ <a href="#akka.stream.stage;StatefulStage.emittingState;$anon.onPull.ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.pushAndFinish" title="(elem: Out)akka.stream.stage.DownstreamDirective">pushAndFinish</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emittingState;$anon.onPull.elem" title="Out">elem</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
          <a href="#akka.stream.stage;StatefulStage.emittingState;$anon.onPull.ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.push" title="(elem: Out)akka.stream.stage.DownstreamDirective">push</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emittingState;$anon.onPull.elem" title="Out">elem</a><span class="delimiter">)</span>
        <span class="delimiter">}</span> else
          <a href="#akka.stream.stage;StatefulStage.emittingState;$anon.onPull.ctx" title="akka.stream.stage.Context[Out]">ctx</a>.<a href="#akka.stream.stage;Context.pushAndFinish" title="(elem: Out)akka.stream.stage.DownstreamDirective">pushAndFinish</a><span class="delimiter">(</span><a href="#akka.stream.stage;StatefulStage.emittingState;$anon.onPull.elem" title="Out">elem</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else
        throw new <span title="IllegalStateException">IllegalStateException</span><span class="delimiter">(</span><span title="String(&quot;onPull with empty iterator is not expected in emittingState&quot;)" class="string">&quot;onPull with empty iterator is not expected in emittingState&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * Return type from [[Context]] methods.
 */</span>
sealed trait <a title="trait Directive extends AnyRef" id="akka.stream.stage;Directive">Directive</a>
sealed trait <a title="trait UpstreamDirective extends AnyRef with akka.stream.stage.Directive" id="akka.stream.stage;UpstreamDirective">UpstreamDirective</a> extends <a href="#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a>
sealed trait <a title="trait DownstreamDirective extends AnyRef with akka.stream.stage.Directive" id="akka.stream.stage;DownstreamDirective">DownstreamDirective</a> extends <a href="#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a>
sealed trait <a title="trait TerminationDirective extends AnyRef with akka.stream.stage.Directive" id="akka.stream.stage;TerminationDirective">TerminationDirective</a> extends <a href="#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a>
final class <a title="class FreeDirective extends AnyRef with akka.stream.stage.UpstreamDirective with akka.stream.stage.DownstreamDirective with akka.stream.stage.TerminationDirective" id="akka.stream.stage;FreeDirective">FreeDirective</a> extends <a href="#akka.stream.stage;UpstreamDirective" title="akka.stream.stage.UpstreamDirective">UpstreamDirective</a> with <a href="#akka.stream.stage;DownstreamDirective" title="akka.stream.stage.DownstreamDirective">DownstreamDirective</a> with <a href="#akka.stream.stage;TerminationDirective" title="akka.stream.stage.TerminationDirective">TerminationDirective</a>

<span class="comment">/**
 * Passed to the callback methods of [[PushPullStage]] and [[StatefulStage]].
 */</span>
sealed trait <a title="trait Context[Out] extends AnyRef" id="akka.stream.stage;Context">Context</a><span class="delimiter">[</span><a title="" id="akka.stream.stage;Context;Out">Out</a><span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="comment">/**
   * Push one element to downstreams.
   */</span>
  def <a title="(elem: Out)akka.stream.stage.DownstreamDirective" id="akka.stream.stage;Context.push">push</a><span class="delimiter">(</span><a title="Out" id="akka.stream.stage;Context.push.elem">elem</a>: <a href="#akka.stream.stage;Context;Out" title="Out">Out</a><span class="delimiter">)</span>: <a href="#akka.stream.stage;DownstreamDirective" title="akka.stream.stage.DownstreamDirective">DownstreamDirective</a>
  <span class="comment">/**
   * Request for more elements from upstreams.
   */</span>
  def <a title="()akka.stream.stage.UpstreamDirective" id="akka.stream.stage;Context.pull">pull</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;UpstreamDirective" title="akka.stream.stage.UpstreamDirective">UpstreamDirective</a>
  <span class="comment">/**
   * Cancel upstreams and complete downstreams successfully.
   */</span>
  def <a title="()akka.stream.stage.FreeDirective" id="akka.stream.stage;Context.finish">finish</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;FreeDirective" title="akka.stream.stage.FreeDirective">FreeDirective</a>
  <span class="comment">/**
   * Push one element to downstream immediately followed by
   * cancel of upstreams and complete of downstreams.
   */</span>
  def <a title="(elem: Out)akka.stream.stage.DownstreamDirective" id="akka.stream.stage;Context.pushAndFinish">pushAndFinish</a><span class="delimiter">(</span><a title="Out" id="akka.stream.stage;Context.pushAndFinish.elem">elem</a>: <a href="#akka.stream.stage;Context;Out" title="Out">Out</a><span class="delimiter">)</span>: <a href="#akka.stream.stage;DownstreamDirective" title="akka.stream.stage.DownstreamDirective">DownstreamDirective</a>
  <span class="comment">/**
   * Cancel upstreams and complete downstreams with failure.
   */</span>
  def <a title="(cause: Throwable)akka.stream.stage.FreeDirective" id="akka.stream.stage;Context.fail">fail</a><span class="delimiter">(</span><a title="Throwable" id="akka.stream.stage;Context.fail.cause">cause</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;FreeDirective" title="akka.stream.stage.FreeDirective">FreeDirective</a>
  <span class="comment">/**
   * Puts the stage in a finishing state so that
   * final elements can be pushed from `onPull`.
   */</span>
  def <a title="()akka.stream.stage.TerminationDirective" id="akka.stream.stage;Context.absorbTermination">absorbTermination</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;TerminationDirective" title="akka.stream.stage.TerminationDirective">TerminationDirective</a>

  <span class="comment">/**
   * This returns `true` after [[#absorbTermination]] has been used.
   */</span>
  def <a title="=&gt; Boolean" id="akka.stream.stage;Context.isFinishing">isFinishing</a>: <span title="Boolean">Boolean</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Passed to the callback methods of [[DetachedStage]].
 *
 * [[#hold]] stops execution and at the same time putting the stage in a holding state.
 * If the stage is in a holding state it contains one absorbed signal, therefore in
 * this state the only possible command to call is [[#pushAndPull]] which results in two
 * events making the balance right again: 1 hold + 1 external event = 2 external event
 */</span>
trait <a title="trait DetachedContext[Out] extends AnyRef with akka.stream.stage.Context[Out]" id="akka.stream.stage;DetachedContext">DetachedContext</a><span class="delimiter">[</span><a title="" id="akka.stream.stage;DetachedContext;Out">Out</a><span class="delimiter">]</span> extends <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Out]">Context</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> <span class="delimiter">{</span>
  def <a title="()akka.stream.stage.FreeDirective" id="akka.stream.stage;DetachedContext.hold">hold</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;FreeDirective" title="akka.stream.stage.FreeDirective">FreeDirective</a>

  <span class="comment">/**
   * This returns `true` when [[#hold]] has been used
   * and it is reset to `false` after [[#pushAndPull]].
   */</span>
  def <a title="=&gt; Boolean" id="akka.stream.stage;DetachedContext.isHolding">isHolding</a>: <span title="Boolean">Boolean</span>

  def <a title="(elem: Out)akka.stream.stage.FreeDirective" id="akka.stream.stage;DetachedContext.pushAndPull">pushAndPull</a><span class="delimiter">(</span><a title="Out" id="akka.stream.stage;DetachedContext.pushAndPull.elem">elem</a>: <a href="#akka.stream.stage;DetachedContext;Out" title="Out">Out</a><span class="delimiter">)</span>: <a href="#akka.stream.stage;FreeDirective" title="akka.stream.stage.FreeDirective">FreeDirective</a>

<span class="delimiter">}</span>

<span class="comment">/**
 * INTERNAL API
 */</span>
private<span class="delimiter">[</span>akka<span class="delimiter">]</span> trait <a title="trait BoundaryContext extends AnyRef with akka.stream.stage.Context[Any]" id="akka.stream.stage;BoundaryContext">BoundaryContext</a> extends <a href="#akka.stream.stage;Context" title="akka.stream.stage.Context[Any]">Context</a><span class="delimiter">[</span>Any<span class="delimiter">]</span> <span class="delimiter">{</span>
  def <a title="()akka.stream.stage.FreeDirective" id="akka.stream.stage;BoundaryContext.exit">exit</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.stream.stage;FreeDirective" title="akka.stream.stage.FreeDirective">FreeDirective</a>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
