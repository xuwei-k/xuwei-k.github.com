<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>akka/stream/impl/DirectedGraphBuilder.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Copyright (C) 2014 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
package akka.stream.impl

import scala.annotation.tailrec
import scala.collection.immutable

<span class="comment">/**
 * INTERNAL API
 */</span>
private<span class="delimiter">[</span>akka<span class="delimiter">]</span> final case class <a href="#akka.stream.impl;Vertex.productElement.x$1" title="class Vertex[E, V] extends AnyRef with Product with Serializable" id="akka.stream.impl.Vertex.readResolve">Vertex</a><span class="delimiter">[</span><a title="" id="akka.stream.impl;Vertex;E">E</a>, <a title="" id="akka.stream.impl;Vertex;V">V</a><span class="delimiter">]</span><a href="#akka.stream.impl.Vertex.readResolve" title="Product" class="delimiter">(</a><a title="V" id="akka.stream.impl;Vertex.label">label</a>: <a href="#akka.stream.impl;Vertex;V" title="V">V</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  private var <a title="scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]" id="akka.stream.impl;Vertex.inEdgeSet_=">inEdgeSet</a> = <span title="=&gt; scala.collection.immutable.Set.type">Set</span>.<span title="[A]=&gt; scala.collection.immutable.Set[A]">empty</span><span title="scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]" class="delimiter">[</span><a href="#akka.stream.impl.Edge.readResolve" title="akka.stream.impl.Edge[E,V]">Edge</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span>
  private var <a title="scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]" id="akka.stream.impl;Vertex.outEdgeSet_=">outEdgeSet</a> = <span title="=&gt; scala.collection.immutable.Set.type">Set</span>.<span title="[A]=&gt; scala.collection.immutable.Set[A]">empty</span><span title="scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]" class="delimiter">[</span><a href="#akka.stream.impl.Edge.readResolve" title="akka.stream.impl.Edge[E,V]">Edge</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span>

  def <a title="(e: akka.stream.impl.Edge[E,V])Unit" id="akka.stream.impl;Vertex.addOutEdge">addOutEdge</a><span class="delimiter">(</span><a title="akka.stream.impl.Edge[E,V]" id="akka.stream.impl;Vertex.addOutEdge.e">e</a>: <a href="#akka.stream.impl.Edge.readResolve" title="akka.stream.impl.Edge[E,V]">Edge</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.stream.impl;Vertex.outEdgeSet_=" title="(x$1: scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]])Unit">outEdgeSet</a> <span title="(elem: akka.stream.impl.Edge[E,V])scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">+=</span> <a href="#akka.stream.impl;Vertex.addOutEdge.e" title="akka.stream.impl.Edge[E,V]">e</a>
  def <a title="(e: akka.stream.impl.Edge[E,V])Unit" id="akka.stream.impl;Vertex.addInEdge">addInEdge</a><span class="delimiter">(</span><a title="akka.stream.impl.Edge[E,V]" id="akka.stream.impl;Vertex.addInEdge.e">e</a>: <a href="#akka.stream.impl.Edge.readResolve" title="akka.stream.impl.Edge[E,V]">Edge</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.stream.impl;Vertex.inEdgeSet_=" title="(x$1: scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]])Unit">inEdgeSet</a> <span title="(elem: akka.stream.impl.Edge[E,V])scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">+=</span> <a href="#akka.stream.impl;Vertex.addInEdge.e" title="akka.stream.impl.Edge[E,V]">e</a>

  def <a title="(e: akka.stream.impl.Edge[E,V])Unit" id="akka.stream.impl;Vertex.removeOutEdge">removeOutEdge</a><span class="delimiter">(</span><a title="akka.stream.impl.Edge[E,V]" id="akka.stream.impl;Vertex.removeOutEdge.e">e</a>: <a href="#akka.stream.impl.Edge.readResolve" title="akka.stream.impl.Edge[E,V]">Edge</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.stream.impl;Vertex.outEdgeSet_=" title="(x$1: scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]])Unit">outEdgeSet</a> <span title="(elem: akka.stream.impl.Edge[E,V])scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">-=</span> <a href="#akka.stream.impl;Vertex.removeOutEdge.e" title="akka.stream.impl.Edge[E,V]">e</a>
  def <a title="(e: akka.stream.impl.Edge[E,V])Unit" id="akka.stream.impl;Vertex.removeInEdge">removeInEdge</a><span class="delimiter">(</span><a title="akka.stream.impl.Edge[E,V]" id="akka.stream.impl;Vertex.removeInEdge.e">e</a>: <a href="#akka.stream.impl.Edge.readResolve" title="akka.stream.impl.Edge[E,V]">Edge</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.stream.impl;Vertex.inEdgeSet_=" title="(x$1: scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]])Unit">inEdgeSet</a> <span title="(elem: akka.stream.impl.Edge[E,V])scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">-=</span> <a href="#akka.stream.impl;Vertex.removeInEdge.e" title="akka.stream.impl.Edge[E,V]">e</a>

  def <a title="=&gt; Int" id="akka.stream.impl;Vertex.inDegree">inDegree</a>: <span title="Int">Int</span> = <a href="#akka.stream.impl;Vertex.inEdgeSet_=" title="=&gt; scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">inEdgeSet</a>.<span title="=&gt; Int">size</span>
  def <a title="=&gt; Int" id="akka.stream.impl;Vertex.outDegree">outDegree</a>: <span title="Int">Int</span> = <a href="#akka.stream.impl;Vertex.outEdgeSet_=" title="=&gt; scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">outEdgeSet</a>.<span title="=&gt; Int">size</span>

  def <a title="=&gt; Boolean" id="akka.stream.impl;Vertex.isolated">isolated</a>: <span title="Boolean">Boolean</span> = <a href="#akka.stream.impl;Vertex.inDegree" title="=&gt; Int">inDegree</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#akka.stream.impl;Vertex.outDegree" title="=&gt; Int">outDegree</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span>

  <span class="comment">// FIXME #16381 this is at the wrong level</span>
  def <a title="=&gt; Boolean" id="akka.stream.impl;Vertex.isSink">isSink</a>: <span title="Boolean">Boolean</span> = <a href="#akka.stream.impl;Vertex.outEdgeSet_=" title="=&gt; scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">outEdgeSet</a>.<span title="=&gt; Boolean">isEmpty</span>

  def <a title="=&gt; Set[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;Vertex.successors">successors</a>: <span title="Set[akka.stream.impl.Vertex[E,V]]">Set</span><span class="delimiter">[</span>Vertex<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#akka.stream.impl;Vertex.outEdgeSet_=" title="=&gt; scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">outEdgeSet</a>.<span title="(f: akka.stream.impl.Edge[E,V] =&gt; akka.stream.impl.Vertex[E,V])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]],akka.stream.impl.Vertex[E,V],Set[akka.stream.impl.Vertex[E,V]]])Set[akka.stream.impl.Vertex[E,V]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,akka.stream.impl.Vertex[E,V],scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]]" class="delimiter">(</span><a href="#akka.stream.impl;Vertex.successors.$anonfun.x$1" title="akka.stream.impl.Edge[E,V]">_</a>.<a href="#akka.stream.impl;Edge.to" title="=&gt; akka.stream.impl.Vertex[E,V]">to</a><span class="delimiter">)</span>
  def <a title="=&gt; Set[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;Vertex.predecessors">predecessors</a>: <span title="Set[akka.stream.impl.Vertex[E,V]]">Set</span><span class="delimiter">[</span>Vertex<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#akka.stream.impl;Vertex.inEdgeSet_=" title="=&gt; scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">inEdgeSet</a>.<span title="(f: akka.stream.impl.Edge[E,V] =&gt; akka.stream.impl.Vertex[E,V])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]],akka.stream.impl.Vertex[E,V],Set[akka.stream.impl.Vertex[E,V]]])Set[akka.stream.impl.Vertex[E,V]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,akka.stream.impl.Vertex[E,V],scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]]" class="delimiter">(</span><a href="#akka.stream.impl;Vertex.predecessors.$anonfun.x$2" title="akka.stream.impl.Edge[E,V]">_</a>.<a href="#akka.stream.impl;Edge.from" title="=&gt; akka.stream.impl.Vertex[E,V]">from</a><span class="delimiter">)</span>

  def <a title="=&gt; Set[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;Vertex.neighbors">neighbors</a>: <span title="Set[akka.stream.impl.Vertex[E,V]]">Set</span><span class="delimiter">[</span>Vertex<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#akka.stream.impl;Vertex.successors" title="=&gt; Set[akka.stream.impl.Vertex[E,V]]">successors</a> <span title="(elems: scala.collection.GenTraversableOnce[akka.stream.impl.Vertex[E,V]])scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">++</span> <a href="#akka.stream.impl;Vertex.predecessors" title="=&gt; Set[akka.stream.impl.Vertex[E,V]]">predecessors</a>

  def <a title="=&gt; Set[akka.stream.impl.Edge[E,V]]" id="akka.stream.impl;Vertex.incoming">incoming</a>: <span title="Set[akka.stream.impl.Edge[E,V]]">Set</span><span class="delimiter">[</span>Edge<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#akka.stream.impl;Vertex.inEdgeSet_=" title="=&gt; scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">inEdgeSet</a>
  def <a title="=&gt; Set[akka.stream.impl.Edge[E,V]]" id="akka.stream.impl;Vertex.outgoing">outgoing</a>: <span title="Set[akka.stream.impl.Edge[E,V]]">Set</span><span class="delimiter">[</span>Edge<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#akka.stream.impl;Vertex.outEdgeSet_=" title="=&gt; scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">outEdgeSet</a>

  override def <a title="(obj: Any)Boolean" id="akka.stream.impl;Vertex.equals">equals</a><span class="delimiter">(</span><a title="Any" id="akka.stream.impl;Vertex.equals.obj">obj</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#akka.stream.impl;Vertex.equals.obj" title="Any">obj</a> match <span class="delimiter">{</span>
    case <a title="akka.stream.impl.Vertex[_,_]" id="akka.stream.impl;Vertex.equals.v">v</a>: <a href="#akka.stream.impl.Vertex.readResolve" title="akka.stream.impl.Vertex[_,_]">Vertex</a><span class="delimiter">[</span>_, _<span class="delimiter">]</span> ⇒ <a href="#akka.stream.impl;Vertex.label" title="=&gt; V">label</a>.<span title="(x$1: Any)Boolean">equals</span><span class="delimiter">(</span><a href="#akka.stream.impl;Vertex.equals.v" title="akka.stream.impl.Vertex[_,_]">v</a>.<a href="#akka.stream.impl;Vertex.label" title="=&gt; _">label</a><span class="delimiter">)</span>
    case _               ⇒ false
  <span class="delimiter">}</span>

  override def <a title="()Int" id="akka.stream.impl;Vertex.hashCode">hashCode</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#akka.stream.impl;Vertex.label" title="=&gt; V">label</a>.<span title="()Int">hashCode</span><span class="delimiter">(</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * INTERNAL API
 */</span>
private<span class="delimiter">[</span>akka<span class="delimiter">]</span> final case class <a href="#akka.stream.impl;Edge.productElement.x$1" title="class Edge[E, V] extends AnyRef with Product with Serializable" id="akka.stream.impl.Edge.readResolve">Edge</a><span class="delimiter">[</span><a title="" id="akka.stream.impl;Edge;E">E</a>, <a title="" id="akka.stream.impl;Edge;V">V</a><span class="delimiter">]</span><a href="#akka.stream.impl.Edge.readResolve" title="Product" class="delimiter">(</a><a title="E" id="akka.stream.impl;Edge.label">label</a>: <a href="#akka.stream.impl;Edge;E" title="E">E</a>, <a title="akka.stream.impl.Vertex[E,V]" id="akka.stream.impl;Edge.from">from</a>: <a href="#akka.stream.impl.Vertex.readResolve" title="akka.stream.impl.Vertex[E,V]">Vertex</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span>, <a title="akka.stream.impl.Vertex[E,V]" id="akka.stream.impl;Edge.to">to</a>: <a href="#akka.stream.impl.Vertex.readResolve" title="akka.stream.impl.Vertex[E,V]">Vertex</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

  override def <a title="(obj: Any)Boolean" id="akka.stream.impl;Edge.equals">equals</a><span class="delimiter">(</span><a title="Any" id="akka.stream.impl;Edge.equals.obj">obj</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#akka.stream.impl;Edge.equals.obj" title="Any">obj</a> match <span class="delimiter">{</span>
    case <a title="akka.stream.impl.Edge[_,_]" id="akka.stream.impl;Edge.equals.e">e</a>: <a href="#akka.stream.impl.Edge.readResolve" title="akka.stream.impl.Edge[_,_]">Edge</a><span class="delimiter">[</span>_, _<span class="delimiter">]</span> ⇒ <a href="#akka.stream.impl;Edge.label" title="=&gt; E">label</a>.<span title="(x$1: Any)Boolean">equals</span><span class="delimiter">(</span><a href="#akka.stream.impl;Edge.equals.e" title="akka.stream.impl.Edge[_,_]">e</a>.<a href="#akka.stream.impl;Edge.label" title="=&gt; _">label</a><span class="delimiter">)</span>
    case _             ⇒ false
  <span class="delimiter">}</span>

  override def <a title="()Int" id="akka.stream.impl;Edge.hashCode">hashCode</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <a href="#akka.stream.impl;Edge.label" title="=&gt; E">label</a>.<span title="()Int">hashCode</span><span class="delimiter">(</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * INTERNAL API
 */</span>
private<span class="delimiter">[</span>akka<span class="delimiter">]</span> class <a title="class DirectedGraphBuilder[E, V] extends AnyRef" id="akka.stream.impl;DirectedGraphBuilder">DirectedGraphBuilder</a><span class="delimiter">[</span><a title="" id="akka.stream.impl;DirectedGraphBuilder;E">E</a>, <a title="" id="akka.stream.impl;DirectedGraphBuilder;V">V</a><span class="delimiter">]</span> <a href="#akka.stream.impl;DirectedGraphBuilder" title="akka.stream.impl.DirectedGraphBuilder[E,V]" class="delimiter">{</a>
  private var <a title="scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.vertexMap_=">vertexMap</a> = <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]" class="delimiter">[</span><a href="#akka.stream.impl;DirectedGraphBuilder;V" title="V">V</a>, <a href="#akka.stream.impl.Vertex.readResolve" title="akka.stream.impl.Vertex[E,V]">Vertex</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span>
  private var <a title="scala.collection.immutable.Map[E,akka.stream.impl.Edge[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.edgeMap_=">edgeMap</a> = <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[E,akka.stream.impl.Edge[E,V]]" class="delimiter">[</span><a href="#akka.stream.impl;DirectedGraphBuilder;E" title="E">E</a>, <a href="#akka.stream.impl.Edge.readResolve" title="akka.stream.impl.Edge[E,V]">Edge</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span>

  def <a title="=&gt; scala.collection.immutable.Seq[akka.stream.impl.Edge[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.edges">edges</a>: immutable.<span title="scala.collection.immutable.Seq[akka.stream.impl.Edge[E,V]]">Seq</span><span class="delimiter">[</span>Edge<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#akka.stream.impl;DirectedGraphBuilder.edgeMap_=" title="=&gt; scala.collection.immutable.Map[E,akka.stream.impl.Edge[E,V]]">edgeMap</a>.<span title="=&gt; Iterable[akka.stream.impl.Edge[E,V]]">values</span>.<span title="=&gt; Vector[akka.stream.impl.Edge[E,V]]">toVector</span>

  def <a title="=&gt; scala.collection.immutable.Seq[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.nodes">nodes</a>: immutable.<span title="scala.collection.immutable.Seq[akka.stream.impl.Vertex[E,V]]">Seq</span><span class="delimiter">[</span>Vertex<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="=&gt; scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">vertexMap</a>.<span title="=&gt; Iterable[akka.stream.impl.Vertex[E,V]]">values</span>.<span title="=&gt; Vector[akka.stream.impl.Vertex[E,V]]">toVector</span>

  def <a title="=&gt; Boolean" id="akka.stream.impl;DirectedGraphBuilder.nonEmpty">nonEmpty</a>: <span title="Boolean">Boolean</span> = <a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="=&gt; scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">vertexMap</a>.<span title="=&gt; Boolean">nonEmpty</span>

  def <a title="(v: V)akka.stream.impl.Vertex[E,V]" id="akka.stream.impl;DirectedGraphBuilder.addVertex">addVertex</a><span class="delimiter">(</span><a title="V" id="akka.stream.impl;DirectedGraphBuilder.addVertex.v">v</a>: <a href="#akka.stream.impl;DirectedGraphBuilder;V" title="V">V</a><span class="delimiter">)</span>: <a href="#akka.stream.impl.Vertex.readResolve" title="akka.stream.impl.Vertex[E,V]">Vertex</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span> = <a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="=&gt; scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">vertexMap</a>.<span title="(key: V)Option[akka.stream.impl.Vertex[E,V]]">get</span><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.addVertex.v" title="V">v</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
    case <span title="None.type">None</span> ⇒
      val <span title="akka.stream.impl.Vertex[E,V]">vx</span> = <a href="#akka.stream.impl.Vertex.readResolve" title="[E, V](label: V)akka.stream.impl.Vertex[E,V]">Vertex</a><span title="(label: V)akka.stream.impl.Vertex[E,V]" class="delimiter">[</span><a href="#akka.stream.impl;DirectedGraphBuilder;E" title="E">E</a>, <a href="#akka.stream.impl;DirectedGraphBuilder;V" title="V">V</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.addVertex.v" title="V">v</a><span class="delimiter">)</span>
      <a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="(x$1: scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]])Unit">vertexMap</a> <span title="(kv: (V, akka.stream.impl.Vertex[E,V]))scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">+=</span> <a href="#akka.stream.impl;DirectedGraphBuilder.addVertex.v" title="(self: V)ArrowAssoc[V]">v</a> <span title="(y: akka.stream.impl.Vertex[E,V])(V, akka.stream.impl.Vertex[E,V])">-&gt;</span> <span title="akka.stream.impl.Vertex[E,V]">vx</span>
      <span title="akka.stream.impl.Vertex[E,V]">vx</span>

    case Some<span class="delimiter">(</span><span title="akka.stream.impl.Vertex[E,V]">vx</span><span class="delimiter">)</span> ⇒ <span title="akka.stream.impl.Vertex[E,V]">vx</span>
  <span class="delimiter">}</span>

  def <a title="(from: V, to: V, label: E)Unit" id="akka.stream.impl;DirectedGraphBuilder.addEdge">addEdge</a><span class="delimiter">(</span><a title="V" id="akka.stream.impl;DirectedGraphBuilder.addEdge.from">from</a>: <a href="#akka.stream.impl;DirectedGraphBuilder;V" title="V">V</a>, <a title="V" id="akka.stream.impl;DirectedGraphBuilder.addEdge.to">to</a>: <a href="#akka.stream.impl;DirectedGraphBuilder;V" title="V">V</a>, <a title="E" id="akka.stream.impl;DirectedGraphBuilder.addEdge.label">label</a>: <a href="#akka.stream.impl;DirectedGraphBuilder;E" title="E">E</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    val <a title="akka.stream.impl.Vertex[E,V]" id="akka.stream.impl;DirectedGraphBuilder.addEdge.vfrom">vfrom</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.addVertex" title="(v: V)akka.stream.impl.Vertex[E,V]">addVertex</a><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.addEdge.from" title="V">from</a><span class="delimiter">)</span>
    val <a title="akka.stream.impl.Vertex[E,V]" id="akka.stream.impl;DirectedGraphBuilder.addEdge.vto">vto</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.addVertex" title="(v: V)akka.stream.impl.Vertex[E,V]">addVertex</a><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.addEdge.to" title="V">to</a><span class="delimiter">)</span>

    <a href="#akka.stream.impl;DirectedGraphBuilder.removeEdge" title="(label: E)Unit">removeEdge</a><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.addEdge.label" title="E">label</a><span class="delimiter">)</span> <span class="comment">// Need to remap existing labels</span>
    val <a title="akka.stream.impl.Edge[E,V]" id="akka.stream.impl;DirectedGraphBuilder.addEdge.edge">edge</a> = <a href="#akka.stream.impl.Edge.readResolve" title="[E, V](label: E, from: akka.stream.impl.Vertex[E,V], to: akka.stream.impl.Vertex[E,V])akka.stream.impl.Edge[E,V]">Edge</a><span title="(label: E, from: akka.stream.impl.Vertex[E,V], to: akka.stream.impl.Vertex[E,V])akka.stream.impl.Edge[E,V]" class="delimiter">[</span><a href="#akka.stream.impl;DirectedGraphBuilder;E" title="E">E</a>, <a href="#akka.stream.impl;DirectedGraphBuilder;V" title="V">V</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.addEdge.label" title="E">label</a>, <a href="#akka.stream.impl;DirectedGraphBuilder.addEdge.vfrom" title="akka.stream.impl.Vertex[E,V]">vfrom</a>, <a href="#akka.stream.impl;DirectedGraphBuilder.addEdge.vto" title="akka.stream.impl.Vertex[E,V]">vto</a><span class="delimiter">)</span>
    <a href="#akka.stream.impl;DirectedGraphBuilder.edgeMap_=" title="(x$1: scala.collection.immutable.Map[E,akka.stream.impl.Edge[E,V]])Unit">edgeMap</a> <span title="(kv: (E, akka.stream.impl.Edge[E,V]))scala.collection.immutable.Map[E,akka.stream.impl.Edge[E,V]]">+=</span> <a href="#akka.stream.impl;DirectedGraphBuilder.addEdge.label" title="(self: E)ArrowAssoc[E]">label</a> <span title="(y: akka.stream.impl.Edge[E,V])(E, akka.stream.impl.Edge[E,V])">-&gt;</span> <a href="#akka.stream.impl;DirectedGraphBuilder.addEdge.edge" title="akka.stream.impl.Edge[E,V]">edge</a>

    <a href="#akka.stream.impl;DirectedGraphBuilder.addEdge.vfrom" title="akka.stream.impl.Vertex[E,V]">vfrom</a>.<a href="#akka.stream.impl;Vertex.addOutEdge" title="(e: akka.stream.impl.Edge[E,V])Unit">addOutEdge</a><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.addEdge.edge" title="akka.stream.impl.Edge[E,V]">edge</a><span class="delimiter">)</span>
    <a href="#akka.stream.impl;DirectedGraphBuilder.addEdge.vto" title="akka.stream.impl.Vertex[E,V]">vto</a>.<a href="#akka.stream.impl;Vertex.addInEdge" title="(e: akka.stream.impl.Edge[E,V])Unit">addInEdge</a><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.addEdge.edge" title="akka.stream.impl.Edge[E,V]">edge</a><span class="delimiter">)</span>

  <span class="delimiter">}</span>

  def <a title="(v: V)Option[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.find">find</a><span class="delimiter">(</span><a title="V" id="akka.stream.impl;DirectedGraphBuilder.find.v">v</a>: <a href="#akka.stream.impl;DirectedGraphBuilder;V" title="V">V</a><span class="delimiter">)</span>: <span title="Option[akka.stream.impl.Vertex[E,V]]">Option</span><span class="delimiter">[</span>Vertex<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="=&gt; scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">vertexMap</a>.<span title="(key: V)Option[akka.stream.impl.Vertex[E,V]]">get</span><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.find.v" title="V">v</a><span class="delimiter">)</span>

  def <a title="(v: V)akka.stream.impl.Vertex[E,V]" id="akka.stream.impl;DirectedGraphBuilder.get">get</a><span class="delimiter">(</span><a title="V" id="akka.stream.impl;DirectedGraphBuilder.get.v">v</a>: <a href="#akka.stream.impl;DirectedGraphBuilder;V" title="V">V</a><span class="delimiter">)</span>: <a href="#akka.stream.impl.Vertex.readResolve" title="akka.stream.impl.Vertex[E,V]">Vertex</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span> = <a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="(key: V)akka.stream.impl.Vertex[E,V]">vertexMap</a><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.get.v" title="V">v</a><span class="delimiter">)</span>

  def <a title="(v: V)Boolean" id="akka.stream.impl;DirectedGraphBuilder.contains">contains</a><span class="delimiter">(</span><a title="V" id="akka.stream.impl;DirectedGraphBuilder.contains.v">v</a>: <a href="#akka.stream.impl;DirectedGraphBuilder;V" title="V">V</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="=&gt; scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">vertexMap</a>.<span title="(key: V)Boolean">contains</span><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.contains.v" title="V">v</a><span class="delimiter">)</span>

  def <a title="(e: E)Boolean" id="akka.stream.impl;DirectedGraphBuilder.containsEdge">containsEdge</a><span class="delimiter">(</span><a title="E" id="akka.stream.impl;DirectedGraphBuilder.containsEdge.e">e</a>: <a href="#akka.stream.impl;DirectedGraphBuilder;E" title="E">E</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#akka.stream.impl;DirectedGraphBuilder.edgeMap_=" title="=&gt; scala.collection.immutable.Map[E,akka.stream.impl.Edge[E,V]]">edgeMap</a>.<span title="(key: E)Boolean">contains</span><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.containsEdge.e" title="E">e</a><span class="delimiter">)</span>

  def <a title="(p: akka.stream.impl.Vertex[E,V] =&gt; Boolean)Boolean" id="akka.stream.impl;DirectedGraphBuilder.exists">exists</a><span class="delimiter">(</span><a title="akka.stream.impl.Vertex[E,V] =&gt; Boolean" id="akka.stream.impl;DirectedGraphBuilder.exists.p">p</a>: Vertex<span class="delimiter">[</span>E, V<span class="delimiter">]</span> ⇒ Boolean<span class="delimiter">)</span> = <a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="=&gt; scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">vertexMap</a>.<span title="=&gt; Iterable[akka.stream.impl.Vertex[E,V]]">values</span>.<span title="(p: akka.stream.impl.Vertex[E,V] =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.exists.p" title="akka.stream.impl.Vertex[E,V] =&gt; Boolean">p</a><span class="delimiter">)</span>

  def <a title="(label: E)Unit" id="akka.stream.impl;DirectedGraphBuilder.removeEdge">removeEdge</a><span class="delimiter">(</span><a title="E" id="akka.stream.impl;DirectedGraphBuilder.removeEdge.label">label</a>: <a href="#akka.stream.impl;DirectedGraphBuilder;E" title="E">E</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.stream.impl;DirectedGraphBuilder.edgeMap_=" title="=&gt; scala.collection.immutable.Map[E,akka.stream.impl.Edge[E,V]]">edgeMap</a>.<span title="(key: E)Option[akka.stream.impl.Edge[E,V]]">get</span><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.removeEdge.label" title="E">label</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
    case Some<span class="delimiter">(</span><a title="akka.stream.impl.Edge[E,V]" id="akka.stream.impl;DirectedGraphBuilder.removeEdge.e">e</a><span class="delimiter">)</span> ⇒
      <a href="#akka.stream.impl;DirectedGraphBuilder.edgeMap_=" title="(x$1: scala.collection.immutable.Map[E,akka.stream.impl.Edge[E,V]])Unit">edgeMap</a> <span title="(key: E)scala.collection.immutable.Map[E,akka.stream.impl.Edge[E,V]]">-=</span> <a href="#akka.stream.impl;DirectedGraphBuilder.removeEdge.label" title="E">label</a>
      <a href="#akka.stream.impl;DirectedGraphBuilder.removeEdge.e" title="akka.stream.impl.Edge[E,V]">e</a>.<a href="#akka.stream.impl;Edge.from" title="=&gt; akka.stream.impl.Vertex[E,V]">from</a>.<a href="#akka.stream.impl;Vertex.removeOutEdge" title="(e: akka.stream.impl.Edge[E,V])Unit">removeOutEdge</a><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.removeEdge.e" title="akka.stream.impl.Edge[E,V]">e</a><span class="delimiter">)</span>
      <a href="#akka.stream.impl;DirectedGraphBuilder.removeEdge.e" title="akka.stream.impl.Edge[E,V]">e</a>.<a href="#akka.stream.impl;Edge.to" title="=&gt; akka.stream.impl.Vertex[E,V]">to</a>.<a href="#akka.stream.impl;Vertex.removeInEdge" title="(e: akka.stream.impl.Edge[E,V])Unit">removeInEdge</a><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.removeEdge.e" title="akka.stream.impl.Edge[E,V]">e</a><span class="delimiter">)</span>
    case <span title="None.type">None</span> ⇒
  <span class="delimiter">}</span>

  def <a title="(v: V)Unit" id="akka.stream.impl;DirectedGraphBuilder.remove">remove</a><span class="delimiter">(</span><a title="V" id="akka.stream.impl;DirectedGraphBuilder.remove.v">v</a>: <a href="#akka.stream.impl;DirectedGraphBuilder;V" title="V">V</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="=&gt; scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">vertexMap</a>.<span title="(key: V)Option[akka.stream.impl.Vertex[E,V]]">get</span><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.remove.v" title="V">v</a><span class="delimiter">)</span> match <span class="delimiter">{</span>
    case Some<span class="delimiter">(</span><a title="akka.stream.impl.Vertex[E,V]" id="akka.stream.impl;DirectedGraphBuilder.remove.vx">vx</a><span class="delimiter">)</span> ⇒
      <a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="(x$1: scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]])Unit">vertexMap</a> <span title="(key: V)scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">-=</span> <a href="#akka.stream.impl;DirectedGraphBuilder.remove.v" title="V">v</a>

      <a href="#akka.stream.impl;DirectedGraphBuilder.remove.vx" title="akka.stream.impl.Vertex[E,V]">vx</a>.<a href="#akka.stream.impl;Vertex.incoming" title="=&gt; Set[akka.stream.impl.Edge[E,V]]">incoming</a> <span title="(f: akka.stream.impl.Edge[E,V] =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <span title="akka.stream.impl.Edge[E,V]">edge</span> ⇒ <a href="#akka.stream.impl;DirectedGraphBuilder.removeEdge" title="(label: E)Unit">removeEdge</a><span class="delimiter">(</span><span title="akka.stream.impl.Edge[E,V]">edge</span>.<a href="#akka.stream.impl;Edge.label" title="=&gt; E">label</a><span class="delimiter">)</span> <span class="delimiter">}</span>
      <a href="#akka.stream.impl;DirectedGraphBuilder.remove.vx" title="akka.stream.impl.Vertex[E,V]">vx</a>.<a href="#akka.stream.impl;Vertex.outgoing" title="=&gt; Set[akka.stream.impl.Edge[E,V]]">outgoing</a> <span title="(f: akka.stream.impl.Edge[E,V] =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <span title="akka.stream.impl.Edge[E,V]">edge</span> ⇒ <a href="#akka.stream.impl;DirectedGraphBuilder.removeEdge" title="(label: E)Unit">removeEdge</a><span class="delimiter">(</span><span title="akka.stream.impl.Edge[E,V]">edge</span>.<a href="#akka.stream.impl;Edge.label" title="=&gt; E">label</a><span class="delimiter">)</span> <span class="delimiter">}</span>

    case <span title="None.type">None</span> ⇒
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Performs a deep copy of the builder. Since the builder is mutable it is not safe to share instances of it
   * without making a defensive copy first.
   */</span>
  def <a title="()akka.stream.impl.DirectedGraphBuilder[E,V]" id="akka.stream.impl;DirectedGraphBuilder.copy">copy</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.stream.impl;DirectedGraphBuilder" title="akka.stream.impl.DirectedGraphBuilder[E,V]">DirectedGraphBuilder</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="akka.stream.impl.DirectedGraphBuilder[E,V]" id="akka.stream.impl;DirectedGraphBuilder.copy.result">result</a> = new <a href="#akka.stream.impl;DirectedGraphBuilder" title="akka.stream.impl.DirectedGraphBuilder[E,V]">DirectedGraphBuilder</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>

    <a href="#akka.stream.impl;DirectedGraphBuilder.edgeMap_=" title="=&gt; scala.collection.immutable.Map[E,akka.stream.impl.Edge[E,V]]">edgeMap</a>.<span title="(f: ((E, akka.stream.impl.Edge[E,V])) =&gt; Unit)Unit">foreach</span> <a href="#akka.stream.impl;DirectedGraphBuilder.copy.$anonfun.x0$1" title="Unit" class="delimiter">{</a>
      case <span class="delimiter">(</span><a title="E" id="akka.stream.impl;DirectedGraphBuilder.copy.$anonfun.label">label</a>, <a title="akka.stream.impl.Edge[E,V]" id="akka.stream.impl;DirectedGraphBuilder.copy.$anonfun.e">e</a><span class="delimiter">)</span> ⇒
        <a href="#akka.stream.impl;DirectedGraphBuilder.copy.result" title="akka.stream.impl.DirectedGraphBuilder[E,V]">result</a>.<a href="#akka.stream.impl;DirectedGraphBuilder.addEdge" title="(from: V, to: V, label: E)Unit">addEdge</a><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.copy.$anonfun.e" title="akka.stream.impl.Edge[E,V]">e</a>.<a href="#akka.stream.impl;Edge.from" title="=&gt; akka.stream.impl.Vertex[E,V]">from</a>.<a href="#akka.stream.impl;Vertex.label" title="=&gt; V">label</a>, <a href="#akka.stream.impl;DirectedGraphBuilder.copy.$anonfun.e" title="akka.stream.impl.Edge[E,V]">e</a>.<a href="#akka.stream.impl;Edge.to" title="=&gt; akka.stream.impl.Vertex[E,V]">to</a>.<a href="#akka.stream.impl;Vertex.label" title="=&gt; V">label</a>, <a href="#akka.stream.impl;DirectedGraphBuilder.copy.$anonfun.e" title="akka.stream.impl.Edge[E,V]">e</a>.<a href="#akka.stream.impl;Edge.label" title="=&gt; E">label</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="=&gt; scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">vertexMap</a>.<span title="(p: ((V, akka.stream.impl.Vertex[E,V])) =&gt; Boolean)scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">filter</span><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.copy.$anonfun.x$3" title="(V, akka.stream.impl.Vertex[E,V])">_</a>.<span title="=&gt; akka.stream.impl.Vertex[E,V]">_2</span>.<a href="#akka.stream.impl;Vertex.isolated" title="=&gt; Boolean">isolated</a><span class="delimiter">)</span> <span title="(f: ((V, akka.stream.impl.Vertex[E,V])) =&gt; akka.stream.impl.Vertex[E,V])Unit">foreach</span> <a href="#akka.stream.impl;DirectedGraphBuilder.copy.$anonfun.x0$2" title="akka.stream.impl.Vertex[E,V]" class="delimiter">{</a>
      case <span class="delimiter">(</span>_, <a title="akka.stream.impl.Vertex[E,V]" id="akka.stream.impl;DirectedGraphBuilder.copy.$anonfun.n">n</a><span class="delimiter">)</span> ⇒
        <a href="#akka.stream.impl;DirectedGraphBuilder.copy.result" title="akka.stream.impl.DirectedGraphBuilder[E,V]">result</a>.<a href="#akka.stream.impl;DirectedGraphBuilder.addVertex" title="(v: V)akka.stream.impl.Vertex[E,V]">addVertex</a><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.copy.$anonfun.n" title="akka.stream.impl.Vertex[E,V]">n</a>.<a href="#akka.stream.impl;Vertex.label" title="=&gt; V">label</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#akka.stream.impl;DirectedGraphBuilder.copy.result" title="akka.stream.impl.DirectedGraphBuilder[E,V]">result</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns true if for every vertex pair there is an undirected path connecting them
   */</span>
  def <a title="=&gt; Boolean" id="akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected">isWeaklyConnected</a>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="=&gt; scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">vertexMap</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> true
    else <span class="delimiter">{</span>
      var <a title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.unvisited">unvisited</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="=&gt; scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">vertexMap</a>.<span title="=&gt; Iterable[akka.stream.impl.Vertex[E,V]]">values</span>.<span title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">toSet</span>
      var <a title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.toVisit">toVisit</a> = <span title="(elems: akka.stream.impl.Vertex[E,V]*)scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">Set</span><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.unvisited" title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">unvisited</a>.<span title="=&gt; akka.stream.impl.Vertex[E,V]">head</span><span class="delimiter">)</span>

      while <span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.toVisit" title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">toVisit</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.while$1" title="()Unit" class="delimiter">{</a>
        val <a title="akka.stream.impl.Vertex[E,V]" id="akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.v">v</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.toVisit" title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">toVisit</a>.<span title="=&gt; akka.stream.impl.Vertex[E,V]">head</span>
        <a href="#akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.unvisited" title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">unvisited</a> <span title="(elem: akka.stream.impl.Vertex[E,V])scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">-=</span> <a href="#akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.v" title="akka.stream.impl.Vertex[E,V]">v</a>
        <a href="#akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.toVisit" title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">toVisit</a> <span title="(elem: akka.stream.impl.Vertex[E,V])scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">-=</span> <a href="#akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.v" title="akka.stream.impl.Vertex[E,V]">v</a>
        <a href="#akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.toVisit" title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">toVisit</a> <span title="(elems: scala.collection.GenTraversableOnce[akka.stream.impl.Vertex[E,V]])scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">++=</span> <a href="#akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.v" title="akka.stream.impl.Vertex[E,V]">v</a>.<a href="#akka.stream.impl;Vertex.neighbors" title="=&gt; Set[akka.stream.impl.Vertex[E,V]]">neighbors</a>.<span title="=&gt; Iterator[akka.stream.impl.Vertex[E,V]]">iterator</span>.<span title="(p: akka.stream.impl.Vertex[E,V] =&gt; Boolean)Iterator[akka.stream.impl.Vertex[E,V]]">filter</span><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.unvisited" title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">unvisited</a>.<a href="#akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.$anonfun.elem" title="(elem: akka.stream.impl.Vertex[E,V])Boolean">contains</a><span class="delimiter">)</span> <span class="comment">// visit all unvisited neighbors of v (neighbors are undirected)</span>
      <span class="delimiter">}</span>

      <a href="#akka.stream.impl;DirectedGraphBuilder.isWeaklyConnected.unvisited" title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">unvisited</a>.<span title="=&gt; Boolean">isEmpty</span> <span class="comment">// if we ended up with unvisited nodes starting from one node we are unconnected</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Finds a directed cycle in the graph
   */</span>
  def <a title="=&gt; scala.collection.immutable.Seq[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.findCycle">findCycle</a>: immutable.<span title="scala.collection.immutable.Seq[akka.stream.impl.Vertex[E,V]]">Seq</span><span class="delimiter">[</span>Vertex<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="=&gt; scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">vertexMap</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(2)" class="int">2</span> <span title="(x: Boolean)Boolean">||</span> <a href="#akka.stream.impl;DirectedGraphBuilder.edgeMap_=" title="=&gt; scala.collection.immutable.Map[E,akka.stream.impl.Edge[E,V]]">edgeMap</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(2)" class="int">2</span><span class="delimiter">)</span> <span title="scala.collection.immutable.Nil.type">Nil</span>
    else <span class="delimiter">{</span>
      <span class="comment">// Vertices we have not visited at all yet</span>
      var <a title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.findCycle.unvisited">unvisited</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.vertexMap_=" title="=&gt; scala.collection.immutable.Map[V,akka.stream.impl.Vertex[E,V]]">vertexMap</a>.<span title="=&gt; Iterable[akka.stream.impl.Vertex[E,V]]">values</span>.<span title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">toSet</span>

      <span class="comment">// Attempts to find a cycle in a connected component</span>
      def <a title="(componentEntryVertex: akka.stream.impl.Vertex[E,V], toVisit: akka.stream.impl.Vertex[E,V], cycleCandidate: List[akka.stream.impl.Vertex[E,V]])List[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent">findCycleInComponent</a><span class="delimiter">(</span>
        <a title="akka.stream.impl.Vertex[E,V]" id="akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.componentEntryVertex">componentEntryVertex</a>: <a href="#akka.stream.impl.Vertex.readResolve" title="akka.stream.impl.Vertex[E,V]">Vertex</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span>,
        <a title="akka.stream.impl.Vertex[E,V]" id="akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.toVisit">toVisit</a>: <a href="#akka.stream.impl.Vertex.readResolve" title="akka.stream.impl.Vertex[E,V]">Vertex</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span>,
        <a title="List[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.cycleCandidate">cycleCandidate</a>: <span title="List[akka.stream.impl.Vertex[E,V]]">List</span><span class="delimiter">[</span>Vertex<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[akka.stream.impl.Vertex[E,V]]">List</span><span class="delimiter">[</span>Vertex<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>

        if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.unvisited" title="(elem: akka.stream.impl.Vertex[E,V])Boolean">unvisited</a><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.toVisit" title="akka.stream.impl.Vertex[E,V]">toVisit</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="scala.collection.immutable.Nil.type">Nil</span>
        else <span class="delimiter">{</span>
          <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.unvisited" title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">unvisited</a> <span title="(elem: akka.stream.impl.Vertex[E,V])scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">-=</span> <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.toVisit" title="akka.stream.impl.Vertex[E,V]">toVisit</a>

          val <a title="Set[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.successors">successors</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.toVisit" title="akka.stream.impl.Vertex[E,V]">toVisit</a>.<a href="#akka.stream.impl;Vertex.successors" title="=&gt; Set[akka.stream.impl.Vertex[E,V]]">successors</a>
          if <span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.successors" title="Set[akka.stream.impl.Vertex[E,V]]">successors</a>.<span title="(elem: akka.stream.impl.Vertex[E,V])Boolean">contains</span><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.componentEntryVertex" title="akka.stream.impl.Vertex[E,V]">componentEntryVertex</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.toVisit" title="akka.stream.impl.Vertex[E,V]">toVisit</a> <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.x$4" title="(x: akka.stream.impl.Vertex[E,V])List[akka.stream.impl.Vertex[E,V]]">::</a> <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.cycleCandidate" title="List[akka.stream.impl.Vertex[E,V]]">cycleCandidate</a>
          else <span class="delimiter">{</span>
            val newCycleCandidate = <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.toVisit" title="akka.stream.impl.Vertex[E,V]">toVisit</a> <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.newCycleCandidate.x$5" title="List[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.newCycleCandidate">::</a> <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.cycleCandidate" title="List[akka.stream.impl.Vertex[E,V]]">cycleCandidate</a>

            <span class="comment">// search in all successors</span>
            @tailrec def <a title="(toTraverse: Set[akka.stream.impl.Vertex[E,V]])List[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.traverse">traverse</a><span class="delimiter">(</span><a title="Set[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.traverse.toTraverse">toTraverse</a>: <span title="Set[akka.stream.impl.Vertex[E,V]]">Set</span><span class="delimiter">[</span>Vertex<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="List[akka.stream.impl.Vertex[E,V]]">List</span><span class="delimiter">[</span>Vertex<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
              if <span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.traverse.toTraverse" title="Set[akka.stream.impl.Vertex[E,V]]">toTraverse</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="scala.collection.immutable.Nil.type">Nil</span>
              else <span class="delimiter">{</span>
                val <a title="akka.stream.impl.Vertex[E,V]" id="akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.traverse.v">v</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.traverse.toTraverse" title="Set[akka.stream.impl.Vertex[E,V]]">toTraverse</a>.<span title="=&gt; akka.stream.impl.Vertex[E,V]">head</span>
                val <a title="List[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.traverse.c">c</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent" title="(componentEntryVertex: akka.stream.impl.Vertex[E,V], toVisit: akka.stream.impl.Vertex[E,V], cycleCandidate: List[akka.stream.impl.Vertex[E,V]])List[akka.stream.impl.Vertex[E,V]]">findCycleInComponent</a><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.componentEntryVertex" title="akka.stream.impl.Vertex[E,V]">componentEntryVertex</a>, toVisit = <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.traverse.v" title="akka.stream.impl.Vertex[E,V]">v</a>, <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.newCycleCandidate" title="List[akka.stream.impl.Vertex[E,V]]">newCycleCandidate</a><span class="delimiter">)</span>
                if <span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.traverse.c" title="List[akka.stream.impl.Vertex[E,V]]">c</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.traverse.c" title="List[akka.stream.impl.Vertex[E,V]]">c</a>
                else <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.traverse" title="(toTraverse: Set[akka.stream.impl.Vertex[E,V]])List[akka.stream.impl.Vertex[E,V]]">traverse</a><span class="delimiter">(</span>toTraverse = <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.traverse.toTraverse" title="Set[akka.stream.impl.Vertex[E,V]]">toTraverse</a> <span title="(elem: akka.stream.impl.Vertex[E,V])scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">-</span> <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.traverse.v" title="akka.stream.impl.Vertex[E,V]">v</a><span class="delimiter">)</span>
              <span class="delimiter">}</span>
            <span class="delimiter">}</span>

            <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.traverse" title="(toTraverse: Set[akka.stream.impl.Vertex[E,V]])List[akka.stream.impl.Vertex[E,V]]">traverse</a><span class="delimiter">(</span>toTraverse = <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent.successors" title="Set[akka.stream.impl.Vertex[E,V]]">successors</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>

      <span class="delimiter">}</span>

      <span class="comment">// Traverse all weakly connected components and try to find cycles in each of them</span>
      @tailrec def <a title="()List[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.findCycle.findNextCycle">findNextCycle</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="List[akka.stream.impl.Vertex[E,V]]">List</span><span class="delimiter">[</span>Vertex<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.unvisited" title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">unvisited</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(2)" class="int">2</span><span class="delimiter">)</span> <span title="scala.collection.immutable.Nil.type">Nil</span>
        else <span class="delimiter">{</span>
          <span class="comment">// Pick a node to recursively start visiting its successors</span>
          val <a title="akka.stream.impl.Vertex[E,V]" id="akka.stream.impl;DirectedGraphBuilder.findCycle.findNextCycle.componentEntry">componentEntry</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.unvisited" title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">unvisited</a>.<span title="=&gt; akka.stream.impl.Vertex[E,V]">head</span>

          if <span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findNextCycle.componentEntry" title="akka.stream.impl.Vertex[E,V]">componentEntry</a>.<a href="#akka.stream.impl;Vertex.inDegree" title="=&gt; Int">inDegree</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(1)" class="int">1</span> <span title="(x: Boolean)Boolean">||</span> <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findNextCycle.componentEntry" title="akka.stream.impl.Vertex[E,V]">componentEntry</a>.<a href="#akka.stream.impl;Vertex.outDegree" title="=&gt; Int">outDegree</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.unvisited" title="scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">unvisited</a> <span title="(elem: akka.stream.impl.Vertex[E,V])scala.collection.immutable.Set[akka.stream.impl.Vertex[E,V]]">-=</span> <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findNextCycle.componentEntry" title="akka.stream.impl.Vertex[E,V]">componentEntry</a>
            <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findNextCycle" title="()List[akka.stream.impl.Vertex[E,V]]">findNextCycle</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <span class="delimiter">}</span> else <span class="delimiter">{</span>
            val <a title="List[akka.stream.impl.Vertex[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.findCycle.findNextCycle.cycleCandidate">cycleCandidate</a> =
              <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findCycleInComponent" title="(componentEntryVertex: akka.stream.impl.Vertex[E,V], toVisit: akka.stream.impl.Vertex[E,V], cycleCandidate: List[akka.stream.impl.Vertex[E,V]])List[akka.stream.impl.Vertex[E,V]]">findCycleInComponent</a><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findNextCycle.componentEntry" title="akka.stream.impl.Vertex[E,V]">componentEntry</a>, toVisit = <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findNextCycle.componentEntry" title="akka.stream.impl.Vertex[E,V]">componentEntry</a>, cycleCandidate = <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>

            if <span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findNextCycle.cycleCandidate" title="List[akka.stream.impl.Vertex[E,V]]">cycleCandidate</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findNextCycle.cycleCandidate" title="List[akka.stream.impl.Vertex[E,V]]">cycleCandidate</a>
            else <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findNextCycle" title="()List[akka.stream.impl.Vertex[E,V]]">findNextCycle</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <span class="delimiter">}</span>

        <span class="delimiter">}</span>

      <span class="delimiter">}</span>

      <a href="#akka.stream.impl;DirectedGraphBuilder.findCycle.findNextCycle" title="()List[akka.stream.impl.Vertex[E,V]]">findNextCycle</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  def <a title="[T](start: akka.stream.impl.Vertex[E,V])(zero: T)(f: (T, akka.stream.impl.Edge[E,V]) =&gt; T)T" id="akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft">edgePredecessorBFSfoldLeft</a><span class="delimiter">[</span><a title="" id="akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.impl.Vertex[E,V]" id="akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.start">start</a>: <a href="#akka.stream.impl.Vertex.readResolve" title="akka.stream.impl.Vertex[E,V]">Vertex</a><span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="T" id="akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.zero">zero</a>: <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(T, akka.stream.impl.Edge[E,V]) =&gt; T" id="akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.f">f</a>: <span class="delimiter">(</span>T, Edge<span class="delimiter">[</span>E, V<span class="delimiter">]</span><span class="delimiter">)</span> ⇒ T<span class="delimiter">)</span>: <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft;T" title="T">T</a> = <span class="delimiter">{</span>
    var <a title="T" id="akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.aggr">aggr</a>: <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft;T" title="T">T</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.zero" title="T">zero</a>
    var <a title="scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.unvisited">unvisited</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.edgeMap_=" title="=&gt; scala.collection.immutable.Map[E,akka.stream.impl.Edge[E,V]]">edgeMap</a>.<span title="=&gt; Iterable[akka.stream.impl.Edge[E,V]]">values</span>.<span title="scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">toSet</span>
    <span class="comment">// Queue to maintain BFS state</span>
    var toVisit = immutable.<span title="(xs: Nothing*)scala.collection.immutable.Queue[Nothing]">Queue</span><span class="delimiter">(</span><span class="delimiter">)</span> <a title="scala.collection.immutable.Queue[akka.stream.impl.Edge[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.toVisit">++</a> <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.start" title="akka.stream.impl.Vertex[E,V]">start</a>.<a href="#akka.stream.impl;Vertex.incoming" title="=&gt; Set[akka.stream.impl.Edge[E,V]]">incoming</a>

    while <span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.toVisit" title="scala.collection.immutable.Queue[akka.stream.impl.Edge[E,V]]">toVisit</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.while$2" title="()Unit" class="delimiter">{</a>
      val <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.e" title="(akka.stream.impl.Edge[E,V], scala.collection.immutable.Queue[akka.stream.impl.Edge[E,V]])" class="delimiter">(</a><a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.x$6" title="akka.stream.impl.Edge[E,V]" id="akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.e">e</a>, <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.x$6" title="scala.collection.immutable.Queue[akka.stream.impl.Edge[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.nextToVisit">nextToVisit</a><span class="delimiter">)</span> = <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.toVisit" title="scala.collection.immutable.Queue[akka.stream.impl.Edge[E,V]]">toVisit</a>.<span title="=&gt; (akka.stream.impl.Edge[E,V], scala.collection.immutable.Queue[akka.stream.impl.Edge[E,V]])">dequeue</span>
      <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.toVisit" title="scala.collection.immutable.Queue[akka.stream.impl.Edge[E,V]]">toVisit</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.nextToVisit" title="scala.collection.immutable.Queue[akka.stream.impl.Edge[E,V]]">nextToVisit</a>

      <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.unvisited" title="scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">unvisited</a> <span title="(elem: akka.stream.impl.Edge[E,V])scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">-=</span> <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.e" title="akka.stream.impl.Edge[E,V]">e</a>
      <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.aggr" title="T">aggr</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.f" title="(v1: T, v2: akka.stream.impl.Edge[E,V])T">f</a><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.aggr" title="T">aggr</a>, <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.e" title="akka.stream.impl.Edge[E,V]">e</a><span class="delimiter">)</span>
      val <a title="scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]" id="akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.unvisitedPredecessors">unvisitedPredecessors</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.e" title="akka.stream.impl.Edge[E,V]">e</a>.<a href="#akka.stream.impl;Edge.from" title="=&gt; akka.stream.impl.Vertex[E,V]">from</a>.<a href="#akka.stream.impl;Vertex.incoming" title="=&gt; Set[akka.stream.impl.Edge[E,V]]">incoming</a>.<span title="(p: akka.stream.impl.Edge[E,V] =&gt; Boolean)scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">filter</span><span class="delimiter">(</span><a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.unvisited" title="scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">unvisited</a>.<a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.unvisitedPredecessors.$anonfun.elem" title="(elem: akka.stream.impl.Edge[E,V])Boolean">contains</a><span class="delimiter">)</span>
      <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.unvisited" title="scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">unvisited</a> <span title="(xs: scala.collection.GenTraversableOnce[akka.stream.impl.Edge[E,V]])scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">--=</span> <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.unvisitedPredecessors" title="scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">unvisitedPredecessors</a>
      <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.toVisit" title="scala.collection.immutable.Queue[akka.stream.impl.Edge[E,V]]">toVisit</a> = <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.toVisit" title="scala.collection.immutable.Queue[akka.stream.impl.Edge[E,V]]">toVisit</a> <span title="(that: scala.collection.GenTraversableOnce[akka.stream.impl.Edge[E,V]])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Queue[akka.stream.impl.Edge[E,V]],akka.stream.impl.Edge[E,V],scala.collection.immutable.Queue[akka.stream.impl.Edge[E,V]]])scala.collection.immutable.Queue[akka.stream.impl.Edge[E,V]]">++</span> <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.unvisitedPredecessors" title="scala.collection.immutable.Set[akka.stream.impl.Edge[E,V]]">unvisitedPredecessors</a>
    <span class="delimiter">}</span>

    <a href="#akka.stream.impl;DirectedGraphBuilder.edgePredecessorBFSfoldLeft.aggr" title="T">aggr</a>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
