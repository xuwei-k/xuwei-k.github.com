<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>akka/stream/scaladsl/FlexiMerge.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Copyright (C) 2009-2014 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
package akka.stream.scaladsl

import scala.annotation.varargs
import scala.collection.immutable
import akka.stream.scaladsl.<a href="OperationAttributes.scala.html#akka.stream.scaladsl.OperationAttributes" title="akka.stream.scaladsl.OperationAttributes.type">OperationAttributes</a>._
import akka.stream.impl.Ast
import akka.stream.impl.<a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast" title="akka.stream.impl.Ast.type">Ast</a>.<a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast.Defaults" title="akka.stream.impl.Ast.Defaults.type">Defaults</a>._
import akka.stream.impl.<a href="../impl/FlexiMergeImpl.scala.html#akka.stream.impl.FlexiMergeImpl" title="akka.stream.impl.FlexiMergeImpl.type">FlexiMergeImpl</a>.MergeLogicFactory

object <a title="akka.stream.scaladsl.FlexiMerge.type" id="akka.stream.scaladsl.FlexiMerge">FlexiMerge</a> <a href="#akka.stream.scaladsl.FlexiMerge" title="akka.stream.scaladsl.FlexiMerge.type" class="delimiter">{</a>

  <span class="comment">/**
   * @see [[InputPort]]
   */</span>
  trait <a title="trait InputHandle extends AnyRef" id="akka.stream.scaladsl.FlexiMerge;InputHandle">InputHandle</a> <span class="delimiter">{</span>
    private<span class="delimiter">[</span>akka<span class="delimiter">]</span> def <a title="=&gt; Int" id="akka.stream.scaladsl.FlexiMerge;InputHandle.portIndex">portIndex</a>: <span title="Int">Int</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * An `InputPort` can be connected to a [[Source]] with the [[FlowGraphBuilder]].
   * The `InputPort` is also an [[InputHandle]], which is passed as parameter
   * to [[MergeLogic#State]] `onInput` when an input element has been read so that you
   * can know exactly from which input the element was read.
   */</span>
  class <a title="class InputPort[In, Out] extends AnyRef with akka.stream.scaladsl.JunctionInPort[In] with akka.stream.scaladsl.FlexiMerge.InputHandle" id="akka.stream.scaladsl.FlexiMerge;InputPort">InputPort</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.FlexiMerge;InputPort;In">In</a>, <a title="" id="akka.stream.scaladsl.FlexiMerge;InputPort;Out">Out</a><span class="delimiter">]</span> private<span class="delimiter">[</span>akka<span class="delimiter">]</span> <span class="delimiter">(</span>override private<span class="delimiter">[</span>akka<span class="delimiter">]</span> val <a title="Int" id="akka.stream.scaladsl.FlexiMerge;InputPort.port">port</a>: <span title="Int">Int</span>, <a title="akka.stream.scaladsl.FlexiMerge[Out]" id="akka.stream.scaladsl.FlexiMerge;InputPort.parent">parent</a>: <a href="#akka.stream.scaladsl;FlexiMerge" title="akka.stream.scaladsl.FlexiMerge[Out]">FlexiMerge</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>
    extends <a href="FlowGraph.scala.html#akka.stream.scaladsl;JunctionInPort" title="akka.stream.scaladsl.JunctionInPort[In]">JunctionInPort</a><span class="delimiter">[</span>In<span class="delimiter">]</span> with <a href="#akka.stream.scaladsl.FlexiMerge;InputHandle" title="akka.stream.scaladsl.FlexiMerge.InputHandle">InputHandle</a> <span class="delimiter">{</span>
    type <a title="Out" id="akka.stream.scaladsl.FlexiMerge;InputPort;NextT">NextT</a> = <a href="#akka.stream.scaladsl.FlexiMerge;InputPort;Out" title="Out">Out</a>
    override private<span class="delimiter">[</span>akka<span class="delimiter">]</span> def <a title="=&gt; akka.stream.scaladsl.JunctionOutPort[Out]" id="akka.stream.scaladsl.FlexiMerge;InputPort.next">next</a> = <a href="#akka.stream.scaladsl.FlexiMerge;InputPort.parent" title="akka.stream.scaladsl.FlexiMerge[Out]">parent</a>.<a href="#akka.stream.scaladsl;FlexiMerge.out" title="=&gt; akka.stream.scaladsl.JunctionOutPort[Out]">out</a>
    override private<span class="delimiter">[</span>akka<span class="delimiter">]</span> def <a title="=&gt; akka.stream.scaladsl.FlowGraphInternal.InternalVertex" id="akka.stream.scaladsl.FlexiMerge;InputPort.vertex">vertex</a> = <a href="#akka.stream.scaladsl.FlexiMerge;InputPort.parent" title="akka.stream.scaladsl.FlexiMerge[Out]">parent</a>.<a href="#akka.stream.scaladsl;FlexiMerge.vertex" title="=&gt; akka.stream.scaladsl.FlowGraphInternal.InternalVertex">vertex</a>

    override private<span class="delimiter">[</span>akka<span class="delimiter">]</span> def <a title="=&gt; Int" id="akka.stream.scaladsl.FlexiMerge;InputPort.portIndex">portIndex</a>: <span title="Int">Int</span> = <a href="#akka.stream.scaladsl.FlexiMerge;InputPort.port" title="=&gt; Int">port</a>

    override def <a title="()String" id="akka.stream.scaladsl.FlexiMerge;InputPort.toString">toString</a>: <span title="String">String</span> = <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;InputPort(&quot;)">InputPort($</span><a href="#akka.stream.scaladsl.FlexiMerge;InputPort.port" title="=&gt; Int">port</a><span title="String(&quot;)&quot;)" class="string">)&quot;</span>
  <span class="delimiter">}</span>

  sealed trait <a title="trait ReadCondition extends AnyRef" id="akka.stream.scaladsl.FlexiMerge;ReadCondition">ReadCondition</a>
  <span class="comment">/**
   * Read condition for the [[MergeLogic#State]] that will be
   * fulfilled when there are elements for one specific upstream
   * input.
   *
   * It is not allowed to use a handle that has been cancelled or
   * has been completed. `IllegalArgumentException` is thrown if
   * that is not obeyed.
   */</span>
  final case class <a title="class Read extends AnyRef with akka.stream.scaladsl.FlexiMerge.ReadCondition with Product with Serializable" id="akka.stream.scaladsl.FlexiMerge.Read.readResolve">Read</a><span title="Product" class="delimiter">(</span><a title="akka.stream.scaladsl.FlexiMerge.InputHandle" id="akka.stream.scaladsl.FlexiMerge;Read.input">input</a>: <a href="#akka.stream.scaladsl.FlexiMerge;InputHandle" title="akka.stream.scaladsl.FlexiMerge.InputHandle">InputHandle</a><span class="delimiter">)</span> extends <a href="#akka.stream.scaladsl.FlexiMerge;ReadCondition" title="akka.stream.scaladsl.FlexiMerge.ReadCondition">ReadCondition</a>

  object <a title="akka.stream.scaladsl.FlexiMerge.ReadAny.type" id="akka.stream.scaladsl.FlexiMerge.ReadAny.readResolve">ReadAny</a> <a href="#akka.stream.scaladsl.FlexiMerge.ReadAny.readResolve" title="akka.stream.scaladsl.FlexiMerge.ReadAny.type" class="delimiter">{</a>
    def <a title="(inputs: scala.collection.immutable.Seq[akka.stream.scaladsl.FlexiMerge.InputHandle])akka.stream.scaladsl.FlexiMerge.ReadAny" id="akka.stream.scaladsl.FlexiMerge.ReadAny.apply(fc2cf6f21d)">apply</a><span class="delimiter">(</span><a title="scala.collection.immutable.Seq[akka.stream.scaladsl.FlexiMerge.InputHandle]" id="akka.stream.scaladsl.FlexiMerge.ReadAny.apply(fc2cf6f21d).inputs">inputs</a>: immutable.<span title="scala.collection.immutable.Seq[akka.stream.scaladsl.FlexiMerge.InputHandle]">Seq</span><span class="delimiter">[</span>InputHandle<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl.FlexiMerge;ReadAny.equals" title="akka.stream.scaladsl.FlexiMerge.ReadAny">ReadAny</a> = new <a href="#akka.stream.scaladsl.FlexiMerge;ReadAny.equals" title="akka.stream.scaladsl.FlexiMerge.ReadAny">ReadAny</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlexiMerge.ReadAny.apply(fc2cf6f21d).inputs" title="scala.collection.immutable.Seq[akka.stream.scaladsl.FlexiMerge.InputHandle]">inputs</a>: _*<span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * Read condition for the [[MergeLogic#State]] that will be
   * fulfilled when there are elements for any of the given upstream
   * inputs.
   *
   * Cancelled and completed inputs are not used, i.e. it is allowed
   * to specify them in the list of `inputs`.
   */</span>
  final case class <a title="(inputs: akka.stream.scaladsl.FlexiMerge.InputHandle*)akka.stream.scaladsl.FlexiMerge.ReadAny" id="akka.stream.scaladsl.FlexiMerge;ReadAny.equals">ReadAny</a><span title="Product" class="delimiter">(</span><a title="akka.stream.scaladsl.FlexiMerge.InputHandle*" id="akka.stream.scaladsl.FlexiMerge;ReadAny.inputs">inputs</a>: <span title="akka.stream.scaladsl.FlexiMerge.InputHandle*">InputHandle</span>*<span class="delimiter">)</span> extends <a href="#akka.stream.scaladsl.FlexiMerge;ReadCondition" title="akka.stream.scaladsl.FlexiMerge.ReadCondition">ReadCondition</a>

  object <a title="akka.stream.scaladsl.FlexiMerge.ReadPreferred.type" id="akka.stream.scaladsl.FlexiMerge.ReadPreferred.readResolve">ReadPreferred</a> <a href="#akka.stream.scaladsl.FlexiMerge.ReadPreferred.readResolve" title="akka.stream.scaladsl.FlexiMerge.ReadPreferred.type" class="delimiter">{</a>
    def <a title="(preferred: akka.stream.scaladsl.FlexiMerge.InputHandle)(secondaries: akka.stream.scaladsl.FlexiMerge.InputHandle*)akka.stream.scaladsl.FlexiMerge.ReadPreferred" id="akka.stream.scaladsl.FlexiMerge.ReadPreferred.apply(3ce3d1b631)">apply</a><span class="delimiter">(</span><a title="akka.stream.scaladsl.FlexiMerge.InputHandle" id="akka.stream.scaladsl.FlexiMerge.ReadPreferred.apply(3ce3d1b631).preferred">preferred</a>: <a href="#akka.stream.scaladsl.FlexiMerge;InputHandle" title="akka.stream.scaladsl.FlexiMerge.InputHandle">InputHandle</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="akka.stream.scaladsl.FlexiMerge.InputHandle*" id="akka.stream.scaladsl.FlexiMerge.ReadPreferred.apply(3ce3d1b631).secondaries">secondaries</a>: <span title="akka.stream.scaladsl.FlexiMerge.InputHandle*">InputHandle</span>*<span class="delimiter">)</span>: <a href="#akka.stream.scaladsl.FlexiMerge;ReadPreferred.equals" title="akka.stream.scaladsl.FlexiMerge.ReadPreferred">ReadPreferred</a> =
      new <a href="#akka.stream.scaladsl.FlexiMerge;ReadPreferred.equals" title="akka.stream.scaladsl.FlexiMerge.ReadPreferred">ReadPreferred</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlexiMerge.ReadPreferred.apply(3ce3d1b631).preferred" title="akka.stream.scaladsl.FlexiMerge.InputHandle">preferred</a>, <a href="#akka.stream.scaladsl.FlexiMerge.ReadPreferred.apply(3ce3d1b631).secondaries" title="akka.stream.scaladsl.FlexiMerge.InputHandle*">secondaries</a>.<span title="(implicit evidence$1: scala.reflect.ClassTag[akka.stream.scaladsl.FlexiMerge.InputHandle])Array[akka.stream.scaladsl.FlexiMerge.InputHandle]">toArray</span><span class="delimiter">)</span>

    def <a title="(preferred: akka.stream.scaladsl.FlexiMerge.InputHandle, secondaries: scala.collection.immutable.Seq[akka.stream.scaladsl.FlexiMerge.InputHandle])akka.stream.scaladsl.FlexiMerge.ReadPreferred" id="akka.stream.scaladsl.FlexiMerge.ReadPreferred.apply(0eabfe7053)">apply</a><span class="delimiter">(</span><a title="akka.stream.scaladsl.FlexiMerge.InputHandle" id="akka.stream.scaladsl.FlexiMerge.ReadPreferred.apply(0eabfe7053).preferred">preferred</a>: <a href="#akka.stream.scaladsl.FlexiMerge;InputHandle" title="akka.stream.scaladsl.FlexiMerge.InputHandle">InputHandle</a>, <a title="scala.collection.immutable.Seq[akka.stream.scaladsl.FlexiMerge.InputHandle]" id="akka.stream.scaladsl.FlexiMerge.ReadPreferred.apply(0eabfe7053).secondaries">secondaries</a>: immutable.<span title="scala.collection.immutable.Seq[akka.stream.scaladsl.FlexiMerge.InputHandle]">Seq</span><span class="delimiter">[</span>InputHandle<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl.FlexiMerge;ReadPreferred.equals" title="akka.stream.scaladsl.FlexiMerge.ReadPreferred">ReadPreferred</a> =
      new <a href="#akka.stream.scaladsl.FlexiMerge;ReadPreferred.equals" title="akka.stream.scaladsl.FlexiMerge.ReadPreferred">ReadPreferred</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlexiMerge.ReadPreferred.apply(0eabfe7053).preferred" title="akka.stream.scaladsl.FlexiMerge.InputHandle">preferred</a>, <a href="#akka.stream.scaladsl.FlexiMerge.ReadPreferred.apply(0eabfe7053).secondaries" title="scala.collection.immutable.Seq[akka.stream.scaladsl.FlexiMerge.InputHandle]">secondaries</a>.<span title="(implicit evidence$1: scala.reflect.ClassTag[akka.stream.scaladsl.FlexiMerge.InputHandle])Array[akka.stream.scaladsl.FlexiMerge.InputHandle]">toArray</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * Read condition for the [[MergeLogic#State]] that will be
   * fulfilled when there are elements for any of the given upstream
   * inputs, however it differs from [[ReadAny]] in the case that both
   * the `preferred` and at least one other `secondary` input have demand,
   * the `preferred` input will always be consumed first.
   *
   * Cancelled and completed inputs are not used, i.e. it is allowed
   * to specify them in the list of `inputs`.
   */</span>
  final case class <a title="(preferred: akka.stream.scaladsl.FlexiMerge.InputHandle, secondaries: Array[akka.stream.scaladsl.FlexiMerge.InputHandle])akka.stream.scaladsl.FlexiMerge.ReadPreferred" id="akka.stream.scaladsl.FlexiMerge;ReadPreferred.equals">ReadPreferred</a><span title="Product" class="delimiter">(</span><a title="akka.stream.scaladsl.FlexiMerge.InputHandle" id="akka.stream.scaladsl.FlexiMerge;ReadPreferred.copy$default$1">preferred</a>: <a href="#akka.stream.scaladsl.FlexiMerge;InputHandle" title="akka.stream.scaladsl.FlexiMerge.InputHandle">InputHandle</a>, <a title="Array[akka.stream.scaladsl.FlexiMerge.InputHandle]" id="akka.stream.scaladsl.FlexiMerge;ReadPreferred.copy$default$2">secondaries</a>: <span title="Array[akka.stream.scaladsl.FlexiMerge.InputHandle]">Array</span><span class="delimiter">[</span>InputHandle<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#akka.stream.scaladsl.FlexiMerge;ReadCondition" title="akka.stream.scaladsl.FlexiMerge.ReadCondition">ReadCondition</a>

  object <a title="akka.stream.scaladsl.FlexiMerge.ReadAll.type" id="akka.stream.scaladsl.FlexiMerge.ReadAll.readResolve">ReadAll</a> <a href="#akka.stream.scaladsl.FlexiMerge.ReadAll.readResolve" title="akka.stream.scaladsl.FlexiMerge.ReadAll.type" class="delimiter">{</a>
    def <a title="(inputs: scala.collection.immutable.Seq[akka.stream.scaladsl.FlexiMerge.InputHandle])akka.stream.scaladsl.FlexiMerge.ReadAll" id="akka.stream.scaladsl.FlexiMerge.ReadAll.apply(7c9061574d)">apply</a><span class="delimiter">(</span><a title="scala.collection.immutable.Seq[akka.stream.scaladsl.FlexiMerge.InputHandle]" id="akka.stream.scaladsl.FlexiMerge.ReadAll.apply(7c9061574d).inputs">inputs</a>: immutable.<span title="scala.collection.immutable.Seq[akka.stream.scaladsl.FlexiMerge.InputHandle]">Seq</span><span class="delimiter">[</span>InputHandle<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl.FlexiMerge;ReadAll.equals" title="akka.stream.scaladsl.FlexiMerge.ReadAll">ReadAll</a> = new <a href="#akka.stream.scaladsl.FlexiMerge;ReadAll.equals" title="akka.stream.scaladsl.FlexiMerge.ReadAll">ReadAll</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlexiMerge.ReadAllInputs.readResolve" title="akka.stream.scaladsl.FlexiMerge.ReadAllInputs.type">ReadAllInputs</a>, <a href="#akka.stream.scaladsl.FlexiMerge.ReadAll.apply(7c9061574d).inputs" title="scala.collection.immutable.Seq[akka.stream.scaladsl.FlexiMerge.InputHandle]">inputs</a>: _*<span class="delimiter">)</span>
    def <a title="(inputs: akka.stream.scaladsl.FlexiMerge.InputHandle*)akka.stream.scaladsl.FlexiMerge.ReadAll" id="akka.stream.scaladsl.FlexiMerge.ReadAll.apply(22631d84f0)">apply</a><span class="delimiter">(</span><a title="akka.stream.scaladsl.FlexiMerge.InputHandle*" id="akka.stream.scaladsl.FlexiMerge.ReadAll.apply(22631d84f0).inputs">inputs</a>: <span title="akka.stream.scaladsl.FlexiMerge.InputHandle*">InputHandle</span>*<span class="delimiter">)</span>: <a href="#akka.stream.scaladsl.FlexiMerge;ReadAll.equals" title="akka.stream.scaladsl.FlexiMerge.ReadAll">ReadAll</a> = new <a href="#akka.stream.scaladsl.FlexiMerge;ReadAll.equals" title="akka.stream.scaladsl.FlexiMerge.ReadAll">ReadAll</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlexiMerge.ReadAllInputs.readResolve" title="akka.stream.scaladsl.FlexiMerge.ReadAllInputs.type">ReadAllInputs</a>, <a href="#akka.stream.scaladsl.FlexiMerge.ReadAll.apply(22631d84f0).inputs" title="akka.stream.scaladsl.FlexiMerge.InputHandle*">inputs</a>: _*<span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * Read condition for the [[MergeLogic#State]] that will be
   * fulfilled when there are elements for *all* of the given upstream
   * inputs.
   *
   * The emited element the will be a [[ReadAllInputs]] object, which contains values for all non-cancelled inputs of this FlexiMerge.
   *
   * Cancelled inputs are not used, i.e. it is allowed to specify them in the list of `inputs`,
   * the resulting [[ReadAllInputs]] will then not contain values for this element, which can be
   * handled via supplying a default value instead of the value from the (now cancelled) input.
   */</span>
  final case class <a title="(mkResult: scala.collection.immutable.Map[akka.stream.scaladsl.FlexiMerge.InputHandle,Any] =&gt; akka.stream.scaladsl.FlexiMerge.ReadAllInputsBase, inputs: akka.stream.scaladsl.FlexiMerge.InputHandle*)akka.stream.scaladsl.FlexiMerge.ReadAll" id="akka.stream.scaladsl.FlexiMerge;ReadAll.equals">ReadAll</a><span title="Product" class="delimiter">(</span><a title="scala.collection.immutable.Map[akka.stream.scaladsl.FlexiMerge.InputHandle,Any] =&gt; akka.stream.scaladsl.FlexiMerge.ReadAllInputsBase" id="akka.stream.scaladsl.FlexiMerge;ReadAll.mkResult">mkResult</a>: immutable.Map<span class="delimiter">[</span>InputHandle, Any<span class="delimiter">]</span> ⇒ ReadAllInputsBase, <a title="akka.stream.scaladsl.FlexiMerge.InputHandle*" id="akka.stream.scaladsl.FlexiMerge;ReadAll.inputs">inputs</a>: <span title="akka.stream.scaladsl.FlexiMerge.InputHandle*">InputHandle</span>*<span class="delimiter">)</span> extends <a href="#akka.stream.scaladsl.FlexiMerge;ReadCondition" title="akka.stream.scaladsl.FlexiMerge.ReadCondition">ReadCondition</a>
  <span class="comment">/** INTERNAL API */</span>
  private<span class="delimiter">[</span>stream<span class="delimiter">]</span> trait <a title="trait ReadAllInputsBase extends AnyRef" id="akka.stream.scaladsl.FlexiMerge;ReadAllInputsBase">ReadAllInputsBase</a>
  <span class="comment">/**
   * Provides typesafe accessors to values from inputs supplied to [[ReadAll]].
   */</span>
  final case class <a title="class ReadAllInputs extends AnyRef with akka.stream.scaladsl.FlexiMerge.ReadAllInputsBase with Product with Serializable" id="akka.stream.scaladsl.FlexiMerge.ReadAllInputs.readResolve">ReadAllInputs</a><span title="Product" class="delimiter">(</span><a title="scala.collection.immutable.Map[akka.stream.scaladsl.FlexiMerge.InputHandle,Any]" id="akka.stream.scaladsl.FlexiMerge;ReadAllInputs.map">map</a>: immutable.<span title="scala.collection.immutable.Map[akka.stream.scaladsl.FlexiMerge.InputHandle,Any]">Map</span><span class="delimiter">[</span>InputHandle, Any<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#akka.stream.scaladsl.FlexiMerge;ReadAllInputsBase" title="akka.stream.scaladsl.FlexiMerge.ReadAllInputsBase">ReadAllInputsBase</a> <span class="delimiter">{</span>
    def <a title="[T](input: akka.stream.scaladsl.FlexiMerge.InputPort[T, _])T" id="akka.stream.scaladsl.FlexiMerge;ReadAllInputs.apply">apply</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.FlexiMerge;ReadAllInputs.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.scaladsl.FlexiMerge.InputPort[T, _]" id="akka.stream.scaladsl.FlexiMerge;ReadAllInputs.apply.input">input</a>: <a href="#akka.stream.scaladsl.FlexiMerge;InputPort" title="akka.stream.scaladsl.FlexiMerge.InputPort[T, _]">InputPort</a><span class="delimiter">[</span>T, _<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl.FlexiMerge;ReadAllInputs.apply;T" title="T">T</a> = <a href="#akka.stream.scaladsl.FlexiMerge;ReadAllInputs.map" title="(key: akka.stream.scaladsl.FlexiMerge.InputHandle)Any">map</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlexiMerge;ReadAllInputs.apply.input" title="akka.stream.scaladsl.FlexiMerge.InputPort[T, _]">input</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#akka.stream.scaladsl.FlexiMerge;ReadAllInputs.apply;T" title="T">T</a><span class="delimiter">]</span>
    def <a title="[T](input: akka.stream.scaladsl.FlexiMerge.InputPort[T, _])Option[T]" id="akka.stream.scaladsl.FlexiMerge;ReadAllInputs.get">get</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.FlexiMerge;ReadAllInputs.get;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.scaladsl.FlexiMerge.InputPort[T, _]" id="akka.stream.scaladsl.FlexiMerge;ReadAllInputs.get.input">input</a>: <a href="#akka.stream.scaladsl.FlexiMerge;InputPort" title="akka.stream.scaladsl.FlexiMerge.InputPort[T, _]">InputPort</a><span class="delimiter">[</span>T, _<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#akka.stream.scaladsl.FlexiMerge;ReadAllInputs.map" title="=&gt; scala.collection.immutable.Map[akka.stream.scaladsl.FlexiMerge.InputHandle,Any]">map</a>.<span title="(key: akka.stream.scaladsl.FlexiMerge.InputHandle)Option[Any]">get</span><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlexiMerge;ReadAllInputs.get.input" title="akka.stream.scaladsl.FlexiMerge.InputPort[T, _]">input</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Option[T]" class="delimiter">[</span><span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>
    def <a title="[T, B &gt;: T](input: akka.stream.scaladsl.FlexiMerge.InputPort[T, _], default: =&gt; B)T" id="akka.stream.scaladsl.FlexiMerge;ReadAllInputs.getOrElse">getOrElse</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.FlexiMerge;ReadAllInputs.getOrElse;T">T</a>, <a title=" &gt;: T" id="akka.stream.scaladsl.FlexiMerge;ReadAllInputs.getOrElse;B">B</a> &gt;: T<span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.scaladsl.FlexiMerge.InputPort[T, _]" id="akka.stream.scaladsl.FlexiMerge;ReadAllInputs.getOrElse.input">input</a>: <a href="#akka.stream.scaladsl.FlexiMerge;InputPort" title="akka.stream.scaladsl.FlexiMerge.InputPort[T, _]">InputPort</a><span class="delimiter">[</span>T, _<span class="delimiter">]</span>, <a title="=&gt; B" id="akka.stream.scaladsl.FlexiMerge;ReadAllInputs.getOrElse.default">default</a>: ⇒ B<span class="delimiter">)</span>: <a href="#akka.stream.scaladsl.FlexiMerge;ReadAllInputs.getOrElse;T" title="T">T</a> = <a href="#akka.stream.scaladsl.FlexiMerge;ReadAllInputs.map" title="=&gt; scala.collection.immutable.Map[akka.stream.scaladsl.FlexiMerge.InputHandle,Any]">map</a>.<span title="(key: akka.stream.scaladsl.FlexiMerge.InputHandle, default: =&gt; Any)Any">getOrElse</span><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlexiMerge;ReadAllInputs.getOrElse.input" title="akka.stream.scaladsl.FlexiMerge.InputPort[T, _]">input</a>, <a href="#akka.stream.scaladsl.FlexiMerge;ReadAllInputs.getOrElse.default" title="=&gt; B">default</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="T" class="delimiter">[</span><a href="#akka.stream.scaladsl.FlexiMerge;ReadAllInputs.getOrElse;T" title="T">T</a><span class="delimiter">]</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * The possibly stateful logic that reads from input via the defined [[MergeLogic#State]] and
   * handles completion and error via the defined [[MergeLogic#CompletionHandling]].
   *
   * Concrete instance is supposed to be created by implementing [[FlexiMerge#createMergeLogic]].
   */</span>
  abstract class <a title="class MergeLogic[Out] extends AnyRef" id="akka.stream.scaladsl.FlexiMerge;MergeLogic">MergeLogic</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;Out">Out</a><span class="delimiter">]</span> <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic" title="akka.stream.scaladsl.FlexiMerge.MergeLogic[Out]" class="delimiter">{</a>
    def <a title="(inputCount: Int)scala.collection.immutable.IndexedSeq[akka.stream.scaladsl.FlexiMerge.InputHandle]" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.inputHandles">inputHandles</a><span class="delimiter">(</span><a title="Int" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.inputHandles.inputCount">inputCount</a>: <span title="Int">Int</span><span class="delimiter">)</span>: immutable.<span title="scala.collection.immutable.IndexedSeq[akka.stream.scaladsl.FlexiMerge.InputHandle]">IndexedSeq</span><span class="delimiter">[</span>InputHandle<span class="delimiter">]</span>
    def <a title="=&gt; MergeLogic.this.State[_]" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.initialState">initialState</a>: <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.State.readResolve" title="MergeLogic.this.State[_]">State</a><span class="delimiter">[</span>_<span class="delimiter">]</span>
    def <a title="=&gt; MergeLogic.this.CompletionHandling" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.initialCompletionHandling">initialCompletionHandling</a>: <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.CompletionHandling.readResolve" title="MergeLogic.this.CompletionHandling">CompletionHandling</a> = <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.defaultCompletionHandling" title="=&gt; MergeLogic.this.CompletionHandling">defaultCompletionHandling</a>

    <span class="comment">/**
     * Context that is passed to the functions of [[State]] and [[CompletionHandling]].
     * The context provides means for performing side effects, such as emitting elements
     * downstream.
     */</span>
    trait <a title="trait MergeLogicContext extends AnyRef" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;MergeLogicContext">MergeLogicContext</a> <span class="delimiter">{</span>
      <span class="comment">/**
       * @return `true` if at least one element has been requested by downstream (output).
       */</span>
      def <a title="=&gt; Boolean" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;MergeLogicContext.isDemandAvailable">isDemandAvailable</a>: <span title="Boolean">Boolean</span>

      <span class="comment">/**
       * Emit one element downstream. It is only allowed to `emit` when
       * [[#isDemandAvailable]] is `true`, otherwise `IllegalArgumentException`
       * is thrown.
       */</span>
      def <a title="(elem: Out)Unit" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;MergeLogicContext.emit">emit</a><span class="delimiter">(</span><a title="Out" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;MergeLogicContext.emit.elem">elem</a>: <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic;Out" title="Out">Out</a><span class="delimiter">)</span>: <span title="Unit">Unit</span>

      <span class="comment">/**
       * Complete this stream successfully. Upstream subscriptions will be cancelled.
       */</span>
      def <a title="()Unit" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;MergeLogicContext.complete">complete</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span>

      <span class="comment">/**
       * Complete this stream with failure. Upstream subscriptions will be cancelled.
       */</span>
      def <a title="(cause: Throwable)Unit" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;MergeLogicContext.error">error</a><span class="delimiter">(</span><a title="Throwable" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;MergeLogicContext.error.cause">cause</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span>: <span title="Unit">Unit</span>

      <span class="comment">/**
       * Cancel a specific upstream input stream.
       */</span>
      def <a title="(input: akka.stream.scaladsl.FlexiMerge.InputHandle)Unit" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;MergeLogicContext.cancel">cancel</a><span class="delimiter">(</span><a title="akka.stream.scaladsl.FlexiMerge.InputHandle" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;MergeLogicContext.cancel.input">input</a>: <a href="#akka.stream.scaladsl.FlexiMerge;InputHandle" title="akka.stream.scaladsl.FlexiMerge.InputHandle">InputHandle</a><span class="delimiter">)</span>: <span title="Unit">Unit</span>

      <span class="comment">/**
       * Replace current [[CompletionHandling]].
       */</span>
      def <a title="(completion: MergeLogic.this.CompletionHandling)Unit" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;MergeLogicContext.changeCompletionHandling">changeCompletionHandling</a><span class="delimiter">(</span><a title="MergeLogic.this.CompletionHandling" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;MergeLogicContext.changeCompletionHandling.completion">completion</a>: <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.CompletionHandling.readResolve" title="MergeLogic.this.CompletionHandling">CompletionHandling</a><span class="delimiter">)</span>: <span title="Unit">Unit</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Definition of which inputs to read from and how to act on the read elements.
     * When an element has been read [[#onInput]] is called and then it is ensured
     * that downstream has requested at least one element, i.e. it is allowed to
     * emit at least one element downstream with [[MergeLogicContext#emit]].
     *
     * The `onInput` function is called when an `element` was read from the `input`.
     * The function returns next behavior or [[#SameState]] to keep current behavior.
     */</span>
    sealed case class <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic;State.productElement.x$1" title="class State[In] extends AnyRef with Product with Serializable" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.State.readResolve">State</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;State;In">In</a><span class="delimiter">]</span><a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.State.readResolve" title="Product" class="delimiter">(</a>val <a title="akka.stream.scaladsl.FlexiMerge.ReadCondition" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;State.condition">condition</a>: <a href="#akka.stream.scaladsl.FlexiMerge;ReadCondition" title="akka.stream.scaladsl.FlexiMerge.ReadCondition">ReadCondition</a><span class="delimiter">)</span><span class="delimiter">(</span>
      val <a title="(MergeLogic.this.MergeLogicContext, akka.stream.scaladsl.FlexiMerge.InputHandle, In) =&gt; MergeLogic.this.State[_]" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;State.onInput">onInput</a>: <span class="delimiter">(</span>MergeLogicContext, InputHandle, In<span class="delimiter">)</span> ⇒ State<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>

    <span class="comment">/**
     * Return this from [[State]] `onInput` to use same state for next element.
     */</span>
    def <a title="[In]=&gt; MergeLogic.this.State[In]" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.SameState">SameState</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.SameState;In">In</a><span class="delimiter">]</span>: <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.State.readResolve" title="MergeLogic.this.State[In]">State</a><span class="delimiter">[</span>In<span class="delimiter">]</span> = <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.sameStateInstance" title="=&gt; MergeLogic.this.State[Any]">sameStateInstance</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="MergeLogic.this.State[In]" class="delimiter">[</span><a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.State.readResolve" title="MergeLogic.this.State[In]">State</a><span class="delimiter">[</span>In<span class="delimiter">]</span><span class="delimiter">]</span>

    private val <a title="MergeLogic.this.State[Any]" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.sameStateInstance">sameStateInstance</a> = new <a title="&lt;$anon: MergeLogic.this.State[Any]&gt; extends MergeLogic.this.State[Any]" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.sameStateInstance;$anon">State</a><span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlexiMerge.ReadAny.apply(fc2cf6f21d)" title="(inputs: scala.collection.immutable.Seq[akka.stream.scaladsl.FlexiMerge.InputHandle])akka.stream.scaladsl.FlexiMerge.ReadAny">ReadAny</a><span class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="MergeLogic.this.MergeLogicContext" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.sameStateInstance;$anon.$anonfun.x$1">_</a>, <a title="akka.stream.scaladsl.FlexiMerge.InputHandle" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.sameStateInstance;$anon.$anonfun.x$2">_</a>, <a title="Any" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.sameStateInstance;$anon.$anonfun.x$3">_</a><span class="delimiter">)</span> ⇒
      throw new <span title="UnsupportedOperationException">UnsupportedOperationException</span><span class="delimiter">(</span><span title="String(&quot;SameState.onInput should not be called&quot;)" class="string">&quot;SameState.onInput should not be called&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>

      <span class="comment">// unique instance, don't use case class</span>
      override def <a title="(other: Any)Boolean" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.sameStateInstance;$anon.equals">equals</a><span class="delimiter">(</span><a title="Any" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.sameStateInstance;$anon.equals.other">other</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = super.<span title="(x$1: Any)Boolean">equals</span><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.sameStateInstance;$anon.equals.other" title="Any">other</a><span class="delimiter">)</span>
      override def <a title="()Int" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.sameStateInstance;$anon.hashCode">hashCode</a>: <span title="Int">Int</span> = super.<span title="()Int">hashCode</span>
      override def <a title="()String" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.sameStateInstance;$anon.toString">toString</a>: <span title="String">String</span> = <span title="String(&quot;SameState&quot;)" class="string">&quot;SameState&quot;</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * How to handle completion or error from upstream input.
     *
     * The `onComplete` function is called when an upstream input was completed successfully.
     * It returns next behavior or [[#SameState]] to keep current behavior.
     * A completion can be propagated downstream with [[MergeLogicContext#complete]],
     * or it can be swallowed to continue with remaining inputs.
     *
     * The `onError` function is called when an upstream input was completed with failure.
     * It returns next behavior or [[#SameState]] to keep current behavior.
     * An error can be propagated downstream with [[MergeLogicContext#error]],
     * or it can be swallowed to continue with remaining inputs.
     */</span>
    sealed case class <a title="class CompletionHandling extends AnyRef with Product with Serializable" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.CompletionHandling.readResolve">CompletionHandling</a><a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.CompletionHandling.readResolve" title="Product" class="delimiter">(</a>
      <a title="(MergeLogic.this.MergeLogicContext, akka.stream.scaladsl.FlexiMerge.InputHandle) =&gt; MergeLogic.this.State[_]" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;CompletionHandling.onComplete">onComplete</a>: <span class="delimiter">(</span>MergeLogicContext, InputHandle<span class="delimiter">)</span> ⇒ State<span class="delimiter">[</span>_<span class="delimiter">]</span>,
      <a title="(MergeLogic.this.MergeLogicContext, akka.stream.scaladsl.FlexiMerge.InputHandle, Throwable) =&gt; MergeLogic.this.State[_]" id="akka.stream.scaladsl.FlexiMerge;MergeLogic;CompletionHandling.onError">onError</a>: <span class="delimiter">(</span>MergeLogicContext, InputHandle, Throwable<span class="delimiter">)</span> ⇒ State<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>

    <span class="comment">/**
     * Will continue to operate until a read becomes unsatisfiable, then it completes.
     * Errors are immediately propagated.
     */</span>
    val <a title="MergeLogic.this.CompletionHandling" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.defaultCompletionHandling">defaultCompletionHandling</a>: <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.CompletionHandling.readResolve" title="MergeLogic.this.CompletionHandling">CompletionHandling</a> = <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.CompletionHandling.readResolve" title="(onComplete: (MergeLogic.this.MergeLogicContext, akka.stream.scaladsl.FlexiMerge.InputHandle) =&gt; MergeLogic.this.State[_], onError: (MergeLogic.this.MergeLogicContext, akka.stream.scaladsl.FlexiMerge.InputHandle, Throwable) =&gt; MergeLogic.this.State[_])MergeLogic.this.CompletionHandling">CompletionHandling</a><span class="delimiter">(</span>
      onComplete = <span class="delimiter">(</span><a title="MergeLogic.this.MergeLogicContext" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.defaultCompletionHandling.$anonfun.x$4">_</a>, <a title="akka.stream.scaladsl.FlexiMerge.InputHandle" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.defaultCompletionHandling.$anonfun.x$5">_</a><span class="delimiter">)</span> ⇒ <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.SameState" title="MergeLogic.this.State[Nothing]">SameState</a>,
      onError = <span class="delimiter">(</span><a title="MergeLogic.this.MergeLogicContext" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.defaultCompletionHandling.$anonfun.ctx">ctx</a>, <a title="akka.stream.scaladsl.FlexiMerge.InputHandle" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.defaultCompletionHandling.$anonfun.x$6">_</a>, <a title="Throwable" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.defaultCompletionHandling.$anonfun.cause">cause</a><span class="delimiter">)</span> ⇒ <span class="delimiter">{</span> <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.defaultCompletionHandling.$anonfun.ctx" title="MergeLogic.this.MergeLogicContext">ctx</a>.<a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic;MergeLogicContext.error" title="(cause: Throwable)Unit">error</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.defaultCompletionHandling.$anonfun.cause" title="Throwable">cause</a><span class="delimiter">)</span>; <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.SameState" title="MergeLogic.this.State[Nothing]">SameState</a> <span class="delimiter">}</span><span class="delimiter">)</span>

    <span class="comment">/**
     * Completes as soon as any input completes.
     * Errors are immediately propagated.
     */</span>
    def <a title="=&gt; MergeLogic.this.CompletionHandling" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.eagerClose">eagerClose</a>: <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.CompletionHandling.readResolve" title="MergeLogic.this.CompletionHandling">CompletionHandling</a> = <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.CompletionHandling.readResolve" title="(onComplete: (MergeLogic.this.MergeLogicContext, akka.stream.scaladsl.FlexiMerge.InputHandle) =&gt; MergeLogic.this.State[_], onError: (MergeLogic.this.MergeLogicContext, akka.stream.scaladsl.FlexiMerge.InputHandle, Throwable) =&gt; MergeLogic.this.State[_])MergeLogic.this.CompletionHandling">CompletionHandling</a><span class="delimiter">(</span>
      onComplete = <span class="delimiter">(</span><span title="MergeLogic.this.MergeLogicContext">ctx</span>, <a title="akka.stream.scaladsl.FlexiMerge.InputHandle" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.eagerClose.$anonfun.x$7">_</a><span class="delimiter">)</span> ⇒ <span class="delimiter">{</span> <span title="MergeLogic.this.MergeLogicContext">ctx</span>.<a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic;MergeLogicContext.complete" title="()Unit">complete</a><span class="delimiter">(</span><span class="delimiter">)</span>; <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.SameState" title="MergeLogic.this.State[Nothing]">SameState</a> <span class="delimiter">}</span>,
      onError = <span class="delimiter">(</span><span title="MergeLogic.this.MergeLogicContext">ctx</span>, <a title="akka.stream.scaladsl.FlexiMerge.InputHandle" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.eagerClose.$anonfun.x$8">_</a>, <a title="Throwable" id="akka.stream.scaladsl.FlexiMerge;MergeLogic.eagerClose.$anonfun.cause">cause</a><span class="delimiter">)</span> ⇒ <span class="delimiter">{</span> <span title="MergeLogic.this.MergeLogicContext">ctx</span>.<a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic;MergeLogicContext.error" title="(cause: Throwable)Unit">error</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.eagerClose.$anonfun.cause" title="Throwable">cause</a><span class="delimiter">)</span>; <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic.SameState" title="MergeLogic.this.State[Nothing]">SameState</a> <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

<a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic" title="AnyRef" class="delimiter">}</a>

<span class="comment">/**
 * Base class for implementing custom merge junctions.
 * Such a junction always has one [[#out]] port and one or more input ports.
 * The input ports are to be defined in the concrete subclass and are created with
 * [[#createInputPort]].
 *
 * The concrete subclass must implement [[#createMergeLogic]] to define the [[FlexiMerge#MergeLogic]]
 * that will be used when reading input elements and emitting output elements.
 * The [[FlexiMerge#MergeLogic]] instance may be stateful, but the ``FlexiMerge`` instance
 * must not hold mutable state, since it may be shared across several materialized ``FlowGraph``
 * instances.
 *
 * Note that a `FlexiMerge` with a specific name can only be used at one place (one vertex)
 * in the `FlowGraph`. If the `name` is not specified the `FlexiMerge` instance can only
 * be used at one place (one vertex) in the `FlowGraph`.
 *
 * @param name optional name of the junction in the [[FlowGraph]],
 */</span>
abstract class <a title="class FlexiMerge[Out] extends AnyRef with akka.stream.impl.FlexiMergeImpl.MergeLogicFactory[Out]" id="akka.stream.scaladsl;FlexiMerge">FlexiMerge</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlexiMerge;Out">Out</a><span class="delimiter">]</span><a href="#akka.stream.scaladsl;FlexiMerge" title="akka.stream.scaladsl.FlexiMerge[Out]" class="delimiter">(</a>override val <a title="akka.stream.scaladsl.OperationAttributes" id="akka.stream.scaladsl;FlexiMerge.attributes">attributes</a>: <a href="OperationAttributes.scala.html#akka.stream.scaladsl;OperationAttributes" title="akka.stream.scaladsl.OperationAttributes">OperationAttributes</a><span class="delimiter">)</span> extends <a href="../impl/FlexiMergeImpl.scala.html#akka.stream.impl.FlexiMergeImpl;MergeLogicFactory" title="akka.stream.impl.FlexiMergeImpl.MergeLogicFactory[Out]">MergeLogicFactory</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> <span class="delimiter">{</span>
  import <a href="#akka.stream.scaladsl.FlexiMerge" title="akka.stream.scaladsl.FlexiMerge.type">FlexiMerge</a>._

  def this<span class="delimiter">(</span><a title="String" id="akka.stream.scaladsl;FlexiMerge.<init>(4172a30a24).name">name</a>: <span title="String">String</span><span class="delimiter">)</span> = this<span class="delimiter">(</span><a href="OperationAttributes.scala.html#akka.stream.scaladsl.OperationAttributes" title="akka.stream.scaladsl.OperationAttributes.type">OperationAttributes</a>.<a href="OperationAttributes.scala.html#akka.stream.scaladsl.OperationAttributes.name" title="(name: String)akka.stream.scaladsl.OperationAttributes">name</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlexiMerge.<init>(4172a30a24).name" title="String">name</a><span class="delimiter">)</span><span class="delimiter">)</span>
  def this<span class="delimiter">(</span><span class="delimiter">)</span> = this<span class="delimiter">(</span><a href="OperationAttributes.scala.html#akka.stream.scaladsl.OperationAttributes" title="akka.stream.scaladsl.OperationAttributes.type">OperationAttributes</a>.<a href="OperationAttributes.scala.html#akka.stream.scaladsl.OperationAttributes.none" title="=&gt; akka.stream.scaladsl.OperationAttributes">none</a><span class="delimiter">)</span>

  private var <a title="Int" id="akka.stream.scaladsl;FlexiMerge.inputCount_=">inputCount</a> = <span title="Int(0)" class="int">0</span>

  <span class="comment">// hide the internal vertex things from subclass, and make it possible to create new instance</span>
  private class <a title="class FlexiMergeVertex extends AnyRef with akka.stream.scaladsl.FlowGraphInternal.InternalVertex" id="akka.stream.scaladsl;FlexiMerge;FlexiMergeVertex">FlexiMergeVertex</a><a href="#akka.stream.scaladsl;FlexiMerge;FlexiMergeVertex" title="FlexiMerge.this.FlexiMergeVertex" class="delimiter">(</a>override val <a title="akka.stream.scaladsl.OperationAttributes" id="akka.stream.scaladsl;FlexiMerge;FlexiMergeVertex.attributes">attributes</a>: <a href="OperationAttributes.scala.html#akka.stream.scaladsl;OperationAttributes" title="akka.stream.scaladsl.OperationAttributes">OperationAttributes</a><span class="delimiter">)</span> extends FlowGraphInternal.<a href="FlowGraph.scala.html#akka.stream.scaladsl.FlowGraphInternal;InternalVertex" title="akka.stream.scaladsl.FlowGraphInternal.InternalVertex">InternalVertex</a> <span class="delimiter">{</span>
    override def <a title="=&gt; Int" id="akka.stream.scaladsl;FlexiMerge;FlexiMergeVertex.minimumInputCount">minimumInputCount</a> = <span title="Int(2)" class="int">2</span>
    override def <a title="=&gt; Int" id="akka.stream.scaladsl;FlexiMerge;FlexiMergeVertex.maximumInputCount">maximumInputCount</a> = <a href="#akka.stream.scaladsl;FlexiMerge.inputCount_=" title="=&gt; Int">inputCount</a>
    override def <a title="=&gt; Int" id="akka.stream.scaladsl;FlexiMerge;FlexiMergeVertex.minimumOutputCount">minimumOutputCount</a> = <span title="Int(1)" class="int">1</span>
    override def <a title="=&gt; Int" id="akka.stream.scaladsl;FlexiMerge;FlexiMergeVertex.maximumOutputCount">maximumOutputCount</a> = <span title="Int(1)" class="int">1</span>

    override private<span class="delimiter">[</span>akka<span class="delimiter">]</span> val <a title="akka.stream.impl.Ast.FlexiMergeNode" id="akka.stream.scaladsl;FlexiMerge;FlexiMergeVertex.astNode">astNode</a> = <a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast" title="akka.stream.impl.Ast.type">Ast</a>.<a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;FlexiMergeNode" title="(factory: akka.stream.impl.FlexiMergeImpl.MergeLogicFactory[Any], attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.FlexiMergeNode">FlexiMergeNode</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlexiMerge" title="FlexiMerge.this.type">FlexiMerge</a>.this.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="akka.stream.scaladsl.FlexiMerge[Any]" class="delimiter">[</span><a href="#akka.stream.scaladsl;FlexiMerge" title="akka.stream.scaladsl.FlexiMerge[Any]">FlexiMerge</a><span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">]</span>, <a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast.Defaults.flexiMerge" title="=&gt; akka.stream.scaladsl.OperationAttributes">flexiMerge</a> <a href="OperationAttributes.scala.html#akka.stream.scaladsl;OperationAttributes.and" title="(other: akka.stream.scaladsl.OperationAttributes)akka.stream.scaladsl.OperationAttributes">and</a> <a href="#akka.stream.scaladsl;FlexiMerge;FlexiMergeVertex.attributes" title="=&gt; akka.stream.scaladsl.OperationAttributes">attributes</a><span class="delimiter">)</span>

    final override private<span class="delimiter">[</span>scaladsl<span class="delimiter">]</span> def <a title="()FlexiMerge.this.FlexiMergeVertex" id="akka.stream.scaladsl;FlexiMerge;FlexiMergeVertex.newInstance">newInstance</a><span class="delimiter">(</span><span class="delimiter">)</span> = new <a href="#akka.stream.scaladsl;FlexiMerge;FlexiMergeVertex" title="FlexiMerge.this.FlexiMergeVertex">FlexiMergeVertex</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlexiMerge;FlexiMergeVertex.attributes" title="=&gt; akka.stream.scaladsl.OperationAttributes">attributes</a>.<a href="OperationAttributes.scala.html#akka.stream.scaladsl;OperationAttributes.withoutName" title="=&gt; akka.stream.scaladsl.OperationAttributes">withoutName</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private<span class="delimiter">[</span>scaladsl<span class="delimiter">]</span> val <a title="akka.stream.scaladsl.FlowGraphInternal.InternalVertex" id="akka.stream.scaladsl;FlexiMerge.vertex">vertex</a>: FlowGraphInternal.<a href="FlowGraph.scala.html#akka.stream.scaladsl.FlowGraphInternal;InternalVertex" title="akka.stream.scaladsl.FlowGraphInternal.InternalVertex">InternalVertex</a> = new <a href="#akka.stream.scaladsl;FlexiMerge;FlexiMergeVertex" title="FlexiMerge.this.FlexiMergeVertex">FlexiMergeVertex</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlexiMerge.attributes" title="=&gt; akka.stream.scaladsl.OperationAttributes">attributes</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Output port of the `FlexiMerge` junction. A [[Sink]] can be connected to this output
   * with the [[FlowGraphBuilder]].
   */</span>
  val <a title="akka.stream.scaladsl.JunctionOutPort[Out]" id="akka.stream.scaladsl;FlexiMerge.out">out</a>: <a href="FlowGraph.scala.html#akka.stream.scaladsl;JunctionOutPort" title="akka.stream.scaladsl.JunctionOutPort[Out]">JunctionOutPort</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> = new <a title="&lt;$anon: akka.stream.scaladsl.JunctionOutPort[Out]&gt; extends AnyRef with akka.stream.scaladsl.JunctionOutPort[Out]" id="akka.stream.scaladsl;FlexiMerge.out;$anon">JunctionOutPort</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> <span class="delimiter">{</span>
    override private<span class="delimiter">[</span>akka<span class="delimiter">]</span> def <a title="=&gt; akka.stream.scaladsl.FlowGraphInternal.InternalVertex" id="akka.stream.scaladsl;FlexiMerge.out;$anon.vertex">vertex</a> = <a href="#akka.stream.scaladsl;FlexiMerge" title="FlexiMerge.this.type">FlexiMerge</a>.this.<a href="#akka.stream.scaladsl;FlexiMerge.vertex" title="=&gt; akka.stream.scaladsl.FlowGraphInternal.InternalVertex">vertex</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Concrete subclass is supposed to define one or more input ports and
   * they are created by calling this method. Each [[FlexiMerge.InputPort]] can be
   * connected to a [[Source]] with the [[FlowGraphBuilder]].
   * The `InputPort` is also an [[FlexiMerge.InputHandle]], which is passed as parameter
   * to [[FlexiMerge#MergeLogic#State]] `onInput` when an input element has been read so that you
   * can know exactly from which input the element was read.
   */</span>
  protected final def <a title="[T]()akka.stream.scaladsl.FlexiMerge.InputPort[T,Out]" id="akka.stream.scaladsl;FlexiMerge.createInputPort">createInputPort</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlexiMerge.createInputPort;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl.FlexiMerge;InputPort" title="akka.stream.scaladsl.FlexiMerge.InputPort[T,Out]">InputPort</a><span class="delimiter">[</span>T, Out<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a title="Int" id="akka.stream.scaladsl;FlexiMerge.createInputPort.port">port</a> = <a href="#akka.stream.scaladsl;FlexiMerge.inputCount_=" title="=&gt; Int">inputCount</a>
    <a href="#akka.stream.scaladsl;FlexiMerge.inputCount_=" title="(x$1: Int)Unit">inputCount</a> <span title="(x: Int)Int">+=</span> <span title="Int(1)" class="int">1</span>
    new <a href="#akka.stream.scaladsl.FlexiMerge;InputPort" title="akka.stream.scaladsl.FlexiMerge.InputPort[T,Out]">InputPort</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlexiMerge.createInputPort.port" title="Int">port</a>, parent = this<span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Create the stateful logic that will be used when reading input elements
   * and emitting output elements. Create a new instance every time.
   */</span>
  override def <a title="()akka.stream.scaladsl.FlexiMerge.MergeLogic[Out]" id="akka.stream.scaladsl;FlexiMerge.createMergeLogic">createMergeLogic</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl.FlexiMerge;MergeLogic" title="akka.stream.scaladsl.FlexiMerge.MergeLogic[Out]">MergeLogic</a><span class="delimiter">[</span>Out<span class="delimiter">]</span>

  override def <a title="()String" id="akka.stream.scaladsl;FlexiMerge.toString">toString</a> = <a href="#akka.stream.scaladsl;FlexiMerge.attributes" title="=&gt; akka.stream.scaladsl.OperationAttributes">attributes</a>.<a href="OperationAttributes.scala.html#akka.stream.scaladsl;OperationAttributes.nameLifted" title="=&gt; Option[String]">nameLifted</a> match <span class="delimiter">{</span>
    case Some<span class="delimiter">(</span><a title="String" id="akka.stream.scaladsl;FlexiMerge.toString.n">n</a><span class="delimiter">)</span> ⇒ <a href="#akka.stream.scaladsl;FlexiMerge.toString.n" title="String">n</a>
    case <span title="None.type">None</span>    ⇒ <a href="#akka.stream.scaladsl;FlexiMerge" title="()Class[_]">getClass</a>.<span title="()String">getSimpleName</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;@&quot;)" class="string">&quot;@&quot;</span> <span title="(x$1: Any)String">+</span> <span title="Integer.type">Integer</span>.<span title="(x$1: Int)String">toHexString</span><span class="delimiter">(</span>super.<span title="()Int">hashCode</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
