<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>akka/stream/scaladsl/Flow.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Copyright (C) 2014 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
package akka.stream.scaladsl

import akka.stream.impl.<a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast" title="akka.stream.impl.Ast.type">Ast</a>._
import akka.stream.scaladsl.<a href="OperationAttributes.scala.html#akka.stream.scaladsl.OperationAttributes" title="akka.stream.scaladsl.OperationAttributes.type">OperationAttributes</a>._
import akka.stream.<span class="delimiter">{</span> TimerTransformer, TransformerLike, OverflowStrategy <span class="delimiter">}</span>
import akka.util.<span title="akka.util.Collections.type">Collections</span>.EmptyImmutableSeq
import scala.collection.immutable
import scala.concurrent.duration.<span class="delimiter">{</span> Duration, FiniteDuration <span class="delimiter">}</span>
import scala.concurrent.Future
import scala.<span title="language.type">language</span>.higherKinds
import akka.stream.FlowMaterializer
import akka.stream.FlattenStrategy
import akka.stream.stage._

<span class="comment">/**
 * A `Flow` is a set of stream processing steps that has one open input and one open output.
 */</span>
trait <a title="trait Flow[-In, +Out] extends AnyRef with akka.stream.scaladsl.FlowOps[Out]" id="akka.stream.scaladsl;Flow">Flow</a><span class="delimiter">[</span>-<a title="" id="akka.stream.scaladsl;Flow;In">In</a>, +<a title="" id="akka.stream.scaladsl;Flow;Out">Out</a><span class="delimiter">]</span> extends <a href="#akka.stream.scaladsl;FlowOps" title="akka.stream.scaladsl.FlowOps[Out]">FlowOps</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> <span class="delimiter">{</span>
  override type <a title="[+O] &lt;: akka.stream.scaladsl.Flow[In,O]" id="akka.stream.scaladsl;Flow;Repr">Repr</a><span class="delimiter">[</span>+<a title="" id="akka.stream.scaladsl;Flow;Repr;O">O</a><span class="delimiter">]</span> &lt;: Flow<span class="delimiter">[</span>In, O<span class="delimiter">]</span>

  <span class="comment">/**
   * Transform this [[Flow]] by appending the given processing steps.
   */</span>
  def <a title="[T](flow: akka.stream.scaladsl.Flow[Out,T])akka.stream.scaladsl.Flow[In,T]" id="akka.stream.scaladsl;Flow.via">via</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;Flow.via;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.scaladsl.Flow[Out,T]" id="akka.stream.scaladsl;Flow.via.flow">flow</a>: <a href="#akka.stream.scaladsl;Flow" title="akka.stream.scaladsl.Flow[Out,T]">Flow</a><span class="delimiter">[</span>Out, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;Flow" title="akka.stream.scaladsl.Flow[In,T]">Flow</a><span class="delimiter">[</span>In, T<span class="delimiter">]</span>

  <span class="comment">/**
   * Connect this [[Flow]] to a [[Sink]], concatenating the processing steps of both.
   */</span>
  def <a title="(sink: akka.stream.scaladsl.Sink[Out])akka.stream.scaladsl.Sink[In]" id="akka.stream.scaladsl;Flow.to">to</a><span class="delimiter">(</span><a title="akka.stream.scaladsl.Sink[Out]" id="akka.stream.scaladsl;Flow.to.sink">sink</a>: <a href="Sink.scala.html#akka.stream.scaladsl;Sink" title="akka.stream.scaladsl.Sink[Out]">Sink</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="Sink.scala.html#akka.stream.scaladsl;Sink" title="akka.stream.scaladsl.Sink[In]">Sink</a><span class="delimiter">[</span>In<span class="delimiter">]</span>

  <span class="comment">/**
   * Join this [[Flow]] to another [[Flow]], by cross connecting the inputs and outputs, creating a [[RunnableFlow]]
   */</span>
  def <a title="(flow: akka.stream.scaladsl.Flow[Out,In])akka.stream.scaladsl.RunnableFlow" id="akka.stream.scaladsl;Flow.join">join</a><span class="delimiter">(</span><a title="akka.stream.scaladsl.Flow[Out,In]" id="akka.stream.scaladsl;Flow.join.flow">flow</a>: <a href="#akka.stream.scaladsl;Flow" title="akka.stream.scaladsl.Flow[Out,In]">Flow</a><span class="delimiter">[</span>Out, In<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;RunnableFlow" title="akka.stream.scaladsl.RunnableFlow">RunnableFlow</a>

  <span class="comment">/**
   *
   * Connect the `Source` to this `Flow` and then connect it to the `Sink` and run it. The returned tuple contains
   * the materialized values of the `Source` and `Sink`, e.g. the `Subscriber` of a [[SubscriberSource]] and
   * and `Publisher` of a [[PublisherSink]].
   */</span>
  def <a title="(source: akka.stream.scaladsl.Source[In], sink: akka.stream.scaladsl.Sink[Out])(implicit materializer: akka.stream.FlowMaterializer)(source.MaterializedType, sink.MaterializedType)" id="akka.stream.scaladsl;Flow.runWith">runWith</a><span class="delimiter">(</span><a title="akka.stream.scaladsl.Source[In]" id="akka.stream.scaladsl;Flow.runWith.source">source</a>: <a href="Source.scala.html#akka.stream.scaladsl;Source" title="akka.stream.scaladsl.Source[In]">Source</a><span class="delimiter">[</span>In<span class="delimiter">]</span>, <a title="akka.stream.scaladsl.Sink[Out]" id="akka.stream.scaladsl;Flow.runWith.sink">sink</a>: <a href="Sink.scala.html#akka.stream.scaladsl;Sink" title="akka.stream.scaladsl.Sink[Out]">Sink</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="akka.stream.FlowMaterializer" id="akka.stream.scaladsl;Flow.runWith.materializer">materializer</a>: <a href="../FlowMaterializer.scala.html#akka.stream;FlowMaterializer" title="akka.stream.FlowMaterializer">FlowMaterializer</a><span class="delimiter">)</span>: <span title="(source.MaterializedType, sink.MaterializedType)" class="delimiter">(</span>source.MaterializedType, sink.MaterializedType<span class="delimiter">)</span> = <span class="delimiter">{</span>
    val <a title="akka.stream.scaladsl.MaterializedMap" id="akka.stream.scaladsl;Flow.runWith.m">m</a> = <a href="#akka.stream.scaladsl;Flow.runWith.source" title="akka.stream.scaladsl.Source[In]">source</a>.<a href="Source.scala.html#akka.stream.scaladsl;Source.via" title="(flow: akka.stream.scaladsl.Flow[In,Out])akka.stream.scaladsl.Source[Out]">via</a><span class="delimiter">(</span>this<span class="delimiter">)</span>.<a href="Source.scala.html#akka.stream.scaladsl;Source.to" title="(sink: akka.stream.scaladsl.Sink[Out])akka.stream.scaladsl.RunnableFlow">to</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;Flow.runWith.sink" title="akka.stream.scaladsl.Sink[Out]">sink</a><span class="delimiter">)</span>.<a href="#akka.stream.scaladsl;RunnableFlow.run" title="()(implicit materializer: akka.stream.FlowMaterializer)akka.stream.scaladsl.MaterializedMap">run</a><a href="#akka.stream.scaladsl;Flow.runWith.materializer" title="akka.stream.FlowMaterializer" class="delimiter">(</a><span class="delimiter">)</span>
    <span title="(_1: source.MaterializedType, _2: sink.MaterializedType)(source.MaterializedType, sink.MaterializedType)" class="delimiter">(</span><a href="#akka.stream.scaladsl;Flow.runWith.m" title="akka.stream.scaladsl.MaterializedMap">m</a>.<a href="MaterializedMap.scala.html#akka.stream.scaladsl;MaterializedMap.get" title="(key: akka.stream.scaladsl.Materializable)key.MaterializedType">get</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;Flow.runWith.source" title="akka.stream.scaladsl.Source[In]">source</a><span class="delimiter">)</span>, <a href="#akka.stream.scaladsl;Flow.runWith.m" title="akka.stream.scaladsl.MaterializedMap">m</a>.<a href="MaterializedMap.scala.html#akka.stream.scaladsl;MaterializedMap.get" title="(key: akka.stream.scaladsl.Materializable)key.MaterializedType">get</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;Flow.runWith.sink" title="akka.stream.scaladsl.Sink[Out]">sink</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns a new `Flow` that concatenates a secondary `Source` to this flow so that,
   * the first element emitted by the given (&quot;second&quot;) source is emitted after the last element of this Flow.
   */</span>
  def <a title="(second: akka.stream.scaladsl.Source[In])akka.stream.scaladsl.Flow[In,Out]" id="akka.stream.scaladsl;Flow.concat">concat</a><span class="delimiter">(</span><a title="akka.stream.scaladsl.Source[In]" id="akka.stream.scaladsl;Flow.concat.second">second</a>: <a href="Source.scala.html#akka.stream.scaladsl;Source" title="akka.stream.scaladsl.Source[In]">Source</a><span class="delimiter">[</span>In<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;Flow" title="akka.stream.scaladsl.Flow[In,Out]">Flow</a><span class="delimiter">[</span>In, Out<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#akka.stream.scaladsl.Flow.apply(e16ca30e59)" title="()(block: akka.stream.scaladsl.FlowGraphBuilder =&gt; (akka.stream.scaladsl.UndefinedSource[In], akka.stream.scaladsl.UndefinedSink[Nothing]))akka.stream.scaladsl.Flow[In,Nothing]">Flow</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a title="akka.stream.scaladsl.FlowGraphBuilder" id="akka.stream.scaladsl;Flow.concat.$anonfun.b">b</a> ⇒
      val <a title="akka.stream.scaladsl.Concat[Out]" id="akka.stream.scaladsl;Flow.concat.$anonfun.concatter">concatter</a> = <a href="FlowGraph.scala.html#akka.stream.scaladsl.Concat.apply(a50b0cf5db)" title="[T]=&gt; akka.stream.scaladsl.Concat[T]">Concat</a><span title="akka.stream.scaladsl.Concat[Out]" class="delimiter">[</span><a href="#akka.stream.scaladsl;Flow;Out" title="Out">Out</a><span class="delimiter">]</span>
      val <a title="akka.stream.scaladsl.UndefinedSource[In]" id="akka.stream.scaladsl;Flow.concat.$anonfun.source">source</a> = <a href="FlowGraph.scala.html#akka.stream.scaladsl.UndefinedSource.apply(60f3f0873d)" title="[T]=&gt; akka.stream.scaladsl.UndefinedSource[T]">UndefinedSource</a><span title="akka.stream.scaladsl.UndefinedSource[In]" class="delimiter">[</span><a href="#akka.stream.scaladsl;Flow;In" title="In">In</a><span class="delimiter">]</span>
      val <a title="akka.stream.scaladsl.UndefinedSink[Out]" id="akka.stream.scaladsl;Flow.concat.$anonfun.sink">sink</a> = <a href="FlowGraph.scala.html#akka.stream.scaladsl.UndefinedSink.apply(319cd600db)" title="[T]=&gt; akka.stream.scaladsl.UndefinedSink[T]">UndefinedSink</a><span title="akka.stream.scaladsl.UndefinedSink[Out]" class="delimiter">[</span><a href="#akka.stream.scaladsl;Flow;Out" title="Out">Out</a><span class="delimiter">]</span>

      <a href="#akka.stream.scaladsl;Flow.concat.$anonfun.b" title="akka.stream.scaladsl.FlowGraphBuilder">b</a>.<a href="FlowGraph.scala.html#akka.stream.scaladsl;FlowGraphBuilder.addEdge(c6aa70ecea)" title="(source: akka.stream.scaladsl.UndefinedSource[In], flow: akka.stream.scaladsl.Flow[In,Out], junctionIn: akka.stream.scaladsl.JunctionInPort[Out])b.type">addEdge</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;Flow.concat.$anonfun.source" title="akka.stream.scaladsl.UndefinedSource[In]">source</a>, this, <a href="#akka.stream.scaladsl;Flow.concat.$anonfun.concatter" title="akka.stream.scaladsl.Concat[Out]">concatter</a>.<a href="FlowGraph.scala.html#akka.stream.scaladsl;Concat.first" title="=&gt; akka.stream.scaladsl.Concat.First[Out]">first</a><span class="delimiter">)</span>
        .<a href="FlowGraph.scala.html#akka.stream.scaladsl;FlowGraphBuilder.addEdge(47cf3e8a16)" title="(source: akka.stream.scaladsl.Source[In], flow: akka.stream.scaladsl.Flow[In,Out], junctionIn: akka.stream.scaladsl.JunctionInPort[Out])b.type">addEdge</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;Flow.concat.second" title="akka.stream.scaladsl.Source[In]">second</a>, this, <a href="#akka.stream.scaladsl;Flow.concat.$anonfun.concatter" title="akka.stream.scaladsl.Concat[Out]">concatter</a>.<a href="FlowGraph.scala.html#akka.stream.scaladsl;Concat.second" title="=&gt; akka.stream.scaladsl.Concat.Second[Out]">second</a><span class="delimiter">)</span>
        .<a href="FlowGraph.scala.html#akka.stream.scaladsl;FlowGraphBuilder.addEdge(a75d0545c7)" title="(junctionOut: akka.stream.scaladsl.JunctionOutPort[Out], sink: akka.stream.scaladsl.UndefinedSink[Out])b.type">addEdge</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;Flow.concat.$anonfun.concatter" title="akka.stream.scaladsl.Concat[Out]">concatter</a>.<a href="FlowGraph.scala.html#akka.stream.scaladsl;Concat.out" title="=&gt; akka.stream.scaladsl.Concat.Out[Out]">out</a>, <a href="#akka.stream.scaladsl;Flow.concat.$anonfun.sink" title="akka.stream.scaladsl.UndefinedSink[Out]">sink</a><span class="delimiter">)</span>

      <a href="#akka.stream.scaladsl;Flow.concat.$anonfun.source" title="(self: akka.stream.scaladsl.UndefinedSource[In])ArrowAssoc[akka.stream.scaladsl.UndefinedSource[In]]">source</a> <span title="(y: akka.stream.scaladsl.UndefinedSink[Out])(akka.stream.scaladsl.UndefinedSource[In], akka.stream.scaladsl.UndefinedSink[Out])">→</span> <a href="#akka.stream.scaladsl;Flow.concat.$anonfun.sink" title="akka.stream.scaladsl.UndefinedSink[Out]">sink</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Add a key that will have a value available after materialization.
   * The key can only use other keys if they have been added to the flow
   * before this key.
   */</span>
  def <a title="(key: akka.stream.scaladsl.Key[_])akka.stream.scaladsl.Flow[In,Out]" id="akka.stream.scaladsl;Flow.withKey">withKey</a><span class="delimiter">(</span><a title="akka.stream.scaladsl.Key[_]" id="akka.stream.scaladsl;Flow.withKey.key">key</a>: <a href="MaterializedMap.scala.html#akka.stream.scaladsl;Key" title="akka.stream.scaladsl.Key[_]">Key</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;Flow" title="akka.stream.scaladsl.Flow[In,Out]">Flow</a><span class="delimiter">[</span>In, Out<span class="delimiter">]</span>

  <span class="comment">/**
   * Applies given [[OperationAttributes]] to a given section.
   */</span>
  def <a title="[I &lt;: In, O](attributes: akka.stream.scaladsl.OperationAttributes)(section: akka.stream.scaladsl.Flow[In,Out] =&gt; akka.stream.scaladsl.Flow[I,O])akka.stream.scaladsl.Flow[I,O]" id="akka.stream.scaladsl;Flow.section">section</a><span class="delimiter">[</span><a title=" &lt;: In" id="akka.stream.scaladsl;Flow.section;I">I</a> &lt;: In, <a title="" id="akka.stream.scaladsl;Flow.section;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.scaladsl.OperationAttributes" id="akka.stream.scaladsl;Flow.section.attributes">attributes</a>: <a href="OperationAttributes.scala.html#akka.stream.scaladsl;OperationAttributes" title="akka.stream.scaladsl.OperationAttributes">OperationAttributes</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="akka.stream.scaladsl.Flow[In,Out] =&gt; akka.stream.scaladsl.Flow[I,O]" id="akka.stream.scaladsl;Flow.section.section">section</a>: Flow<span class="delimiter">[</span>In, Out<span class="delimiter">]</span> ⇒ Flow<span class="delimiter">[</span>I, O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;Flow" title="akka.stream.scaladsl.Flow[I,O]">Flow</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl;Flow.section.section" title="(v1: akka.stream.scaladsl.Flow[In,Out])akka.stream.scaladsl.Flow[I,O]">section</a><span class="delimiter">(</span>this.<a href="#akka.stream.scaladsl;FlowOps.withAttributes" title="(attr: akka.stream.scaladsl.OperationAttributes)Flow.this.Repr[Out]">withAttributes</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;Flow.section.attributes" title="akka.stream.scaladsl.OperationAttributes">attributes</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#akka.stream.scaladsl;FlowOps.withAttributes" title="(attr: akka.stream.scaladsl.OperationAttributes)akka.stream.scaladsl.Flow[I,O]#Repr[O]">withAttributes</a><span class="delimiter">(</span><a href="OperationAttributes.scala.html#akka.stream.scaladsl.OperationAttributes" title="akka.stream.scaladsl.OperationAttributes.type">OperationAttributes</a>.<a href="OperationAttributes.scala.html#akka.stream.scaladsl.OperationAttributes.none" title="=&gt; akka.stream.scaladsl.OperationAttributes">none</a><span class="delimiter">)</span>

<span class="delimiter">}</span>

object <a title="akka.stream.scaladsl.Flow.type" id="akka.stream.scaladsl.Flow">Flow</a> <a href="#akka.stream.scaladsl.Flow" title="akka.stream.scaladsl.Flow.type" class="delimiter">{</a>
  <span class="comment">/**
   * Creates an empty `Flow` of type `T`
   */</span>
  def <a title="[T]=&gt; akka.stream.scaladsl.Flow[T,T]" id="akka.stream.scaladsl.Flow.empty">empty</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.Flow.empty;T">T</a><span class="delimiter">]</span>: <a href="#akka.stream.scaladsl;Flow" title="akka.stream.scaladsl.Flow[T,T]">Flow</a><span class="delimiter">[</span>T, T<span class="delimiter">]</span> = <a href="Pipe.scala.html#akka.stream.scaladsl.Pipe" title="akka.stream.scaladsl.Pipe.type">Pipe</a>.<a href="Pipe.scala.html#akka.stream.scaladsl.Pipe.empty" title="[T]=&gt; akka.stream.scaladsl.Pipe[T,T]">empty</a><span title="akka.stream.scaladsl.Pipe[T,T]" class="delimiter">[</span><a href="#akka.stream.scaladsl.Flow.empty;T" title="T">T</a><span class="delimiter">]</span>

  <span class="comment">/**
   * Helper to create `Flow` without a [[Source]] or a [[Sink]].
   * Example usage: `Flow[Int]`
   */</span>
  def <a title="[T]=&gt; akka.stream.scaladsl.Flow[T,T]" id="akka.stream.scaladsl.Flow.apply(25a994e6fb)">apply</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.Flow.apply(25a994e6fb);T">T</a><span class="delimiter">]</span>: <a href="#akka.stream.scaladsl;Flow" title="akka.stream.scaladsl.Flow[T,T]">Flow</a><span class="delimiter">[</span>T, T<span class="delimiter">]</span> = <a href="Pipe.scala.html#akka.stream.scaladsl.Pipe" title="akka.stream.scaladsl.Pipe.type">Pipe</a>.<a href="Pipe.scala.html#akka.stream.scaladsl.Pipe.empty" title="[T]=&gt; akka.stream.scaladsl.Pipe[T,T]">empty</a><span title="akka.stream.scaladsl.Pipe[T,T]" class="delimiter">[</span><a href="#akka.stream.scaladsl.Flow.apply(25a994e6fb);T" title="T">T</a><span class="delimiter">]</span>

  <span class="comment">/**
   * Creates a `Flow` by using an empty [[FlowGraphBuilder]] on a block that expects a [[FlowGraphBuilder]] and
   * returns the `UndefinedSource` and `UndefinedSink`.
   */</span>
  def <a title="[I, O]()(block: akka.stream.scaladsl.FlowGraphBuilder =&gt; (akka.stream.scaladsl.UndefinedSource[I], akka.stream.scaladsl.UndefinedSink[O]))akka.stream.scaladsl.Flow[I,O]" id="akka.stream.scaladsl.Flow.apply(e16ca30e59)">apply</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.Flow.apply(e16ca30e59);I">I</a>, <a title="" id="akka.stream.scaladsl.Flow.apply(e16ca30e59);O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="akka.stream.scaladsl.FlowGraphBuilder =&gt; (akka.stream.scaladsl.UndefinedSource[I], akka.stream.scaladsl.UndefinedSink[O])" id="akka.stream.scaladsl.Flow.apply(e16ca30e59).block">block</a>: FlowGraphBuilder ⇒ <span class="delimiter">(</span>UndefinedSource<span class="delimiter">[</span>I<span class="delimiter">]</span>, UndefinedSink<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;Flow" title="akka.stream.scaladsl.Flow[I,O]">Flow</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl.Flow.createFlowFromBuilder" title="(builder: akka.stream.scaladsl.FlowGraphBuilder, block: akka.stream.scaladsl.FlowGraphBuilder =&gt; (akka.stream.scaladsl.UndefinedSource[I], akka.stream.scaladsl.UndefinedSink[O]))akka.stream.scaladsl.Flow[I,O]">createFlowFromBuilder</a><span class="delimiter">(</span>new <a href="FlowGraph.scala.html#akka.stream.scaladsl;FlowGraphBuilder" title="akka.stream.scaladsl.FlowGraphBuilder">FlowGraphBuilder</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#akka.stream.scaladsl.Flow.apply(e16ca30e59).block" title="akka.stream.scaladsl.FlowGraphBuilder =&gt; (akka.stream.scaladsl.UndefinedSource[I], akka.stream.scaladsl.UndefinedSink[O])">block</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Creates a `Flow` by using a [[FlowGraphBuilder]] from this [[PartialFlowGraph]] on a block that expects
   * a [[FlowGraphBuilder]] and returns the `UndefinedSource` and `UndefinedSink`.
   */</span>
  def <a title="[I, O](graph: akka.stream.scaladsl.PartialFlowGraph)(block: akka.stream.scaladsl.FlowGraphBuilder =&gt; (akka.stream.scaladsl.UndefinedSource[I], akka.stream.scaladsl.UndefinedSink[O]))akka.stream.scaladsl.Flow[I,O]" id="akka.stream.scaladsl.Flow.apply(f4cdb1104f)">apply</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.Flow.apply(f4cdb1104f);I">I</a>, <a title="" id="akka.stream.scaladsl.Flow.apply(f4cdb1104f);O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.scaladsl.PartialFlowGraph" id="akka.stream.scaladsl.Flow.apply(f4cdb1104f).graph">graph</a>: <a href="FlowGraph.scala.html#akka.stream.scaladsl;PartialFlowGraph" title="akka.stream.scaladsl.PartialFlowGraph">PartialFlowGraph</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="akka.stream.scaladsl.FlowGraphBuilder =&gt; (akka.stream.scaladsl.UndefinedSource[I], akka.stream.scaladsl.UndefinedSink[O])" id="akka.stream.scaladsl.Flow.apply(f4cdb1104f).block">block</a>: FlowGraphBuilder ⇒ <span class="delimiter">(</span>UndefinedSource<span class="delimiter">[</span>I<span class="delimiter">]</span>, UndefinedSink<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;Flow" title="akka.stream.scaladsl.Flow[I,O]">Flow</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl.Flow.createFlowFromBuilder" title="(builder: akka.stream.scaladsl.FlowGraphBuilder, block: akka.stream.scaladsl.FlowGraphBuilder =&gt; (akka.stream.scaladsl.UndefinedSource[I], akka.stream.scaladsl.UndefinedSink[O]))akka.stream.scaladsl.Flow[I,O]">createFlowFromBuilder</a><span class="delimiter">(</span>new <a href="FlowGraph.scala.html#akka.stream.scaladsl;FlowGraphBuilder" title="akka.stream.scaladsl.FlowGraphBuilder">FlowGraphBuilder</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.Flow.apply(f4cdb1104f).graph" title="akka.stream.scaladsl.PartialFlowGraph">graph</a><span class="delimiter">)</span>, <a href="#akka.stream.scaladsl.Flow.apply(f4cdb1104f).block" title="akka.stream.scaladsl.FlowGraphBuilder =&gt; (akka.stream.scaladsl.UndefinedSource[I], akka.stream.scaladsl.UndefinedSink[O])">block</a><span class="delimiter">)</span>

  private def <a title="[I, O](builder: akka.stream.scaladsl.FlowGraphBuilder, block: akka.stream.scaladsl.FlowGraphBuilder =&gt; (akka.stream.scaladsl.UndefinedSource[I], akka.stream.scaladsl.UndefinedSink[O]))akka.stream.scaladsl.Flow[I,O]" id="akka.stream.scaladsl.Flow.createFlowFromBuilder">createFlowFromBuilder</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.Flow.createFlowFromBuilder;I">I</a>, <a title="" id="akka.stream.scaladsl.Flow.createFlowFromBuilder;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.scaladsl.FlowGraphBuilder" id="akka.stream.scaladsl.Flow.createFlowFromBuilder.builder">builder</a>: <a href="FlowGraph.scala.html#akka.stream.scaladsl;FlowGraphBuilder" title="akka.stream.scaladsl.FlowGraphBuilder">FlowGraphBuilder</a>,
                                          <a title="akka.stream.scaladsl.FlowGraphBuilder =&gt; (akka.stream.scaladsl.UndefinedSource[I], akka.stream.scaladsl.UndefinedSink[O])" id="akka.stream.scaladsl.Flow.createFlowFromBuilder.block">block</a>: FlowGraphBuilder ⇒ <span class="delimiter">(</span>UndefinedSource<span class="delimiter">[</span>I<span class="delimiter">]</span>, UndefinedSink<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;Flow" title="akka.stream.scaladsl.Flow[I,O]">Flow</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> = <span class="delimiter">{</span>
    val <a href="#akka.stream.scaladsl.Flow.createFlowFromBuilder.in" title="(akka.stream.scaladsl.UndefinedSource[I], akka.stream.scaladsl.UndefinedSink[O])" class="delimiter">(</a><a href="#akka.stream.scaladsl.Flow.createFlowFromBuilder.x$1" title="akka.stream.scaladsl.UndefinedSource[I]" id="akka.stream.scaladsl.Flow.createFlowFromBuilder.in">in</a>, <a href="#akka.stream.scaladsl.Flow.createFlowFromBuilder.x$1" title="akka.stream.scaladsl.UndefinedSink[O]" id="akka.stream.scaladsl.Flow.createFlowFromBuilder.out">out</a><span class="delimiter">)</span> = <a href="#akka.stream.scaladsl.Flow.createFlowFromBuilder.block" title="(v1: akka.stream.scaladsl.FlowGraphBuilder)(akka.stream.scaladsl.UndefinedSource[I], akka.stream.scaladsl.UndefinedSink[O])">block</a><span title="(akka.stream.scaladsl.UndefinedSource[I], akka.stream.scaladsl.UndefinedSink[O]) @unchecked" class="delimiter">(</span><a href="#akka.stream.scaladsl.Flow.createFlowFromBuilder.builder" title="akka.stream.scaladsl.FlowGraphBuilder">builder</a><span class="delimiter">)</span>
    <a href="#akka.stream.scaladsl.Flow.createFlowFromBuilder.builder" title="akka.stream.scaladsl.FlowGraphBuilder">builder</a>.<a href="FlowGraph.scala.html#akka.stream.scaladsl;FlowGraphBuilder.partialBuild" title="()akka.stream.scaladsl.PartialFlowGraph">partialBuild</a><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="FlowGraph.scala.html#akka.stream.scaladsl;PartialFlowGraph.toFlow" title="(in: akka.stream.scaladsl.UndefinedSource[I], out: akka.stream.scaladsl.UndefinedSink[O])akka.stream.scaladsl.Flow[I,O]">toFlow</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.Flow.createFlowFromBuilder.in" title="akka.stream.scaladsl.UndefinedSource[I]">in</a>, <a href="#akka.stream.scaladsl.Flow.createFlowFromBuilder.out" title="akka.stream.scaladsl.UndefinedSink[O]">out</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Create a [[Flow]] from a seemingly disconnected [[Source]] and [[Sink]] pair.
   */</span>
  def <a title="[I, O](sink: akka.stream.scaladsl.Sink[I], source: akka.stream.scaladsl.Source[O])akka.stream.scaladsl.Flow[I,O]" id="akka.stream.scaladsl.Flow.apply(e736a5a5c3)">apply</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.Flow.apply(e736a5a5c3);I">I</a>, <a title="" id="akka.stream.scaladsl.Flow.apply(e736a5a5c3);O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.scaladsl.Sink[I]" id="akka.stream.scaladsl.Flow.apply(e736a5a5c3).sink">sink</a>: <a href="Sink.scala.html#akka.stream.scaladsl;Sink" title="akka.stream.scaladsl.Sink[I]">Sink</a><span class="delimiter">[</span>I<span class="delimiter">]</span>, <a title="akka.stream.scaladsl.Source[O]" id="akka.stream.scaladsl.Flow.apply(e736a5a5c3).source">source</a>: <a href="Source.scala.html#akka.stream.scaladsl;Source" title="akka.stream.scaladsl.Source[O]">Source</a><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;Flow" title="akka.stream.scaladsl.Flow[I,O]">Flow</a><span class="delimiter">[</span>I, O<span class="delimiter">]</span> = <a href="GraphFlow.scala.html#akka.stream.scaladsl.GraphFlow.apply(66cd87324d)" title="(sink: akka.stream.scaladsl.Sink[I], source: akka.stream.scaladsl.Source[O])akka.stream.scaladsl.Flow[I,Nothing]">GraphFlow</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.Flow.apply(e736a5a5c3).sink" title="akka.stream.scaladsl.Sink[I]">sink</a>, <a href="#akka.stream.scaladsl.Flow.apply(e736a5a5c3).source" title="akka.stream.scaladsl.Source[O]">source</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Flow with attached input and output, can be executed.
 */</span>
trait <a title="trait RunnableFlow extends AnyRef" id="akka.stream.scaladsl;RunnableFlow">RunnableFlow</a> <span title="Unit" class="delimiter">{</span>
  <span class="comment">/**
   * Run this flow and return the [[MaterializedMap]] containing the values for the [[KeyedMaterializable]] of the flow.
   */</span>
  def <a title="()(implicit materializer: akka.stream.FlowMaterializer)akka.stream.scaladsl.MaterializedMap" id="akka.stream.scaladsl;RunnableFlow.run">run</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="akka.stream.FlowMaterializer" id="akka.stream.scaladsl;RunnableFlow.run.materializer">materializer</a>: <a href="../FlowMaterializer.scala.html#akka.stream;FlowMaterializer" title="akka.stream.FlowMaterializer">FlowMaterializer</a><span class="delimiter">)</span>: <a href="MaterializedMap.scala.html#akka.stream.scaladsl;MaterializedMap" title="akka.stream.scaladsl.MaterializedMap">MaterializedMap</a>

  <span class="comment">/**
   * Run this flow and return the value of the [[KeyedMaterializable]].
   */</span>
  def <a title="(key: akka.stream.scaladsl.KeyedMaterializable[_])(implicit materializer: akka.stream.FlowMaterializer)key.MaterializedType" id="akka.stream.scaladsl;RunnableFlow.runWith">runWith</a><span class="delimiter">(</span><a title="akka.stream.scaladsl.KeyedMaterializable[_]" id="akka.stream.scaladsl;RunnableFlow.runWith.key">key</a>: <a href="MaterializedMap.scala.html#akka.stream.scaladsl;KeyedMaterializable" title="akka.stream.scaladsl.KeyedMaterializable[_]">KeyedMaterializable</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="akka.stream.FlowMaterializer" id="akka.stream.scaladsl;RunnableFlow.runWith.materializer">materializer</a>: <a href="../FlowMaterializer.scala.html#akka.stream;FlowMaterializer" title="akka.stream.FlowMaterializer">FlowMaterializer</a><span class="delimiter">)</span>: key.<a href="#akka.stream.scaladsl;RunnableFlow.runWith.key;_$2" title="key.MaterializedType">MaterializedType</a> =
    this.<a href="#akka.stream.scaladsl;RunnableFlow.run" title="()(implicit materializer: akka.stream.FlowMaterializer)akka.stream.scaladsl.MaterializedMap">run</a><a href="#akka.stream.scaladsl;RunnableFlow.runWith.materializer" title="akka.stream.FlowMaterializer" class="delimiter">(</a><span class="delimiter">)</span>.<a href="MaterializedMap.scala.html#akka.stream.scaladsl;MaterializedMap.get" title="(key: akka.stream.scaladsl.Materializable)key.MaterializedType">get</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;RunnableFlow.runWith.key" title="akka.stream.scaladsl.KeyedMaterializable[_]">key</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Scala API: Operations offered by Sources and Flows with a free output side: the DSL flows left-to-right only.
 */</span>
trait <a title="trait FlowOps[+Out] extends AnyRef" id="akka.stream.scaladsl;FlowOps">FlowOps</a><span class="delimiter">[</span>+<a title="" id="akka.stream.scaladsl;FlowOps;Out">Out</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>
  import <a href="#akka.stream.scaladsl.FlowOps" title="akka.stream.scaladsl.FlowOps.type">FlowOps</a>._
  type <a title="[+O] &lt;: akka.stream.scaladsl.FlowOps[O]" id="akka.stream.scaladsl;FlowOps;Repr">Repr</a><span class="delimiter">[</span>+<a title="" id="akka.stream.scaladsl;FlowOps;Repr;O">O</a><span class="delimiter">]</span> &lt;: FlowOps<span class="delimiter">[</span>O<span class="delimiter">]</span>

  <span class="comment">/**
   * Transform this stream by applying the given function to each of the elements
   * as they pass through this processing step.
   */</span>
  def <a title="[T](f: Out =&gt; T)FlowOps.this.Repr[T]" id="akka.stream.scaladsl;FlowOps.map">map</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlowOps.map;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Out =&gt; T" id="akka.stream.scaladsl;FlowOps.map.f">f</a>: Out ⇒ T<span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[T]">Repr</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;Map" title="(f: Any =&gt; Any, attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.Map">Map</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.map.f" title="Out =&gt; T">f</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Any =&gt; Any" class="delimiter">[</span>Any ⇒ Any<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Transform each input element into a sequence of output elements that is
   * then flattened into the output stream.
   */</span>
  def <a title="[T](f: Out =&gt; scala.collection.immutable.Seq[T])FlowOps.this.Repr[T]" id="akka.stream.scaladsl;FlowOps.mapConcat">mapConcat</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlowOps.mapConcat;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Out =&gt; scala.collection.immutable.Seq[T]" id="akka.stream.scaladsl;FlowOps.mapConcat.f">f</a>: Out ⇒ immutable.Seq<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[T]">Repr</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;MapConcat" title="(f: Any =&gt; scala.collection.immutable.Seq[Any], attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.MapConcat">MapConcat</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.mapConcat.f" title="Out =&gt; scala.collection.immutable.Seq[T]">f</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Any =&gt; scala.collection.immutable.Seq[Any]" class="delimiter">[</span>Any ⇒ immutable.Seq<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Transform this stream by applying the given function to each of the elements
   * as they pass through this processing step. The function returns a `Future` of the
   * element that will be emitted downstream. As many futures as requested elements by
   * downstream may run in parallel and may complete in any order, but the elements that
   * are emitted downstream are in the same order as from upstream.
   *
   * @see [[#mapAsyncUnordered]]
   */</span>
  def <a title="[T](f: Out =&gt; scala.concurrent.Future[T])FlowOps.this.Repr[T]" id="akka.stream.scaladsl;FlowOps.mapAsync">mapAsync</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlowOps.mapAsync;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Out =&gt; scala.concurrent.Future[T]" id="akka.stream.scaladsl;FlowOps.mapAsync.f">f</a>: Out ⇒ Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[T]">Repr</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;MapAsync" title="(f: Any =&gt; scala.concurrent.Future[Any], attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.MapAsync">MapAsync</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.mapAsync.f" title="Out =&gt; scala.concurrent.Future[T]">f</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Any =&gt; scala.concurrent.Future[Any]" class="delimiter">[</span>Any ⇒ Future<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Transform this stream by applying the given function to each of the elements
   * as they pass through this processing step. The function returns a `Future` of the
   * element that will be emitted downstream. As many futures as requested elements by
   * downstream may run in parallel and each processed element will be emitted dowstream
   * as soon as it is ready, i.e. it is possible that the elements are not emitted downstream
   * in the same order as from upstream.
   *
   * @see [[#mapAsync]]
   */</span>
  def <a title="[T](f: Out =&gt; scala.concurrent.Future[T])FlowOps.this.Repr[T]" id="akka.stream.scaladsl;FlowOps.mapAsyncUnordered">mapAsyncUnordered</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlowOps.mapAsyncUnordered;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Out =&gt; scala.concurrent.Future[T]" id="akka.stream.scaladsl;FlowOps.mapAsyncUnordered.f">f</a>: Out ⇒ Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[T]">Repr</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;MapAsyncUnordered" title="(f: Any =&gt; scala.concurrent.Future[Any], attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.MapAsyncUnordered">MapAsyncUnordered</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.mapAsyncUnordered.f" title="Out =&gt; scala.concurrent.Future[T]">f</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Any =&gt; scala.concurrent.Future[Any]" class="delimiter">[</span>Any ⇒ Future<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Only pass on those elements that satisfy the given predicate.
   */</span>
  def <a title="(p: Out =&gt; Boolean)FlowOps.this.Repr[Out]" id="akka.stream.scaladsl;FlowOps.filter">filter</a><span class="delimiter">(</span><a title="Out =&gt; Boolean" id="akka.stream.scaladsl;FlowOps.filter.p">p</a>: Out ⇒ Boolean<span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[Out]">Repr</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> = <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;Filter" title="(p: Any =&gt; Boolean, attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.Filter">Filter</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.filter.p" title="Out =&gt; Boolean">p</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Any =&gt; Boolean" class="delimiter">[</span>Any ⇒ Boolean<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Transform this stream by applying the given partial function to each of the elements
   * on which the function is defined as they pass through this processing step.
   * Non-matching elements are filtered out.
   */</span>
  def <a title="[T](pf: PartialFunction[Out,T])FlowOps.this.Repr[T]" id="akka.stream.scaladsl;FlowOps.collect">collect</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlowOps.collect;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[Out,T]" id="akka.stream.scaladsl;FlowOps.collect.pf">pf</a>: <span title="PartialFunction[Out,T]">PartialFunction</span><span class="delimiter">[</span>Out, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[T]">Repr</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;Collect" title="(pf: PartialFunction[Any,Any], attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.Collect">Collect</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.collect.pf" title="PartialFunction[Out,T]">pf</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PartialFunction[Any,Any]" class="delimiter">[</span><span title="PartialFunction[Any,Any]">PartialFunction</span><span class="delimiter">[</span>Any, Any<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Chunk up this stream into groups of the given size, with the last group
   * possibly smaller than requested due to end-of-stream.
   *
   * `n` must be positive, otherwise IllegalArgumentException is thrown.
   */</span>
  def <a title="(n: Int)FlowOps.this.Repr[scala.collection.immutable.Seq[Out]]" id="akka.stream.scaladsl;FlowOps.grouped">grouped</a><span class="delimiter">(</span><a title="Int" id="akka.stream.scaladsl;FlowOps.grouped.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[scala.collection.immutable.Seq[Out]]">Repr</a><span class="delimiter">[</span>immutable.Seq<span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;Grouped" title="(n: Int, attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.Grouped">Grouped</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.grouped.n" title="Int">n</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Similar to `fold` but is not a terminal operation,
   * emits its current value which starts at `zero` and then
   * applies the current and next value to the given function `f`,
   * emitting the next current value.
   */</span>
  def <a title="[T](zero: T)(f: (T, Out) =&gt; T)FlowOps.this.Repr[T]" id="akka.stream.scaladsl;FlowOps.scan">scan</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlowOps.scan;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="akka.stream.scaladsl;FlowOps.scan.zero">zero</a>: <a href="#akka.stream.scaladsl;FlowOps.scan;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="(T, Out) =&gt; T" id="akka.stream.scaladsl;FlowOps.scan.f">f</a>: <span class="delimiter">(</span>T, Out<span class="delimiter">)</span> ⇒ T<span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[T]">Repr</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;Scan" title="(zero: Any, f: (Any, Any) =&gt; Any, attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.Scan">Scan</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.scan.zero" title="T">zero</a>, <a href="#akka.stream.scaladsl;FlowOps.scan.f" title="(T, Out) =&gt; T">f</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="(Any, Any) =&gt; Any" class="delimiter">[</span><span class="delimiter">(</span>Any, Any<span class="delimiter">)</span> ⇒ Any<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Chunk up this stream into groups of elements received within a time window,
   * or limited by the given number of elements, whatever happens first.
   * Empty groups will not be emitted if no elements are received from upstream.
   * The last group before end-of-stream will contain the buffered elements
   * since the previously emitted group.
   *
   * `n` must be positive, and `d` must be greater than 0 seconds, otherwise
   * IllegalArgumentException is thrown.
   */</span>
  def <a title="(n: Int, d: scala.concurrent.duration.FiniteDuration)FlowOps.this.Repr[Out]#Repr[scala.collection.immutable.Seq[Out]]" id="akka.stream.scaladsl;FlowOps.groupedWithin">groupedWithin</a><span class="delimiter">(</span><a title="Int" id="akka.stream.scaladsl;FlowOps.groupedWithin.n">n</a>: <span title="Int">Int</span>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.stream.scaladsl;FlowOps.groupedWithin.d">d</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span>: Repr<span class="delimiter">[</span>Out<span class="delimiter">]</span>#<a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[Out]#Repr[scala.collection.immutable.Seq[Out]]">Repr</a><span class="delimiter">[</span>immutable.Seq<span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.groupedWithin.n" title="Int">n</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span>, <span title="String(&quot;n must be greater than 0&quot;)" class="string">&quot;n must be greater than 0&quot;</span><span class="delimiter">)</span>
    <span title="(requirement: Boolean)Unit">require</span><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.groupedWithin.d" title="scala.concurrent.duration.FiniteDuration">d</a> <span title="(that: scala.concurrent.duration.Duration)Boolean">&gt;</span> <span title="scala.concurrent.duration.Duration.type">Duration</span>.<span title="=&gt; scala.concurrent.duration.FiniteDuration">Zero</span><span class="delimiter">)</span>
    <a href="#akka.stream.scaladsl;FlowOps.withAttributes" title="(attr: akka.stream.scaladsl.OperationAttributes)FlowOps.this.Repr[Out]">withAttributes</a><span class="delimiter">(</span><a href="OperationAttributes.scala.html#akka.stream.scaladsl.OperationAttributes.name" title="(name: String)akka.stream.scaladsl.OperationAttributes">name</a><span class="delimiter">(</span><span title="String(&quot;groupedWithin&quot;)" class="string">&quot;groupedWithin&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#akka.stream.scaladsl;FlowOps.timerTransform" title="(mkStage: () =&gt; akka.stream.TimerTransformer[Out,scala.collection.immutable.Seq[Out]])FlowOps.this.Repr[Out]#Repr[scala.collection.immutable.Seq[Out]]">timerTransform</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> ⇒ new <a title="&lt;$anon: akka.stream.TimerTransformer[Out,scala.collection.immutable.Seq[Out]]&gt; extends akka.stream.TimerTransformer[Out,scala.collection.immutable.Seq[Out]]" id="akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon">TimerTransformer</a><span class="delimiter">[</span>Out, immutable.Seq<span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
      <a href="../TimerTransformer.scala.html#akka.stream;TimerTransformer.schedulePeriodically" title="(timerKey: Any, interval: scala.concurrent.duration.FiniteDuration)Unit">schedulePeriodically</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlowOps.GroupedWithinTimerKey.readResolve" title="akka.stream.scaladsl.FlowOps.GroupedWithinTimerKey.type">GroupedWithinTimerKey</a>, <a href="#akka.stream.scaladsl;FlowOps.groupedWithin.d" title="scala.concurrent.duration.FiniteDuration">d</a><span class="delimiter">)</span>
      var <a title="Vector[Out]" id="akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.buf_=">buf</a>: <span title="Vector[Out]">Vector</span><span class="delimiter">[</span>Out<span class="delimiter">]</span> = <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span>

      def <a title="(in: Out)scala.collection.immutable.Seq[scala.collection.immutable.Seq[Out]]" id="akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.onNext">onNext</a><span class="delimiter">(</span><a title="Out" id="akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.onNext.in">in</a>: <a href="#akka.stream.scaladsl;FlowOps;Out" title="Out">Out</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <a href="#akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.buf_=" title="(x$1: Vector[Out])Unit">buf</a> <span title="(elem: Out)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[Out],Out,Vector[Out]])Vector[Out]">:+=</span> <a href="#akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.onNext.in" title="Out">in</a>
        if <span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.buf_=" title="=&gt; Vector[Out]">buf</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">==</span> <a href="#akka.stream.scaladsl;FlowOps.groupedWithin.n" title="Int">n</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="comment">// start new time window</span>
          <a href="../TimerTransformer.scala.html#akka.stream;TimerTransformer.schedulePeriodically" title="(timerKey: Any, interval: scala.concurrent.duration.FiniteDuration)Unit">schedulePeriodically</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlowOps.GroupedWithinTimerKey.readResolve" title="akka.stream.scaladsl.FlowOps.GroupedWithinTimerKey.type">GroupedWithinTimerKey</a>, <a href="#akka.stream.scaladsl;FlowOps.groupedWithin.d" title="scala.concurrent.duration.FiniteDuration">d</a><span class="delimiter">)</span>
          <a href="#akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.emitGroup" title="()scala.collection.immutable.Seq[scala.collection.immutable.Seq[Out]]">emitGroup</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <span class="delimiter">}</span> else <span title="scala.collection.immutable.Nil.type">Nil</span>
      <span class="delimiter">}</span>
      override def <a title="(e: Option[Throwable])scala.collection.immutable.Seq[scala.collection.immutable.Seq[Out]]" id="akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.onTermination">onTermination</a><span class="delimiter">(</span><a title="Option[Throwable]" id="akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.onTermination.e">e</a>: <span title="Option[Throwable]">Option</span><span class="delimiter">[</span>Throwable<span class="delimiter">]</span><span class="delimiter">)</span> = if <span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.buf_=" title="=&gt; Vector[Out]">buf</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="scala.collection.immutable.Nil.type">Nil</span> else <span title="(xs: Vector[Out]*)List[Vector[Out]]">List</span><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.buf_=" title="=&gt; Vector[Out]">buf</a><span class="delimiter">)</span>
      def <a title="(timerKey: Any)scala.collection.immutable.Seq[scala.collection.immutable.Seq[Out]]" id="akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.onTimer">onTimer</a><span class="delimiter">(</span><a title="Any" id="akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.onTimer.timerKey">timerKey</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <a href="#akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.emitGroup" title="()scala.collection.immutable.Seq[scala.collection.immutable.Seq[Out]]">emitGroup</a><span class="delimiter">(</span><span class="delimiter">)</span>
      private def <a title="()scala.collection.immutable.Seq[scala.collection.immutable.Seq[Out]]" id="akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.emitGroup">emitGroup</a><span class="delimiter">(</span><span class="delimiter">)</span>: immutable.<span title="scala.collection.immutable.Seq[scala.collection.immutable.Seq[Out]]">Seq</span><span class="delimiter">[</span>immutable.Seq<span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">]</span> =
        if <span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.buf_=" title="=&gt; Vector[Out]">buf</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="akka.util.Collections.EmptyImmutableSeq.type">EmptyImmutableSeq</span>
        else <span class="delimiter">{</span>
          val <a title="Vector[Out]" id="akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.emitGroup.group">group</a> = <a href="#akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.buf_=" title="=&gt; Vector[Out]">buf</a>
          <a href="#akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.buf_=" title="(x$1: Vector[Out])Unit">buf</a> = <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="scala.collection.immutable.Vector[Nothing]">empty</span>
          <span title="(xs: Vector[Out]*)List[Vector[Out]]">List</span><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.groupedWithin.$anonfun;$anon.emitGroup.group" title="Vector[Out]">group</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Discard the given number of elements at the beginning of the stream.
   * No elements will be dropped if `n` is zero or negative.
   */</span>
  def <a title="(n: Int)FlowOps.this.Repr[Out]" id="akka.stream.scaladsl;FlowOps.drop">drop</a><span class="delimiter">(</span><a title="Int" id="akka.stream.scaladsl;FlowOps.drop.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[Out]">Repr</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> = <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;Drop" title="(n: Int, attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.Drop">Drop</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.drop.n" title="Int">n</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Discard the elements received within the given duration at beginning of the stream.
   */</span>
  def <a title="(d: scala.concurrent.duration.FiniteDuration)FlowOps.this.Repr[Out]#Repr[Out]" id="akka.stream.scaladsl;FlowOps.dropWithin">dropWithin</a><span class="delimiter">(</span><a title="scala.concurrent.duration.FiniteDuration" id="akka.stream.scaladsl;FlowOps.dropWithin.d">d</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span>: Repr<span class="delimiter">[</span>Out<span class="delimiter">]</span>#<a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[Out]#Repr[Out]">Repr</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl;FlowOps.withAttributes" title="(attr: akka.stream.scaladsl.OperationAttributes)FlowOps.this.Repr[Out]">withAttributes</a><span class="delimiter">(</span><a href="OperationAttributes.scala.html#akka.stream.scaladsl.OperationAttributes.name" title="(name: String)akka.stream.scaladsl.OperationAttributes">name</a><span class="delimiter">(</span><span title="String(&quot;dropWithin&quot;)" class="string">&quot;dropWithin&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#akka.stream.scaladsl;FlowOps.timerTransform" title="(mkStage: () =&gt; akka.stream.TimerTransformer[Out,Out])FlowOps.this.Repr[Out]#Repr[Out]">timerTransform</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> ⇒ new <a title="&lt;$anon: akka.stream.TimerTransformer[Out,Out]&gt; extends akka.stream.TimerTransformer[Out,Out]" id="akka.stream.scaladsl;FlowOps.dropWithin.$anonfun;$anon">TimerTransformer</a><span class="delimiter">[</span>Out, Out<span class="delimiter">]</span> <span class="delimiter">{</span>
      <a href="../TimerTransformer.scala.html#akka.stream;TimerTransformer.scheduleOnce" title="(timerKey: Any, delay: scala.concurrent.duration.FiniteDuration)Unit">scheduleOnce</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlowOps.DropWithinTimerKey.readResolve" title="akka.stream.scaladsl.FlowOps.DropWithinTimerKey.type">DropWithinTimerKey</a>, <a href="#akka.stream.scaladsl;FlowOps.dropWithin.d" title="scala.concurrent.duration.FiniteDuration">d</a><span class="delimiter">)</span>

      var <a title="akka.stream.TransformerLike[Out,Out]" id="akka.stream.scaladsl;FlowOps.dropWithin.$anonfun;$anon.delegate_=">delegate</a>: <a href="../Transformer.scala.html#akka.stream;TransformerLike" title="akka.stream.TransformerLike[Out,Out]">TransformerLike</a><span class="delimiter">[</span>Out, Out<span class="delimiter">]</span> =
        new <a title="&lt;$anon: akka.stream.TransformerLike[Out,Out]&gt; extends akka.stream.TransformerLike[Out,Out]" id="akka.stream.scaladsl;FlowOps.dropWithin.$anonfun;$anon.delegate;$anon">TransformerLike</a><span class="delimiter">[</span>Out, Out<span class="delimiter">]</span> <span class="delimiter">{</span>
          def <a title="(in: Out)scala.collection.immutable.Nil.type" id="akka.stream.scaladsl;FlowOps.dropWithin.$anonfun;$anon.delegate;$anon.onNext">onNext</a><span class="delimiter">(</span><a title="Out" id="akka.stream.scaladsl;FlowOps.dropWithin.$anonfun;$anon.delegate;$anon.onNext.in">in</a>: <a href="#akka.stream.scaladsl;FlowOps;Out" title="Out">Out</a><span class="delimiter">)</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>
        <span class="delimiter">}</span>

      def <a title="(in: Out)scala.collection.immutable.Seq[Out]" id="akka.stream.scaladsl;FlowOps.dropWithin.$anonfun;$anon.onNext">onNext</a><span class="delimiter">(</span><a title="Out" id="akka.stream.scaladsl;FlowOps.dropWithin.$anonfun;$anon.onNext.in">in</a>: <a href="#akka.stream.scaladsl;FlowOps;Out" title="Out">Out</a><span class="delimiter">)</span> = <a href="#akka.stream.scaladsl;FlowOps.dropWithin.$anonfun;$anon.delegate_=" title="=&gt; akka.stream.TransformerLike[Out,Out]">delegate</a>.<a href="../Transformer.scala.html#akka.stream;TransformerLike.onNext" title="(element: Out)scala.collection.immutable.Seq[Out]">onNext</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.dropWithin.$anonfun;$anon.onNext.in" title="Out">in</a><span class="delimiter">)</span>
      def <a title="(timerKey: Any)scala.collection.immutable.Nil.type" id="akka.stream.scaladsl;FlowOps.dropWithin.$anonfun;$anon.onTimer">onTimer</a><span class="delimiter">(</span><a title="Any" id="akka.stream.scaladsl;FlowOps.dropWithin.$anonfun;$anon.onTimer.timerKey">timerKey</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <a href="#akka.stream.scaladsl;FlowOps.dropWithin.$anonfun;$anon.delegate_=" title="(x$1: akka.stream.TransformerLike[Out,Out])Unit">delegate</a> = <a href="#akka.stream.scaladsl.FlowOps" title="akka.stream.scaladsl.FlowOps.type">FlowOps</a>.<a href="#akka.stream.scaladsl.FlowOps.identityTransformer" title="[T]=&gt; akka.stream.TransformerLike[T,T]">identityTransformer</a><span title="akka.stream.TransformerLike[Out,Out]" class="delimiter">[</span><a href="#akka.stream.scaladsl;FlowOps;Out" title="Out">Out</a><span class="delimiter">]</span>
        <span title="scala.collection.immutable.Nil.type">Nil</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Terminate processing (and cancel the upstream publisher) after the given
   * number of elements. Due to input buffering some elements may have been
   * requested from upstream publishers that will then not be processed downstream
   * of this step.
   *
   * The stream will be completed without producing any elements if `n` is zero
   * or negative.
   */</span>
  def <a title="(n: Int)FlowOps.this.Repr[Out]" id="akka.stream.scaladsl;FlowOps.take">take</a><span class="delimiter">(</span><a title="Int" id="akka.stream.scaladsl;FlowOps.take.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[Out]">Repr</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> = <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;Take" title="(n: Int, attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.Take">Take</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.take.n" title="Int">n</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Terminate processing (and cancel the upstream publisher) after the given
   * duration. Due to input buffering some elements may have been
   * requested from upstream publishers that will then not be processed downstream
   * of this step.
   *
   * Note that this can be combined with [[#take]] to limit the number of elements
   * within the duration.
   */</span>
  def <a title="(d: scala.concurrent.duration.FiniteDuration)FlowOps.this.Repr[Out]#Repr[Out]" id="akka.stream.scaladsl;FlowOps.takeWithin">takeWithin</a><span class="delimiter">(</span><a title="scala.concurrent.duration.FiniteDuration" id="akka.stream.scaladsl;FlowOps.takeWithin.d">d</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span>: Repr<span class="delimiter">[</span>Out<span class="delimiter">]</span>#<a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[Out]#Repr[Out]">Repr</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl;FlowOps.withAttributes" title="(attr: akka.stream.scaladsl.OperationAttributes)FlowOps.this.Repr[Out]">withAttributes</a><span class="delimiter">(</span><a href="OperationAttributes.scala.html#akka.stream.scaladsl.OperationAttributes.name" title="(name: String)akka.stream.scaladsl.OperationAttributes">name</a><span class="delimiter">(</span><span title="String(&quot;takeWithin&quot;)" class="string">&quot;takeWithin&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="#akka.stream.scaladsl;FlowOps.timerTransform" title="(mkStage: () =&gt; akka.stream.TimerTransformer[Out,Out])FlowOps.this.Repr[Out]#Repr[Out]">timerTransform</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> ⇒ new <a title="&lt;$anon: akka.stream.TimerTransformer[Out,Out]&gt; extends akka.stream.TimerTransformer[Out,Out]" id="akka.stream.scaladsl;FlowOps.takeWithin.$anonfun;$anon">TimerTransformer</a><span class="delimiter">[</span>Out, Out<span class="delimiter">]</span> <span class="delimiter">{</span>
      <a href="../TimerTransformer.scala.html#akka.stream;TimerTransformer.scheduleOnce" title="(timerKey: Any, delay: scala.concurrent.duration.FiniteDuration)Unit">scheduleOnce</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlowOps.TakeWithinTimerKey.readResolve" title="akka.stream.scaladsl.FlowOps.TakeWithinTimerKey.type">TakeWithinTimerKey</a>, <a href="#akka.stream.scaladsl;FlowOps.takeWithin.d" title="scala.concurrent.duration.FiniteDuration">d</a><span class="delimiter">)</span>

      var <a title="akka.stream.TransformerLike[Out,Out]" id="akka.stream.scaladsl;FlowOps.takeWithin.$anonfun;$anon.delegate_=">delegate</a>: <a href="../Transformer.scala.html#akka.stream;TransformerLike" title="akka.stream.TransformerLike[Out,Out]">TransformerLike</a><span class="delimiter">[</span>Out, Out<span class="delimiter">]</span> = <a href="#akka.stream.scaladsl.FlowOps" title="akka.stream.scaladsl.FlowOps.type">FlowOps</a>.<a href="#akka.stream.scaladsl.FlowOps.identityTransformer" title="[T]=&gt; akka.stream.TransformerLike[T,T]">identityTransformer</a><span title="akka.stream.TransformerLike[Out,Out]" class="delimiter">[</span><a href="#akka.stream.scaladsl;FlowOps;Out" title="Out">Out</a><span class="delimiter">]</span>

      override def <a title="(in: Out)scala.collection.immutable.Seq[Out]" id="akka.stream.scaladsl;FlowOps.takeWithin.$anonfun;$anon.onNext">onNext</a><span class="delimiter">(</span><a title="Out" id="akka.stream.scaladsl;FlowOps.takeWithin.$anonfun;$anon.onNext.in">in</a>: <a href="#akka.stream.scaladsl;FlowOps;Out" title="Out">Out</a><span class="delimiter">)</span> = <a href="#akka.stream.scaladsl;FlowOps.takeWithin.$anonfun;$anon.delegate_=" title="=&gt; akka.stream.TransformerLike[Out,Out]">delegate</a>.<a href="../Transformer.scala.html#akka.stream;TransformerLike.onNext" title="(element: Out)scala.collection.immutable.Seq[Out]">onNext</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.takeWithin.$anonfun;$anon.onNext.in" title="Out">in</a><span class="delimiter">)</span>
      override def <a title="=&gt; Boolean" id="akka.stream.scaladsl;FlowOps.takeWithin.$anonfun;$anon.isComplete">isComplete</a> = <a href="#akka.stream.scaladsl;FlowOps.takeWithin.$anonfun;$anon.delegate_=" title="=&gt; akka.stream.TransformerLike[Out,Out]">delegate</a>.<a href="../Transformer.scala.html#akka.stream;TransformerLike.isComplete" title="=&gt; Boolean">isComplete</a>
      override def <a title="(timerKey: Any)scala.collection.immutable.Nil.type" id="akka.stream.scaladsl;FlowOps.takeWithin.$anonfun;$anon.onTimer">onTimer</a><span class="delimiter">(</span><a title="Any" id="akka.stream.scaladsl;FlowOps.takeWithin.$anonfun;$anon.onTimer.timerKey">timerKey</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
        <a href="#akka.stream.scaladsl;FlowOps.takeWithin.$anonfun;$anon.delegate_=" title="(x$1: akka.stream.TransformerLike[Out,Out])Unit">delegate</a> = <a href="#akka.stream.scaladsl.FlowOps" title="akka.stream.scaladsl.FlowOps.type">FlowOps</a>.<a href="#akka.stream.scaladsl.FlowOps.completedTransformer" title="[T]=&gt; akka.stream.TransformerLike[T,T]">completedTransformer</a><span title="akka.stream.TransformerLike[Out,Out]" class="delimiter">[</span><a href="#akka.stream.scaladsl;FlowOps;Out" title="Out">Out</a><span class="delimiter">]</span>
        <span title="scala.collection.immutable.Nil.type">Nil</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
   * until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
   * upstream publisher is faster.
   *
   * This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
   * duplicate elements.
   *
   * @param seed Provides the first state for a conflated value using the first unconsumed element as a start
   * @param aggregate Takes the currently aggregated value and the current pending element to produce a new aggregate
   */</span>
  def <a title="[S](seed: Out =&gt; S)(aggregate: (S, Out) =&gt; S)FlowOps.this.Repr[S]" id="akka.stream.scaladsl;FlowOps.conflate">conflate</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlowOps.conflate;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Out =&gt; S" id="akka.stream.scaladsl;FlowOps.conflate.seed">seed</a>: Out ⇒ S<span class="delimiter">)</span><span class="delimiter">(</span><a title="(S, Out) =&gt; S" id="akka.stream.scaladsl;FlowOps.conflate.aggregate">aggregate</a>: <span class="delimiter">(</span>S, Out<span class="delimiter">)</span> ⇒ S<span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[S]">Repr</a><span class="delimiter">[</span>S<span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;Conflate" title="(seed: Any =&gt; Any, aggregate: (Any, Any) =&gt; Any, attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.Conflate">Conflate</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.conflate.seed" title="Out =&gt; S">seed</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Any =&gt; Any" class="delimiter">[</span>Any ⇒ Any<span class="delimiter">]</span>, <a href="#akka.stream.scaladsl;FlowOps.conflate.aggregate" title="(S, Out) =&gt; S">aggregate</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="(Any, Any) =&gt; Any" class="delimiter">[</span><span class="delimiter">(</span>Any, Any<span class="delimiter">)</span> ⇒ Any<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Allows a faster downstream to progress independently of a slower publisher by extrapolating elements from an older
   * element until new element comes from the upstream. For example an expand step might repeat the last element for
   * the subscriber until it receives an update from upstream.
   *
   * This element will never &quot;drop&quot; upstream elements as all elements go through at least one extrapolation step.
   * This means that if the upstream is actually faster than the upstream it will be backpressured by the downstream
   * subscriber.
   *
   * @param seed Provides the first state for extrapolation using the first unconsumed element
   * @param extrapolate Takes the current extrapolation state to produce an output element and the next extrapolation
   *                    state.
   */</span>
  def <a title="[S, U](seed: Out =&gt; S)(extrapolate: S =&gt; (U, S))FlowOps.this.Repr[U]" id="akka.stream.scaladsl;FlowOps.expand">expand</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlowOps.expand;S">S</a>, <a title="" id="akka.stream.scaladsl;FlowOps.expand;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Out =&gt; S" id="akka.stream.scaladsl;FlowOps.expand.seed">seed</a>: Out ⇒ S<span class="delimiter">)</span><span class="delimiter">(</span><a title="S =&gt; (U, S)" id="akka.stream.scaladsl;FlowOps.expand.extrapolate">extrapolate</a>: S ⇒ <span class="delimiter">(</span>U, S<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[U]">Repr</a><span class="delimiter">[</span>U<span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;Expand" title="(seed: Any =&gt; Any, extrapolate: Any =&gt; (Any, Any), attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.Expand">Expand</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.expand.seed" title="Out =&gt; S">seed</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Any =&gt; Any" class="delimiter">[</span>Any ⇒ Any<span class="delimiter">]</span>, <a href="#akka.stream.scaladsl;FlowOps.expand.extrapolate" title="S =&gt; (U, S)">extrapolate</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Any =&gt; (Any, Any)" class="delimiter">[</span>Any ⇒ <span class="delimiter">(</span>Any, Any<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.
   * Depending on the defined [[akka.stream.OverflowStrategy]] it might drop elements or backpressure the upstream if
   * there is no space available
   *
   * @param size The size of the buffer in element count
   * @param overflowStrategy Strategy that is used when incoming elements cannot fit inside the buffer
   */</span>
  def <a title="(size: Int, overflowStrategy: akka.stream.OverflowStrategy)FlowOps.this.Repr[Out]" id="akka.stream.scaladsl;FlowOps.buffer">buffer</a><span class="delimiter">(</span><a title="Int" id="akka.stream.scaladsl;FlowOps.buffer.size">size</a>: <span title="Int">Int</span>, <a title="akka.stream.OverflowStrategy" id="akka.stream.scaladsl;FlowOps.buffer.overflowStrategy">overflowStrategy</a>: <a href="../OverflowStrategy.scala.html#akka.stream;OverflowStrategy" title="akka.stream.OverflowStrategy">OverflowStrategy</a><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[Out]">Repr</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;Buffer" title="(size: Int, overflowStrategy: akka.stream.OverflowStrategy, attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.Buffer">Buffer</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.buffer.size" title="Int">size</a>, <a href="#akka.stream.scaladsl;FlowOps.buffer.overflowStrategy" title="akka.stream.OverflowStrategy">overflowStrategy</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Generic transformation of a stream with a custom processing [[akka.stream.stage.Stage]].
   * This operator makes it possible to extend the `Flow` API when there is no specialized
   * operator that performs the transformation.
   */</span>
  def <a title="[T](mkStage: () =&gt; akka.stream.stage.Stage[Out,T])FlowOps.this.Repr[T]" id="akka.stream.scaladsl;FlowOps.transform">transform</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlowOps.transform;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="() =&gt; akka.stream.stage.Stage[Out,T]" id="akka.stream.scaladsl;FlowOps.transform.mkStage">mkStage</a>: <span class="delimiter">(</span><span class="delimiter">)</span> ⇒ Stage<span class="delimiter">[</span>Out, T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[T]">Repr</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;StageFactory" title="(mkStage: () =&gt; akka.stream.stage.Stage[_, _], attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.StageFactory">StageFactory</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.transform.mkStage" title="() =&gt; akka.stream.stage.Stage[Out,T]">mkStage</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Takes up to `n` elements from the stream and returns a pair containing a strict sequence of the taken element
   * and a stream representing the remaining elements. If ''n'' is zero or negative, then this will return a pair
   * of an empty collection and a stream containing the whole upstream unchanged.
   */</span>
  def <a title="[U &gt;: Out](n: Int)FlowOps.this.Repr[(scala.collection.immutable.Seq[Out], akka.stream.scaladsl.Source[U])]" id="akka.stream.scaladsl;FlowOps.prefixAndTail">prefixAndTail</a><span class="delimiter">[</span><a title=" &gt;: Out" id="akka.stream.scaladsl;FlowOps.prefixAndTail;U">U</a> &gt;: Out<span class="delimiter">]</span><span class="delimiter">(</span><a title="Int" id="akka.stream.scaladsl;FlowOps.prefixAndTail.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[(scala.collection.immutable.Seq[Out], akka.stream.scaladsl.Source[U])]">Repr</a><span class="delimiter">[</span><span class="delimiter">(</span>immutable.Seq<span class="delimiter">[</span>Out<span class="delimiter">]</span>, Source<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;PrefixAndTail" title="(n: Int, attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.PrefixAndTail">PrefixAndTail</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.prefixAndTail.n" title="Int">n</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * This operation demultiplexes the incoming stream into separate output
   * streams, one for each element key. The key is computed for each element
   * using the given function. When a new key is encountered for the first time
   * it is emitted to the downstream subscriber together with a fresh
   * flow that will eventually produce all the elements of the substream
   * for that key. Not consuming the elements from the created streams will
   * stop this processor from processing more elements, therefore you must take
   * care to unblock (or cancel) all of the produced streams even if you want
   * to consume only one of them.
   */</span>
  def <a title="[K, U &gt;: Out](f: Out =&gt; K)FlowOps.this.Repr[(K, akka.stream.scaladsl.Source[U])]" id="akka.stream.scaladsl;FlowOps.groupBy">groupBy</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlowOps.groupBy;K">K</a>, <a title=" &gt;: Out" id="akka.stream.scaladsl;FlowOps.groupBy;U">U</a> &gt;: Out<span class="delimiter">]</span><span class="delimiter">(</span><a title="Out =&gt; K" id="akka.stream.scaladsl;FlowOps.groupBy.f">f</a>: Out ⇒ K<span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[(K, akka.stream.scaladsl.Source[U])]">Repr</a><span class="delimiter">[</span><span class="delimiter">(</span>K, Source<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;GroupBy" title="(f: Any =&gt; Any, attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.GroupBy">GroupBy</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.groupBy.f" title="Out =&gt; K">f</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Any =&gt; Any" class="delimiter">[</span>Any ⇒ Any<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * This operation applies the given predicate to all incoming elements and
   * emits them to a stream of output streams, always beginning a new one with
   * the current element if the given predicate returns true for it. This means
   * that for the following series of predicate values, three substreams will
   * be produced with lengths 1, 2, and 3:
   *
   * {{{
   * false,             // element goes into first substream
   * true, false,       // elements go into second substream
   * true, false, false // elements go into third substream
   * }}}
   */</span>
  def <a title="[U &gt;: Out](p: Out =&gt; Boolean)FlowOps.this.Repr[akka.stream.scaladsl.Source[U]]" id="akka.stream.scaladsl;FlowOps.splitWhen">splitWhen</a><span class="delimiter">[</span><a title=" &gt;: Out" id="akka.stream.scaladsl;FlowOps.splitWhen;U">U</a> &gt;: Out<span class="delimiter">]</span><span class="delimiter">(</span><a title="Out =&gt; Boolean" id="akka.stream.scaladsl;FlowOps.splitWhen.p">p</a>: Out ⇒ Boolean<span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[akka.stream.scaladsl.Source[U]]">Repr</a><span class="delimiter">[</span>Source<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;SplitWhen" title="(p: Any =&gt; Boolean, attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.SplitWhen">SplitWhen</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.splitWhen.p" title="Out =&gt; Boolean">p</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Any =&gt; Boolean" class="delimiter">[</span>Any ⇒ Boolean<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Transforms a stream of streams into a contiguous stream of elements using the provided flattening strategy.
   * This operation can be used on a stream of element type [[akka.stream.scaladsl.Source]].
   */</span>
  def <a title="[U](strategy: akka.stream.FlattenStrategy[Out,U])FlowOps.this.Repr[U]" id="akka.stream.scaladsl;FlowOps.flatten">flatten</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlowOps.flatten;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.FlattenStrategy[Out,U]" id="akka.stream.scaladsl;FlowOps.flatten.strategy">strategy</a>: akka.stream.<a href="../FlattenStrategy.scala.html#akka.stream;FlattenStrategy" title="akka.stream.FlattenStrategy[Out,U]">FlattenStrategy</a><span class="delimiter">[</span>Out, U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[U]">Repr</a><span class="delimiter">[</span>U<span class="delimiter">]</span> = <a href="#akka.stream.scaladsl;FlowOps.flatten.strategy" title="akka.stream.FlattenStrategy[Out,U]">strategy</a> match <span class="delimiter">{</span>
    case _: FlattenStrategy.<a href="../FlattenStrategy.scala.html#akka.stream.FlattenStrategy;Concat" title="akka.stream.FlattenStrategy.Concat[Out]">Concat</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> ⇒ <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;ConcatAll" title="(attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.ConcatAll">ConcatAll</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
    case _ ⇒
      throw new <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Unsupported flattening strategy [&quot;)">Unsupported flattening strategy [$</span><span class="delimiter">{</span><a href="#akka.stream.scaladsl;FlowOps.flatten.strategy" title="akka.stream.FlattenStrategy[Out,U]">strategy</a>.<span title="()Class[_]">getClass</span>.<span title="()String">getName</span><span class="delimiter">}</span><span title="String(&quot;]&quot;)" class="string">]&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * INTERNAL API - meant for removal / rewrite. See https://github.com/akka/akka/issues/16393
   *
   * Transformation of a stream, with additional support for scheduled events.
   *
   * For each element the [[akka.stream.TransformerLike#onNext]]
   * function is invoked, expecting a (possibly empty) sequence of output elements
   * to be produced.
   * After handing off the elements produced from one input element to the downstream
   * subscribers, the [[akka.stream.TransformerLike#isComplete]] predicate determines whether to end
   * stream processing at this point; in that case the upstream subscription is
   * canceled. Before signaling normal completion to the downstream subscribers,
   * the [[akka.stream.TransformerLike#onTermination]] function is invoked to produce a (possibly empty)
   * sequence of elements in response to the end-of-stream event.
   *
   * [[akka.stream.TransformerLike#onError]] is called when failure is signaled from upstream.
   *
   * After normal completion or error the [[akka.stream.TransformerLike#cleanup]] function is called.
   *
   * It is possible to keep state in the concrete [[akka.stream.Transformer]] instance with
   * ordinary instance variables. The [[akka.stream.Transformer]] is executed by an actor and
   * therefore you do not have to add any additional thread safety or memory
   * visibility constructs to access the state from the callback methods.
   *
   * Note that you can use [[#transform]] if you just need to transform elements time plays no role in the transformation.
   */</span>
  private<span class="delimiter">[</span>akka<span class="delimiter">]</span> def <a title="[U](mkStage: () =&gt; akka.stream.TimerTransformer[Out,U])FlowOps.this.Repr[U]" id="akka.stream.scaladsl;FlowOps.timerTransform">timerTransform</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlowOps.timerTransform;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="() =&gt; akka.stream.TimerTransformer[Out,U]" id="akka.stream.scaladsl;FlowOps.timerTransform.mkStage">mkStage</a>: <span class="delimiter">(</span><span class="delimiter">)</span> ⇒ TimerTransformer<span class="delimiter">[</span>Out, U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[U]">Repr</a><span class="delimiter">[</span>U<span class="delimiter">]</span> =
    <a href="#akka.stream.scaladsl;FlowOps.andThen" title="(op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[Nothing]">andThen</a><span class="delimiter">(</span><a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;TimerTransform" title="(mkStage: () =&gt; akka.stream.TimerTransformer[Any,Any], attributes: akka.stream.scaladsl.OperationAttributes)akka.stream.impl.Ast.TimerTransform">TimerTransform</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl;FlowOps.timerTransform.mkStage" title="() =&gt; akka.stream.TimerTransformer[Out,U]">mkStage</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="() =&gt; akka.stream.TimerTransformer[Any,Any]" class="delimiter">[</span><span class="delimiter">(</span><span class="delimiter">)</span> ⇒ TimerTransformer<span class="delimiter">[</span>Any, Any<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/** INTERNAL API */</span>
  private<span class="delimiter">[</span>scaladsl<span class="delimiter">]</span> def <a title="(attr: akka.stream.scaladsl.OperationAttributes)FlowOps.this.Repr[Out]" id="akka.stream.scaladsl;FlowOps.withAttributes">withAttributes</a><span class="delimiter">(</span><a title="akka.stream.scaladsl.OperationAttributes" id="akka.stream.scaladsl;FlowOps.withAttributes.attr">attr</a>: <a href="OperationAttributes.scala.html#akka.stream.scaladsl;OperationAttributes" title="akka.stream.scaladsl.OperationAttributes">OperationAttributes</a><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[Out]">Repr</a><span class="delimiter">[</span>Out<span class="delimiter">]</span>

  <span class="comment">/** INTERNAL API */</span>
  <span class="comment">// Storing ops in reverse order</span>
  private<span class="delimiter">[</span>scaladsl<span class="delimiter">]</span> def <a title="[U](op: akka.stream.impl.Ast.AstNode)FlowOps.this.Repr[U]" id="akka.stream.scaladsl;FlowOps.andThen">andThen</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl;FlowOps.andThen;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.impl.Ast.AstNode" id="akka.stream.scaladsl;FlowOps.andThen.op">op</a>: <a href="../impl/ActorBasedFlowMaterializer.scala.html#akka.stream.impl.Ast;AstNode" title="akka.stream.impl.Ast.AstNode">AstNode</a><span class="delimiter">)</span>: <a href="#akka.stream.scaladsl;FlowOps;Repr" title="FlowOps.this.Repr[U]">Repr</a><span class="delimiter">[</span>U<span class="delimiter">]</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * INTERNAL API
 */</span>
private<span class="delimiter">[</span>stream<span class="delimiter">]</span> object <a title="akka.stream.scaladsl.FlowOps.type" id="akka.stream.scaladsl.FlowOps">FlowOps</a> <a href="#akka.stream.scaladsl.FlowOps" title="akka.stream.scaladsl.FlowOps.type" class="delimiter">{</a>
  private case object <a href="#akka.stream.scaladsl.FlowOps.TakeWithinTimerKey.productElement.x$1" title="akka.stream.scaladsl.FlowOps.TakeWithinTimerKey.type" id="akka.stream.scaladsl.FlowOps.TakeWithinTimerKey.readResolve">TakeWithinTimerKey</a>
  private case object <a href="#akka.stream.scaladsl.FlowOps.DropWithinTimerKey.productElement.x$1" title="akka.stream.scaladsl.FlowOps.DropWithinTimerKey.type" id="akka.stream.scaladsl.FlowOps.DropWithinTimerKey.readResolve">DropWithinTimerKey</a>
  private case object <a href="#akka.stream.scaladsl.FlowOps.GroupedWithinTimerKey.productElement.x$1" title="akka.stream.scaladsl.FlowOps.GroupedWithinTimerKey.type" id="akka.stream.scaladsl.FlowOps.GroupedWithinTimerKey.readResolve">GroupedWithinTimerKey</a>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> final case object <a href="#akka.stream.scaladsl.FlowOps.CompletedTransformer.productElement.x$1" title="akka.stream.scaladsl.FlowOps.CompletedTransformer.type" id="akka.stream.scaladsl.FlowOps.CompletedTransformer.readResolve">CompletedTransformer</a> extends <a href="../Transformer.scala.html#akka.stream;TransformerLike" title="akka.stream.TransformerLike[Any,Any]">TransformerLike</a><span class="delimiter">[</span>Any, Any<span class="delimiter">]</span> <span class="delimiter">{</span>
    override def <a title="(elem: Any)scala.collection.immutable.Nil.type" id="akka.stream.scaladsl.FlowOps.CompletedTransformer.onNext">onNext</a><span class="delimiter">(</span><a title="Any" id="akka.stream.scaladsl.FlowOps.CompletedTransformer.onNext.elem">elem</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>
    override def <a title="=&gt; Boolean" id="akka.stream.scaladsl.FlowOps.CompletedTransformer.isComplete">isComplete</a> = true
  <span class="delimiter">}</span>

  private<span class="delimiter">[</span>this<span class="delimiter">]</span> final case object <a href="#akka.stream.scaladsl.FlowOps.IdentityTransformer.productElement.x$1" title="akka.stream.scaladsl.FlowOps.IdentityTransformer.type" id="akka.stream.scaladsl.FlowOps.IdentityTransformer.readResolve">IdentityTransformer</a> extends <a href="../Transformer.scala.html#akka.stream;TransformerLike" title="akka.stream.TransformerLike[Any,Any]">TransformerLike</a><span class="delimiter">[</span>Any, Any<span class="delimiter">]</span> <span class="delimiter">{</span>
    override def <a title="(elem: Any)List[Any]" id="akka.stream.scaladsl.FlowOps.IdentityTransformer.onNext">onNext</a><span class="delimiter">(</span><a title="Any" id="akka.stream.scaladsl.FlowOps.IdentityTransformer.onNext.elem">elem</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <span title="(xs: Any*)List[Any]">List</span><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlowOps.IdentityTransformer.onNext.elem" title="Any">elem</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  def <a title="[T]=&gt; akka.stream.TransformerLike[T,T]" id="akka.stream.scaladsl.FlowOps.completedTransformer">completedTransformer</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.FlowOps.completedTransformer;T">T</a><span class="delimiter">]</span>: <a href="../Transformer.scala.html#akka.stream;TransformerLike" title="akka.stream.TransformerLike[T,T]">TransformerLike</a><span class="delimiter">[</span>T, T<span class="delimiter">]</span> = <a href="#akka.stream.scaladsl.FlowOps.CompletedTransformer.readResolve" title="akka.stream.scaladsl.FlowOps.CompletedTransformer.type">CompletedTransformer</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="akka.stream.TransformerLike[T,T]" class="delimiter">[</span><a href="../Transformer.scala.html#akka.stream;TransformerLike" title="akka.stream.TransformerLike[T,T]">TransformerLike</a><span class="delimiter">[</span>T, T<span class="delimiter">]</span><span class="delimiter">]</span>
  def <a title="[T]=&gt; akka.stream.TransformerLike[T,T]" id="akka.stream.scaladsl.FlowOps.identityTransformer">identityTransformer</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.FlowOps.identityTransformer;T">T</a><span class="delimiter">]</span>: <a href="../Transformer.scala.html#akka.stream;TransformerLike" title="akka.stream.TransformerLike[T,T]">TransformerLike</a><span class="delimiter">[</span>T, T<span class="delimiter">]</span> = <a href="#akka.stream.scaladsl.FlowOps.IdentityTransformer.readResolve" title="akka.stream.scaladsl.FlowOps.IdentityTransformer.type">IdentityTransformer</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="akka.stream.TransformerLike[T,T]" class="delimiter">[</span><a href="../Transformer.scala.html#akka.stream;TransformerLike" title="akka.stream.TransformerLike[T,T]">TransformerLike</a><span class="delimiter">[</span>T, T<span class="delimiter">]</span><span class="delimiter">]</span>

  def <a title="[T]=&gt; akka.stream.stage.Stage[T,T]" id="akka.stream.scaladsl.FlowOps.identityStage">identityStage</a><span class="delimiter">[</span><a title="" id="akka.stream.scaladsl.FlowOps.identityStage;T">T</a><span class="delimiter">]</span>: <a href="../stage/Stage.scala.html#akka.stream.stage;Stage" title="akka.stream.stage.Stage[T,T]">Stage</a><span class="delimiter">[</span>T, T<span class="delimiter">]</span> = new <a title="&lt;$anon: akka.stream.stage.PushStage[T,T]&gt; extends akka.stream.stage.PushStage[T,T]" id="akka.stream.scaladsl.FlowOps.identityStage;$anon">PushStage</a><span class="delimiter">[</span>T, T<span class="delimiter">]</span> <span class="delimiter">{</span>
    override def <a title="(elem: T, ctx: akka.stream.stage.Context[T])akka.stream.stage.Directive" id="akka.stream.scaladsl.FlowOps.identityStage;$anon.onPush">onPush</a><span class="delimiter">(</span><a title="T" id="akka.stream.scaladsl.FlowOps.identityStage;$anon.onPush.elem">elem</a>: <a href="#akka.stream.scaladsl.FlowOps.identityStage;T" title="T">T</a>, <a title="akka.stream.stage.Context[T]" id="akka.stream.scaladsl.FlowOps.identityStage;$anon.onPush.ctx">ctx</a>: <a href="../stage/Stage.scala.html#akka.stream.stage;Context" title="akka.stream.stage.Context[T]">Context</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../stage/Stage.scala.html#akka.stream.stage;Directive" title="akka.stream.stage.Directive">Directive</a> = <a href="#akka.stream.scaladsl.FlowOps.identityStage;$anon.onPush.ctx" title="akka.stream.stage.Context[T]">ctx</a>.<a href="../stage/Stage.scala.html#akka.stream.stage;Context.push" title="(elem: T)akka.stream.stage.DownstreamDirective">push</a><span class="delimiter">(</span><a href="#akka.stream.scaladsl.FlowOps.identityStage;$anon.onPush.elem" title="T">elem</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
