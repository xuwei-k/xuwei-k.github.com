<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>akka/stream/javadsl/Source.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Copyright (C) 2014 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
package akka.stream.javadsl

import java.util.concurrent.Callable
import akka.actor.ActorRef
import akka.actor.Props
import akka.japi.Util
import akka.stream._
import akka.stream.scaladsl.PropsSource
import org.reactivestreams.Publisher
import org.reactivestreams.Subscriber
import scala.annotation.unchecked.uncheckedVariance
import scala.collection.<span title="scala.collection.JavaConverters.type">JavaConverters</span>._
import scala.concurrent.Future
import scala.concurrent.duration.FiniteDuration
import scala.<span title="language.type">language</span>.higherKinds
import scala.<span title="language.type">language</span>.implicitConversions
import akka.stream.stage.Stage

<span class="comment">/** Java API */</span>
object <a title="akka.stream.javadsl.Source.type" id="akka.stream.javadsl.Source">Source</a> <a href="#akka.stream.javadsl.Source" title="akka.stream.javadsl.Source.type" class="delimiter">{</a>

  import scaladsl.<a href="../scaladsl/JavaConverters.scala.html#akka.stream.scaladsl.JavaConverters" title="akka.stream.scaladsl.JavaConverters.type">JavaConverters</a>._

  <span class="comment">/** Adapt [[scaladsl.Source]] for use within JavaDSL */</span>
  def <a title="[O](source: akka.stream.scaladsl.Source[O])akka.stream.javadsl.Source[O]" id="akka.stream.javadsl.Source.adapt">adapt</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl.Source.adapt;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.scaladsl.Source[O]" id="akka.stream.javadsl.Source.adapt.source">source</a>: scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl;Source" title="akka.stream.scaladsl.Source[O]">Source</a><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">[</span>O<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl.Source.adapt.source" title="akka.stream.scaladsl.Source[O]">source</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Create a `Source` with no elements, i.e. an empty stream that is completed immediately
   * for every connected `Sink`.
   */</span>
  def <a title="[O]()akka.stream.javadsl.Source[O]" id="akka.stream.javadsl.Source.empty">empty</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl.Source.empty;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">[</span>O<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Nothing]">Source</a><span class="delimiter">(</span>scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source" title="akka.stream.scaladsl.Source.type">Source</a>.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source.empty" title="()akka.stream.scaladsl.Source[Nothing]">empty</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Helper to create [[Source]] from `Publisher`.
   *
   * Construct a transformation starting with given publisher. The transformation steps
   * are executed by a series of [[org.reactivestreams.Processor]] instances
   * that mediate the flow of elements downstream and the propagation of
   * back-pressure upstream.
   */</span>
  def <a title="[O](publisher: org.reactivestreams.Publisher[O])akka.stream.javadsl.Source[O]" id="akka.stream.javadsl.Source.from(a6a3ed9751)">from</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl.Source.from(a6a3ed9751);O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="org.reactivestreams.Publisher[O]" id="akka.stream.javadsl.Source.from(a6a3ed9751).publisher">publisher</a>: <span title="org.reactivestreams.Publisher[O]">Publisher</span><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">[</span>O<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">(</span>scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source" title="akka.stream.scaladsl.Source.type">Source</a>.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source.apply(56ffbc7d46)" title="(publisher: org.reactivestreams.Publisher[O])akka.stream.scaladsl.Source[O]">apply</a><span class="delimiter">(</span><a href="#akka.stream.javadsl.Source.from(a6a3ed9751).publisher" title="org.reactivestreams.Publisher[O]">publisher</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Helper to create [[Source]] from `Iterator`.
   * Example usage:
   *
   * {{{
   * List&lt;Integer&gt; data = new ArrayList&lt;Integer&gt;();
   * data.add(1);
   * data.add(2);
   * data.add(3);
   * Source.from(data.iterator());
   * }}}
   *
   * Start a new `Source` from the given Iterator. The produced stream of elements
   * will continue until the iterator runs empty or fails during evaluation of
   * the `next()` method. Elements are pulled out of the iterator
   * in accordance with the demand coming from the downstream transformation
   * steps.
   */</span>
  def <a title="[O](f: akka.stream.javadsl.japi.Creator[java.util.Iterator[O]])akka.stream.javadsl.Source[O]" id="akka.stream.javadsl.Source.from(83c03720d3)">from</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl.Source.from(83c03720d3);O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.japi.Creator[java.util.Iterator[O]]" id="akka.stream.javadsl.Source.from(83c03720d3).f">f</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Creator" title="akka.stream.javadsl.japi.Creator[java.util.Iterator[O]]">Creator</a><span class="delimiter">[</span>java.util.Iterator<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">[</span>O<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">(</span>scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source.apply(5f5e506229)" title="(f: () =&gt; Iterator[O])akka.stream.scaladsl.Source[O]">Source</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> ⇒ <a href="#akka.stream.javadsl.Source.from(83c03720d3).f" title="akka.stream.javadsl.japi.Creator[java.util.Iterator[O]]">f</a>.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Creator.create" title="()java.util.Iterator[O]">create</a><span title="(i: java.util.Iterator[O])scala.collection.convert.Decorators.AsScala[Iterator[O]]" class="delimiter">(</span><span class="delimiter">)</span>.<span title="=&gt; Iterator[O]">asScala</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Helper to create [[Source]] from `Iterable`.
   * Example usage:
   * {{{
   * List&lt;Integer&gt; data = new ArrayList&lt;Integer&gt;();
   * data.add(1);
   * data.add(2);
   * data.add(3);
   * Source.fom(data);
   * }}}
   *
   * Starts a new `Source` from the given `Iterable`. This is like starting from an
   * Iterator, but every Subscriber directly attached to the Publisher of this
   * stream will see an individual flow of elements (always starting from the
   * beginning) regardless of when they subscribed.
   */</span>
  def <a title="[O](iterable: Iterable[O])akka.stream.javadsl.Source[O]" id="akka.stream.javadsl.Source.from(4ee42c9d51)">from</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl.Source.from(4ee42c9d51);O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[O]" id="akka.stream.javadsl.Source.from(4ee42c9d51).iterable">iterable</a>: java.lang.<span title="Iterable[O]">Iterable</span><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">[</span>O<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">(</span>scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source.apply(46ac5f8ce6)" title="(iterable: scala.collection.immutable.Iterable[O])akka.stream.scaladsl.Source[O]">Source</a><span class="delimiter">(</span>akka.stream.javadsl.japi.<a href="japi/Util.scala.html#akka.stream.javadsl.japi.Util" title="akka.stream.javadsl.japi.Util.type">Util</a>.<a href="japi/Util.scala.html#akka.stream.javadsl.japi.Util.immutableIterable" title="(iterable: Iterable[O])scala.collection.immutable.Iterable[O]">immutableIterable</a><span class="delimiter">(</span><a href="#akka.stream.javadsl.Source.from(4ee42c9d51).iterable" title="Iterable[O]">iterable</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Start a new `Source` from the given `Future`. The stream will consist of
   * one element when the `Future` is completed with a successful value, which
   * may happen before or after materializing the `Flow`.
   * The stream terminates with an error if the `Future` is completed with a failure.
   */</span>
  def <a title="[O](future: scala.concurrent.Future[O])akka.stream.javadsl.Source[O]" id="akka.stream.javadsl.Source.from(27e749c485)">from</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl.Source.from(27e749c485);O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.concurrent.Future[O]" id="akka.stream.javadsl.Source.from(27e749c485).future">future</a>: <span title="scala.concurrent.Future[O]">Future</span><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">[</span>O<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">(</span>scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source.apply(45d92ae3b4)" title="(future: scala.concurrent.Future[O])akka.stream.scaladsl.Source[O]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl.Source.from(27e749c485).future" title="scala.concurrent.Future[O]">future</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Elements are produced from the tick closure periodically with the specified interval.
   * The tick element will be delivered to downstream consumers that has requested any elements.
   * If a consumer has not requested any elements at the point in time when the tick
   * element is produced it will not receive that tick element later. It will
   * receive new tick elements as soon as it has requested more elements.
   */</span>
  def <a title="[O](initialDelay: scala.concurrent.duration.FiniteDuration, interval: scala.concurrent.duration.FiniteDuration, tick: java.util.concurrent.Callable[O])akka.stream.javadsl.Source[O]" id="akka.stream.javadsl.Source.from(ef077d367d)">from</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl.Source.from(ef077d367d);O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.concurrent.duration.FiniteDuration" id="akka.stream.javadsl.Source.from(ef077d367d).initialDelay">initialDelay</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.stream.javadsl.Source.from(ef077d367d).interval">interval</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>, <a title="java.util.concurrent.Callable[O]" id="akka.stream.javadsl.Source.from(ef077d367d).tick">tick</a>: <span title="java.util.concurrent.Callable[O]">Callable</span><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">[</span>O<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">(</span>scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source.apply(86e6cc10c4)" title="(initialDelay: scala.concurrent.duration.FiniteDuration, interval: scala.concurrent.duration.FiniteDuration, tick: () =&gt; O)akka.stream.scaladsl.TickSource[O]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl.Source.from(ef077d367d).initialDelay" title="scala.concurrent.duration.FiniteDuration">initialDelay</a>, <a href="#akka.stream.javadsl.Source.from(ef077d367d).interval" title="scala.concurrent.duration.FiniteDuration">interval</a>, <span class="delimiter">(</span><span class="delimiter">)</span> ⇒ <a href="#akka.stream.javadsl.Source.from(ef077d367d).tick" title="java.util.concurrent.Callable[O]">tick</a>.<span title="()O">call</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Creates a `Source` by using a [[FlowGraphBuilder]] from this [[PartialFlowGraph]] on a block that expects
   * a [[FlowGraphBuilder]] and returns the `UndefinedSink`.
   */</span>
  def <a title="[T](graph: akka.stream.javadsl.PartialFlowGraph, block: akka.stream.javadsl.japi.Function[akka.stream.javadsl.FlowGraphBuilder,akka.stream.javadsl.UndefinedSink[T]])akka.stream.javadsl.Source[T]" id="akka.stream.javadsl.Source.from(f884fd0551)">from</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl.Source.from(f884fd0551);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.PartialFlowGraph" id="akka.stream.javadsl.Source.from(f884fd0551).graph">graph</a>: <a href="FlowGraph.scala.html#akka.stream.javadsl;PartialFlowGraph" title="akka.stream.javadsl.PartialFlowGraph">PartialFlowGraph</a>, <a title="akka.stream.javadsl.japi.Function[akka.stream.javadsl.FlowGraphBuilder,akka.stream.javadsl.UndefinedSink[T]]" id="akka.stream.javadsl.Source.from(f884fd0551).block">block</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function" title="akka.stream.javadsl.japi.Function[akka.stream.javadsl.FlowGraphBuilder,akka.stream.javadsl.UndefinedSink[T]]">Function</a><span class="delimiter">[</span>FlowGraphBuilder, UndefinedSink<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Nothing]">Source</a><span class="delimiter">(</span>scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source.apply(9d6c024e41)" title="(graph: akka.stream.scaladsl.PartialFlowGraph)(block: akka.stream.scaladsl.FlowGraphBuilder =&gt; akka.stream.scaladsl.UndefinedSink[Nothing])akka.stream.scaladsl.Source[Nothing]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl.Source.from(f884fd0551).graph" title="akka.stream.javadsl.PartialFlowGraph">graph</a>.<a href="FlowGraph.scala.html#akka.stream.javadsl;PartialFlowGraph.asScala" title="=&gt; akka.stream.scaladsl.PartialFlowGraph">asScala</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="akka.stream.scaladsl.FlowGraphBuilder" id="akka.stream.javadsl.Source.from(f884fd0551).$anonfun.x">x</a> ⇒ <a href="#akka.stream.javadsl.Source.from(f884fd0551).block" title="akka.stream.javadsl.japi.Function[akka.stream.javadsl.FlowGraphBuilder,akka.stream.javadsl.UndefinedSink[T]]">block</a>.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function.apply" title="(param: akka.stream.javadsl.FlowGraphBuilder)akka.stream.javadsl.UndefinedSink[T]">apply</a><span class="delimiter">(</span><a href="../scaladsl/JavaConverters.scala.html#akka.stream.scaladsl.JavaConverters.AsAsJavaFlowGraphBuilder(ad092d5197)" title="(builder: akka.stream.scaladsl.FlowGraphBuilder)akka.stream.scaladsl.JavaConverters.AsAsJavaFlowGraphBuilder[Nothing]">x</a>.<a href="../scaladsl/JavaConverters.scala.html#akka.stream.scaladsl.JavaConverters;AsAsJavaFlowGraphBuilder.asJava" title="=&gt; akka.stream.javadsl.FlowGraphBuilder">asJava</a><span class="delimiter">)</span>.<a href="FlowGraph.scala.html#akka.stream.javadsl;UndefinedSink.asScala" title="=&gt; akka.stream.scaladsl.UndefinedSink[T]">asScala</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Creates a `Source` that is materialized to an [[akka.actor.ActorRef]] which points to an Actor
   * created according to the passed in [[akka.actor.Props]]. Actor created by the `props` should
   * be [[akka.stream.actor.ActorPublisher]].
   */</span>
  def <a title="[T](props: akka.actor.Props)akka.stream.javadsl.KeyedSource[T,akka.actor.ActorRef]" id="akka.stream.javadsl.Source.from(7e9c5f4fc6)">from</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl.Source.from(7e9c5f4fc6);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.actor.Props" id="akka.stream.javadsl.Source.from(7e9c5f4fc6).props">props</a>: <span title="akka.actor.Props">Props</span><span class="delimiter">)</span>: <a href="#akka.stream.javadsl;KeyedSource" title="akka.stream.javadsl.KeyedSource[T,akka.actor.ActorRef]">KeyedSource</a><span class="delimiter">[</span>T, ActorRef<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;KeyedSource" title="akka.stream.javadsl.KeyedSource[Nothing,akka.actor.ActorRef]">KeyedSource</a><span class="delimiter">(</span>scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source" title="akka.stream.scaladsl.Source.type">Source</a>.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source.apply(072f21a291)" title="(props: akka.actor.Props)akka.stream.scaladsl.PropsSource[Nothing]">apply</a><span class="delimiter">(</span><a href="#akka.stream.javadsl.Source.from(7e9c5f4fc6).props" title="akka.actor.Props">props</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Create a `Source` with one element.
   * Every connected `Sink` of this stream will see an individual stream consisting of one element.
   */</span>
  def <a title="[T](element: T)akka.stream.javadsl.Source[T]" id="akka.stream.javadsl.Source.singleton">singleton</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl.Source.singleton;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="akka.stream.javadsl.Source.singleton.element">element</a>: <a href="#akka.stream.javadsl.Source.singleton;T" title="T">T</a><span class="delimiter">)</span>: <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">(</span>scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source" title="akka.stream.scaladsl.Source.type">Source</a>.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source.singleton" title="(element: T)akka.stream.scaladsl.Source[T]">singleton</a><span class="delimiter">(</span><a href="#akka.stream.javadsl.Source.singleton.element" title="T">element</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Create a `Source` that immediately ends the stream with the `cause` error to every connected `Sink`.
   */</span>
  def <a title="[T](cause: Throwable)akka.stream.javadsl.Source[T]" id="akka.stream.javadsl.Source.failed">failed</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl.Source.failed;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Throwable" id="akka.stream.javadsl.Source.failed.cause">cause</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span>: <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Nothing]">Source</a><span class="delimiter">(</span>scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source" title="akka.stream.scaladsl.Source.type">Source</a>.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source.failed" title="(cause: Throwable)akka.stream.scaladsl.Source[Nothing]">failed</a><span class="delimiter">(</span><a href="#akka.stream.javadsl.Source.failed.cause" title="Throwable">cause</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Creates a `Source` that is materialized as a [[org.reactivestreams.Subscriber]]
   */</span>
  def <a title="[T]()akka.stream.javadsl.KeyedSource[T,org.reactivestreams.Subscriber[T]]" id="akka.stream.javadsl.Source.subscriber">subscriber</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl.Source.subscriber;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.stream.javadsl;KeyedSource" title="akka.stream.javadsl.KeyedSource[T,org.reactivestreams.Subscriber[T]]">KeyedSource</a><span class="delimiter">[</span>T, Subscriber<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;KeyedSource" title="akka.stream.javadsl.KeyedSource[T,org.reactivestreams.Subscriber[T]]">KeyedSource</a><span class="delimiter">(</span>scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source" title="akka.stream.scaladsl.Source.type">Source</a>.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source.subscriber" title="akka.stream.scaladsl.SubscriberSource[T]">subscriber</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Concatenates two sources so that the first element
   * emitted by the second source is emitted after the last element of the first
   * source.
   */</span>
  def <a title="[T](first: akka.stream.javadsl.Source[T], second: akka.stream.javadsl.Source[T])akka.stream.javadsl.Source[T]" id="akka.stream.javadsl.Source.concat">concat</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl.Source.concat;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.Source[T]" id="akka.stream.javadsl.Source.concat.first">first</a>: <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="akka.stream.javadsl.Source[T]" id="akka.stream.javadsl.Source.concat.second">second</a>: <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">(</span>scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source" title="akka.stream.scaladsl.Source.type">Source</a>.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl.Source.concat" title="(source1: akka.stream.scaladsl.Source[T], source2: akka.stream.scaladsl.Source[T])akka.stream.scaladsl.Source[T]">concat</a><span class="delimiter">(</span><a href="#akka.stream.javadsl.Source.concat.first" title="akka.stream.javadsl.Source[T]">first</a>.<a href="#akka.stream.javadsl;Source.asScala" title="=&gt; akka.stream.scaladsl.Source[T]">asScala</a>, <a href="#akka.stream.javadsl.Source.concat.second" title="akka.stream.javadsl.Source[T]">second</a>.<a href="#akka.stream.javadsl;Source.asScala" title="=&gt; akka.stream.scaladsl.Source[T]">asScala</a><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Java API
 *
 * A `Source` is a set of stream processing steps that has one open output and an attached input.
 * Can be used as a `Publisher`
 */</span>
class <a title="class Source[+Out] extends AnyRef" id="akka.stream.javadsl;Source">Source</a><span class="delimiter">[</span>+<a title="" id="akka.stream.javadsl;Source;Out">Out</a><span class="delimiter">]</span><a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]" class="delimiter">(</a><a title="akka.stream.scaladsl.Source[Out]" id="akka.stream.javadsl;Source.delegate">delegate</a>: scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl;Source" title="akka.stream.scaladsl.Source[Out]">Source</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>
  import akka.stream.scaladsl.<a href="../scaladsl/JavaConverters.scala.html#akka.stream.scaladsl.JavaConverters" title="akka.stream.scaladsl.JavaConverters.type">JavaConverters</a>._

  import scala.collection.<span title="scala.collection.JavaConverters.type">JavaConverters</span>._

  <span class="comment">/** Converts this Java DSL element to it's Scala DSL counterpart. */</span>
  def <a title="=&gt; akka.stream.scaladsl.Source[Out]" id="akka.stream.javadsl;Source.asScala">asScala</a>: scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl;Source" title="akka.stream.scaladsl.Source[Out]">Source</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> = <a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>

  <span class="comment">/**
   * Transform this [[Source]] by appending the given processing stages.
   */</span>
  def <a title="[T](flow: akka.stream.javadsl.Flow[Out,T])akka.stream.javadsl.Source[T]" id="akka.stream.javadsl;Source.via">via</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.via;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.Flow[Out,T]" id="akka.stream.javadsl;Source.via.flow">flow</a>: javadsl.<a href="Flow.scala.html#akka.stream.javadsl;Flow" title="akka.stream.javadsl.Flow[Out,T]">Flow</a><span class="delimiter">[</span>Out, T<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl;Source.via" title="(flow: akka.stream.scaladsl.Flow[Out,T])akka.stream.scaladsl.Source[T]">via</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.via.flow" title="akka.stream.javadsl.Flow[Out,T]">flow</a>.<a href="Flow.scala.html#akka.stream.javadsl;Flow.asScala" title="=&gt; akka.stream.scaladsl.Flow[Out,T]">asScala</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Connect this [[Source]] to a [[Sink]], concatenating the processing steps of both.
   */</span>
  def <a title="(sink: akka.stream.javadsl.Sink[Out])akka.stream.javadsl.RunnableFlow" id="akka.stream.javadsl;Source.to">to</a><span class="delimiter">(</span><a title="akka.stream.javadsl.Sink[Out]" id="akka.stream.javadsl;Source.to.sink">sink</a>: javadsl.<a href="Sink.scala.html#akka.stream.javadsl;Sink" title="akka.stream.javadsl.Sink[Out]">Sink</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="Flow.scala.html#akka.stream.javadsl;RunnableFlow" title="akka.stream.javadsl.RunnableFlow">RunnableFlow</a> =
    new <a href="Flow.scala.html#akka.stream.javadsl;RunnableFlowAdapter" title="akka.stream.javadsl.RunnableFlowAdapter">RunnableFlowAdapter</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl;Source.to" title="(sink: akka.stream.scaladsl.Sink[Out])akka.stream.scaladsl.RunnableFlow">to</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.to.sink" title="akka.stream.javadsl.Sink[Out]">sink</a>.<a href="Sink.scala.html#akka.stream.javadsl;Sink.asScala" title="=&gt; akka.stream.scaladsl.Sink[Out]">asScala</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Connect this `Source` to a `KeyedSink` and run it.
   *
   * The returned value is the materialized value of the `Sink`, e.g. the `Publisher` of a `Sink.publisher()`.
   *
   * @tparam S materialized type of the given Sink
   */</span>
  def <a title="[S](sink: akka.stream.javadsl.KeyedSink[Out,S], materializer: akka.stream.FlowMaterializer)S" id="akka.stream.javadsl;Source.runWith(c7d41e0b67)">runWith</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.runWith(c7d41e0b67);S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.KeyedSink[Out,S]" id="akka.stream.javadsl;Source.runWith(c7d41e0b67).sink">sink</a>: <a href="Sink.scala.html#akka.stream.javadsl;KeyedSink" title="akka.stream.javadsl.KeyedSink[Out,S]">KeyedSink</a><span class="delimiter">[</span>Out, S<span class="delimiter">]</span>, <a title="akka.stream.FlowMaterializer" id="akka.stream.javadsl;Source.runWith(c7d41e0b67).materializer">materializer</a>: <a href="../FlowMaterializer.scala.html#akka.stream;FlowMaterializer" title="akka.stream.FlowMaterializer">FlowMaterializer</a><span class="delimiter">)</span>: <a href="#akka.stream.javadsl;Source.runWith(c7d41e0b67);S" title="S">S</a> =
    <a href="#akka.stream.javadsl;Source.asScala" title="=&gt; akka.stream.scaladsl.Source[Out]">asScala</a>.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl;Source.runWith" title="(sink: akka.stream.scaladsl.Sink[Out])(implicit materializer: akka.stream.FlowMaterializer)sink.MaterializedType">runWith</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.runWith(c7d41e0b67).sink" title="akka.stream.javadsl.KeyedSink[Out,S]">sink</a>.<a href="Sink.scala.html#akka.stream.javadsl;KeyedSink.asScala" title="=&gt; akka.stream.scaladsl.KeyedSink[Out,S]">asScala</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.runWith(c7d41e0b67).materializer" title="akka.stream.FlowMaterializer">materializer</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="S" class="delimiter">[</span><a href="#akka.stream.javadsl;Source.runWith(c7d41e0b67);S" title="S">S</a><span class="delimiter">]</span>

  <span class="comment">/**
   * Connect this `Source` to a `Sink` and run it. The returned value is the materialized value
   * of the `Sink`, e.g. the `Publisher` of a `Sink.publisher()`.
   */</span>
  def <a title="(sink: akka.stream.javadsl.Sink[Out], materializer: akka.stream.FlowMaterializer)Unit" id="akka.stream.javadsl;Source.runWith(a4a01ee767)">runWith</a><span class="delimiter">(</span><a title="akka.stream.javadsl.Sink[Out]" id="akka.stream.javadsl;Source.runWith(a4a01ee767).sink">sink</a>: <a href="Sink.scala.html#akka.stream.javadsl;Sink" title="akka.stream.javadsl.Sink[Out]">Sink</a><span class="delimiter">[</span>Out<span class="delimiter">]</span>, <a title="akka.stream.FlowMaterializer" id="akka.stream.javadsl;Source.runWith(a4a01ee767).materializer">materializer</a>: <a href="../FlowMaterializer.scala.html#akka.stream;FlowMaterializer" title="akka.stream.FlowMaterializer">FlowMaterializer</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl;Source.to" title="(sink: akka.stream.scaladsl.Sink[Out])akka.stream.scaladsl.RunnableFlow">to</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.runWith(a4a01ee767).sink" title="akka.stream.javadsl.Sink[Out]">sink</a>.<a href="Sink.scala.html#akka.stream.javadsl;Sink.asScala" title="=&gt; akka.stream.scaladsl.Sink[Out]">asScala</a><span class="delimiter">)</span>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;RunnableFlow.run" title="()(implicit materializer: akka.stream.FlowMaterializer)akka.stream.scaladsl.MaterializedMap">run</a><span class="delimiter">(</span><span class="delimiter">)</span><span title="Unit" class="delimiter">(</span><a href="#akka.stream.javadsl;Source.runWith(a4a01ee767).materializer" title="akka.stream.FlowMaterializer">materializer</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Shortcut for running this `Source` with a fold function.
   * The given function is invoked for every received element, giving it its previous
   * output (or the given `zero` value) and the element as input.
   * The returned [[scala.concurrent.Future]] will be completed with value of the final
   * function evaluation when the input stream ends, or completed with `Failure`
   * if there is an error is signaled in the stream.
   */</span>
  def <a title="[U](zero: U, f: akka.stream.javadsl.japi.Function2[U,Out,U], materializer: akka.stream.FlowMaterializer)scala.concurrent.Future[U]" id="akka.stream.javadsl;Source.fold">fold</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.fold;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="U" id="akka.stream.javadsl;Source.fold.zero">zero</a>: <a href="#akka.stream.javadsl;Source.fold;U" title="U">U</a>, <a title="akka.stream.javadsl.japi.Function2[U,Out,U]" id="akka.stream.javadsl;Source.fold.f">f</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function2" title="akka.stream.javadsl.japi.Function2[U,Out,U]">Function2</a><span class="delimiter">[</span>U, Out, U<span class="delimiter">]</span>, <a title="akka.stream.FlowMaterializer" id="akka.stream.javadsl;Source.fold.materializer">materializer</a>: <a href="../FlowMaterializer.scala.html#akka.stream;FlowMaterializer" title="akka.stream.FlowMaterializer">FlowMaterializer</a><span class="delimiter">)</span>: <span title="scala.concurrent.Future[U]">Future</span><span class="delimiter">[</span>U<span class="delimiter">]</span> =
    <a href="#akka.stream.javadsl;Source.runWith(c7d41e0b67)" title="(sink: akka.stream.javadsl.KeyedSink[Out,scala.concurrent.Future[U]], materializer: akka.stream.FlowMaterializer)scala.concurrent.Future[U]">runWith</a><span class="delimiter">(</span><a href="Sink.scala.html#akka.stream.javadsl.Sink" title="akka.stream.javadsl.Sink.type">Sink</a>.<a href="Sink.scala.html#akka.stream.javadsl.Sink.fold" title="(zero: U, f: akka.stream.javadsl.japi.Function2[U,Out,U])akka.stream.javadsl.KeyedSink[Out,scala.concurrent.Future[U]]">fold</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.fold.zero" title="U">zero</a>, <a href="#akka.stream.javadsl;Source.fold.f" title="akka.stream.javadsl.japi.Function2[U,Out,U]">f</a><span class="delimiter">)</span>, <a href="#akka.stream.javadsl;Source.fold.materializer" title="akka.stream.FlowMaterializer">materializer</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Concatenates a second source so that the first element
   * emitted by that source is emitted after the last element of this
   * source.
   */</span>
  def <a title="[Out2 &gt;: Out](second: akka.stream.javadsl.Source[Out2])akka.stream.javadsl.Source[Out2]" id="akka.stream.javadsl;Source.concat">concat</a><span class="delimiter">[</span><a title=" &gt;: Out" id="akka.stream.javadsl;Source.concat;Out2">Out2</a> &gt;: Out<span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.Source[Out2]" id="akka.stream.javadsl;Source.concat.second">second</a>: <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out2]">Source</a><span class="delimiter">[</span>Out2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out2]">Source</a><span class="delimiter">[</span>Out2<span class="delimiter">]</span> =
    <a href="#akka.stream.javadsl.Source" title="akka.stream.javadsl.Source.type">Source</a>.<a href="#akka.stream.javadsl.Source.concat" title="(first: akka.stream.javadsl.Source[Out2], second: akka.stream.javadsl.Source[Out2])akka.stream.javadsl.Source[Out2]">concat</a><span class="delimiter">(</span>this, <a href="#akka.stream.javadsl;Source.concat.second" title="akka.stream.javadsl.Source[Out2]">second</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Shortcut for running this `Source` with a foreach procedure. The given procedure is invoked
   * for each received element.
   * The returned [[scala.concurrent.Future]] will be completed with `Success` when reaching the
   * normal end of the stream, or completed with `Failure` if there is an error is signaled in
   * the stream.
   */</span>
  def <a title="(f: akka.stream.javadsl.japi.Procedure[Out], materializer: akka.stream.FlowMaterializer)scala.concurrent.Future[Unit]" id="akka.stream.javadsl;Source.foreach">foreach</a><span class="delimiter">(</span><a title="akka.stream.javadsl.japi.Procedure[Out]" id="akka.stream.javadsl;Source.foreach.f">f</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Procedure" title="akka.stream.javadsl.japi.Procedure[Out]">Procedure</a><span class="delimiter">[</span>Out<span class="delimiter">]</span>, <a title="akka.stream.FlowMaterializer" id="akka.stream.javadsl;Source.foreach.materializer">materializer</a>: <a href="../FlowMaterializer.scala.html#akka.stream;FlowMaterializer" title="akka.stream.FlowMaterializer">FlowMaterializer</a><span class="delimiter">)</span>: <span title="scala.concurrent.Future[Unit]">Future</span><span class="delimiter">[</span>Unit<span class="delimiter">]</span> =
    <a href="#akka.stream.javadsl;Source.runWith(c7d41e0b67)" title="(sink: akka.stream.javadsl.KeyedSink[Out,scala.concurrent.Future[Unit]], materializer: akka.stream.FlowMaterializer)scala.concurrent.Future[Unit]">runWith</a><span class="delimiter">(</span><a href="Sink.scala.html#akka.stream.javadsl.Sink" title="akka.stream.javadsl.Sink.type">Sink</a>.<a href="Sink.scala.html#akka.stream.javadsl.Sink.foreach" title="(f: akka.stream.javadsl.japi.Procedure[Out])akka.stream.javadsl.KeyedSink[Out,scala.concurrent.Future[Unit]]">foreach</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.foreach.f" title="akka.stream.javadsl.japi.Procedure[Out]">f</a><span class="delimiter">)</span>, <a href="#akka.stream.javadsl;Source.foreach.materializer" title="akka.stream.FlowMaterializer">materializer</a><span class="delimiter">)</span>

  <span class="comment">// COMMON OPS //</span>

  <span class="comment">/**
   * Transform this stream by applying the given function to each of the elements
   * as they pass through this processing step.
   */</span>
  def <a title="[T](f: akka.stream.javadsl.japi.Function[Out,T])akka.stream.javadsl.Source[T]" id="akka.stream.javadsl;Source.map">map</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.map;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.japi.Function[Out,T]" id="akka.stream.javadsl;Source.map.f">f</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function" title="akka.stream.javadsl.japi.Function[Out,T]">Function</a><span class="delimiter">[</span>Out, T<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.map" title="(f: Out =&gt; T)Source.this.delegate.Repr[T]">map</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.map.f" title="akka.stream.javadsl.japi.Function[Out,T]">f</a>.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function.apply" title="(param: Out)T">apply</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Transform each input element into a sequence of output elements that is
   * then flattened into the output stream.
   */</span>
  def <a title="[T](f: akka.stream.javadsl.japi.Function[Out,java.util.List[T]])akka.stream.javadsl.Source[T]" id="akka.stream.javadsl;Source.mapConcat">mapConcat</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.mapConcat;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.japi.Function[Out,java.util.List[T]]" id="akka.stream.javadsl;Source.mapConcat.f">f</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function" title="akka.stream.javadsl.japi.Function[Out,java.util.List[T]]">Function</a><span class="delimiter">[</span>Out, java.util.List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.mapConcat" title="(f: Out =&gt; scala.collection.immutable.Seq[T])Source.this.delegate.Repr[T]">mapConcat</a><span class="delimiter">(</span><a title="Out" id="akka.stream.javadsl;Source.mapConcat.$anonfun.elem">elem</a> ⇒ <span title="akka.japi.Util.type">Util</span>.<span title="(iterable: Iterable[T])scala.collection.immutable.Seq[T]">immutableSeq</span><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.mapConcat.f" title="akka.stream.javadsl.japi.Function[Out,java.util.List[T]]">f</a>.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function.apply" title="(param: Out)java.util.List[T]">apply</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.mapConcat.$anonfun.elem" title="Out">elem</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Transform this stream by applying the given function to each of the elements
   * as they pass through this processing step. The function returns a `Future` of the
   * element that will be emitted downstream. As many futures as requested elements by
   * downstream may run in parallel and may complete in any order, but the elements that
   * are emitted downstream are in the same order as from upstream.
   *
   * @see [[#mapAsyncUnordered]]
   */</span>
  def <a title="[T](f: akka.stream.javadsl.japi.Function[Out,scala.concurrent.Future[T]])akka.stream.javadsl.Source[T]" id="akka.stream.javadsl;Source.mapAsync">mapAsync</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.mapAsync;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.japi.Function[Out,scala.concurrent.Future[T]]" id="akka.stream.javadsl;Source.mapAsync.f">f</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function" title="akka.stream.javadsl.japi.Function[Out,scala.concurrent.Future[T]]">Function</a><span class="delimiter">[</span>Out, Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.mapAsync" title="(f: Out =&gt; scala.concurrent.Future[T])Source.this.delegate.Repr[T]">mapAsync</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.mapAsync.f" title="akka.stream.javadsl.japi.Function[Out,scala.concurrent.Future[T]]">f</a>.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function.apply" title="(param: Out)scala.concurrent.Future[T]">apply</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Transform this stream by applying the given function to each of the elements
   * as they pass through this processing step. The function returns a `Future` of the
   * element that will be emitted downstream. As many futures as requested elements by
   * downstream may run in parallel and each processed element will be emitted dowstream
   * as soon as it is ready, i.e. it is possible that the elements are not emitted downstream
   * in the same order as from upstream.
   *
   * @see [[#mapAsync]]
   */</span>
  def <a title="[T](f: akka.stream.javadsl.japi.Function[Out,scala.concurrent.Future[T]])akka.stream.javadsl.Source[T]" id="akka.stream.javadsl;Source.mapAsyncUnordered">mapAsyncUnordered</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.mapAsyncUnordered;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.japi.Function[Out,scala.concurrent.Future[T]]" id="akka.stream.javadsl;Source.mapAsyncUnordered.f">f</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function" title="akka.stream.javadsl.japi.Function[Out,scala.concurrent.Future[T]]">Function</a><span class="delimiter">[</span>Out, Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.mapAsyncUnordered" title="(f: Out =&gt; scala.concurrent.Future[T])Source.this.delegate.Repr[T]">mapAsyncUnordered</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.mapAsyncUnordered.f" title="akka.stream.javadsl.japi.Function[Out,scala.concurrent.Future[T]]">f</a>.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function.apply" title="(param: Out)scala.concurrent.Future[T]">apply</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Only pass on those elements that satisfy the given predicate.
   */</span>
  def <a title="(p: akka.stream.javadsl.japi.Predicate[Out])akka.stream.javadsl.Source[Out]" id="akka.stream.javadsl;Source.filter">filter</a><span class="delimiter">(</span><a title="akka.stream.javadsl.japi.Predicate[Out]" id="akka.stream.javadsl;Source.filter.p">p</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Predicate" title="akka.stream.javadsl.japi.Predicate[Out]">Predicate</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.filter" title="(p: Out =&gt; Boolean)Source.this.delegate.Repr[Out]">filter</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.filter.p" title="akka.stream.javadsl.japi.Predicate[Out]">p</a>.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Predicate.test" title="(param: Out)Boolean">test</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Transform this stream by applying the given partial function to each of the elements
   * on which the function is defined as they pass through this processing step.
   * Non-matching elements are filtered out.
   */</span>
  def <a title="[T](pf: PartialFunction[Out,T])akka.stream.javadsl.Source[T]" id="akka.stream.javadsl;Source.collect">collect</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.collect;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="PartialFunction[Out,T]" id="akka.stream.javadsl;Source.collect.pf">pf</a>: <span title="PartialFunction[Out,T]">PartialFunction</span><span class="delimiter">[</span>Out, T<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.collect" title="(pf: PartialFunction[Out,T])Source.this.delegate.Repr[T]">collect</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.collect.pf" title="PartialFunction[Out,T]">pf</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Chunk up this stream into groups of the given size, with the last group
   * possibly smaller than requested due to end-of-stream.
   *
   * @param n must be positive, otherwise [[IllegalArgumentException]] is thrown.
   */</span>
  def <a title="(n: Int)akka.stream.javadsl.Source[java.util.List[Out]]" id="akka.stream.javadsl;Source.grouped">grouped</a><span class="delimiter">(</span><a title="Int" id="akka.stream.javadsl;Source.grouped.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[java.util.List[Out @scala.annotation.unchecked.uncheckedVariance]]">Source</a><span class="delimiter">[</span>java.util.List<span class="delimiter">[</span>Out @uncheckedVariance<span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[java.util.List[Out]]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.grouped" title="(n: Int)Source.this.delegate.Repr[scala.collection.immutable.Seq[Out]]">grouped</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.grouped.n" title="Int">n</a><span class="delimiter">)</span>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.map" title="(f: scala.collection.immutable.Seq[Out] =&gt; java.util.List[Out])Source.this.delegate.Repr[scala.collection.immutable.Seq[Out]]#Repr[java.util.List[Out]]">map</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.grouped.$anonfun.x$1" title="(b: Seq[Out])scala.collection.convert.Decorators.AsJava[java.util.List[Out]]">_</a>.<span title="=&gt; java.util.List[Out]">asJava</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Similar to `fold` but is not a terminal operation,
   * emits its current value which starts at `zero` and then
   * applies the current and next value to the given function `f`,
   * yielding the next current value.
   */</span>
  def <a title="[T](zero: T)(f: akka.stream.javadsl.japi.Function2[T,Out,T])akka.stream.javadsl.Source[T]" id="akka.stream.javadsl;Source.scan">scan</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.scan;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="akka.stream.javadsl;Source.scan.zero">zero</a>: <a href="#akka.stream.javadsl;Source.scan;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="akka.stream.javadsl.japi.Function2[T,Out,T]" id="akka.stream.javadsl;Source.scan.f">f</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function2" title="akka.stream.javadsl.japi.Function2[T,Out,T]">Function2</a><span class="delimiter">[</span>T, Out, T<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">[</span>T<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[T]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.scan" title="(zero: T)(f: (T, Out) =&gt; T)Source.this.delegate.Repr[T]">scan</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.scan.zero" title="T">zero</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.scan.f" title="akka.stream.javadsl.japi.Function2[T,Out,T]">f</a>.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function2.apply" title="(arg1: T, arg2: Out)T">apply</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Chunk up this stream into groups of elements received within a time window,
   * or limited by the given number of elements, whatever happens first.
   * Empty groups will not be emitted if no elements are received from upstream.
   * The last group before end-of-stream will contain the buffered elements
   * since the previously emitted group.
   *
   * @param n must be positive, and `d` must be greater than 0 seconds, otherwise [[IllegalArgumentException]] is thrown.
   */</span>
  def <a title="(n: Int, d: scala.concurrent.duration.FiniteDuration)akka.stream.javadsl.Source[java.util.List[Out]]" id="akka.stream.javadsl;Source.groupedWithin">groupedWithin</a><span class="delimiter">(</span><a title="Int" id="akka.stream.javadsl;Source.groupedWithin.n">n</a>: <span title="Int">Int</span>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.stream.javadsl;Source.groupedWithin.d">d</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[java.util.List[Out @scala.annotation.unchecked.uncheckedVariance]]">Source</a><span class="delimiter">[</span>java.util.List<span class="delimiter">[</span>Out @uncheckedVariance<span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[java.util.List[Out]]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.groupedWithin" title="(n: Int, d: scala.concurrent.duration.FiniteDuration)Source.this.delegate.Repr[Out]#Repr[scala.collection.immutable.Seq[Out]]">groupedWithin</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.groupedWithin.n" title="Int">n</a>, <a href="#akka.stream.javadsl;Source.groupedWithin.d" title="scala.concurrent.duration.FiniteDuration">d</a><span class="delimiter">)</span>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.map" title="(f: scala.collection.immutable.Seq[Out] =&gt; java.util.List[Out])Source.this.delegate.Repr[Out]#Repr[scala.collection.immutable.Seq[Out]]#Repr[java.util.List[Out]]">map</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.groupedWithin.$anonfun.x$2" title="(b: Seq[Out])scala.collection.convert.Decorators.AsJava[java.util.List[Out]]">_</a>.<span title="=&gt; java.util.List[Out]">asJava</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// FIXME optimize to one step</span>

  <span class="comment">/**
   * Discard the given number of elements at the beginning of the stream.
   * No elements will be dropped if `n` is zero or negative.
   */</span>
  def <a title="(n: Int)akka.stream.javadsl.Source[Out]" id="akka.stream.javadsl;Source.drop">drop</a><span class="delimiter">(</span><a title="Int" id="akka.stream.javadsl;Source.drop.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.drop" title="(n: Int)Source.this.delegate.Repr[Out]">drop</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.drop.n" title="Int">n</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Discard the elements received within the given duration at beginning of the stream.
   */</span>
  def <a title="(d: scala.concurrent.duration.FiniteDuration)akka.stream.javadsl.Source[Out]" id="akka.stream.javadsl;Source.dropWithin">dropWithin</a><span class="delimiter">(</span><a title="scala.concurrent.duration.FiniteDuration" id="akka.stream.javadsl;Source.dropWithin.d">d</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.dropWithin" title="(d: scala.concurrent.duration.FiniteDuration)Source.this.delegate.Repr[Out]#Repr[Out]">dropWithin</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.dropWithin.d" title="scala.concurrent.duration.FiniteDuration">d</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Terminate processing (and cancel the upstream publisher) after the given
   * number of elements. Due to input buffering some elements may have been
   * requested from upstream publishers that will then not be processed downstream
   * of this step.
   *
   * @param n if `n` is zero or negative the stream will be completed without producing any elements.
   */</span>
  def <a title="(n: Int)akka.stream.javadsl.Source[Out]" id="akka.stream.javadsl;Source.take">take</a><span class="delimiter">(</span><a title="Int" id="akka.stream.javadsl;Source.take.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.take" title="(n: Int)Source.this.delegate.Repr[Out]">take</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.take.n" title="Int">n</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Terminate processing (and cancel the upstream publisher) after the given
   * duration. Due to input buffering some elements may have been
   * requested from upstream publishers that will then not be processed downstream
   * of this step.
   *
   * Note that this can be combined with [[#take]] to limit the number of elements
   * within the duration.
   */</span>
  def <a title="(d: scala.concurrent.duration.FiniteDuration)akka.stream.javadsl.Source[Out]" id="akka.stream.javadsl;Source.takeWithin">takeWithin</a><span class="delimiter">(</span><a title="scala.concurrent.duration.FiniteDuration" id="akka.stream.javadsl;Source.takeWithin.d">d</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.takeWithin" title="(d: scala.concurrent.duration.FiniteDuration)Source.this.delegate.Repr[Out]#Repr[Out]">takeWithin</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.takeWithin.d" title="scala.concurrent.duration.FiniteDuration">d</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Allows a faster upstream to progress independently of a slower subscriber by conflating elements into a summary
   * until the subscriber is ready to accept them. For example a conflate step might average incoming numbers if the
   * upstream publisher is faster.
   *
   * This element only rolls up elements if the upstream is faster, but if the downstream is faster it will not
   * duplicate elements.
   *
   * @param seed Provides the first state for a conflated value using the first unconsumed element as a start
   * @param aggregate Takes the currently aggregated value and the current pending element to produce a new aggregate
   */</span>
  def <a title="[S](seed: akka.stream.javadsl.japi.Function[Out,S], aggregate: akka.stream.javadsl.japi.Function2[S,Out,S])akka.stream.javadsl.Source[S]" id="akka.stream.javadsl;Source.conflate">conflate</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.conflate;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.japi.Function[Out,S]" id="akka.stream.javadsl;Source.conflate.seed">seed</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function" title="akka.stream.javadsl.japi.Function[Out,S]">Function</a><span class="delimiter">[</span>Out, S<span class="delimiter">]</span>, <a title="akka.stream.javadsl.japi.Function2[S,Out,S]" id="akka.stream.javadsl;Source.conflate.aggregate">aggregate</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function2" title="akka.stream.javadsl.japi.Function2[S,Out,S]">Function2</a><span class="delimiter">[</span>S, Out, S<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[S]">Source</a><span class="delimiter">[</span>S<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[S]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.conflate" title="(seed: Out =&gt; S)(aggregate: (S, Out) =&gt; S)Source.this.delegate.Repr[S]">conflate</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.conflate.seed" title="akka.stream.javadsl.japi.Function[Out,S]">seed</a>.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function.apply" title="(param: Out)S">apply</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.conflate.aggregate" title="akka.stream.javadsl.japi.Function2[S,Out,S]">aggregate</a>.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function2.apply" title="(arg1: S, arg2: Out)S">apply</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Allows a faster downstream to progress independently of a slower publisher by extrapolating elements from an older
   * element until new element comes from the upstream. For example an expand step might repeat the last element for
   * the subscriber until it receives an update from upstream.
   *
   * This element will never &quot;drop&quot; upstream elements as all elements go through at least one extrapolation step.
   * This means that if the upstream is actually faster than the upstream it will be backpressured by the downstream
   * subscriber.
   *
   * @param seed Provides the first state for extrapolation using the first unconsumed element
   * @param extrapolate Takes the current extrapolation state to produce an output element and the next extrapolation
   *                    state.
   */</span>
  def <a title="[S, U](seed: akka.stream.javadsl.japi.Function[Out,S], extrapolate: akka.stream.javadsl.japi.Function[S,akka.japi.Pair[U,S]])akka.stream.javadsl.Source[U]" id="akka.stream.javadsl;Source.expand">expand</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.expand;S">S</a>, <a title="" id="akka.stream.javadsl;Source.expand;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.japi.Function[Out,S]" id="akka.stream.javadsl;Source.expand.seed">seed</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function" title="akka.stream.javadsl.japi.Function[Out,S]">Function</a><span class="delimiter">[</span>Out, S<span class="delimiter">]</span>, <a title="akka.stream.javadsl.japi.Function[S,akka.japi.Pair[U,S]]" id="akka.stream.javadsl;Source.expand.extrapolate">extrapolate</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function" title="akka.stream.javadsl.japi.Function[S,akka.japi.Pair[U,S]]">Function</a><span class="delimiter">[</span>S, akka.japi.Pair<span class="delimiter">[</span>U, S<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[U]">Source</a><span class="delimiter">[</span>U<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[U]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.expand" title="(seed: Out =&gt; S)(extrapolate: S =&gt; (U, S))Source.this.delegate.Repr[U]">expand</a><span class="delimiter">(</span><a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function.apply" title="(param: Out)S">seed</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.expand.$anonfun.x$3" title="Out">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="S" id="akka.stream.javadsl;Source.expand.$anonfun.s">s</a> ⇒ <span class="delimiter">{</span>
      val <a title="akka.japi.Pair[U,S]" id="akka.stream.javadsl;Source.expand.$anonfun.p">p</a> = <a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function.apply" title="(param: S)akka.japi.Pair[U,S]">extrapolate</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.expand.$anonfun.s" title="S">s</a><span class="delimiter">)</span>
      <span title="(_1: U, _2: S)(U, S)" class="delimiter">(</span><a href="#akka.stream.javadsl;Source.expand.$anonfun.p" title="akka.japi.Pair[U,S]">p</a>.<span title="=&gt; U">first</span>, <a href="#akka.stream.javadsl;Source.expand.$anonfun.p" title="akka.japi.Pair[U,S]">p</a>.<span title="=&gt; S">second</span><span class="delimiter">)</span>
    <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Adds a fixed size buffer in the flow that allows to store elements from a faster upstream until it becomes full.
   * Depending on the defined [[akka.stream.OverflowStrategy]] it might drop elements or backpressure the upstream if
   * there is no space available
   *
   * @param size The size of the buffer in element count
   * @param overflowStrategy Strategy that is used when incoming elements cannot fit inside the buffer
   */</span>
  def <a title="(size: Int, overflowStrategy: akka.stream.OverflowStrategy)akka.stream.javadsl.Source[Out]" id="akka.stream.javadsl;Source.buffer">buffer</a><span class="delimiter">(</span><a title="Int" id="akka.stream.javadsl;Source.buffer.size">size</a>: <span title="Int">Int</span>, <a title="akka.stream.OverflowStrategy" id="akka.stream.javadsl;Source.buffer.overflowStrategy">overflowStrategy</a>: <a href="../OverflowStrategy.scala.html#akka.stream;OverflowStrategy" title="akka.stream.OverflowStrategy">OverflowStrategy</a><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.buffer" title="(size: Int, overflowStrategy: akka.stream.OverflowStrategy)Source.this.delegate.Repr[Out]">buffer</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.buffer.size" title="Int">size</a>, <a href="#akka.stream.javadsl;Source.buffer.overflowStrategy" title="akka.stream.OverflowStrategy">overflowStrategy</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Generic transformation of a stream with a custom processing [[akka.stream.stage.Stage]].
   * This operator makes it possible to extend the `Flow` API when there is no specialized
   * operator that performs the transformation.
   */</span>
  def <a title="[U](mkStage: akka.stream.javadsl.japi.Creator[akka.stream.stage.Stage[Out,U]])akka.stream.javadsl.Source[U]" id="akka.stream.javadsl;Source.transform">transform</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.transform;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.japi.Creator[akka.stream.stage.Stage[Out,U]]" id="akka.stream.javadsl;Source.transform.mkStage">mkStage</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Creator" title="akka.stream.javadsl.japi.Creator[akka.stream.stage.Stage[Out,U]]">Creator</a><span class="delimiter">[</span>Stage<span class="delimiter">[</span>Out, U<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[U]">Source</a><span class="delimiter">[</span>U<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[U]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.transform" title="(mkStage: () =&gt; akka.stream.stage.Stage[Out,U])Source.this.delegate.Repr[U]">transform</a><span class="delimiter">(</span><span class="delimiter">(</span><span class="delimiter">)</span> ⇒ <a href="#akka.stream.javadsl;Source.transform.mkStage" title="akka.stream.javadsl.japi.Creator[akka.stream.stage.Stage[Out,U]]">mkStage</a>.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Creator.create" title="()akka.stream.stage.Stage[Out,U]">create</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Takes up to `n` elements from the stream and returns a pair containing a strict sequence of the taken element
   * and a stream representing the remaining elements. If ''n'' is zero or negative, then this will return a pair
   * of an empty collection and a stream containing the whole upstream unchanged.
   */</span>
  def <a title="(n: Int)akka.stream.javadsl.Source[akka.japi.Pair[java.util.List[Out],akka.stream.javadsl.Source[Out]]]" id="akka.stream.javadsl;Source.prefixAndTail">prefixAndTail</a><span class="delimiter">(</span><a title="Int" id="akka.stream.javadsl;Source.prefixAndTail.n">n</a>: <span title="Int">Int</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[akka.japi.Pair[java.util.List[Out @scala.annotation.unchecked.uncheckedVariance],akka.stream.javadsl.Source[Out @scala.annotation.unchecked.uncheckedVariance]]]">Source</a><span class="delimiter">[</span>akka.japi.Pair<span class="delimiter">[</span>java.util.List<span class="delimiter">[</span>Out @uncheckedVariance<span class="delimiter">]</span>, javadsl.Source<span class="delimiter">[</span>Out @uncheckedVariance<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[akka.japi.Pair[java.util.List[Out],akka.stream.javadsl.Source[Out]]]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.prefixAndTail" title="(n: Int)Source.this.delegate.Repr[(scala.collection.immutable.Seq[Out], akka.stream.scaladsl.Source[Out])]">prefixAndTail</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.prefixAndTail.n" title="Int">n</a><span class="delimiter">)</span>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.map" title="(f: ((scala.collection.immutable.Seq[Out], akka.stream.scaladsl.Source[Out])) =&gt; akka.japi.Pair[java.util.List[Out @scala.annotation.unchecked.uncheckedVariance],akka.stream.javadsl.Source[Out @scala.annotation.unchecked.uncheckedVariance]])Source.this.delegate.Repr[(scala.collection.immutable.Seq[Out], akka.stream.scaladsl.Source[Out])]#Repr[akka.japi.Pair[java.util.List[Out @scala.annotation.unchecked.uncheckedVariance],akka.stream.javadsl.Source[Out @scala.annotation.unchecked.uncheckedVariance]]]">map</a> <a href="#akka.stream.javadsl;Source.prefixAndTail.$anonfun.x0$1" title="akka.japi.Pair[java.util.List[Out @scala.annotation.unchecked.uncheckedVariance],akka.stream.javadsl.Source[Out @scala.annotation.unchecked.uncheckedVariance]]" class="delimiter">{</a> case <span class="delimiter">(</span><a title="scala.collection.immutable.Seq[Out]" id="akka.stream.javadsl;Source.prefixAndTail.$anonfun.taken">taken</a>, <a title="akka.stream.scaladsl.Source[Out]" id="akka.stream.javadsl;Source.prefixAndTail.$anonfun.tail">tail</a><span class="delimiter">)</span> ⇒ akka.japi.<span title="(first: java.util.List[Out], second: akka.stream.javadsl.Source[Out])akka.japi.Pair[java.util.List[Out],akka.stream.javadsl.Source[Out]]">Pair</span><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.prefixAndTail.$anonfun.taken" title="(b: Seq[Out])scala.collection.convert.Decorators.AsJava[java.util.List[Out]]">taken</a>.<span title="=&gt; java.util.List[Out]">asJava</span>, <a href="../scaladsl/JavaConverters.scala.html#akka.stream.scaladsl.JavaConverters.AddAsJavaSource(bfad1e55e6)" title="(source: akka.stream.scaladsl.Source[Out])akka.stream.scaladsl.JavaConverters.AddAsJavaSource[Out]">tail</a>.<a href="../scaladsl/JavaConverters.scala.html#akka.stream.scaladsl.JavaConverters;AddAsJavaSource.asJava" title="=&gt; akka.stream.javadsl.Source[Out]">asJava</a><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="comment">/**
   * This operation demultiplexes the incoming stream into separate output
   * streams, one for each element key. The key is computed for each element
   * using the given function. When a new key is encountered for the first time
   * it is emitted to the downstream subscriber together with a fresh
   * flow that will eventually produce all the elements of the substream
   * for that key. Not consuming the elements from the created streams will
   * stop this processor from processing more elements, therefore you must take
   * care to unblock (or cancel) all of the produced streams even if you want
   * to consume only one of them.
   */</span>
  def <a title="[K](f: akka.stream.javadsl.japi.Function[Out,K])akka.stream.javadsl.Source[akka.japi.Pair[K,akka.stream.javadsl.Source[Out]]]" id="akka.stream.javadsl;Source.groupBy">groupBy</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.groupBy;K">K</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.japi.Function[Out,K]" id="akka.stream.javadsl;Source.groupBy.f">f</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function" title="akka.stream.javadsl.japi.Function[Out,K]">Function</a><span class="delimiter">[</span>Out, K<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[akka.japi.Pair[K,akka.stream.javadsl.Source[Out @scala.annotation.unchecked.uncheckedVariance]]]">Source</a><span class="delimiter">[</span>akka.japi.Pair<span class="delimiter">[</span>K, javadsl.Source<span class="delimiter">[</span>Out @uncheckedVariance<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[akka.japi.Pair[K,akka.stream.javadsl.Source[Out]]]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.groupBy" title="(f: Out =&gt; K)Source.this.delegate.Repr[(K, akka.stream.scaladsl.Source[Out])]">groupBy</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.groupBy.f" title="akka.stream.javadsl.japi.Function[Out,K]">f</a>.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function.apply" title="(param: Out)K">apply</a><span class="delimiter">)</span>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.map" title="(f: ((K, akka.stream.scaladsl.Source[Out])) =&gt; akka.japi.Pair[K,akka.stream.javadsl.Source[Out @scala.annotation.unchecked.uncheckedVariance]])Source.this.delegate.Repr[(K, akka.stream.scaladsl.Source[Out])]#Repr[akka.japi.Pair[K,akka.stream.javadsl.Source[Out @scala.annotation.unchecked.uncheckedVariance]]]">map</a> <a href="#akka.stream.javadsl;Source.groupBy.$anonfun.x0$2" title="akka.japi.Pair[K,akka.stream.javadsl.Source[Out @scala.annotation.unchecked.uncheckedVariance]]" class="delimiter">{</a> case <span class="delimiter">(</span><a title="K" id="akka.stream.javadsl;Source.groupBy.$anonfun.k">k</a>, <a title="akka.stream.scaladsl.Source[Out]" id="akka.stream.javadsl;Source.groupBy.$anonfun.p">p</a><span class="delimiter">)</span> ⇒ akka.japi.<span title="(first: K, second: akka.stream.javadsl.Source[Out])akka.japi.Pair[K,akka.stream.javadsl.Source[Out]]">Pair</span><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.groupBy.$anonfun.k" title="K">k</a>, <a href="../scaladsl/JavaConverters.scala.html#akka.stream.scaladsl.JavaConverters.AddAsJavaSource(bfad1e55e6)" title="(source: akka.stream.scaladsl.Source[Out])akka.stream.scaladsl.JavaConverters.AddAsJavaSource[Out]">p</a>.<a href="../scaladsl/JavaConverters.scala.html#akka.stream.scaladsl.JavaConverters;AddAsJavaSource.asJava" title="=&gt; akka.stream.javadsl.Source[Out]">asJava</a><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span> <span class="comment">// FIXME optimize to one step</span>

  <span class="comment">/**
   * This operation applies the given predicate to all incoming elements and
   * emits them to a stream of output streams, always beginning a new one with
   * the current element if the given predicate returns true for it. This means
   * that for the following series of predicate values, three substreams will
   * be produced with lengths 1, 2, and 3:
   *
   * {{{
   * false,             // element goes into first substream
   * true, false,       // elements go into second substream
   * true, false, false // elements go into third substream
   * }}}
   */</span>
  def <a title="(p: akka.stream.javadsl.japi.Predicate[Out])akka.stream.javadsl.Source[akka.stream.javadsl.Source[Out]]" id="akka.stream.javadsl;Source.splitWhen">splitWhen</a><span class="delimiter">(</span><a title="akka.stream.javadsl.japi.Predicate[Out]" id="akka.stream.javadsl;Source.splitWhen.p">p</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Predicate" title="akka.stream.javadsl.japi.Predicate[Out]">Predicate</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[akka.stream.javadsl.Source[Out]]">Source</a><span class="delimiter">[</span>javadsl.Source<span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[akka.stream.javadsl.Source[Out]]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.splitWhen" title="(p: Out =&gt; Boolean)Source.this.delegate.Repr[akka.stream.scaladsl.Source[Out]]">splitWhen</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.splitWhen.p" title="akka.stream.javadsl.japi.Predicate[Out]">p</a>.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Predicate.test" title="(param: Out)Boolean">test</a><span class="delimiter">)</span>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.map" title="(f: akka.stream.scaladsl.Source[Out] =&gt; akka.stream.javadsl.Source[Out])Source.this.delegate.Repr[akka.stream.scaladsl.Source[Out]]#Repr[akka.stream.javadsl.Source[Out]]">map</a><span class="delimiter">(</span><a href="../scaladsl/JavaConverters.scala.html#akka.stream.scaladsl.JavaConverters.AddAsJavaSource(bfad1e55e6)" title="(source: akka.stream.scaladsl.Source[Out])akka.stream.scaladsl.JavaConverters.AddAsJavaSource[Out]">_</a>.<a href="../scaladsl/JavaConverters.scala.html#akka.stream.scaladsl.JavaConverters;AddAsJavaSource.asJava" title="=&gt; akka.stream.javadsl.Source[Out]">asJava</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Transforms a stream of streams into a contiguous stream of elements using the provided flattening strategy.
   * This operation can be used on a stream of element type [[Source]].
   */</span>
  def <a title="[U](strategy: akka.stream.FlattenStrategy[Out,U])akka.stream.javadsl.Source[U]" id="akka.stream.javadsl;Source.flatten">flatten</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.flatten;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.FlattenStrategy[Out,U]" id="akka.stream.javadsl;Source.flatten.strategy">strategy</a>: akka.stream.<a href="../FlattenStrategy.scala.html#akka.stream;FlattenStrategy" title="akka.stream.FlattenStrategy[Out,U]">FlattenStrategy</a><span class="delimiter">[</span>Out, U<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[U]">Source</a><span class="delimiter">[</span>U<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[U]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Flow.scala.html#akka.stream.scaladsl;FlowOps.flatten" title="(strategy: akka.stream.FlattenStrategy[Out,U])Source.this.delegate.Repr[U]">flatten</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.flatten.strategy" title="akka.stream.FlattenStrategy[Out,U]">strategy</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Add a key that will have a value available after materialization.
   * The key can only use other keys if they have been added to the source
   * before this key. This also includes the keyed source if applicable.
   */</span>
  def <a title="[T](key: akka.stream.javadsl.Key[T])akka.stream.javadsl.Source[Out]" id="akka.stream.javadsl;Source.withKey">withKey</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.withKey;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.Key[T]" id="akka.stream.javadsl;Source.withKey.key">key</a>: javadsl.<a href="MaterializedMap.scala.html#akka.stream.javadsl;Key" title="akka.stream.javadsl.Key[T]">Key</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">[</span>Out<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl;Source.withKey" title="(key: akka.stream.scaladsl.Key[_])akka.stream.scaladsl.Source[Out]">withKey</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.withKey.key" title="akka.stream.javadsl.Key[T]">key</a>.<a href="MaterializedMap.scala.html#akka.stream.javadsl;Key.asScala" title="=&gt; akka.stream.scaladsl.Key[T]">asScala</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Applies given [[OperationAttributes]] to a given section.
   */</span>
  def <a title="[O](attributes: akka.stream.javadsl.OperationAttributes, section: akka.stream.javadsl.japi.Function[akka.stream.javadsl.Source[Out],akka.stream.javadsl.Source[O]])akka.stream.javadsl.Source[O]" id="akka.stream.javadsl;Source.section">section</a><span class="delimiter">[</span><a title="" id="akka.stream.javadsl;Source.section;O">O</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="akka.stream.javadsl.OperationAttributes" id="akka.stream.javadsl;Source.section.attributes">attributes</a>: <a href="OperationAttributes.scala.html#akka.stream.javadsl;OperationAttributes" title="akka.stream.javadsl.OperationAttributes">OperationAttributes</a>, <a title="akka.stream.javadsl.japi.Function[akka.stream.javadsl.Source[Out],akka.stream.javadsl.Source[O]]" id="akka.stream.javadsl;Source.section.section">section</a>: japi.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function" title="akka.stream.javadsl.japi.Function[akka.stream.javadsl.Source[Out],akka.stream.javadsl.Source[O]]">Function</a><span class="delimiter">[</span>javadsl.Source<span class="delimiter">[</span>Out<span class="delimiter">]</span>, javadsl.Source<span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">[</span>O<span class="delimiter">]</span> =
    new <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.delegate" title="akka.stream.scaladsl.Source[Out]">delegate</a>.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl;Source.section" title="(attributes: akka.stream.scaladsl.OperationAttributes)(section: akka.stream.scaladsl.Source[Out] =&gt; akka.stream.scaladsl.Source[O])akka.stream.scaladsl.Source[O]">section</a><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.section.attributes" title="akka.stream.javadsl.OperationAttributes">attributes</a>.<a href="OperationAttributes.scala.html#akka.stream.javadsl;OperationAttributes.asScala" title="=&gt; akka.stream.scaladsl.OperationAttributes">asScala</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="akka.stream.scaladsl.Source[Out] =&gt; akka.stream.javadsl.Source[Out]" id="akka.stream.javadsl;Source.section.scalaToJava">scalaToJava</a> = <span class="delimiter">(</span>source: scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl;Source" title="akka.stream.scaladsl.Source[Out]">Source</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">)</span> ⇒ new javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">(</span><a href="#akka.stream.javadsl;Source.section.scalaToJava.$anonfun.source" title="akka.stream.scaladsl.Source[Out]">source</a><span class="delimiter">)</span>
      val <a title="akka.stream.javadsl.Source[O] =&gt; akka.stream.scaladsl.Source[O]" id="akka.stream.javadsl;Source.section.javaToScala">javaToScala</a> = <span class="delimiter">(</span>source: javadsl.<a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[O]">Source</a><span class="delimiter">[</span>O<span class="delimiter">]</span><span class="delimiter">)</span> ⇒ <a href="#akka.stream.javadsl;Source.section.javaToScala.$anonfun.source" title="akka.stream.javadsl.Source[O]">source</a>.<a href="#akka.stream.javadsl;Source.asScala" title="=&gt; akka.stream.scaladsl.Source[O]">asScala</a>
      <a href="#akka.stream.javadsl;Source.section.scalaToJava" title="akka.stream.scaladsl.Source[Out] =&gt; akka.stream.javadsl.Source[Out]">scalaToJava</a> <span title="(g: akka.stream.javadsl.Source[Out] =&gt; akka.stream.javadsl.Source[O])akka.stream.scaladsl.Source[Out] =&gt; akka.stream.javadsl.Source[O]">andThen</span> <a href="#akka.stream.javadsl;Source.section.section" title="akka.stream.javadsl.japi.Function[akka.stream.javadsl.Source[Out],akka.stream.javadsl.Source[O]]">section</a>.<a href="japi/WithVariance.scala.html#akka.stream.javadsl.japi;Function.apply" title="(param: akka.stream.javadsl.Source[Out])akka.stream.javadsl.Source[O]">apply</a> <span title="(g: akka.stream.javadsl.Source[O] =&gt; akka.stream.scaladsl.Source[O])akka.stream.scaladsl.Source[Out] =&gt; akka.stream.scaladsl.Source[O]">andThen</span> <a href="#akka.stream.javadsl;Source.section.javaToScala" title="akka.stream.javadsl.Source[O] =&gt; akka.stream.scaladsl.Source[O]">javaToScala</a>
    <span class="delimiter">}</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Java API
 *
 * A `Source` that will create an object during materialization that the user will need
 * to retrieve in order to access aspects of this source (could be a Subscriber, a Future/Promise, etc.).
 */</span>
final class <a title="class KeyedSource[+Out, M] extends akka.stream.javadsl.Source[Out] with akka.stream.javadsl.KeyedMaterializable[M]" id="akka.stream.javadsl;KeyedSource">KeyedSource</a><span class="delimiter">[</span>+<a title="" id="akka.stream.javadsl;KeyedSource;Out">Out</a>, <a title="" id="akka.stream.javadsl;KeyedSource;M">M</a><span class="delimiter">]</span><a href="#akka.stream.javadsl;KeyedSource" title="akka.stream.javadsl.KeyedSource[Out,M]" class="delimiter">(</a><a title="akka.stream.scaladsl.KeyedSource[Out,M]" id="akka.stream.javadsl;KeyedSource.delegate">delegate</a>: scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl;KeyedSource" title="akka.stream.scaladsl.KeyedSource[Out,M]">KeyedSource</a><span class="delimiter">[</span>Out, M<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#akka.stream.javadsl;Source" title="akka.stream.javadsl.Source[Out]">Source</a><span class="delimiter">[</span>Out<span class="delimiter">]</span><span class="delimiter">(</span><a href="#akka.stream.javadsl;KeyedSource.delegate" title="akka.stream.scaladsl.KeyedSource[Out,M]">delegate</a><span class="delimiter">)</span> with <a href="MaterializedMap.scala.html#akka.stream.javadsl;KeyedMaterializable" title="akka.stream.javadsl.KeyedMaterializable[M]">KeyedMaterializable</a><span class="delimiter">[</span>M<span class="delimiter">]</span> <span class="delimiter">{</span>
  override def <a title="=&gt; akka.stream.scaladsl.KeyedSource[Out,M]" id="akka.stream.javadsl;KeyedSource.asScala">asScala</a>: scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl;KeyedSource" title="akka.stream.scaladsl.KeyedSource[Out,M]">KeyedSource</a><span class="delimiter">[</span>Out, M<span class="delimiter">]</span> = super.<a href="#akka.stream.javadsl;Source.asScala" title="=&gt; akka.stream.scaladsl.Source[Out]">asScala</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="akka.stream.scaladsl.KeyedSource[Out,M]" class="delimiter">[</span>scaladsl.<a href="../scaladsl/Source.scala.html#akka.stream.scaladsl;KeyedSource" title="akka.stream.scaladsl.KeyedSource[Out,M]">KeyedSource</a><span class="delimiter">[</span>Out, M<span class="delimiter">]</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
