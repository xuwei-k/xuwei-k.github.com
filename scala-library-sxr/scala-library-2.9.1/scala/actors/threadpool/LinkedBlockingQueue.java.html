<?xml version="1.0" encoding="utf-8"?>
      <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <meta http-equiv="Expires" content="0" />
        <title>scala/actors/threadpool/LinkedBlockingQueue.java</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/licenses/publicdomain
 */</span>

<span class="keyword">package</span> scala.actors.threadpool;

<span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;
<span class="keyword">import</span> java.util.concurrent.locks.Condition;
<span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;
<span class="keyword">import</span> java.util.AbstractQueue;
<span class="keyword">import</span> java.util.Collection;
<span class="keyword">import</span> java.util.Iterator;
<span class="keyword">import</span> java.util.NoSuchElementException;

<span class="comment">/**
 * An optionally-bounded {@linkplain BlockingQueue blocking queue} based on
 * linked nodes.
 * This queue orders elements FIFO (first-in-first-out).
 * The &lt;em&gt;head&lt;/em&gt; of the queue is that element that has been on the
 * queue the longest time.
 * The &lt;em&gt;tail&lt;/em&gt; of the queue is that element that has been on the
 * queue the shortest time. New elements
 * are inserted at the tail of the queue, and the queue retrieval
 * operations obtain elements at the head of the queue.
 * Linked queues typically have higher throughput than array-based queues but
 * less predictable performance in most concurrent applications.
 *
 * &lt;p&gt; The optional capacity bound constructor argument serves as a
 * way to prevent excessive queue expansion. The capacity, if unspecified,
 * is equal to {@link Integer#MAX_VALUE}.  Linked nodes are
 * dynamically created upon each insertion unless this would bring the
 * queue above capacity.
 *
 * &lt;p&gt;This class and its iterator implement all of the
 * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Collection} and {@link
 * Iterator} interfaces.
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @since 1.5
 * @author Doug Lea
 * @param &lt;E&gt; the type of elements held in this collection
 *
 */</span>
public <span class="keyword">class</span> <a title="object scala.actors.threadpool.LinkedBlockingQueue" id="11741">LinkedBlockingQueue</a>&lt;<a title="Nothing" id="11918">E</a>&gt; <span class="keyword">extends</span> java.util.<span title="java.util.AbstractQueue">AbstractQueue</span>&lt;<a href="#11918" title="E">E</a>&gt;
        implements <a href="BlockingQueue.java.html#11834" title="scala.actors.threadpool.BlockingQueue">BlockingQueue</a>&lt;<a href="#11918" title="E">E</a>&gt;, java.io.<span title="java.io.Serializable">Serializable</span> <span class="delimiter">{</span>
    <span class="keyword">private</span> static <span class="keyword">final</span> long <a title="Long" id="87383">serialVersionUID</a> = -<span class="long">6903933977591709194L</span>;

    <span class="comment">/*
     * A variant of the &quot;two lock queue&quot; algorithm.  The putLock gates
     * entry to put (and offer), and has an associated condition for
     * waiting puts.  Similarly for the takeLock.  The &quot;count&quot; field
     * that they both rely on is maintained as an atomic to avoid
     * needing to get both locks in most cases. Also, to minimize need
     * for puts to get takeLock and vice-versa, cascading notifies are
     * used. When a put notices that it has enabled at least one take,
     * it signals taker. That taker in turn signals others if more
     * items have been entered since the signal. And symmetrically for
     * takes signalling puts. Operations such as remove(Object) and
     * iterators acquire both locks.
     *
     * Visibility between writers and readers is provided as follows:
     *
     * Whenever an element is enqueued, the putLock is acquired and
     * count updated.  A subsequent reader guarantees visibility to the
     * enqueued Node by either acquiring the putLock (via fullyLock)
     * or by acquiring the takeLock, and then reading n = count.get();
     * this gives visibility to the first n items.
     *
     * To implement weakly consistent iterators, it appears we need to
     * keep all Nodes GC-reachable from a predecessor dequeued Node.
     * That would cause two problems:
     * - allow a rogue Iterator to cause unbounded memory retention
     * - cause cross-generational linking of old Nodes to new Nodes if
     *   a Node was tenured while live, which generational GCs have a
     *   hard time dealing with, causing repeated major collections.
     * However, only non-deleted Nodes need to be reachable from
     * dequeued Nodes, and reachability does not necessarily have to
     * be of the kind understood by the GC.  We use the trick of
     * linking a Node that has just been dequeued to itself.  Such a
     * self-link implicitly means to advance to head.next.
     */</span>

    <span class="comment">/**
     * Linked list node class
     */</span>
    static <span class="keyword">class</span> <a title="object scala.actors.threadpool.LinkedBlockingQueue.Node" id="87386">Node</a>&lt;<a id="87387">E</a>&gt; <span class="delimiter">{</span>
        E item;

        <span class="comment">/**
         * One of:
         * - the real successor Node
         * - this Node, meaning the successor is head.next
         * - null, meaning there is no successor (this is the last node)
         */</span>
        Node&lt;E&gt; next;

        Node<span class="delimiter">(</span>E x<span class="delimiter">)</span> <span class="delimiter">{</span> item = x; <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/** The capacity bound, or Integer.MAX_VALUE if none */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> int <a title="Int" id="87323">capacity</a>;

    <span class="comment">/** Current number of elements */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <a href="AtomicInteger.java.html#11822" title="scala.actors.threadpool.AtomicInteger">AtomicInteger</a> <a title="scala.actors.threadpool.AtomicInteger" id="87324">count</a> = <span class="keyword">new</span> AtomicInteger<span class="delimiter">(</span><span class="int">0</span><span class="delimiter">)</span>;

    <span class="comment">/**
     * Head of linked list.
     * Invariant: head.item == null
     */</span>
    <span class="keyword">private</span> transient Node&lt;<a href="#11918" title="E">E</a>&gt; <a title="scala.actors.threadpool.LinkedBlockingQueue.Node[E]" id="87325">head</a>;

    <span class="comment">/**
     * Tail of linked list.
     * Invariant: last.next == null
     */</span>
    <span class="keyword">private</span> transient Node&lt;<a href="#11918" title="E">E</a>&gt; <a title="scala.actors.threadpool.LinkedBlockingQueue.Node[E]" id="87326">last</a>;

    <span class="comment">/** Lock held by take, poll, etc */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock <a title="java.util.concurrent.locks.ReentrantLock" id="87327">takeLock</a> = <span class="keyword">new</span> ReentrantLock<span class="delimiter">(</span><span class="delimiter">)</span>;

    <span class="comment">/** Wait queue for waiting takes */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> Condition <a title="java.util.concurrent.locks.Condition" id="87328">notEmpty</a> = takeLock.newCondition<span class="delimiter">(</span><span class="delimiter">)</span>;

    <span class="comment">/** Lock held by put, offer, etc */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock <a title="java.util.concurrent.locks.ReentrantLock" id="87329">putLock</a> = <span class="keyword">new</span> ReentrantLock<span class="delimiter">(</span><span class="delimiter">)</span>;

    <span class="comment">/** Wait queue for waiting puts */</span>
    <span class="keyword">private</span> <span class="keyword">final</span> Condition <a title="java.util.concurrent.locks.Condition" id="87330">notFull</a> = putLock.newCondition<span class="delimiter">(</span><span class="delimiter">)</span>;

    <span class="comment">/**
     * Signals a waiting take. Called only from put/offer (which do not
     * otherwise ordinarily lock takeLock.)
     */</span>
    <span class="keyword">private</span> void <a title="()Unit" id="87331">signalNotEmpty</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;
        takeLock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            notEmpty.signal<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            takeLock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Signals a waiting put. Called only from take/poll.
     */</span>
    <span class="keyword">private</span> void <a title="()Unit" id="87332">signalNotFull</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;
        putLock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            notFull.signal<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            putLock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Creates a node and links it at end of queue.
     *
     * @param x the item
     */</span>
    <span class="keyword">private</span> void <a title="(x: E)Unit" id="87333">enqueue</a><span class="delimiter">(</span><a href="#11918" title="E">E</a> <a title="E" id="2789854">x</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// assert putLock.isHeldByCurrentThread();</span>
        <span class="comment">// assert last.next == null;</span>
        last = last.next = <span class="keyword">new</span> Node&lt;E&gt;<span class="delimiter">(</span>x<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Removes a node from head of queue.
     *
     * @return the node
     */</span>
    <span class="keyword">private</span> <a href="#11918" title="E">E</a> <a title="()E" id="87334">dequeue</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// assert takeLock.isHeldByCurrentThread();</span>
        <span class="comment">// assert head.item == null;</span>
        Node&lt;E&gt; h = head;
        Node&lt;E&gt; first = h.next;
        h.next = h; <span class="comment">// help GC</span>
        head = first;
        E x = first.item;
        first.item = <span class="keyword">null</span>;
        <span class="keyword">return</span> x;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Lock to prevent both puts and takes.
     */</span>
    void <a title="()Unit" id="87335">fullyLock</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        putLock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
        takeLock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Unlock to allow both puts and takes.
     */</span>
    void <a title="()Unit" id="87336">fullyUnlock</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        takeLock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        putLock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

<span class="comment">//     /**</span>
<span class="comment">//      * Tells whether both locks are held by current thread.</span>
<span class="comment">//      */</span>
<span class="comment">//     boolean isFullyLocked() {</span>
<span class="comment">//         return (putLock.isHeldByCurrentThread() &amp;&amp;</span>
<span class="comment">//                 takeLock.isHeldByCurrentThread());</span>
<span class="comment">//     }</span>

    <span class="comment">/**
     * Creates a {@code LinkedBlockingQueue} with a capacity of
     * {@link Integer#MAX_VALUE}.
     */</span>
    public LinkedBlockingQueue<a href="#11741" title="scala.actors.threadpool.LinkedBlockingQueue[E]" class="delimiter">(</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">this</span><span class="delimiter">(</span>Integer.MAX_VALUE<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity.
     *
     * @param capacity the capacity of this queue
     * @throws IllegalArgumentException if {@code capacity} is not greater
     *         than zero
     */</span>
    public LinkedBlockingQueue<a title="(capacity: Int)scala.actors.threadpool.LinkedBlockingQueue[E]" id="87338" class="delimiter">(</a>int <a title="Int" id="87389">capacity</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>capacity &lt;= <span class="int">0</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">this</span>.capacity = capacity;
        last = head = <span class="keyword">new</span> Node&lt;E&gt;<span class="delimiter">(</span><span class="keyword">null</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Creates a {@code LinkedBlockingQueue} with a capacity of
     * {@link Integer#MAX_VALUE}, initially containing the elements of the
     * given collection,
     * added in traversal order of the collection's iterator.
     *
     * @param c the collection of elements to initially contain
     * @throws NullPointerException if the specified collection or any
     *         of its elements are null
     */</span>
    public LinkedBlockingQueue<a title="(c: java.util.Collection[_ &lt;: E])scala.actors.threadpool.LinkedBlockingQueue[E]" id="87339" class="delimiter">(</a>Collection&lt;? <span class="keyword">extends</span> <a href="#11918" title="E">E</a>&gt; <a title="java.util.Collection[_ &lt;: E]" id="87380">c</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">this</span><span class="delimiter">(</span>Integer.MAX_VALUE<span class="delimiter">)</span>;
        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;
        putLock.lock<span class="delimiter">(</span><span class="delimiter">)</span>; <span class="comment">// Never contended, but necessary for visibility</span>
        <span class="keyword">try</span> <span class="delimiter">{</span>
            int n = <span class="int">0</span>;
            <span class="keyword">for</span> <span class="delimiter">(</span>E e : c<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>e == <span class="keyword">null</span><span class="delimiter">)</span>
                    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span>n == capacity<span class="delimiter">)</span>
                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException<span class="delimiter">(</span><span class="string">&quot;Queue full&quot;</span><span class="delimiter">)</span>;
                enqueue<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                ++n;
            <span class="delimiter">}</span>
            count.set<span class="delimiter">(</span>n<span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            putLock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>


    <span class="comment">// this doc comment is overridden to remove the reference to collections</span>
    <span class="comment">// greater in size than Integer.MAX_VALUE</span>
    <span class="comment">/**
     * Returns the number of elements in this queue.
     *
     * @return the number of elements in this queue
     */</span>
    public int <a title="()Int" id="87340">size</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> count.get<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">// this doc comment is a modified copy of the inherited doc comment,</span>
    <span class="comment">// without the reference to unlimited queues.</span>
    <span class="comment">/**
     * Returns the number of additional elements that this queue can ideally
     * (in the absence of memory or resource constraints) accept without
     * blocking. This is always equal to the initial capacity of this queue
     * less the current {@code size} of this queue.
     *
     * &lt;p&gt;Note that you &lt;em&gt;cannot&lt;/em&gt; always tell if an attempt to insert
     * an element will succeed by inspecting {@code remainingCapacity}
     * because it may be the case that another thread is about to
     * insert or remove an element.
     */</span>
    public int <a title="()Int" id="87341">remainingCapacity</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> capacity - count.get<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Inserts the specified element at the tail of this queue, waiting if
     * necessary for space to become available.
     *
     * @throws InterruptedException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     */</span>
    public void <a title="(e: E)Unit" id="87342">put</a><span class="delimiter">(</span><a href="#11918" title="E">E</a> <a title="E" id="2789864">e</a><span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>e == <span class="keyword">null</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="comment">// Note: convention in all put/take/etc is to preset local var</span>
        <span class="comment">// holding count negative to indicate failure unless set.</span>
        int c = -<span class="int">1</span>;
        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;
        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;
        putLock.lockInterruptibly<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="comment">/*
             * Note that count is used in wait guard even though it is
             * not protected by lock. This works because count can
             * only decrease at this point (all other puts are shut
             * out by lock), and we (or some other waiting put) are
             * signalled if it ever changes from capacity. Similarly
             * for all other uses of count in other wait guards.
             */</span>
            <span class="keyword">while</span> <span class="delimiter">(</span>count.get<span class="delimiter">(</span><span class="delimiter">)</span> == capacity<span class="delimiter">)</span> <span class="delimiter">{</span>
                notFull.await<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            enqueue<span class="delimiter">(</span>e<span class="delimiter">)</span>;
            c = count.getAndIncrement<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>c + <span class="int">1</span> &lt; capacity<span class="delimiter">)</span>
                notFull.signal<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            putLock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>c == <span class="int">0</span><span class="delimiter">)</span>
            signalNotEmpty<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Inserts the specified element at the tail of this queue, waiting if
     * necessary up to the specified wait time for space to become available.
     *
     * @return {@code true} if successful, or {@code false} if
     *         the specified waiting time elapses before space is available.
     * @throws InterruptedException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     */</span>
    public boolean <a title="(e: E, timeout: Long, unit: scala.actors.threadpool.TimeUnit)Boolean" id="87343">offer</a><span class="delimiter">(</span><a href="#11918" title="E">E</a> <a title="E" id="2789867">e</a>, long <a title="Long" id="2789868">timeout</a>, <a href="TimeUnit.java.html#11801" title="scala.actors.threadpool.TimeUnit">TimeUnit</a> <a title="scala.actors.threadpool.TimeUnit" id="2789869">unit</a><span class="delimiter">)</span>
        throws InterruptedException <span class="delimiter">{</span>

        <span class="keyword">if</span> <span class="delimiter">(</span>e == <span class="keyword">null</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        long nanos = unit.toNanos<span class="delimiter">(</span>timeout<span class="delimiter">)</span>;
        int c = -<span class="int">1</span>;
        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;
        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;
        putLock.lockInterruptibly<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">while</span> <span class="delimiter">(</span>count.get<span class="delimiter">(</span><span class="delimiter">)</span> == capacity<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>nanos &lt;= <span class="int">0</span><span class="delimiter">)</span>
                    <span class="keyword">return</span> <span class="keyword">false</span>;
                nanos = notFull.awaitNanos<span class="delimiter">(</span>nanos<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            enqueue<span class="delimiter">(</span>e<span class="delimiter">)</span>;
            c = count.getAndIncrement<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>c + <span class="int">1</span> &lt; capacity<span class="delimiter">)</span>
                notFull.signal<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            putLock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>c == <span class="int">0</span><span class="delimiter">)</span>
            signalNotEmpty<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">return</span> <span class="keyword">true</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Inserts the specified element at the tail of this queue if it is
     * possible to do so immediately without exceeding the queue's capacity,
     * returning {@code true} upon success and {@code false} if this queue
     * is full.
     * When using a capacity-restricted queue, this method is generally
     * preferable to method {@link BlockingQueue#add add}, which can fail to
     * insert an element only by throwing an exception.
     *
     * @throws NullPointerException if the specified element is null
     */</span>
    public boolean <a title="(e: E)Boolean" id="87344">offer</a><span class="delimiter">(</span><a href="#11918" title="E">E</a> <a title="E" id="2789878">e</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>e == <span class="keyword">null</span><span class="delimiter">)</span> <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;
        <span class="keyword">if</span> <span class="delimiter">(</span>count.get<span class="delimiter">(</span><span class="delimiter">)</span> == capacity<span class="delimiter">)</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
        int c = -<span class="int">1</span>;
        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;
        putLock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>count.get<span class="delimiter">(</span><span class="delimiter">)</span> &lt; capacity<span class="delimiter">)</span> <span class="delimiter">{</span>
                enqueue<span class="delimiter">(</span>e<span class="delimiter">)</span>;
                c = count.getAndIncrement<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span>c + <span class="int">1</span> &lt; capacity<span class="delimiter">)</span>
                    notFull.signal<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            putLock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>c == <span class="int">0</span><span class="delimiter">)</span>
            signalNotEmpty<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">return</span> c &gt;= <span class="int">0</span>;
    <span class="delimiter">}</span>


    public <a href="#11918" title="E">E</a> <a title="()E" id="87345">take</a><span class="delimiter">(</span><span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
        E x;
        int c = -<span class="int">1</span>;
        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;
        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;
        takeLock.lockInterruptibly<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">while</span> <span class="delimiter">(</span>count.get<span class="delimiter">(</span><span class="delimiter">)</span> == <span class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                notEmpty.await<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            x = dequeue<span class="delimiter">(</span><span class="delimiter">)</span>;
            c = count.getAndDecrement<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>c &gt; <span class="int">1</span><span class="delimiter">)</span>
                notEmpty.signal<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            takeLock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>c == capacity<span class="delimiter">)</span>
            signalNotFull<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">return</span> x;
    <span class="delimiter">}</span>

    public <a href="#11918" title="E">E</a> <a title="(timeout: Long, unit: scala.actors.threadpool.TimeUnit)E" id="87346">poll</a><span class="delimiter">(</span>long <a title="Long" id="2789885">timeout</a>, <a href="TimeUnit.java.html#11801" title="scala.actors.threadpool.TimeUnit">TimeUnit</a> <a title="scala.actors.threadpool.TimeUnit" id="2789886">unit</a><span class="delimiter">)</span> throws InterruptedException <span class="delimiter">{</span>
        E x = <span class="keyword">null</span>;
        int c = -<span class="int">1</span>;
        long nanos = unit.toNanos<span class="delimiter">(</span>timeout<span class="delimiter">)</span>;
        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;
        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;
        takeLock.lockInterruptibly<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">while</span> <span class="delimiter">(</span>count.get<span class="delimiter">(</span><span class="delimiter">)</span> == <span class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>nanos &lt;= <span class="int">0</span><span class="delimiter">)</span>
                    <span class="keyword">return</span> <span class="keyword">null</span>;
                nanos = notEmpty.awaitNanos<span class="delimiter">(</span>nanos<span class="delimiter">)</span>;
            <span class="delimiter">}</span>
            x = dequeue<span class="delimiter">(</span><span class="delimiter">)</span>;
            c = count.getAndDecrement<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>c &gt; <span class="int">1</span><span class="delimiter">)</span>
                notEmpty.signal<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            takeLock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>c == capacity<span class="delimiter">)</span>
            signalNotFull<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">return</span> x;
    <span class="delimiter">}</span>

    public <a href="#11918" title="E">E</a> <a title="()E" id="87347">poll</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;
        <span class="keyword">if</span> <span class="delimiter">(</span>count.get<span class="delimiter">(</span><span class="delimiter">)</span> == <span class="int">0</span><span class="delimiter">)</span>
            <span class="keyword">return</span> <span class="keyword">null</span>;
        E x = <span class="keyword">null</span>;
        int c = -<span class="int">1</span>;
        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;
        takeLock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>count.get<span class="delimiter">(</span><span class="delimiter">)</span> &gt; <span class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                x = dequeue<span class="delimiter">(</span><span class="delimiter">)</span>;
                c = count.getAndDecrement<span class="delimiter">(</span><span class="delimiter">)</span>;
                <span class="keyword">if</span> <span class="delimiter">(</span>c &gt; <span class="int">1</span><span class="delimiter">)</span>
                    notEmpty.signal<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            takeLock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>c == capacity<span class="delimiter">)</span>
            signalNotFull<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">return</span> x;
    <span class="delimiter">}</span>

    public <a href="#11918" title="E">E</a> <a title="()E" id="87348">peek</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>count.get<span class="delimiter">(</span><span class="delimiter">)</span> == <span class="int">0</span><span class="delimiter">)</span>
            <span class="keyword">return</span> <span class="keyword">null</span>;
        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;
        takeLock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            Node&lt;E&gt; first = head.next;
            <span class="keyword">if</span> <span class="delimiter">(</span>first == <span class="keyword">null</span><span class="delimiter">)</span>
                <span class="keyword">return</span> <span class="keyword">null</span>;
            <span class="keyword">else</span>
                <span class="keyword">return</span> first.item;
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            takeLock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Unlinks interior Node p with predecessor trail.
     */</span>
    void <a title="(p: scala.actors.threadpool.LinkedBlockingQueue.Node[E], trail: scala.actors.threadpool.LinkedBlockingQueue.Node[E])Unit" id="87349">unlink</a><span class="delimiter">(</span>Node&lt;<a href="#11918" title="E">E</a>&gt; <a title="scala.actors.threadpool.LinkedBlockingQueue.Node[E]" id="2789892">p</a>, Node&lt;<a href="#11918" title="E">E</a>&gt; <a title="scala.actors.threadpool.LinkedBlockingQueue.Node[E]" id="2789893">trail</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// assert isFullyLocked();</span>
        <span class="comment">// p.next is not changed, to allow iterators that are</span>
        <span class="comment">// traversing p to maintain their weak-consistency guarantee.</span>
        p.item = <span class="keyword">null</span>;
        trail.next = p.next;
        <span class="keyword">if</span> <span class="delimiter">(</span>last == p<span class="delimiter">)</span>
            last = trail;
        <span class="keyword">if</span> <span class="delimiter">(</span>count.getAndDecrement<span class="delimiter">(</span><span class="delimiter">)</span> == capacity<span class="delimiter">)</span>
            notFull.signal<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Removes a single instance of the specified element from this queue,
     * if it is present.  More formally, removes an element {@code e} such
     * that {@code o.equals(e)}, if this queue contains one or more such
     * elements.
     * Returns {@code true} if this queue contained the specified element
     * (or equivalently, if this queue changed as a result of the call).
     *
     * @param o element to be removed from this queue, if present
     * @return {@code true} if this queue changed as a result of the call
     */</span>
    public boolean <a title="(o: Any)Boolean" id="87350">remove</a><span class="delimiter">(</span>Object <a title="Any" id="2789895">o</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>o == <span class="keyword">null</span><span class="delimiter">)</span> <span class="keyword">return</span> <span class="keyword">false</span>;
        fullyLock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">for</span> <span class="delimiter">(</span>Node&lt;E&gt; trail = head, p = trail.next;
                 p != <span class="keyword">null</span>;
                 trail = p, p = p.next<span class="delimiter">)</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>o.equals<span class="delimiter">(</span>p.item<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    unlink<span class="delimiter">(</span>p, trail<span class="delimiter">)</span>;
                    <span class="keyword">return</span> <span class="keyword">true</span>;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            fullyUnlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns an array containing all of the elements in this queue, in
     * proper sequence.
     *
     * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
     * maintained by this queue.  (In other words, this method must allocate
     * a new array).  The caller is thus free to modify the returned array.
     *
     * &lt;p&gt;This method acts as bridge between array-based and collection-based
     * APIs.
     *
     * @return an array containing all of the elements in this queue
     */</span>
    public Object<span class="delimiter">[</span><a href="../../Array.scala.html#1426" title="Array" class="delimiter">]</a> <a title="()Array[java.lang.Object]" id="87351">toArray</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        fullyLock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            int size = count.get<span class="delimiter">(</span><span class="delimiter">)</span>;
            Object<span class="delimiter">[</span><span class="delimiter">]</span> a = <span class="keyword">new</span> Object<span class="delimiter">[</span>size<span class="delimiter">]</span>;
            int k = <span class="int">0</span>;
            <span class="keyword">for</span> <span class="delimiter">(</span>Node&lt;E&gt; p = head.next; p != <span class="keyword">null</span>; p = p.next<span class="delimiter">)</span>
                a<span class="delimiter">[</span>k++<span class="delimiter">]</span> = p.item;
            <span class="keyword">return</span> a;
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            fullyUnlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns an array containing all of the elements in this queue, in
     * proper sequence; the runtime type of the returned array is that of
     * the specified array.  If the queue fits in the specified array, it
     * is returned therein.  Otherwise, a new array is allocated with the
     * runtime type of the specified array and the size of this queue.
     *
     * &lt;p&gt;If this queue fits in the specified array with room to spare
     * (i.e., the array has more elements than this queue), the element in
     * the array immediately following the end of the queue is set to
     * {@code null}.
     *
     * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between
     * array-based and collection-based APIs.  Further, this method allows
     * precise control over the runtime type of the output array, and may,
     * under certain circumstances, be used to save allocation costs.
     *
     * &lt;p&gt;Suppose {@code x} is a queue known to contain only strings.
     * The following code can be used to dump the queue into a newly
     * allocated array of {@code String}:
     *
     * &lt;pre&gt;
     *     String[] y = x.toArray(new String[0]);&lt;/pre&gt;
     *
     * Note that {@code toArray(new Object[0])} is identical in function to
     * {@code toArray()}.
     *
     * @param a the array into which the elements of the queue are to
     *          be stored, if it is big enough; otherwise, a new array of the
     *          same runtime type is allocated for this purpose
     * @return an array containing all of the elements in this queue
     * @throws ArrayStoreException if the runtime type of the specified array
     *         is not a supertype of the runtime type of every element in
     *         this queue
     * @throws NullPointerException if the specified array is null
     */</span>
    @SuppressWarnings<span class="delimiter">(</span><span class="string">&quot;unchecked&quot;</span><span class="delimiter">)</span>
    public &lt;<a title="Nothing" id="87354">T</a>&gt; <a href="#87354" title="T">T</a><span class="delimiter">[</span><a href="../../Array.scala.html#1426" title="Array" class="delimiter">]</a> <a title="[T](a: Array[T with java.lang.Object])Array[T with java.lang.Object]" id="87352">toArray</a><span class="delimiter">(</span><a href="#87354" title="T">T</a><span class="delimiter">[</span><a href="../../Array.scala.html#1426" title="Array" class="delimiter">]</a> <a title="Array[T]" id="2789904">a</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        fullyLock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            int size = count.get<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>a.length &lt; size<span class="delimiter">)</span>
                a = <span class="delimiter">(</span>T<span class="delimiter">[</span><span class="delimiter">]</span><span class="delimiter">)</span>java.lang.reflect.Array.newInstance
                    <span class="delimiter">(</span>a.getClass<span class="delimiter">(</span><span class="delimiter">)</span>.getComponentType<span class="delimiter">(</span><span class="delimiter">)</span>, size<span class="delimiter">)</span>;

            int k = <span class="int">0</span>;
            <span class="keyword">for</span> <span class="delimiter">(</span>Node&lt;E&gt; p = head.next; p != <span class="keyword">null</span>; p = p.next<span class="delimiter">)</span>
                a<span class="delimiter">[</span>k++<span class="delimiter">]</span> = <span class="delimiter">(</span>T<span class="delimiter">)</span>p.item;
            <span class="keyword">if</span> <span class="delimiter">(</span>a.length &gt; k<span class="delimiter">)</span>
                a<span class="delimiter">[</span>k<span class="delimiter">]</span> = <span class="keyword">null</span>;
            <span class="keyword">return</span> a;
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            fullyUnlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    public String <a title="()java.lang.String" id="87355">toString</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        fullyLock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> <span class="keyword">super</span>.toString<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            fullyUnlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Atomically removes all of the elements from this queue.
     * The queue will be empty after this call returns.
     */</span>
    public void <a title="()Unit" id="87356">clear</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        fullyLock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="keyword">for</span> <span class="delimiter">(</span>Node&lt;E&gt; p, h = head; <span class="delimiter">(</span>p = h.next<span class="delimiter">)</span> != <span class="keyword">null</span>; h = p<span class="delimiter">)</span> <span class="delimiter">{</span>
                h.next = h;
                p.item = <span class="keyword">null</span>;
            <span class="delimiter">}</span>
            head = last;
            <span class="comment">// assert head.item == null &amp;&amp; head.next == null;</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>count.getAndSet<span class="delimiter">(</span><span class="int">0</span><span class="delimiter">)</span> == capacity<span class="delimiter">)</span>
                notFull.signal<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            fullyUnlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException            {@inheritDoc}
     * @throws NullPointerException          {@inheritDoc}
     * @throws IllegalArgumentException      {@inheritDoc}
     */</span>
    public int <a title="(c: java.util.Collection[_ &gt;: E])Int" id="87357">drainTo</a><span class="delimiter">(</span>Collection&lt;? <span class="keyword">super</span> <a href="#11918" title="E">E</a>&gt; <a title="java.util.Collection[_ &gt;: E]" id="2789921">c</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">return</span> drainTo<span class="delimiter">(</span>c, Integer.MAX_VALUE<span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="comment">/**
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException            {@inheritDoc}
     * @throws NullPointerException          {@inheritDoc}
     * @throws IllegalArgumentException      {@inheritDoc}
     */</span>
    public int <a title="(c: java.util.Collection[_ &gt;: E], maxElements: Int)Int" id="87358">drainTo</a><span class="delimiter">(</span>Collection&lt;? <span class="keyword">super</span> <a href="#11918" title="E">E</a>&gt; <a title="java.util.Collection[_ &gt;: E]" id="2789935">c</a>, int <a title="Int" id="2789936">maxElements</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">if</span> <span class="delimiter">(</span>c == <span class="keyword">null</span><span class="delimiter">)</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">if</span> <span class="delimiter">(</span>c == <span class="keyword">this</span><span class="delimiter">)</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException<span class="delimiter">(</span><span class="delimiter">)</span>;
        boolean signalNotFull = <span class="keyword">false</span>;
        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;
        takeLock.lock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            int n = Math.min<span class="delimiter">(</span>maxElements, count.get<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>;
            <span class="comment">// count.get provides visibility to first n Nodes</span>
            Node&lt;E&gt; h = head;
            int i = <span class="int">0</span>;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                <span class="keyword">while</span> <span class="delimiter">(</span>i &lt; n<span class="delimiter">)</span> <span class="delimiter">{</span>
                    Node&lt;E&gt; p = h.next;
                    c.add<span class="delimiter">(</span>p.item<span class="delimiter">)</span>;
                    p.item = <span class="keyword">null</span>;
                    h.next = h;
                    h = p;
                    ++i;
                <span class="delimiter">}</span>
                <span class="keyword">return</span> n;
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                <span class="comment">// Restore invariants even if c.add() threw</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>i &gt; <span class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="comment">// assert h.item == null;</span>
                    head = h;
                    signalNotFull = <span class="delimiter">(</span>count.getAndAdd<span class="delimiter">(</span>-i<span class="delimiter">)</span> == capacity<span class="delimiter">)</span>;
                <span class="delimiter">}</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            takeLock.unlock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>signalNotFull<span class="delimiter">)</span>
                signalNotFull<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Returns an iterator over the elements in this queue in proper sequence.
     * The returned {@code Iterator} is a &quot;weakly consistent&quot; iterator that
     * will never throw {@link java.util.ConcurrentModificationException
     * ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     *
     * @return an iterator over the elements in this queue in proper sequence
     */</span>
    public Iterator&lt;<a href="#11918" title="E">E</a>&gt; <a title="()java.util.Iterator[E]" id="87359">iterator</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">return</span> <span class="keyword">new</span> Itr<span class="delimiter">(</span><span class="delimiter">)</span>;
    <span class="delimiter">}</span>

    <span class="keyword">private</span> <span class="keyword">class</span> <a title="object LinkedBlockingQueue.this.Itr" id="87362">Itr</a> implements Iterator&lt;E&gt; <span class="delimiter">{</span>
        <span class="comment">/*
         * Basic weakly-consistent iterator.  At all times hold the next
         * item to hand out so that if hasNext() reports true, we will
         * still have it to return even if lost race with a take etc.
         */</span>
        <span class="keyword">private</span> Node&lt;E&gt; current;
        <span class="keyword">private</span> Node&lt;E&gt; lastRet;
        <span class="keyword">private</span> E currentElement;

        Itr<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            fullyLock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                current = head.next;
                <span class="keyword">if</span> <span class="delimiter">(</span>current != <span class="keyword">null</span><span class="delimiter">)</span>
                    currentElement = current.item;
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                fullyUnlock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        public boolean hasNext<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">return</span> current != <span class="keyword">null</span>;
        <span class="delimiter">}</span>

        <span class="comment">/**
         * Returns the next live successor of p, or null if no such.
         *
         * Unlike other traversal methods, iterators need to handle both:
         * - dequeued nodes (p.next == p)
         * - (possibly multiple) interior removed nodes (p.item == null)
         */</span>
        <span class="keyword">private</span> Node&lt;E&gt; nextNode<span class="delimiter">(</span>Node&lt;E&gt; p<span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">for</span> <span class="delimiter">(</span>;;<span class="delimiter">)</span> <span class="delimiter">{</span>
                Node&lt;E&gt; s = p.next;
                <span class="keyword">if</span> <span class="delimiter">(</span>s == p<span class="delimiter">)</span>
                    <span class="keyword">return</span> head.next;
                <span class="keyword">if</span> <span class="delimiter">(</span>s == <span class="keyword">null</span> || s.item != <span class="keyword">null</span><span class="delimiter">)</span>
                    <span class="keyword">return</span> s;
                p = s;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        public E next<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            fullyLock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                <span class="keyword">if</span> <span class="delimiter">(</span>current == <span class="keyword">null</span><span class="delimiter">)</span>
                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException<span class="delimiter">(</span><span class="delimiter">)</span>;
                E x = currentElement;
                lastRet = current;
                current = nextNode<span class="delimiter">(</span>current<span class="delimiter">)</span>;
                currentElement = <span class="delimiter">(</span>current == <span class="keyword">null</span><span class="delimiter">)</span> ? <span class="keyword">null</span> : current.item;
                <span class="keyword">return</span> x;
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                fullyUnlock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>

        public void remove<span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="keyword">if</span> <span class="delimiter">(</span>lastRet == <span class="keyword">null</span><span class="delimiter">)</span>
                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException<span class="delimiter">(</span><span class="delimiter">)</span>;
            fullyLock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">try</span> <span class="delimiter">{</span>
                Node&lt;E&gt; node = lastRet;
                lastRet = <span class="keyword">null</span>;
                <span class="keyword">for</span> <span class="delimiter">(</span>Node&lt;E&gt; trail = head, p = trail.next;
                     p != <span class="keyword">null</span>;
                     trail = p, p = p.next<span class="delimiter">)</span> <span class="delimiter">{</span>
                    <span class="keyword">if</span> <span class="delimiter">(</span>p == node<span class="delimiter">)</span> <span class="delimiter">{</span>
                        unlink<span class="delimiter">(</span>p, trail<span class="delimiter">)</span>;
                        break;
                    <span class="delimiter">}</span>
                <span class="delimiter">}</span>
            <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
                fullyUnlock<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Save the state to a stream (that is, serialize it).
     *
     * @serialData The capacity is emitted (int), followed by all of
     * its elements (each an {@code Object}) in the proper order,
     * followed by a null
     * @param s the stream
     */</span>
    <span class="keyword">private</span> void <a title="(s: java.io.ObjectOutputStream)Unit" id="87363">writeObject</a><span class="delimiter">(</span>java.io.<span title="java.io.ObjectOutputStream">ObjectOutputStream</span> <a title="java.io.ObjectOutputStream" id="2789943">s</a><span class="delimiter">)</span>
        throws java.io.IOException <span class="delimiter">{</span>

        fullyLock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="keyword">try</span> <span class="delimiter">{</span>
            <span class="comment">// Write out any hidden stuff, plus capacity</span>
            s.defaultWriteObject<span class="delimiter">(</span><span class="delimiter">)</span>;

            <span class="comment">// Write out all elements in the proper order.</span>
            <span class="keyword">for</span> <span class="delimiter">(</span>Node&lt;E&gt; p = head.next; p != <span class="keyword">null</span>; p = p.next<span class="delimiter">)</span>
                s.writeObject<span class="delimiter">(</span>p.item<span class="delimiter">)</span>;

            <span class="comment">// Use trailing null as sentinel</span>
            s.writeObject<span class="delimiter">(</span><span class="keyword">null</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span>
            fullyUnlock<span class="delimiter">(</span><span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Reconstitute this queue instance from a stream (that is,
     * deserialize it).
     *
     * @param s the stream
     */</span>
    <span class="keyword">private</span> void <a title="(s: java.io.ObjectInputStream)Unit" id="87364">readObject</a><span class="delimiter">(</span>java.io.<span title="java.io.ObjectInputStream">ObjectInputStream</span> <a title="java.io.ObjectInputStream" id="2789945">s</a><span class="delimiter">)</span>
        throws java.io.IOException, ClassNotFoundException <span class="delimiter">{</span>
        <span class="comment">// Read in capacity, and any hidden stuff</span>
        s.defaultReadObject<span class="delimiter">(</span><span class="delimiter">)</span>;

        count.set<span class="delimiter">(</span><span class="int">0</span><span class="delimiter">)</span>;
        last = head = <span class="keyword">new</span> Node&lt;E&gt;<span class="delimiter">(</span><span class="keyword">null</span><span class="delimiter">)</span>;

        <span class="comment">// Read in all elements and place in queue</span>
        <span class="keyword">for</span> <span class="delimiter">(</span>;;<span class="delimiter">)</span> <span class="delimiter">{</span>
            @SuppressWarnings<span class="delimiter">(</span><span class="string">&quot;unchecked&quot;</span><span class="delimiter">)</span>
            E item = <span class="delimiter">(</span>E<span class="delimiter">)</span>s.readObject<span class="delimiter">(</span><span class="delimiter">)</span>;
            <span class="keyword">if</span> <span class="delimiter">(</span>item == <span class="keyword">null</span><span class="delimiter">)</span>
                break;
            add<span class="delimiter">(</span>item<span class="delimiter">)</span>;
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>