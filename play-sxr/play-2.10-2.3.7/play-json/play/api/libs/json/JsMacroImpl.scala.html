<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>play-json/play/api/libs/json/JsMacroImpl.scala</title>
        <script type="text/javascript" src="../../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (C) 2009-2013 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
<span class="keyword">package</span> play.api.libs.json

<span class="keyword">import</span> scala.<span title="language.type">language</span>.reflectiveCalls
<span class="keyword">import</span> scala.reflect.macros.Context
<span class="keyword">import</span> <span title="language.type">language</span>.<span title="language.experimental.type">experimental</span>.macros

<span class="keyword">object</span> <a title="play.api.libs.json.JsMacroImpl.type" id="play.api.libs.json.JsMacroImpl">JsMacroImpl</a> <a href="#play.api.libs.json.JsMacroImpl" title="play.api.libs.json.JsMacroImpl.type" class="delimiter">{</a>
  <span class="keyword">def</span> <a title="[A](c: scala.reflect.macros.Context)(implicit evidence$1: c.WeakTypeTag[A])c.Expr[play.api.libs.json.Reads[A]]" id="play.api.libs.json.JsMacroImpl.readsImpl">readsImpl</a><span class="delimiter">[</span><a title="" id="play.api.libs.json.JsMacroImpl.readsImpl;A">A</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="play.api.libs.json.JsMacroImpl.readsImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span>: c.<span title="c.Expr[play.api.libs.json.Reads[A]]">Expr</span><span class="delimiter">[</span>Reads<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">import</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
    <span class="keyword">import</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="=&gt; c.universe.FlagValues">Flag</span>._

    <span class="keyword">val</span> <a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.readsImpl.companioned">companioned</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.evidence$1" title="(implicit attag: c.universe.WeakTypeTag[A])c.universe.Type" class="delimiter">[</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl;A" title="A">A</a><span class="delimiter">]</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span>
    <span class="keyword">val</span> <a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.readsImpl.companionSymbol">companionSymbol</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.companioned" title="c.universe.Symbol">companioned</a>.<span title="=&gt; c.universe.Symbol">companionSymbol</span>
    <span class="keyword">val</span> <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.companionType">companionType</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a>.<span title="=&gt; c.universe.Type">typeSignature</span>

    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.readsImpl.libsPkg">libsPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;play&quot;)" class="string">&quot;play&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;api&quot;)" class="string">&quot;api&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;libs&quot;)" class="string">&quot;libs&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.readsImpl.jsonPkg">jsonPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.libsPkg" title="c.universe.Select">libsPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;json&quot;)" class="string">&quot;json&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.readsImpl.functionalSyntaxPkg">functionalSyntaxPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.libsPkg" title="c.universe.Select">libsPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;functional&quot;)" class="string">&quot;functional&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;syntax&quot;)" class="string">&quot;syntax&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.readsImpl.utilPkg">utilPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.jsonPkg" title="c.universe.Select">jsonPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;util&quot;)" class="string">&quot;util&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.readsImpl.jsPathSelect">jsPathSelect</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.jsonPkg" title="c.universe.Select">jsonPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;JsPath&quot;)" class="string">&quot;JsPath&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.readsImpl.readsSelect">readsSelect</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.jsonPkg" title="c.universe.Select">jsonPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;Reads&quot;)" class="string">&quot;Reads&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.readsImpl.unliftIdent">unliftIdent</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.functionalSyntaxPkg" title="c.universe.Select">functionalSyntaxPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;unlift&quot;)" class="string">&quot;unlift&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.readsImpl.lazyHelperSelect">lazyHelperSelect</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.utilPkg" title="c.universe.Select">utilPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;LazyHelper&quot;)" class="string">&quot;LazyHelper&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <a href="#play.api.libs.json.JsMacroImpl.readsImpl.companionType" title="c.universe.Type">companionType</a>.<span title="(name: c.universe.Name)c.universe.Symbol">declaration</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="implicit scala.reflect.api.Names.stringToTermName : (s: String)c.universe.TermName">stringToTermName</a><span class="delimiter">(</span><span title="String(&quot;unapply&quot;)" class="string">&quot;unapply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="c.Expr[play.api.libs.json.Reads[A]]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.Symbol">NoSymbol</a> =&gt; <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;No unapply function found&quot;)" class="string">&quot;No unapply function found&quot;</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="c.universe.Symbol">s</span> =&gt;
        <span class="keyword">val</span> <a title="c.universe.MethodSymbol" id="play.api.libs.json.JsMacroImpl.readsImpl.unapply">unapply</a> = <span title="c.universe.Symbol">s</span>.<span title="=&gt; c.universe.MethodSymbol">asMethod</span>
        <span class="keyword">val</span> <a title="Any" id="play.api.libs.json.JsMacroImpl.readsImpl.unapplyReturnTypes">unapplyReturnTypes</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.unapply" title="c.universe.MethodSymbol">unapply</a>.<span title="=&gt; c.universe.Type">returnType</span> <span title="Any" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> =&gt;
            <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Apply of &quot;)">Apply of $</span><span class="delimiter">{</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a><span class="delimiter">}</span><span title="String(&quot; has no parameters. Are you using an empty case class?&quot;)" class="string"> has no parameters. Are you using an empty case class?&quot;</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="List[c.universe.Type]">args</span><span class="delimiter">)</span> =&gt;
            <span title="List[c.universe.Type]">args</span>.<span title="=&gt; c.universe.Type">head</span> <span title="Any" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="c.universe.TypeRef">t</span> @ <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> =&gt; <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">case</span> <span title="c.universe.TypeRef">t</span> @ <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="List[c.universe.Type]">args</span><span class="delimiter">)</span> =&gt;
                <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.unapplyReturnTypes;$typecreator1.apply.symdef$_$11" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit ttag: c.universe.TypeTag[Seq[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.unapplyReturnTypes;$typecreator2.apply.symdef$_$21" class="delimiter">[</a><span title="Seq[_]">Seq</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit ttag: c.universe.TypeTag[Set[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.unapplyReturnTypes;$typecreator3.apply.symdef$_$31" class="delimiter">[</a><span title="Set[_]">Set</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit ttag: c.universe.TypeTag[Map[_, _]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.unapplyReturnTypes;$typecreator4.apply.symdef$_$51" class="delimiter">[</a><span title="Map[_, _]">Map</span><span class="delimiter">[</span>_, _<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit ttag: c.universe.TypeTag[Product])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.unapplyReturnTypes;$typecreator5.apply.$m" class="delimiter">[</a><span title="Product">Product</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.Type])Some[List[c.universe.Type]]">Some</span><span class="delimiter">(</span><span title="List[c.universe.Type]">args</span><span class="delimiter">)</span>
              <span class="keyword">case</span> _ =&gt; <span title="None.type">None</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> _ =&gt; <span title="None.type">None</span>
        <span class="delimiter">}</span>

        <span class="comment">//println(&quot;Unapply return type:&quot; + unapply.returnType)</span>

        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.companionType" title="c.universe.Type">companionType</a>.<span title="(name: c.universe.Name)c.universe.Symbol">declaration</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="implicit scala.reflect.api.Names.stringToTermName : (s: String)c.universe.TermName">stringToTermName</a><span class="delimiter">(</span><span title="String(&quot;apply&quot;)" class="string">&quot;apply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="c.Expr[play.api.libs.json.Reads[A]]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.Symbol">NoSymbol</a> =&gt; <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;No apply function found&quot;)" class="string">&quot;No apply function found&quot;</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="c.universe.Symbol">s</span> =&gt;
            <span class="comment">// searches apply method corresponding to unapply</span>
            <span class="keyword">val</span> <a title="List[c.universe.Symbol]" id="play.api.libs.json.JsMacroImpl.readsImpl.applies">applies</a> = <span title="c.universe.Symbol">s</span>.<span title="=&gt; c.universe.MethodSymbol">asMethod</span>.<span title="=&gt; List[c.universe.Symbol]">alternatives</span>
            <span class="keyword">val</span> <span title="Option[c.universe.MethodSymbol]">apply</span> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.applies" title="List[c.universe.Symbol]">applies</a>.<span title="(pf: PartialFunction[c.universe.Symbol,c.universe.MethodSymbol])Option[c.universe.MethodSymbol]">collectFirst</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[c.universe.Symbol,c.universe.MethodSymbol] with Serializable" id="play.api.libs.json.JsMacroImpl.readsImpl.apply;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
              <span class="keyword">case</span> <span class="delimiter">(</span><a title="c.universe.MethodSymbol" id="play.api.libs.json.JsMacroImpl.readsImpl.apply;$anonfun.isDefinedAt.apply">apply</a>: <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(x: Any)Option[c.universe.MethodSymbol]">MethodSymbol</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.apply;$anonfun.isDefinedAt.apply" title="c.universe.MethodSymbol">apply</a>.<span title="=&gt; List[List[c.universe.Symbol]]">paramss</span>.<span title="=&gt; Option[List[c.universe.Symbol]]">headOption</span>.<span title="(f: List[c.universe.Symbol] =&gt; List[c.universe.Type])Option[List[c.universe.Type]]">map</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.apply;$anonfun.applyOrElse.$anonfun.x$1" title="List[c.universe.Symbol]">_</a>.<span title="(f: c.universe.Symbol =&gt; c.universe.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Symbol],c.universe.Type,List[c.universe.Type]])List[c.universe.Type]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,c.universe.Type,List[c.universe.Type]]" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.apply;$anonfun.applyOrElse.$anonfun.$anonfun.x$2" title="c.universe.Symbol">_</a>.<span title="=&gt; c.universe.TermSymbol">asTerm</span>.<span title="=&gt; c.universe.Type">typeSignature</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.unapplyReturnTypes" title="Any">unapplyReturnTypes</a><span class="delimiter">)</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.readsImpl.apply;$anonfun.isDefinedAt.apply" title="c.universe.MethodSymbol">apply</a>
            <span class="delimiter">}</span>
            <span title="Option[c.universe.MethodSymbol]">apply</span> <span title="c.Expr[play.api.libs.json.Reads[A]]" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> Some<span class="delimiter">(</span><span title="c.universe.MethodSymbol">apply</span><span class="delimiter">)</span> =&gt;
                <span class="comment">//println(&quot;apply found:&quot; + apply)    </span>
                <span class="keyword">val</span> <a title="List[c.universe.Symbol]" id="play.api.libs.json.JsMacroImpl.readsImpl.params">params</a> = <span title="c.universe.MethodSymbol">apply</span>.<span title="=&gt; List[List[c.universe.Symbol]]">paramss</span>.<span title="=&gt; List[c.universe.Symbol]">head</span> <span class="comment">//verify there is a single parameter group</span>

                <span class="keyword">val</span> <a title="List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]" id="play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits">inferedImplicits</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(f: c.universe.Symbol =&gt; c.universe.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Symbol],c.universe.Type,List[c.universe.Type]])List[c.universe.Type]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,c.universe.Type,List[c.universe.Type]]" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.x$3" title="c.universe.Symbol">_</a>.<span title="=&gt; c.universe.Type">typeSignature</span><span class="delimiter">)</span>.<span title="(f: c.universe.Type =&gt; (c.universe.Type, c.Tree, Boolean, c.universe.Type))(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Type],(c.universe.Type, c.Tree, Boolean, c.universe.Type),List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]])List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,(c.universe.Type, c.Tree, Boolean, c.universe.Type),List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]]" class="delimiter">{</span> <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.implType">implType</a> =&gt;

                  <span class="keyword">val</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.isRecursive" title="(Boolean, c.universe.Type)" class="delimiter">(</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.x$4" title="Boolean" id="play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.isRecursive">isRecursive</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.x$4" title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.tpe">tpe</a><span class="delimiter">)</span> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a> <span title="(Boolean, c.universe.Type)" class="keyword">match</span> <span class="delimiter">{</span>
                    <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, <span title="c.universe.Symbol">t</span>, <a title="List[c.universe.Type]" id="play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.x$4.args">args</a><span class="delimiter">)</span> =&gt;
                      <span class="comment">// Option[_] needs special treatment because we need to use XXXOpt</span>
                      <span title="(Boolean, c.universe.Type)" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.x$4;$typecreator6.apply.symdef$_$61" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                        <span title="(_1: Boolean, _2: c.universe.Type)(Boolean, c.universe.Type)" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.x$4.args" title="List[c.universe.Type]">args</a>.<span title="(p: c.universe.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <span title="c.universe.Type">a</span> =&gt; <span title="c.universe.Type">a</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.companioned" title="c.universe.Symbol">companioned</a> <span class="delimiter">}</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.x$4.args" title="List[c.universe.Type]">args</a>.<span title="=&gt; c.universe.Type">head</span><span class="delimiter">)</span>
                      <span class="keyword">else</span> <span title="(_1: Boolean, _2: c.universe.Type)(Boolean, c.universe.Type)" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.x$4.args" title="List[c.universe.Type]">args</a>.<span title="(p: c.universe.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <span title="c.universe.Type">a</span> =&gt; <span title="c.universe.Type">a</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.companioned" title="c.universe.Symbol">companioned</a> <span class="delimiter">}</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a><span class="delimiter">)</span>
                    <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, <span title="c.universe.Symbol">t</span>, _<span class="delimiter">)</span> =&gt;
                      <span title="(_1: Boolean, _2: c.universe.Type)(Boolean, c.universe.Type)" class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a><span class="delimiter">)</span>
                  <span class="delimiter">}</span>

                  <span class="comment">// builds reads implicit from expected type</span>
                  <span class="keyword">val</span> <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.neededImplicitType">neededImplicitType</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(tycon: c.universe.Type, args: List[c.universe.Type])c.universe.Type">appliedType</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit attag: c.universe.WeakTypeTag[play.api.libs.json.Reads[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.neededImplicitType;$typecreator7.apply.symdef$_$71" class="delimiter">[</a><a href="Reads.scala.html#play.api.libs.json;Reads" title="play.api.libs.json.Reads[_]">Reads</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.tpe" title="c.universe.Type">tpe</a> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.neededImplicitType.x$5" title="(x: c.universe.Type)List[c.universe.Type]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
                  <span class="comment">// infers implicit</span>
                  <span class="keyword">val</span> <a title="c.Tree" id="play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.neededImplicit">neededImplicit</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pt: c.Type, silent: Boolean, withMacrosDisabled: Boolean, pos: c.Position)c.Tree">inferImplicitValue</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.neededImplicitType" title="c.universe.Type">neededImplicitType</a><span class="delimiter">)</span>
                  <span title="(_1: c.universe.Type, _2: c.Tree, _3: Boolean, _4: c.universe.Type)(c.universe.Type, c.Tree, Boolean, c.universe.Type)" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.neededImplicit" title="c.Tree">neededImplicit</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.isRecursive" title="Boolean">isRecursive</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits.$anonfun.tpe" title="c.universe.Type">tpe</a><span class="delimiter">)</span>
                <span class="delimiter">}</span>

                <span class="comment">// if any implicit is missing, abort</span>
                <span class="comment">// else goes on</span>
                <a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits" title="List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]">inferedImplicits</a>.<span title="(pf: PartialFunction[(c.universe.Type, c.Tree, Boolean, c.universe.Type),c.universe.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)],c.universe.Type,List[c.universe.Type]])List[c.universe.Type]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[(c.universe.Type, c.Tree, Boolean, c.universe.Type),c.universe.Type] with Serializable" id="play.api.libs.json.JsMacroImpl.readsImpl;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl;$anonfun.isDefinedAt.t">t</a>, <a title="c.Tree" id="play.api.libs.json.JsMacroImpl.readsImpl;$anonfun.isDefinedAt.impl">impl</a>, <a title="Boolean" id="play.api.libs.json.JsMacroImpl.readsImpl;$anonfun.isDefinedAt.rec">rec</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl;$anonfun.isDefinedAt.impl" title="c.Tree">impl</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.Tree">EmptyTree</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl;$anonfun.isDefinedAt.rec" title="Boolean">rec</a><span class="delimiter">)</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.readsImpl;$anonfun.isDefinedAt.t" title="c.universe.Type">t</a> <span class="delimiter">}</span> <span title="c.Expr[play.api.libs.json.Reads[A]]" class="keyword">match</span> <span class="delimiter">{</span>
                  <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.<unapply-selector>" title="(x: List[c.universe.Type])Some[List[c.universe.Type]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt;
                    <span class="keyword">val</span> <a title="List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]" id="play.api.libs.json.JsMacroImpl.readsImpl.namedImplicits">namedImplicits</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(f: c.universe.Symbol =&gt; c.universe.Name)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Symbol],c.universe.Name,List[c.universe.Name]])List[c.universe.Name]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,c.universe.Name,List[c.universe.Name]]" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.namedImplicits.$anonfun.x$6" title="c.universe.Symbol">_</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>.<span title="(that: scala.collection.GenIterable[(c.universe.Type, c.Tree, Boolean, c.universe.Type)])(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Name],(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type)),List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]])List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]">zip</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type)),List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]]" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.inferedImplicits" title="List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]">inferedImplicits</a><span class="delimiter">)</span>
                    <span class="comment">//println(&quot;Found implicits:&quot;+namedImplicits)</span>

                    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.readsImpl.helperMember">helperMember</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qual: c.universe.TypeName)c.universe.This">This</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">EMPTY</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyStuff&quot;)" class="string">&quot;lazyStuff&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

                    <span class="keyword">var</span> <a title="Boolean" id="play.api.libs.json.JsMacroImpl.readsImpl.hasRec">hasRec</a> = <span title="Boolean(false)" class="keyword">false</span>

                    <span class="comment">// combines all reads into CanBuildX</span>
                    <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild">canBuild</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.namedImplicits" title="List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]">namedImplicits</a>.<span title="(f: ((c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))) =&gt; c.universe.Apply)(implicit bf: scala.collection.generic.CanBuildFrom[List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))],c.universe.Apply,List[c.universe.Apply]])List[c.universe.Apply]">map</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.x0$1" title="c.universe.Apply" class="delimiter">{</a>
                      <span class="keyword">case</span> <span class="delimiter">(</span><a title="c.universe.Name" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.name">name</a>, <span class="delimiter">(</span><a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.t">t</a>, <a title="c.Tree" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.impl">impl</a>, <a title="Boolean" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.rec">rec</a>, <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.tpe">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
                        <span class="comment">// inception of (__ \ name).read(impl)</span>
                        <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.jspathTree">jspathTree</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                          <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.jsPathSelect" title="c.universe.Select">jsPathSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span>scala.reflect.<span title="scala.reflect.NameTransformer.type">NameTransformer</span>.<span title="(name: String)String">encode</span><span class="delimiter">(</span><span title="String(&quot;\\&quot;)" class="string">&quot;\\&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                          <span title="(xs: c.universe.Literal*)List[c.universe.Literal]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(value: c.universe.Constant)c.universe.Literal">Literal</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(value: Any)c.universe.Constant">Constant</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.name" title="c.universe.Name">name</a>.<span title="=&gt; String">decoded</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                        <span class="delimiter">)</span>

                        <span title="c.universe.Apply" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.rec" title="Boolean">rec</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                          <span class="keyword">val</span> <span title="c.universe.Apply">readTree</span> =
                            <span title="c.universe.Apply" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.t" title="c.universe.Type">t</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.readTree;$typecreator8.apply.symdef$_$81" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                              <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;readNullable&quot;)" class="string">&quot;readNullable&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                <span title="(xs: c.Tree*)List[c.Tree]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.impl" title="c.Tree">impl</a><span class="delimiter">)</span>
                              <span class="delimiter">)</span>
                            <span class="keyword">else</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                              <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;read&quot;)" class="string">&quot;read&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                              <span title="(xs: c.Tree*)List[c.Tree]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.impl" title="c.Tree">impl</a><span class="delimiter">)</span>
                            <span class="delimiter">)</span>

                          <span title="c.universe.Apply">readTree</span>
                        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                          <a href="#play.api.libs.json.JsMacroImpl.readsImpl.hasRec" title="Boolean">hasRec</a> = <span title="Boolean(true)" class="keyword">true</span>
                          <span class="keyword">val</span> <span title="c.universe.Apply">readTree</span> =
                            <span title="c.universe.Apply" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.t" title="c.universe.Type">t</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.readTree;$typecreator9.apply.symdef$_$91" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                              <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;readNullable&quot;)" class="string">&quot;readNullable&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.jsPathSelect" title="c.universe.Select">jsPathSelect</a>, List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyRead&quot;)" class="string">&quot;lazyRead&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                              <span class="delimiter">)</span>

                            <span class="keyword">else</span> <span class="delimiter">{</span>
                              <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyRead&quot;)" class="string">&quot;lazyRead&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit ttag: c.universe.TypeTag[List[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.readTree;$typecreator10.apply.symdef$_$101" class="delimiter">[</a><span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                                  <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.readsSelect" title="c.universe.Select">readsSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;list&quot;)" class="string">&quot;list&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                                <span class="keyword">else</span> <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit ttag: c.universe.TypeTag[Set[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.readTree;$typecreator11.apply.symdef$_$111" class="delimiter">[</a><span title="Set[_]">Set</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                                  <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.readsSelect" title="c.universe.Select">readsSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;set&quot;)" class="string">&quot;set&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                                <span class="keyword">else</span> <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit ttag: c.universe.TypeTag[Seq[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.readTree;$typecreator12.apply.symdef$_$121" class="delimiter">[</a><span title="Seq[_]">Seq</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                                  <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.readsSelect" title="c.universe.Select">readsSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;seq&quot;)" class="string">&quot;seq&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                                <span class="keyword">else</span> <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit ttag: c.universe.TypeTag[Map[_, _]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.readTree;$typecreator13.apply.symdef$_$141" class="delimiter">[</a><span title="Map[_, _]">Map</span><span class="delimiter">[</span>_, _<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                                  <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.readsSelect" title="c.universe.Select">readsSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;map&quot;)" class="string">&quot;map&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                                <span class="keyword">else</span> <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                              <span class="delimiter">)</span>
                            <span class="delimiter">}</span>

                          <span title="c.universe.Apply">readTree</span>
                        <span class="delimiter">}</span>
                    <span class="delimiter">}</span>.<span title="(f: (c.universe.Apply, c.universe.Apply) =&gt; c.universe.Apply)c.universe.Apply">reduceLeft</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.acc">acc</a>, <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.r">r</a><span class="delimiter">)</span> =&gt;
                      <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.acc" title="c.universe.Apply">acc</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;and&quot;)" class="string">&quot;and&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                        <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild.$anonfun.r" title="c.universe.Apply">r</a><span class="delimiter">)</span>
                      <span class="delimiter">)</span>
                    <span class="delimiter">}</span>

                    <span class="comment">// builds the final Reads using apply method</span>
                    <span class="keyword">val</span> <a title="c.universe.Function" id="play.api.libs.json.JsMacroImpl.readsImpl.applyMethod">applyMethod</a> =
                      <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(vparams: List[c.universe.ValDef], body: c.universe.Tree)c.universe.Function">Function</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(z: List[c.universe.ValDef])(f: (List[c.universe.ValDef], c.universe.Symbol) =&gt; List[c.universe.ValDef])List[c.universe.ValDef]">foldLeft</span><span class="delimiter">(</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span title="List[c.universe.ValDef]">l</span>, <span title="c.universe.Symbol">e</span><span class="delimiter">)</span> =&gt;
                          <span title="List[c.universe.ValDef]">l</span> <span title="(elem: c.universe.ValDef)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.ValDef],c.universe.ValDef,List[c.universe.ValDef]])List[c.universe.ValDef]">:+</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TermName, tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.ValDef">ValDef</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(flags: c.universe.FlagSet)c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.FlagSet">PARAM</a><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="c.universe.Symbol">e</span>.<span title="=&gt; c.universe.Name">name</span>.<span title="=&gt; String">encoded</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="()c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.Tree">EmptyTree</a><span class="delimiter">)</span>
                        <span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                          <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;apply&quot;)" class="string">&quot;apply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                          <a href="#play.api.libs.json.JsMacroImpl.readsImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(z: List[c.universe.Tree])(f: (List[c.universe.Tree], c.universe.Symbol) =&gt; List[c.universe.Tree])List[c.universe.Tree]">foldLeft</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span title="List[c.universe.Tree]">l</span>, <span title="c.universe.Symbol">e</span><span class="delimiter">)</span> =&gt;
                            <span title="List[c.universe.Tree]">l</span> <span title="(elem: c.universe.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Tree],c.universe.Tree,List[c.universe.Tree]])List[c.universe.Tree]">:+</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="c.universe.Symbol">e</span>.<span title="=&gt; c.universe.Name">name</span>.<span title="=&gt; String">encoded</span><span class="delimiter">)</span><span class="delimiter">)</span>
                          <span class="delimiter">)</span>
                        <span class="delimiter">)</span>
                      <span class="delimiter">)</span>

                    <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.readsImpl.unapplyMethod">unapplyMethod</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                      <a href="#play.api.libs.json.JsMacroImpl.readsImpl.unliftIdent" title="c.universe.Select">unliftIdent</a>,
                      <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.unapply" title="c.universe.MethodSymbol">unapply</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>
                      <span class="delimiter">)</span>
                    <span class="delimiter">)</span>

                    <span class="comment">// if case class has one single field, needs to use inmap instead of canbuild.apply</span>
                    <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.readsImpl.finalTree">finalTree</a> = <span title="c.universe.Apply" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                      <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild" title="c.universe.Apply">canBuild</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;apply&quot;)" class="string">&quot;apply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                        <span title="(xs: c.universe.Function*)List[c.universe.Function]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.applyMethod" title="c.universe.Function">applyMethod</a><span class="delimiter">)</span>
                      <span class="delimiter">)</span>
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                      <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.canBuild" title="c.universe.Apply">canBuild</a>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;map&quot;)" class="string">&quot;map&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                        <span title="(xs: c.universe.Function*)List[c.universe.Function]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.applyMethod" title="c.universe.Function">applyMethod</a><span class="delimiter">)</span>
                      <span class="delimiter">)</span>
                    <span class="delimiter">}</span>
                    <span class="comment">//println(&quot;finalTree: &quot;+finalTree)</span>

                    <span title="c.Expr[play.api.libs.json.Reads[A]]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.hasRec" title="Boolean">hasRec</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                      <span class="keyword">val</span> <span title="c.universe.Block">block</span> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(stats: c.universe.Tree*)c.universe.Block">Block</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(expr: c.universe.Tree, selectors: List[c.universe.ImportSelector])c.universe.Import">Import</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.functionalSyntaxPkg" title="c.universe.Select">functionalSyntaxPkg</a>, <span title="(xs: c.universe.ImportSelector*)List[c.universe.ImportSelector]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(name: c.universe.Name, namePos: Int, rename: c.universe.Name, renamePos: Int)c.universe.ImportSelector">ImportSelector</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">WILDCARD</span>, -<span title="Int(-1)" class="int">1</span>, <span title="Null(null)" class="keyword">null</span>, -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.finalTree" title="c.universe.Apply">finalTree</a>
                      <span class="delimiter">)</span>

                      <span class="comment">//println(&quot;block:&quot;+block)</span>

                      <span class="comment">/*val reif = reify(
                        /*new play.api.libs.json.util.LazyHelper[Format, A] {
                          override lazy val lazyStuff: Format[A] = null
                        }*/
                      )
                      println(&quot;RAW:&quot;+showRaw(reif.tree, printKinds = true))*/</span>

                      <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[play.api.libs.json.Reads[A]])c.Expr[play.api.libs.json.Reads[A]]" class="delimiter">[</span><a href="Reads.scala.html#play.api.libs.json;Reads" title="play.api.libs.json.Reads[A]">Reads</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="c.universe.type" id="play.api.libs.json.JsMacroImpl.readsImpl;$typecreator14.apply.$m" class="delimiter">(</a><span title="c.universe.Block">block</span><span class="delimiter">)</span>
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                      <span class="keyword">val</span> <a title="c.universe.TermName" id="play.api.libs.json.JsMacroImpl.readsImpl.helper">helper</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;helper&quot;)" class="string">&quot;helper&quot;</span><span class="delimiter">)</span>
                      <span class="keyword">val</span> <a title="c.universe.ValDef" id="play.api.libs.json.JsMacroImpl.readsImpl.helperVal">helperVal</a> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TermName, tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.ValDef">ValDef</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="()c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.helper" title="c.universe.TermName">helper</a>,
                        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit attag: c.universe.WeakTypeTag[play.api.libs.json.util.LazyHelper[play.api.libs.json.Reads,A]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.helperVal;$typecreator15.apply.$m" class="delimiter">[</a>play.api.libs.json.util.<a href="Util.scala.html#play.api.libs.json.util;LazyHelper" title="play.api.libs.json.util.LazyHelper[play.api.libs.json.Reads,A]">LazyHelper</a><span class="delimiter">[</span>Reads, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.lazyHelperSelect" title="c.universe.Select">lazyHelperSelect</a>, <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.finalTree" title="c.universe.Apply">finalTree</a><span class="delimiter">)</span><span class="delimiter">)</span>
                      <span class="delimiter">)</span>

                      <span class="keyword">val</span> <span title="c.universe.Select">block</span> = <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(stats: c.universe.Tree*)c.universe.Block">Block</a><span class="delimiter">(</span>
                          <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(expr: c.universe.Tree, selectors: List[c.universe.ImportSelector])c.universe.Import">Import</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.functionalSyntaxPkg" title="c.universe.Select">functionalSyntaxPkg</a>, <span title="(xs: c.universe.ImportSelector*)List[c.universe.ImportSelector]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(name: c.universe.Name, namePos: Int, rename: c.universe.Name, renamePos: Int)c.universe.ImportSelector">ImportSelector</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">WILDCARD</span>, -<span title="Int(-1)" class="int">1</span>, <span title="Null(null)" class="keyword">null</span>, -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                          <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TypeName, tparams: List[c.universe.TypeDef], impl: c.universe.Template)c.universe.ClassDef">ClassDef</a><span class="delimiter">(</span>
                            <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(flags: c.universe.FlagSet)c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.FlagValues">Flag</a>.<span title="=&gt; c.universe.FlagSet">FINAL</span><span class="delimiter">)</span>,
                            <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;$anon&quot;)" class="string">&quot;$anon&quot;</span><span class="delimiter">)</span>,
                            List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>,
                            <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(parents: List[c.universe.Tree], self: c.universe.ValDef, body: List[c.universe.Tree])c.universe.Template">Template</a><span class="delimiter">(</span>
                              <span title="(xs: c.universe.AppliedTypeTree*)List[c.universe.AppliedTypeTree]">List</span><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(tpt: c.universe.Tree, args: List[c.universe.Tree])c.universe.AppliedTypeTree">AppliedTypeTree</a><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.readsImpl.lazyHelperSelect" title="c.universe.Select">lazyHelperSelect</a>,
                                  <span title="(xs: c.universe.Ident*)List[c.universe.Ident]">List</span><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit attag: c.universe.WeakTypeTag[play.api.libs.json.Reads[A]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.block;$typecreator16.apply.$m" class="delimiter">[</a><a href="Reads.scala.html#play.api.libs.json;Reads" title="play.api.libs.json.Reads[A]">Reads</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span><span class="delimiter">)</span>,
                                    <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.evidence$1" title="(implicit attag: c.universe.WeakTypeTag[A])c.universe.Type" class="delimiter">[</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl;A" title="A">A</a><span class="delimiter">]</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                              <span class="delimiter">)</span>,
                              <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.ValDef">emptyValDef</a>,
                              <span title="(xs: c.universe.ValOrDefDef with c.universe.MemberDef with c.universe.ValOrDefDefApi with c.universe.SymTree with c.universe.NameTree with c.universe.DefTreeApi with c.universe.Tree with c.universe.NameTreeApi*)List[c.universe.ValOrDefDef with c.universe.MemberDef with c.universe.ValOrDefDefApi with c.universe.SymTree with c.universe.NameTree with c.universe.DefTreeApi with c.universe.Tree with c.universe.NameTreeApi]">List</span><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.Name, tparams: List[c.universe.TypeDef], vparamss: List[List[c.universe.ValDef]], tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.DefDef">DefDef</a><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="()c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">CONSTRUCTOR</span>,
                                  List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>,
                                  <span title="(xs: List[Nothing]*)List[List[Nothing]]">List</span><span class="delimiter">(</span>List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="()c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(stats: c.universe.Tree*)c.universe.Block">Block</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                      <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qual: c.universe.Tree, mix: c.universe.TypeName)c.universe.Super">Super</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qual: c.universe.TypeName)c.universe.This">This</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">EMPTY</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">EMPTY</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">CONSTRUCTOR</span><span class="delimiter">)</span>,
                                      List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>
                                    <span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>,
                                <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TermName, tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.ValDef">ValDef</a><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(flags: c.universe.FlagSet)c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.FlagValues">Flag</a>.<a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="implicit scala.reflect.api.FlagSets.addFlagOps : (left: c.universe.FlagSet)c.universe.FlagOps">OVERRIDE</a> <span title="(right: c.universe.FlagSet)c.universe.FlagSet">|</span> <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.FlagValues">Flag</a>.<span title="=&gt; c.universe.FlagSet">LAZY</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyStuff&quot;)" class="string">&quot;lazyStuff&quot;</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(tpt: c.universe.Tree, args: List[c.universe.Tree])c.universe.AppliedTypeTree">AppliedTypeTree</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(implicit attag: c.universe.WeakTypeTag[play.api.libs.json.Reads[A]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.readsImpl.block;$typecreator17.apply.$m" class="delimiter">[</a><a href="Reads.scala.html#play.api.libs.json;Reads" title="play.api.libs.json.Reads[A]">Reads</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span><span class="delimiter">)</span>, <span title="(xs: c.universe.TypeTree*)List[c.universe.TypeTree]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.evidence$1" title="(implicit attag: c.universe.WeakTypeTag[A])c.universe.Type" class="delimiter">[</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.readsImpl.finalTree" title="c.universe.Apply">finalTree</a>
                                <span class="delimiter">)</span>
                              <span class="delimiter">)</span>
                            <span class="delimiter">)</span>
                          <span class="delimiter">)</span>,
                          <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(tpt: c.universe.Tree)c.universe.New">New</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;$anon&quot;)" class="string">&quot;$anon&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">CONSTRUCTOR</span><span class="delimiter">)</span>, List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
                        <span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyStuff&quot;)" class="string">&quot;lazyStuff&quot;</span><span class="delimiter">)</span>
                      <span class="delimiter">)</span>

                      <span class="comment">//println(&quot;block:&quot;+block)</span>

                      <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[play.api.libs.json.Reads[A]])c.Expr[play.api.libs.json.Reads[A]]" class="delimiter">[</span><a href="Reads.scala.html#play.api.libs.json;Reads" title="play.api.libs.json.Reads[A]">Reads</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="c.universe.type" id="play.api.libs.json.JsMacroImpl.readsImpl;$typecreator18.apply.$m" class="delimiter">(</a><span title="c.universe.Select">block</span><span class="delimiter">)</span>
                    <span class="delimiter">}</span>
                  <span class="keyword">case</span> <a title="List[c.universe.Type]" id="play.api.libs.json.JsMacroImpl.readsImpl.l">l</a> =&gt; <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;No implicit Reads for &quot;)">No implicit Reads for $</span><span class="delimiter">{</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.l" title="List[c.universe.Type]">l</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot; available.&quot;)" class="string"> available.&quot;</span><span class="delimiter">)</span>
                <span class="delimiter">}</span>

              <span class="keyword">case</span> <span title="None.type">None</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;No apply function found matching unapply return types&quot;)" class="string">&quot;No apply function found matching unapply return types&quot;</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>

        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[A](c: scala.reflect.macros.Context)(implicit evidence$2: c.WeakTypeTag[A])c.Expr[play.api.libs.json.Writes[A]]" id="play.api.libs.json.JsMacroImpl.writesImpl">writesImpl</a><span class="delimiter">[</span><a title="" id="play.api.libs.json.JsMacroImpl.writesImpl;A">A</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="play.api.libs.json.JsMacroImpl.writesImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span>: c.<span title="c.Expr[play.api.libs.json.Writes[A]]">Expr</span><span class="delimiter">[</span>Writes<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">import</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
    <span class="keyword">import</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="=&gt; c.universe.FlagValues">Flag</span>._

    <span class="keyword">val</span> <a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.writesImpl.companioned">companioned</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.evidence$2" title="(implicit attag: c.universe.WeakTypeTag[A])c.universe.Type" class="delimiter">[</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl;A" title="A">A</a><span class="delimiter">]</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span>
    <span class="keyword">val</span> <a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.writesImpl.companionSymbol">companionSymbol</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.companioned" title="c.universe.Symbol">companioned</a>.<span title="=&gt; c.universe.Symbol">companionSymbol</span>
    <span class="keyword">val</span> <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.companionType">companionType</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a>.<span title="=&gt; c.universe.Type">typeSignature</span>

    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.writesImpl.libsPkg">libsPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;play&quot;)" class="string">&quot;play&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;api&quot;)" class="string">&quot;api&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;libs&quot;)" class="string">&quot;libs&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.writesImpl.jsonPkg">jsonPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.libsPkg" title="c.universe.Select">libsPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;json&quot;)" class="string">&quot;json&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.writesImpl.functionalSyntaxPkg">functionalSyntaxPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.libsPkg" title="c.universe.Select">libsPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;functional&quot;)" class="string">&quot;functional&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;syntax&quot;)" class="string">&quot;syntax&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.writesImpl.utilPkg">utilPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.jsonPkg" title="c.universe.Select">jsonPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;util&quot;)" class="string">&quot;util&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.writesImpl.jsPathSelect">jsPathSelect</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.jsonPkg" title="c.universe.Select">jsonPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;JsPath&quot;)" class="string">&quot;JsPath&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.writesImpl.writesSelect">writesSelect</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.jsonPkg" title="c.universe.Select">jsonPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;Writes&quot;)" class="string">&quot;Writes&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.writesImpl.unliftIdent">unliftIdent</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.functionalSyntaxPkg" title="c.universe.Select">functionalSyntaxPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;unlift&quot;)" class="string">&quot;unlift&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.writesImpl.lazyHelperSelect">lazyHelperSelect</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.utilPkg" title="c.universe.Select">utilPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;LazyHelper&quot;)" class="string">&quot;LazyHelper&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <a href="#play.api.libs.json.JsMacroImpl.writesImpl.companionType" title="c.universe.Type">companionType</a>.<span title="(name: c.universe.Name)c.universe.Symbol">declaration</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="implicit scala.reflect.api.Names.stringToTermName : (s: String)c.universe.TermName">stringToTermName</a><span class="delimiter">(</span><span title="String(&quot;unapply&quot;)" class="string">&quot;unapply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="c.Expr[play.api.libs.json.Writes[A]]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.Symbol">NoSymbol</a> =&gt; <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;No unapply function found&quot;)" class="string">&quot;No unapply function found&quot;</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="c.universe.Symbol">s</span> =&gt;
        <span class="keyword">val</span> <a title="c.universe.MethodSymbol" id="play.api.libs.json.JsMacroImpl.writesImpl.unapply">unapply</a> = <span title="c.universe.Symbol">s</span>.<span title="=&gt; c.universe.MethodSymbol">asMethod</span>
        <span class="keyword">val</span> <a title="Any" id="play.api.libs.json.JsMacroImpl.writesImpl.unapplyReturnTypes">unapplyReturnTypes</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.unapply" title="c.universe.MethodSymbol">unapply</a>.<span title="=&gt; c.universe.Type">returnType</span> <span title="Any" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> =&gt;
            <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Unapply of &quot;)">Unapply of $</span><span class="delimiter">{</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a><span class="delimiter">}</span><span title="String(&quot; has no parameters. Are you using an empty case class?&quot;)" class="string"> has no parameters. Are you using an empty case class?&quot;</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="List[c.universe.Type]">args</span><span class="delimiter">)</span> =&gt;
            <span title="List[c.universe.Type]">args</span>.<span title="=&gt; c.universe.Type">head</span> <span title="Any" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="c.universe.TypeRef">t</span> @ <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> =&gt; <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">case</span> <span title="c.universe.TypeRef">t</span> @ <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="List[c.universe.Type]">args</span><span class="delimiter">)</span> =&gt;
                <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.unapplyReturnTypes;$typecreator19.apply.symdef$_$151" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit ttag: c.universe.TypeTag[Seq[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.unapplyReturnTypes;$typecreator20.apply.symdef$_$161" class="delimiter">[</a><span title="Seq[_]">Seq</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit ttag: c.universe.TypeTag[Set[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.unapplyReturnTypes;$typecreator21.apply.symdef$_$171" class="delimiter">[</a><span title="Set[_]">Set</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit ttag: c.universe.TypeTag[Map[_, _]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.unapplyReturnTypes;$typecreator22.apply.symdef$_$191" class="delimiter">[</a><span title="Map[_, _]">Map</span><span class="delimiter">[</span>_, _<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit ttag: c.universe.TypeTag[Product])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.unapplyReturnTypes;$typecreator23.apply.$m" class="delimiter">[</a><span title="Product">Product</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.Type])Some[List[c.universe.Type]]">Some</span><span class="delimiter">(</span><span title="List[c.universe.Type]">args</span><span class="delimiter">)</span>
              <span class="keyword">case</span> _ =&gt; <span title="None.type">None</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> _ =&gt; <span title="None.type">None</span>
        <span class="delimiter">}</span>

        <span class="comment">//println(&quot;Unapply return type:&quot; + unapplyReturnTypes)</span>

        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.companionType" title="c.universe.Type">companionType</a>.<span title="(name: c.universe.Name)c.universe.Symbol">declaration</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="implicit scala.reflect.api.Names.stringToTermName : (s: String)c.universe.TermName">stringToTermName</a><span class="delimiter">(</span><span title="String(&quot;apply&quot;)" class="string">&quot;apply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="c.Expr[play.api.libs.json.Writes[A]]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.Symbol">NoSymbol</a> =&gt; <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;No apply function found&quot;)" class="string">&quot;No apply function found&quot;</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="c.universe.Symbol">s</span> =&gt;
            <span class="comment">// searches apply method corresponding to unapply</span>
            <span class="keyword">val</span> <a title="List[c.universe.Symbol]" id="play.api.libs.json.JsMacroImpl.writesImpl.applies">applies</a> = <span title="c.universe.Symbol">s</span>.<span title="=&gt; c.universe.MethodSymbol">asMethod</span>.<span title="=&gt; List[c.universe.Symbol]">alternatives</span>
            <span class="keyword">val</span> <span title="Option[c.universe.MethodSymbol]">apply</span> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.applies" title="List[c.universe.Symbol]">applies</a>.<span title="(pf: PartialFunction[c.universe.Symbol,c.universe.MethodSymbol])Option[c.universe.MethodSymbol]">collectFirst</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[c.universe.Symbol,c.universe.MethodSymbol] with Serializable" id="play.api.libs.json.JsMacroImpl.writesImpl.apply;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
              <span class="keyword">case</span> <span class="delimiter">(</span><a title="c.universe.MethodSymbol" id="play.api.libs.json.JsMacroImpl.writesImpl.apply;$anonfun.isDefinedAt.apply">apply</a>: <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(x: Any)Option[c.universe.MethodSymbol]">MethodSymbol</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.apply;$anonfun.isDefinedAt.apply" title="c.universe.MethodSymbol">apply</a>.<span title="=&gt; List[List[c.universe.Symbol]]">paramss</span>.<span title="=&gt; Option[List[c.universe.Symbol]]">headOption</span>.<span title="(f: List[c.universe.Symbol] =&gt; List[c.universe.Type])Option[List[c.universe.Type]]">map</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.apply;$anonfun.applyOrElse.$anonfun.x$7" title="List[c.universe.Symbol]">_</a>.<span title="(f: c.universe.Symbol =&gt; c.universe.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Symbol],c.universe.Type,List[c.universe.Type]])List[c.universe.Type]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,c.universe.Type,List[c.universe.Type]]" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.apply;$anonfun.applyOrElse.$anonfun.$anonfun.x$8" title="c.universe.Symbol">_</a>.<span title="=&gt; c.universe.TermSymbol">asTerm</span>.<span title="=&gt; c.universe.Type">typeSignature</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.unapplyReturnTypes" title="Any">unapplyReturnTypes</a><span class="delimiter">)</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.writesImpl.apply;$anonfun.isDefinedAt.apply" title="c.universe.MethodSymbol">apply</a>
            <span class="delimiter">}</span>
            <span title="Option[c.universe.MethodSymbol]">apply</span> <span title="c.Expr[play.api.libs.json.Writes[A]]" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> Some<span class="delimiter">(</span><span title="c.universe.MethodSymbol">apply</span><span class="delimiter">)</span> =&gt;
                <span class="comment">//println(&quot;apply found:&quot; + apply)    </span>
                <span class="keyword">val</span> <a title="List[c.universe.Symbol]" id="play.api.libs.json.JsMacroImpl.writesImpl.params">params</a> = <span title="c.universe.MethodSymbol">apply</span>.<span title="=&gt; List[List[c.universe.Symbol]]">paramss</span>.<span title="=&gt; List[c.universe.Symbol]">head</span> <span class="comment">//verify there is a single parameter group</span>

                <span class="keyword">val</span> <a title="List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]" id="play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits">inferedImplicits</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(f: c.universe.Symbol =&gt; c.universe.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Symbol],c.universe.Type,List[c.universe.Type]])List[c.universe.Type]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,c.universe.Type,List[c.universe.Type]]" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.x$9" title="c.universe.Symbol">_</a>.<span title="=&gt; c.universe.Type">typeSignature</span><span class="delimiter">)</span>.<span title="(f: c.universe.Type =&gt; (c.universe.Type, c.Tree, Boolean, c.universe.Type))(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Type],(c.universe.Type, c.Tree, Boolean, c.universe.Type),List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]])List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,(c.universe.Type, c.Tree, Boolean, c.universe.Type),List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]]" class="delimiter">{</span> <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.implType">implType</a> =&gt;

                  <span class="keyword">val</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.isRecursive" title="(Boolean, c.universe.Type)" class="delimiter">(</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.x$10" title="Boolean" id="play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.isRecursive">isRecursive</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.x$10" title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.tpe">tpe</a><span class="delimiter">)</span> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a> <span title="(Boolean, c.universe.Type)" class="keyword">match</span> <span class="delimiter">{</span>
                    <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, <span title="c.universe.Symbol">t</span>, <a title="List[c.universe.Type]" id="play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.x$10.args">args</a><span class="delimiter">)</span> =&gt;
                      <span class="comment">// Option[_] needs special treatment because we need to use XXXOpt</span>
                      <span title="(Boolean, c.universe.Type)" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.x$10;$typecreator24.apply.symdef$_$201" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                        <span title="(_1: Boolean, _2: c.universe.Type)(Boolean, c.universe.Type)" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.x$10.args" title="List[c.universe.Type]">args</a>.<span title="(p: c.universe.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <span title="c.universe.Type">a</span> =&gt; <span title="c.universe.Type">a</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.companioned" title="c.universe.Symbol">companioned</a> <span class="delimiter">}</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.x$10.args" title="List[c.universe.Type]">args</a>.<span title="=&gt; c.universe.Type">head</span><span class="delimiter">)</span>
                      <span class="keyword">else</span> <span title="(_1: Boolean, _2: c.universe.Type)(Boolean, c.universe.Type)" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.x$10.args" title="List[c.universe.Type]">args</a>.<span title="(p: c.universe.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <span title="c.universe.Type">a</span> =&gt; <span title="c.universe.Type">a</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.companioned" title="c.universe.Symbol">companioned</a> <span class="delimiter">}</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a><span class="delimiter">)</span>
                    <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, <span title="c.universe.Symbol">t</span>, _<span class="delimiter">)</span> =&gt;
                      <span title="(_1: Boolean, _2: c.universe.Type)(Boolean, c.universe.Type)" class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a><span class="delimiter">)</span>
                  <span class="delimiter">}</span>

                  <span class="comment">// builds reads implicit from expected type</span>
                  <span class="keyword">val</span> <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.neededImplicitType">neededImplicitType</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(tycon: c.universe.Type, args: List[c.universe.Type])c.universe.Type">appliedType</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit attag: c.universe.WeakTypeTag[play.api.libs.json.Writes[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.neededImplicitType;$typecreator25.apply.symdef$_$211" class="delimiter">[</a><a href="Writes.scala.html#play.api.libs.json;Writes" title="play.api.libs.json.Writes[_]">Writes</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.tpe" title="c.universe.Type">tpe</a> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.neededImplicitType.x$11" title="(x: c.universe.Type)List[c.universe.Type]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
                  <span class="comment">// infers implicit</span>
                  <span class="keyword">val</span> <a title="c.Tree" id="play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.neededImplicit">neededImplicit</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pt: c.Type, silent: Boolean, withMacrosDisabled: Boolean, pos: c.Position)c.Tree">inferImplicitValue</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.neededImplicitType" title="c.universe.Type">neededImplicitType</a><span class="delimiter">)</span>
                  <span title="(_1: c.universe.Type, _2: c.Tree, _3: Boolean, _4: c.universe.Type)(c.universe.Type, c.Tree, Boolean, c.universe.Type)" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.neededImplicit" title="c.Tree">neededImplicit</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.isRecursive" title="Boolean">isRecursive</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits.$anonfun.tpe" title="c.universe.Type">tpe</a><span class="delimiter">)</span>
                <span class="delimiter">}</span>

                <span class="comment">// if any implicit is missing, abort</span>
                <span class="comment">// else goes on</span>
                <a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits" title="List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]">inferedImplicits</a>.<span title="(pf: PartialFunction[(c.universe.Type, c.Tree, Boolean, c.universe.Type),c.universe.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)],c.universe.Type,List[c.universe.Type]])List[c.universe.Type]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[(c.universe.Type, c.Tree, Boolean, c.universe.Type),c.universe.Type] with Serializable" id="play.api.libs.json.JsMacroImpl.writesImpl;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl;$anonfun.isDefinedAt.t">t</a>, <a title="c.Tree" id="play.api.libs.json.JsMacroImpl.writesImpl;$anonfun.isDefinedAt.impl">impl</a>, <a title="Boolean" id="play.api.libs.json.JsMacroImpl.writesImpl;$anonfun.isDefinedAt.rec">rec</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl;$anonfun.isDefinedAt.impl" title="c.Tree">impl</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.Tree">EmptyTree</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl;$anonfun.isDefinedAt.rec" title="Boolean">rec</a><span class="delimiter">)</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.writesImpl;$anonfun.isDefinedAt.t" title="c.universe.Type">t</a> <span class="delimiter">}</span> <span title="c.Expr[play.api.libs.json.Writes[A]]" class="keyword">match</span> <span class="delimiter">{</span>
                  <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.<unapply-selector>" title="(x: List[c.universe.Type])Some[List[c.universe.Type]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt;
                    <span class="keyword">val</span> <a title="List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]" id="play.api.libs.json.JsMacroImpl.writesImpl.namedImplicits">namedImplicits</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(f: c.universe.Symbol =&gt; c.universe.Name)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Symbol],c.universe.Name,List[c.universe.Name]])List[c.universe.Name]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,c.universe.Name,List[c.universe.Name]]" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.namedImplicits.$anonfun.x$12" title="c.universe.Symbol">_</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>.<span title="(that: scala.collection.GenIterable[(c.universe.Type, c.Tree, Boolean, c.universe.Type)])(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Name],(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type)),List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]])List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]">zip</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type)),List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]]" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.inferedImplicits" title="List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]">inferedImplicits</a><span class="delimiter">)</span>
                    <span class="comment">//println(&quot;Found implicits:&quot;+namedImplicits)</span>

                    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.writesImpl.helperMember">helperMember</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qual: c.universe.TypeName)c.universe.This">This</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">EMPTY</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyStuff&quot;)" class="string">&quot;lazyStuff&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

                    <span class="keyword">var</span> <a title="Boolean" id="play.api.libs.json.JsMacroImpl.writesImpl.hasRec">hasRec</a> = <span title="Boolean(false)" class="keyword">false</span>

                    <span class="comment">// combines all reads into CanBuildX</span>
                    <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild">canBuild</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.namedImplicits" title="List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]">namedImplicits</a>.<span title="(f: ((c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))) =&gt; c.universe.Apply)(implicit bf: scala.collection.generic.CanBuildFrom[List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))],c.universe.Apply,List[c.universe.Apply]])List[c.universe.Apply]">map</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.x0$2" title="c.universe.Apply" class="delimiter">{</a>
                      <span class="keyword">case</span> <span class="delimiter">(</span><a title="c.universe.Name" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.name">name</a>, <span class="delimiter">(</span><a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.t">t</a>, <a title="c.Tree" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.impl">impl</a>, <a title="Boolean" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.rec">rec</a>, <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.tpe">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
                        <span class="comment">// inception of (__ \ name).read(impl)</span>
                        <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.jspathTree">jspathTree</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                          <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.jsPathSelect" title="c.universe.Select">jsPathSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span>scala.reflect.<span title="scala.reflect.NameTransformer.type">NameTransformer</span>.<span title="(name: String)String">encode</span><span class="delimiter">(</span><span title="String(&quot;\\&quot;)" class="string">&quot;\\&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                          <span title="(xs: c.universe.Literal*)List[c.universe.Literal]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(value: c.universe.Constant)c.universe.Literal">Literal</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(value: Any)c.universe.Constant">Constant</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.name" title="c.universe.Name">name</a>.<span title="=&gt; String">decoded</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                        <span class="delimiter">)</span>

                        <span title="c.universe.Apply" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.rec" title="Boolean">rec</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                          <span class="keyword">val</span> <span title="c.universe.Apply">writesTree</span> =
                            <span title="c.universe.Apply" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.t" title="c.universe.Type">t</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.writesTree;$typecreator26.apply.symdef$_$221" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                              <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;writeNullable&quot;)" class="string">&quot;writeNullable&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                <span title="(xs: c.Tree*)List[c.Tree]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.impl" title="c.Tree">impl</a><span class="delimiter">)</span>
                              <span class="delimiter">)</span>
                            <span class="keyword">else</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                              <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;write&quot;)" class="string">&quot;write&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                              <span title="(xs: c.Tree*)List[c.Tree]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.impl" title="c.Tree">impl</a><span class="delimiter">)</span>
                            <span class="delimiter">)</span>

                          <span title="c.universe.Apply">writesTree</span>
                        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                          <a href="#play.api.libs.json.JsMacroImpl.writesImpl.hasRec" title="Boolean">hasRec</a> = <span title="Boolean(true)" class="keyword">true</span>
                          <span class="keyword">val</span> <span title="c.universe.Apply">writesTree</span> =
                            <span title="c.universe.Apply" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.t" title="c.universe.Type">t</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.writesTree;$typecreator27.apply.symdef$_$231" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                              <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;writeNullable&quot;)" class="string">&quot;writeNullable&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.jsPathSelect" title="c.universe.Select">jsPathSelect</a>, List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyWrite&quot;)" class="string">&quot;lazyWrite&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                              <span class="delimiter">)</span>

                            <span class="keyword">else</span> <span class="delimiter">{</span>
                              <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyWrite&quot;)" class="string">&quot;lazyWrite&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit ttag: c.universe.TypeTag[List[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.writesTree;$typecreator28.apply.symdef$_$241" class="delimiter">[</a><span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                                  <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.writesSelect" title="c.universe.Select">writesSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;list&quot;)" class="string">&quot;list&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                                <span class="keyword">else</span> <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit ttag: c.universe.TypeTag[Set[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.writesTree;$typecreator29.apply.symdef$_$251" class="delimiter">[</a><span title="Set[_]">Set</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                                  <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.writesSelect" title="c.universe.Select">writesSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;set&quot;)" class="string">&quot;set&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                                <span class="keyword">else</span> <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit ttag: c.universe.TypeTag[Seq[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.writesTree;$typecreator30.apply.symdef$_$261" class="delimiter">[</a><span title="Seq[_]">Seq</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                                  <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.writesSelect" title="c.universe.Select">writesSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;seq&quot;)" class="string">&quot;seq&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                                <span class="keyword">else</span> <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit ttag: c.universe.TypeTag[Map[_, _]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.writesTree;$typecreator31.apply.symdef$_$281" class="delimiter">[</a><span title="Map[_, _]">Map</span><span class="delimiter">[</span>_, _<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                                  <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.writesSelect" title="c.universe.Select">writesSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;map&quot;)" class="string">&quot;map&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                                <span class="keyword">else</span> <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                              <span class="delimiter">)</span>
                            <span class="delimiter">}</span>

                          <span title="c.universe.Apply">writesTree</span>
                        <span class="delimiter">}</span>
                    <span class="delimiter">}</span>.<span title="(f: (c.universe.Apply, c.universe.Apply) =&gt; c.universe.Apply)c.universe.Apply">reduceLeft</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.acc">acc</a>, <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.r">r</a><span class="delimiter">)</span> =&gt;
                      <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.acc" title="c.universe.Apply">acc</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;and&quot;)" class="string">&quot;and&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                        <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild.$anonfun.r" title="c.universe.Apply">r</a><span class="delimiter">)</span>
                      <span class="delimiter">)</span>
                    <span class="delimiter">}</span>

                    <span class="comment">// builds the final Reads using apply method</span>
                    <span class="comment">//val applyMethod = Ident( companionSymbol.name )</span>
                    <span class="keyword">val</span> <a title="c.universe.Function" id="play.api.libs.json.JsMacroImpl.writesImpl.applyMethod">applyMethod</a> =
                      <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(vparams: List[c.universe.ValDef], body: c.universe.Tree)c.universe.Function">Function</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(z: List[c.universe.ValDef])(f: (List[c.universe.ValDef], c.universe.Symbol) =&gt; List[c.universe.ValDef])List[c.universe.ValDef]">foldLeft</span><span class="delimiter">(</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span title="List[c.universe.ValDef]">l</span>, <span title="c.universe.Symbol">e</span><span class="delimiter">)</span> =&gt;
                          <span title="List[c.universe.ValDef]">l</span> <span title="(elem: c.universe.ValDef)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.ValDef],c.universe.ValDef,List[c.universe.ValDef]])List[c.universe.ValDef]">:+</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TermName, tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.ValDef">ValDef</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(flags: c.universe.FlagSet)c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.FlagSet">PARAM</a><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="c.universe.Symbol">e</span>.<span title="=&gt; c.universe.Name">name</span>.<span title="=&gt; String">encoded</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="()c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.Tree">EmptyTree</a><span class="delimiter">)</span>
                        <span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                          <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;apply&quot;)" class="string">&quot;apply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                          <a href="#play.api.libs.json.JsMacroImpl.writesImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(z: List[c.universe.Tree])(f: (List[c.universe.Tree], c.universe.Symbol) =&gt; List[c.universe.Tree])List[c.universe.Tree]">foldLeft</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span title="List[c.universe.Tree]">l</span>, <span title="c.universe.Symbol">e</span><span class="delimiter">)</span> =&gt;
                            <span title="List[c.universe.Tree]">l</span> <span title="(elem: c.universe.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Tree],c.universe.Tree,List[c.universe.Tree]])List[c.universe.Tree]">:+</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="c.universe.Symbol">e</span>.<span title="=&gt; c.universe.Name">name</span>.<span title="=&gt; String">encoded</span><span class="delimiter">)</span><span class="delimiter">)</span>
                          <span class="delimiter">)</span>
                        <span class="delimiter">)</span>
                      <span class="delimiter">)</span>

                    <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.writesImpl.unapplyMethod">unapplyMethod</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                      <a href="#play.api.libs.json.JsMacroImpl.writesImpl.unliftIdent" title="c.universe.Select">unliftIdent</a>,
                      <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.unapply" title="c.universe.MethodSymbol">unapply</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>
                      <span class="delimiter">)</span>
                    <span class="delimiter">)</span>

                    <span class="comment">// if case class has one single field, needs to use inmap instead of canbuild.apply</span>
                    <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.writesImpl.finalTree">finalTree</a> = <span title="c.universe.Apply" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                      <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild" title="c.universe.Apply">canBuild</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;apply&quot;)" class="string">&quot;apply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                        <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.unapplyMethod" title="c.universe.Apply">unapplyMethod</a><span class="delimiter">)</span>
                      <span class="delimiter">)</span>
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                      <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.canBuild" title="c.universe.Apply">canBuild</a>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;contramap&quot;)" class="string">&quot;contramap&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                        <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.unapplyMethod" title="c.universe.Apply">unapplyMethod</a><span class="delimiter">)</span>
                      <span class="delimiter">)</span>
                    <span class="delimiter">}</span>
                    <span class="comment">//println(&quot;finalTree: &quot;+finalTree)</span>

                    <span title="c.Expr[play.api.libs.json.Writes[A]]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.hasRec" title="Boolean">hasRec</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                      <span class="keyword">val</span> <span title="c.universe.Block">block</span> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(stats: c.universe.Tree*)c.universe.Block">Block</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(expr: c.universe.Tree, selectors: List[c.universe.ImportSelector])c.universe.Import">Import</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.functionalSyntaxPkg" title="c.universe.Select">functionalSyntaxPkg</a>, <span title="(xs: c.universe.ImportSelector*)List[c.universe.ImportSelector]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(name: c.universe.Name, namePos: Int, rename: c.universe.Name, renamePos: Int)c.universe.ImportSelector">ImportSelector</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">WILDCARD</span>, -<span title="Int(-1)" class="int">1</span>, <span title="Null(null)" class="keyword">null</span>, -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.finalTree" title="c.universe.Apply">finalTree</a>
                      <span class="delimiter">)</span>
                      <span class="comment">//println(&quot;block:&quot;+block)</span>
                      <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[play.api.libs.json.Writes[A]])c.Expr[play.api.libs.json.Writes[A]]" class="delimiter">[</span><a href="Writes.scala.html#play.api.libs.json;Writes" title="play.api.libs.json.Writes[A]">Writes</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="c.universe.type" id="play.api.libs.json.JsMacroImpl.writesImpl;$typecreator32.apply.$m" class="delimiter">(</a><span title="c.universe.Block">block</span><span class="delimiter">)</span>
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                      <span class="keyword">val</span> <a title="c.universe.TermName" id="play.api.libs.json.JsMacroImpl.writesImpl.helper">helper</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;helper&quot;)" class="string">&quot;helper&quot;</span><span class="delimiter">)</span>
                      <span class="keyword">val</span> <a title="c.universe.ValDef" id="play.api.libs.json.JsMacroImpl.writesImpl.helperVal">helperVal</a> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TermName, tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.ValDef">ValDef</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="()c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.helper" title="c.universe.TermName">helper</a>,
                        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit attag: c.universe.WeakTypeTag[play.api.libs.json.util.LazyHelper[play.api.libs.json.Writes,A]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.helperVal;$typecreator33.apply.$m" class="delimiter">[</a>play.api.libs.json.util.<a href="Util.scala.html#play.api.libs.json.util;LazyHelper" title="play.api.libs.json.util.LazyHelper[play.api.libs.json.Writes,A]">LazyHelper</a><span class="delimiter">[</span>Writes, A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.lazyHelperSelect" title="c.universe.Select">lazyHelperSelect</a>, <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.finalTree" title="c.universe.Apply">finalTree</a><span class="delimiter">)</span><span class="delimiter">)</span>
                      <span class="delimiter">)</span>

                      <span class="keyword">val</span> <span title="c.universe.Select">block</span> = <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(stats: c.universe.Tree*)c.universe.Block">Block</a><span class="delimiter">(</span>
                          <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(expr: c.universe.Tree, selectors: List[c.universe.ImportSelector])c.universe.Import">Import</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.functionalSyntaxPkg" title="c.universe.Select">functionalSyntaxPkg</a>, <span title="(xs: c.universe.ImportSelector*)List[c.universe.ImportSelector]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(name: c.universe.Name, namePos: Int, rename: c.universe.Name, renamePos: Int)c.universe.ImportSelector">ImportSelector</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">WILDCARD</span>, -<span title="Int(-1)" class="int">1</span>, <span title="Null(null)" class="keyword">null</span>, -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                          <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TypeName, tparams: List[c.universe.TypeDef], impl: c.universe.Template)c.universe.ClassDef">ClassDef</a><span class="delimiter">(</span>
                            <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(flags: c.universe.FlagSet)c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.FlagValues">Flag</a>.<span title="=&gt; c.universe.FlagSet">FINAL</span><span class="delimiter">)</span>,
                            <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;$anon&quot;)" class="string">&quot;$anon&quot;</span><span class="delimiter">)</span>,
                            List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>,
                            <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(parents: List[c.universe.Tree], self: c.universe.ValDef, body: List[c.universe.Tree])c.universe.Template">Template</a><span class="delimiter">(</span>
                              <span title="(xs: c.universe.AppliedTypeTree*)List[c.universe.AppliedTypeTree]">List</span><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(tpt: c.universe.Tree, args: List[c.universe.Tree])c.universe.AppliedTypeTree">AppliedTypeTree</a><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.writesImpl.lazyHelperSelect" title="c.universe.Select">lazyHelperSelect</a>,
                                  <span title="(xs: c.universe.Ident*)List[c.universe.Ident]">List</span><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit attag: c.universe.WeakTypeTag[play.api.libs.json.Writes[A]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.block;$typecreator34.apply.$m" class="delimiter">[</a><a href="Writes.scala.html#play.api.libs.json;Writes" title="play.api.libs.json.Writes[A]">Writes</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span><span class="delimiter">)</span>,
                                    <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.evidence$2" title="(implicit attag: c.universe.WeakTypeTag[A])c.universe.Type" class="delimiter">[</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl;A" title="A">A</a><span class="delimiter">]</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                              <span class="delimiter">)</span>,
                              <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.ValDef">emptyValDef</a>,
                              <span title="(xs: c.universe.ValOrDefDef with c.universe.MemberDef with c.universe.ValOrDefDefApi with c.universe.SymTree with c.universe.NameTree with c.universe.DefTreeApi with c.universe.Tree with c.universe.NameTreeApi*)List[c.universe.ValOrDefDef with c.universe.MemberDef with c.universe.ValOrDefDefApi with c.universe.SymTree with c.universe.NameTree with c.universe.DefTreeApi with c.universe.Tree with c.universe.NameTreeApi]">List</span><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.Name, tparams: List[c.universe.TypeDef], vparamss: List[List[c.universe.ValDef]], tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.DefDef">DefDef</a><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="()c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">CONSTRUCTOR</span>,
                                  List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>,
                                  <span title="(xs: List[Nothing]*)List[List[Nothing]]">List</span><span class="delimiter">(</span>List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="()c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(stats: c.universe.Tree*)c.universe.Block">Block</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                      <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qual: c.universe.Tree, mix: c.universe.TypeName)c.universe.Super">Super</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qual: c.universe.TypeName)c.universe.This">This</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">EMPTY</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">EMPTY</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">CONSTRUCTOR</span><span class="delimiter">)</span>,
                                      List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>
                                    <span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>,
                                <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TermName, tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.ValDef">ValDef</a><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(flags: c.universe.FlagSet)c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.FlagValues">Flag</a>.<a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="implicit scala.reflect.api.FlagSets.addFlagOps : (left: c.universe.FlagSet)c.universe.FlagOps">OVERRIDE</a> <span title="(right: c.universe.FlagSet)c.universe.FlagSet">|</span> <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.FlagValues">Flag</a>.<span title="=&gt; c.universe.FlagSet">LAZY</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyStuff&quot;)" class="string">&quot;lazyStuff&quot;</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(tpt: c.universe.Tree, args: List[c.universe.Tree])c.universe.AppliedTypeTree">AppliedTypeTree</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(implicit attag: c.universe.WeakTypeTag[play.api.libs.json.Writes[A]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.writesImpl.block;$typecreator35.apply.$m" class="delimiter">[</a><a href="Writes.scala.html#play.api.libs.json;Writes" title="play.api.libs.json.Writes[A]">Writes</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span><span class="delimiter">)</span>, <span title="(xs: c.universe.TypeTree*)List[c.universe.TypeTree]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.evidence$2" title="(implicit attag: c.universe.WeakTypeTag[A])c.universe.Type" class="delimiter">[</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.writesImpl.finalTree" title="c.universe.Apply">finalTree</a>
                                <span class="delimiter">)</span>
                              <span class="delimiter">)</span>
                            <span class="delimiter">)</span>
                          <span class="delimiter">)</span>,
                          <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(tpt: c.universe.Tree)c.universe.New">New</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;$anon&quot;)" class="string">&quot;$anon&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">CONSTRUCTOR</span><span class="delimiter">)</span>, List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
                        <span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyStuff&quot;)" class="string">&quot;lazyStuff&quot;</span><span class="delimiter">)</span>
                      <span class="delimiter">)</span>

                      <span class="comment">//println(&quot;block:&quot;+block)</span>

                      <span class="comment">/*val reif = reify(
                        new play.api.libs.json.util.LazyHelper[Format, A] {
                          override lazy val lazyStuff: Format[A] = null
                        }
                      )
                      //println(&quot;RAW:&quot;+showRaw(reif.tree, printKinds = true))*/</span>
                      <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[play.api.libs.json.Writes[A]])c.Expr[play.api.libs.json.Writes[A]]" class="delimiter">[</span><a href="Writes.scala.html#play.api.libs.json;Writes" title="play.api.libs.json.Writes[A]">Writes</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="c.universe.type" id="play.api.libs.json.JsMacroImpl.writesImpl;$typecreator36.apply.$m" class="delimiter">(</a><span title="c.universe.Select">block</span><span class="delimiter">)</span>
                    <span class="delimiter">}</span>
                  <span class="keyword">case</span> <a title="List[c.universe.Type]" id="play.api.libs.json.JsMacroImpl.writesImpl.l">l</a> =&gt; <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;No implicit Writes for &quot;)">No implicit Writes for $</span><span class="delimiter">{</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.l" title="List[c.universe.Type]">l</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot; available.&quot;)" class="string"> available.&quot;</span><span class="delimiter">)</span>
                <span class="delimiter">}</span>

              <span class="keyword">case</span> <span title="None.type">None</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;No apply function found matching unapply parameters&quot;)" class="string">&quot;No apply function found matching unapply parameters&quot;</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>

        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="[A](c: scala.reflect.macros.Context)(implicit evidence$3: c.WeakTypeTag[A])c.Expr[play.api.libs.json.Format[A]]" id="play.api.libs.json.JsMacroImpl.formatImpl">formatImpl</a><span class="delimiter">[</span><a title="" id="play.api.libs.json.JsMacroImpl.formatImpl;A">A</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="play.api.libs.json.JsMacroImpl.formatImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span>: c.<span title="c.Expr[play.api.libs.json.Format[A]]">Expr</span><span class="delimiter">[</span>Format<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">import</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
    <span class="keyword">import</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="=&gt; c.universe.FlagValues">Flag</span>._

    <span class="keyword">val</span> <a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.formatImpl.companioned">companioned</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.evidence$3" title="(implicit attag: c.universe.WeakTypeTag[A])c.universe.Type" class="delimiter">[</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl;A" title="A">A</a><span class="delimiter">]</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span>
    <span class="keyword">val</span> <a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.formatImpl.companionSymbol">companionSymbol</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.companioned" title="c.universe.Symbol">companioned</a>.<span title="=&gt; c.universe.Symbol">companionSymbol</span>
    <span class="keyword">val</span> <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.companionType">companionType</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a>.<span title="=&gt; c.universe.Type">typeSignature</span>

    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.formatImpl.libsPkg">libsPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;play&quot;)" class="string">&quot;play&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;api&quot;)" class="string">&quot;api&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;libs&quot;)" class="string">&quot;libs&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.formatImpl.jsonPkg">jsonPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.libsPkg" title="c.universe.Select">libsPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;json&quot;)" class="string">&quot;json&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.formatImpl.functionalSyntaxPkg">functionalSyntaxPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.libsPkg" title="c.universe.Select">libsPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;functional&quot;)" class="string">&quot;functional&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;syntax&quot;)" class="string">&quot;syntax&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.formatImpl.utilPkg">utilPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.jsonPkg" title="c.universe.Select">jsonPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;util&quot;)" class="string">&quot;util&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.formatImpl.jsPathSelect">jsPathSelect</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.jsonPkg" title="c.universe.Select">jsonPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;JsPath&quot;)" class="string">&quot;JsPath&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.formatImpl.readsSelect">readsSelect</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.jsonPkg" title="c.universe.Select">jsonPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;Reads&quot;)" class="string">&quot;Reads&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.formatImpl.writesSelect">writesSelect</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.jsonPkg" title="c.universe.Select">jsonPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;Writes&quot;)" class="string">&quot;Writes&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.formatImpl.unliftIdent">unliftIdent</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.functionalSyntaxPkg" title="c.universe.Select">functionalSyntaxPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;unlift&quot;)" class="string">&quot;unlift&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.formatImpl.lazyHelperSelect">lazyHelperSelect</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.utilPkg" title="c.universe.Select">utilPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;LazyHelper&quot;)" class="string">&quot;LazyHelper&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <a href="#play.api.libs.json.JsMacroImpl.formatImpl.companionType" title="c.universe.Type">companionType</a>.<span title="(name: c.universe.Name)c.universe.Symbol">declaration</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="implicit scala.reflect.api.Names.stringToTermName : (s: String)c.universe.TermName">stringToTermName</a><span class="delimiter">(</span><span title="String(&quot;unapply&quot;)" class="string">&quot;unapply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="c.Expr[play.api.libs.json.Format[A]]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.Symbol">NoSymbol</a> =&gt; <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;No unapply function found&quot;)" class="string">&quot;No unapply function found&quot;</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <span title="c.universe.Symbol">s</span> =&gt;
        <span class="keyword">val</span> <a title="c.universe.MethodSymbol" id="play.api.libs.json.JsMacroImpl.formatImpl.unapply">unapply</a> = <span title="c.universe.Symbol">s</span>.<span title="=&gt; c.universe.MethodSymbol">asMethod</span>
        <span class="keyword">val</span> <a title="Any" id="play.api.libs.json.JsMacroImpl.formatImpl.unapplyReturnTypes">unapplyReturnTypes</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.unapply" title="c.universe.MethodSymbol">unapply</a>.<span title="=&gt; c.universe.Type">returnType</span> <span title="Any" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> =&gt;
            <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Unapply of &quot;)">Unapply of $</span><span class="delimiter">{</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a><span class="delimiter">}</span><span title="String(&quot; has no parameters. Are you using an empty case class?&quot;)" class="string"> has no parameters. Are you using an empty case class?&quot;</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="List[c.universe.Type]">args</span><span class="delimiter">)</span> =&gt;
            <span title="List[c.universe.Type]">args</span>.<span title="=&gt; c.universe.Type">head</span> <span title="Any" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> <span title="c.universe.TypeRef">t</span> @ <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> =&gt; <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
              <span class="keyword">case</span> <span title="c.universe.TypeRef">t</span> @ <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="List[c.universe.Type]">args</span><span class="delimiter">)</span> =&gt;
                <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.unapplyReturnTypes;$typecreator37.apply.symdef$_$291" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit ttag: c.universe.TypeTag[Seq[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.unapplyReturnTypes;$typecreator38.apply.symdef$_$301" class="delimiter">[</a><span title="Seq[_]">Seq</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit ttag: c.universe.TypeTag[Set[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.unapplyReturnTypes;$typecreator39.apply.symdef$_$311" class="delimiter">[</a><span title="Set[_]">Set</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit ttag: c.universe.TypeTag[Map[_, _]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.unapplyReturnTypes;$typecreator40.apply.symdef$_$331" class="delimiter">[</a><span title="Map[_, _]">Map</span><span class="delimiter">[</span>_, _<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
                <span class="keyword">else</span> <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit ttag: c.universe.TypeTag[Product])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.unapplyReturnTypes;$typecreator41.apply.$m" class="delimiter">[</a><span title="Product">Product</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.Type])Some[List[c.universe.Type]]">Some</span><span class="delimiter">(</span><span title="List[c.universe.Type]">args</span><span class="delimiter">)</span>
              <span class="keyword">case</span> _ =&gt; <span title="None.type">None</span>
            <span class="delimiter">}</span>
          <span class="keyword">case</span> _ =&gt; <span title="None.type">None</span>
        <span class="delimiter">}</span>

        <span class="comment">//println(&quot;Unapply return type:&quot; + unapplyReturnTypes)</span>

        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.companionType" title="c.universe.Type">companionType</a>.<span title="(name: c.universe.Name)c.universe.Symbol">declaration</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="implicit scala.reflect.api.Names.stringToTermName : (s: String)c.universe.TermName">stringToTermName</a><span class="delimiter">(</span><span title="String(&quot;apply&quot;)" class="string">&quot;apply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="c.Expr[play.api.libs.json.Format[A]]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.Symbol">NoSymbol</a> =&gt; <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;No apply function found&quot;)" class="string">&quot;No apply function found&quot;</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="c.universe.Symbol">s</span> =&gt;
            <span class="comment">// searches apply method corresponding to unapply</span>
            <span class="keyword">val</span> <a title="List[c.universe.Symbol]" id="play.api.libs.json.JsMacroImpl.formatImpl.applies">applies</a> = <span title="c.universe.Symbol">s</span>.<span title="=&gt; c.universe.MethodSymbol">asMethod</span>.<span title="=&gt; List[c.universe.Symbol]">alternatives</span>
            <span class="keyword">val</span> <span title="Option[c.universe.MethodSymbol]">apply</span> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.applies" title="List[c.universe.Symbol]">applies</a>.<span title="(pf: PartialFunction[c.universe.Symbol,c.universe.MethodSymbol])Option[c.universe.MethodSymbol]">collectFirst</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[c.universe.Symbol,c.universe.MethodSymbol] with Serializable" id="play.api.libs.json.JsMacroImpl.formatImpl.apply;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
              <span class="keyword">case</span> <span class="delimiter">(</span><a title="c.universe.MethodSymbol" id="play.api.libs.json.JsMacroImpl.formatImpl.apply;$anonfun.isDefinedAt.apply">apply</a>: <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(x: Any)Option[c.universe.MethodSymbol]">MethodSymbol</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.apply;$anonfun.isDefinedAt.apply" title="c.universe.MethodSymbol">apply</a>.<span title="=&gt; List[List[c.universe.Symbol]]">paramss</span>.<span title="=&gt; Option[List[c.universe.Symbol]]">headOption</span>.<span title="(f: List[c.universe.Symbol] =&gt; List[c.universe.Type])Option[List[c.universe.Type]]">map</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.apply;$anonfun.applyOrElse.$anonfun.x$13" title="List[c.universe.Symbol]">_</a>.<span title="(f: c.universe.Symbol =&gt; c.universe.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Symbol],c.universe.Type,List[c.universe.Type]])List[c.universe.Type]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,c.universe.Type,List[c.universe.Type]]" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.apply;$anonfun.applyOrElse.$anonfun.$anonfun.x$14" title="c.universe.Symbol">_</a>.<span title="=&gt; c.universe.TermSymbol">asTerm</span>.<span title="=&gt; c.universe.Type">typeSignature</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: Any)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.unapplyReturnTypes" title="Any">unapplyReturnTypes</a><span class="delimiter">)</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.formatImpl.apply;$anonfun.isDefinedAt.apply" title="c.universe.MethodSymbol">apply</a>
            <span class="delimiter">}</span>
            <span title="Option[c.universe.MethodSymbol]">apply</span> <span title="c.Expr[play.api.libs.json.Format[A]]" class="keyword">match</span> <span class="delimiter">{</span>
              <span class="keyword">case</span> Some<span class="delimiter">(</span><span title="c.universe.MethodSymbol">apply</span><span class="delimiter">)</span> =&gt;
                <span class="comment">//println(&quot;apply found:&quot; + apply)    </span>
                <span class="keyword">val</span> <a title="List[c.universe.Symbol]" id="play.api.libs.json.JsMacroImpl.formatImpl.params">params</a> = <span title="c.universe.MethodSymbol">apply</span>.<span title="=&gt; List[List[c.universe.Symbol]]">paramss</span>.<span title="=&gt; List[c.universe.Symbol]">head</span> <span class="comment">//verify there is a single parameter group</span>

                <span class="keyword">val</span> <a title="List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]" id="play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits">inferedImplicits</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(f: c.universe.Symbol =&gt; c.universe.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Symbol],c.universe.Type,List[c.universe.Type]])List[c.universe.Type]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,c.universe.Type,List[c.universe.Type]]" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.x$15" title="c.universe.Symbol">_</a>.<span title="=&gt; c.universe.Type">typeSignature</span><span class="delimiter">)</span>.<span title="(f: c.universe.Type =&gt; (c.universe.Type, c.Tree, Boolean, c.universe.Type))(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Type],(c.universe.Type, c.Tree, Boolean, c.universe.Type),List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]])List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,(c.universe.Type, c.Tree, Boolean, c.universe.Type),List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]]" class="delimiter">{</span> <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.implType">implType</a> =&gt;

                  <span class="keyword">val</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.isRecursive" title="(Boolean, c.universe.Type)" class="delimiter">(</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.x$16" title="Boolean" id="play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.isRecursive">isRecursive</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.x$16" title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.tpe">tpe</a><span class="delimiter">)</span> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a> <span title="(Boolean, c.universe.Type)" class="keyword">match</span> <span class="delimiter">{</span>
                    <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, <span title="c.universe.Symbol">t</span>, <a title="List[c.universe.Type]" id="play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.x$16.args">args</a><span class="delimiter">)</span> =&gt;
                      <span class="comment">// Option[_] needs special treatment because we need to use XXXOpt</span>
                      <span title="(Boolean, c.universe.Type)" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.x$16;$typecreator42.apply.symdef$_$341" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                        <span title="(_1: Boolean, _2: c.universe.Type)(Boolean, c.universe.Type)" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.x$16.args" title="List[c.universe.Type]">args</a>.<span title="(p: c.universe.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <span title="c.universe.Type">a</span> =&gt; <span title="c.universe.Type">a</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.companioned" title="c.universe.Symbol">companioned</a> <span class="delimiter">}</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.x$16.args" title="List[c.universe.Type]">args</a>.<span title="=&gt; c.universe.Type">head</span><span class="delimiter">)</span>
                      <span class="keyword">else</span> <span title="(_1: Boolean, _2: c.universe.Type)(Boolean, c.universe.Type)" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.x$16.args" title="List[c.universe.Type]">args</a>.<span title="(p: c.universe.Type =&gt; Boolean)Boolean">exists</span> <span class="delimiter">{</span> <span title="c.universe.Type">a</span> =&gt; <span title="c.universe.Type">a</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.companioned" title="c.universe.Symbol">companioned</a> <span class="delimiter">}</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a><span class="delimiter">)</span>
                    <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, <span title="c.universe.Symbol">t</span>, _<span class="delimiter">)</span> =&gt;
                      <span title="(_1: Boolean, _2: c.universe.Type)(Boolean, c.universe.Type)" class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a><span class="delimiter">)</span>
                  <span class="delimiter">}</span>

                  <span class="comment">// builds reads implicit from expected type</span>
                  <span class="keyword">val</span> <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.neededImplicitType">neededImplicitType</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(tycon: c.universe.Type, args: List[c.universe.Type])c.universe.Type">appliedType</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit attag: c.universe.WeakTypeTag[play.api.libs.json.Format[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.neededImplicitType;$typecreator43.apply.symdef$_$351" class="delimiter">[</a><a href="Format.scala.html#play.api.libs.json;Format" title="play.api.libs.json.Format[_]">Format</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.tpe" title="c.universe.Type">tpe</a> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.neededImplicitType.x$17" title="(x: c.universe.Type)List[c.universe.Type]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
                  <span class="comment">// infers implicit</span>
                  <span class="keyword">val</span> <a title="c.Tree" id="play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.neededImplicit">neededImplicit</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pt: c.Type, silent: Boolean, withMacrosDisabled: Boolean, pos: c.Position)c.Tree">inferImplicitValue</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.neededImplicitType" title="c.universe.Type">neededImplicitType</a><span class="delimiter">)</span>
                  <span title="(_1: c.universe.Type, _2: c.Tree, _3: Boolean, _4: c.universe.Type)(c.universe.Type, c.Tree, Boolean, c.universe.Type)" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.implType" title="c.universe.Type">implType</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.neededImplicit" title="c.Tree">neededImplicit</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.isRecursive" title="Boolean">isRecursive</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits.$anonfun.tpe" title="c.universe.Type">tpe</a><span class="delimiter">)</span>
                <span class="delimiter">}</span>

                <span class="comment">// if any implicit is missing, abort</span>
                <span class="comment">// else goes on</span>
                <a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits" title="List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]">inferedImplicits</a>.<span title="(pf: PartialFunction[(c.universe.Type, c.Tree, Boolean, c.universe.Type),c.universe.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)],c.universe.Type,List[c.universe.Type]])List[c.universe.Type]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[(c.universe.Type, c.Tree, Boolean, c.universe.Type),c.universe.Type] with Serializable" id="play.api.libs.json.JsMacroImpl.formatImpl;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl;$anonfun.isDefinedAt.t">t</a>, <a title="c.Tree" id="play.api.libs.json.JsMacroImpl.formatImpl;$anonfun.isDefinedAt.impl">impl</a>, <a title="Boolean" id="play.api.libs.json.JsMacroImpl.formatImpl;$anonfun.isDefinedAt.rec">rec</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl;$anonfun.isDefinedAt.impl" title="c.Tree">impl</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.Tree">EmptyTree</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl;$anonfun.isDefinedAt.rec" title="Boolean">rec</a><span class="delimiter">)</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.formatImpl;$anonfun.isDefinedAt.t" title="c.universe.Type">t</a> <span class="delimiter">}</span> <span title="c.Expr[play.api.libs.json.Format[A]]" class="keyword">match</span> <span class="delimiter">{</span>
                  <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.<unapply-selector>" title="(x: List[c.universe.Type])Some[List[c.universe.Type]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt;
                    <span class="keyword">val</span> <a title="List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]" id="play.api.libs.json.JsMacroImpl.formatImpl.namedImplicits">namedImplicits</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(f: c.universe.Symbol =&gt; c.universe.Name)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Symbol],c.universe.Name,List[c.universe.Name]])List[c.universe.Name]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,c.universe.Name,List[c.universe.Name]]" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.namedImplicits.$anonfun.x$18" title="c.universe.Symbol">_</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>.<span title="(that: scala.collection.GenIterable[(c.universe.Type, c.Tree, Boolean, c.universe.Type)])(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Name],(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type)),List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]])List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]">zip</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type)),List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]]" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.inferedImplicits" title="List[(c.universe.Type, c.Tree, Boolean, c.universe.Type)]">inferedImplicits</a><span class="delimiter">)</span>
                    <span class="comment">//println(&quot;Found implicits:&quot;+namedImplicits)</span>

                    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.formatImpl.helperMember">helperMember</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qual: c.universe.TypeName)c.universe.This">This</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">EMPTY</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyStuff&quot;)" class="string">&quot;lazyStuff&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

                    <span class="keyword">var</span> <a title="Boolean" id="play.api.libs.json.JsMacroImpl.formatImpl.hasRec">hasRec</a> = <span title="Boolean(false)" class="keyword">false</span>

                    <span class="comment">// combines all reads into CanBuildX</span>
                    <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild">canBuild</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.namedImplicits" title="List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))]">namedImplicits</a>.<span title="(f: ((c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))) =&gt; c.universe.Apply)(implicit bf: scala.collection.generic.CanBuildFrom[List[(c.universe.Name, (c.universe.Type, c.Tree, Boolean, c.universe.Type))],c.universe.Apply,List[c.universe.Apply]])List[c.universe.Apply]">map</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.x0$3" title="c.universe.Apply" class="delimiter">{</a>
                      <span class="keyword">case</span> <span class="delimiter">(</span><a title="c.universe.Name" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.name">name</a>, <span class="delimiter">(</span><a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.t">t</a>, <a title="c.Tree" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.impl">impl</a>, <a title="Boolean" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.rec">rec</a>, <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.tpe">tpe</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
                        <span class="comment">// inception of (__ \ name).read(impl)</span>
                        <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.jspathTree">jspathTree</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                          <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.jsPathSelect" title="c.universe.Select">jsPathSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span>scala.reflect.<span title="scala.reflect.NameTransformer.type">NameTransformer</span>.<span title="(name: String)String">encode</span><span class="delimiter">(</span><span title="String(&quot;\\&quot;)" class="string">&quot;\\&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                          <span title="(xs: c.universe.Literal*)List[c.universe.Literal]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(value: c.universe.Constant)c.universe.Literal">Literal</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(value: Any)c.universe.Constant">Constant</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.name" title="c.universe.Name">name</a>.<span title="=&gt; String">decoded</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                        <span class="delimiter">)</span>

                        <span title="c.universe.Apply" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.rec" title="Boolean">rec</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                          <span class="keyword">val</span> <span title="c.universe.Apply">formatTree</span> =
                            <span title="c.universe.Apply" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.t" title="c.universe.Type">t</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.formatTree;$typecreator44.apply.symdef$_$361" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                              <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;formatNullable&quot;)" class="string">&quot;formatNullable&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                <span title="(xs: c.Tree*)List[c.Tree]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.impl" title="c.Tree">impl</a><span class="delimiter">)</span>
                              <span class="delimiter">)</span>
                            <span class="keyword">else</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                              <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;format&quot;)" class="string">&quot;format&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                              <span title="(xs: c.Tree*)List[c.Tree]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.impl" title="c.Tree">impl</a><span class="delimiter">)</span>
                            <span class="delimiter">)</span>

                          <span title="c.universe.Apply">formatTree</span>
                        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                          <a href="#play.api.libs.json.JsMacroImpl.formatImpl.hasRec" title="Boolean">hasRec</a> = <span title="Boolean(true)" class="keyword">true</span>
                          <span class="keyword">val</span> <span title="c.universe.Apply">formatTree</span> =
                            <span title="c.universe.Apply" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.t" title="c.universe.Type">t</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.formatTree;$typecreator45.apply.symdef$_$371" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                              <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;formatNullable&quot;)" class="string">&quot;formatNullable&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.jsPathSelect" title="c.universe.Select">jsPathSelect</a>, List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyFormat&quot;)" class="string">&quot;lazyFormat&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                              <span class="delimiter">)</span>

                            <span class="keyword">else</span> <span class="delimiter">{</span>
                              <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyFormat&quot;)" class="string">&quot;lazyFormat&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit ttag: c.universe.TypeTag[List[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.formatTree;$typecreator46.apply.symdef$_$381" class="delimiter">[</a><span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                                  <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.readsSelect" title="c.universe.Select">readsSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;list&quot;)" class="string">&quot;list&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.writesSelect" title="c.universe.Select">writesSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;list&quot;)" class="string">&quot;list&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                                <span class="keyword">else</span> <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit ttag: c.universe.TypeTag[Set[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.formatTree;$typecreator47.apply.symdef$_$391" class="delimiter">[</a><span title="Set[_]">Set</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                                  <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.readsSelect" title="c.universe.Select">readsSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;set&quot;)" class="string">&quot;set&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.writesSelect" title="c.universe.Select">writesSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;set&quot;)" class="string">&quot;set&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                                <span class="keyword">else</span> <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit ttag: c.universe.TypeTag[Seq[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.formatTree;$typecreator48.apply.symdef$_$401" class="delimiter">[</a><span title="Seq[_]">Seq</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                                  <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.readsSelect" title="c.universe.Select">readsSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;seq&quot;)" class="string">&quot;seq&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.writesSelect" title="c.universe.Select">writesSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;seq&quot;)" class="string">&quot;seq&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                                <span class="keyword">else</span> <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit ttag: c.universe.TypeTag[Map[_, _]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.formatTree;$typecreator49.apply.symdef$_$421" class="delimiter">[</a><span title="Map[_, _]">Map</span><span class="delimiter">[</span>_, _<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                                  <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.readsSelect" title="c.universe.Select">readsSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;map&quot;)" class="string">&quot;map&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.writesSelect" title="c.universe.Select">writesSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;map&quot;)" class="string">&quot;map&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                    <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                                <span class="keyword">else</span> <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
                              <span class="delimiter">)</span>
                            <span class="delimiter">}</span>

                          <span title="c.universe.Apply">formatTree</span>
                        <span class="delimiter">}</span>
                    <span class="delimiter">}</span>.<span title="(f: (c.universe.Apply, c.universe.Apply) =&gt; c.universe.Apply)c.universe.Apply">reduceLeft</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.acc">acc</a>, <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.r">r</a><span class="delimiter">)</span> =&gt;
                      <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.acc" title="c.universe.Apply">acc</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;and&quot;)" class="string">&quot;and&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                        <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild.$anonfun.r" title="c.universe.Apply">r</a><span class="delimiter">)</span>
                      <span class="delimiter">)</span>
                    <span class="delimiter">}</span>

                    <span class="comment">// builds the final Reads using apply method</span>
                    <span class="comment">//val applyMethod = Ident( companionSymbol.name )</span>
                    <span class="keyword">val</span> <a title="c.universe.Function" id="play.api.libs.json.JsMacroImpl.formatImpl.applyMethod">applyMethod</a> =
                      <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(vparams: List[c.universe.ValDef], body: c.universe.Tree)c.universe.Function">Function</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(z: List[c.universe.ValDef])(f: (List[c.universe.ValDef], c.universe.Symbol) =&gt; List[c.universe.ValDef])List[c.universe.ValDef]">foldLeft</span><span class="delimiter">(</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span title="List[c.universe.ValDef]">l</span>, <span title="c.universe.Symbol">e</span><span class="delimiter">)</span> =&gt;
                          <span title="List[c.universe.ValDef]">l</span> <span title="(elem: c.universe.ValDef)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.ValDef],c.universe.ValDef,List[c.universe.ValDef]])List[c.universe.ValDef]">:+</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TermName, tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.ValDef">ValDef</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(flags: c.universe.FlagSet)c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.FlagSet">PARAM</a><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="c.universe.Symbol">e</span>.<span title="=&gt; c.universe.Name">name</span>.<span title="=&gt; String">encoded</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="()c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.Tree">EmptyTree</a><span class="delimiter">)</span>
                        <span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                          <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;apply&quot;)" class="string">&quot;apply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                          <a href="#play.api.libs.json.JsMacroImpl.formatImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(z: List[c.universe.Tree])(f: (List[c.universe.Tree], c.universe.Symbol) =&gt; List[c.universe.Tree])List[c.universe.Tree]">foldLeft</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><span title="List[c.universe.Tree]">l</span>, <span title="c.universe.Symbol">e</span><span class="delimiter">)</span> =&gt;
                            <span title="List[c.universe.Tree]">l</span> <span title="(elem: c.universe.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Tree],c.universe.Tree,List[c.universe.Tree]])List[c.universe.Tree]">:+</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="c.universe.Symbol">e</span>.<span title="=&gt; c.universe.Name">name</span>.<span title="=&gt; String">encoded</span><span class="delimiter">)</span><span class="delimiter">)</span>
                          <span class="delimiter">)</span>
                        <span class="delimiter">)</span>
                      <span class="delimiter">)</span>

                    <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.formatImpl.unapplyMethod">unapplyMethod</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                      <a href="#play.api.libs.json.JsMacroImpl.formatImpl.unliftIdent" title="c.universe.Select">unliftIdent</a>,
                      <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.unapply" title="c.universe.MethodSymbol">unapply</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>
                      <span class="delimiter">)</span>
                    <span class="delimiter">)</span>

                    <span class="comment">// if case class has one single field, needs to use inmap instead of canbuild.apply</span>
                    <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.formatImpl.finalTree">finalTree</a> = <span title="c.universe.Apply" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span class="delimiter">{</span>
                      <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild" title="c.universe.Apply">canBuild</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;apply&quot;)" class="string">&quot;apply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                        <span title="(xs: c.universe.TermTree with c.universe.Tree with c.universe.TermTreeApi*)List[c.universe.TermTree with c.universe.Tree with c.universe.TermTreeApi]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.applyMethod" title="c.universe.Function">applyMethod</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.unapplyMethod" title="c.universe.Apply">unapplyMethod</a><span class="delimiter">)</span>
                      <span class="delimiter">)</span>
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                      <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.canBuild" title="c.universe.Apply">canBuild</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;inmap&quot;)" class="string">&quot;inmap&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                        <span title="(xs: c.universe.TermTree with c.universe.Tree with c.universe.TermTreeApi*)List[c.universe.TermTree with c.universe.Tree with c.universe.TermTreeApi]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.applyMethod" title="c.universe.Function">applyMethod</a>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.unapplyMethod" title="c.universe.Apply">unapplyMethod</a><span class="delimiter">)</span>
                      <span class="delimiter">)</span>
                    <span class="delimiter">}</span>
                    <span class="comment">//println(&quot;finalTree: &quot;+finalTree)</span>

                    <span title="c.Expr[play.api.libs.json.Format[A]]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.hasRec" title="Boolean">hasRec</a><span class="delimiter">)</span> <span class="delimiter">{</span>
                      <span class="keyword">val</span> <span title="c.universe.Block">block</span> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(stats: c.universe.Tree*)c.universe.Block">Block</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(expr: c.universe.Tree, selectors: List[c.universe.ImportSelector])c.universe.Import">Import</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.functionalSyntaxPkg" title="c.universe.Select">functionalSyntaxPkg</a>, <span title="(xs: c.universe.ImportSelector*)List[c.universe.ImportSelector]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(name: c.universe.Name, namePos: Int, rename: c.universe.Name, renamePos: Int)c.universe.ImportSelector">ImportSelector</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">WILDCARD</span>, -<span title="Int(-1)" class="int">1</span>, <span title="Null(null)" class="keyword">null</span>, -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.finalTree" title="c.universe.Apply">finalTree</a>
                      <span class="delimiter">)</span>
                      <span class="comment">//println(&quot;block:&quot;+block)</span>
                      <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[play.api.libs.json.Format[A]])c.Expr[play.api.libs.json.Format[A]]" class="delimiter">[</span><a href="Format.scala.html#play.api.libs.json;Format" title="play.api.libs.json.Format[A]">Format</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="c.universe.type" id="play.api.libs.json.JsMacroImpl.formatImpl;$typecreator50.apply.$m" class="delimiter">(</a><span title="c.universe.Block">block</span><span class="delimiter">)</span>
                    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
                      <span class="keyword">val</span> <a title="c.universe.TermName" id="play.api.libs.json.JsMacroImpl.formatImpl.helper">helper</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;helper&quot;)" class="string">&quot;helper&quot;</span><span class="delimiter">)</span>
                      <span class="keyword">val</span> <a title="c.universe.ValDef" id="play.api.libs.json.JsMacroImpl.formatImpl.helperVal">helperVal</a> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TermName, tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.ValDef">ValDef</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="()c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.helper" title="c.universe.TermName">helper</a>,
                        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit attag: c.universe.WeakTypeTag[play.api.libs.json.util.LazyHelper[play.api.libs.json.Format,A]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.helperVal;$typecreator51.apply.$m" class="delimiter">[</a>play.api.libs.json.util.<a href="Util.scala.html#play.api.libs.json.util;LazyHelper" title="play.api.libs.json.util.LazyHelper[play.api.libs.json.Format,A]">LazyHelper</a><span class="delimiter">[</span>Format, A<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span><span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;LazyHelper&quot;)" class="string">&quot;LazyHelper&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.finalTree" title="c.universe.Apply">finalTree</a><span class="delimiter">)</span><span class="delimiter">)</span>
                      <span class="delimiter">)</span>

                      <span class="keyword">val</span> <span title="c.universe.Select">block</span> = <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(stats: c.universe.Tree*)c.universe.Block">Block</a><span class="delimiter">(</span>
                          <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(expr: c.universe.Tree, selectors: List[c.universe.ImportSelector])c.universe.Import">Import</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.functionalSyntaxPkg" title="c.universe.Select">functionalSyntaxPkg</a>, <span title="(xs: c.universe.ImportSelector*)List[c.universe.ImportSelector]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(name: c.universe.Name, namePos: Int, rename: c.universe.Name, renamePos: Int)c.universe.ImportSelector">ImportSelector</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">WILDCARD</span>, -<span title="Int(-1)" class="int">1</span>, <span title="Null(null)" class="keyword">null</span>, -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                          <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TypeName, tparams: List[c.universe.TypeDef], impl: c.universe.Template)c.universe.ClassDef">ClassDef</a><span class="delimiter">(</span>
                            <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(flags: c.universe.FlagSet)c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.FlagValues">Flag</a>.<span title="=&gt; c.universe.FlagSet">FINAL</span><span class="delimiter">)</span>,
                            <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;$anon&quot;)" class="string">&quot;$anon&quot;</span><span class="delimiter">)</span>,
                            List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>,
                            <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(parents: List[c.universe.Tree], self: c.universe.ValDef, body: List[c.universe.Tree])c.universe.Template">Template</a><span class="delimiter">(</span>
                              <span title="(xs: c.universe.AppliedTypeTree*)List[c.universe.AppliedTypeTree]">List</span><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(tpt: c.universe.Tree, args: List[c.universe.Tree])c.universe.AppliedTypeTree">AppliedTypeTree</a><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.lazyHelperSelect" title="c.universe.Select">lazyHelperSelect</a>,
                                  <span title="(xs: c.universe.Ident*)List[c.universe.Ident]">List</span><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit attag: c.universe.WeakTypeTag[play.api.libs.json.Format[A]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.block;$typecreator52.apply.$m" class="delimiter">[</a><a href="Format.scala.html#play.api.libs.json;Format" title="play.api.libs.json.Format[A]">Format</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span><span class="delimiter">)</span>,
                                    <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.evidence$3" title="(implicit attag: c.universe.WeakTypeTag[A])c.universe.Type" class="delimiter">[</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl;A" title="A">A</a><span class="delimiter">]</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span><span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>
                              <span class="delimiter">)</span>,
                              <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.ValDef">emptyValDef</a>,
                              <span title="(xs: c.universe.ValOrDefDef with c.universe.MemberDef with c.universe.ValOrDefDefApi with c.universe.SymTree with c.universe.NameTree with c.universe.DefTreeApi with c.universe.Tree with c.universe.NameTreeApi*)List[c.universe.ValOrDefDef with c.universe.MemberDef with c.universe.ValOrDefDefApi with c.universe.SymTree with c.universe.NameTree with c.universe.DefTreeApi with c.universe.Tree with c.universe.NameTreeApi]">List</span><span class="delimiter">(</span>
                                <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.Name, tparams: List[c.universe.TypeDef], vparamss: List[List[c.universe.ValDef]], tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.DefDef">DefDef</a><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="()c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">CONSTRUCTOR</span>,
                                  List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>,
                                  <span title="(xs: List[Nothing]*)List[List[Nothing]]">List</span><span class="delimiter">(</span>List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="()c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(stats: c.universe.Tree*)c.universe.Block">Block</a><span class="delimiter">(</span>
                                    <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                                      <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qual: c.universe.Tree, mix: c.universe.TypeName)c.universe.Super">Super</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qual: c.universe.TypeName)c.universe.This">This</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">EMPTY</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">EMPTY</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">CONSTRUCTOR</span><span class="delimiter">)</span>,
                                      List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>
                                    <span class="delimiter">)</span>
                                  <span class="delimiter">)</span>
                                <span class="delimiter">)</span>,
                                <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TermName, tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.ValDef">ValDef</a><span class="delimiter">(</span>
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(flags: c.universe.FlagSet)c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.FlagValues">Flag</a>.<a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="implicit scala.reflect.api.FlagSets.addFlagOps : (left: c.universe.FlagSet)c.universe.FlagOps">OVERRIDE</a> <span title="(right: c.universe.FlagSet)c.universe.FlagSet">|</span> <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.FlagValues">Flag</a>.<span title="=&gt; c.universe.FlagSet">LAZY</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyStuff&quot;)" class="string">&quot;lazyStuff&quot;</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(tpt: c.universe.Tree, args: List[c.universe.Tree])c.universe.AppliedTypeTree">AppliedTypeTree</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(implicit attag: c.universe.WeakTypeTag[play.api.libs.json.Format[A]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.formatImpl.block;$typecreator53.apply.$m" class="delimiter">[</a><a href="Format.scala.html#play.api.libs.json;Format" title="play.api.libs.json.Format[A]">Format</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span><span class="delimiter">)</span>, <span title="(xs: c.universe.TypeTree*)List[c.universe.TypeTree]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.evidence$3" title="(implicit attag: c.universe.WeakTypeTag[A])c.universe.Type" class="delimiter">[</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl;A" title="A">A</a><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                                  <a href="#play.api.libs.json.JsMacroImpl.formatImpl.finalTree" title="c.universe.Apply">finalTree</a>
                                <span class="delimiter">)</span>
                              <span class="delimiter">)</span>
                            <span class="delimiter">)</span>
                          <span class="delimiter">)</span>,
                          <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(tpt: c.universe.Tree)c.universe.New">New</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;$anon&quot;)" class="string">&quot;$anon&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">CONSTRUCTOR</span><span class="delimiter">)</span>, List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
                        <span class="delimiter">)</span>,
                        <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyStuff&quot;)" class="string">&quot;lazyStuff&quot;</span><span class="delimiter">)</span>
                      <span class="delimiter">)</span>

                      <span class="comment">//println(&quot;block:&quot;+block)</span>

                      <span class="comment">/*val reif = reify(
                        new play.api.libs.json.util.LazyHelper[Format, A] {
                          override lazy val lazyStuff: Format[A] = null
                        }
                      )
                      //println(&quot;RAW:&quot;+showRaw(reif.tree, printKinds = true))*/</span>
                      <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[play.api.libs.json.Format[A]])c.Expr[play.api.libs.json.Format[A]]" class="delimiter">[</span><a href="Format.scala.html#play.api.libs.json;Format" title="play.api.libs.json.Format[A]">Format</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="c.universe.type" id="play.api.libs.json.JsMacroImpl.formatImpl;$typecreator54.apply.$m" class="delimiter">(</a><span title="c.universe.Select">block</span><span class="delimiter">)</span>
                    <span class="delimiter">}</span>
                  <span class="keyword">case</span> <a title="List[c.universe.Type]" id="play.api.libs.json.JsMacroImpl.formatImpl.l">l</a> =&gt; <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;No implicit format for &quot;)">No implicit format for $</span><span class="delimiter">{</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.l" title="List[c.universe.Type]">l</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot; available.&quot;)" class="string"> available.&quot;</span><span class="delimiter">)</span>
                <span class="delimiter">}</span>

              <span class="keyword">case</span> <span title="None.type">None</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;No apply function found matching unapply parameters&quot;)" class="string">&quot;No apply function found matching unapply parameters&quot;</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>

        <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
