<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>play-java/play/libs/ReflectionsCache.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (C) 2009-2015 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
<span class="keyword">package</span> play.libs

<span class="keyword">import</span> org.reflections.util.FilterBuilder

<span class="comment">/**
 * Provides a cache for reflections, so that classloader scanning over the same classloader for the same package
 * multiple times doesn't need to be done.
 *
 * This is most useful in tests, when each test starts a new FakeApplication, and so things like Ebean scan the
 * classloader for @Entity annotated classes in a given package.  Profiling shows that without this cache, over 90%
 * of a tests time might be spent in classpath scanning.
 */</span>
<span class="keyword">object</span> <a title="play.libs.ReflectionsCache.type" id="play.libs.ReflectionsCache">ReflectionsCache</a> <a href="#play.libs.ReflectionsCache" title="play.libs.ReflectionsCache.type" class="delimiter">{</a>
  <span class="keyword">import</span> ref.SoftReference
  <span class="keyword">import</span> org.reflections.<span class="delimiter">{</span> scanners, util, Reflections <span class="delimiter">}</span>
  <span class="keyword">import</span> scala.collection.concurrent._

  <span class="comment">// A soft reference is used so that we don't force the classloader or reflections to be live after a test run,</span>
  <span class="comment">// but we don't use weak reference as this is the only reference to the tuple, and it will just always get collected</span>
  <span class="comment">// on each eden space collection if it was weak.</span>
  @volatile <span class="keyword">private</span> <span class="keyword">var</span> <a title="Option[scala.ref.SoftReference[(ClassLoader, scala.collection.concurrent.Map[String,org.reflections.Reflections])]]" id="play.libs.ReflectionsCache.reflectionsMapRef_=">reflectionsMapRef</a>: <span title="Option[scala.ref.SoftReference[(ClassLoader, scala.collection.concurrent.Map[String,org.reflections.Reflections])]]">Option</span><span class="delimiter">[</span>SoftReference<span class="delimiter">[</span><span class="delimiter">(</span>ClassLoader, Map<span class="delimiter">[</span>String, Reflections<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="None.type">None</span>

  <span class="keyword">def</span> <a title="(classLoader: ClassLoader, pkg: String)org.reflections.Reflections" id="play.libs.ReflectionsCache.getReflections">getReflections</a><span class="delimiter">(</span><a title="ClassLoader" id="play.libs.ReflectionsCache.getReflections.classLoader">classLoader</a>: <span title="ClassLoader">ClassLoader</span>, <a title="String" id="play.libs.ReflectionsCache.getReflections.pkg">pkg</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="comment">// Detect if the classloader is different from last time, if it is, create a new cache and replace the old</span>
    <span class="keyword">val</span> <a title="scala.collection.concurrent.Map[String,org.reflections.Reflections]" id="play.libs.ReflectionsCache.getReflections.reflectionsMap">reflectionsMap</a> = <a href="#play.libs.ReflectionsCache.reflectionsMapRef_=" title="=&gt; Option[scala.ref.SoftReference[(ClassLoader, scala.collection.concurrent.Map[String,org.reflections.Reflections])]]">reflectionsMapRef</a>.<span title="(f: scala.ref.SoftReference[(ClassLoader, scala.collection.concurrent.Map[String,org.reflections.Reflections])] =&gt; Option[(ClassLoader, scala.collection.concurrent.Map[String,org.reflections.Reflections])])Option[(ClassLoader, scala.collection.concurrent.Map[String,org.reflections.Reflections])]">flatMap</span><span class="delimiter">(</span><a href="#play.libs.ReflectionsCache.getReflections.reflectionsMap.$anonfun.x$1" title="scala.ref.SoftReference[(ClassLoader, scala.collection.concurrent.Map[String,org.reflections.Reflections])]">_</a>.<span title="=&gt; Option[(ClassLoader, scala.collection.concurrent.Map[String,org.reflections.Reflections])]">get</span><span class="delimiter">)</span>.<span title="(p: ((ClassLoader, scala.collection.concurrent.Map[String,org.reflections.Reflections])) =&gt; Boolean)Option[(ClassLoader, scala.collection.concurrent.Map[String,org.reflections.Reflections])]">filter</span><span class="delimiter">(</span><a href="#play.libs.ReflectionsCache.getReflections.reflectionsMap.$anonfun.x$2" title="(ClassLoader, scala.collection.concurrent.Map[String,org.reflections.Reflections])">_</a>.<span title="=&gt; ClassLoader">_1</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.libs.ReflectionsCache.getReflections.classLoader" title="ClassLoader">classLoader</a><span class="delimiter">)</span>.<span title="(f: ((ClassLoader, scala.collection.concurrent.Map[String,org.reflections.Reflections])) =&gt; scala.collection.concurrent.Map[String,org.reflections.Reflections])Option[scala.collection.concurrent.Map[String,org.reflections.Reflections]]">map</span><span class="delimiter">(</span><a href="#play.libs.ReflectionsCache.getReflections.reflectionsMap.$anonfun.x$3" title="(ClassLoader, scala.collection.concurrent.Map[String,org.reflections.Reflections])">_</a>.<span title="=&gt; scala.collection.concurrent.Map[String,org.reflections.Reflections]">_2</span><span class="delimiter">)</span>.<span title="(default: =&gt; scala.collection.concurrent.Map[String,org.reflections.Reflections])scala.collection.concurrent.Map[String,org.reflections.Reflections]">getOrElse</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="scala.collection.concurrent.TrieMap[String,org.reflections.Reflections]" id="play.libs.ReflectionsCache.getReflections.reflectionsMap.map">map</a> = <span title="scala.collection.concurrent.TrieMap.type">TrieMap</span>.<span title="[K, V]=&gt; scala.collection.concurrent.TrieMap[K,V]">empty</span><span title="scala.collection.concurrent.TrieMap[String,org.reflections.Reflections]" class="delimiter">[</span><span title="String">String</span>, <span title="org.reflections.Reflections">Reflections</span><span class="delimiter">]</span>
      <a href="#play.libs.ReflectionsCache.reflectionsMapRef_=" title="(x$1: Option[scala.ref.SoftReference[(ClassLoader, scala.collection.concurrent.Map[String,org.reflections.Reflections])]])Unit">reflectionsMapRef</a> = <span title="(x: scala.ref.SoftReference[(ClassLoader, scala.collection.concurrent.TrieMap[String,org.reflections.Reflections])])Some[scala.ref.SoftReference[(ClassLoader, scala.collection.concurrent.TrieMap[String,org.reflections.Reflections])]]">Some</span><span class="delimiter">(</span><span title="scala.ref.SoftReference[(ClassLoader, scala.collection.concurrent.TrieMap[String,org.reflections.Reflections])]" class="keyword">new</span> <span title="scala.ref.SoftReference[(ClassLoader, scala.collection.concurrent.TrieMap[String,org.reflections.Reflections])]">SoftReference</span><span class="delimiter">(</span><span title="(_1: ClassLoader, _2: scala.collection.concurrent.TrieMap[String,org.reflections.Reflections])(ClassLoader, scala.collection.concurrent.TrieMap[String,org.reflections.Reflections])" class="delimiter">(</span><a href="#play.libs.ReflectionsCache.getReflections.classLoader" title="ClassLoader">classLoader</a>, <a href="#play.libs.ReflectionsCache.getReflections.reflectionsMap.map" title="scala.collection.concurrent.TrieMap[String,org.reflections.Reflections]">map</a><span class="delimiter">)</span>, <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#play.libs.ReflectionsCache.getReflections.reflectionsMap.map" title="scala.collection.concurrent.TrieMap[String,org.reflections.Reflections]">map</a>
    <span class="delimiter">}</span>
    <a href="#play.libs.ReflectionsCache.getReflections.reflectionsMap" title="scala.collection.concurrent.Map[String,org.reflections.Reflections]">reflectionsMap</a>.<span title="(key: String)Option[org.reflections.Reflections]">get</span><span class="delimiter">(</span><a href="#play.libs.ReflectionsCache.getReflections.pkg" title="String">pkg</a><span class="delimiter">)</span>.<span title="(default: =&gt; org.reflections.Reflections)org.reflections.Reflections">getOrElse</span> <span class="delimiter">{</span>

      <span class="keyword">val</span> <a title="org.reflections.Reflections" id="play.libs.ReflectionsCache.getReflections.reflections">reflections</a> = <span title="org.reflections.Reflections" class="keyword">new</span> <span title="org.reflections.Reflections">Reflections</span><span class="delimiter">(</span><span title="org.reflections.util.ConfigurationBuilder" class="keyword">new</span> util.<span title="org.reflections.util.ConfigurationBuilder">ConfigurationBuilder</span><span class="delimiter">(</span><span class="delimiter">)</span>
        .<span title="(x$1: java.util.Collection[java.net.URL])org.reflections.util.ConfigurationBuilder">addUrls</span><span class="delimiter">(</span>util.<span title="org.reflections.util.ClasspathHelper.type">ClasspathHelper</span>.<span title="(x$1: String, x$2: &lt;repeated...&gt;[ClassLoader])java.util.Collection[java.net.URL]">forPackage</span><span class="delimiter">(</span><a href="#play.libs.ReflectionsCache.getReflections.pkg" title="String">pkg</a>, <a href="#play.libs.ReflectionsCache.getReflections.classLoader" title="ClassLoader">classLoader</a><span class="delimiter">)</span><span class="delimiter">)</span>
        .<span title="(x$1: com.google.common.base.Predicate[String])org.reflections.util.ConfigurationBuilder">filterInputsBy</span><span class="delimiter">(</span><span title="org.reflections.util.FilterBuilder" class="keyword">new</span> <span title="org.reflections.util.FilterBuilder">FilterBuilder</span><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="(x$1: String)org.reflections.util.FilterBuilder">include</span><span class="delimiter">(</span><span title="org.reflections.util.FilterBuilder.type">FilterBuilder</span>.<span title="(x$1: String)String">prefix</span><span class="delimiter">(</span><a href="#play.libs.ReflectionsCache.getReflections.pkg" title="String">pkg</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        .<span title="(x$1: &lt;repeated...&gt;[org.reflections.scanners.Scanner])org.reflections.util.ConfigurationBuilder">setScanners</span><span class="delimiter">(</span><span title="org.reflections.scanners.TypeAnnotationsScanner" class="keyword">new</span> scanners.<span title="org.reflections.scanners.TypeAnnotationsScanner">TypeAnnotationsScanner</span>, <span title="org.reflections.scanners.TypeElementsScanner" class="keyword">new</span> scanners.<span title="org.reflections.scanners.TypeElementsScanner">TypeElementsScanner</span><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#play.libs.ReflectionsCache.getReflections.reflectionsMap" title="scala.collection.concurrent.Map[String,org.reflections.Reflections]">reflectionsMap</a>.<span title="(k: String, v: org.reflections.Reflections)Option[org.reflections.Reflections]">putIfAbsent</span><span class="delimiter">(</span><a href="#play.libs.ReflectionsCache.getReflections.pkg" title="String">pkg</a>, <a href="#play.libs.ReflectionsCache.getReflections.reflections" title="org.reflections.Reflections">reflections</a><span class="delimiter">)</span>.<span title="(default: =&gt; org.reflections.Reflections)org.reflections.Reflections">getOrElse</span><span class="delimiter">(</span><a href="#play.libs.ReflectionsCache.getReflections.reflections" title="org.reflections.Reflections">reflections</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
