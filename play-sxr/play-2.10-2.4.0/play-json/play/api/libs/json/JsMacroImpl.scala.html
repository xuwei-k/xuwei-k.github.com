<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>play-json/play/api/libs/json/JsMacroImpl.scala</title>
        <script type="text/javascript" src="../../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (C) 2009-2015 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
<span class="keyword">package</span> play.api.libs.json

<span class="keyword">import</span> scala.<span title="language.type">language</span>.higherKinds
<span class="keyword">import</span> scala.reflect.macros.Context
<span class="keyword">import</span> <span title="language.type">language</span>.<span title="language.experimental.type">experimental</span>.macros

<span class="keyword">object</span> <a title="play.api.libs.json.JsMacroImpl.type" id="play.api.libs.json.JsMacroImpl">JsMacroImpl</a> <a href="#play.api.libs.json.JsMacroImpl" title="play.api.libs.json.JsMacroImpl.type" class="delimiter">{</a>

  <span class="keyword">def</span> <a title="[A](c: scala.reflect.macros.Context)(implicit evidence$1: c.WeakTypeTag[A])c.Expr[play.api.libs.json.Format[A]]" id="play.api.libs.json.JsMacroImpl.formatImpl">formatImpl</a><span class="delimiter">[</span><a title="" id="play.api.libs.json.JsMacroImpl.formatImpl;A">A</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="play.api.libs.json.JsMacroImpl.formatImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span>: c.<span title="c.Expr[play.api.libs.json.Format[A]]">Expr</span><span class="delimiter">[</span>Format<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#play.api.libs.json.JsMacroImpl.macroImpl" title="[A, M[_]](c: scala.reflect.macros.Context, methodName: String, mapLikeMethod: String, reads: Boolean, writes: Boolean)(implicit atag: c.WeakTypeTag[A], implicit matag: c.WeakTypeTag[M[A]])c.Expr[M[A]]">macroImpl</a><span title="(c: scala.reflect.macros.Context, methodName: String, mapLikeMethod: String, reads: Boolean, writes: Boolean)(implicit atag: c.WeakTypeTag[A], implicit matag: c.WeakTypeTag[play.api.libs.json.Format[A]])c.Expr[play.api.libs.json.Format[A]]" class="delimiter">[</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl;A" title="A">A</a>, <a href="Format.scala.html#play.api.libs.json;Format" title="play.api.libs.json.Format">Format</a><span class="delimiter">]</span><a href="#play.api.libs.json.JsMacroImpl.formatImpl.evidence$1" title="c.WeakTypeTag[A]" id="play.api.libs.json.JsMacroImpl.formatImpl;$typecreator1.apply.$m" class="delimiter">(</a><a href="#play.api.libs.json.JsMacroImpl.formatImpl.c" title="scala.reflect.macros.Context">c</a>, <span title="String(&quot;format&quot;)" class="string">&quot;format&quot;</span>, <span title="String(&quot;inmap&quot;)" class="string">&quot;inmap&quot;</span>, reads = <span title="Boolean(true)" class="keyword">true</span>, writes = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[A](c: scala.reflect.macros.Context)(implicit evidence$2: c.WeakTypeTag[A])c.Expr[play.api.libs.json.Reads[A]]" id="play.api.libs.json.JsMacroImpl.readsImpl">readsImpl</a><span class="delimiter">[</span><a title="" id="play.api.libs.json.JsMacroImpl.readsImpl;A">A</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="play.api.libs.json.JsMacroImpl.readsImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span>: c.<span title="c.Expr[play.api.libs.json.Reads[A]]">Expr</span><span class="delimiter">[</span>Reads<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#play.api.libs.json.JsMacroImpl.macroImpl" title="[A, M[_]](c: scala.reflect.macros.Context, methodName: String, mapLikeMethod: String, reads: Boolean, writes: Boolean)(implicit atag: c.WeakTypeTag[A], implicit matag: c.WeakTypeTag[M[A]])c.Expr[M[A]]">macroImpl</a><span title="(c: scala.reflect.macros.Context, methodName: String, mapLikeMethod: String, reads: Boolean, writes: Boolean)(implicit atag: c.WeakTypeTag[A], implicit matag: c.WeakTypeTag[play.api.libs.json.Reads[A]])c.Expr[play.api.libs.json.Reads[A]]" class="delimiter">[</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl;A" title="A">A</a>, <a href="Reads.scala.html#play.api.libs.json;Reads" title="play.api.libs.json.Reads">Reads</a><span class="delimiter">]</span><a href="#play.api.libs.json.JsMacroImpl.readsImpl.evidence$2" title="c.WeakTypeTag[A]" id="play.api.libs.json.JsMacroImpl.readsImpl;$typecreator2.apply.$m" class="delimiter">(</a><a href="#play.api.libs.json.JsMacroImpl.readsImpl.c" title="scala.reflect.macros.Context">c</a>, <span title="String(&quot;read&quot;)" class="string">&quot;read&quot;</span>, <span title="String(&quot;map&quot;)" class="string">&quot;map&quot;</span>, reads = <span title="Boolean(true)" class="keyword">true</span>, writes = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[A](c: scala.reflect.macros.Context)(implicit evidence$3: c.WeakTypeTag[A])c.Expr[play.api.libs.json.Writes[A]]" id="play.api.libs.json.JsMacroImpl.writesImpl">writesImpl</a><span class="delimiter">[</span><a title="" id="play.api.libs.json.JsMacroImpl.writesImpl;A">A</a>: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="play.api.libs.json.JsMacroImpl.writesImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span>: c.<span title="c.Expr[play.api.libs.json.Writes[A]]">Expr</span><span class="delimiter">[</span>Writes<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> =
    <a href="#play.api.libs.json.JsMacroImpl.macroImpl" title="[A, M[_]](c: scala.reflect.macros.Context, methodName: String, mapLikeMethod: String, reads: Boolean, writes: Boolean)(implicit atag: c.WeakTypeTag[A], implicit matag: c.WeakTypeTag[M[A]])c.Expr[M[A]]">macroImpl</a><span title="(c: scala.reflect.macros.Context, methodName: String, mapLikeMethod: String, reads: Boolean, writes: Boolean)(implicit atag: c.WeakTypeTag[A], implicit matag: c.WeakTypeTag[play.api.libs.json.Writes[A]])c.Expr[play.api.libs.json.Writes[A]]" class="delimiter">[</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl;A" title="A">A</a>, <a href="Writes.scala.html#play.api.libs.json;Writes" title="play.api.libs.json.Writes">Writes</a><span class="delimiter">]</span><a href="#play.api.libs.json.JsMacroImpl.writesImpl.evidence$3" title="c.WeakTypeTag[A]" id="play.api.libs.json.JsMacroImpl.writesImpl;$typecreator3.apply.$m" class="delimiter">(</a><a href="#play.api.libs.json.JsMacroImpl.writesImpl.c" title="scala.reflect.macros.Context">c</a>, <span title="String(&quot;write&quot;)" class="string">&quot;write&quot;</span>, <span title="String(&quot;contramap&quot;)" class="string">&quot;contramap&quot;</span>, reads = <span title="Boolean(false)" class="keyword">false</span>, writes = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="[A, M[_]](c: scala.reflect.macros.Context, methodName: String, mapLikeMethod: String, reads: Boolean, writes: Boolean)(implicit atag: c.WeakTypeTag[A], implicit matag: c.WeakTypeTag[M[A]])c.Expr[M[A]]" id="play.api.libs.json.JsMacroImpl.macroImpl">macroImpl</a><span class="delimiter">[</span><a title="" id="play.api.libs.json.JsMacroImpl.macroImpl;A">A</a>, <a title="[_]" id="play.api.libs.json.JsMacroImpl.macroImpl;M">M</a><span class="delimiter">[</span><a title="" id="play.api.libs.json.JsMacroImpl.macroImpl;M;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="play.api.libs.json.JsMacroImpl.macroImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span>, <a title="String" id="play.api.libs.json.JsMacroImpl.macroImpl.methodName">methodName</a>: <span title="String">String</span>, <a title="String" id="play.api.libs.json.JsMacroImpl.macroImpl.mapLikeMethod">mapLikeMethod</a>: <span title="String">String</span>, <a title="Boolean" id="play.api.libs.json.JsMacroImpl.macroImpl.reads">reads</a>: <span title="Boolean">Boolean</span>, <a title="Boolean" id="play.api.libs.json.JsMacroImpl.macroImpl.writes">writes</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="c.WeakTypeTag[A]" id="play.api.libs.json.JsMacroImpl.macroImpl.atag">atag</a>: c.<span title="c.WeakTypeTag[A]">WeakTypeTag</span><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="c.WeakTypeTag[M[A]]" id="play.api.libs.json.JsMacroImpl.macroImpl.matag">matag</a>: c.<span title="c.WeakTypeTag[M[A]]">WeakTypeTag</span><span class="delimiter">[</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[M[A]]">Expr</span><span class="delimiter">[</span>M<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>

    <span class="keyword">val</span> <a title="String" id="play.api.libs.json.JsMacroImpl.macroImpl.nullableMethodName">nullableMethodName</a> = <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;&quot;)">$</span><span class="delimiter">{</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.methodName" title="String">methodName</a><span class="delimiter">}</span><span title="String(&quot;Nullable&quot;)" class="string">Nullable&quot;</span>
    <span class="keyword">val</span> <a title="String" id="play.api.libs.json.JsMacroImpl.macroImpl.lazyMethodName">lazyMethodName</a> = <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;lazy&quot;)">lazy$</span><span class="delimiter">{</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.methodName" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">methodName</a>.<span title="=&gt; String">capitalize</span><span class="delimiter">}</span><span title="String(&quot;&quot;)" class="string">&quot;</span>

    <span class="keyword">def</span> <a title="[T](ifReads: T, ifWrites: T)List[T]" id="play.api.libs.json.JsMacroImpl.macroImpl.conditionalList">conditionalList</a><span class="delimiter">[</span><a title="" id="play.api.libs.json.JsMacroImpl.macroImpl.conditionalList;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="play.api.libs.json.JsMacroImpl.macroImpl.conditionalList.ifReads">ifReads</a>: <a href="#play.api.libs.json.JsMacroImpl.macroImpl.conditionalList;T" title="T">T</a>, <a title="T" id="play.api.libs.json.JsMacroImpl.macroImpl.conditionalList.ifWrites">ifWrites</a>: <a href="#play.api.libs.json.JsMacroImpl.macroImpl.conditionalList;T" title="T">T</a><span class="delimiter">)</span>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span> =
      <span class="delimiter">(</span><span title="List[T]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.reads" title="Boolean">reads</a><span class="delimiter">)</span> <span title="(xs: T*)List[T]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.conditionalList.ifReads" title="T">ifReads</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.conditionalList.x$1" title="(prefix: List[T])List[T]">:::</a>
        <span class="delimiter">(</span><span title="List[T]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.writes" title="Boolean">writes</a><span class="delimiter">)</span> <span title="(xs: T*)List[T]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.conditionalList.ifWrites" title="T">ifWrites</a><span class="delimiter">)</span> <span class="keyword">else</span> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>

    <span class="keyword">import</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
    <span class="keyword">import</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="=&gt; c.universe.FlagValues">Flag</span>._

    <span class="keyword">val</span> <a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.macroImpl.companioned">companioned</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.atag" title="(implicit attag: c.universe.WeakTypeTag[A])c.universe.Type" class="delimiter">[</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl;A" title="A">A</a><span class="delimiter">]</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span>
    <span class="keyword">val</span> <a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.macroImpl.companionSymbol">companionSymbol</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.companioned" title="c.universe.Symbol">companioned</a>.<span title="=&gt; c.universe.Symbol">companionSymbol</span>
    <span class="keyword">val</span> <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.companionType">companionType</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a>.<span title="=&gt; c.universe.Type">typeSignature</span>

    <span class="keyword">def</span> <a title="(qual: c.universe.Tree, names: String*)c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.selectTerm">selectTerm</a><span class="delimiter">(</span><a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.selectTerm.qual">qual</a>: <span title="c.universe.Tree">Tree</span>, <a title="String*" id="play.api.libs.json.JsMacroImpl.macroImpl.selectTerm.names">names</a>: <span title="String*">String</span>*<span class="delimiter">)</span> =
      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.selectTerm.names" title="String*">names</a>.<span title="(z: c.universe.Tree)(op: (c.universe.Tree, String) =&gt; c.universe.Tree)c.universe.Tree">foldLeft</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.selectTerm.qual" title="c.universe.Tree">qual</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.selectTerm.$anonfun.z">z</a>, <a title="String" id="play.api.libs.json.JsMacroImpl.macroImpl.selectTerm.$anonfun.b">b</a><span class="delimiter">)</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.selectTerm.$anonfun.z" title="c.universe.Tree">z</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.selectTerm.$anonfun.b" title="String">b</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(names: String*)c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.selectFromRoot">selectFromRoot</a><span class="delimiter">(</span><a title="String*" id="play.api.libs.json.JsMacroImpl.macroImpl.selectFromRoot.names">names</a>: <span title="String*">String</span>*<span class="delimiter">)</span> =
      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.selectTerm" title="(qual: c.universe.Tree, names: String*)c.universe.Tree">selectTerm</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.Mirror">rootMirror</a>.<span title="=&gt; c.universe.ModuleSymbol">RootPackage</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.selectFromRoot.names" title="String*">names</a>: _*<span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.libsPkg">libsPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.selectFromRoot" title="(names: String*)c.universe.Tree">selectFromRoot</a><span class="delimiter">(</span><span title="String(&quot;play&quot;)" class="string">&quot;play&quot;</span>, <span title="String(&quot;api&quot;)" class="string">&quot;api&quot;</span>, <span title="String(&quot;libs&quot;)" class="string">&quot;libs&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.jsonPkg">jsonPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.selectTerm" title="(qual: c.universe.Tree, names: String*)c.universe.Tree">selectTerm</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.libsPkg" title="c.universe.Tree">libsPkg</a>, <span title="String(&quot;json&quot;)" class="string">&quot;json&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.functionalSyntaxPkg">functionalSyntaxPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.selectTerm" title="(qual: c.universe.Tree, names: String*)c.universe.Tree">selectTerm</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.libsPkg" title="c.universe.Tree">libsPkg</a>, <span title="String(&quot;functional&quot;)" class="string">&quot;functional&quot;</span>, <span title="String(&quot;syntax&quot;)" class="string">&quot;syntax&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.utilPkg">utilPkg</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.selectTerm" title="(qual: c.universe.Tree, names: String*)c.universe.Tree">selectTerm</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.jsonPkg" title="c.universe.Tree">jsonPkg</a>, <span title="String(&quot;util&quot;)" class="string">&quot;util&quot;</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.jsPathSelect">jsPathSelect</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.selectTerm" title="(qual: c.universe.Tree, names: String*)c.universe.Tree">selectTerm</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.jsonPkg" title="c.universe.Tree">jsonPkg</a>, <span title="String(&quot;JsPath&quot;)" class="string">&quot;JsPath&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.readsSelect">readsSelect</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.selectTerm" title="(qual: c.universe.Tree, names: String*)c.universe.Tree">selectTerm</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.jsonPkg" title="c.universe.Tree">jsonPkg</a>, <span title="String(&quot;Reads&quot;)" class="string">&quot;Reads&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.writesSelect">writesSelect</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.selectTerm" title="(qual: c.universe.Tree, names: String*)c.universe.Tree">selectTerm</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.jsonPkg" title="c.universe.Tree">jsonPkg</a>, <span title="String(&quot;Writes&quot;)" class="string">&quot;Writes&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.unliftIdent">unliftIdent</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.selectTerm" title="(qual: c.universe.Tree, names: String*)c.universe.Tree">selectTerm</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.functionalSyntaxPkg" title="c.universe.Tree">functionalSyntaxPkg</a>, <span title="String(&quot;unlift&quot;)" class="string">&quot;unlift&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.macroImpl.lazyHelperSelect">lazyHelperSelect</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.utilPkg" title="c.universe.Tree">utilPkg</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;LazyHelper&quot;)" class="string">&quot;LazyHelper&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.macroImpl.unapply">unapply</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.companionType" title="c.universe.Type">companionType</a>.<span title="(name: c.universe.Name)c.universe.Symbol">declaration</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="implicit scala.reflect.api.Names.stringToTermName : (s: String)c.universe.TermName">stringToTermName</a><span class="delimiter">(</span><span title="String(&quot;unapply&quot;)" class="string">&quot;unapply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.macroImpl.unapplySeq">unapplySeq</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.companionType" title="c.universe.Type">companionType</a>.<span title="(name: c.universe.Name)c.universe.Symbol">declaration</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="implicit scala.reflect.api.Names.stringToTermName : (s: String)c.universe.TermName">stringToTermName</a><span class="delimiter">(</span><span title="String(&quot;unapplySeq&quot;)" class="string">&quot;unapplySeq&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Boolean" id="play.api.libs.json.JsMacroImpl.macroImpl.hasVarArgs">hasVarArgs</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.unapplySeq" title="c.universe.Symbol">unapplySeq</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.Symbol">NoSymbol</a>

    <span class="keyword">val</span> <a title="c.universe.MethodSymbol" id="play.api.libs.json.JsMacroImpl.macroImpl.effectiveUnapply">effectiveUnapply</a> = <span title="(elems: c.universe.Symbol*)Seq[c.universe.Symbol]">Seq</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.unapply" title="c.universe.Symbol">unapply</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.unapplySeq" title="c.universe.Symbol">unapplySeq</a><span class="delimiter">)</span>.<span title="(p: c.universe.Symbol =&gt; Boolean)Seq[c.universe.Symbol]">filter</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.effectiveUnapply.$anonfun.x$2" title="c.universe.Symbol">_</a> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.Symbol">NoSymbol</a><span class="delimiter">)</span>.<span title="=&gt; Option[c.universe.Symbol]">headOption</span> <span title="c.universe.MethodSymbol" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="None.type">None</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;No unapply or unapplySeq function found&quot;)" class="string">&quot;No unapply or unapplySeq function found&quot;</span><span class="delimiter">)</span>
      <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.macroImpl.effectiveUnapply.s">s</a><span class="delimiter">)</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.macroImpl.effectiveUnapply.s" title="c.universe.Symbol">s</a>.<span title="=&gt; c.universe.MethodSymbol">asMethod</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="Option[List[c.universe.Type]]" id="play.api.libs.json.JsMacroImpl.macroImpl.unapplyReturnTypes">unapplyReturnTypes</a>: <span title="Option[List[c.universe.Type]]">Option</span><span class="delimiter">[</span>List<span class="delimiter">[</span>Type<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.effectiveUnapply" title="c.universe.MethodSymbol">effectiveUnapply</a>.<span title="=&gt; c.universe.Type">returnType</span> <span title="Option[List[c.universe.Type]]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
        <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Unapply of &quot;)">Unapply of $</span><span class="delimiter">{</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a><span class="delimiter">}</span><span title="String(&quot; has no parameters. Are you using an empty case class?&quot;)" class="string"> has no parameters. Are you using an empty case class?&quot;</span><span class="delimiter">)</span>
        <span title="None.type">None</span>
      <span class="delimiter">}</span>
      <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="List[c.universe.Type]">args</span><span class="delimiter">)</span> =&gt;
        <span title="List[c.universe.Type]">args</span>.<span title="=&gt; c.universe.Type">head</span> <span title="Option[List[c.universe.Type]]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> <span title="c.universe.TypeRef">t</span> @ <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> =&gt; <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> <span title="c.universe.TypeRef">t</span> @ <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, _, <span title="List[c.universe.Type]">args</span><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
            <span class="keyword">import</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>.<span title="=&gt; c.universe.DefinitionsApi">definitions</span>.TupleClass
            <span title="Option[List[c.universe.Type]]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(xs: Array[c.universe.Symbol])scala.collection.mutable.ArrayOps[c.universe.Symbol]">TupleClass</a>.<span title="=&gt; scala.collection.mutable.IndexedSeq[c.universe.Symbol]">seq</span>.<span title="(p: c.universe.Symbol =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.macroImpl.unapplyReturnTypes.$anonfun.tupleSym">tupleSym</a> =&gt; <span title="c.universe.TypeRef">t</span>.<span title="(clazz: c.universe.Symbol)c.universe.Type">baseType</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.unapplyReturnTypes.$anonfun.tupleSym" title="c.universe.Symbol">tupleSym</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.Type">NoType</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: List[c.universe.TypeRef])Some[List[c.universe.TypeRef]]">Some</span><span class="delimiter">(</span><span title="(xs: c.universe.TypeRef*)List[c.universe.TypeRef]">List</span><span class="delimiter">(</span><span title="c.universe.TypeRef">t</span><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="Option[List[c.universe.Type]]" class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.TypeRef">t</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(implicit ttag: c.universe.TypeTag[Product])c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.unapplyReturnTypes;$typecreator4.apply.$m" class="delimiter">[</a><span title="Product">Product</span><span class="delimiter">]</span><span class="delimiter">)</span> <span title="(x: List[c.universe.Type])Some[List[c.universe.Type]]">Some</span><span class="delimiter">(</span><span title="List[c.universe.Type]">args</span><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="None.type">None</span>
          <span class="delimiter">}</span>
          <span class="keyword">case</span> _ =&gt; <span title="None.type">None</span>
        <span class="delimiter">}</span>
      <span class="keyword">case</span> _ =&gt; <span title="None.type">None</span>
    <span class="delimiter">}</span>

    <span class="comment">//println(&quot;Unapply return type:&quot; + unapplyReturnTypes)</span>

    <span class="keyword">val</span> <a title="List[c.universe.Symbol]" id="play.api.libs.json.JsMacroImpl.macroImpl.applies">applies</a> =
      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.companionType" title="c.universe.Type">companionType</a>.<span title="(name: c.universe.Name)c.universe.Symbol">declaration</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="implicit scala.reflect.api.Names.stringToTermName : (s: String)c.universe.TermName">stringToTermName</a><span class="delimiter">(</span><span title="String(&quot;apply&quot;)" class="string">&quot;apply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="List[c.universe.Symbol]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.Symbol">NoSymbol</a> =&gt; <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;No apply function found&quot;)" class="string">&quot;No apply function found&quot;</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.macroImpl.applies.s">s</a> =&gt; <a href="#play.api.libs.json.JsMacroImpl.macroImpl.applies.s" title="c.universe.Symbol">s</a>.<span title="=&gt; c.universe.MethodSymbol">asMethod</span>.<span title="=&gt; List[c.universe.Symbol]">alternatives</span>
      <span class="delimiter">}</span>

    <span class="comment">// searches apply method corresponding to unapply</span>
    <span class="keyword">val</span> <a title="Option[c.universe.MethodSymbol]" id="play.api.libs.json.JsMacroImpl.macroImpl.apply">apply</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.applies" title="List[c.universe.Symbol]">applies</a>.<span title="(pf: PartialFunction[c.universe.Symbol,c.universe.MethodSymbol])Option[c.universe.MethodSymbol]">collectFirst</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[c.universe.Symbol,c.universe.MethodSymbol] with Serializable" id="play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><span title="c.universe.MethodSymbol">apply</span>: <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(x: Any)Option[c.universe.MethodSymbol]">MethodSymbol</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.hasVarArgs" title="Boolean">hasVarArgs</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Option[List[c.universe.Type]]" id="play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.someApplyTypes">someApplyTypes</a> = <span title="c.universe.MethodSymbol">apply</span>.<span title="=&gt; List[List[c.universe.Symbol]]">paramss</span>.<span title="=&gt; Option[List[c.universe.Symbol]]">headOption</span>.<span title="(f: List[c.universe.Symbol] =&gt; List[c.universe.Type])Option[List[c.universe.Type]]">map</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.applyOrElse.someApplyTypes.$anonfun.x$3" title="List[c.universe.Symbol]">_</a>.<span title="(f: c.universe.Symbol =&gt; c.universe.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Symbol],c.universe.Type,List[c.universe.Type]])List[c.universe.Type]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,c.universe.Type,List[c.universe.Type]]" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.applyOrElse.someApplyTypes.$anonfun.$anonfun.x$4" title="c.universe.Symbol">_</a>.<span title="=&gt; c.universe.TermSymbol">asTerm</span>.<span title="=&gt; c.universe.Type">typeSignature</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Option[List[c.universe.Type]]" id="play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.someInitApply">someInitApply</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.someApplyTypes" title="Option[List[c.universe.Type]]">someApplyTypes</a>.<span title="(f: List[c.universe.Type] =&gt; List[c.universe.Type])Option[List[c.universe.Type]]">map</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.applyOrElse.someInitApply.$anonfun.x$5" title="List[c.universe.Type]">_</a>.<span title="=&gt; List[c.universe.Type]">init</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Option[c.universe.Type]" id="play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.someApplyLast">someApplyLast</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.someApplyTypes" title="Option[List[c.universe.Type]]">someApplyTypes</a>.<span title="(f: List[c.universe.Type] =&gt; c.universe.Type)Option[c.universe.Type]">map</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.applyOrElse.someApplyLast.$anonfun.x$6" title="List[c.universe.Type]">_</a>.<span title="=&gt; c.universe.Type">last</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Option[List[c.universe.Type]]" id="play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.someInitUnapply">someInitUnapply</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.unapplyReturnTypes" title="Option[List[c.universe.Type]]">unapplyReturnTypes</a>.<span title="(f: List[c.universe.Type] =&gt; List[c.universe.Type])Option[List[c.universe.Type]]">map</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.applyOrElse.someInitUnapply.$anonfun.x$7" title="List[c.universe.Type]">_</a>.<span title="=&gt; List[c.universe.Type]">init</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Option[c.universe.Type]" id="play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.someUnapplyLast">someUnapplyLast</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.unapplyReturnTypes" title="Option[List[c.universe.Type]]">unapplyReturnTypes</a>.<span title="(f: List[c.universe.Type] =&gt; c.universe.Type)Option[c.universe.Type]">map</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.applyOrElse.someUnapplyLast.$anonfun.x$8" title="List[c.universe.Type]">_</a>.<span title="=&gt; c.universe.Type">last</span><span class="delimiter">)</span>
        <span class="keyword">val</span> <a title="Boolean" id="play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.initsMatch">initsMatch</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.someInitApply" title="Option[List[c.universe.Type]]">someInitApply</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.someInitUnapply" title="Option[List[c.universe.Type]]">someInitUnapply</a>
        <span class="keyword">val</span> <a title="Boolean" id="play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.lastMatch">lastMatch</a> = <span class="delimiter">(</span><span class="keyword">for</span> <span class="delimiter">{</span>
          <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.lastMatch.$anonfun.lastApply">lastApply</a> &lt;- <a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.someApplyLast" title="(f: c.universe.Type =&gt; Option[Boolean])Option[Boolean]">someApplyLast</a>
          <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.lastMatch.$anonfun.$anonfun.lastUnapply">lastUnapply</a> &lt;- <a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.someUnapplyLast" title="(f: c.universe.Type =&gt; Boolean)Option[Boolean]">someUnapplyLast</a>
        <span class="delimiter">}</span> <span class="keyword">yield</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.lastMatch.$anonfun.lastApply" title="c.universe.Type">lastApply</a> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.lastMatch.$anonfun.$anonfun.lastUnapply" title="c.universe.Type">lastUnapply</a><span class="delimiter">)</span>.<span title="(default: =&gt; Boolean)Boolean">getOrElse</span><span class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>
        <a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.initsMatch" title="Boolean">initsMatch</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.isDefinedAt.lastMatch" title="Boolean">lastMatch</a>
      <span class="delimiter">}</span> =&gt; <span title="c.universe.MethodSymbol">apply</span>
      <span class="keyword">case</span> <span class="delimiter">(</span><span title="c.universe.MethodSymbol">apply</span>: <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(x: Any)Option[c.universe.MethodSymbol]">MethodSymbol</a><span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><span title="c.universe.MethodSymbol">apply</span>.<span title="=&gt; List[List[c.universe.Symbol]]">paramss</span>.<span title="=&gt; Option[List[c.universe.Symbol]]">headOption</span>.<span title="(f: List[c.universe.Symbol] =&gt; List[c.universe.Type])Option[List[c.universe.Type]]">map</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.applyOrElse.$anonfun.x$9" title="List[c.universe.Symbol]">_</a>.<span title="(f: c.universe.Symbol =&gt; c.universe.Type)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Symbol],c.universe.Type,List[c.universe.Type]])List[c.universe.Type]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,c.universe.Type,List[c.universe.Type]]" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply;$anonfun.applyOrElse.$anonfun.$anonfun.x$10" title="c.universe.Symbol">_</a>.<span title="=&gt; c.universe.TermSymbol">asTerm</span>.<span title="=&gt; c.universe.Type">typeSignature</span><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.unapplyReturnTypes" title="Option[List[c.universe.Type]]">unapplyReturnTypes</a><span class="delimiter">)</span> =&gt; <span title="c.universe.MethodSymbol">apply</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="List[c.universe.Symbol]" id="play.api.libs.json.JsMacroImpl.macroImpl.params">params</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.apply" title="Option[c.universe.MethodSymbol]">apply</a> <span title="List[c.universe.Symbol]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="c.universe.MethodSymbol" id="play.api.libs.json.JsMacroImpl.macroImpl.params.apply">apply</a><span class="delimiter">)</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.macroImpl.params.apply" title="c.universe.MethodSymbol">apply</a>.<span title="=&gt; List[List[c.universe.Symbol]]">paramss</span>.<span title="=&gt; List[c.universe.Symbol]">head</span> <span class="comment">//verify there is a single parameter group</span>
      <span class="keyword">case</span> <span title="None.type">None</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;No apply function found matching unapply parameters&quot;)" class="string">&quot;No apply function found matching unapply parameters&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">//println(&quot;apply found:&quot; + apply)</span>

    <span class="keyword">final</span> <span class="keyword">case class</span> <a title="class Implicit extends AnyRef with Product with Serializable" id="play.api.libs.json.JsMacroImpl.macroImpl;Implicit.readResolve">Implicit</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl;Implicit.readResolve" title="Product" class="delimiter">(</a><a title="c.universe.Name" id="play.api.libs.json.JsMacroImpl.macroImpl;Implicit.paramName">paramName</a>: <span title="c.universe.Name">Name</span>, <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl;Implicit.paramType">paramType</a>: <span title="c.universe.Type">Type</span>, <a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl;Implicit.neededImplicit">neededImplicit</a>: <span title="c.universe.Tree">Tree</span>, <a title="Boolean" id="play.api.libs.json.JsMacroImpl.macroImpl;Implicit.isRecursive">isRecursive</a>: <span title="Boolean">Boolean</span>, <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl;Implicit.tpe">tpe</a>: <span title="c.universe.Type">Type</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="(c.universe.Name, c.universe.Type) =&gt; Implicit" id="play.api.libs.json.JsMacroImpl.macroImpl.createImplicit">createImplicit</a> = <span class="delimiter">{</span> <span class="delimiter">(</span>name: <span title="c.universe.Name">Name</span>, implType: c.universe.<span class="keyword">type</span>#<span title="c.universe.Type">Type</span><span class="delimiter">)</span> =&gt;
      <span class="keyword">val</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.isRecursive" title="(Boolean, c.universe.Type)" class="delimiter">(</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.x$12" title="Boolean" id="play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.isRecursive">isRecursive</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.x$12" title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.tpe">tpe</a><span class="delimiter">)</span> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.implType" title="c.universe.Type">implType</a> <span title="(Boolean, c.universe.Type)" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, <span title="c.universe.Symbol">t</span>, <a title="List[c.universe.Type]" id="play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.x$12.args">args</a><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="Boolean" id="play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.x$12.isRec">isRec</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.x$12.args" title="List[c.universe.Type]">args</a>.<span title="(p: c.universe.Type =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.x$12.isRec.$anonfun.x$11" title="c.universe.Type">_</a>.<span title="=&gt; c.universe.Symbol">typeSymbol</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.companioned" title="c.universe.Symbol">companioned</a><span class="delimiter">)</span>
          <span class="comment">// Option[_] needs special treatment because we need to use XXXOpt</span>
          <span class="keyword">val</span> <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.x$12.tp">tp</a> = <span title="c.universe.Type" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.implType" title="c.universe.Type">implType</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.x$12.tp;$typecreator5.apply.symdef$_$11" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.x$12.args" title="List[c.universe.Type]">args</a>.<span title="=&gt; c.universe.Type">head</span> <span class="keyword">else</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.implType" title="c.universe.Type">implType</a>
          <span title="(_1: Boolean, _2: c.universe.Type)(Boolean, c.universe.Type)" class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.x$12.isRec" title="Boolean">isRec</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.x$12.tp" title="c.universe.Type">tp</a><span class="delimiter">)</span>
        <span class="keyword">case</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(tpe: c.universe.TypeRef)Option[(c.universe.Type, c.universe.Symbol, List[c.universe.Type])]">TypeRef</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(x: Any)Option[c.universe.TypeRef]" class="delimiter">(</a>_, <span title="c.universe.Symbol">t</span>, _<span class="delimiter">)</span> =&gt;
          <span title="(_1: Boolean, _2: c.universe.Type)(Boolean, c.universe.Type)" class="delimiter">(</span><span title="Boolean(false)" class="keyword">false</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.implType" title="c.universe.Type">implType</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="comment">// builds M implicit from expected type</span>
      <span class="keyword">val</span> <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.neededImplicitType">neededImplicitType</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(tycon: c.universe.Type, args: List[c.universe.Type])c.universe.Type">appliedType</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.matag" title="c.WeakTypeTag[M[A]]">matag</a>.<span title="=&gt; c.universe.Type">tpe</span>.<span title="=&gt; c.universe.Type">typeConstructor</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.tpe" title="c.universe.Type">tpe</a> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.neededImplicitType.x$13" title="(x: c.universe.Type)List[c.universe.Type]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>
      <span class="comment">// infers implicit</span>
      <span class="keyword">val</span> <a title="c.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.neededImplicit">neededImplicit</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pt: c.Type, silent: Boolean, withMacrosDisabled: Boolean, pos: c.Position)c.Tree">inferImplicitValue</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.neededImplicitType" title="c.universe.Type">neededImplicitType</a><span class="delimiter">)</span>
      <a href="#play.api.libs.json.JsMacroImpl.macroImpl;Implicit.readResolve" title="(paramName: c.universe.Name, paramType: c.universe.Type, neededImplicit: c.universe.Tree, isRecursive: Boolean, tpe: c.universe.Type)Implicit">Implicit</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.name" title="c.universe.Name">name</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.implType" title="c.universe.Type">implType</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.neededImplicit" title="c.Tree">neededImplicit</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.isRecursive" title="Boolean">isRecursive</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit.$anonfun.tpe" title="c.universe.Type">tpe</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="List[Implicit]" id="play.api.libs.json.JsMacroImpl.macroImpl.applyParamImplicits">applyParamImplicits</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(f: c.universe.Symbol =&gt; Implicit)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Symbol],Implicit,List[Implicit]])List[Implicit]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,Implicit,List[Implicit]]" class="delimiter">{</span> <a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.macroImpl.applyParamImplicits.$anonfun.param">param</a> =&gt; <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit" title="(v1: c.universe.Name, v2: c.universe.Type)Implicit">createImplicit</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.applyParamImplicits.$anonfun.param" title="c.universe.Symbol">param</a>.<span title="=&gt; c.universe.Name">name</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.applyParamImplicits.$anonfun.param" title="c.universe.Symbol">param</a>.<span title="=&gt; c.universe.Type">typeSignature</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="List[Implicit]" id="play.api.libs.json.JsMacroImpl.macroImpl.effectiveInferredImplicits">effectiveInferredImplicits</a> = <span title="List[Implicit]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.hasVarArgs" title="Boolean">hasVarArgs</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Implicit" id="play.api.libs.json.JsMacroImpl.macroImpl.effectiveInferredImplicits.varArgsImplicit">varArgsImplicit</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.createImplicit" title="(v1: c.universe.Name, v2: c.universe.Type)Implicit">createImplicit</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.applyParamImplicits" title="List[Implicit]">applyParamImplicits</a>.<span title="=&gt; Implicit">last</span>.<a href="#play.api.libs.json.JsMacroImpl.macroImpl;Implicit.paramName" title="=&gt; c.universe.Name">paramName</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.unapplyReturnTypes" title="Option[List[c.universe.Type]]">unapplyReturnTypes</a>.<span title="=&gt; List[c.universe.Type]">get</span>.<span title="=&gt; c.universe.Type">last</span><span class="delimiter">)</span>
      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.applyParamImplicits" title="List[Implicit]">applyParamImplicits</a>.<span title="=&gt; List[Implicit]">init</span> <span title="(elem: Implicit)(implicit bf: scala.collection.generic.CanBuildFrom[List[Implicit],Implicit,List[Implicit]])List[Implicit]">:+</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.effectiveInferredImplicits.varArgsImplicit" title="Implicit">varArgsImplicit</a>
    <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.applyParamImplicits" title="List[Implicit]">applyParamImplicits</a>

    <span class="comment">// if any implicit is missing, abort</span>
    <span class="keyword">val</span> <a title="List[c.universe.Type]" id="play.api.libs.json.JsMacroImpl.macroImpl.missingImplicits">missingImplicits</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.effectiveInferredImplicits" title="List[Implicit]">effectiveInferredImplicits</a>.<span title="(pf: PartialFunction[Implicit,c.universe.Type])(implicit bf: scala.collection.generic.CanBuildFrom[List[Implicit],c.universe.Type,List[c.universe.Type]])List[c.universe.Type]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[Implicit,c.universe.Type] with Serializable" id="play.api.libs.json.JsMacroImpl.macroImpl.missingImplicits;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> <span class="keyword">case</span> Implicit<span class="delimiter">(</span>_, <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.missingImplicits;$anonfun.isDefinedAt.t">t</a>, <a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.missingImplicits;$anonfun.isDefinedAt.impl">impl</a>, <a title="Boolean" id="play.api.libs.json.JsMacroImpl.macroImpl.missingImplicits;$anonfun.isDefinedAt.rec">rec</a>, _<span class="delimiter">)</span> <span class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.missingImplicits;$anonfun.isDefinedAt.impl" title="c.universe.Tree">impl</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.Tree">EmptyTree</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.missingImplicits;$anonfun.isDefinedAt.rec" title="Boolean">rec</a><span class="delimiter">)</span> =&gt; <a href="#play.api.libs.json.JsMacroImpl.macroImpl.missingImplicits;$anonfun.isDefinedAt.t" title="c.universe.Type">t</a> <span class="delimiter">}</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.missingImplicits" title="List[c.universe.Type]">missingImplicits</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span>
      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;No implicit format for &quot;)">No implicit format for $</span><span class="delimiter">{</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.missingImplicits" title="List[c.universe.Type]">missingImplicits</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot; available.&quot;)" class="string"> available.&quot;</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="c.universe.Select" id="play.api.libs.json.JsMacroImpl.macroImpl.helperMember">helperMember</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qual: c.universe.TypeName)c.universe.This">This</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">EMPTY</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyStuff&quot;)" class="string">&quot;lazyStuff&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(target: c.universe.Tree, methodName: String)c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.callHelper">callHelper</a><span class="delimiter">(</span><a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.callHelper.target">target</a>: <span title="c.universe.Tree">Tree</span>, <a title="String" id="play.api.libs.json.JsMacroImpl.macroImpl.callHelper.methodName">methodName</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="c.universe.Tree">Tree</span> =
      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.callHelper.target" title="c.universe.Tree">target</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.callHelper.methodName" title="String">methodName</a><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="(methodName: String)List[c.universe.Tree]" id="play.api.libs.json.JsMacroImpl.macroImpl.readsWritesHelper">readsWritesHelper</a><span class="delimiter">(</span><a title="String" id="play.api.libs.json.JsMacroImpl.macroImpl.readsWritesHelper.methodName">methodName</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="List[c.universe.Tree]">List</span><span class="delimiter">[</span>Tree<span class="delimiter">]</span> =
      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.conditionalList" title="(ifReads: c.universe.Tree, ifWrites: c.universe.Tree)List[c.universe.Tree]">conditionalList</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.readsSelect" title="c.universe.Tree">readsSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.writesSelect" title="c.universe.Tree">writesSelect</a><span class="delimiter">)</span>.<span title="(f: c.universe.Tree =&gt; c.universe.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Tree],c.universe.Tree,List[c.universe.Tree]])List[c.universe.Tree]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,c.universe.Tree,List[c.universe.Tree]]" class="delimiter">(</span><a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.readsWritesHelper.$anonfun.s">s</a> =&gt; <a href="#play.api.libs.json.JsMacroImpl.macroImpl.callHelper" title="(target: c.universe.Tree, methodName: String)c.universe.Tree">callHelper</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.readsWritesHelper.$anonfun.s" title="c.universe.Tree">s</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.readsWritesHelper.methodName" title="String">methodName</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">var</span> <a title="Boolean" id="play.api.libs.json.JsMacroImpl.macroImpl.hasRec">hasRec</a> = <span title="Boolean(false)" class="keyword">false</span>

    <span class="comment">// combines all reads into CanBuildX</span>
    <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild">canBuild</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.effectiveInferredImplicits" title="List[Implicit]">effectiveInferredImplicits</a>.<span title="(f: Implicit =&gt; c.universe.Apply)(implicit bf: scala.collection.generic.CanBuildFrom[List[Implicit],c.universe.Apply,List[c.universe.Apply]])List[c.universe.Apply]">map</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.x0$1" title="c.universe.Apply" class="delimiter">{</a>
      <span class="keyword">case</span> Implicit<span class="delimiter">(</span><a title="c.universe.Name" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.name">name</a>, <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.t">t</a>, <a title="c.universe.Tree" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.impl">impl</a>, <a title="Boolean" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.rec">rec</a>, <a title="c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.tpe">tpe</a><span class="delimiter">)</span> =&gt;
        <span class="comment">// inception of (__ \name).read(impl)</span>
        <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.jspathTree">jspathTree</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
          <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.jsPathSelect" title="c.universe.Tree">jsPathSelect</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span>scala.reflect.<span title="scala.reflect.NameTransformer.type">NameTransformer</span>.<span title="(name: String)String">encode</span><span class="delimiter">(</span><span title="String(&quot;\\&quot;)" class="string">&quot;\\&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
          <span title="(xs: c.universe.Literal*)List[c.universe.Literal]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(value: c.universe.Constant)c.universe.Literal">Literal</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(value: Any)c.universe.Constant">Constant</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.name" title="c.universe.Name">name</a>.<span title="=&gt; String">decoded</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>

        <span title="c.universe.Apply" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.rec" title="Boolean">rec</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a title="String" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.callMethod">callMethod</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.t" title="c.universe.Type">t</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.callMethod;$typecreator6.apply.symdef$_$21" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.nullableMethodName" title="String">nullableMethodName</a> <span class="keyword">else</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.methodName" title="String">methodName</a>
          <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
            <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.callMethod" title="String">callMethod</a><span class="delimiter">)</span><span class="delimiter">)</span>,
            <span title="(xs: c.universe.Tree*)List[c.universe.Tree]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.impl" title="c.universe.Tree">impl</a><span class="delimiter">)</span>
          <span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <a href="#play.api.libs.json.JsMacroImpl.macroImpl.hasRec" title="Boolean">hasRec</a> = <span title="Boolean(true)" class="keyword">true</span>
          <span title="c.universe.Apply" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.t" title="c.universe.Type">t</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(implicit ttag: c.universe.TypeTag[Option[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun;$typecreator7.apply.symdef$_$31" class="delimiter">[</a><span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
            <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
              <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.nullableMethodName" title="String">nullableMethodName</a><span class="delimiter">)</span><span class="delimiter">)</span>,
              <a href="#play.api.libs.json.JsMacroImpl.macroImpl.callHelper" title="(target: c.universe.Tree, methodName: String)c.universe.Tree">callHelper</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.jsPathSelect" title="c.universe.Tree">jsPathSelect</a>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.lazyMethodName" title="String">lazyMethodName</a><span class="delimiter">)</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.x$14" title="(x: c.universe.Tree)List[c.universe.Tree]">::</a> <span title="scala.collection.immutable.Nil.type">Nil</span>
            <span class="delimiter">)</span>
          <span class="keyword">else</span> <span class="delimiter">{</span>
            <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
              <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.jspathTree" title="c.universe.Apply">jspathTree</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.lazyMethodName" title="String">lazyMethodName</a><span class="delimiter">)</span><span class="delimiter">)</span>,
              <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(implicit ttag: c.universe.TypeTag[List[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun;$typecreator8.apply.symdef$_$41" class="delimiter">[</a><span title="List[_]">List</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                <a href="#play.api.libs.json.JsMacroImpl.macroImpl.readsWritesHelper" title="(methodName: String)List[c.universe.Tree]">readsWritesHelper</a><span class="delimiter">(</span><span title="String(&quot;list&quot;)" class="string">&quot;list&quot;</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(implicit ttag: c.universe.TypeTag[Set[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun;$typecreator9.apply.symdef$_$51" class="delimiter">[</a><span title="Set[_]">Set</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                <a href="#play.api.libs.json.JsMacroImpl.macroImpl.readsWritesHelper" title="(methodName: String)List[c.universe.Tree]">readsWritesHelper</a><span class="delimiter">(</span><span title="String(&quot;set&quot;)" class="string">&quot;set&quot;</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(implicit ttag: c.universe.TypeTag[Seq[_]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun;$typecreator10.apply.symdef$_$61" class="delimiter">[</a><span title="Seq[_]">Seq</span><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                <a href="#play.api.libs.json.JsMacroImpl.macroImpl.readsWritesHelper" title="(methodName: String)List[c.universe.Tree]">readsWritesHelper</a><span class="delimiter">(</span><span title="String(&quot;seq&quot;)" class="string">&quot;seq&quot;</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span> <span title="(that: c.universe.Type)Boolean">&lt;:&lt;</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="[T](implicit ttag: c.universe.TypeTag[T])c.universe.Type">typeOf</a><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(implicit ttag: c.universe.TypeTag[Map[_, _]])c.universe.Type" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun;$typecreator11.apply.symdef$_$81" class="delimiter">[</a><span title="Map[_, _]">Map</span><span class="delimiter">[</span>_, _<span class="delimiter">]</span><span class="delimiter">]</span>.<span title="=&gt; c.universe.Type">typeConstructor</span><span class="delimiter">)</span>
                <a href="#play.api.libs.json.JsMacroImpl.macroImpl.readsWritesHelper" title="(methodName: String)List[c.universe.Tree]">readsWritesHelper</a><span class="delimiter">(</span><span title="String(&quot;map&quot;)" class="string">&quot;map&quot;</span><span class="delimiter">)</span>
              <span class="keyword">else</span> <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.helperMember" title="c.universe.Select">helperMember</a><span class="delimiter">)</span>
            <span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>.<span title="(f: (c.universe.Apply, c.universe.Apply) =&gt; c.universe.Apply)c.universe.Apply">reduceLeft</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.acc">acc</a>, <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.r">r</a><span class="delimiter">)</span> =&gt;
      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
        <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.acc" title="c.universe.Apply">acc</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;and&quot;)" class="string">&quot;and&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
        <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild.$anonfun.r" title="c.universe.Apply">r</a><span class="delimiter">)</span>
      <span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// builds the final M[A] using apply method</span>
    <span class="comment">//val applyMethod = Ident( companionSymbol )</span>

    <span class="keyword">val</span> <a title="List[c.universe.Tree]" id="play.api.libs.json.JsMacroImpl.macroImpl.applyBody">applyBody</a> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="List[c.universe.Tree]" id="play.api.libs.json.JsMacroImpl.macroImpl.applyBody.body">body</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(z: List[c.universe.Tree])(f: (List[c.universe.Tree], c.universe.Symbol) =&gt; List[c.universe.Tree])List[c.universe.Tree]">foldLeft</span><span class="delimiter">(</span>List<span class="delimiter">[</span>Tree<span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="List[c.universe.Tree]" id="play.api.libs.json.JsMacroImpl.macroImpl.applyBody.body.$anonfun.l">l</a>, <a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.macroImpl.applyBody.body.$anonfun.e">e</a><span class="delimiter">)</span> =&gt;
        <a href="#play.api.libs.json.JsMacroImpl.macroImpl.applyBody.body.$anonfun.l" title="List[c.universe.Tree]">l</a> <span title="(elem: c.universe.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Tree],c.universe.Tree,List[c.universe.Tree]])List[c.universe.Tree]">:+</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.applyBody.body.$anonfun.e" title="c.universe.Symbol">e</a>.<span title="=&gt; c.universe.Name">name</span>.<span title="=&gt; String">encoded</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>
      <span title="List[c.universe.Tree]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.hasVarArgs" title="Boolean">hasVarArgs</a><span class="delimiter">)</span>
        <a href="#play.api.libs.json.JsMacroImpl.macroImpl.applyBody.body" title="List[c.universe.Tree]">body</a>.<span title="=&gt; List[c.universe.Tree]">init</span> <span title="(elem: c.universe.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Tree],c.universe.Tree,List[c.universe.Tree]])List[c.universe.Tree]">:+</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(expr: c.universe.Tree, tpt: c.universe.Tree)c.universe.Typed">Typed</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.applyBody.body" title="List[c.universe.Tree]">body</a>.<span title="=&gt; c.universe.Tree">last</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">WILDCARD_STAR</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.applyBody.body" title="List[c.universe.Tree]">body</a>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="c.universe.Function" id="play.api.libs.json.JsMacroImpl.macroImpl.applyMethod">applyMethod</a> =
      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(vparams: List[c.universe.ValDef], body: c.universe.Tree)c.universe.Function">Function</a><span class="delimiter">(</span>
        <a href="#play.api.libs.json.JsMacroImpl.macroImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="(z: List[c.universe.ValDef])(f: (List[c.universe.ValDef], c.universe.Symbol) =&gt; List[c.universe.ValDef])List[c.universe.ValDef]">foldLeft</span><span class="delimiter">(</span>List<span class="delimiter">[</span>ValDef<span class="delimiter">]</span><span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="delimiter">(</span><a title="List[c.universe.ValDef]" id="play.api.libs.json.JsMacroImpl.macroImpl.applyMethod.$anonfun.l">l</a>, <a title="c.universe.Symbol" id="play.api.libs.json.JsMacroImpl.macroImpl.applyMethod.$anonfun.e">e</a><span class="delimiter">)</span> =&gt;
          <a href="#play.api.libs.json.JsMacroImpl.macroImpl.applyMethod.$anonfun.l" title="List[c.universe.ValDef]">l</a> <span title="(elem: c.universe.ValDef)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.ValDef],c.universe.ValDef,List[c.universe.ValDef]])List[c.universe.ValDef]">:+</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TermName, tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.ValDef">ValDef</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(flags: c.universe.FlagSet)c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.FlagSet">PARAM</a><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.applyMethod.$anonfun.e" title="c.universe.Symbol">e</a>.<span title="=&gt; c.universe.Name">name</span>.<span title="=&gt; String">encoded</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="()c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.Tree">EmptyTree</a><span class="delimiter">)</span>
        <span class="delimiter">)</span>,
        <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
          <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;apply&quot;)" class="string">&quot;apply&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
          <a href="#play.api.libs.json.JsMacroImpl.macroImpl.applyBody" title="List[c.universe.Tree]">applyBody</a>
        <span class="delimiter">)</span>
      <span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.macroImpl.unapplyMethod">unapplyMethod</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.unliftIdent" title="c.universe.Tree">unliftIdent</a>,
      <span title="(xs: c.universe.Select*)List[c.universe.Select]">List</span><span class="delimiter">(</span>
        <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.companionSymbol" title="c.universe.Symbol">companionSymbol</a><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.effectiveUnapply" title="c.universe.MethodSymbol">effectiveUnapply</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>
    <span class="delimiter">)</span>

    <span class="comment">// if case class has one single field, needs to use inmap instead of canbuild.apply</span>
    <span class="keyword">val</span> <a title="String" id="play.api.libs.json.JsMacroImpl.macroImpl.method">method</a> = <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.params" title="List[c.universe.Symbol]">params</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span> <span title="String(&quot;apply&quot;)" class="string">&quot;apply&quot;</span> <span class="keyword">else</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.mapLikeMethod" title="String">mapLikeMethod</a>
    <span class="keyword">val</span> <a title="c.universe.Apply" id="play.api.libs.json.JsMacroImpl.macroImpl.finalTree">finalTree</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.canBuild" title="c.universe.Apply">canBuild</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.method" title="String">method</a><span class="delimiter">)</span><span class="delimiter">)</span>,
      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.conditionalList" title="(ifReads: c.universe.TermTree with c.universe.Tree with c.universe.TermTreeApi, ifWrites: c.universe.TermTree with c.universe.Tree with c.universe.TermTreeApi)List[c.universe.TermTree with c.universe.Tree with c.universe.TermTreeApi]">conditionalList</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.applyMethod" title="c.universe.Function">applyMethod</a>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.unapplyMethod" title="c.universe.Apply">unapplyMethod</a><span class="delimiter">)</span>
    <span class="delimiter">)</span>
    <span class="comment">//println(&quot;finalTree: &quot; + finalTree)</span>

    <span class="keyword">val</span> <a title="c.universe.Import" id="play.api.libs.json.JsMacroImpl.macroImpl.importFunctionalSyntax">importFunctionalSyntax</a> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(expr: c.universe.Tree, selectors: List[c.universe.ImportSelector])c.universe.Import">Import</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.functionalSyntaxPkg" title="c.universe.Tree">functionalSyntaxPkg</a>, <span title="(xs: c.universe.ImportSelector*)List[c.universe.ImportSelector]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(name: c.universe.Name, namePos: Int, rename: c.universe.Name, renamePos: Int)c.universe.ImportSelector">ImportSelector</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">WILDCARD</span>, -<span title="Int(-1)" class="int">1</span>, <span title="Null(null)" class="keyword">null</span>, -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span title="c.Expr[M[A]]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.hasRec" title="Boolean">hasRec</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <span title="c.universe.Block">block</span> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(stats: List[c.universe.Tree], expr: c.universe.Tree)c.universe.Block">Block</a><span class="delimiter">(</span>
        <span title="(xs: c.universe.Import*)List[c.universe.Import]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.importFunctionalSyntax" title="c.universe.Import">importFunctionalSyntax</a><span class="delimiter">)</span>,
        <a href="#play.api.libs.json.JsMacroImpl.macroImpl.finalTree" title="c.universe.Apply">finalTree</a>
      <span class="delimiter">)</span>
      <span class="comment">//println(&quot;block:&quot;+block)</span>
      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[M[A]])c.Expr[M[A]]" class="delimiter">[</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl;M" title="M[A]">M</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.matag" title="c.WeakTypeTag[M[A]]" class="delimiter">(</a><span title="c.universe.Block">block</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <span title="c.universe.Select">block</span> = <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span>
        <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(stats: List[c.universe.Tree], expr: c.universe.Tree)c.universe.Block">Block</a><span class="delimiter">(</span>
          <span title="(xs: c.universe.SymTree with c.universe.Tree with c.universe.SymTreeContextApi*)List[c.universe.SymTree with c.universe.Tree with c.universe.SymTreeContextApi]">List</span><span class="delimiter">(</span>
            <a href="#play.api.libs.json.JsMacroImpl.macroImpl.importFunctionalSyntax" title="c.universe.Import">importFunctionalSyntax</a>,
            <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TypeName, tparams: List[c.universe.TypeDef], impl: c.universe.Template)c.universe.ClassDef">ClassDef</a><span class="delimiter">(</span>
              <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(flags: c.universe.FlagSet)c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.FlagValues">Flag</a>.<span title="=&gt; c.universe.FlagSet">FINAL</span><span class="delimiter">)</span>,
              <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;$anon&quot;)" class="string">&quot;$anon&quot;</span><span class="delimiter">)</span>,
              List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>,
              <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(parents: List[c.universe.Tree], self: c.universe.ValDef, body: List[c.universe.Tree])c.universe.Template">Template</a><span class="delimiter">(</span>
                <span title="(xs: c.universe.AppliedTypeTree*)List[c.universe.AppliedTypeTree]">List</span><span class="delimiter">(</span>
                  <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(tpt: c.universe.Tree, args: List[c.universe.Tree])c.universe.AppliedTypeTree">AppliedTypeTree</a><span class="delimiter">(</span>
                    <a href="#play.api.libs.json.JsMacroImpl.macroImpl.lazyHelperSelect" title="c.universe.Select">lazyHelperSelect</a>,
                    <span title="(xs: c.universe.Ident*)List[c.universe.Ident]">List</span><span class="delimiter">(</span>
                      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.matag" title="c.WeakTypeTag[M[A]]">matag</a>.<span title="=&gt; c.universe.Type">tpe</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span><span class="delimiter">)</span>,
                      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.atag" title="c.WeakTypeTag[A]">atag</a>.<span title="=&gt; c.universe.Type">tpe</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span><span class="delimiter">)</span>
                    <span class="delimiter">)</span>
                  <span class="delimiter">)</span>
                <span class="delimiter">)</span>,
                <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.ValDef">emptyValDef</a>,
                <span title="(xs: c.universe.ValOrDefDef with c.universe.MemberDef with c.universe.ValOrDefDefApi with c.universe.SymTree with c.universe.NameTree with c.universe.DefTreeApi with c.universe.Tree with c.universe.NameTreeApi*)List[c.universe.ValOrDefDef with c.universe.MemberDef with c.universe.ValOrDefDefApi with c.universe.SymTree with c.universe.NameTree with c.universe.DefTreeApi with c.universe.Tree with c.universe.NameTreeApi]">List</span><span class="delimiter">(</span>
                  <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.Name, tparams: List[c.universe.TypeDef], vparamss: List[List[c.universe.ValDef]], tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.DefDef">DefDef</a><span class="delimiter">(</span>
                    <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="()c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><span class="delimiter">)</span>,
                    <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">CONSTRUCTOR</span>,
                    List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>,
                    <span title="(xs: List[Nothing]*)List[List[Nothing]]">List</span><span class="delimiter">(</span>List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                    <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="()c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><span class="delimiter">)</span>,
                    <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(stats: List[c.universe.Tree], expr: c.universe.Tree)c.universe.Block">Block</a><span class="delimiter">(</span>
                      <span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span>
                        <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span>
                          <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qual: c.universe.Tree, mix: c.universe.TypeName)c.universe.Super">Super</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qual: c.universe.TypeName)c.universe.This">This</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">EMPTY</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">EMPTY</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">CONSTRUCTOR</span><span class="delimiter">)</span>,
                          List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>
                        <span class="delimiter">)</span>
                      <span class="delimiter">)</span>,
                      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(value: c.universe.Constant)c.universe.Literal">Literal</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(value: Any)c.universe.Constant">Constant</a><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
                    <span class="delimiter">)</span>
                  <span class="delimiter">)</span>,
                  <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TermName, tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.ValDef">ValDef</a><span class="delimiter">(</span>
                    <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(flags: c.universe.FlagSet)c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.FlagValues">Flag</a>.<a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="implicit scala.reflect.api.FlagSets.addFlagOps : (left: c.universe.FlagSet)c.universe.FlagOps">OVERRIDE</a> <span title="(right: c.universe.FlagSet)c.universe.FlagSet">|</span> <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.FlagValues">Flag</a>.<span title="=&gt; c.universe.FlagSet">LAZY</span><span class="delimiter">)</span>,
                    <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyStuff&quot;)" class="string">&quot;lazyStuff&quot;</span><span class="delimiter">)</span>,
                    <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(tpt: c.universe.Tree, args: List[c.universe.Tree])c.universe.AppliedTypeTree">AppliedTypeTree</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.matag" title="c.WeakTypeTag[M[A]]">matag</a>.<span title="=&gt; c.universe.Type">tpe</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span><span class="delimiter">)</span>, <span title="(xs: c.universe.TypeTree*)List[c.universe.TypeTree]">List</span><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.atag" title="c.WeakTypeTag[A]">atag</a>.<span title="=&gt; c.universe.Type">tpe</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
                    <a href="#play.api.libs.json.JsMacroImpl.macroImpl.finalTree" title="c.universe.Apply">finalTree</a>
                  <span class="delimiter">)</span>
                <span class="delimiter">)</span>
              <span class="delimiter">)</span>
            <span class="delimiter">)</span>
          <span class="delimiter">)</span>,
          <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(tpt: c.universe.Tree)c.universe.New">New</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;$anon&quot;)" class="string">&quot;$anon&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">CONSTRUCTOR</span><span class="delimiter">)</span>, List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>,
        <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;lazyStuff&quot;)" class="string">&quot;lazyStuff&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>

      <span class="comment">// println(&quot;block:&quot; + block)</span>

      <a href="#play.api.libs.json.JsMacroImpl.macroImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[M[A]])c.Expr[M[A]]" class="delimiter">[</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl;M" title="M[A]">M</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><a href="#play.api.libs.json.JsMacroImpl.macroImpl.matag" title="c.WeakTypeTag[M[A]]" class="delimiter">(</a><span title="c.universe.Select">block</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
