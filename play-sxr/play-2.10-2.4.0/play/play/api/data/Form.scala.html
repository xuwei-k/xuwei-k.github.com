<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>play/play/api/data/Form.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (C) 2009-2015 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
<span class="keyword">package</span> play.api.data

<span class="keyword">import</span> scala.<span title="language.type">language</span>.existentials

<span class="keyword">import</span> format._
<span class="keyword">import</span> play.api.data.validation._

<span class="comment">/**
 * Helper to manage HTML form description, submission and validation.
 *
 * For example, a form handling a `User` case class submission:
 * {{{
 * import play.api.data._
 * import play.api.data.Forms._
 * import play.api.data.format.Formats._
 *
 * val userForm = Form(
 *   mapping(
 *     &quot;name&quot; -&gt; of[String],
 *     &quot;age&quot; -&gt; of[Int],
 *     &quot;email&quot; -&gt; of[String]
 *   )(User.apply)(User.unapply)
 * )
 * }}}
 *
 * @tparam T the type managed by this form
 * @param mapping the form mapping, which describes all form fields
 * @param data the current form data, used to display the form
 * @param errors the collection of errors associated with this form
 * @param value a concrete value of type `T` if the form submission was successful
 */</span>
<span class="keyword">case class</span> <a href="#play.api.data;Form.productElement.x$1" title="class Form[T] extends AnyRef with Product with Serializable" id="play.api.data;Form">Form</a><span class="delimiter">[</span><a title="" id="play.api.data;Form;T">T</a><span class="delimiter">]</span><a href="#play.api.data;Form" title="Product" class="delimiter">(</a><a title="play.api.data.Mapping[T]" id="play.api.data;Form.mapping">mapping</a>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[T]">Mapping</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="Map[String,String]" id="play.api.data;Form.data">data</a>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span>, <a title="Seq[play.api.data.FormError]" id="play.api.data;Form.errors">errors</a>: <span title="Seq[play.api.data.FormError]">Seq</span><span class="delimiter">[</span>FormError<span class="delimiter">]</span>, <a title="Option[T]" id="play.api.data;Form.value">value</a>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

  <span class="comment">/**
   * Constraints associated with this form, indexed by field name.
   */</span>
  <span class="keyword">val</span> <a title="Map[String,Seq[(String, Seq[Any])]]" id="play.api.data;Form.constraints">constraints</a>: <span title="Map[String,Seq[(String, Seq[Any])]]">Map</span><span class="delimiter">[</span>String, Seq<span class="delimiter">[</span><span class="delimiter">(</span>String, Seq<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#play.api.data;Form.mapping" title="=&gt; play.api.data.Mapping[T]">mapping</a>.<a href="#play.api.data;Mapping.mappings" title="=&gt; Seq[play.api.data.Mapping[_]]">mappings</a>.<span title="(f: play.api.data.Mapping[_] =&gt; (String, Seq[(String, Seq[Any])]))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[play.api.data.Mapping[_]],(String, Seq[(String, Seq[Any])]),Seq[(String, Seq[(String, Seq[Any])])]])Seq[(String, Seq[(String, Seq[Any])])]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,(String, Seq[(String, Seq[Any])]),Seq[(String, Seq[(String, Seq[Any])])]]" class="delimiter">{</span> <a title="play.api.data.Mapping[_]" id="play.api.data;Form.constraints.$anonfun.m">m</a> =&gt;
    <a href="#play.api.data;Form.constraints.$anonfun.m" title="play.api.data.Mapping[_]">m</a>.<a href="#play.api.data;Mapping.key" title="(x: String)ArrowAssoc[String]">key</a> <span title="(y: Seq[(String, Seq[Any])])(String, Seq[(String, Seq[Any])])">-&gt;</span> <a href="#play.api.data;Form.constraints.$anonfun.m" title="play.api.data.Mapping[_]">m</a>.<a href="#play.api.data;Mapping.constraints" title="=&gt; Seq[play.api.data.validation.Constraint[_$3]]">constraints</a>.<span title="(pf: PartialFunction[play.api.data.validation.Constraint[_$3],(String, Seq[Any])])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[play.api.data.validation.Constraint[_$3]],(String, Seq[Any]),Seq[(String, Seq[Any])]])Seq[(String, Seq[Any])]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[play.api.data.validation.Constraint[_$3],(String, Seq[Any])] with Serializable" id="play.api.data;Form.constraints.$anonfun;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> <span class="keyword">case</span> Constraint<span class="delimiter">(</span>Some<span class="delimiter">(</span><a title="String" id="play.api.data;Form.constraints.$anonfun;$anonfun.isDefinedAt.name">name</a><span class="delimiter">)</span>, <a title="Seq[Any]" id="play.api.data;Form.constraints.$anonfun;$anonfun.isDefinedAt.args">args</a><span class="delimiter">)</span> =&gt; <a href="#play.api.data;Form.constraints.$anonfun;$anonfun.isDefinedAt.name" title="(x: String)ArrowAssoc[String]">name</a> <span title="(y: Seq[Any])(String, Seq[Any])">-&gt;</span> <a href="#play.api.data;Form.constraints.$anonfun;$anonfun.isDefinedAt.args" title="Seq[Any]">args</a> <span class="delimiter">}</span>
  <span class="delimiter">}</span>.<span title="(p: ((String, Seq[(String, Seq[Any])])) =&gt; Boolean)Seq[(String, Seq[(String, Seq[Any])])]">filterNot</span><span class="delimiter">(</span><a href="#play.api.data;Form.constraints.$anonfun.x$1" title="(String, Seq[(String, Seq[Any])])">_</a>.<span title="=&gt; Seq[(String, Seq[Any])]">_2</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>.<span title="(implicit ev: &lt;:&lt;[(String, Seq[(String, Seq[Any])]),(String, Seq[(String, Seq[Any])])])scala.collection.immutable.Map[String,Seq[(String, Seq[Any])]]">toMap</span>

  <span class="comment">/**
   * Formats associated to this form, indexed by field name. *
   */</span>
  <span class="keyword">val</span> <a title="Map[String,(String, Seq[Any])]" id="play.api.data;Form.formats">formats</a>: <span title="Map[String,(String, Seq[Any])]">Map</span><span class="delimiter">[</span>String, <span class="delimiter">(</span>String, Seq<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#play.api.data;Form.mapping" title="=&gt; play.api.data.Mapping[T]">mapping</a>.<a href="#play.api.data;Mapping.mappings" title="=&gt; Seq[play.api.data.Mapping[_]]">mappings</a>.<span title="(f: play.api.data.Mapping[_] =&gt; (String, Option[(String, Seq[Any])]))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[play.api.data.Mapping[_]],(String, Option[(String, Seq[Any])]),Seq[(String, Option[(String, Seq[Any])])]])Seq[(String, Option[(String, Seq[Any])])]">map</span> <span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,(String, Option[(String, Seq[Any])]),Seq[(String, Option[(String, Seq[Any])])]]" class="delimiter">{</span> <a title="play.api.data.Mapping[_]" id="play.api.data;Form.formats.$anonfun.m">m</a> =&gt;
    <a href="#play.api.data;Form.formats.$anonfun.m" title="play.api.data.Mapping[_]">m</a>.<a href="#play.api.data;Mapping.key" title="(x: String)ArrowAssoc[String]">key</a> <span title="(y: Option[(String, Seq[Any])])(String, Option[(String, Seq[Any])])">-&gt;</span> <a href="#play.api.data;Form.formats.$anonfun.m" title="play.api.data.Mapping[_]">m</a>.<a href="#play.api.data;Mapping.format" title="=&gt; Option[(String, Seq[Any])]">format</a>
  <span class="delimiter">}</span>.<span title="(pf: PartialFunction[(String, Option[(String, Seq[Any])]),(String, (String, Seq[Any]))])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, Option[(String, Seq[Any])])],(String, (String, Seq[Any])),Seq[(String, (String, Seq[Any]))]])Seq[(String, (String, Seq[Any]))]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[(String, Option[(String, Seq[Any])]),(String, (String, Seq[Any]))] with Serializable" id="play.api.data;Form.formats;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
    <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="play.api.data;Form.formats;$anonfun.isDefinedAt.k">k</a>, Some<span class="delimiter">(</span><a title="(String, Seq[Any])" id="play.api.data;Form.formats;$anonfun.isDefinedAt.f">f</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#play.api.data;Form.formats;$anonfun.isDefinedAt.k" title="(x: String)ArrowAssoc[String]">k</a> <span title="(y: (String, Seq[Any]))(String, (String, Seq[Any]))">-&gt;</span> <a href="#play.api.data;Form.formats;$anonfun.isDefinedAt.f" title="(String, Seq[Any])">f</a>
  <span class="delimiter">}</span>.<span title="(implicit ev: &lt;:&lt;[(String, (String, Seq[Any])),(String, (String, Seq[Any]))])scala.collection.immutable.Map[String,(String, Seq[Any])]">toMap</span>

  <span class="comment">/**
   * Binds data to this form, i.e. handles form submission.
   *
   * @param data the data to submit
   * @return a copy of this form, filled with the new data
   */</span>
  <span class="keyword">def</span> <a title="(data: Map[String,String])play.api.data.Form[T]" id="play.api.data;Form.bind(5a82085d3b)">bind</a><span class="delimiter">(</span><a title="Map[String,String]" id="play.api.data;Form.bind(5a82085d3b).data">data</a>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#play.api.data;Form" title="play.api.data.Form[T]">Form</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#play.api.data;Form.mapping" title="=&gt; play.api.data.Mapping[T]">mapping</a>.<a href="#play.api.data;Mapping.bind" title="(data: Map[String,String])Either[Seq[play.api.data.FormError],T]">bind</a><span class="delimiter">(</span><a href="#play.api.data;Form.bind(5a82085d3b).data" title="Map[String,String]">data</a><span class="delimiter">)</span>.<span title="(fa: Seq[play.api.data.FormError] =&gt; play.api.data.Form[T], fb: T =&gt; play.api.data.Form[T])play.api.data.Form[T]">fold</span><span class="delimiter">(</span>
    <a title="Seq[play.api.data.FormError]" id="play.api.data;Form.bind(5a82085d3b).$anonfun.newErrors">newErrors</a> =&gt; <a href="#play.api.data;Form" title="Form.this.type" class="keyword">this</a>.<a href="#play.api.data;Form.mapping" title="play.api.data.Mapping[T] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.bind(5a82085d3b).$anonfun.x$38">copy</a><span class="delimiter">(</span>data = <a href="#play.api.data;Form.bind(5a82085d3b).data" title="Map[String,String] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.bind(5a82085d3b).$anonfun.x$35">data</a>, errors = <a href="#play.api.data;Form.errors" title="=&gt; Seq[play.api.data.FormError]">errors</a> <a title="Seq[play.api.data.FormError] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.bind(5a82085d3b).$anonfun.x$36">++</a> <a href="#play.api.data;Form.bind(5a82085d3b).$anonfun.newErrors" title="Seq[play.api.data.FormError]">newErrors</a>, value = <a title="None.type" id="play.api.data;Form.bind(5a82085d3b).$anonfun.x$37">None</a><span class="delimiter">)</span>,
    <a title="T" id="play.api.data;Form.bind(5a82085d3b).$anonfun.value">value</a> =&gt; <a href="#play.api.data;Form" title="Form.this.type" class="keyword">this</a>.<a href="#play.api.data;Form.mapping" title="play.api.data.Mapping[T] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.bind(5a82085d3b).$anonfun.x$42">copy</a><span class="delimiter">(</span>data = <a href="#play.api.data;Form.bind(5a82085d3b).data" title="Map[String,String] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.bind(5a82085d3b).$anonfun.x$39">data</a>, errors = <a href="#play.api.data;Form.errors" title="Seq[play.api.data.FormError] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.bind(5a82085d3b).$anonfun.x$40">errors</a>, value = <span title="(x: T)Some[T]">Some</span><a title="Some[T] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.bind(5a82085d3b).$anonfun.x$41" class="delimiter">(</a><a href="#play.api.data;Form.bind(5a82085d3b).$anonfun.value" title="T">value</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Binds data to this form, i.e. handles form submission.
   *
   * @param data Json data to submit
   * @return a copy of this form, filled with the new data
   */</span>
  <span class="keyword">def</span> <a title="(data: play.api.libs.json.JsValue)play.api.data.Form[T]" id="play.api.data;Form.bind(e11765a7e4)">bind</a><span class="delimiter">(</span><a title="play.api.libs.json.JsValue" id="play.api.data;Form.bind(e11765a7e4).data">data</a>: play.api.libs.json.<a href="../../../../play-json/play/api/libs/json/JsValue.scala.html#play.api.libs.json;JsValue" title="play.api.libs.json.JsValue">JsValue</a><span class="delimiter">)</span>: <a href="#play.api.data;Form" title="play.api.data.Form[T]">Form</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#play.api.data;Form.bind(5a82085d3b)" title="(data: Map[String,String])play.api.data.Form[T]">bind</a><span class="delimiter">(</span><a href="#play.api.data.FormUtils" title="play.api.data.FormUtils.type">FormUtils</a>.<a href="#play.api.data.FormUtils.fromJson$default$1" title="String" id="play.api.data;Form.bind(e11765a7e4).x$44">fromJson</a><span class="delimiter">(</span>js = <a href="#play.api.data;Form.bind(e11765a7e4).data" title="play.api.libs.json.JsValue" id="play.api.data;Form.bind(e11765a7e4).x$43">data</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Binds request data to this form, i.e. handles form submission.
   *
   * @return a copy of this form filled with the new data
   */</span>
  <span class="keyword">def</span> <a title="()(implicit request: play.api.mvc.Request[_])play.api.data.Form[T]" id="play.api.data;Form.bindFromRequest(e945bc6ab6)">bindFromRequest</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="play.api.mvc.Request[_]" id="play.api.data;Form.bindFromRequest(e945bc6ab6).request">request</a>: play.api.mvc.<a href="../mvc/Http.scala.html#play.api.mvc;Request" title="play.api.mvc.Request[_]">Request</a><span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#play.api.data;Form" title="play.api.data.Form[T]">Form</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data;Form.bindFromRequest(7cae208c55)" title="(data: Map[String,Seq[String]])play.api.data.Form[T]">bindFromRequest</a> <span class="delimiter">{</span>
      <span class="delimiter">(</span><a href="#play.api.data;Form.bindFromRequest(e945bc6ab6).request" title="play.api.mvc.Request[_]">request</a>.<a href="../mvc/Http.scala.html#play.api.mvc;Request.body" title="=&gt; _$1">body</a> <span title="Map[String,Seq[String]]" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <span title="play.api.mvc.AnyContent">body</span>: play.api.mvc.<a href="../mvc/ContentTypes.scala.html#play.api.mvc;AnyContent" title="play.api.mvc.AnyContent">AnyContent</a> <span class="keyword">if</span> <span title="play.api.mvc.AnyContent">body</span>.<a href="../mvc/ContentTypes.scala.html#play.api.mvc;AnyContent.asFormUrlEncoded" title="=&gt; Option[Map[String,Seq[String]]]">asFormUrlEncoded</a>.<span title="=&gt; Boolean">isDefined</span> =&gt; <span title="play.api.mvc.AnyContent">body</span>.<a href="../mvc/ContentTypes.scala.html#play.api.mvc;AnyContent.asFormUrlEncoded" title="=&gt; Option[Map[String,Seq[String]]]">asFormUrlEncoded</a>.<span title="=&gt; Map[String,Seq[String]]">get</span>
        <span class="keyword">case</span> <span title="play.api.mvc.AnyContent">body</span>: play.api.mvc.<a href="../mvc/ContentTypes.scala.html#play.api.mvc;AnyContent" title="play.api.mvc.AnyContent">AnyContent</a> <span class="keyword">if</span> <span title="play.api.mvc.AnyContent">body</span>.<a href="../mvc/ContentTypes.scala.html#play.api.mvc;AnyContent.asMultipartFormData" title="=&gt; Option[play.api.mvc.MultipartFormData[play.api.libs.Files.TemporaryFile]]">asMultipartFormData</a>.<span title="=&gt; Boolean">isDefined</span> =&gt; <span title="play.api.mvc.AnyContent">body</span>.<a href="../mvc/ContentTypes.scala.html#play.api.mvc;AnyContent.asMultipartFormData" title="=&gt; Option[play.api.mvc.MultipartFormData[play.api.libs.Files.TemporaryFile]]">asMultipartFormData</a>.<span title="=&gt; play.api.mvc.MultipartFormData[play.api.libs.Files.TemporaryFile]">get</span>.<a href="../mvc/ContentTypes.scala.html#play.api.mvc;MultipartFormData.asFormUrlEncoded" title="=&gt; Map[String,Seq[String]]">asFormUrlEncoded</a>
        <span class="keyword">case</span> <span title="play.api.mvc.AnyContent">body</span>: play.api.mvc.<a href="../mvc/ContentTypes.scala.html#play.api.mvc;AnyContent" title="play.api.mvc.AnyContent">AnyContent</a> <span class="keyword">if</span> <span title="play.api.mvc.AnyContent">body</span>.<a href="../mvc/ContentTypes.scala.html#play.api.mvc;AnyContent.asJson" title="=&gt; Option[play.api.libs.json.JsValue]">asJson</a>.<span title="=&gt; Boolean">isDefined</span> =&gt; <a href="#play.api.data.FormUtils" title="play.api.data.FormUtils.type">FormUtils</a>.<a href="#play.api.data.FormUtils.fromJson$default$1" title="String" id="play.api.data;Form.bindFromRequest(e945bc6ab6).x$46">fromJson</a><span class="delimiter">(</span>js = <span title="play.api.mvc.AnyContent">body</span>.<a href="../mvc/ContentTypes.scala.html#play.api.mvc;AnyContent.asJson" title="=&gt; Option[play.api.libs.json.JsValue]">asJson</a>.<a title="play.api.libs.json.JsValue" id="play.api.data;Form.bindFromRequest(e945bc6ab6).x$45">get</a><span class="delimiter">)</span>.<span title="(f: String =&gt; Seq[String])scala.collection.immutable.Map[String,Seq[String]]">mapValues</span><span class="delimiter">(</span><span title="(elems: String*)Seq[String]">Seq</span><span class="delimiter">(</span><a href="#play.api.data;Form.bindFromRequest(e945bc6ab6).$anonfun.x$2" title="String">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> <span title="Map[_,_]">body</span>: <span title="Map[_,_]">Map</span><span class="delimiter">[</span>_, _<span class="delimiter">]</span> =&gt; <span title="Map[_,_]">body</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Map[String,Seq[String]]" class="delimiter">[</span><span title="Map[String,Seq[String]]">Map</span><span class="delimiter">[</span>String, Seq<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
        <span class="keyword">case</span> <span title="play.api.mvc.MultipartFormData[_]">body</span>: play.api.mvc.<a href="../mvc/ContentTypes.scala.html#play.api.mvc;MultipartFormData" title="play.api.mvc.MultipartFormData[_]">MultipartFormData</a><span class="delimiter">[</span>_<span class="delimiter">]</span> =&gt; <span title="play.api.mvc.MultipartFormData[_]">body</span>.<a href="../mvc/ContentTypes.scala.html#play.api.mvc;MultipartFormData.asFormUrlEncoded" title="=&gt; Map[String,Seq[String]]">asFormUrlEncoded</a>
        <span class="keyword">case</span> <span title="play.api.libs.json.JsValue">body</span>: play.api.libs.json.<a href="../../../../play-json/play/api/libs/json/JsValue.scala.html#play.api.libs.json;JsValue" title="play.api.libs.json.JsValue">JsValue</a> =&gt; <a href="#play.api.data.FormUtils" title="play.api.data.FormUtils.type">FormUtils</a>.<a href="#play.api.data.FormUtils.fromJson$default$1" title="String" id="play.api.data;Form.bindFromRequest(e945bc6ab6).x$48">fromJson</a><span class="delimiter">(</span>js = <a title="play.api.libs.json.JsValue" id="play.api.data;Form.bindFromRequest(e945bc6ab6).x$47">body</a><span class="delimiter">)</span>.<span title="(f: String =&gt; Seq[String])scala.collection.immutable.Map[String,Seq[String]]">mapValues</span><span class="delimiter">(</span><span title="(elems: String*)Seq[String]">Seq</span><span class="delimiter">(</span><a href="#play.api.data;Form.bindFromRequest(e945bc6ab6).$anonfun.x$3" title="String">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="keyword">case</span> _ =&gt; <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[String,Seq[String]]" class="delimiter">[</span><span title="String">String</span>, <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span>
      <span class="delimiter">}</span><span class="delimiter">)</span> <span title="(xs: scala.collection.GenTraversableOnce[(String, Seq[String])])scala.collection.immutable.Map[String,Seq[String]]">++</span> <a href="#play.api.data;Form.bindFromRequest(e945bc6ab6).request" title="play.api.mvc.Request[_]">request</a>.<a href="../mvc/Http.scala.html#play.api.mvc;RequestHeader.queryString" title="=&gt; Map[String,Seq[String]]">queryString</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(data: Map[String,Seq[String]])play.api.data.Form[T]" id="play.api.data;Form.bindFromRequest(7cae208c55)">bindFromRequest</a><span class="delimiter">(</span><a title="Map[String,Seq[String]]" id="play.api.data;Form.bindFromRequest(7cae208c55).data">data</a>: <span title="Map[String,Seq[String]]">Map</span><span class="delimiter">[</span>String, Seq<span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#play.api.data;Form" title="play.api.data.Form[T]">Form</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data;Form.bind(5a82085d3b)" title="(data: Map[String,String])play.api.data.Form[T]">bind</a> <span class="delimiter">{</span>
      <a href="#play.api.data;Form.bindFromRequest(7cae208c55).data" title="Map[String,Seq[String]]">data</a>.<span title="(z: scala.collection.immutable.Map[String,String])(op: (scala.collection.immutable.Map[String,String], (String, Seq[String])) =&gt; scala.collection.immutable.Map[String,String])scala.collection.immutable.Map[String,String]">foldLeft</span><span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[String,String]" class="delimiter">[</span><span title="String">String</span>, <span title="String">String</span><span class="delimiter">]</span><span class="delimiter">)</span> <a href="#play.api.data;Form.bindFromRequest(7cae208c55).$anonfun.x0$1" title="scala.collection.immutable.Map[String,String]" class="delimiter">{</a>
        <span class="keyword">case</span> <span class="delimiter">(</span><span title="scala.collection.immutable.Map[String,String]">s</span>, <span class="delimiter">(</span><span title="String">key</span>, <span title="Seq[String]">values</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="keyword">if</span> <span title="String">key</span>.<span title="(x$1: String)Boolean">endsWith</span><span class="delimiter">(</span><span title="String(&quot;[]&quot;)" class="string">&quot;[]&quot;</span><span class="delimiter">)</span> =&gt; <span title="scala.collection.immutable.Map[String,String]">s</span> <span title="(xs: scala.collection.GenTraversableOnce[(String, String)])scala.collection.immutable.Map[String,String]">++</span> <span title="Seq[String]">values</span>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[Seq[String],(String, Int),Seq[(String, Int)]])Seq[(String, Int)]">zipWithIndex</span>.<span title="(f: ((String, Int)) =&gt; (String, String))(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, Int)],(String, String),Seq[(String, String)]])Seq[(String, String)]">map</span> <a href="#play.api.data;Form.bindFromRequest(7cae208c55).$anonfun.$anonfun.x0$2" title="(String, String)" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="play.api.data;Form.bindFromRequest(7cae208c55).$anonfun.$anonfun.v">v</a>, <a title="Int" id="play.api.data;Form.bindFromRequest(7cae208c55).$anonfun.$anonfun.i">i</a><span class="delimiter">)</span> =&gt; <span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">key</span>.<span title="(n: Int)String">dropRight</span><span class="delimiter">(</span><span title="Int(2)" class="int">2</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#play.api.data;Form.bindFromRequest(7cae208c55).$anonfun.$anonfun.i" title="Int">i</a> <span title="(x: String)ArrowAssoc[String]">+</span> <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span> <span title="(y: String)(String, String)">-&gt;</span> <a href="#play.api.data;Form.bindFromRequest(7cae208c55).$anonfun.$anonfun.v" title="String">v</a> <span class="delimiter">}</span>
        <span class="keyword">case</span> <span class="delimiter">(</span><span title="scala.collection.immutable.Map[String,String]">s</span>, <span class="delimiter">(</span><span title="String">key</span>, <span title="Seq[String]">values</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="scala.collection.immutable.Map[String,String]">s</span> <span title="(kv: (String, String))scala.collection.immutable.Map[String,String]">+</span> <span class="delimiter">(</span><span title="(x: String)ArrowAssoc[String]">key</span> <span title="(y: String)(String, String)">-&gt;</span> <span title="Seq[String]">values</span>.<span title="=&gt; Option[String]">headOption</span>.<span title="(default: =&gt; String)String">getOrElse</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Fills this form with a existing value, used for edit forms.
   *
   * @param value an existing value of type `T`, used to fill this form
   * @return a copy of this form filled with the new data
   */</span>
  <span class="keyword">def</span> <a title="(value: T)play.api.data.Form[T]" id="play.api.data;Form.fill">fill</a><span class="delimiter">(</span><a title="T" id="play.api.data;Form.fill.value">value</a>: <a href="#play.api.data;Form;T" title="T">T</a><span class="delimiter">)</span>: <a href="#play.api.data;Form" title="play.api.data.Form[T]">Form</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Map[String,String]" id="play.api.data;Form.fill.result">result</a> = <a href="#play.api.data;Form.mapping" title="=&gt; play.api.data.Mapping[T]">mapping</a>.<a href="#play.api.data;Mapping.unbind" title="(value: T)Map[String,String]">unbind</a><span class="delimiter">(</span><a href="#play.api.data;Form.fill.value" title="T">value</a><span class="delimiter">)</span>
    <a href="#play.api.data;Form" title="Form.this.type" class="keyword">this</a>.<a href="#play.api.data;Form.mapping" title="play.api.data.Mapping[T] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.fill.x$52">copy</a><span class="delimiter">(</span>data = <a href="#play.api.data;Form.fill.result" title="Map[String,String] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.fill.x$49">result</a>, value = <span title="(x: T)Some[T]">Some</span><a title="Some[T] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.fill.x$50" class="delimiter">(</a><a href="#play.api.data;Form.fill.value" title="T">value</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Fills this form with a existing value, and performs a validation.
   *
   * @param value an existing value of type `T`, used to fill this form
   * @return a copy of this form filled with the new data
   */</span>
  <span class="keyword">def</span> <a title="(value: T)play.api.data.Form[T]" id="play.api.data;Form.fillAndValidate">fillAndValidate</a><span class="delimiter">(</span><a title="T" id="play.api.data;Form.fillAndValidate.value">value</a>: <a href="#play.api.data;Form;T" title="T">T</a><span class="delimiter">)</span>: <a href="#play.api.data;Form" title="play.api.data.Form[T]">Form</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="(Map[String,String], Seq[play.api.data.FormError])" id="play.api.data;Form.fillAndValidate.result">result</a> = <a href="#play.api.data;Form.mapping" title="=&gt; play.api.data.Mapping[T]">mapping</a>.<a href="#play.api.data;Mapping.unbindAndValidate" title="(value: T)(Map[String,String], Seq[play.api.data.FormError])">unbindAndValidate</a><span class="delimiter">(</span><a href="#play.api.data;Form.fillAndValidate.value" title="T">value</a><span class="delimiter">)</span>
    <a href="#play.api.data;Form" title="Form.this.type" class="keyword">this</a>.<a href="#play.api.data;Form.mapping" title="play.api.data.Mapping[T] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.fillAndValidate.x$56">copy</a><span class="delimiter">(</span>data = <a href="#play.api.data;Form.fillAndValidate.result" title="(Map[String,String], Seq[play.api.data.FormError])">result</a>.<a title="Map[String,String] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.fillAndValidate.x$53">_1</a>, errors = <a href="#play.api.data;Form.fillAndValidate.result" title="(Map[String,String], Seq[play.api.data.FormError])">result</a>.<a title="Seq[play.api.data.FormError] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.fillAndValidate.x$54">_2</a>, value = <span title="(x: T)Some[T]">Some</span><a title="Some[T] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.fillAndValidate.x$55" class="delimiter">(</a><a href="#play.api.data;Form.fillAndValidate.value" title="T">value</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Handles form results. Either the form has errors, or the submission was a success and a
   * concrete value is available.
   *
   * For example:
   * {{{
   *   anyForm.bindFromRequest().fold(
   *      f =&gt; redisplayForm(f),
   *      t =&gt; handleValidFormSubmission(t)
   *   )
   * }}}
   *
   * @tparam R common result type
   * @param hasErrors a function to handle forms with errors
   * @param success a function to handle form submission success
   * @return a result `R`.
   */</span>
  <span class="keyword">def</span> <a title="[R](hasErrors: play.api.data.Form[T] =&gt; R, success: T =&gt; R)R" id="play.api.data;Form.fold">fold</a><span class="delimiter">[</span><a title="" id="play.api.data;Form.fold;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="play.api.data.Form[T] =&gt; R" id="play.api.data;Form.fold.hasErrors">hasErrors</a>: Form<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; R, <a title="T =&gt; R" id="play.api.data;Form.fold.success">success</a>: T =&gt; R<span class="delimiter">)</span>: <a href="#play.api.data;Form.fold;R" title="R">R</a> = <a href="#play.api.data;Form.value" title="=&gt; Option[T]">value</a> <span title="R" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="T" id="play.api.data;Form.fold.v">v</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#play.api.data;Form.errors" title="=&gt; Seq[play.api.data.FormError]">errors</a>.<span title="=&gt; Boolean">isEmpty</span> =&gt; <a href="#play.api.data;Form.fold.success" title="(v1: T)R">success</a><span class="delimiter">(</span><a href="#play.api.data;Form.fold.v" title="T">v</a><span class="delimiter">)</span>
    <span class="keyword">case</span> _ =&gt; <a href="#play.api.data;Form.fold.hasErrors" title="(v1: play.api.data.Form[T])R">hasErrors</a><span class="delimiter">(</span><a href="#play.api.data;Form" title="play.api.data.Form[T]" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Retrieves a field.
   *
   * For example:
   * {{{
   * val usernameField = userForm(&quot;username&quot;)
   * }}}
   *
   * @param key the field name
   * @return the field, returned even if the field does not exist
   */</span>
  <span class="keyword">def</span> <a title="(key: String)play.api.data.Field" id="play.api.data;Form.apply">apply</a><span class="delimiter">(</span><a title="String" id="play.api.data;Form.apply.key">key</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#play.api.data.Field.readResolve" title="play.api.data.Field">Field</a> = <a href="#play.api.data.Field.readResolve" title="(form: play.api.data.Form[_], name: String, constraints: Seq[(String, Seq[Any])], format: Option[(String, Seq[Any])], errors: Seq[play.api.data.FormError], value: Option[String])play.api.data.Field">Field</a><span class="delimiter">(</span>
    <a href="#play.api.data;Form" title="play.api.data.Form[T]" class="keyword">this</a>,
    <a href="#play.api.data;Form.apply.key" title="String">key</a>,
    <a href="#play.api.data;Form.constraints" title="=&gt; Map[String,Seq[(String, Seq[Any])]]">constraints</a>.<span title="(key: String)Option[Seq[(String, Seq[Any])]]">get</span><span class="delimiter">(</span><a href="#play.api.data;Form.apply.key" title="String">key</a><span class="delimiter">)</span>.<span title="(default: =&gt; Seq[(String, Seq[Any])])Seq[(String, Seq[Any])]">getOrElse</span><span class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>,
    <a href="#play.api.data;Form.formats" title="=&gt; Map[String,(String, Seq[Any])]">formats</a>.<span title="(key: String)Option[(String, Seq[Any])]">get</span><span class="delimiter">(</span><a href="#play.api.data;Form.apply.key" title="String">key</a><span class="delimiter">)</span>,
    <a href="#play.api.data;Form.errors" title="=&gt; Seq[play.api.data.FormError]">errors</a>.<span title="(pf: PartialFunction[play.api.data.FormError,play.api.data.FormError])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[play.api.data.FormError],play.api.data.FormError,Seq[play.api.data.FormError]])Seq[play.api.data.FormError]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[play.api.data.FormError,play.api.data.FormError] with Serializable" id="play.api.data;Form.apply;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> <span class="keyword">case</span> <a title="play.api.data.FormError" id="play.api.data;Form.apply;$anonfun.isDefinedAt.e">e</a> <span class="keyword">if</span> <a href="#play.api.data;Form.apply;$anonfun.isDefinedAt.e" title="play.api.data.FormError">e</a>.<a href="#play.api.data;FormError.key" title="=&gt; String">key</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.data;Form.apply.key" title="String">key</a> =&gt; <a href="#play.api.data;Form.apply;$anonfun.isDefinedAt.e" title="play.api.data.FormError">e</a> <span class="delimiter">}</span>,
    <a href="#play.api.data;Form.data" title="=&gt; Map[String,String]">data</a>.<span title="(key: String)Option[String]">get</span><span class="delimiter">(</span><a href="#play.api.data;Form.apply.key" title="String">key</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Retrieves the first global error, if it exists, i.e. an error without any key.
   *
   * @return an error
   */</span>
  <span class="keyword">def</span> <a title="=&gt; Option[play.api.data.FormError]" id="play.api.data;Form.globalError">globalError</a>: <span title="Option[play.api.data.FormError]">Option</span><span class="delimiter">[</span>FormError<span class="delimiter">]</span> = <a href="#play.api.data;Form.globalErrors" title="=&gt; Seq[play.api.data.FormError]">globalErrors</a>.<span title="=&gt; Option[play.api.data.FormError]">headOption</span>

  <span class="comment">/**
   * Retrieves all global errors, i.e. errors without a key.
   *
   * @return all global errors
   */</span>
  <span class="keyword">def</span> <a title="=&gt; Seq[play.api.data.FormError]" id="play.api.data;Form.globalErrors">globalErrors</a>: <span title="Seq[play.api.data.FormError]">Seq</span><span class="delimiter">[</span>FormError<span class="delimiter">]</span> = <a href="#play.api.data;Form.errors" title="=&gt; Seq[play.api.data.FormError]">errors</a>.<span title="(p: play.api.data.FormError =&gt; Boolean)Seq[play.api.data.FormError]">filter</span><span class="delimiter">(</span><a href="#play.api.data;Form.globalErrors.$anonfun.x$4" title="play.api.data.FormError">_</a>.<a href="#play.api.data;FormError.key" title="=&gt; String">key</a>.<span title="()Boolean">isEmpty</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Applies a function for a field.
   *
   * For example:
   * {{{
   * userForm.forField(&quot;username&quot;) { field =&gt;
   *   &lt;input type=&quot;text&quot; name={field.name} value={field.value.getOrElse(&quot;&quot;)} /&gt;
   * }
   * }}}
   *
   * @tparam R result type
   * @param key field name
   * @param handler field handler (transform the field to `R`)
   */</span>
  <span class="keyword">def</span> <a title="[R](key: String)(handler: play.api.data.Field =&gt; R)R" id="play.api.data;Form.forField">forField</a><span class="delimiter">[</span><a title="" id="play.api.data;Form.forField;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="String" id="play.api.data;Form.forField.key">key</a>: <span title="String">String</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="play.api.data.Field =&gt; R" id="play.api.data;Form.forField.handler">handler</a>: Field =&gt; R<span class="delimiter">)</span>: <a href="#play.api.data;Form.forField;R" title="R">R</a> = <a href="#play.api.data;Form.forField.handler" title="(v1: play.api.data.Field)R">handler</a><span class="delimiter">(</span><a href="#play.api.data;Form.apply" title="(key: String)play.api.data.Field" class="keyword">this</a><span class="delimiter">(</span><a href="#play.api.data;Form.forField.key" title="String">key</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns `true` if there is an error related to this form.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; Boolean" id="play.api.data;Form.hasErrors">hasErrors</a>: <span title="Boolean">Boolean</span> = <span title="=&gt; Boolean">!</span><a href="#play.api.data;Form.errors" title="=&gt; Seq[play.api.data.FormError]">errors</a>.<span title="=&gt; Boolean">isEmpty</span>

  <span class="comment">/**
   * Retrieve the first error for this key.
   *
   * @param key field name.
   */</span>
  <span class="keyword">def</span> <a title="(key: String)Option[play.api.data.FormError]" id="play.api.data;Form.error">error</a><span class="delimiter">(</span><a title="String" id="play.api.data;Form.error.key">key</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Option[play.api.data.FormError]">Option</span><span class="delimiter">[</span>FormError<span class="delimiter">]</span> = <a href="#play.api.data;Form.errors" title="=&gt; Seq[play.api.data.FormError]">errors</a>.<span title="(p: play.api.data.FormError =&gt; Boolean)Option[play.api.data.FormError]">find</span><span class="delimiter">(</span><a href="#play.api.data;Form.error.$anonfun.x$5" title="play.api.data.FormError">_</a>.<a href="#play.api.data;FormError.key" title="=&gt; String">key</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.data;Form.error.key" title="String">key</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Retrieve all errors for this key.
   *
   * @param key field name.
   */</span>
  <span class="keyword">def</span> <a title="(key: String)Seq[play.api.data.FormError]" id="play.api.data;Form.errors(122d0d8806)">errors</a><span class="delimiter">(</span><a title="String" id="play.api.data;Form.errors(122d0d8806).key">key</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Seq[play.api.data.FormError]">Seq</span><span class="delimiter">[</span>FormError<span class="delimiter">]</span> = <a href="#play.api.data;Form.errors" title="=&gt; Seq[play.api.data.FormError]">errors</a>.<span title="(p: play.api.data.FormError =&gt; Boolean)Seq[play.api.data.FormError]">filter</span><span class="delimiter">(</span><a href="#play.api.data;Form.errors(122d0d8806).$anonfun.x$6" title="play.api.data.FormError">_</a>.<a href="#play.api.data;FormError.key" title="=&gt; String">key</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.data;Form.errors(122d0d8806).key" title="String">key</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns `true` if there is a global error related to this form.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; Boolean" id="play.api.data;Form.hasGlobalErrors">hasGlobalErrors</a>: <span title="Boolean">Boolean</span> = <span title="=&gt; Boolean">!</span><a href="#play.api.data;Form.globalErrors" title="=&gt; Seq[play.api.data.FormError]">globalErrors</a>.<span title="=&gt; Boolean">isEmpty</span>

  <span class="comment">/**
   * Returns the concrete value, if the submission was a success.
   *
   * Note that this method fails with an Exception if this form as errors.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; T" id="play.api.data;Form.get">get</a>: <a href="#play.api.data;Form;T" title="T">T</a> = <a href="#play.api.data;Form.value" title="=&gt; Option[T]">value</a>.<span title="=&gt; T">get</span>

  <span class="comment">/**
   * Returns the form errors serialized as Json.
   */</span>
  <span class="keyword">def</span> <a title="(implicit lang: play.api.i18n.Messages)play.api.libs.json.JsValue" id="play.api.data;Form.errorsAsJson">errorsAsJson</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="play.api.i18n.Messages" id="play.api.data;Form.errorsAsJson.lang">lang</a>: play.api.i18n.<a href="../i18n/Messages.scala.html#play.api.i18n;Messages" title="play.api.i18n.Messages">Messages</a><span class="delimiter">)</span>: play.api.libs.json.<a href="../../../../play-json/play/api/libs/json/JsValue.scala.html#play.api.libs.json;JsValue" title="play.api.libs.json.JsValue">JsValue</a> = <span class="delimiter">{</span>

    <span class="keyword">import</span> play.api.libs.json._

    <a href="../../../../play-json/play/api/libs/json/Json.scala.html#play.api.libs.json.Json" title="play.api.libs.json.Json.type">Json</a>.<a href="../../../../play-json/play/api/libs/json/Json.scala.html#play.api.libs.json.Json.toJson(09a84969e8)" title="(o: scala.collection.immutable.Map[String,Seq[String]])(implicit tjs: play.api.libs.json.Writes[scala.collection.immutable.Map[String,Seq[String]]])play.api.libs.json.JsValue">toJson</a><a href="../../../../play-json/play/api/libs/json/Writes.scala.html#play.api.libs.json;DefaultWrites.mapWrites" title="(implicit fmtv: play.api.libs.json.Writes[Seq[String]])play.api.libs.json.OWrites[scala.collection.immutable.Map[String,Seq[String]]]" class="delimiter">(</a>
      <a href="#play.api.data;Form.errors" title="=&gt; Seq[play.api.data.FormError]">errors</a>.<span title="(f: play.api.data.FormError =&gt; String)scala.collection.immutable.Map[String,Seq[play.api.data.FormError]]">groupBy</span><span class="delimiter">(</span><a href="#play.api.data;Form.errorsAsJson.$anonfun.x$7" title="play.api.data.FormError">_</a>.<a href="#play.api.data;FormError.key" title="=&gt; String">key</a><span class="delimiter">)</span>.<span title="(f: Seq[play.api.data.FormError] =&gt; Seq[String])scala.collection.immutable.Map[String,Seq[String]]">mapValues</span> <span class="delimiter">{</span> <a title="Seq[play.api.data.FormError]" id="play.api.data;Form.errorsAsJson.$anonfun.errors">errors</a> =&gt;
        <a href="#play.api.data;Form.errorsAsJson.$anonfun.errors" title="Seq[play.api.data.FormError]">errors</a>.<span title="(f: play.api.data.FormError =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[play.api.data.FormError],String,Seq[String]])Seq[String]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,String,Seq[String]]" class="delimiter">(</span><a title="play.api.data.FormError" id="play.api.data;Form.errorsAsJson.$anonfun.$anonfun.e">e</a> =&gt; play.api.i18n.<a href="../i18n/Messages.scala.html#play.api.i18n.Messages.apply(03d9aa3489)" title="(key: String, args: Any*)(implicit messages: play.api.i18n.Messages)String">Messages</a><a href="#play.api.data;Form.errorsAsJson.lang" title="play.api.i18n.Messages" class="delimiter">(</a><a href="#play.api.data;Form.errorsAsJson.$anonfun.$anonfun.e" title="play.api.data.FormError">e</a>.<a href="#play.api.data;FormError.message" title="=&gt; String">message</a>, <a href="#play.api.data;Form.errorsAsJson.$anonfun.$anonfun.e" title="play.api.data.FormError">e</a>.<a href="#play.api.data.FormError.<init>$default$3" title="=&gt; Seq[Any]">args</a>: _*<span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">)</span>

  <span class="delimiter">}</span>

  <span class="comment">/**
   * Adds an error to this form
   * @param error Error to add
   * @return a copy of this form with the added error
   */</span>
  <span class="keyword">def</span> <a title="(error: play.api.data.FormError)play.api.data.Form[T]" id="play.api.data;Form.withError(97ea3202ed)">withError</a><span class="delimiter">(</span><a title="play.api.data.FormError" id="play.api.data;Form.withError(97ea3202ed).error">error</a>: <a href="#play.api.data;FormError" title="play.api.data.FormError">FormError</a><span class="delimiter">)</span>: <a href="#play.api.data;Form" title="play.api.data.Form[T]">Form</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#play.api.data;Form" title="Form.this.type" class="keyword">this</a>.<a href="#play.api.data;Form.mapping" title="play.api.data.Mapping[T] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.withError(97ea3202ed).x$60">copy</a><span class="delimiter">(</span>errors = <a href="#play.api.data;Form.errors" title="=&gt; Seq[play.api.data.FormError]">errors</a> <a title="Seq[play.api.data.FormError] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.withError(97ea3202ed).x$57">:+</a> <a href="#play.api.data;Form.withError(97ea3202ed).error" title="play.api.data.FormError">error</a>, value = <a title="None.type" id="play.api.data;Form.withError(97ea3202ed).x$58">None</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Convenient overloaded method adding an error to this form
   * @param key Key of the field having the error
   * @param message Error message
   * @param args Error message arguments
   * @return a copy of this form with the added error
   */</span>
  <span class="keyword">def</span> <a title="(key: String, message: String, args: Any*)play.api.data.Form[T]" id="play.api.data;Form.withError(cbec68ff9b)">withError</a><span class="delimiter">(</span><a title="String" id="play.api.data;Form.withError(cbec68ff9b).key">key</a>: <span title="String">String</span>, <a title="String" id="play.api.data;Form.withError(cbec68ff9b).message">message</a>: <span title="String">String</span>, <a title="Any*" id="play.api.data;Form.withError(cbec68ff9b).args">args</a>: <span title="Any*">Any</span>*<span class="delimiter">)</span>: <a href="#play.api.data;Form" title="play.api.data.Form[T]">Form</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#play.api.data;Form.withError(97ea3202ed)" title="(error: play.api.data.FormError)play.api.data.Form[T]">withError</a><span class="delimiter">(</span><a href="#play.api.data.FormError.apply(0ac8408758)" title="(key: String, message: String, args: Seq[Any])play.api.data.FormError">FormError</a><span class="delimiter">(</span><a href="#play.api.data;Form.withError(cbec68ff9b).key" title="String">key</a>, <a href="#play.api.data;Form.withError(cbec68ff9b).message" title="String">message</a>, <a href="#play.api.data;Form.withError(cbec68ff9b).args" title="Any*">args</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Adds a global error to this form
   * @param message Error message
   * @param args Error message arguments
   * @return a copy of this form with the added global error
   */</span>
  <span class="keyword">def</span> <a title="(message: String, args: Any*)play.api.data.Form[T]" id="play.api.data;Form.withGlobalError">withGlobalError</a><span class="delimiter">(</span><a title="String" id="play.api.data;Form.withGlobalError.message">message</a>: <span title="String">String</span>, <a title="Any*" id="play.api.data;Form.withGlobalError.args">args</a>: <span title="Any*">Any</span>*<span class="delimiter">)</span>: <a href="#play.api.data;Form" title="play.api.data.Form[T]">Form</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#play.api.data;Form.withError(97ea3202ed)" title="(error: play.api.data.FormError)play.api.data.Form[T]">withError</a><span class="delimiter">(</span><a href="#play.api.data.FormError.apply(0ac8408758)" title="(key: String, message: String, args: Seq[Any])play.api.data.FormError">FormError</a><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <a href="#play.api.data;Form.withGlobalError.message" title="String">message</a>, <a href="#play.api.data;Form.withGlobalError.args" title="Any*">args</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Discards this form’s errors
   * @return a copy of this form without errors
   */</span>
  <span class="keyword">def</span> <a title="=&gt; play.api.data.Form[T]" id="play.api.data;Form.discardingErrors">discardingErrors</a>: <a href="#play.api.data;Form" title="play.api.data.Form[T]">Form</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#play.api.data;Form" title="Form.this.type" class="keyword">this</a>.<a href="#play.api.data;Form.mapping" title="play.api.data.Mapping[T] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.discardingErrors.x$64">copy</a><span class="delimiter">(</span>errors = <span title="scala.collection.Seq.type">Seq</span>.<a title="Seq[Nothing] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;Form.discardingErrors.x$61">empty</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * A form field.
 *
 * @param name the field name
 * @param constraints the constraints associated with the field
 * @param format the format expected for this field
 * @param errors the errors associated to this field
 * @param value the field value, if any
 */</span>
<span class="keyword">case class</span> <a title="class Field extends AnyRef with Product with Serializable" id="play.api.data.Field.readResolve">Field</a><a href="#play.api.data.Field.readResolve" title="Product" class="delimiter">(</a><span class="keyword">private</span> <span class="keyword">val</span> <a title="play.api.data.Form[_]" id="play.api.data;Field.form">form</a>: <a href="#play.api.data;Form" title="play.api.data.Form[_]">Form</a><span class="delimiter">[</span>_<span class="delimiter">]</span>, <a title="String" id="play.api.data;Field.name">name</a>: <span title="String">String</span>, <a title="Seq[(String, Seq[Any])]" id="play.api.data;Field.constraints">constraints</a>: <span title="Seq[(String, Seq[Any])]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Seq<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>, <a title="Option[(String, Seq[Any])]" id="play.api.data;Field.format">format</a>: <span title="Option[(String, Seq[Any])]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Seq<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>, <a title="Seq[play.api.data.FormError]" id="play.api.data;Field.errors">errors</a>: <span title="Seq[play.api.data.FormError]">Seq</span><span class="delimiter">[</span>FormError<span class="delimiter">]</span>, <a title="Option[String]" id="play.api.data;Field.value">value</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

  <span class="comment">/**
   * The field ID - the same as the field name but with '.' replaced by '_'.
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="String" id="play.api.data;Field.id">id</a>: <span title="String">String</span> = <a href="#play.api.data;Field.name" title="=&gt; String">name</a>.<span title="(x$1: Char, x$2: Char)String">replace</span><span class="delimiter">(</span><span title="Char('.')" class="char">'.'</span>, <span title="Char('_')" class="char">'_'</span><span class="delimiter">)</span>.<span title="(x$1: Char, x$2: Char)String">replace</span><span class="delimiter">(</span><span title="Char('[')" class="char">'['</span>, <span title="Char('_')" class="char">'_'</span><span class="delimiter">)</span>.<span title="(x$1: CharSequence, x$2: CharSequence)String">replace</span><span class="delimiter">(</span><span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span>, <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Returns the first error associated with this field, if it exists.
   *
   * @return an error
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Option[play.api.data.FormError]" id="play.api.data;Field.error">error</a>: <span title="Option[play.api.data.FormError]">Option</span><span class="delimiter">[</span>FormError<span class="delimiter">]</span> = <a href="#play.api.data;Field.errors" title="=&gt; Seq[play.api.data.FormError]">errors</a>.<span title="=&gt; Option[play.api.data.FormError]">headOption</span>

  <span class="comment">/**
   * Check if this field has errors.
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Boolean" id="play.api.data;Field.hasErrors">hasErrors</a>: <span title="Boolean">Boolean</span> = <span title="=&gt; Boolean">!</span><a href="#play.api.data;Field.errors" title="=&gt; Seq[play.api.data.FormError]">errors</a>.<span title="=&gt; Boolean">isEmpty</span>

  <span class="comment">/**
   * Retrieve a field from the same form, using a key relative to this field key.
   *
   * @param key Relative key.
   */</span>
  <span class="keyword">def</span> <a title="(key: String)play.api.data.Field" id="play.api.data;Field.apply">apply</a><span class="delimiter">(</span><a title="String" id="play.api.data;Field.apply.key">key</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#play.api.data.Field.readResolve" title="play.api.data.Field">Field</a> = <span class="delimiter">{</span>
    <a href="#play.api.data;Form.apply" title="(key: String)play.api.data.Field">form</a><span class="delimiter">(</span><span title="(x: String)Option[String]">Option</span><span class="delimiter">(</span><a href="#play.api.data;Field.name" title="=&gt; String">name</a><span class="delimiter">)</span>.<span title="(p: String =&gt; Boolean)Option[String]">filterNot</span><span class="delimiter">(</span><a href="#play.api.data;Field.apply.$anonfun.x$8" title="String">_</a>.<span title="()Boolean">isEmpty</span><span class="delimiter">)</span>.<span title="(f: String =&gt; String)Option[String]">map</span><span class="delimiter">(</span><a href="#play.api.data;Field.apply.$anonfun.x$9" title="String">_</a> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.data;Field.apply.key" title="(index: Int)Char">key</a><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span title="(x: Char)Boolean">==</span> <span title="Char('[')" class="char">'['</span><span class="delimiter">)</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span> <span class="keyword">else</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(default: =&gt; String)String">getOrElse</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#play.api.data;Field.apply.key" title="String">key</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Retrieve available indexes defined for this field (if this field is repeated).
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Seq[Int]" id="play.api.data;Field.indexes">indexes</a>: <span title="Seq[Int]">Seq</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data.RepeatedMapping.readResolve" title="play.api.data.RepeatedMapping.type">RepeatedMapping</a>.<a href="#play.api.data.RepeatedMapping.indexes" title="(key: String, data: Map[String,String])Seq[Int]">indexes</a><span class="delimiter">(</span><a href="#play.api.data;Field.name" title="=&gt; String">name</a>, <a href="#play.api.data;Field.form" title="=&gt; play.api.data.Form[_]">form</a>.<a href="#play.api.data;Form.data" title="=&gt; Map[String,String]">data</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * The label for the field.  Transforms repeat names from foo[0] etc to foo.0.
   */</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="String" id="play.api.data;Field.label">label</a>: <span title="String">String</span> = <a href="#play.api.data;Field.name" title="=&gt; String">name</a>.<span title="(x$1: String, x$2: String)String">replaceAll</span><span class="delimiter">(</span><span title="String(&quot;\\[(\\d+)\\]&quot;)" class="string">&quot;\\[(\\d+)\\]&quot;</span>, <span title="String(&quot;.$1&quot;)" class="string">&quot;.$1&quot;</span><span class="delimiter">)</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * Provides a set of operations for creating `Form` values.
 */</span>
<span class="keyword">object</span> <a title="play.api.data.Form.type" id="play.api.data.Form.readResolve">Form</a> <a href="#play.api.data.Form.readResolve" title="play.api.data.Form.type" class="delimiter">{</a>

  <span class="comment">/**
   * Creates a new form from a mapping.
   *
   * For example:
   * {{{
   * import play.api.data._
   * import play.api.data.Forms._
   * import play.api.data.format.Formats._
   *
   * val userForm = Form(
   *   tuple(
   *     &quot;name&quot; -&gt; of[String],
   *     &quot;age&quot; -&gt; of[Int],
   *     &quot;email&quot; -&gt; of[String]
   *   )
   * )
   * }}}
   *
   * @param mapping the form mapping
   * @return a form definition
   */</span>
  <span class="keyword">def</span> <a title="[T](mapping: play.api.data.Mapping[T])play.api.data.Form[T]" id="play.api.data.Form.apply(d39f7bec1d)">apply</a><span class="delimiter">[</span><a title="" id="play.api.data.Form.apply(d39f7bec1d);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="play.api.data.Mapping[T]" id="play.api.data.Form.apply(d39f7bec1d).mapping">mapping</a>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[T]">Mapping</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#play.api.data;Form" title="play.api.data.Form[T]">Form</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#play.api.data;Form" title="(mapping: play.api.data.Mapping[T], data: Map[String,String], errors: Seq[play.api.data.FormError], value: Option[T])play.api.data.Form[T]">Form</a><span class="delimiter">(</span><a href="#play.api.data.Form.apply(d39f7bec1d).mapping" title="play.api.data.Mapping[T]">mapping</a>, <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[String,Nothing]">empty</span>, <span title="scala.collection.immutable.Nil.type">Nil</span>, <span title="None.type">None</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Creates a new form from a mapping, with a root key.
   *
   * For example:
   * {{{
   * import play.api.data._
   * import play.api.data.Forms._
   * import play.api.data.format.Formats._
   *
   * val userForm = Form(
   *   &quot;user&quot; -&gt; tuple(
   *     &quot;name&quot; -&gt; of[String],
   *     &quot;age&quot; -&gt; of[Int],
   *     &quot;email&quot; -&gt; of[String]
   *   )
   * )
   * }}}
   *
   * @param mapping the root key, form mapping association
   * @return a form definition
   */</span>
  <span class="keyword">def</span> <a title="[T](mapping: (String, play.api.data.Mapping[T]))play.api.data.Form[T]" id="play.api.data.Form.apply(8e6ba81294)">apply</a><span class="delimiter">[</span><a title="" id="play.api.data.Form.apply(8e6ba81294);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(String, play.api.data.Mapping[T])" id="play.api.data.Form.apply(8e6ba81294).mapping">mapping</a>: <span title="(String, play.api.data.Mapping[T])" class="delimiter">(</span>String, Mapping<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">)</span>: <a href="#play.api.data;Form" title="play.api.data.Form[T]">Form</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#play.api.data;Form" title="(mapping: play.api.data.Mapping[T], data: Map[String,String], errors: Seq[play.api.data.FormError], value: Option[T])play.api.data.Form[T]">Form</a><span class="delimiter">(</span><a href="#play.api.data.Form.apply(8e6ba81294).mapping" title="(String, play.api.data.Mapping[T])">mapping</a>.<span title="=&gt; play.api.data.Mapping[T]">_2</span>.<a href="#play.api.data;Mapping.withPrefix" title="(prefix: String)play.api.data.Mapping[T]">withPrefix</a><span class="delimiter">(</span><a href="#play.api.data.Form.apply(8e6ba81294).mapping" title="(String, play.api.data.Mapping[T])">mapping</a>.<span title="=&gt; String">_1</span><span class="delimiter">)</span>, <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[String,Nothing]">empty</span>, <span title="scala.collection.immutable.Nil.type">Nil</span>, <span title="None.type">None</span><span class="delimiter">)</span>

<span class="delimiter">}</span>

<span title="AnyRef" class="keyword">private</span><span class="delimiter">[</span>data<span class="delimiter">]</span> <span class="keyword">object</span> <a title="play.api.data.FormUtils.type" id="play.api.data.FormUtils">FormUtils</a> <a href="#play.api.data.FormUtils" title="play.api.data.FormUtils.type" class="delimiter">{</a>

  <span class="keyword">import</span> play.api.libs.json._

  <span class="keyword">def</span> <a title="(prefix: String, js: play.api.libs.json.JsValue)Map[String,String]" id="play.api.data.FormUtils.fromJson">fromJson</a><span class="delimiter">(</span><a title="String" id="play.api.data.FormUtils.fromJson$default$1">prefix</a>: <span title="String">String</span> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <a title="play.api.libs.json.JsValue" id="play.api.data.FormUtils.fromJson.js">js</a>: <a href="../../../../play-json/play/api/libs/json/JsValue.scala.html#play.api.libs.json;JsValue" title="play.api.libs.json.JsValue">JsValue</a><span class="delimiter">)</span>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span> = <a href="#play.api.data.FormUtils.fromJson.js" title="play.api.libs.json.JsValue">js</a> <span title="Map[String,String]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> JsObject<span class="delimiter">(</span><a title="scala.collection.Map[String,play.api.libs.json.JsValue]" id="play.api.data.FormUtils.fromJson.fields">fields</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
      <a href="#play.api.data.FormUtils.fromJson.fields" title="scala.collection.Map[String,play.api.libs.json.JsValue]">fields</a>.<span title="(f: ((String, play.api.libs.json.JsValue)) =&gt; Map[String,String])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.Map[String,play.api.libs.json.JsValue],Map[String,String],Iterable[Map[String,String]]])Iterable[Map[String,String]]">map</span> <a href="#play.api.data.FormUtils.fromJson.$anonfun.x0$3" title="Map[String,String]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="play.api.data.FormUtils.fromJson.$anonfun.key">key</a>, <span title="play.api.libs.json.JsValue">value</span><span class="delimiter">)</span> =&gt; <a href="#play.api.data.FormUtils.fromJson" title="(prefix: String, js: play.api.libs.json.JsValue)Map[String,String]">fromJson</a><span class="delimiter">(</span><span title="(x: String)Option[String]">Option</span><span class="delimiter">(</span><a href="#play.api.data.FormUtils.fromJson$default$1" title="String">prefix</a><span class="delimiter">)</span>.<span title="(p: String =&gt; Boolean)Option[String]">filterNot</span><span class="delimiter">(</span><a href="#play.api.data.FormUtils.fromJson.$anonfun.$anonfun.x$10" title="String">_</a>.<span title="()Boolean">isEmpty</span><span class="delimiter">)</span>.<span title="(f: String =&gt; String)Option[String]">map</span><span class="delimiter">(</span><a href="#play.api.data.FormUtils.fromJson.$anonfun.$anonfun.x$11" title="String">_</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span><span class="delimiter">)</span>.<span title="(default: =&gt; String)String">getOrElse</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <a href="#play.api.data.FormUtils.fromJson.$anonfun.key" title="String">key</a>, <span title="play.api.libs.json.JsValue">value</span><span class="delimiter">)</span> <span class="delimiter">}</span>.<span title="(z: scala.collection.immutable.Map[String,String])(op: (scala.collection.immutable.Map[String,String], Map[String,String]) =&gt; scala.collection.immutable.Map[String,String])scala.collection.immutable.Map[String,String]">foldLeft</span><span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[String,String]" class="delimiter">[</span><span title="String">String</span>, <span title="String">String</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#play.api.data.FormUtils.fromJson.$anonfun.x$12" title="scala.collection.immutable.Map[String,String]">_</a> <span title="(xs: scala.collection.GenTraversableOnce[(String, String)])scala.collection.immutable.Map[String,String]">++</span> <a href="#play.api.data.FormUtils.fromJson.$anonfun.x$13" title="Map[String,String]">_</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">case</span> JsArray<span class="delimiter">(</span><a title="Seq[play.api.libs.json.JsValue]" id="play.api.data.FormUtils.fromJson.values">values</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
      <a href="#play.api.data.FormUtils.fromJson.values" title="Seq[play.api.libs.json.JsValue]">values</a>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[Seq[play.api.libs.json.JsValue],(play.api.libs.json.JsValue, Int),Seq[(play.api.libs.json.JsValue, Int)]])Seq[(play.api.libs.json.JsValue, Int)]">zipWithIndex</span>.<span title="(f: ((play.api.libs.json.JsValue, Int)) =&gt; Map[String,String])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(play.api.libs.json.JsValue, Int)],Map[String,String],Seq[Map[String,String]]])Seq[Map[String,String]]">map</span> <a href="#play.api.data.FormUtils.fromJson.$anonfun.x0$4" title="Map[String,String]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><span title="play.api.libs.json.JsValue">value</span>, <a title="Int" id="play.api.data.FormUtils.fromJson.$anonfun.i">i</a><span class="delimiter">)</span> =&gt; <a href="#play.api.data.FormUtils.fromJson" title="(prefix: String, js: play.api.libs.json.JsValue)Map[String,String]">fromJson</a><span class="delimiter">(</span><a href="#play.api.data.FormUtils.fromJson$default$1" title="String">prefix</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#play.api.data.FormUtils.fromJson.$anonfun.i" title="Int">i</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span>, <span title="play.api.libs.json.JsValue">value</span><span class="delimiter">)</span> <span class="delimiter">}</span>.<span title="(z: scala.collection.immutable.Map[String,String])(op: (scala.collection.immutable.Map[String,String], Map[String,String]) =&gt; scala.collection.immutable.Map[String,String])scala.collection.immutable.Map[String,String]">foldLeft</span><span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[String,String]" class="delimiter">[</span><span title="String">String</span>, <span title="String">String</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#play.api.data.FormUtils.fromJson.$anonfun.x$14" title="scala.collection.immutable.Map[String,String]">_</a> <span title="(xs: scala.collection.GenTraversableOnce[(String, String)])scala.collection.immutable.Map[String,String]">++</span> <a href="#play.api.data.FormUtils.fromJson.$anonfun.x$15" title="Map[String,String]">_</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">case</span> <a href="../../../../play-json/play/api/libs/json/JsValue.scala.html#play.api.libs.json.JsNull" title="play.api.libs.json.JsNull.type">JsNull</a> =&gt; <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[String,Nothing]">empty</span>
    <span class="keyword">case</span> <a href="../../../../play-json/play/api/libs/json/JsLookup.scala.html#play.api.libs.json.JsUndefined.unapply" title="(o: Object)Boolean">JsUndefined</a><span class="delimiter">(</span><span class="delimiter">)</span> =&gt; <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[String,Nothing]">empty</span>
    <span class="keyword">case</span> JsBoolean<span class="delimiter">(</span><span title="Boolean">value</span><span class="delimiter">)</span> =&gt; <span title="(elems: (String, String)*)scala.collection.immutable.Map[String,String]">Map</span><span class="delimiter">(</span><a href="#play.api.data.FormUtils.fromJson$default$1" title="(x: String)ArrowAssoc[String]">prefix</a> <span title="(y: String)(String, String)">-&gt;</span> <span title="Boolean">value</span>.<span title="()String">toString</span><span class="delimiter">)</span>
    <span class="keyword">case</span> JsNumber<span class="delimiter">(</span><span title="BigDecimal">value</span><span class="delimiter">)</span> =&gt; <span title="(elems: (String, String)*)scala.collection.immutable.Map[String,String]">Map</span><span class="delimiter">(</span><a href="#play.api.data.FormUtils.fromJson$default$1" title="(x: String)ArrowAssoc[String]">prefix</a> <span title="(y: String)(String, String)">-&gt;</span> <span title="BigDecimal">value</span>.<span title="()String">toString</span><span class="delimiter">)</span>
    <span class="keyword">case</span> JsString<span class="delimiter">(</span><span title="String">value</span><span class="delimiter">)</span> =&gt; <span title="(elems: (String, String)*)scala.collection.immutable.Map[String,String]">Map</span><span class="delimiter">(</span><a href="#play.api.data.FormUtils.fromJson$default$1" title="(x: String)ArrowAssoc[String]">prefix</a> <span title="(y: String)(String, String)">-&gt;</span> <span title="String">value</span>.<span title="()String">toString</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * A form error.
 *
 * @param key The error key (should be associated with a field using the same key).
 * @param message The form message (often a simple message key needing to be translated).
 * @param args Arguments used to format the message.
 */</span>
<span title="AnyRef" class="keyword">case class</span> <a title="class FormError extends AnyRef with Product with Serializable" id="play.api.data;FormError">FormError</a><a href="#play.api.data;FormError" title="Product" class="delimiter">(</a><a title="String" id="play.api.data;FormError.key">key</a>: <span title="String">String</span>, <a title="Seq[String]" id="play.api.data;FormError.messages">messages</a>: <span title="Seq[String]">Seq</span><span class="delimiter">[</span>String<span class="delimiter">]</span>, <a title="Seq[Any]" id="play.api.data.FormError.<init>$default$3">args</a>: <span title="Seq[Any]">Seq</span><span class="delimiter">[</span>Any<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <span class="delimiter">{</span>

  <span class="keyword">def</span> <a title="(key: String, message: String)play.api.data.FormError" id="play.api.data;FormError.<init>(051ff8dfe8)" class="keyword">this</a><span class="delimiter">(</span><a title="String" id="play.api.data;FormError.<init>(051ff8dfe8).key">key</a>: <span title="String">String</span>, <a title="String" id="play.api.data;FormError.<init>(051ff8dfe8).message">message</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#play.api.data;FormError" title="FormError.this.type" class="keyword">this</a><span class="delimiter">(</span><a href="#play.api.data;FormError.<init>(051ff8dfe8).key" title="String">key</a>, <span title="(elems: String*)Seq[String]">Seq</span><span class="delimiter">(</span><a href="#play.api.data;FormError.<init>(051ff8dfe8).message" title="String">message</a><span class="delimiter">)</span>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(key: String, message: String, args: Seq[Any])play.api.data.FormError" id="play.api.data;FormError.<init>(0ac8408758)" class="keyword">this</a><span class="delimiter">(</span><a title="String" id="play.api.data;FormError.<init>(0ac8408758).key">key</a>: <span title="String">String</span>, <a title="String" id="play.api.data;FormError.<init>(0ac8408758).message">message</a>: <span title="String">String</span>, <a title="Seq[Any]" id="play.api.data;FormError.<init>(0ac8408758).args">args</a>: <span title="Seq[Any]">Seq</span><span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#play.api.data;FormError" title="FormError.this.type" class="keyword">this</a><span class="delimiter">(</span><a href="#play.api.data;FormError.<init>(0ac8408758).key" title="String">key</a>, <span title="(elems: String*)Seq[String]">Seq</span><span class="delimiter">(</span><a href="#play.api.data;FormError.<init>(0ac8408758).message" title="String">message</a><span class="delimiter">)</span>, <a href="#play.api.data;FormError.<init>(0ac8408758).args" title="Seq[Any]">args</a><span class="delimiter">)</span>

  <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="String" id="play.api.data;FormError.message">message</a> = <a href="#play.api.data;FormError.messages" title="=&gt; Seq[String]">messages</a>.<span title="=&gt; String">last</span>

  <span class="comment">/**
   * Copy this error with a new Message.
   *
   * @param message The new message.
   */</span>
  <span class="keyword">def</span> <a title="(message: String)play.api.data.FormError" id="play.api.data;FormError.withMessage">withMessage</a><span class="delimiter">(</span><a title="String" id="play.api.data;FormError.withMessage.message">message</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#play.api.data;FormError" title="play.api.data.FormError">FormError</a> = <a href="#play.api.data.FormError.apply(051ff8dfe8)" title="(key: String, message: String)play.api.data.FormError">FormError</a><span class="delimiter">(</span><a href="#play.api.data;FormError.key" title="=&gt; String">key</a>, <a href="#play.api.data;FormError.withMessage.message" title="String">message</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="play.api.data.FormError.type" id="play.api.data.FormError.readResolve">FormError</a> <a href="#play.api.data.FormError.readResolve" title="play.api.data.FormError.type" class="delimiter">{</a>

  <span class="keyword">def</span> <a title="(key: String, message: String)play.api.data.FormError" id="play.api.data.FormError.apply(051ff8dfe8)">apply</a><span class="delimiter">(</span><a title="String" id="play.api.data.FormError.apply(051ff8dfe8).key">key</a>: <span title="String">String</span>, <a title="String" id="play.api.data.FormError.apply(051ff8dfe8).message">message</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#play.api.data;FormError.<init>(051ff8dfe8)" title="(key: String, message: String)play.api.data.FormError" class="keyword">new</a> <a href="#play.api.data;FormError" title="play.api.data.FormError">FormError</a><span class="delimiter">(</span><a href="#play.api.data.FormError.apply(051ff8dfe8).key" title="String">key</a>, <a href="#play.api.data.FormError.apply(051ff8dfe8).message" title="String">message</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(key: String, message: String, args: Seq[Any])play.api.data.FormError" id="play.api.data.FormError.apply(0ac8408758)">apply</a><span class="delimiter">(</span><a title="String" id="play.api.data.FormError.apply(0ac8408758).key">key</a>: <span title="String">String</span>, <a title="String" id="play.api.data.FormError.apply(0ac8408758).message">message</a>: <span title="String">String</span>, <a title="Seq[Any]" id="play.api.data.FormError.apply(0ac8408758).args">args</a>: <span title="Seq[Any]">Seq</span><span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#play.api.data;FormError.<init>(0ac8408758)" title="(key: String, message: String, args: Seq[Any])play.api.data.FormError" class="keyword">new</a> <a href="#play.api.data;FormError" title="play.api.data.FormError">FormError</a><span class="delimiter">(</span><a href="#play.api.data.FormError.apply(0ac8408758).key" title="String">key</a>, <a href="#play.api.data.FormError.apply(0ac8408758).message" title="String">message</a>, <a href="#play.api.data.FormError.apply(0ac8408758).args" title="Seq[Any]">args</a><span class="delimiter">)</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * A mapping is a two-way binder to handle a form field.
 */</span>
<span title="AnyRef" class="keyword">trait</span> <a title="trait Mapping[T] extends AnyRef" id="play.api.data;Mapping">Mapping</a><span class="delimiter">[</span><a title="" id="play.api.data;Mapping;T">T</a><span class="delimiter">]</span> <span title="Unit" class="delimiter">{</span>
  self =&gt;

  <span class="comment">/**
   * The field key.
   */</span>
  <span class="keyword">val</span> <a title="=&gt; String" id="play.api.data;Mapping.key">key</a>: <span title="String">String</span>

  <span class="comment">/**
   * Sub-mappings (these can be seen as sub-keys).
   */</span>
  <span class="keyword">val</span> <a title="=&gt; Seq[play.api.data.Mapping[_]]" id="play.api.data;Mapping.mappings">mappings</a>: <span title="Seq[play.api.data.Mapping[_]]">Seq</span><span class="delimiter">[</span>Mapping<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="comment">/**
   * The Format expected for this field, if it exists.
   */</span>
  <span class="keyword">val</span> <a title="Option[(String, Seq[Any])]" id="play.api.data;Mapping.format">format</a>: <span title="Option[(String, Seq[Any])]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Seq<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <span title="None.type">None</span>

  <span class="comment">/**
   * The constraints associated with this field.
   */</span>
  <span class="keyword">val</span> <a title="=&gt; Seq[play.api.data.validation.Constraint[T]]" id="play.api.data;Mapping.constraints">constraints</a>: <span title="Seq[play.api.data.validation.Constraint[T]]">Seq</span><span class="delimiter">[</span>Constraint<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>

  <span class="comment">/**
   * Binds this field, i.e. construct a concrete value from submitted data.
   *
   * @param data the submitted data
   * @return either a concrete value of type `T` or a set of errors, if the binding failed
   */</span>
  <span class="keyword">def</span> <a title="(data: Map[String,String])Either[Seq[play.api.data.FormError],T]" id="play.api.data;Mapping.bind">bind</a><span class="delimiter">(</span><a title="Map[String,String]" id="play.api.data;Mapping.bind.data">data</a>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Either[Seq[play.api.data.FormError],T]">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span>, T<span class="delimiter">]</span>

  <span class="comment">/**
   * Unbinds this field, i.e. transforms a concrete value to plain data.
   *
   * @param value the value to unbind
   * @return the plain data
   */</span>
  <span class="keyword">def</span> <a title="(value: T)Map[String,String]" id="play.api.data;Mapping.unbind">unbind</a><span class="delimiter">(</span><a title="T" id="play.api.data;Mapping.unbind.value">value</a>: <a href="#play.api.data;Mapping;T" title="T">T</a><span class="delimiter">)</span>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span>

  <span class="comment">/**
   * Unbinds this field, i.e. transforms a concrete value to plain data, and applies validation.
   *
   * @param value the value to unbind
   * @return the plain data and any errors in the plain data
   */</span>
  <span class="keyword">def</span> <a title="(value: T)(Map[String,String], Seq[play.api.data.FormError])" id="play.api.data;Mapping.unbindAndValidate">unbindAndValidate</a><span class="delimiter">(</span><a title="T" id="play.api.data;Mapping.unbindAndValidate.value">value</a>: <a href="#play.api.data;Mapping;T" title="T">T</a><span class="delimiter">)</span>: <span title="(Map[String,String], Seq[play.api.data.FormError])" class="delimiter">(</span>Map<span class="delimiter">[</span>String, String<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Constructs a new Mapping based on this one, adding a prefix to the key.
   *
   * @param prefix the prefix to add to the key
   * @return the same mapping, with only the key changed
   */</span>
  <span class="keyword">def</span> <a title="(prefix: String)play.api.data.Mapping[T]" id="play.api.data;Mapping.withPrefix">withPrefix</a><span class="delimiter">(</span><a title="String" id="play.api.data;Mapping.withPrefix.prefix">prefix</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[T]">Mapping</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="comment">/**
   * Constructs a new Mapping based on this one, by adding new constraints.
   *
   * For example:
   * {{{
   *   import play.api.data._
   *   import validation.Constraints._
   *
   *   Form(&quot;phonenumber&quot; -&gt; text.verifying(required) )
   * }}}
   *
   * @param constraints the constraints to add
   * @return the new mapping
   */</span>
  <span class="keyword">def</span> <a title="(constraints: play.api.data.validation.Constraint[T]*)play.api.data.Mapping[T]" id="play.api.data;Mapping.verifying(d186087b37)">verifying</a><span class="delimiter">(</span><a title="play.api.data.validation.Constraint[T]*" id="play.api.data;Mapping.verifying(d186087b37).constraints">constraints</a>: <span title="play.api.data.validation.Constraint[T]*">Constraint</span><span class="delimiter">[</span>T<span class="delimiter">]</span>*<span class="delimiter">)</span>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[T]">Mapping</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="comment">/**
   * Constructs a new Mapping based on this one, by adding a new ad-hoc constraint.
   *
   * For example:
   * {{{
   *   import play.api.data._
   *   import validation.Constraints._
   *
   *   Form(&quot;phonenumber&quot; -&gt; text.verifying {_.grouped(2).size == 5})
   * }}}
   *
   * @param constraint a function describing the constraint that returns `false` on failure
   * @return the new mapping
   */</span>
  <span class="keyword">def</span> <a title="(constraint: T =&gt; Boolean)play.api.data.Mapping[T]" id="play.api.data;Mapping.verifying(e2c5b974a3)">verifying</a><span class="delimiter">(</span><a title="T =&gt; Boolean" id="play.api.data;Mapping.verifying(e2c5b974a3).constraint">constraint</a>: <span class="delimiter">(</span>T =&gt; Boolean<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[T]">Mapping</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#play.api.data;Mapping.verifying(a573f81ee6)" title="(error: =&gt; String, constraint: T =&gt; Boolean)play.api.data.Mapping[T]">verifying</a><span class="delimiter">(</span><span title="String(&quot;error.unknown&quot;)" class="string">&quot;error.unknown&quot;</span>, <a href="#play.api.data;Mapping.verifying(e2c5b974a3).constraint" title="T =&gt; Boolean">constraint</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Constructs a new Mapping based on this one, by adding a new ad-hoc constraint.
   *
   * For example:
   * {{{
   *   import play.api.data._
   *   import validation.Constraints._
   *
   *   Form(&quot;phonenumber&quot; -&gt; text.verifying(&quot;Bad phone number&quot;, {_.grouped(2).size == 5}))
   * }}}
   *
   * @param error The error message used if the constraint fails
   * @param constraint a function describing the constraint that returns `false` on failure
   * @return the new mapping
   */</span>
  <span class="keyword">def</span> <a title="(error: =&gt; String, constraint: T =&gt; Boolean)play.api.data.Mapping[T]" id="play.api.data;Mapping.verifying(a573f81ee6)">verifying</a><span class="delimiter">(</span><a title="=&gt; String" id="play.api.data;Mapping.verifying(a573f81ee6).error">error</a>: =&gt; String, <a title="T =&gt; Boolean" id="play.api.data;Mapping.verifying(a573f81ee6).constraint">constraint</a>: <span class="delimiter">(</span>T =&gt; Boolean<span class="delimiter">)</span><span class="delimiter">)</span>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[T]">Mapping</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data;Mapping.verifying(d186087b37)" title="(constraints: play.api.data.validation.Constraint[T]*)play.api.data.Mapping[T]">verifying</a><span class="delimiter">(</span><a href="validation/Validation.scala.html#play.api.data.validation.Constraint.apply(71de8999b8)" title="(f: T =&gt; play.api.data.validation.ValidationResult)play.api.data.validation.Constraint[T]">Constraint</a> <span class="delimiter">{</span> t: <a href="#play.api.data;Mapping;T" title="T">T</a> =&gt;
      <span title="play.api.data.validation.ValidationResult" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.data;Mapping.verifying(a573f81ee6).constraint" title="(v1: T)Boolean">constraint</a><span class="delimiter">(</span><a href="#play.api.data;Mapping.verifying(a573f81ee6).$anonfun.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="validation/Validation.scala.html#play.api.data.validation.Valid" title="play.api.data.validation.Valid.type">Valid</a> <span class="keyword">else</span> <a href="validation/Validation.scala.html#play.api.data.validation;Invalid" title="(errors: Seq[play.api.data.validation.ValidationError])play.api.data.validation.Invalid">Invalid</a><span class="delimiter">(</span><span title="(elems: play.api.data.validation.ValidationError*)Seq[play.api.data.validation.ValidationError]">Seq</span><span class="delimiter">(</span><a href="../../../../play-datacommons/play/api/data/validation/ValidationError.scala.html#play.api.data.validation.ValidationError.apply(64d2a33725)" title="(message: String, args: Any*)play.api.data.validation.ValidationError">ValidationError</a><span class="delimiter">(</span><a href="#play.api.data;Mapping.verifying(a573f81ee6).error" title="=&gt; String">error</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Transform this Mapping[T] to a Mapping[B].
   *
   * @tparam B The type of the new mapping.
   * @param f1 Transform value of T to a value of B
   * @param f2 Transform value of B to a value of T
   */</span>
  <span class="keyword">def</span> <a title="[B](f1: T =&gt; B, f2: B =&gt; T)play.api.data.Mapping[B]" id="play.api.data;Mapping.transform">transform</a><span class="delimiter">[</span><a title="" id="play.api.data;Mapping.transform;B">B</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T =&gt; B" id="play.api.data;Mapping.transform.f1">f1</a>: T =&gt; B, <a title="B =&gt; T" id="play.api.data;Mapping.transform.f2">f2</a>: B =&gt; T<span class="delimiter">)</span>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[B]">Mapping</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <a href="#play.api.data.WrappedMapping.readResolve" title="(wrapped: play.api.data.Mapping[T], f1: T =&gt; B, f2: B =&gt; T, additionalConstraints: Seq[play.api.data.validation.Constraint[B]])play.api.data.WrappedMapping[T,B]">WrappedMapping</a><span class="delimiter">(</span><a href="#play.api.data;Mapping" title="play.api.data.Mapping[T]" class="keyword">this</a>, <a href="#play.api.data;Mapping.transform.f1" title="T =&gt; B">f1</a>, <a href="#play.api.data;Mapping.transform.f2" title="B =&gt; T">f2</a><span class="delimiter">)</span>

  <span class="comment">// Internal utilities</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(prefix: String)Option[String]" id="play.api.data;Mapping.addPrefix">addPrefix</a><span class="delimiter">(</span><a title="String" id="play.api.data;Mapping.addPrefix.prefix">prefix</a>: <span title="String">String</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span title="(x: String)Option[String]">Option</span><span class="delimiter">(</span><a href="#play.api.data;Mapping.addPrefix.prefix" title="String">prefix</a><span class="delimiter">)</span>.<span title="(p: String =&gt; Boolean)Option[String]">filterNot</span><span class="delimiter">(</span><a href="#play.api.data;Mapping.addPrefix.$anonfun.x$16" title="String">_</a>.<span title="()Boolean">isEmpty</span><span class="delimiter">)</span>.<span title="(f: String =&gt; String)Option[String]">map</span><span class="delimiter">(</span><a title="String" id="play.api.data;Mapping.addPrefix.$anonfun.p">p</a> =&gt; <a href="#play.api.data;Mapping.addPrefix.$anonfun.p" title="String">p</a> <span title="(x$1: Any)String">+</span> <span title="(x: String)Option[String]">Option</span><span class="delimiter">(</span><a href="#play.api.data;Mapping.key" title="=&gt; String">key</a><span class="delimiter">)</span>.<span title="(p: String =&gt; Boolean)Option[String]">filterNot</span><span class="delimiter">(</span><a href="#play.api.data;Mapping.addPrefix.$anonfun.$anonfun.x$17" title="String">_</a>.<span title="()Boolean">isEmpty</span><span class="delimiter">)</span>.<span title="(f: String =&gt; String)Option[String]">map</span><span class="delimiter">(</span><span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#play.api.data;Mapping.addPrefix.$anonfun.$anonfun.x$18" title="String">_</a><span class="delimiter">)</span>.<span title="(default: =&gt; String)String">getOrElse</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(t: T)Either[Seq[play.api.data.FormError],T]" id="play.api.data;Mapping.applyConstraints">applyConstraints</a><span class="delimiter">(</span><a title="T" id="play.api.data;Mapping.applyConstraints.t">t</a>: <a href="#play.api.data;Mapping;T" title="T">T</a><span class="delimiter">)</span>: <span title="Either[Seq[play.api.data.FormError],T]">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span>, T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="(b: T)scala.util.Right[Nothing,T]">Right</span><span class="delimiter">(</span><a href="#play.api.data;Mapping.applyConstraints.t" title="T">t</a><span class="delimiter">)</span>.<span title="=&gt; scala.util.Either.RightProjection[Nothing,T]">right</span>.<span title="(f: T =&gt; scala.util.Either[Seq[play.api.data.FormError],T])scala.util.Either[Seq[play.api.data.FormError],T]">flatMap</span> <span class="delimiter">{</span> <a title="T" id="play.api.data;Mapping.applyConstraints.$anonfun.v">v</a> =&gt;
      <span title="(x: Seq[play.api.data.FormError])Option[Seq[play.api.data.FormError]]">Option</span><span class="delimiter">(</span><a href="#play.api.data;Mapping.collectErrors" title="(t: T)Seq[play.api.data.FormError]">collectErrors</a><span class="delimiter">(</span><a href="#play.api.data;Mapping.applyConstraints.$anonfun.v" title="T">v</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(p: Seq[play.api.data.FormError] =&gt; Boolean)Option[Seq[play.api.data.FormError]]">filterNot</span><span class="delimiter">(</span><a href="#play.api.data;Mapping.applyConstraints.$anonfun.$anonfun.x$19" title="Seq[play.api.data.FormError]">_</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>.<span title="(right: =&gt; T)Serializable with Product with scala.util.Either[Seq[play.api.data.FormError],T]">toLeft</span><span class="delimiter">(</span><a href="#play.api.data;Mapping.applyConstraints.$anonfun.v" title="T">v</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(t: T)Seq[play.api.data.FormError]" id="play.api.data;Mapping.collectErrors">collectErrors</a><span class="delimiter">(</span><a title="T" id="play.api.data;Mapping.collectErrors.t">t</a>: <a href="#play.api.data;Mapping;T" title="T">T</a><span class="delimiter">)</span>: <span title="Seq[play.api.data.FormError]">Seq</span><span class="delimiter">[</span>FormError<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data;Mapping.constraints" title="=&gt; Seq[play.api.data.validation.Constraint[T]]">constraints</a>.<span title="(f: play.api.data.validation.Constraint[T] =&gt; play.api.data.validation.ValidationResult)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[play.api.data.validation.Constraint[T]],play.api.data.validation.ValidationResult,Seq[play.api.data.validation.ValidationResult]])Seq[play.api.data.validation.ValidationResult]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,play.api.data.validation.ValidationResult,Seq[play.api.data.validation.ValidationResult]]" class="delimiter">(</span><a href="validation/Validation.scala.html#play.api.data.validation;Constraint.apply" title="(t: T)play.api.data.validation.ValidationResult">_</a><span class="delimiter">(</span><a href="#play.api.data;Mapping.collectErrors.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(pf: PartialFunction[play.api.data.validation.ValidationResult,Seq[play.api.data.validation.ValidationError]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[play.api.data.validation.ValidationResult],Seq[play.api.data.validation.ValidationError],Seq[Seq[play.api.data.validation.ValidationError]]])Seq[Seq[play.api.data.validation.ValidationError]]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[play.api.data.validation.ValidationResult,Seq[play.api.data.validation.ValidationError]] with Serializable" id="play.api.data;Mapping.collectErrors;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
      <span class="keyword">case</span> Invalid<span class="delimiter">(</span><a title="Seq[play.api.data.validation.ValidationError]" id="play.api.data;Mapping.collectErrors;$anonfun.isDefinedAt.errors">errors</a><span class="delimiter">)</span> =&gt; <a href="#play.api.data;Mapping.collectErrors;$anonfun.isDefinedAt.errors" title="Seq[play.api.data.validation.ValidationError]">errors</a>.<span title="=&gt; Seq[play.api.data.validation.ValidationError]">toSeq</span>
    <span class="delimiter">}</span>.<span title="(implicit asTraversable: Seq[play.api.data.validation.ValidationError] =&gt; scala.collection.GenTraversableOnce[play.api.data.validation.ValidationError])Seq[play.api.data.validation.ValidationError]">flatten</span>.<span title="(f: play.api.data.validation.ValidationError =&gt; play.api.data.FormError)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[play.api.data.validation.ValidationError],play.api.data.FormError,Seq[play.api.data.FormError]])Seq[play.api.data.FormError]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,play.api.data.FormError,Seq[play.api.data.FormError]]" class="delimiter">(</span><a title="play.api.data.validation.ValidationError" id="play.api.data;Mapping.collectErrors.$anonfun.ve">ve</a> =&gt; <a href="#play.api.data;FormError" title="(key: String, messages: Seq[String], args: Seq[Any])play.api.data.FormError">FormError</a><span class="delimiter">(</span><a href="#play.api.data;Mapping.key" title="=&gt; String">key</a>, <a href="#play.api.data;Mapping.collectErrors.$anonfun.ve" title="play.api.data.validation.ValidationError">ve</a>.<a href="../../../../play-datacommons/play/api/data/validation/ValidationError.scala.html#play.api.data.validation;ValidationError.messages" title="=&gt; Seq[String]">messages</a>, <a href="#play.api.data;Mapping.collectErrors.$anonfun.ve" title="play.api.data.validation.ValidationError">ve</a>.<a href="../../../../play-datacommons/play/api/data/validation/ValidationError.scala.html#play.api.data.validation;ValidationError.args" title="=&gt; Any*">args</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * A mapping wrapping another existing mapping with transformation functions.
 *
 * @param wrapped Existing wrapped mapping
 * @param f1 Transformation function from A to B
 * @param f2 Transformation function from B to A
 * @param additionalConstraints Additional constraints of type B
 */</span>
<span title="AnyRef" class="keyword">case class</span> <a href="#play.api.data;WrappedMapping.productElement.x$1" title="class WrappedMapping[A, B] extends AnyRef with play.api.data.Mapping[B] with Product with Serializable" id="play.api.data.WrappedMapping.readResolve">WrappedMapping</a><span class="delimiter">[</span><a title="" id="play.api.data.WrappedMapping.<init>$default$4;A">A</a>, <a title="" id="play.api.data.WrappedMapping.<init>$default$4;B">B</a><span class="delimiter">]</span><a href="#play.api.data.WrappedMapping.readResolve" title="Product" class="delimiter">(</a><a title="play.api.data.Mapping[A]" id="play.api.data;WrappedMapping.wrapped">wrapped</a>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[A]">Mapping</a><span class="delimiter">[</span>A<span class="delimiter">]</span>, <a title="A =&gt; B" id="play.api.data;WrappedMapping.f1">f1</a>: A =&gt; B, <a title="B =&gt; A" id="play.api.data;WrappedMapping.f2">f2</a>: B =&gt; A, <span class="keyword">val</span> <a title="Seq[play.api.data.validation.Constraint[B]]" id="play.api.data.WrappedMapping.<init>$default$4">additionalConstraints</a>: <span title="Seq[play.api.data.validation.Constraint[B]]">Seq</span><span class="delimiter">[</span>Constraint<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#play.api.data;Mapping" title="play.api.data.Mapping[B]">Mapping</a><span class="delimiter">[</span>B<span class="delimiter">]</span> <span class="delimiter">{</span>

  <span class="comment">/**
   * The field key.
   */</span>
  <span class="keyword">val</span> <a title="String" id="play.api.data;WrappedMapping.key">key</a> = <a href="#play.api.data;WrappedMapping.wrapped" title="=&gt; play.api.data.Mapping[A]">wrapped</a>.<a href="#play.api.data;Mapping.key" title="=&gt; String">key</a>

  <span class="comment">/**
   * Sub-mappings (these can be seen as sub-keys).
   */</span>
  <span class="keyword">val</span> <a title="Seq[play.api.data.Mapping[_]]" id="play.api.data;WrappedMapping.mappings">mappings</a> = <a href="#play.api.data;WrappedMapping.wrapped" title="=&gt; play.api.data.Mapping[A]">wrapped</a>.<a href="#play.api.data;Mapping.mappings" title="=&gt; Seq[play.api.data.Mapping[_]]">mappings</a>

  <span class="comment">/**
   * The Format expected for this field, if it exists.
   */</span>
  <span class="keyword">override</span> <span class="keyword">val</span> <a title="Option[(String, Seq[Any])]" id="play.api.data;WrappedMapping.format">format</a> = <a href="#play.api.data;WrappedMapping.wrapped" title="=&gt; play.api.data.Mapping[A]">wrapped</a>.<a href="#play.api.data;Mapping.format" title="=&gt; Option[(String, Seq[Any])]">format</a>

  <span class="comment">/**
   * The constraints associated with this field.
   */</span>
  <span class="keyword">val</span> <a title="Seq[play.api.data.validation.Constraint[B]]" id="play.api.data;WrappedMapping.constraints">constraints</a>: <span title="Seq[play.api.data.validation.Constraint[B]]">Seq</span><span class="delimiter">[</span>Constraint<span class="delimiter">[</span>B<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#play.api.data.WrappedMapping.<init>$default$4" title="=&gt; Seq[play.api.data.validation.Constraint[B]]">additionalConstraints</a>

  <span class="comment">/**
   * Binds this field, i.e. construct a concrete value from submitted data.
   *
   * @param data the submitted data
   * @return either a concrete value of type `B` or a set of errors, if the binding failed
   */</span>
  <span class="keyword">def</span> <a title="(data: Map[String,String])Either[Seq[play.api.data.FormError],B]" id="play.api.data;WrappedMapping.bind">bind</a><span class="delimiter">(</span><a title="Map[String,String]" id="play.api.data;WrappedMapping.bind.data">data</a>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Either[Seq[play.api.data.FormError],B]">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span>, B<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data;WrappedMapping.wrapped" title="=&gt; play.api.data.Mapping[A]">wrapped</a>.<a href="#play.api.data;Mapping.bind" title="(data: Map[String,String])Either[Seq[play.api.data.FormError],A]">bind</a><span class="delimiter">(</span><a href="#play.api.data;WrappedMapping.bind.data" title="Map[String,String]">data</a><span class="delimiter">)</span>.<span title="=&gt; scala.util.Either.RightProjection[Seq[play.api.data.FormError],A]">right</span>.<span title="(f: A =&gt; B)Serializable with Product with scala.util.Either[Seq[play.api.data.FormError],B]">map</span><span class="delimiter">(</span><a title="A" id="play.api.data;WrappedMapping.bind.$anonfun.t">t</a> =&gt; <a href="#play.api.data;WrappedMapping.f1" title="(v1: A)B">f1</a><span class="delimiter">(</span><a href="#play.api.data;WrappedMapping.bind.$anonfun.t" title="A">t</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; scala.util.Either.RightProjection[Seq[play.api.data.FormError],B]">right</span>.<span title="(f: B =&gt; scala.util.Either[Seq[play.api.data.FormError],B])scala.util.Either[Seq[play.api.data.FormError],B]">flatMap</span><span class="delimiter">(</span><a href="#play.api.data;Mapping.applyConstraints" title="(t: B)Either[Seq[play.api.data.FormError],B]">applyConstraints</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Unbinds this field, i.e. transforms a concrete value to plain data.
   *
   * @param value the value to unbind
   * @return the plain data
   */</span>
  <span class="keyword">def</span> <a title="(value: B)Map[String,String]" id="play.api.data;WrappedMapping.unbind">unbind</a><span class="delimiter">(</span><a title="B" id="play.api.data;WrappedMapping.unbind.value">value</a>: <a href="#play.api.data.WrappedMapping.<init>$default$4;B" title="B">B</a><span class="delimiter">)</span>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span> = <a href="#play.api.data;WrappedMapping.wrapped" title="=&gt; play.api.data.Mapping[A]">wrapped</a>.<a href="#play.api.data;Mapping.unbind" title="(value: A)Map[String,String]">unbind</a><span class="delimiter">(</span><a href="#play.api.data;WrappedMapping.f2" title="(v1: B)A">f2</a><span class="delimiter">(</span><a href="#play.api.data;WrappedMapping.unbind.value" title="B">value</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Unbinds this field, i.e. transforms a concrete value to plain data, and applies validation.
   *
   * @param value the value to unbind
   * @return the plain data and any errors in the plain data
   */</span>
  <span class="keyword">def</span> <a title="(value: B)(Map[String,String], Seq[play.api.data.FormError])" id="play.api.data;WrappedMapping.unbindAndValidate">unbindAndValidate</a><span class="delimiter">(</span><a title="B" id="play.api.data;WrappedMapping.unbindAndValidate.value">value</a>: <a href="#play.api.data.WrappedMapping.<init>$default$4;B" title="B">B</a><span class="delimiter">)</span>: <span title="(Map[String,String], Seq[play.api.data.FormError])" class="delimiter">(</span>Map<span class="delimiter">[</span>String, String<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a href="#play.api.data;WrappedMapping.unbindAndValidate.data" title="(Map[String,String], Seq[play.api.data.FormError])" class="delimiter">(</a><a href="#play.api.data;WrappedMapping.unbindAndValidate.x$21" title="Map[String,String]" id="play.api.data;WrappedMapping.unbindAndValidate.data">data</a>, <a href="#play.api.data;WrappedMapping.unbindAndValidate.x$21" title="Seq[play.api.data.FormError]" id="play.api.data;WrappedMapping.unbindAndValidate.errors">errors</a><span class="delimiter">)</span> = <a href="#play.api.data;WrappedMapping.wrapped" title="=&gt; play.api.data.Mapping[A]">wrapped</a>.<a href="#play.api.data;Mapping.unbindAndValidate" title="(value: A)(Map[String,String], Seq[play.api.data.FormError])">unbindAndValidate</a><span title="(Map[String,String], Seq[play.api.data.FormError]) @unchecked" class="delimiter">(</span><a href="#play.api.data;WrappedMapping.f2" title="(v1: B)A">f2</a><span class="delimiter">(</span><a href="#play.api.data;WrappedMapping.unbindAndValidate.value" title="B">value</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span title="(_1: Map[String,String], _2: Seq[play.api.data.FormError])(Map[String,String], Seq[play.api.data.FormError])" class="delimiter">(</span><a href="#play.api.data;WrappedMapping.unbindAndValidate.data" title="Map[String,String]">data</a>, <a href="#play.api.data;WrappedMapping.unbindAndValidate.errors" title="Seq[play.api.data.FormError]">errors</a> <span title="(that: scala.collection.GenTraversableOnce[play.api.data.FormError])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[play.api.data.FormError],play.api.data.FormError,Seq[play.api.data.FormError]])Seq[play.api.data.FormError]">++</span> <a href="#play.api.data;Mapping.collectErrors" title="(t: B)Seq[play.api.data.FormError]">collectErrors</a><span class="delimiter">(</span><a href="#play.api.data;WrappedMapping.unbindAndValidate.value" title="B">value</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Constructs a new Mapping based on this one, adding a prefix to the key.
   *
   * @param prefix the prefix to add to the key
   * @return the same mapping, with only the key changed
   */</span>
  <span class="keyword">def</span> <a title="(prefix: String)play.api.data.Mapping[B]" id="play.api.data;WrappedMapping.withPrefix">withPrefix</a><span class="delimiter">(</span><a title="String" id="play.api.data;WrappedMapping.withPrefix.prefix">prefix</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[B]">Mapping</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data.WrappedMapping.readResolve" title="(wrapped: play.api.data.Mapping[A], f1: A =&gt; B, f2: B =&gt; A, additionalConstraints: Seq[play.api.data.validation.Constraint[B]])play.api.data.WrappedMapping[A,B]">copy</a><span class="delimiter">(</span>wrapped = <a href="#play.api.data;WrappedMapping.wrapped" title="=&gt; play.api.data.Mapping[A]">wrapped</a>.<a href="#play.api.data;Mapping.withPrefix" title="(prefix: String)play.api.data.Mapping[A]">withPrefix</a><span class="delimiter">(</span><a href="#play.api.data;WrappedMapping.withPrefix.prefix" title="String">prefix</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Constructs a new Mapping based on this one, by adding new constraints.
   *
   * For example:
   * {{{
   *   import play.api.data._
   *   import validation.Constraints._
   *
   *   Form(&quot;phonenumber&quot; -&gt; text.verifying(required) )
   * }}}
   *
   * @param constraints the constraints to add
   * @return the new mapping
   */</span>
  <span class="keyword">def</span> <a title="(constraints: play.api.data.validation.Constraint[B]*)play.api.data.Mapping[B]" id="play.api.data;WrappedMapping.verifying(3ef970c9f7)">verifying</a><span class="delimiter">(</span><a title="play.api.data.validation.Constraint[B]*" id="play.api.data;WrappedMapping.verifying(3ef970c9f7).constraints">constraints</a>: <span title="play.api.data.validation.Constraint[B]*">Constraint</span><span class="delimiter">[</span>B<span class="delimiter">]</span>*<span class="delimiter">)</span>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[B]">Mapping</a><span class="delimiter">[</span>B<span class="delimiter">]</span> = <a href="#play.api.data;WrappedMapping.wrapped" title="play.api.data.Mapping[A] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;WrappedMapping.verifying(3ef970c9f7).x$68">copy</a><span class="delimiter">(</span>additionalConstraints = <a href="#play.api.data.WrappedMapping.<init>$default$4" title="=&gt; Seq[play.api.data.validation.Constraint[B]]">additionalConstraints</a> <a title="Seq[play.api.data.validation.Constraint[B]] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;WrappedMapping.verifying(3ef970c9f7).x$65">++</a> <a href="#play.api.data;WrappedMapping.verifying(3ef970c9f7).constraints" title="play.api.data.validation.Constraint[B]*">constraints</a><span class="delimiter">)</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * Provides a set of operations related to `RepeatedMapping` values.
 */</span>
<span class="keyword">object</span> <a title="play.api.data.RepeatedMapping.type" id="play.api.data.RepeatedMapping.readResolve">RepeatedMapping</a> <a href="#play.api.data.RepeatedMapping.readResolve" title="play.api.data.RepeatedMapping.type" class="delimiter">{</a>

  <span class="comment">/**
   * Computes the available indexes for the given key in this set of data.
   */</span>
  <span class="keyword">def</span> <a title="(key: String, data: Map[String,String])Seq[Int]" id="play.api.data.RepeatedMapping.indexes">indexes</a><span class="delimiter">(</span><a title="String" id="play.api.data.RepeatedMapping.indexes.key">key</a>: <span title="String">String</span>, <a title="Map[String,String]" id="play.api.data.RepeatedMapping.indexes.data">data</a>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Seq[Int]">Seq</span><span class="delimiter">[</span>Int<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="scala.util.matching.Regex" id="play.api.data.RepeatedMapping.indexes.KeyPattern">KeyPattern</a> = <span class="delimiter">(</span><span title="String(&quot;^&quot;)" class="string">&quot;^&quot;</span> <span title="(x$1: Any)String">+</span> java.util.regex.<span title="java.util.regex.Pattern.type">Pattern</span>.<span title="(x$1: String)String">quote</span><span class="delimiter">(</span><a href="#play.api.data.RepeatedMapping.indexes.key" title="String">key</a><span class="delimiter">)</span> <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">+</span> <span title="String(&quot;\\[(\\d+)\\].*$&quot;)" class="string">&quot;&quot;&quot;\[(\d+)\].*$&quot;&quot;&quot;</span><span class="delimiter">)</span>.<span title="=&gt; scala.util.matching.Regex">r</span>
    <a href="#play.api.data.RepeatedMapping.indexes.data" title="Map[String,String]">data</a>.<span title="=&gt; Seq[(String, String)]">toSeq</span>.<span title="(pf: PartialFunction[(String, String),Int])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, String)],Int,Seq[Int]])Seq[Int]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[(String, String),Int] with Serializable" id="play.api.data.RepeatedMapping.indexes;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a href="#play.api.data.RepeatedMapping.indexes.KeyPattern" title="(target: Any)Option[List[String]]">KeyPattern</a><span class="delimiter">(</span><a title="String" id="play.api.data.RepeatedMapping.indexes;$anonfun.isDefinedAt.index">index</a><span class="delimiter">)</span>, _<span class="delimiter">)</span> =&gt; <a href="#play.api.data.RepeatedMapping.indexes;$anonfun.isDefinedAt.index" title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">index</a>.<span title="=&gt; Int">toInt</span> <span class="delimiter">}</span>.<span title="(implicit ord: scala.math.Ordering[Int])Seq[Int]">sorted</span>.<span title="=&gt; Seq[Int]">distinct</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * A mapping for repeated elements.
 *
 * @param wrapped The wrapped mapping
 */</span>
<span title="AnyRef" class="keyword">case class</span> <a href="#play.api.data;RepeatedMapping.copy$default$1" title="[T](wrapped: play.api.data.Mapping[T], key: String, constraints: Seq[play.api.data.validation.Constraint[List[T]]])play.api.data.RepeatedMapping[T]" id="play.api.data;RepeatedMapping.equals">RepeatedMapping</a><span class="delimiter">[</span><a title="" id="play.api.data;RepeatedMapping.copy$default$3;T">T</a><span class="delimiter">]</span><a href="#play.api.data;RepeatedMapping.equals" title="Product" class="delimiter">(</a><a title="play.api.data.Mapping[T]" id="play.api.data;RepeatedMapping.copy$default$1">wrapped</a>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[T]">Mapping</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="String" id="play.api.data;RepeatedMapping.copy$default$2">key</a>: <span title="String">String</span> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span class="keyword">val</span> <a title="Seq[play.api.data.validation.Constraint[List[T]]]" id="play.api.data;RepeatedMapping.copy$default$3">constraints</a>: <span title="Seq[play.api.data.validation.Constraint[List[T]]]">Seq</span><span class="delimiter">[</span>Constraint<span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#play.api.data;Mapping" title="play.api.data.Mapping[List[T]]">Mapping</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>

  <span class="comment">/**
   * The Format expected for this field, if it exists.
   */</span>
  <span class="keyword">override</span> <span class="keyword">val</span> <a title="Option[(String, Seq[Any])]" id="play.api.data;RepeatedMapping.format">format</a>: <span title="Option[(String, Seq[Any])]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Seq<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#play.api.data;RepeatedMapping.copy$default$1" title="=&gt; play.api.data.Mapping[T]">wrapped</a>.<a href="#play.api.data;Mapping.format" title="=&gt; Option[(String, Seq[Any])]">format</a>

  <span class="comment">/**
   * Constructs a new Mapping based on this one, by adding new constraints.
   *
   * For example:
   * {{{
   *   import play.api.data._
   *   import validation.Constraints._
   *
   *   Form(&quot;phonenumber&quot; -&gt; text.verifying(required) )
   * }}}
   *
   * @param addConstraints the constraints to add
   * @return the new mapping
   */</span>
  <span class="keyword">def</span> <a title="(addConstraints: play.api.data.validation.Constraint[List[T]]*)play.api.data.Mapping[List[T]]" id="play.api.data;RepeatedMapping.verifying(831488f193)">verifying</a><span class="delimiter">(</span><a title="play.api.data.validation.Constraint[List[T]]*" id="play.api.data;RepeatedMapping.verifying(831488f193).addConstraints">addConstraints</a>: <span title="play.api.data.validation.Constraint[List[T]]*">Constraint</span><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>*<span class="delimiter">)</span>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[List[T]]">Mapping</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data;RepeatedMapping.equals" title="RepeatedMapping.this.type" class="keyword">this</a>.<a href="#play.api.data;RepeatedMapping.copy$default$1" title="play.api.data.Mapping[T] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;RepeatedMapping.verifying(831488f193).x$71">copy</a><span class="delimiter">(</span>constraints = <a href="#play.api.data;RepeatedMapping.copy$default$3" title="=&gt; Seq[play.api.data.validation.Constraint[List[T]]]">constraints</a> <a title="Seq[play.api.data.validation.Constraint[List[T]]] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;RepeatedMapping.verifying(831488f193).x$69">++</a> <a href="#play.api.data;RepeatedMapping.verifying(831488f193).addConstraints" title="play.api.data.validation.Constraint[List[T]]*">addConstraints</a>.<span title="=&gt; Seq[play.api.data.validation.Constraint[List[T]]]">toSeq</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds this field, i.e. construct a concrete value from submitted data.
   *
   * @param data the submitted data
   * @return either a concrete value of type `List[T]` or a set of errors, if the binding failed
   */</span>
  <span class="keyword">def</span> <a title="(data: Map[String,String])Either[Seq[play.api.data.FormError],List[T]]" id="play.api.data;RepeatedMapping.bind">bind</a><span class="delimiter">(</span><a title="Map[String,String]" id="play.api.data;RepeatedMapping.bind.data">data</a>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Either[Seq[play.api.data.FormError],List[T]]">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span>, List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Seq[Either[Seq[play.api.data.FormError],T]]" id="play.api.data;RepeatedMapping.bind.allErrorsOrItems">allErrorsOrItems</a>: <span title="Seq[Either[Seq[play.api.data.FormError],T]]">Seq</span><span class="delimiter">[</span>Either<span class="delimiter">[</span>Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span>, T<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#play.api.data.RepeatedMapping.readResolve" title="play.api.data.RepeatedMapping.type">RepeatedMapping</a>.<a href="#play.api.data.RepeatedMapping.indexes" title="(key: String, data: Map[String,String])Seq[Int]">indexes</a><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.copy$default$2" title="=&gt; String">key</a>, <a href="#play.api.data;RepeatedMapping.bind.data" title="Map[String,String]">data</a><span class="delimiter">)</span>.<span title="(f: Int =&gt; Either[Seq[play.api.data.FormError],T])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Int],Either[Seq[play.api.data.FormError],T],Seq[Either[Seq[play.api.data.FormError],T]]])Seq[Either[Seq[play.api.data.FormError],T]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,Either[Seq[play.api.data.FormError],T],Seq[Either[Seq[play.api.data.FormError],T]]]" class="delimiter">(</span><a title="Int" id="play.api.data;RepeatedMapping.bind.allErrorsOrItems.$anonfun.i">i</a> =&gt; <a href="#play.api.data;RepeatedMapping.copy$default$1" title="=&gt; play.api.data.Mapping[T]">wrapped</a>.<a href="#play.api.data;Mapping.withPrefix" title="(prefix: String)play.api.data.Mapping[T]">withPrefix</a><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.copy$default$2" title="=&gt; String">key</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#play.api.data;RepeatedMapping.bind.allErrorsOrItems.$anonfun.i" title="Int">i</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>.<a href="#play.api.data;Mapping.bind" title="(data: Map[String,String])Either[Seq[play.api.data.FormError],T]">bind</a><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.bind.data" title="Map[String,String]">data</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span title="Either[Seq[play.api.data.FormError],List[T]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.bind.allErrorsOrItems" title="Seq[Either[Seq[play.api.data.FormError],T]]">allErrorsOrItems</a>.<span title="(p: Either[Seq[play.api.data.FormError],T] =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.bind.$anonfun.x$22" title="Either[Seq[play.api.data.FormError],T]">_</a>.<span title="=&gt; Boolean">isRight</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(b: List[T])scala.util.Right[Nothing,List[T]]">Right</span><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.bind.allErrorsOrItems" title="Seq[Either[Seq[play.api.data.FormError],T]]">allErrorsOrItems</a>.<span title="(f: Either[Seq[play.api.data.FormError],T] =&gt; T)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Either[Seq[play.api.data.FormError],T]],T,Seq[T]])Seq[T]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,T,Seq[T]]" class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.bind.$anonfun.x$23" title="Either[Seq[play.api.data.FormError],T]">_</a>.<span title="=&gt; scala.util.Either.RightProjection[Seq[play.api.data.FormError],T]">right</span>.<span title="=&gt; T">get</span><span class="delimiter">)</span>.<span title="=&gt; List[T]">toList</span><span class="delimiter">)</span>.<span title="=&gt; scala.util.Either.RightProjection[Nothing,List[T]]">right</span>.<span title="(f: List[T] =&gt; scala.util.Either[Seq[play.api.data.FormError],List[T]])scala.util.Either[Seq[play.api.data.FormError],List[T]]">flatMap</span><span class="delimiter">(</span><a href="#play.api.data;Mapping.applyConstraints" title="(t: List[T])Either[Seq[play.api.data.FormError],List[T]]">applyConstraints</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span title="(a: Seq[play.api.data.FormError])scala.util.Left[Seq[play.api.data.FormError],Nothing]">Left</span><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.bind.allErrorsOrItems" title="Seq[Either[Seq[play.api.data.FormError],T]]">allErrorsOrItems</a>.<span title="(pf: PartialFunction[Either[Seq[play.api.data.FormError],T],Seq[play.api.data.FormError]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Either[Seq[play.api.data.FormError],T]],Seq[play.api.data.FormError],Seq[Seq[play.api.data.FormError]]])Seq[Seq[play.api.data.FormError]]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[Either[Seq[play.api.data.FormError],T],Seq[play.api.data.FormError]] with Serializable" id="play.api.data;RepeatedMapping.bind;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> <span class="keyword">case</span> Left<span class="delimiter">(</span><a title="Seq[play.api.data.FormError]" id="play.api.data;RepeatedMapping.bind;$anonfun.isDefinedAt.errors">errors</a><span class="delimiter">)</span> =&gt; <a href="#play.api.data;RepeatedMapping.bind;$anonfun.isDefinedAt.errors" title="Seq[play.api.data.FormError]">errors</a> <span class="delimiter">}</span>.<span title="(implicit asTraversable: Seq[play.api.data.FormError] =&gt; scala.collection.GenTraversableOnce[play.api.data.FormError])Seq[play.api.data.FormError]">flatten</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Unbinds this field, i.e. transforms a concrete value to plain data.
   *
   * @param value the value to unbind
   * @return the plain data
   */</span>
  <span class="keyword">def</span> <a title="(value: List[T])Map[String,String]" id="play.api.data;RepeatedMapping.unbind">unbind</a><span class="delimiter">(</span><a title="List[T]" id="play.api.data;RepeatedMapping.unbind.value">value</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="List[Map[String,String]]" id="play.api.data;RepeatedMapping.unbind.datas">datas</a> = <a href="#play.api.data;RepeatedMapping.unbind.value" title="List[T]">value</a>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[List[T],(T, Int),List[(T, Int)]])List[(T, Int)]">zipWithIndex</span>.<span title="(f: ((T, Int)) =&gt; Map[String,String])(implicit bf: scala.collection.generic.CanBuildFrom[List[(T, Int)],Map[String,String],List[Map[String,String]]])List[Map[String,String]]">map</span> <a href="#play.api.data;RepeatedMapping.unbind.datas.$anonfun.x0$5" title="Map[String,String]" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="T" id="play.api.data;RepeatedMapping.unbind.datas.$anonfun.t">t</a>, <a title="Int" id="play.api.data;RepeatedMapping.unbind.datas.$anonfun.i">i</a><span class="delimiter">)</span> =&gt; <a href="#play.api.data;RepeatedMapping.copy$default$1" title="=&gt; play.api.data.Mapping[T]">wrapped</a>.<a href="#play.api.data;Mapping.withPrefix" title="(prefix: String)play.api.data.Mapping[T]">withPrefix</a><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.copy$default$2" title="=&gt; String">key</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#play.api.data;RepeatedMapping.unbind.datas.$anonfun.i" title="Int">i</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>.<a href="#play.api.data;Mapping.unbind" title="(value: T)Map[String,String]">unbind</a><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.unbind.datas.$anonfun.t" title="T">t</a><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#play.api.data;RepeatedMapping.unbind.datas" title="List[Map[String,String]]">datas</a>.<span title="(z: scala.collection.immutable.Map[String,String])(f: (scala.collection.immutable.Map[String,String], Map[String,String]) =&gt; scala.collection.immutable.Map[String,String])scala.collection.immutable.Map[String,String]">foldLeft</span><span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[String,String]" class="delimiter">[</span><span title="String">String</span>, <span title="String">String</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.unbind.$anonfun.x$24" title="scala.collection.immutable.Map[String,String]">_</a> <span title="(xs: scala.collection.GenTraversableOnce[(String, String)])scala.collection.immutable.Map[String,String]">++</span> <a href="#play.api.data;RepeatedMapping.unbind.$anonfun.x$25" title="Map[String,String]">_</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Unbinds this field, i.e. transforms a concrete value to plain data, and applies validation.
   *
   * @param value the value to unbind
   * @return the plain data and any errors in the plain data
   */</span>
  <span class="keyword">def</span> <a title="(value: List[T])(Map[String,String], Seq[play.api.data.FormError])" id="play.api.data;RepeatedMapping.unbindAndValidate">unbindAndValidate</a><span class="delimiter">(</span><a title="List[T]" id="play.api.data;RepeatedMapping.unbindAndValidate.value">value</a>: <span title="List[T]">List</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Map[String,String], Seq[play.api.data.FormError])" class="delimiter">(</span>Map<span class="delimiter">[</span>String, String<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a href="#play.api.data;RepeatedMapping.unbindAndValidate.datas" title="(List[Map[String,String]], List[Seq[play.api.data.FormError]])" class="delimiter">(</a><a href="#play.api.data;RepeatedMapping.unbindAndValidate.x$26" title="List[Map[String,String]]" id="play.api.data;RepeatedMapping.unbindAndValidate.datas">datas</a>, <a href="#play.api.data;RepeatedMapping.unbindAndValidate.x$26" title="List[Seq[play.api.data.FormError]]" id="play.api.data;RepeatedMapping.unbindAndValidate.errors">errors</a><span class="delimiter">)</span> = <a href="#play.api.data;RepeatedMapping.unbindAndValidate.value" title="List[T]">value</a>.<span title="(implicit bf: scala.collection.generic.CanBuildFrom[List[T],(T, Int),List[(T, Int)]])List[(T, Int)]">zipWithIndex</span>.<span title="(f: ((T, Int)) =&gt; (Map[String,String], Seq[play.api.data.FormError]))(implicit bf: scala.collection.generic.CanBuildFrom[List[(T, Int)],(Map[String,String], Seq[play.api.data.FormError]),List[(Map[String,String], Seq[play.api.data.FormError])]])List[(Map[String,String], Seq[play.api.data.FormError])]">map</span> <a href="#play.api.data;RepeatedMapping.unbindAndValidate.x$26.$anonfun.x0$6" title="(Map[String,String], Seq[play.api.data.FormError])" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><a title="T" id="play.api.data;RepeatedMapping.unbindAndValidate.x$26.$anonfun.t">t</a>, <a title="Int" id="play.api.data;RepeatedMapping.unbindAndValidate.x$26.$anonfun.i">i</a><span class="delimiter">)</span> =&gt; <a href="#play.api.data;RepeatedMapping.copy$default$1" title="=&gt; play.api.data.Mapping[T]">wrapped</a>.<a href="#play.api.data;Mapping.withPrefix" title="(prefix: String)play.api.data.Mapping[T]">withPrefix</a><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.copy$default$2" title="=&gt; String">key</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#play.api.data;RepeatedMapping.unbindAndValidate.x$26.$anonfun.i" title="Int">i</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;]&quot;)" class="string">&quot;]&quot;</span><span class="delimiter">)</span>.<a href="#play.api.data;Mapping.unbindAndValidate" title="(value: T)(Map[String,String], Seq[play.api.data.FormError])">unbindAndValidate</a><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.unbindAndValidate.x$26.$anonfun.t" title="T">t</a><span class="delimiter">)</span> <span class="delimiter">}</span>.<span title="(implicit asPair: ((Map[String,String], Seq[play.api.data.FormError])) =&gt; (Map[String,String], Seq[play.api.data.FormError]))(List[Map[String,String]], List[Seq[play.api.data.FormError]])">unzip</span>
    <span title="(_1: scala.collection.immutable.Map[String,String], _2: Seq[play.api.data.FormError])(scala.collection.immutable.Map[String,String], Seq[play.api.data.FormError])" class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.unbindAndValidate.datas" title="List[Map[String,String]]">datas</a>.<span title="(z: scala.collection.immutable.Map[String,String])(f: (scala.collection.immutable.Map[String,String], Map[String,String]) =&gt; scala.collection.immutable.Map[String,String])scala.collection.immutable.Map[String,String]">foldLeft</span><span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[String,String]" class="delimiter">[</span><span title="String">String</span>, <span title="String">String</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.unbindAndValidate.$anonfun.x$27" title="scala.collection.immutable.Map[String,String]">_</a> <span title="(xs: scala.collection.GenTraversableOnce[(String, String)])scala.collection.immutable.Map[String,String]">++</span> <a href="#play.api.data;RepeatedMapping.unbindAndValidate.$anonfun.x$28" title="Map[String,String]">_</a><span class="delimiter">)</span>, <a href="#play.api.data;RepeatedMapping.unbindAndValidate.errors" title="List[Seq[play.api.data.FormError]]">errors</a>.<span title="(implicit asTraversable: Seq[play.api.data.FormError] =&gt; scala.collection.GenTraversableOnce[play.api.data.FormError])List[play.api.data.FormError]">flatten</span> <span title="(that: scala.collection.GenTraversableOnce[play.api.data.FormError])(implicit bf: scala.collection.generic.CanBuildFrom[List[play.api.data.FormError],play.api.data.FormError,Seq[play.api.data.FormError]])Seq[play.api.data.FormError]">++</span> <a href="#play.api.data;Mapping.collectErrors" title="(t: List[T])Seq[play.api.data.FormError]">collectErrors</a><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.unbindAndValidate.value" title="List[T]">value</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Constructs a new Mapping based on this one, adding a prefix to the key.
   *
   * @param prefix the prefix to add to the key
   * @return the same mapping, with only the key changed
   */</span>
  <span class="keyword">def</span> <a title="(prefix: String)play.api.data.Mapping[List[T]]" id="play.api.data;RepeatedMapping.withPrefix">withPrefix</a><span class="delimiter">(</span><a title="String" id="play.api.data;RepeatedMapping.withPrefix.prefix">prefix</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[List[T]]">Mapping</a><span class="delimiter">[</span>List<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data;Mapping.addPrefix" title="(prefix: String)Option[String]">addPrefix</a><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.withPrefix.prefix" title="String">prefix</a><span class="delimiter">)</span>.<span title="(f: String =&gt; play.api.data.RepeatedMapping[T])Option[play.api.data.RepeatedMapping[T]]">map</span><span class="delimiter">(</span><a title="String" id="play.api.data;RepeatedMapping.withPrefix.$anonfun.newKey">newKey</a> =&gt; <a href="#play.api.data;RepeatedMapping.equals" title="RepeatedMapping.this.type" class="keyword">this</a>.<a href="#play.api.data;RepeatedMapping.copy$default$1" title="play.api.data.Mapping[T] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;RepeatedMapping.withPrefix.$anonfun.x$74">copy</a><span class="delimiter">(</span>key = <a href="#play.api.data;RepeatedMapping.withPrefix.$anonfun.newKey" title="String" id="play.api.data;RepeatedMapping.withPrefix.$anonfun.x$72">newKey</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(default: =&gt; play.api.data.RepeatedMapping[T])play.api.data.RepeatedMapping[T]">getOrElse</span><span class="delimiter">(</span><a href="#play.api.data;RepeatedMapping.equals" title="play.api.data.RepeatedMapping[T]" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Sub-mappings (these can be seen as sub-keys).
   */</span>
  <span class="keyword">val</span> <a title="Seq[play.api.data.Mapping[_]]" id="play.api.data;RepeatedMapping.mappings">mappings</a>: <span title="Seq[play.api.data.Mapping[_]]">Seq</span><span class="delimiter">[</span>Mapping<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#play.api.data;RepeatedMapping.copy$default$1" title="=&gt; play.api.data.Mapping[T]">wrapped</a>.<a href="#play.api.data;Mapping.mappings" title="=&gt; Seq[play.api.data.Mapping[_]]">mappings</a>

<span class="delimiter">}</span>

<span class="comment">/**
 * A mapping for optional elements
 *
 * @param wrapped the wrapped mapping
 */</span>
<span class="keyword">case class</span> <a href="#play.api.data;OptionalMapping.productElement.x$1" title="class OptionalMapping[T] extends AnyRef with play.api.data.Mapping[Option[T]] with Product with Serializable" id="play.api.data.OptionalMapping.readResolve">OptionalMapping</a><span class="delimiter">[</span><a title="" id="play.api.data.OptionalMapping.apply$default$2;T">T</a><span class="delimiter">]</span><a href="#play.api.data.OptionalMapping.readResolve" title="Product" class="delimiter">(</a><a title="play.api.data.Mapping[T]" id="play.api.data;OptionalMapping.wrapped">wrapped</a>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[T]">Mapping</a><span class="delimiter">[</span>T<span class="delimiter">]</span>, <span class="keyword">val</span> <a title="Seq[play.api.data.validation.Constraint[Option[T]]]" id="play.api.data.OptionalMapping.apply$default$2">constraints</a>: <span title="Seq[play.api.data.validation.Constraint[Option[T]]]">Seq</span><span class="delimiter">[</span>Constraint<span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#play.api.data;Mapping" title="play.api.data.Mapping[Option[T]]">Mapping</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>

  <span class="keyword">override</span> <span class="keyword">val</span> <a title="Option[(String, Seq[Any])]" id="play.api.data;OptionalMapping.format">format</a>: <span title="Option[(String, Seq[Any])]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Seq<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#play.api.data;OptionalMapping.wrapped" title="=&gt; play.api.data.Mapping[T]">wrapped</a>.<a href="#play.api.data;Mapping.format" title="=&gt; Option[(String, Seq[Any])]">format</a>

  <span class="comment">/**
   * The field key.
   */</span>
  <span class="keyword">val</span> <a title="String" id="play.api.data;OptionalMapping.key">key</a> = <a href="#play.api.data;OptionalMapping.wrapped" title="=&gt; play.api.data.Mapping[T]">wrapped</a>.<a href="#play.api.data;Mapping.key" title="=&gt; String">key</a>

  <span class="comment">/**
   * Constructs a new Mapping based on this one, by adding new constraints.
   *
   * For example:
   * {{{
   *   import play.api.data._
   *   import validation.Constraints._
   *
   *   Form(&quot;phonenumber&quot; -&gt; text.verifying(required) )
   * }}}
   *
   * @param constraints the constraints to add
   * @return the new mapping
   */</span>
  <span class="keyword">def</span> <a title="(addConstraints: play.api.data.validation.Constraint[Option[T]]*)play.api.data.Mapping[Option[T]]" id="play.api.data;OptionalMapping.verifying(7508645b90)">verifying</a><span class="delimiter">(</span><a title="play.api.data.validation.Constraint[Option[T]]*" id="play.api.data;OptionalMapping.verifying(7508645b90).addConstraints">addConstraints</a>: <span title="play.api.data.validation.Constraint[Option[T]]*">Constraint</span><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span>*<span class="delimiter">)</span>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[Option[T]]">Mapping</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data.OptionalMapping.readResolve" title="OptionalMapping.this.type" class="keyword">this</a>.<a href="#play.api.data;OptionalMapping.wrapped" title="play.api.data.Mapping[T] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;OptionalMapping.verifying(7508645b90).x$76">copy</a><span class="delimiter">(</span>constraints = <a href="#play.api.data.OptionalMapping.apply$default$2" title="=&gt; Seq[play.api.data.validation.Constraint[Option[T]]]">constraints</a> <a title="Seq[play.api.data.validation.Constraint[Option[T]]] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;OptionalMapping.verifying(7508645b90).x$75">++</a> <a href="#play.api.data;OptionalMapping.verifying(7508645b90).addConstraints" title="play.api.data.validation.Constraint[Option[T]]*">addConstraints</a>.<span title="=&gt; Seq[play.api.data.validation.Constraint[Option[T]]]">toSeq</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds this field, i.e. constructs a concrete value from submitted data.
   *
   * @param data the submitted data
   * @return either a concrete value of type `T` or a set of error if the binding failed
   */</span>
  <span class="keyword">def</span> <a title="(data: Map[String,String])Either[Seq[play.api.data.FormError],Option[T]]" id="play.api.data;OptionalMapping.bind">bind</a><span class="delimiter">(</span><a title="Map[String,String]" id="play.api.data;OptionalMapping.bind.data">data</a>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Either[Seq[play.api.data.FormError],Option[T]]">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span>, Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data;OptionalMapping.bind.data" title="Map[String,String]">data</a>.<span title="=&gt; Iterable[String]">keys</span>.<span title="(p: String =&gt; Boolean)Iterable[String]">filter</span><span class="delimiter">(</span><a title="String" id="play.api.data;OptionalMapping.bind.$anonfun.p">p</a> =&gt; <a href="#play.api.data;OptionalMapping.bind.$anonfun.p" title="String">p</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#play.api.data;OptionalMapping.key" title="=&gt; String">key</a> <span title="(x: Boolean)Boolean">||</span> <a href="#play.api.data;OptionalMapping.bind.$anonfun.p" title="String">p</a>.<span title="(x$1: String)Boolean">startsWith</span><span class="delimiter">(</span><a href="#play.api.data;OptionalMapping.key" title="=&gt; String">key</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;.&quot;)" class="string">&quot;.&quot;</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#play.api.data;OptionalMapping.bind.$anonfun.p" title="String">p</a>.<span title="(x$1: String)Boolean">startsWith</span><span class="delimiter">(</span><a href="#play.api.data;OptionalMapping.key" title="=&gt; String">key</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;[&quot;)" class="string">&quot;[&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(f: String =&gt; Option[String])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[String],Option[String],Iterable[Option[String]]])Iterable[Option[String]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Iterable.Coll,Option[String],Iterable[Option[String]]]" class="delimiter">(</span><a title="String" id="play.api.data;OptionalMapping.bind.$anonfun.k">k</a> =&gt; <a href="#play.api.data;OptionalMapping.bind.data" title="Map[String,String]">data</a>.<span title="(key: String)Option[String]">get</span><span class="delimiter">(</span><a href="#play.api.data;OptionalMapping.bind.$anonfun.k" title="String">k</a><span class="delimiter">)</span>.<span title="(p: String =&gt; Boolean)Option[String]">filterNot</span><span class="delimiter">(</span><a href="#play.api.data;OptionalMapping.bind.$anonfun.$anonfun.x$29" title="String">_</a>.<span title="()Boolean">isEmpty</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(pf: PartialFunction[Option[String],String])(implicit bf: scala.collection.generic.CanBuildFrom[Iterable[Option[String]],String,Iterable[String]])Iterable[String]">collect</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[Option[String],String] with Serializable" id="play.api.data;OptionalMapping.bind;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> <span class="keyword">case</span> Some<span class="delimiter">(</span><a title="String" id="play.api.data;OptionalMapping.bind;$anonfun.isDefinedAt.v">v</a><span class="delimiter">)</span> =&gt; <a href="#play.api.data;OptionalMapping.bind;$anonfun.isDefinedAt.v" title="String">v</a> <span class="delimiter">}</span>.<span title="=&gt; Option[String]">headOption</span>.<span title="(f: String =&gt; Serializable with Product with scala.util.Either[Seq[play.api.data.FormError],Some[T]])Option[Serializable with Product with scala.util.Either[Seq[play.api.data.FormError],Some[T]]]">map</span> <span class="delimiter">{</span> <a title="String" id="play.api.data;OptionalMapping.bind.$anonfun.x$30">_</a> =&gt;
      <a href="#play.api.data;OptionalMapping.wrapped" title="=&gt; play.api.data.Mapping[T]">wrapped</a>.<a href="#play.api.data;Mapping.bind" title="(data: Map[String,String])Either[Seq[play.api.data.FormError],T]">bind</a><span class="delimiter">(</span><a href="#play.api.data;OptionalMapping.bind.data" title="Map[String,String]">data</a><span class="delimiter">)</span>.<span title="=&gt; scala.util.Either.RightProjection[Seq[play.api.data.FormError],T]">right</span>.<span title="(f: T =&gt; Some[T])Serializable with Product with scala.util.Either[Seq[play.api.data.FormError],Some[T]]">map</span><span class="delimiter">(</span><span title="(x: T)Some[T]">Some</span><span class="delimiter">(</span><a href="#play.api.data;OptionalMapping.bind.$anonfun.$anonfun.x$31" title="T">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>.<span title="(default: =&gt; Product with Serializable with scala.util.Either[Seq[play.api.data.FormError],Option[T]])Product with Serializable with scala.util.Either[Seq[play.api.data.FormError],Option[T]]">getOrElse</span> <span class="delimiter">{</span>
      <span title="(b: None.type)scala.util.Right[Nothing,None.type]">Right</span><span class="delimiter">(</span><span title="None.type">None</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>.<span title="=&gt; scala.util.Either.RightProjection[Seq[play.api.data.FormError],Option[T]]">right</span>.<span title="(f: Option[T] =&gt; scala.util.Either[Seq[play.api.data.FormError],Option[T]])scala.util.Either[Seq[play.api.data.FormError],Option[T]]">flatMap</span><span class="delimiter">(</span><a href="#play.api.data;Mapping.applyConstraints" title="(t: Option[T])Either[Seq[play.api.data.FormError],Option[T]]">applyConstraints</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Unbinds this field, i.e. transforms a concrete value to plain data.
   *
   * @param value the value to unbind
   * @return the plain data
   */</span>
  <span class="keyword">def</span> <a title="(value: Option[T])Map[String,String]" id="play.api.data;OptionalMapping.unbind">unbind</a><span class="delimiter">(</span><a title="Option[T]" id="play.api.data;OptionalMapping.unbind.value">value</a>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data;OptionalMapping.unbind.value" title="Option[T]">value</a>.<span title="(f: T =&gt; Map[String,String])Option[Map[String,String]]">map</span><span class="delimiter">(</span><a href="#play.api.data;OptionalMapping.wrapped" title="=&gt; play.api.data.Mapping[T]">wrapped</a>.<a href="#play.api.data;Mapping.unbind" title="(value: T)Map[String,String]">unbind</a><span class="delimiter">)</span>.<span title="(default: =&gt; Map[String,String])Map[String,String]">getOrElse</span><span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="scala.collection.immutable.Map[String,Nothing]">empty</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Unbinds this field, i.e. transforms a concrete value to plain data, and applies validation.
   *
   * @param value the value to unbind
   * @return the plain data and any errors in the plain data
   */</span>
  <span class="keyword">def</span> <a title="(value: Option[T])(Map[String,String], Seq[play.api.data.FormError])" id="play.api.data;OptionalMapping.unbindAndValidate">unbindAndValidate</a><span class="delimiter">(</span><a title="Option[T]" id="play.api.data;OptionalMapping.unbindAndValidate.value">value</a>: <span title="Option[T]">Option</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="(Map[String,String], Seq[play.api.data.FormError])" class="delimiter">(</span>Map<span class="delimiter">[</span>String, String<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Seq[play.api.data.FormError]" id="play.api.data;OptionalMapping.unbindAndValidate.errors">errors</a> = <a href="#play.api.data;Mapping.collectErrors" title="(t: Option[T])Seq[play.api.data.FormError]">collectErrors</a><span class="delimiter">(</span><a href="#play.api.data;OptionalMapping.unbindAndValidate.value" title="Option[T]">value</a><span class="delimiter">)</span>
    <a href="#play.api.data;OptionalMapping.unbindAndValidate.value" title="Option[T]">value</a>.<span title="(f: T =&gt; (Map[String,String], Seq[play.api.data.FormError]))Option[(Map[String,String], Seq[play.api.data.FormError])]">map</span><span class="delimiter">(</span><a href="#play.api.data;OptionalMapping.wrapped" title="=&gt; play.api.data.Mapping[T]">wrapped</a>.<a href="#play.api.data;Mapping.unbindAndValidate" title="(value: T)(Map[String,String], Seq[play.api.data.FormError])">unbindAndValidate</a><span class="delimiter">)</span>.<span title="(f: ((Map[String,String], Seq[play.api.data.FormError])) =&gt; (Map[String,String], Seq[play.api.data.FormError]))Option[(Map[String,String], Seq[play.api.data.FormError])]">map</span><span class="delimiter">(</span><a title="(Map[String,String], Seq[play.api.data.FormError])" id="play.api.data;OptionalMapping.unbindAndValidate.$anonfun.r">r</a> =&gt; <a href="#play.api.data;OptionalMapping.unbindAndValidate.$anonfun.r" title="(Map[String,String], Seq[play.api.data.FormError])">r</a>.<span title="(x: Map[String,String])ArrowAssoc[Map[String,String]]">_1</span> <span title="(y: Seq[play.api.data.FormError])(Map[String,String], Seq[play.api.data.FormError])">-&gt;</span> <span class="delimiter">(</span><a href="#play.api.data;OptionalMapping.unbindAndValidate.$anonfun.r" title="(Map[String,String], Seq[play.api.data.FormError])">r</a>.<span title="=&gt; Seq[play.api.data.FormError]">_2</span> <span title="(that: scala.collection.GenTraversableOnce[play.api.data.FormError])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[play.api.data.FormError],play.api.data.FormError,Seq[play.api.data.FormError]])Seq[play.api.data.FormError]">++</span> <a href="#play.api.data;OptionalMapping.unbindAndValidate.errors" title="Seq[play.api.data.FormError]">errors</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(default: =&gt; (Map[String,String], Seq[play.api.data.FormError]))(Map[String,String], Seq[play.api.data.FormError])">getOrElse</span><span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="(x: scala.collection.immutable.Map[String,Nothing])ArrowAssoc[scala.collection.immutable.Map[String,Nothing]]">empty</span> <span title="(y: Seq[play.api.data.FormError])(scala.collection.immutable.Map[String,Nothing], Seq[play.api.data.FormError])">-&gt;</span> <a href="#play.api.data;OptionalMapping.unbindAndValidate.errors" title="Seq[play.api.data.FormError]">errors</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Constructs a new Mapping based on this one, adding a prefix to the key.
   *
   * @param prefix the prefix to add to the key
   * @return the same mapping, with only the key changed
   */</span>
  <span class="keyword">def</span> <a title="(prefix: String)play.api.data.Mapping[Option[T]]" id="play.api.data;OptionalMapping.withPrefix">withPrefix</a><span class="delimiter">(</span><a title="String" id="play.api.data;OptionalMapping.withPrefix.prefix">prefix</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[Option[T]]">Mapping</a><span class="delimiter">[</span>Option<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data.OptionalMapping.readResolve" title="(wrapped: play.api.data.Mapping[T], constraints: Seq[play.api.data.validation.Constraint[Option[T]]])play.api.data.OptionalMapping[T]">copy</a><span class="delimiter">(</span>wrapped = <a href="#play.api.data;OptionalMapping.wrapped" title="=&gt; play.api.data.Mapping[T]">wrapped</a>.<a href="#play.api.data;Mapping.withPrefix" title="(prefix: String)play.api.data.Mapping[T]">withPrefix</a><span class="delimiter">(</span><a href="#play.api.data;OptionalMapping.withPrefix.prefix" title="String">prefix</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Sub-mappings (these can be seen as sub-keys). */</span>
  <span class="keyword">val</span> <a title="Seq[play.api.data.Mapping[_]]" id="play.api.data;OptionalMapping.mappings">mappings</a>: <span title="Seq[play.api.data.Mapping[_]]">Seq</span><span class="delimiter">[</span>Mapping<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#play.api.data;OptionalMapping.wrapped" title="=&gt; play.api.data.Mapping[T]">wrapped</a>.<a href="#play.api.data;Mapping.mappings" title="=&gt; Seq[play.api.data.Mapping[_]]">mappings</a>

<span class="delimiter">}</span>

<span class="comment">/**
 * A mapping for a single field.
 *
 * @param key the field key
 * @param constraints the constraints associated with this field.
 */</span>
<span class="keyword">case class</span> <a href="#play.api.data;FieldMapping.productElement.x$1" title="class FieldMapping[T] extends AnyRef with play.api.data.Mapping[T] with Product with Serializable" id="play.api.data.FieldMapping.readResolve">FieldMapping</a><span class="delimiter">[</span><a title="" id="play.api.data.FieldMapping.apply$default$2;T">T</a><span class="delimiter">]</span><a href="#play.api.data.FieldMapping.readResolve" title="Product" class="delimiter">(</a><span class="keyword">val</span> <a title="String" id="play.api.data.FieldMapping.apply$default$1">key</a>: <span title="String">String</span> = <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span class="keyword">val</span> <a title="Seq[play.api.data.validation.Constraint[T]]" id="play.api.data.FieldMapping.apply$default$2">constraints</a>: <span title="Seq[play.api.data.validation.Constraint[T]]">Seq</span><span class="delimiter">[</span>Constraint<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <span class="keyword">val</span> <a title="play.api.data.format.Formatter[T]" id="play.api.data;FieldMapping.binder">binder</a>: <a href="format/Format.scala.html#play.api.data.format;Formatter" title="play.api.data.format.Formatter[T]">Formatter</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#play.api.data;Mapping" title="play.api.data.Mapping[T]">Mapping</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>

  <span class="comment">/**
   * The Format expected for this field, if it exists.
   */</span>
  <span class="keyword">override</span> <span class="keyword">val</span> <a title="Option[(String, Seq[Any])]" id="play.api.data;FieldMapping.format">format</a>: <span title="Option[(String, Seq[Any])]">Option</span><span class="delimiter">[</span><span class="delimiter">(</span>String, Seq<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#play.api.data;FieldMapping.binder" title="=&gt; play.api.data.format.Formatter[T]">binder</a>.<a href="format/Format.scala.html#play.api.data.format;Formatter.format" title="=&gt; Option[(String, Seq[Any])]">format</a>

  <span class="comment">/**
   * Constructs a new Mapping based on this one, by adding new constraints.
   *
   * For example:
   * {{{
   *   import play.api.data._
   *   import validation.Constraints._
   *
   *   Form(&quot;phonenumber&quot; -&gt; text.verifying(required) )
   * }}}
   *
   * @param constraints the constraints to add
   * @return the new mapping
   */</span>
  <span class="keyword">def</span> <a title="(addConstraints: play.api.data.validation.Constraint[T]*)play.api.data.Mapping[T]" id="play.api.data;FieldMapping.verifying(9ec01a47d0)">verifying</a><span class="delimiter">(</span><a title="play.api.data.validation.Constraint[T]*" id="play.api.data;FieldMapping.verifying(9ec01a47d0).addConstraints">addConstraints</a>: <span title="play.api.data.validation.Constraint[T]*">Constraint</span><span class="delimiter">[</span>T<span class="delimiter">]</span>*<span class="delimiter">)</span>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[T]">Mapping</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data.FieldMapping.readResolve" title="FieldMapping.this.type" class="keyword">this</a>.<a href="#play.api.data.FieldMapping.apply$default$1" title="String" id="play.api.data;FieldMapping.verifying(9ec01a47d0).x$78">copy</a><a href="#play.api.data;FieldMapping.binder" title="=&gt; play.api.data.format.Formatter[T]" class="delimiter">(</a>constraints = <a href="#play.api.data.FieldMapping.apply$default$2" title="=&gt; Seq[play.api.data.validation.Constraint[T]]">constraints</a> <a title="Seq[play.api.data.validation.Constraint[T]] @scala.reflect.internal.annotations.uncheckedBounds" id="play.api.data;FieldMapping.verifying(9ec01a47d0).x$77">++</a> <a href="#play.api.data;FieldMapping.verifying(9ec01a47d0).addConstraints" title="play.api.data.validation.Constraint[T]*">addConstraints</a>.<span title="=&gt; Seq[play.api.data.validation.Constraint[T]]">toSeq</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Changes the binder used to handle this field.
   *
   * @param binder the new binder to use
   * @return the same mapping with a new binder
   */</span>
  <span class="keyword">def</span> <a title="(binder: play.api.data.format.Formatter[T])play.api.data.Mapping[T]" id="play.api.data;FieldMapping.as">as</a><span class="delimiter">(</span><a title="play.api.data.format.Formatter[T]" id="play.api.data;FieldMapping.as.binder">binder</a>: <a href="format/Format.scala.html#play.api.data.format;Formatter" title="play.api.data.format.Formatter[T]">Formatter</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[T]">Mapping</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data.FieldMapping.readResolve" title="FieldMapping.this.type" class="keyword">this</a>.<a href="#play.api.data.FieldMapping.readResolve" title="(key: String, constraints: Seq[play.api.data.validation.Constraint[T]])(implicit binder: play.api.data.format.Formatter[T])play.api.data.FieldMapping[T]">copy</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#play.api.data;FieldMapping.as.binder" title="play.api.data.format.Formatter[T]">binder</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Binds this field, i.e. constructs a concrete value from submitted data.
   *
   * @param data the submitted data
   * @return either a concrete value of type `T` or a set of errors, if binding failed
   */</span>
  <span class="keyword">def</span> <a title="(data: Map[String,String])Either[Seq[play.api.data.FormError],T]" id="play.api.data;FieldMapping.bind">bind</a><span class="delimiter">(</span><a title="Map[String,String]" id="play.api.data;FieldMapping.bind.data">data</a>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Either[Seq[play.api.data.FormError],T]">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span>, T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data;FieldMapping.binder" title="=&gt; play.api.data.format.Formatter[T]">binder</a>.<a href="format/Format.scala.html#play.api.data.format;Formatter.bind" title="(key: String, data: Map[String,String])Either[Seq[play.api.data.FormError],T]">bind</a><span class="delimiter">(</span><a href="#play.api.data.FieldMapping.apply$default$1" title="=&gt; String">key</a>, <a href="#play.api.data;FieldMapping.bind.data" title="Map[String,String]">data</a><span class="delimiter">)</span>.<span title="=&gt; scala.util.Either.RightProjection[Seq[play.api.data.FormError],T]">right</span>.<span title="(f: T =&gt; scala.util.Either[Seq[play.api.data.FormError],T])scala.util.Either[Seq[play.api.data.FormError],T]">flatMap</span> <span class="delimiter">{</span> <a href="#play.api.data;Mapping.applyConstraints" title="(t: T)Either[Seq[play.api.data.FormError],T]">applyConstraints</a><span class="delimiter">(</span><a href="#play.api.data;FieldMapping.bind.$anonfun.x$32" title="T">_</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Unbinds this field, i.e. transforms a concrete value to plain data.
   *
   * @param value the value to unbind
   * @return the plain data
   */</span>
  <span class="keyword">def</span> <a title="(value: T)Map[String,String]" id="play.api.data;FieldMapping.unbind">unbind</a><span class="delimiter">(</span><a title="T" id="play.api.data;FieldMapping.unbind.value">value</a>: <a href="#play.api.data.FieldMapping.apply$default$2;T" title="T">T</a><span class="delimiter">)</span>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data;FieldMapping.binder" title="=&gt; play.api.data.format.Formatter[T]">binder</a>.<a href="format/Format.scala.html#play.api.data.format;Formatter.unbind" title="(key: String, value: T)Map[String,String]">unbind</a><span class="delimiter">(</span><a href="#play.api.data.FieldMapping.apply$default$1" title="=&gt; String">key</a>, <a href="#play.api.data;FieldMapping.unbind.value" title="T">value</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Unbinds this field, i.e. transforms a concrete value to plain data, and applies validation.
   *
   * @param value the value to unbind
   * @return the plain data and any errors in the plain data
   */</span>
  <span class="keyword">def</span> <a title="(value: T)(Map[String,String], Seq[play.api.data.FormError])" id="play.api.data;FieldMapping.unbindAndValidate">unbindAndValidate</a><span class="delimiter">(</span><a title="T" id="play.api.data;FieldMapping.unbindAndValidate.value">value</a>: <a href="#play.api.data.FieldMapping.apply$default$2;T" title="T">T</a><span class="delimiter">)</span>: <span title="(Map[String,String], Seq[play.api.data.FormError])" class="delimiter">(</span>Map<span class="delimiter">[</span>String, String<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <a href="#play.api.data;FieldMapping.binder" title="=&gt; play.api.data.format.Formatter[T]">binder</a>.<a href="format/Format.scala.html#play.api.data.format;Formatter.unbind" title="(key: String, value: T)Map[String,String]">unbind</a><span title="(x: Map[String,String])ArrowAssoc[Map[String,String]]" class="delimiter">(</span><a href="#play.api.data.FieldMapping.apply$default$1" title="=&gt; String">key</a>, <a href="#play.api.data;FieldMapping.unbindAndValidate.value" title="T">value</a><span class="delimiter">)</span> <span title="(y: Seq[play.api.data.FormError])(Map[String,String], Seq[play.api.data.FormError])">-&gt;</span> <a href="#play.api.data;Mapping.collectErrors" title="(t: T)Seq[play.api.data.FormError]">collectErrors</a><span class="delimiter">(</span><a href="#play.api.data;FieldMapping.unbindAndValidate.value" title="T">value</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Constructs a new Mapping based on this one, adding a prefix to the key.
   *
   * @param prefix the prefix to add to the key
   * @return the same mapping, with only the key changed
   */</span>
  <span class="keyword">def</span> <a title="(prefix: String)play.api.data.Mapping[T]" id="play.api.data;FieldMapping.withPrefix">withPrefix</a><span class="delimiter">(</span><a title="String" id="play.api.data;FieldMapping.withPrefix.prefix">prefix</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#play.api.data;Mapping" title="play.api.data.Mapping[T]">Mapping</a><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <a href="#play.api.data;Mapping.addPrefix" title="(prefix: String)Option[String]">addPrefix</a><span class="delimiter">(</span><a href="#play.api.data;FieldMapping.withPrefix.prefix" title="String">prefix</a><span class="delimiter">)</span>.<span title="(f: String =&gt; play.api.data.FieldMapping[T])Option[play.api.data.FieldMapping[T]]">map</span><span class="delimiter">(</span><a title="String" id="play.api.data;FieldMapping.withPrefix.$anonfun.newKey">newKey</a> =&gt; <a href="#play.api.data.FieldMapping.readResolve" title="FieldMapping.this.type" class="keyword">this</a>.<a href="#play.api.data.FieldMapping.readResolve" title="(key: String, constraints: Seq[play.api.data.validation.Constraint[T]])(implicit binder: play.api.data.format.Formatter[T])play.api.data.FieldMapping[T]">copy</a><a href="#play.api.data;FieldMapping.binder" title="=&gt; play.api.data.format.Formatter[T]" class="delimiter">(</a>key = <a href="#play.api.data;FieldMapping.withPrefix.$anonfun.newKey" title="String">newKey</a><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(default: =&gt; play.api.data.FieldMapping[T])play.api.data.FieldMapping[T]">getOrElse</span><span class="delimiter">(</span><a href="#play.api.data.FieldMapping.readResolve" title="play.api.data.FieldMapping[T]" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Sub-mappings (these can be seen as sub-keys). */</span>
  <span class="keyword">val</span> <a title="Seq[play.api.data.Mapping[_]]" id="play.api.data;FieldMapping.mappings">mappings</a>: <span title="Seq[play.api.data.Mapping[_]]">Seq</span><span class="delimiter">[</span>Mapping<span class="delimiter">[</span>_<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(elems: play.api.data.FieldMapping[T]*)Seq[play.api.data.FieldMapping[T]]">Seq</span><span class="delimiter">(</span><a href="#play.api.data.FieldMapping.readResolve" title="play.api.data.FieldMapping[T]" class="keyword">this</a><span class="delimiter">)</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * Common helper methods for all object mappings - mappings including several fields.
 */</span>
<span class="keyword">trait</span> <a title="trait ObjectMapping extends AnyRef" id="play.api.data;ObjectMapping">ObjectMapping</a> <span title="Unit" class="delimiter">{</span>

  <span class="comment">/**
   * Merges the result of two bindings.
   *
   * @see bind()
   */</span>
  <span class="keyword">def</span> <a title="(a: Either[Seq[play.api.data.FormError],Seq[Any]], b: Either[Seq[play.api.data.FormError],Seq[Any]])Either[Seq[play.api.data.FormError],Seq[Any]]" id="play.api.data;ObjectMapping.merge2">merge2</a><span class="delimiter">(</span><span title="Either[Seq[play.api.data.FormError],Seq[Any]]">a</span>: <span title="Either[Seq[play.api.data.FormError],Seq[Any]]">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">]</span>, <span title="Either[Seq[play.api.data.FormError],Seq[Any]]">b</span>: <span title="Either[Seq[play.api.data.FormError],Seq[Any]]">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Either[Seq[play.api.data.FormError],Seq[Any]]">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">]</span> = <span title="(_1: Either[Seq[play.api.data.FormError],Seq[Any]], _2: Either[Seq[play.api.data.FormError],Seq[Any]])(Either[Seq[play.api.data.FormError],Seq[Any]], Either[Seq[play.api.data.FormError],Seq[Any]])" class="delimiter">(</span><span title="Either[Seq[play.api.data.FormError],Seq[Any]]">a</span>, <span title="Either[Seq[play.api.data.FormError],Seq[Any]]">b</span><span class="delimiter">)</span> <span title="Either[Seq[play.api.data.FormError],Seq[Any]]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span class="delimiter">(</span>Left<span class="delimiter">(</span><span title="Seq[play.api.data.FormError]">errorsA</span><span class="delimiter">)</span>, Left<span class="delimiter">(</span><span title="Seq[play.api.data.FormError]">errorsB</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="(a: Seq[play.api.data.FormError])scala.util.Left[Seq[play.api.data.FormError],Nothing]">Left</span><span class="delimiter">(</span><span title="Seq[play.api.data.FormError]">errorsA</span> <span title="(that: scala.collection.GenTraversableOnce[play.api.data.FormError])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[play.api.data.FormError],play.api.data.FormError,Seq[play.api.data.FormError]])Seq[play.api.data.FormError]">++</span> <span title="Seq[play.api.data.FormError]">errorsB</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span class="delimiter">(</span>Left<span class="delimiter">(</span><span title="Seq[play.api.data.FormError]">errorsA</span><span class="delimiter">)</span>, Right<span class="delimiter">(</span>_<span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="(a: Seq[play.api.data.FormError])scala.util.Left[Seq[play.api.data.FormError],Nothing]">Left</span><span class="delimiter">(</span><span title="Seq[play.api.data.FormError]">errorsA</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span class="delimiter">(</span>Right<span class="delimiter">(</span>_<span class="delimiter">)</span>, Left<span class="delimiter">(</span><span title="Seq[play.api.data.FormError]">errorsB</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="(a: Seq[play.api.data.FormError])scala.util.Left[Seq[play.api.data.FormError],Nothing]">Left</span><span class="delimiter">(</span><span title="Seq[play.api.data.FormError]">errorsB</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span class="delimiter">(</span>Right<span class="delimiter">(</span><span title="Seq[Any]">a</span><span class="delimiter">)</span>, Right<span class="delimiter">(</span><span title="Seq[Any]">b</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <span title="(b: Seq[Any])scala.util.Right[Nothing,Seq[Any]]">Right</span><span class="delimiter">(</span><span title="Seq[Any]">a</span> <span title="(that: scala.collection.GenTraversableOnce[Any])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Any],Any,Seq[Any]])Seq[Any]">++</span> <span title="Seq[Any]">b</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Merges the result of multiple bindings.
   *
   * @see bind()
   */</span>
  <span class="keyword">def</span> <a title="(results: Either[Seq[play.api.data.FormError],Any]*)Either[Seq[play.api.data.FormError],Seq[Any]]" id="play.api.data;ObjectMapping.merge">merge</a><span class="delimiter">(</span><a title="Either[Seq[play.api.data.FormError],Any]*" id="play.api.data;ObjectMapping.merge.results">results</a>: <span title="Either[Seq[play.api.data.FormError],Any]*">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span>, Any<span class="delimiter">]</span>*<span class="delimiter">)</span>: <span title="Either[Seq[play.api.data.FormError],Seq[Any]]">Either</span><span class="delimiter">[</span>Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Seq[Either[Seq[play.api.data.FormError],Seq[Any]]]" id="play.api.data;ObjectMapping.merge.all">all</a>: <span title="Seq[Either[Seq[play.api.data.FormError],Seq[Any]]]">Seq</span><span class="delimiter">[</span>Either<span class="delimiter">[</span>Seq<span class="delimiter">[</span>FormError<span class="delimiter">]</span>, Seq<span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <a href="#play.api.data;ObjectMapping.merge.results" title="Either[Seq[play.api.data.FormError],Any]*">results</a>.<span title="(f: Either[Seq[play.api.data.FormError],Any] =&gt; Serializable with Product with scala.util.Either[Seq[play.api.data.FormError],Seq[Any]])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[Either[Seq[play.api.data.FormError],Any]],Serializable with Product with scala.util.Either[Seq[play.api.data.FormError],Seq[Any]],Seq[Either[Seq[play.api.data.FormError],Seq[Any]]]])Seq[Either[Seq[play.api.data.FormError],Seq[Any]]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.Seq.Coll,Serializable with Product with scala.util.Either[Seq[play.api.data.FormError],Seq[Any]],Seq[Serializable with Product with scala.util.Either[Seq[play.api.data.FormError],Seq[Any]]]]" class="delimiter">(</span><a href="#play.api.data;ObjectMapping.merge.all.$anonfun.x$33" title="Either[Seq[play.api.data.FormError],Any]">_</a>.<span title="=&gt; scala.util.Either.RightProjection[Seq[play.api.data.FormError],Any]">right</span>.<span title="(f: Any =&gt; Seq[Any])Serializable with Product with scala.util.Either[Seq[play.api.data.FormError],Seq[Any]]">map</span><span class="delimiter">(</span><span title="(elems: Any*)Seq[Any]">Seq</span><span class="delimiter">(</span><a href="#play.api.data;ObjectMapping.merge.all.$anonfun.$anonfun.x$34" title="Any">_</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#play.api.data;ObjectMapping.merge.all" title="Seq[Either[Seq[play.api.data.FormError],Seq[Any]]]">all</a>.<span title="(z: Either[Seq[play.api.data.FormError],Seq[Any]])(op: (Either[Seq[play.api.data.FormError],Seq[Any]], Either[Seq[play.api.data.FormError],Seq[Any]]) =&gt; Either[Seq[play.api.data.FormError],Seq[Any]])Either[Seq[play.api.data.FormError],Seq[Any]]">fold</span><span class="delimiter">(</span><span title="(b: scala.collection.immutable.Nil.type)scala.util.Right[Nothing,scala.collection.immutable.Nil.type]">Right</span><span class="delimiter">(</span><span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="Either[Seq[play.api.data.FormError],Seq[Any]]" id="play.api.data;ObjectMapping.merge.$anonfun.s">s</a>, <a title="Either[Seq[play.api.data.FormError],Seq[Any]]" id="play.api.data;ObjectMapping.merge.$anonfun.i">i</a><span class="delimiter">)</span> =&gt; <a href="#play.api.data;ObjectMapping.merge2" title="(a: Either[Seq[play.api.data.FormError],Seq[Any]], b: Either[Seq[play.api.data.FormError],Seq[Any]])Either[Seq[play.api.data.FormError],Seq[Any]]">merge2</a><span class="delimiter">(</span><a href="#play.api.data;ObjectMapping.merge.$anonfun.s" title="Either[Seq[play.api.data.FormError],Seq[Any]]">s</a>, <a href="#play.api.data;ObjectMapping.merge.$anonfun.i" title="Either[Seq[play.api.data.FormError],Seq[Any]]">i</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
