<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>play/play/core/routing/PathPattern.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (C) 2009-2015 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
<span class="keyword">package</span> play.core.routing

<span class="keyword">import</span> java.net.URI

<span class="keyword">import</span> scala.util.control.Exception

<span class="comment">/**
 * A part of a path.
 */</span>
<span class="keyword">trait</span> <a title="trait PathPart extends AnyRef" id="play.core.routing;PathPart">PathPart</a>

<span class="comment">/**
 * A dynamically extracted part of the path.
 *
 * @param name The name of the part.
 * @param constraint The constraint - that is, the type.
 * @param encodeable Whether the path should be encoded/decoded.
 */</span>
<span title="AnyRef" class="keyword">case class</span> <a title="class DynamicPart extends AnyRef with play.core.routing.PathPart with Product with Serializable" id="play.core.routing.DynamicPart.readResolve">DynamicPart</a><a href="#play.core.routing.DynamicPart.readResolve" title="Product" class="delimiter">(</a><a title="String" id="play.core.routing;DynamicPart.name">name</a>: <span title="String">String</span>, <a title="String" id="play.core.routing;DynamicPart.constraint">constraint</a>: <span title="String">String</span>, <a title="Boolean" id="play.core.routing;DynamicPart.encodeable">encodeable</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#play.core.routing;PathPart" title="play.core.routing.PathPart">PathPart</a> <span class="delimiter">{</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="play.core.routing;DynamicPart.toString">toString</a> = <span title="String(&quot;DynamicPart(\&quot;&quot;)" class="string">&quot;&quot;&quot;DynamicPart(&quot;&quot;&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#play.core.routing;DynamicPart.name" title="=&gt; String">name</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\&quot;, \&quot;\&quot;\&quot;&quot;)" class="string">&quot;\&quot;, \&quot;\&quot;\&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#play.core.routing;DynamicPart.constraint" title="=&gt; String">constraint</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\&quot;\&quot;\&quot;)&quot;)" class="string">&quot;\&quot;\&quot;\&quot;)&quot;</span> <span class="comment">// &quot;</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * A static part of the path.
 */</span>
<span class="keyword">case class</span> <a title="class StaticPart extends AnyRef with play.core.routing.PathPart with Product with Serializable" id="play.core.routing.StaticPart.readResolve">StaticPart</a><a href="#play.core.routing.StaticPart.readResolve" title="Product" class="delimiter">(</a><a title="String" id="play.core.routing;StaticPart.value">value</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#play.core.routing;PathPart" title="play.core.routing.PathPart">PathPart</a> <span class="delimiter">{</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="play.core.routing;StaticPart.toString">toString</a> = <span title="String(&quot;StaticPart(\&quot;&quot;)" class="string">&quot;&quot;&quot;StaticPart(&quot;&quot;&quot;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#play.core.routing;StaticPart.value" title="=&gt; String">value</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\&quot;)&quot;)" class="string">&quot;&quot;&quot;&quot;)&quot;&quot;&quot;</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * A pattern for match paths, consisting of a sequence of path parts.
 */</span>
<span class="keyword">case class</span> <a title="class PathPattern extends AnyRef with Product with Serializable" id="play.core.routing.PathPattern.readResolve">PathPattern</a><a href="#play.core.routing.PathPattern.readResolve" title="Product" class="delimiter">(</a><a title="Seq[play.core.routing.PathPart]" id="play.core.routing;PathPattern.parts">parts</a>: <span title="Seq[play.core.routing.PathPart]">Seq</span><span class="delimiter">[</span>PathPart<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

  <span class="keyword">import</span> java.util.regex._

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(decode: Boolean, groupCount: Int)java.util.regex.Matcher =&gt; Either[Throwable,String]" id="play.core.routing;PathPattern.decodeIfEncoded">decodeIfEncoded</a><span class="delimiter">(</span><a title="Boolean" id="play.core.routing;PathPattern.decodeIfEncoded.decode">decode</a>: <span title="Boolean">Boolean</span>, <a title="Int" id="play.core.routing;PathPattern.decodeIfEncoded.groupCount">groupCount</a>: <span title="Int">Int</span><span class="delimiter">)</span>: Matcher =&gt; Either<span class="delimiter">[</span>Throwable, String<span class="delimiter">]</span> = <a title="java.util.regex.Matcher" id="play.core.routing;PathPattern.decodeIfEncoded.$anonfun.matcher">matcher</a> =&gt;
    <span title="scala.util.control.Exception.type">Exception</span>.<span title="[T]=&gt; scala.util.control.Exception.Catch[T]">allCatch</span><span title="scala.util.control.Exception.Catch[String]" class="delimiter">[</span><span title="String">String</span><span class="delimiter">]</span>.<span title="(body: =&gt; String)scala.util.Either[Throwable,String]">either</span> <span class="delimiter">{</span>
      <span title="String" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.core.routing;PathPattern.decodeIfEncoded.decode" title="Boolean">decode</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="String" id="play.core.routing;PathPattern.decodeIfEncoded.$anonfun.group">group</a> = <a href="#play.core.routing;PathPattern.decodeIfEncoded.$anonfun.matcher" title="java.util.regex.Matcher">matcher</a>.<span title="(x$1: Int)String">group</span><span class="delimiter">(</span><a href="#play.core.routing;PathPattern.decodeIfEncoded.groupCount" title="Int">groupCount</a><span class="delimiter">)</span>
        <span class="comment">// If param is not correctly encoded, get path will return null, so we prepend a / to it</span>
        <span title="java.net.URI" class="keyword">new</span> <span title="java.net.URI">URI</span><span class="delimiter">(</span><span title="String(&quot;/&quot;)" class="string">&quot;/&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#play.core.routing;PathPattern.decodeIfEncoded.$anonfun.group" title="String">group</a><span class="delimiter">)</span>.<span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps">getPath</span>.<span title="(n: Int)String">drop</span><span class="delimiter">(</span><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">else</span>
        <a href="#play.core.routing;PathPattern.decodeIfEncoded.$anonfun.matcher" title="java.util.regex.Matcher">matcher</a>.<span title="(x$1: Int)String">group</span><span class="delimiter">(</span><a href="#play.core.routing;PathPattern.decodeIfEncoded.groupCount" title="Int">groupCount</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="(java.util.regex.Pattern, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]])" id="play.core.routing;PathPattern.x$1" class="delimiter">(</a><a title="java.util.regex.Pattern" id="play.core.routing;PathPattern.regex">regex</a>, <a title="scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]]" id="play.core.routing;PathPattern.groups">groups</a><span class="delimiter">)</span> = <span class="delimiter">{</span>
    <span title="(x: (String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int))Some[(String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)]">Some</span><span class="delimiter">(</span><a href="#play.core.routing;PathPattern.parts" title="=&gt; Seq[play.core.routing.PathPart]">parts</a>.<span title="(z: (String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int))(op: ((String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int), play.core.routing.PathPart) =&gt; (String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int))(String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)">foldLeft</span><span title="(_1: String, _2: scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], _3: Int)(String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)" class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span>, <span title="=&gt; scala.collection.immutable.Map.type">Map</span>.<span title="[A, B]=&gt; scala.collection.immutable.Map[A,B]">empty</span><span title="scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]]" class="delimiter">[</span><span title="String">String</span>, Matcher =&gt; Either<span class="delimiter">[</span>Throwable, String<span class="delimiter">]</span><span class="delimiter">]</span>, <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="(String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)" id="play.core.routing;PathPattern.x$1.$anonfun.s">s</a>, <a title="play.core.routing.PathPart" id="play.core.routing;PathPattern.x$1.$anonfun.e">e</a><span class="delimiter">)</span> =&gt;
      <a href="#play.core.routing;PathPattern.x$1.$anonfun.e" title="play.core.routing.PathPart">e</a> <span title="(String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> StaticPart<span class="delimiter">(</span><a title="String" id="play.core.routing;PathPattern.x$1.$anonfun.p">p</a><span class="delimiter">)</span> =&gt; <span title="(_1: String, _2: scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], _3: Int)(String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)" class="delimiter">(</span><span class="delimiter">(</span><a href="#play.core.routing;PathPattern.x$1.$anonfun.s" title="(String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)">s</a>.<span title="=&gt; String">_1</span> <span title="(x$1: Any)String">+</span> <span title="java.util.regex.Pattern.type">Pattern</span>.<span title="(x$1: String)String">quote</span><span class="delimiter">(</span><a href="#play.core.routing;PathPattern.x$1.$anonfun.p" title="String">p</a><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#play.core.routing;PathPattern.x$1.$anonfun.s" title="(String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)">s</a>.<span title="=&gt; scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]]">_2</span>, <a href="#play.core.routing;PathPattern.x$1.$anonfun.s" title="(String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)">s</a>.<span title="=&gt; Int">_3</span><span class="delimiter">)</span>
        <span class="keyword">case</span> DynamicPart<span class="delimiter">(</span><a title="String" id="play.core.routing;PathPattern.x$1.$anonfun.k">k</a>, <span title="String">r</span>, <a title="Boolean" id="play.core.routing;PathPattern.x$1.$anonfun.encodeable">encodeable</a><span class="delimiter">)</span> =&gt; <span class="delimiter">{</span>
          <span title="(_1: String, _2: scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], _3: Int)(String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)" class="delimiter">(</span><span class="delimiter">(</span><a href="#play.core.routing;PathPattern.x$1.$anonfun.s" title="(String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)">s</a>.<span title="=&gt; String">_1</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;(&quot;)" class="string">&quot;(&quot;</span> <span title="(x$1: Any)String">+</span> <span title="String">r</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>,
            <span class="delimiter">(</span><a href="#play.core.routing;PathPattern.x$1.$anonfun.s" title="(String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)">s</a>.<span title="=&gt; scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]]">_2</span> <span title="(kv: (String, java.util.regex.Matcher =&gt; Either[Throwable,String]))scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]]">+</span> <span class="delimiter">(</span><a href="#play.core.routing;PathPattern.x$1.$anonfun.k" title="(x: String)ArrowAssoc[String]">k</a> <span title="(y: java.util.regex.Matcher =&gt; Either[Throwable,String])(String, java.util.regex.Matcher =&gt; Either[Throwable,String])">-&gt;</span> <a href="#play.core.routing;PathPattern.decodeIfEncoded" title="(decode: Boolean, groupCount: Int)java.util.regex.Matcher =&gt; Either[Throwable,String]">decodeIfEncoded</a><span class="delimiter">(</span><a href="#play.core.routing;PathPattern.x$1.$anonfun.encodeable" title="Boolean">encodeable</a>, <a href="#play.core.routing;PathPattern.x$1.$anonfun.s" title="(String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)">s</a>.<span title="=&gt; Int">_3</span> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
            <a href="#play.core.routing;PathPattern.x$1.$anonfun.s" title="(String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)">s</a>.<span title="=&gt; Int">_3</span> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span> <span title="(x: Int)Int">+</span> <span title="java.util.regex.Pattern.type">Pattern</span>.<span title="(x$1: String)java.util.regex.Pattern">compile</span><span class="delimiter">(</span><span title="String">r</span><span class="delimiter">)</span>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>.<span title="()Int">groupCount</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span><span class="delimiter">)</span>.<span title="(f: ((String, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]], Int)) =&gt; (java.util.regex.Pattern, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]]))Option[(java.util.regex.Pattern, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]])]">map</span> <a href="#play.core.routing;PathPattern.x$1.$anonfun.x0$1" title="(java.util.regex.Pattern, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]])" class="delimiter">{</a>
      <span class="keyword">case</span> <span class="delimiter">(</span><span title="String">r</span>, <a title="scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]]" id="play.core.routing;PathPattern.x$1.$anonfun.g">g</a>, _<span class="delimiter">)</span> =&gt; <span title="java.util.regex.Pattern.type">Pattern</span>.<span title="(x$1: String)java.util.regex.Pattern">compile</span><span title="(x: java.util.regex.Pattern)ArrowAssoc[java.util.regex.Pattern]" class="delimiter">(</span><span title="String(&quot;^&quot;)" class="string">&quot;^&quot;</span> <span title="(x$1: Any)String">+</span> <span title="String">r</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;$&quot;)" class="string">&quot;$&quot;</span><span class="delimiter">)</span> <span title="(y: scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]])(java.util.regex.Pattern, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]])">-&gt;</span> <a href="#play.core.routing;PathPattern.x$1.$anonfun.g" title="scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]]">g</a>
    <span class="delimiter">}</span>.<span title="=&gt; (java.util.regex.Pattern, scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]])">get</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Apply the path pattern to a given candidate path to see if it matches.
   *
   * @param path The path to match against.
   * @return The map of extracted parameters, or none if the path didn't match.
   */</span>
  <span class="keyword">def</span> <a title="(path: String)Option[Map[String,Either[Throwable,String]]]" id="play.core.routing;PathPattern.apply">apply</a><span class="delimiter">(</span><a title="String" id="play.core.routing;PathPattern.apply.path">path</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Option[Map[String,Either[Throwable,String]]]">Option</span><span class="delimiter">[</span>Map<span class="delimiter">[</span>String, Either<span class="delimiter">[</span>Throwable, String<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="java.util.regex.Matcher" id="play.core.routing;PathPattern.apply.matcher">matcher</a> = <a href="#play.core.routing;PathPattern.regex" title="=&gt; java.util.regex.Pattern">regex</a>.<span title="(x$1: CharSequence)java.util.regex.Matcher">matcher</span><span class="delimiter">(</span><a href="#play.core.routing;PathPattern.apply.path" title="String">path</a><span class="delimiter">)</span>
    <span title="Option[Map[String,Either[Throwable,String]]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.core.routing;PathPattern.apply.matcher" title="java.util.regex.Matcher">matcher</a>.<span title="()Boolean">matches</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(x: scala.collection.immutable.Map[String,Either[Throwable,String]])Some[scala.collection.immutable.Map[String,Either[Throwable,String]]]">Some</span><span class="delimiter">(</span><a href="#play.core.routing;PathPattern.groups" title="=&gt; scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]]">groups</a>.<span title="(f: ((String, java.util.regex.Matcher =&gt; Either[Throwable,String])) =&gt; (String, Either[Throwable,String]))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Map[String,java.util.regex.Matcher =&gt; Either[Throwable,String]],(String, Either[Throwable,String]),scala.collection.immutable.Map[String,Either[Throwable,String]]])scala.collection.immutable.Map[String,Either[Throwable,String]]">map</span> <a href="#play.core.routing;PathPattern.apply.$anonfun.x0$2" title="(String, Either[Throwable,String])" class="delimiter">{</a>
        <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="play.core.routing;PathPattern.apply.$anonfun.name">name</a>, <a title="java.util.regex.Matcher =&gt; Either[Throwable,String]" id="play.core.routing;PathPattern.apply.$anonfun.g">g</a><span class="delimiter">)</span> =&gt; <a href="#play.core.routing;PathPattern.apply.$anonfun.name" title="(x: String)ArrowAssoc[String]">name</a> <span title="(y: Either[Throwable,String])(String, Either[Throwable,String])">-&gt;</span> <a href="#play.core.routing;PathPattern.apply.$anonfun.g" title="(v1: java.util.regex.Matcher)Either[Throwable,String]">g</a><span class="delimiter">(</span><a href="#play.core.routing;PathPattern.apply.matcher" title="java.util.regex.Matcher">matcher</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>.<span title="(implicit ev: &lt;:&lt;[(String, Either[Throwable,String]),(String, Either[Throwable,String])])scala.collection.immutable.Map[String,Either[Throwable,String]]">toMap</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span title="None.type">None</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="play.core.routing;PathPattern.toString">toString</a> = <a href="#play.core.routing;PathPattern.parts" title="=&gt; Seq[play.core.routing.PathPart]">parts</a>.<span title="(f: play.core.routing.PathPart =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Seq[play.core.routing.PathPart],String,Seq[String]])Seq[String]">map</span> <a href="#play.core.routing;PathPattern.toString.$anonfun.x0$3" title="String" class="delimiter">{</a>
    <span class="keyword">case</span> DynamicPart<span class="delimiter">(</span><a title="String" id="play.core.routing;PathPattern.toString.$anonfun.name">name</a>, <a title="String" id="play.core.routing;PathPattern.toString.$anonfun.constraint">constraint</a>, _<span class="delimiter">)</span> =&gt; <span title="String(&quot;$&quot;)" class="string">&quot;$&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#play.core.routing;PathPattern.toString.$anonfun.name" title="String">name</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;&lt;&quot;)" class="string">&quot;&lt;&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#play.core.routing;PathPattern.toString.$anonfun.constraint" title="String">constraint</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;&gt;&quot;)" class="string">&quot;&gt;&quot;</span>
    <span class="keyword">case</span> StaticPart<span class="delimiter">(</span><a title="String" id="play.core.routing;PathPattern.toString.$anonfun.path">path</a><span class="delimiter">)</span> =&gt; <a href="#play.core.routing;PathPattern.toString.$anonfun.path" title="String">path</a>
  <span class="delimiter">}</span>.<span title="=&gt; String">mkString</span>

<span class="delimiter">}</span>

        </pre>
    </body>
</html>
