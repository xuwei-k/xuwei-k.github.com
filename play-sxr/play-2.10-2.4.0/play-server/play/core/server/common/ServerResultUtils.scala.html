<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>play-server/play/core/server/common/ServerResultUtils.scala</title>
        <script type="text/javascript" src="../../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (C) 2009-2015 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
<span class="keyword">package</span> play.core.server.common

<span class="keyword">import</span> play.api.mvc._
<span class="keyword">import</span> play.api.http.HttpProtocol
<span class="keyword">import</span> play.api.http.<a href="../../../../../play/play/api/http/StandardValues.scala.html#play.api.http.HeaderNames" title="play.api.http.HeaderNames.type">HeaderNames</a>._
<span class="keyword">import</span> play.api.libs.iteratee._
<span class="keyword">import</span> scala.concurrent.<span class="delimiter">{</span> Future, Promise <span class="delimiter">}</span>

<span class="keyword">object</span> <a title="play.core.server.common.ServerResultUtils.type" id="play.core.server.common.ServerResultUtils">ServerResultUtils</a> <a href="#play.core.server.common.ServerResultUtils" title="play.core.server.common.ServerResultUtils.type" class="delimiter">{</a>

  <span class="comment">/** Save allocation by caching an empty array */</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="Array[Byte]" id="play.core.server.common.ServerResultUtils.emptyBytes">emptyBytes</a> = <span title="Array[Byte]" class="keyword">new</span> <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Used to indicate that a result can't be streamed. Offers an
   * alternative result that can be sent instead.
   */</span>
  <span class="keyword">final</span> <span class="keyword">case class</span> <a title="class InvalidResult extends AnyRef with Product with Serializable" id="play.core.server.common.ServerResultUtils.InvalidResult.readResolve">InvalidResult</a><a href="#play.core.server.common.ServerResultUtils.InvalidResult.readResolve" title="Product" class="delimiter">(</a><a title="String" id="play.core.server.common.ServerResultUtils;InvalidResult.reason">reason</a>: <span title="String">String</span>, <a title="play.api.mvc.Result" id="play.core.server.common.ServerResultUtils;InvalidResult.alternativeResult">alternativeResult</a>: <a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result" title="play.api.mvc.Result">Result</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Indicates the streaming strategy to use for returning the response.
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait ResultStreaming extends AnyRef" id="play.core.server.common.ServerResultUtils;ResultStreaming">ResultStreaming</a>
  <span class="comment">/**
   * Used for responses that may not contain a body, e.g. 204 or 304 responses.
   * The server shouldn't send a body and, since the response cannot have a
   * body, the Content-Length header shouldn't be sent either.
   */</span>
  <span class="keyword">final</span> <span class="keyword">case object</span> <a href="#play.core.server.common.ServerResultUtils.StreamWithNoBody.productElement.x$1" title="play.core.server.common.ServerResultUtils.StreamWithNoBody.type" id="play.core.server.common.ServerResultUtils.StreamWithNoBody.readResolve">StreamWithNoBody</a> <span title="Product" class="keyword">extends</span> <a href="#play.core.server.common.ServerResultUtils;ResultStreaming" title="play.core.server.common.ServerResultUtils.ResultStreaming">ResultStreaming</a>
  <span class="comment">/**
   * Used for responses that have unknown length and should be delimited by
   * the connection closing. This is used for all HTTP 1.0 responses with
   * unknown length, since HTTP 1.0 doesn't support chunked encoding. It can
   * also be used for some HTTP 1.1 responses, if chunked encoding isn't
   * desired for some reason, e.g. see the `Results.feed` method.
   */</span>
  <span class="keyword">final</span> <span class="keyword">case class</span> <a title="class StreamWithClose extends AnyRef with play.core.server.common.ServerResultUtils.ResultStreaming with Product with Serializable" id="play.core.server.common.ServerResultUtils.StreamWithClose.readResolve">StreamWithClose</a><a href="#play.core.server.common.ServerResultUtils.StreamWithClose.readResolve" title="Product" class="delimiter">(</a><a title="play.api.libs.iteratee.Enumerator[Array[Byte]]" id="play.core.server.common.ServerResultUtils;StreamWithClose.enum">enum</a>: <a href="../../../../../play-iteratees/play/api/libs/iteratee/Enumerator.scala.html#play.api.libs.iteratee;Enumerator" title="play.api.libs.iteratee.Enumerator[Array[Byte]]">Enumerator</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#play.core.server.common.ServerResultUtils;ResultStreaming" title="play.core.server.common.ServerResultUtils.ResultStreaming">ResultStreaming</a>
  <span class="comment">/**
   * A stream with a known length where the Content-Length header can be
   * set.
   */</span>
  <span class="keyword">final</span> <span class="keyword">case class</span> <a title="class StreamWithKnownLength extends AnyRef with play.core.server.common.ServerResultUtils.ResultStreaming with Product with Serializable" id="play.core.server.common.ServerResultUtils.StreamWithKnownLength.readResolve">StreamWithKnownLength</a><a href="#play.core.server.common.ServerResultUtils.StreamWithKnownLength.readResolve" title="Product" class="delimiter">(</a><a title="play.api.libs.iteratee.Enumerator[Array[Byte]]" id="play.core.server.common.ServerResultUtils;StreamWithKnownLength.enum">enum</a>: <a href="../../../../../play-iteratees/play/api/libs/iteratee/Enumerator.scala.html#play.api.libs.iteratee;Enumerator" title="play.api.libs.iteratee.Enumerator[Array[Byte]]">Enumerator</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#play.core.server.common.ServerResultUtils;ResultStreaming" title="play.core.server.common.ServerResultUtils.ResultStreaming">ResultStreaming</a>
  <span class="comment">/**
   * A stream with bytes that are already entirely known. The Content-Length
   * can be sent and an efficient streaming strategy can be used by the server.
   */</span>
  <span class="keyword">final</span> <span class="keyword">case class</span> <a title="class StreamWithStrictBody extends AnyRef with play.core.server.common.ServerResultUtils.ResultStreaming with Product with Serializable" id="play.core.server.common.ServerResultUtils.StreamWithStrictBody.readResolve">StreamWithStrictBody</a><a href="#play.core.server.common.ServerResultUtils.StreamWithStrictBody.readResolve" title="Product" class="delimiter">(</a><a title="Array[Byte]" id="play.core.server.common.ServerResultUtils;StreamWithStrictBody.body">body</a>: <span title="Array[Byte]">Array</span><span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#play.core.server.common.ServerResultUtils;ResultStreaming" title="play.core.server.common.ServerResultUtils.ResultStreaming">ResultStreaming</a>
  <span class="comment">/**
   * A stream where the response has already been encoded by the user, e.g. using
   * `Results.chunked`. The server may be able to feed this encoded data directly -
   * or it may need to reverse the encoding before resending it. :(
   */</span>
  <span class="keyword">final</span> <span class="keyword">case class</span> <a title="class UseExistingTransferEncoding extends AnyRef with play.core.server.common.ServerResultUtils.ResultStreaming with Product with Serializable" id="play.core.server.common.ServerResultUtils.UseExistingTransferEncoding.readResolve">UseExistingTransferEncoding</a><a href="#play.core.server.common.ServerResultUtils.UseExistingTransferEncoding.readResolve" title="Product" class="delimiter">(</a><a title="play.api.libs.iteratee.Enumerator[Array[Byte]]" id="play.core.server.common.ServerResultUtils;UseExistingTransferEncoding.transferEncodedEnum">transferEncodedEnum</a>: <a href="../../../../../play-iteratees/play/api/libs/iteratee/Enumerator.scala.html#play.api.libs.iteratee;Enumerator" title="play.api.libs.iteratee.Enumerator[Array[Byte]]">Enumerator</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#play.core.server.common.ServerResultUtils;ResultStreaming" title="play.core.server.common.ServerResultUtils.ResultStreaming">ResultStreaming</a>
  <span class="comment">/**
   * A stream where the response should be chunk encoded. This is usually used for
   * an HTTP 1.1 connection where the response has unknown size.
   */</span>
  <span class="keyword">final</span> <span class="keyword">case class</span> <a title="class PerformChunkedTransferEncoding extends AnyRef with play.core.server.common.ServerResultUtils.ResultStreaming with Product with Serializable" id="play.core.server.common.ServerResultUtils.PerformChunkedTransferEncoding.readResolve">PerformChunkedTransferEncoding</a><a href="#play.core.server.common.ServerResultUtils.PerformChunkedTransferEncoding.readResolve" title="Product" class="delimiter">(</a><a title="play.api.libs.iteratee.Enumerator[Array[Byte]]" id="play.core.server.common.ServerResultUtils;PerformChunkedTransferEncoding.enum">enum</a>: <a href="../../../../../play-iteratees/play/api/libs/iteratee/Enumerator.scala.html#play.api.libs.iteratee;Enumerator" title="play.api.libs.iteratee.Enumerator[Array[Byte]]">Enumerator</a><span class="delimiter">[</span>Array<span class="delimiter">[</span>Byte<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#play.core.server.common.ServerResultUtils;ResultStreaming" title="play.core.server.common.ServerResultUtils.ResultStreaming">ResultStreaming</a>

  <span class="comment">/**
   * The connection header logic to use for the result.
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait ConnectionHeader extends AnyRef" id="play.core.server.common.ServerResultUtils;ConnectionHeader">ConnectionHeader</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="play.core.server.common.ServerResultUtils;ConnectionHeader.willClose">willClose</a>: <span title="Boolean">Boolean</span>
    <span class="keyword">def</span> <a title="=&gt; Option[String]" id="play.core.server.common.ServerResultUtils;ConnectionHeader.header">header</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * A `Connection: keep-alive` header should be sent. Used to
   * force an HTTP 1.0 connection to remain open.
   */</span>
  <span class="keyword">final</span> <span class="keyword">case object</span> <a href="#play.core.server.common.ServerResultUtils.SendKeepAlive.productElement.x$1" title="play.core.server.common.ServerResultUtils.SendKeepAlive.type" id="play.core.server.common.ServerResultUtils.SendKeepAlive.readResolve">SendKeepAlive</a> <span title="Product" class="keyword">extends</span> <a href="#play.core.server.common.ServerResultUtils;ConnectionHeader" title="play.core.server.common.ServerResultUtils.ConnectionHeader">ConnectionHeader</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="play.core.server.common.ServerResultUtils.SendKeepAlive.willClose">willClose</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Some[String]" id="play.core.server.common.ServerResultUtils.SendKeepAlive.header">header</a> = <span title="(x: String)Some[String]">Some</span><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.KEEP_ALIVE" title="=&gt; String">KEEP_ALIVE</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * A `Connection: close` header should be sent. Used to
   * force an HTTP 1.1 connection to close.
   */</span>
  <span class="keyword">final</span> <span class="keyword">case object</span> <a href="#play.core.server.common.ServerResultUtils.SendClose.productElement.x$1" title="play.core.server.common.ServerResultUtils.SendClose.type" id="play.core.server.common.ServerResultUtils.SendClose.readResolve">SendClose</a> <span title="Product" class="keyword">extends</span> <a href="#play.core.server.common.ServerResultUtils;ConnectionHeader" title="play.core.server.common.ServerResultUtils.ConnectionHeader">ConnectionHeader</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="play.core.server.common.ServerResultUtils.SendClose.willClose">willClose</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Some[String]" id="play.core.server.common.ServerResultUtils.SendClose.header">header</a> = <span title="(x: String)Some[String]">Some</span><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.CLOSE" title="=&gt; String">CLOSE</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * No `Connection` header should be sent. Used on an HTTP 1.0
   * connection where the default behavior is to close the connection.
   */</span>
  <span class="keyword">final</span> <span class="keyword">case object</span> <a href="#play.core.server.common.ServerResultUtils.DefaultClose.productElement.x$1" title="play.core.server.common.ServerResultUtils.DefaultClose.type" id="play.core.server.common.ServerResultUtils.DefaultClose.readResolve">DefaultClose</a> <span title="Product" class="keyword">extends</span> <a href="#play.core.server.common.ServerResultUtils;ConnectionHeader" title="play.core.server.common.ServerResultUtils.ConnectionHeader">ConnectionHeader</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="play.core.server.common.ServerResultUtils.DefaultClose.willClose">willClose</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; None.type" id="play.core.server.common.ServerResultUtils.DefaultClose.header">header</a> = <span title="None.type">None</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * No `Connection` header should be sent. Used on an HTTP 1.1
   * connection where the default behavior is to keep the connection
   * open.
   */</span>
  <span class="keyword">final</span> <span class="keyword">case object</span> <a href="#play.core.server.common.ServerResultUtils.DefaultKeepAlive.productElement.x$1" title="play.core.server.common.ServerResultUtils.DefaultKeepAlive.type" id="play.core.server.common.ServerResultUtils.DefaultKeepAlive.readResolve">DefaultKeepAlive</a> <span title="Product" class="keyword">extends</span> <a href="#play.core.server.common.ServerResultUtils;ConnectionHeader" title="play.core.server.common.ServerResultUtils.ConnectionHeader">ConnectionHeader</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="play.core.server.common.ServerResultUtils.DefaultKeepAlive.willClose">willClose</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; None.type" id="play.core.server.common.ServerResultUtils.DefaultKeepAlive.header">header</a> = <span title="None.type">None</span>
  <span class="delimiter">}</span>

  <span class="comment">// Values for the Connection header</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="String" id="play.core.server.common.ServerResultUtils.KEEP_ALIVE">KEEP_ALIVE</a> = <span title="String(&quot;keep-alive&quot;)" class="string">&quot;keep-alive&quot;</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="String" id="play.core.server.common.ServerResultUtils.CLOSE">CLOSE</a> = <span title="String(&quot;close&quot;)" class="string">&quot;close&quot;</span>

  <span class="comment">/**
   * Analyze the Result and determine how best to send it. This may involve looking at
   * headers, buffering the enumerator, etc. The returned value will indicate how to
   * stream the result and will provide an Enumerator or Array with the result body
   * that should be streamed.
   *
   * CannotStream will be returned if the Result cannot be
   * streamed to the given client. This can happen if a result requires Transfer-Encoding
   * but the client uses HTTP 1.0. It can also happen if there is an error in the
   * Result headers.
   *
   * The ConnectionHeader returned for a successful result will indicate how the
   * header should be set in the response header.
   */</span>
  <span class="keyword">def</span> <a title="(requestHeader: play.api.mvc.RequestHeader, result: play.api.mvc.Result)scala.concurrent.Future[Either[play.core.server.common.ServerResultUtils.InvalidResult,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]]" id="play.core.server.common.ServerResultUtils.determineResultStreaming">determineResultStreaming</a><span class="delimiter">(</span>
    <a title="play.api.mvc.RequestHeader" id="play.core.server.common.ServerResultUtils.determineResultStreaming.requestHeader">requestHeader</a>: <a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc;RequestHeader" title="play.api.mvc.RequestHeader">RequestHeader</a>,
    <a title="play.api.mvc.Result" id="play.core.server.common.ServerResultUtils.determineResultStreaming.result">result</a>: <a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result" title="play.api.mvc.Result">Result</a><span class="delimiter">)</span>: <span title="scala.concurrent.Future[Either[play.core.server.common.ServerResultUtils.InvalidResult,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]]">Future</span><span class="delimiter">[</span>Either<span class="delimiter">[</span>InvalidResult, <span class="delimiter">(</span>ResultStreaming, ConnectionHeader<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>

    <span class="comment">// The protocol version will affect how we stream the result and</span>
    <span class="comment">// the value of the Connection header that we set</span>
    <span class="keyword">val</span> <a title="Boolean" id="play.core.server.common.ServerResultUtils.determineResultStreaming.isHttp10">isHttp10</a> = <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.requestHeader" title="play.api.mvc.RequestHeader">requestHeader</a>.<a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc;RequestHeader.version" title="=&gt; String">version</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../../../play/play/api/http/StandardValues.scala.html#play.api.http.HttpProtocol" title="play.api.http.HttpProtocol.type">HttpProtocol</a>.<a href="../../../../../play/play/api/http/StandardValues.scala.html#play.api.http;HttpProtocol.HTTP_1_0" title="=&gt; String">HTTP_1_0</a>

    <span class="comment">// Work out whether we should close the connection after our response</span>
    <span class="keyword">val</span> <a title="Boolean" id="play.core.server.common.ServerResultUtils.determineResultStreaming.needsClose">needsClose</a>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
      <span class="comment">// Has the user has requested that the connection be closed?</span>
      <span class="keyword">val</span> <a title="Boolean" id="play.core.server.common.ServerResultUtils.determineResultStreaming.needsClose.forceClose">forceClose</a>: <span title="Boolean">Boolean</span> = <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.result" title="play.api.mvc.Result">result</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result.connection" title="=&gt; play.api.mvc.HttpConnection.Connection">connection</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc.HttpConnection" title="play.api.mvc.HttpConnection.type">HttpConnection</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc.HttpConnection.Close" title="=&gt; play.api.mvc.HttpConnection.Value">Close</a>
      <span class="comment">// Did the request we receive indicate whether the connection should be closed?</span>
      <span class="keyword">def</span> <a title="=&gt; Boolean" id="play.core.server.common.ServerResultUtils.determineResultStreaming.needsClose.defaultClose">defaultClose</a>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="Option[String]" id="play.core.server.common.ServerResultUtils.determineResultStreaming.needsClose.defaultClose.requestConnectionHeader">requestConnectionHeader</a>: <span title="Option[String]">Option</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.requestHeader" title="play.api.mvc.RequestHeader">requestHeader</a>.<a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc;RequestHeader.headers" title="=&gt; play.api.mvc.Headers">headers</a>.<a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc;Headers.get" title="(key: String)Option[String]">get</a><span class="delimiter">(</span><a href="../../../../../play/play/api/http/StandardValues.scala.html#play.api.http;HeaderNames.CONNECTION" title="=&gt; String">CONNECTION</a><span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="(value: String)Boolean" id="play.core.server.common.ServerResultUtils.determineResultStreaming.needsClose.defaultClose.requestConnectionHeaderMatches">requestConnectionHeaderMatches</a><span class="delimiter">(</span><a title="String" id="play.core.server.common.ServerResultUtils.determineResultStreaming.needsClose.defaultClose.requestConnectionHeaderMatches.value">value</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.needsClose.defaultClose.requestConnectionHeader" title="Option[String]">requestConnectionHeader</a>.<span title="(p: String =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.needsClose.defaultClose.requestConnectionHeaderMatches.$anonfun.x$1" title="String">_</a>.<span title="(x$1: String)Boolean">equalsIgnoreCase</span><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.needsClose.defaultClose.requestConnectionHeaderMatches.value" title="String">value</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.isHttp10" title="Boolean">isHttp10</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.needsClose.defaultClose.requestConnectionHeaderMatches" title="(value: String)Boolean">requestConnectionHeaderMatches</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.KEEP_ALIVE" title="=&gt; String">KEEP_ALIVE</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.isHttp10" title="Boolean">isHttp10</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.needsClose.defaultClose.requestConnectionHeaderMatches" title="(value: String)Boolean">requestConnectionHeaderMatches</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.CLOSE" title="=&gt; String">CLOSE</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
      <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.needsClose.forceClose" title="Boolean">forceClose</a> <span title="(x: Boolean)Boolean">||</span> <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.needsClose.defaultClose" title="=&gt; Boolean">defaultClose</a>
    <span class="delimiter">}</span>

    <span class="comment">// Get a Connection header to use that will close the connection or keep it alive,</span>
    <span class="comment">// depending on what we need to do.</span>
    <span class="keyword">val</span> <a title="play.core.server.common.ServerResultUtils.ConnectionHeader" id="play.core.server.common.ServerResultUtils.determineResultStreaming.connection">connection</a>: <a href="#play.core.server.common.ServerResultUtils;ConnectionHeader" title="play.core.server.common.ServerResultUtils.ConnectionHeader">ConnectionHeader</a> = <span class="delimiter">{</span>
      <span title="play.core.server.common.ServerResultUtils.ConnectionHeader" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.needsClose" title="Boolean">needsClose</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="play.core.server.common.ServerResultUtils.ConnectionHeader" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.isHttp10" title="Boolean">isHttp10</a><span class="delimiter">)</span> <a href="#play.core.server.common.ServerResultUtils.DefaultClose.readResolve" title="play.core.server.common.ServerResultUtils.DefaultClose.type">DefaultClose</a> <span class="keyword">else</span> <a href="#play.core.server.common.ServerResultUtils.SendClose.readResolve" title="play.core.server.common.ServerResultUtils.SendClose.type">SendClose</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <span title="play.core.server.common.ServerResultUtils.ConnectionHeader" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.isHttp10" title="Boolean">isHttp10</a><span class="delimiter">)</span> <a href="#play.core.server.common.ServerResultUtils.SendKeepAlive.readResolve" title="play.core.server.common.ServerResultUtils.SendKeepAlive.type">SendKeepAlive</a> <span class="keyword">else</span> <a href="#play.core.server.common.ServerResultUtils.DefaultKeepAlive.readResolve" title="play.core.server.common.ServerResultUtils.DefaultKeepAlive.type">DefaultKeepAlive</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">// Helpers for creating return values for this method</span>
    <span class="keyword">def</span> <a title="(reason: String, alternativeResult: play.api.mvc.Result)scala.concurrent.Future[Left[play.core.server.common.ServerResultUtils.InvalidResult,Nothing]]" id="play.core.server.common.ServerResultUtils.determineResultStreaming.invalid">invalid</a><span class="delimiter">(</span><a title="String" id="play.core.server.common.ServerResultUtils.determineResultStreaming.invalid.reason">reason</a>: <span title="String">String</span>, <a title="play.api.mvc.Result" id="play.core.server.common.ServerResultUtils.determineResultStreaming.invalid.alternativeResult">alternativeResult</a>: <a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result" title="play.api.mvc.Result">Result</a><span class="delimiter">)</span>: <span title="scala.concurrent.Future[Left[play.core.server.common.ServerResultUtils.InvalidResult,Nothing]]">Future</span><span class="delimiter">[</span>Left<span class="delimiter">[</span>InvalidResult, Nothing<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span title="scala.concurrent.Future.type">Future</span>.<span title="(result: scala.util.Left[play.core.server.common.ServerResultUtils.InvalidResult,Nothing])scala.concurrent.Future[scala.util.Left[play.core.server.common.ServerResultUtils.InvalidResult,Nothing]]">successful</span><span class="delimiter">(</span><span title="(a: play.core.server.common.ServerResultUtils.InvalidResult)scala.util.Left[play.core.server.common.ServerResultUtils.InvalidResult,Nothing]">Left</span><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.InvalidResult.readResolve" title="(reason: String, alternativeResult: play.api.mvc.Result)play.core.server.common.ServerResultUtils.InvalidResult">InvalidResult</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.invalid.reason" title="String">reason</a>, <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.invalid.alternativeResult" title="play.api.mvc.Result">alternativeResult</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">def</span> <a title="(streaming: play.core.server.common.ServerResultUtils.ResultStreaming, connection: play.core.server.common.ServerResultUtils.ConnectionHeader)scala.concurrent.Future[Right[Nothing,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]]" id="play.core.server.common.ServerResultUtils.determineResultStreaming.valid">valid</a><span class="delimiter">(</span><a title="play.core.server.common.ServerResultUtils.ResultStreaming" id="play.core.server.common.ServerResultUtils.determineResultStreaming.valid.streaming">streaming</a>: <a href="#play.core.server.common.ServerResultUtils;ResultStreaming" title="play.core.server.common.ServerResultUtils.ResultStreaming">ResultStreaming</a>, <a title="play.core.server.common.ServerResultUtils.ConnectionHeader" id="play.core.server.common.ServerResultUtils.determineResultStreaming.valid.connection">connection</a>: <a href="#play.core.server.common.ServerResultUtils;ConnectionHeader" title="play.core.server.common.ServerResultUtils.ConnectionHeader">ConnectionHeader</a><span class="delimiter">)</span>: <span title="scala.concurrent.Future[Right[Nothing,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]]">Future</span><span class="delimiter">[</span>Right<span class="delimiter">[</span>Nothing, <span class="delimiter">(</span>ResultStreaming, ConnectionHeader<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span title="scala.concurrent.Future.type">Future</span>.<span title="(result: scala.util.Right[Nothing,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)])scala.concurrent.Future[scala.util.Right[Nothing,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]]">successful</span><span class="delimiter">(</span><span title="(b: (play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader))scala.util.Right[Nothing,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]">Right</span><span class="delimiter">(</span><span title="(_1: play.core.server.common.ServerResultUtils.ResultStreaming, _2: play.core.server.common.ServerResultUtils.ConnectionHeader)(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)" class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.valid.streaming" title="play.core.server.common.ServerResultUtils.ResultStreaming">streaming</a>, <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.valid.connection" title="play.core.server.common.ServerResultUtils.ConnectionHeader">connection</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.result" title="play.api.mvc.Result">result</a> <span title="scala.concurrent.Future[Either[play.core.server.common.ServerResultUtils.InvalidResult,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]]" class="keyword">match</span> <span class="delimiter">{</span>

      <span class="comment">// Check if the header has invalid values</span>
      <span class="keyword">case</span> _ <span class="keyword">if</span> <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.result" title="play.api.mvc.Result">result</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result.header" title="=&gt; play.api.mvc.ResponseHeader">header</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;ResponseHeader.headers" title="=&gt; Map[String,String]">headers</a>.<span title="(p: ((String, String)) =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.$anonfun.x$2" title="(String, String)">_</a>.<span title="=&gt; String">_2</span> <span title="(x$1: AnyRef)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> =&gt;
        <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.invalid" title="(reason: String, alternativeResult: play.api.mvc.Result)scala.concurrent.Future[Left[play.core.server.common.ServerResultUtils.InvalidResult,Nothing]]">invalid</a><span class="delimiter">(</span>
          <span title="String(&quot;A header was set to null&quot;)" class="string">&quot;A header was set to null&quot;</span>,
          <a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc.Results" title="play.api.mvc.Results.type">Results</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Results;Status.apply" title="(content: String)(implicit writeable: play.api.http.Writeable[String])play.api.mvc.Result">InternalServerError</a><a href="../../../../../play/play/api/http/Writeable.scala.html#play.api.http;DefaultWriteables.wString" title="implicit play.api.http.DefaultWriteables.wString : (implicit codec: play.api.mvc.Codec)play.api.http.Writeable[String]" class="delimiter">(</a><span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>

      <span class="comment">// The HTTP spec requires that some responses don't have a body</span>
      <span class="keyword">case</span> _ <span class="keyword">if</span> <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.result" title="play.api.mvc.Result">result</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result.header" title="=&gt; play.api.mvc.ResponseHeader">header</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;ResponseHeader.status" title="=&gt; Int">status</a> <span title="(x: Int)Boolean">==</span> <span title="Int(204)" class="int">204</span> <span title="(x: Boolean)Boolean">||</span> <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.result" title="play.api.mvc.Result">result</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result.header" title="=&gt; play.api.mvc.ResponseHeader">header</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;ResponseHeader.status" title="=&gt; Int">status</a> <span title="(x: Int)Boolean">==</span> <span title="Int(304)" class="int">304</span> =&gt;
        <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.valid" title="(streaming: play.core.server.common.ServerResultUtils.ResultStreaming, connection: play.core.server.common.ServerResultUtils.ConnectionHeader)scala.concurrent.Future[Right[Nothing,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]]">valid</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.StreamWithNoBody.readResolve" title="play.core.server.common.ServerResultUtils.StreamWithNoBody.type">StreamWithNoBody</a>, <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.connection" title="play.core.server.common.ServerResultUtils.ConnectionHeader">connection</a><span class="delimiter">)</span>

      <span class="comment">// Check if the user has already transfer encoded the response</span>
      <span class="keyword">case</span> _ <span class="keyword">if</span> <span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.result" title="play.api.mvc.Result">result</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result.header" title="=&gt; play.api.mvc.ResponseHeader">header</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;ResponseHeader.headers" title="=&gt; Map[String,String]">headers</a>.<span title="(key: String)Boolean">contains</span><span class="delimiter">(</span><a href="../../../../../play/play/api/http/StandardValues.scala.html#play.api.http;HeaderNames.TRANSFER_ENCODING" title="=&gt; String">TRANSFER_ENCODING</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <span title="scala.concurrent.Future[Either[play.core.server.common.ServerResultUtils.InvalidResult,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.isHttp10" title="Boolean">isHttp10</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.invalid" title="(reason: String, alternativeResult: play.api.mvc.Result)scala.concurrent.Future[Left[play.core.server.common.ServerResultUtils.InvalidResult,Nothing]]">invalid</a><span class="delimiter">(</span>
            <span title="String(&quot;Chunked response to HTTP/1.0 request&quot;)" class="string">&quot;Chunked response to HTTP/1.0 request&quot;</span>,
            <a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc.Results" title="play.api.mvc.Results.type">Results</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Results;Status.apply" title="(content: String)(implicit writeable: play.api.http.Writeable[String])play.api.mvc.Result">HttpVersionNotSupported</a><a href="../../../../../play/play/api/http/Writeable.scala.html#play.api.http;DefaultWriteables.wString" title="implicit play.api.http.DefaultWriteables.wString : (implicit codec: play.api.mvc.Codec)play.api.http.Writeable[String]" class="delimiter">(</a><span title="String(&quot;The response to this request is chunked and hence requires HTTP 1.1 to be sent, but this is a HTTP 1.0 request.&quot;)" class="string">&quot;The response to this request is chunked and hence requires HTTP 1.1 to be sent, but this is a HTTP 1.0 request.&quot;</span><span class="delimiter">)</span>
          <span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.valid" title="(streaming: play.core.server.common.ServerResultUtils.ResultStreaming, connection: play.core.server.common.ServerResultUtils.ConnectionHeader)scala.concurrent.Future[Right[Nothing,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]]">valid</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.UseExistingTransferEncoding.readResolve" title="(transferEncodedEnum: play.api.libs.iteratee.Enumerator[Array[Byte]])play.core.server.common.ServerResultUtils.UseExistingTransferEncoding">UseExistingTransferEncoding</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.result" title="play.api.mvc.Result">result</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result.body" title="=&gt; play.api.libs.iteratee.Enumerator[Array[Byte]]">body</a><span class="delimiter">)</span>, <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.connection" title="play.core.server.common.ServerResultUtils.ConnectionHeader">connection</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>

      <span class="comment">// Check if the result has a known length</span>
      <span class="keyword">case</span> _ <span class="keyword">if</span> <span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.result" title="play.api.mvc.Result">result</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result.header" title="=&gt; play.api.mvc.ResponseHeader">header</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;ResponseHeader.headers" title="=&gt; Map[String,String]">headers</a>.<span title="(key: String)Boolean">contains</span><span class="delimiter">(</span><a href="../../../../../play/play/api/http/StandardValues.scala.html#play.api.http;HeaderNames.CONTENT_LENGTH" title="=&gt; String">CONTENT_LENGTH</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
        <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.valid" title="(streaming: play.core.server.common.ServerResultUtils.ResultStreaming, connection: play.core.server.common.ServerResultUtils.ConnectionHeader)scala.concurrent.Future[Right[Nothing,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]]">valid</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.StreamWithKnownLength.readResolve" title="(enum: play.api.libs.iteratee.Enumerator[Array[Byte]])play.core.server.common.ServerResultUtils.StreamWithKnownLength">StreamWithKnownLength</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.result" title="play.api.mvc.Result">result</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result.body" title="=&gt; play.api.libs.iteratee.Enumerator[Array[Byte]]">body</a><span class="delimiter">)</span>, <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.connection" title="play.core.server.common.ServerResultUtils.ConnectionHeader">connection</a><span class="delimiter">)</span>

      <span class="comment">// Check if the connection is required to close (if so we don't need to</span>
      <span class="comment">// worry about chunking the response)</span>
      <span class="keyword">case</span> _ <span class="keyword">if</span> <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.connection" title="play.core.server.common.ServerResultUtils.ConnectionHeader">connection</a>.<a href="#play.core.server.common.ServerResultUtils;ConnectionHeader.willClose" title="=&gt; Boolean">willClose</a> =&gt;
        <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.valid" title="(streaming: play.core.server.common.ServerResultUtils.ResultStreaming, connection: play.core.server.common.ServerResultUtils.ConnectionHeader)scala.concurrent.Future[Right[Nothing,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]]">valid</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.StreamWithClose.readResolve" title="(enum: play.api.libs.iteratee.Enumerator[Array[Byte]])play.core.server.common.ServerResultUtils.StreamWithClose">StreamWithClose</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.result" title="play.api.mvc.Result">result</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result.body" title="=&gt; play.api.libs.iteratee.Enumerator[Array[Byte]]">body</a><span class="delimiter">)</span>, <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.connection" title="play.core.server.common.ServerResultUtils.ConnectionHeader">connection</a><span class="delimiter">)</span>

      <span class="comment">// Read ahead one element and see if we can send the body</span>
      <span class="comment">// in one element, or if we need to chunk it, or if we need</span>
      <span class="comment">// to stream it and then close the connection</span>
      <span class="keyword">case</span> _ =&gt;
        <span class="keyword">import</span> play.api.libs.iteratee.<a href="../../../../../play-iteratees/play/api/libs/iteratee/Execution.scala.html#play.api.libs.iteratee.Execution" title="play.api.libs.iteratee.Execution.type">Execution</a>.<a href="../../../../../play-iteratees/play/api/libs/iteratee/Execution.scala.html#play.api.libs.iteratee.Execution.Implicits" title="play.api.libs.iteratee.Execution.Implicits.type">Implicits</a>.trampoline
        <span class="keyword">val</span> <a title="scala.concurrent.Future[Either[Option[Array[Byte]],play.api.libs.iteratee.Enumerator[Array[Byte]]]]" id="play.core.server.common.ServerResultUtils.determineResultStreaming.bodyReadAhead">bodyReadAhead</a> = <a href="#play.core.server.common.ServerResultUtils.readAheadOne" title="(enum: play.api.libs.iteratee.Enumerator[Array[Byte]])scala.concurrent.Future[Either[Option[Array[Byte]],play.api.libs.iteratee.Enumerator[Array[Byte]]]]">readAheadOne</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.result" title="play.api.mvc.Result">result</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result.body" title="=&gt; play.api.libs.iteratee.Enumerator[Array[Byte]]">body</a> <a href="../../../../../play-iteratees/play/api/libs/iteratee/Enumerator.scala.html#play.api.libs.iteratee;Enumerator.>>>" title="(e: play.api.libs.iteratee.Enumerator[Array[Byte]])play.api.libs.iteratee.Enumerator[Array[Byte]]">&gt;&gt;&gt;</a> <a href="../../../../../play-iteratees/play/api/libs/iteratee/Enumerator.scala.html#play.api.libs.iteratee.Enumerator" title="play.api.libs.iteratee.Enumerator.type">Enumerator</a>.<a href="../../../../../play-iteratees/play/api/libs/iteratee/Enumerator.scala.html#play.api.libs.iteratee.Enumerator.eof" title="enumInput extends AnyRef with play.api.libs.iteratee.Enumerator[Array[Byte]]">eof</a><span class="delimiter">)</span>
        <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.bodyReadAhead" title="scala.concurrent.Future[Either[Option[Array[Byte]],play.api.libs.iteratee.Enumerator[Array[Byte]]]]">bodyReadAhead</a>.<span title="(f: Either[Option[Array[Byte]],play.api.libs.iteratee.Enumerator[Array[Byte]]] =&gt; Either[play.core.server.common.ServerResultUtils.InvalidResult,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)])(implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[Either[play.core.server.common.ServerResultUtils.InvalidResult,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]]">map</span> <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.$anonfun.x0$1" title="Either[play.core.server.common.ServerResultUtils.InvalidResult,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]" class="delimiter">{</a>
          <span class="keyword">case</span> Left<span class="delimiter">(</span><a title="Option[Array[Byte]]" id="play.core.server.common.ServerResultUtils.determineResultStreaming.$anonfun.bodyOption">bodyOption</a><span class="delimiter">)</span> =&gt;
            <span class="keyword">val</span> <a title="Array[Byte]" id="play.core.server.common.ServerResultUtils.determineResultStreaming.$anonfun.body">body</a> = <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.$anonfun.bodyOption" title="Option[Array[Byte]]">bodyOption</a>.<span title="(default: =&gt; Array[Byte])Array[Byte]">getOrElse</span><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.emptyBytes" title="=&gt; Array[Byte]">emptyBytes</a><span class="delimiter">)</span>
            <span title="(b: (play.core.server.common.ServerResultUtils.StreamWithStrictBody, play.core.server.common.ServerResultUtils.ConnectionHeader))scala.util.Right[Nothing,(play.core.server.common.ServerResultUtils.StreamWithStrictBody, play.core.server.common.ServerResultUtils.ConnectionHeader)]">Right</span><span class="delimiter">(</span><span title="(_1: play.core.server.common.ServerResultUtils.StreamWithStrictBody, _2: play.core.server.common.ServerResultUtils.ConnectionHeader)(play.core.server.common.ServerResultUtils.StreamWithStrictBody, play.core.server.common.ServerResultUtils.ConnectionHeader)" class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.StreamWithStrictBody.readResolve" title="(body: Array[Byte])play.core.server.common.ServerResultUtils.StreamWithStrictBody">StreamWithStrictBody</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.$anonfun.body" title="Array[Byte]">body</a><span class="delimiter">)</span>, <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.connection" title="play.core.server.common.ServerResultUtils.ConnectionHeader">connection</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">case</span> Right<span class="delimiter">(</span><a title="play.api.libs.iteratee.Enumerator[Array[Byte]]" id="play.core.server.common.ServerResultUtils.determineResultStreaming.$anonfun.bodyEnum">bodyEnum</a><span class="delimiter">)</span> =&gt;
            <span class="comment">// Use chunked encoding for HTTP 1.1. For HTTP 1.0</span>
            <span class="comment">// delimit the end of the result by closing the</span>
            <span class="comment">// connection.</span>
            <span title="Either[play.core.server.common.ServerResultUtils.InvalidResult,(play.core.server.common.ServerResultUtils.ResultStreaming, play.core.server.common.ServerResultUtils.ConnectionHeader)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.isHttp10" title="Boolean">isHttp10</a><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span title="(b: (play.core.server.common.ServerResultUtils.StreamWithClose, play.core.server.common.ServerResultUtils.DefaultClose.type))scala.util.Right[Nothing,(play.core.server.common.ServerResultUtils.StreamWithClose, play.core.server.common.ServerResultUtils.DefaultClose.type)]">Right</span><span class="delimiter">(</span><span title="(_1: play.core.server.common.ServerResultUtils.StreamWithClose, _2: play.core.server.common.ServerResultUtils.DefaultClose.type)(play.core.server.common.ServerResultUtils.StreamWithClose, play.core.server.common.ServerResultUtils.DefaultClose.type)" class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.StreamWithClose.readResolve" title="(enum: play.api.libs.iteratee.Enumerator[Array[Byte]])play.core.server.common.ServerResultUtils.StreamWithClose">StreamWithClose</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.$anonfun.bodyEnum" title="play.api.libs.iteratee.Enumerator[Array[Byte]]">bodyEnum</a><span class="delimiter">)</span>, <a href="#play.core.server.common.ServerResultUtils.DefaultClose.readResolve" title="play.core.server.common.ServerResultUtils.DefaultClose.type">DefaultClose</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <span title="(b: (play.core.server.common.ServerResultUtils.PerformChunkedTransferEncoding, play.core.server.common.ServerResultUtils.ConnectionHeader))scala.util.Right[Nothing,(play.core.server.common.ServerResultUtils.PerformChunkedTransferEncoding, play.core.server.common.ServerResultUtils.ConnectionHeader)]">Right</span><span class="delimiter">(</span><span title="(_1: play.core.server.common.ServerResultUtils.PerformChunkedTransferEncoding, _2: play.core.server.common.ServerResultUtils.ConnectionHeader)(play.core.server.common.ServerResultUtils.PerformChunkedTransferEncoding, play.core.server.common.ServerResultUtils.ConnectionHeader)" class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.PerformChunkedTransferEncoding.readResolve" title="(enum: play.api.libs.iteratee.Enumerator[Array[Byte]])play.core.server.common.ServerResultUtils.PerformChunkedTransferEncoding">PerformChunkedTransferEncoding</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.$anonfun.bodyEnum" title="play.api.libs.iteratee.Enumerator[Array[Byte]]">bodyEnum</a><span class="delimiter">)</span>, <a href="#play.core.server.common.ServerResultUtils.determineResultStreaming.connection" title="play.core.server.common.ServerResultUtils.ConnectionHeader">connection</a><span class="delimiter">)</span><span class="delimiter">)</span>
            <span class="delimiter">}</span>
        <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  <span class="comment">/**
   * Start reading an Enumerator and see if it is only zero or one
   * elements long.
   * - If zero-length, return Left(None).
   * - If one-length, return the element in Left(Some(el))
   * - If more than one element long, return Right(enumerator) where
   *   enumerator is an Enumerator that contains *all* the input. Any
   *   already-read elements will still be included in this Enumerator.
   */</span>
  <span class="keyword">def</span> <a title="[A](enum: play.api.libs.iteratee.Enumerator[A])scala.concurrent.Future[Either[Option[A],play.api.libs.iteratee.Enumerator[A]]]" id="play.core.server.common.ServerResultUtils.readAheadOne">readAheadOne</a><span class="delimiter">[</span><a title="" id="play.core.server.common.ServerResultUtils.readAheadOne;A">A</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="play.api.libs.iteratee.Enumerator[A]" id="play.core.server.common.ServerResultUtils.readAheadOne.enum">enum</a>: <a href="../../../../../play-iteratees/play/api/libs/iteratee/Enumerator.scala.html#play.api.libs.iteratee;Enumerator" title="play.api.libs.iteratee.Enumerator[A]">Enumerator</a><span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scala.concurrent.Future[Either[Option[A],play.api.libs.iteratee.Enumerator[A]]]">Future</span><span class="delimiter">[</span>Either<span class="delimiter">[</span>Option<span class="delimiter">[</span>A<span class="delimiter">]</span>, Enumerator<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">import</span> <a href="../../../../../play-iteratees/play/api/libs/iteratee/Execution.scala.html#play.api.libs.iteratee.Execution" title="play.api.libs.iteratee.Execution.type">Execution</a>.<a href="../../../../../play-iteratees/play/api/libs/iteratee/Execution.scala.html#play.api.libs.iteratee.Execution.Implicits" title="play.api.libs.iteratee.Execution.Implicits.type">Implicits</a>.trampoline
    <span class="keyword">val</span> <a title="scala.concurrent.Promise[Either[Option[A],play.api.libs.iteratee.Enumerator[A]]]" id="play.core.server.common.ServerResultUtils.readAheadOne.result">result</a> = <span title="[T]()scala.concurrent.Promise[T]">Promise</span><span title="()scala.concurrent.Promise[Either[Option[A],play.api.libs.iteratee.Enumerator[A]]]" class="delimiter">[</span><span title="Either[Option[A],play.api.libs.iteratee.Enumerator[A]]">Either</span><span class="delimiter">[</span>Option<span class="delimiter">[</span>A<span class="delimiter">]</span>, Enumerator<span class="delimiter">[</span>A<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="play.api.libs.iteratee.Iteratee[A,Unit]" id="play.core.server.common.ServerResultUtils.readAheadOne.it">it</a>: <a href="../../../../../play-iteratees/play/api/libs/iteratee/Iteratee.scala.html#play.api.libs.iteratee;Iteratee" title="play.api.libs.iteratee.Iteratee[A,Unit]">Iteratee</a><span class="delimiter">[</span>A, Unit<span class="delimiter">]</span> = <span class="keyword">for</span> <span class="delimiter">{</span>
      <a title="Seq[A]" id="play.core.server.common.ServerResultUtils.readAheadOne.it.$anonfun.taken">taken</a> &lt;- <a href="../../../../../play-iteratees/play/api/libs/iteratee/Iteratee.scala.html#play.api.libs.iteratee.Iteratee" title="play.api.libs.iteratee.Iteratee.type">Iteratee</a>.<a href="../../../../../play-iteratees/play/api/libs/iteratee/Iteratee.scala.html#play.api.libs.iteratee.Iteratee.takeUpTo" title="(n: Int)play.api.libs.iteratee.Iteratee[A,Seq[A]]">takeUpTo</a><a href="../../../../../play-iteratees/play/api/libs/iteratee/Iteratee.scala.html#play.api.libs.iteratee;Iteratee.flatMap" title="(f: Seq[A] =&gt; play.api.libs.iteratee.Iteratee[A,Unit])(implicit ec: scala.concurrent.ExecutionContext)play.api.libs.iteratee.Iteratee[A,Unit]" class="delimiter">(</a><span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
      <a title="Boolean" id="play.core.server.common.ServerResultUtils.readAheadOne.it.$anonfun.$anonfun.emptyAfterTaken">emptyAfterTaken</a> &lt;- <a href="../../../../../play-iteratees/play/api/libs/iteratee/Iteratee.scala.html#play.api.libs.iteratee.Iteratee" title="play.api.libs.iteratee.Iteratee.type">Iteratee</a>.<a href="../../../../../play-iteratees/play/api/libs/iteratee/Iteratee.scala.html#play.api.libs.iteratee;Iteratee.flatMap" title="(f: Boolean =&gt; play.api.libs.iteratee.Iteratee[A,Unit])(implicit ec: scala.concurrent.ExecutionContext)play.api.libs.iteratee.Iteratee[A,Unit]">isEmpty</a>
      <a title="Unit" id="play.core.server.common.ServerResultUtils.readAheadOne.it.$anonfun.$anonfun.$anonfun._">_</a> &lt;- <span class="delimiter">{</span>
        <a href="../../../../../play-iteratees/play/api/libs/iteratee/Iteratee.scala.html#play.api.libs.iteratee;Iteratee.map" title="(f: Unit =&gt; Unit)(implicit ec: scala.concurrent.ExecutionContext)play.api.libs.iteratee.Iteratee[A,Unit]" class="keyword">if</a> <span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.readAheadOne.it.$anonfun.$anonfun.emptyAfterTaken" title="Boolean">emptyAfterTaken</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span title="(assertion: Boolean)Unit">assert</span><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.readAheadOne.it.$anonfun.taken" title="Seq[A]">taken</a>.<span title="=&gt; Int">length</span> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
          <a href="#play.core.server.common.ServerResultUtils.readAheadOne.result" title="scala.concurrent.Promise[Either[Option[A],play.api.libs.iteratee.Enumerator[A]]]">result</a>.<span title="(v: Either[Option[A],play.api.libs.iteratee.Enumerator[A]])result.type">success</span><span class="delimiter">(</span><span title="(a: Option[A])scala.util.Left[Option[A],Nothing]">Left</span><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.readAheadOne.it.$anonfun.taken" title="Seq[A]">taken</a>.<span title="=&gt; Option[A]">headOption</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="../../../../../play-iteratees/play/api/libs/iteratee/Iteratee.scala.html#play.api.libs.iteratee.Done.apply" title="[E, A](a: A, e: play.api.libs.iteratee.Input[E])play.api.libs.iteratee.Iteratee[E,A]">Done</a><a href="../../../../../play-iteratees/play/api/libs/iteratee/Iteratee.scala.html#play.api.libs.iteratee.Done.apply$default$2" title="(a: Unit, e: play.api.libs.iteratee.Input[A])play.api.libs.iteratee.Iteratee[A,Unit]" class="delimiter">[</a><a href="#play.core.server.common.ServerResultUtils.readAheadOne;A" title="A">A</a>, <span title="Unit">Unit</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="keyword">val</span> <a href="#play.core.server.common.ServerResultUtils.readAheadOne.it.$anonfun.$anonfun.remainingIt" title="(play.api.libs.iteratee.Iteratee[A,Unit], play.api.libs.iteratee.Enumerator[A])" class="delimiter">(</a><a href="#play.core.server.common.ServerResultUtils.readAheadOne.it.$anonfun.$anonfun.x$3" title="play.api.libs.iteratee.Iteratee[A,Unit]" id="play.core.server.common.ServerResultUtils.readAheadOne.it.$anonfun.$anonfun.remainingIt">remainingIt</a>, <a href="#play.core.server.common.ServerResultUtils.readAheadOne.it.$anonfun.$anonfun.x$3" title="play.api.libs.iteratee.Enumerator[A]" id="play.core.server.common.ServerResultUtils.readAheadOne.it.$anonfun.$anonfun.remainingEnum">remainingEnum</a><span class="delimiter">)</span> = <a href="../../../../../play-iteratees/play/api/libs/iteratee/Concurrent.scala.html#play.api.libs.iteratee.Concurrent" title="play.api.libs.iteratee.Concurrent.type">Concurrent</a>.<a href="../../../../../play-iteratees/play/api/libs/iteratee/Concurrent.scala.html#play.api.libs.iteratee.Concurrent.joined" title="[A]=&gt; (play.api.libs.iteratee.Iteratee[A,Unit], play.api.libs.iteratee.Enumerator[A])">joined</a><span title="(play.api.libs.iteratee.Iteratee[A,Unit], play.api.libs.iteratee.Enumerator[A])" class="delimiter">[</span><a href="#play.core.server.common.ServerResultUtils.readAheadOne;A" title="A">A</a><span class="delimiter">]</span>
          <a href="#play.core.server.common.ServerResultUtils.readAheadOne.result" title="scala.concurrent.Promise[Either[Option[A],play.api.libs.iteratee.Enumerator[A]]]">result</a>.<span title="(v: Either[Option[A],play.api.libs.iteratee.Enumerator[A]])result.type">success</span><span class="delimiter">(</span><span title="(b: play.api.libs.iteratee.Enumerator[A])scala.util.Right[Nothing,play.api.libs.iteratee.Enumerator[A]]">Right</span><span class="delimiter">(</span><a href="../../../../../play-iteratees/play/api/libs/iteratee/Enumerator.scala.html#play.api.libs.iteratee.Enumerator" title="play.api.libs.iteratee.Enumerator.type">Enumerator</a>.<a href="../../../../../play-iteratees/play/api/libs/iteratee/Enumerator.scala.html#play.api.libs.iteratee.Enumerator.enumerate" title="(traversable: TraversableOnce[A])(implicit ctx: scala.concurrent.ExecutionContext)play.api.libs.iteratee.Enumerator[A]">enumerate</a><a href="../../../../../play-iteratees/play/api/libs/iteratee/Execution.scala.html#play.api.libs.iteratee.Execution.Implicits.trampoline" title="=&gt; scala.concurrent.ExecutionContext" class="delimiter">(</a><a href="#play.core.server.common.ServerResultUtils.readAheadOne.it.$anonfun.taken" title="Seq[A]">taken</a><span class="delimiter">)</span> <a href="../../../../../play-iteratees/play/api/libs/iteratee/Enumerator.scala.html#play.api.libs.iteratee;Enumerator.>>>" title="(e: play.api.libs.iteratee.Enumerator[A])play.api.libs.iteratee.Enumerator[A]">&gt;&gt;&gt;</a> <a href="#play.core.server.common.ServerResultUtils.readAheadOne.it.$anonfun.$anonfun.remainingEnum" title="play.api.libs.iteratee.Enumerator[A]">remainingEnum</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#play.core.server.common.ServerResultUtils.readAheadOne.it.$anonfun.$anonfun.remainingIt" title="play.api.libs.iteratee.Iteratee[A,Unit]">remainingIt</a>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> <span class="keyword">yield</span> <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
    <a href="../../../../../play-iteratees/play/api/libs/iteratee/Enumerator.scala.html#play.api.libs.iteratee;Enumerator.apply" title="(i: play.api.libs.iteratee.Iteratee[A,Unit])scala.concurrent.Future[play.api.libs.iteratee.Iteratee[A,Unit]]">enum</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.readAheadOne.it" title="play.api.libs.iteratee.Iteratee[A,Unit]">it</a><span class="delimiter">)</span>
    <a href="#play.core.server.common.ServerResultUtils.readAheadOne.result" title="scala.concurrent.Promise[Either[Option[A],play.api.libs.iteratee.Enumerator[A]]]">result</a>.<span title="=&gt; scala.concurrent.Future[Either[Option[A],play.api.libs.iteratee.Enumerator[A]]]">future</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Update the result's Set-Cookie header so that it removes any Flash cookies we received
   * in the incoming request.
   */</span>
  <span class="keyword">def</span> <a title="(requestHeader: play.api.mvc.RequestHeader, result: play.api.mvc.Result)play.api.mvc.Result" id="play.core.server.common.ServerResultUtils.cleanFlashCookie">cleanFlashCookie</a><span class="delimiter">(</span><a title="play.api.mvc.RequestHeader" id="play.core.server.common.ServerResultUtils.cleanFlashCookie.requestHeader">requestHeader</a>: <a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc;RequestHeader" title="play.api.mvc.RequestHeader">RequestHeader</a>, <a title="play.api.mvc.Result" id="play.core.server.common.ServerResultUtils.cleanFlashCookie.result">result</a>: <a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result" title="play.api.mvc.Result">Result</a><span class="delimiter">)</span>: <a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result" title="play.api.mvc.Result">Result</a> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Option[_]" id="play.core.server.common.ServerResultUtils.cleanFlashCookie.optResultFlashCookies">optResultFlashCookies</a>: <span title="Option[_]">Option</span><span class="delimiter">[</span>_<span class="delimiter">]</span> = <a href="#play.core.server.common.ServerResultUtils.cleanFlashCookie.result" title="play.api.mvc.Result">result</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result.header" title="=&gt; play.api.mvc.ResponseHeader">header</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;ResponseHeader.headers" title="=&gt; Map[String,String]">headers</a>.<span title="(key: String)Option[String]">get</span><span class="delimiter">(</span><a href="../../../../../play/play/api/http/StandardValues.scala.html#play.api.http;HeaderNames.SET_COOKIE" title="=&gt; String">SET_COOKIE</a><span class="delimiter">)</span>.<span title="(f: String =&gt; Option[play.api.mvc.Cookie])Option[play.api.mvc.Cookie]">flatMap</span> <span class="delimiter">{</span> setCookieValue: <span title="String">String</span> =&gt;
      <a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc.Cookies" title="play.api.mvc.Cookies.type">Cookies</a>.<a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc.Cookies.decodeSetCookieHeader" title="(cookieHeader: String)Seq[play.api.mvc.Cookie]">decodeSetCookieHeader</a><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.cleanFlashCookie.optResultFlashCookies.$anonfun.setCookieValue" title="String">setCookieValue</a><span class="delimiter">)</span>.<span title="(p: play.api.mvc.Cookie =&gt; Boolean)Option[play.api.mvc.Cookie]">find</span><span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.cleanFlashCookie.optResultFlashCookies.$anonfun.$anonfun.x$4" title="play.api.mvc.Cookie">_</a>.<a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc;Cookie.name" title="=&gt; String">name</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc.Flash" title="play.api.mvc.Flash.type">Flash</a>.<a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc.Flash.COOKIE_NAME" title="=&gt; String">COOKIE_NAME</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span title="play.api.mvc.Result" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.cleanFlashCookie.optResultFlashCookies" title="Option[_]">optResultFlashCookies</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// We're already setting a flash cookie in the result, just pass that</span>
      <span class="comment">// through unchanged</span>
      <a href="#play.core.server.common.ServerResultUtils.cleanFlashCookie.result" title="play.api.mvc.Result">result</a>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="play.api.mvc.Flash" id="play.core.server.common.ServerResultUtils.cleanFlashCookie.requestFlash">requestFlash</a>: <a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc;Flash" title="play.api.mvc.Flash">Flash</a> = <a href="#play.core.server.common.ServerResultUtils.cleanFlashCookie.requestHeader" title="play.api.mvc.RequestHeader">requestHeader</a>.<a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc;RequestHeader.flash" title="=&gt; play.api.mvc.Flash">flash</a>
      <span title="play.api.mvc.Result" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.cleanFlashCookie.requestFlash" title="play.api.mvc.Flash">requestFlash</a>.<a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc;Flash.isEmpty" title="=&gt; Boolean">isEmpty</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="comment">// Neither incoming nor outgoing flash cookies; nothing to do</span>
        <a href="#play.core.server.common.ServerResultUtils.cleanFlashCookie.result" title="play.api.mvc.Result">result</a>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="comment">// We got incoming flash cookies, but there are no outgoing flash cookies,</span>
        <span class="comment">// so we need to clear the cookies for the next request</span>
        <a href="#play.core.server.common.ServerResultUtils.cleanFlashCookie.result" title="play.api.mvc.Result">result</a>.<a href="../../../../../play/play/api/mvc/Results.scala.html#play.api.mvc;Result.withHeaders" title="(headers: (String, String)*)play.api.mvc.Result">withHeaders</a><span class="delimiter">(</span><a href="../../../../../play/play/api/http/StandardValues.scala.html#play.api.http;HeaderNames.SET_COOKIE" title="(x: String)ArrowAssoc[String]">SET_COOKIE</a> <span title="(y: String)(String, String)">-&gt;</span> <a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc.Cookies" title="play.api.mvc.Cookies.type">Cookies</a>.<a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc.Cookies.encodeSetCookieHeader" title="(cookies: Seq[play.api.mvc.Cookie])String">encodeSetCookieHeader</a><span class="delimiter">(</span><span title="(elems: play.api.mvc.Cookie*)Seq[play.api.mvc.Cookie]">Seq</span><span class="delimiter">(</span><a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc.Flash" title="play.api.mvc.Flash.type">Flash</a>.<a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc;CookieBaker.discard" title="=&gt; play.api.mvc.DiscardingCookie">discard</a>.<a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc;DiscardingCookie.toCookie" title="=&gt; play.api.mvc.Cookie">toCookie</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Given a map of headers, split it into a sequence of individual headers.
   * Most headers map into a single pair in the new sequence. The exception is
   * the `Set-Cookie` header which we split into a pair for each cookie it
   * contains. This allows us to work around issues with clients that can't
   * handle combined headers. (Also RFC6265 says multiple headers shouldn't
   * be folded together, which Play's API unfortunately  does.)
   */</span>
  <span class="keyword">def</span> <a title="(headers: Map[String,String])Iterable[(String, String)]" id="play.core.server.common.ServerResultUtils.splitSetCookieHeaders">splitSetCookieHeaders</a><span class="delimiter">(</span><a title="Map[String,String]" id="play.core.server.common.ServerResultUtils.splitSetCookieHeaders.headers">headers</a>: <span title="Map[String,String]">Map</span><span class="delimiter">[</span>String, String<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Iterable[(String, String)]">Iterable</span><span class="delimiter">[</span><span class="delimiter">(</span>String, String<span class="delimiter">)</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span title="Iterable[(String, String)]" class="keyword">if</span> <span class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.splitSetCookieHeaders.headers" title="Map[String,String]">headers</a>.<span title="(key: String)Boolean">contains</span><span class="delimiter">(</span><a href="../../../../../play/play/api/http/StandardValues.scala.html#play.api.http;HeaderNames.SET_COOKIE" title="=&gt; String">SET_COOKIE</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="comment">// Rewrite the headers with Set-Cookie split into separate headers</span>
      <a href="#play.core.server.common.ServerResultUtils.splitSetCookieHeaders.headers" title="Map[String,String]">headers</a>.<span title="[Col[_]](implicit cbf: scala.collection.generic.CanBuildFrom[Nothing,(String, String),Col[(String, String)]])Col[(String, String)]">to</span><span title="(implicit cbf: scala.collection.generic.CanBuildFrom[Nothing,(String, String),Seq[(String, String)]])Seq[(String, String)]" class="delimiter">[</span><span title="Seq">Seq</span><span class="delimiter">]</span>.<span title="(f: ((String, String)) =&gt; scala.collection.GenTraversableOnce[(String, String)])(implicit bf: scala.collection.generic.CanBuildFrom[Seq[(String, String)],(String, String),Iterable[(String, String)]])Iterable[(String, String)]">flatMap</span> <a href="#play.core.server.common.ServerResultUtils.splitSetCookieHeaders.$anonfun.x0$2" title="scala.collection.SeqLike[(String, String),Object]" class="delimiter">{</a>
        <span class="keyword">case</span> <span class="delimiter">(</span><a href="../../../../../play/play/api/http/StandardValues.scala.html#play.api.http;HeaderNames.SET_COOKIE" title="=&gt; String">SET_COOKIE</a>, <span title="String">value</span><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <a title="Array[String]" id="play.core.server.common.ServerResultUtils.splitSetCookieHeaders.$anonfun.cookieParts">cookieParts</a> = <a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc.Cookies" title="play.api.mvc.Cookies.type">Cookies</a>.<a href="../../../../../play/play/api/mvc/Http.scala.html#play.api.mvc.Cookies.SetCookieHeaderSeparatorRegex" title="=&gt; scala.util.matching.Regex">SetCookieHeaderSeparatorRegex</a>.<span title="(toSplit: CharSequence)Array[String]">split</span><span class="delimiter">(</span><span title="String">value</span><span class="delimiter">)</span>
          <a href="#play.core.server.common.ServerResultUtils.splitSetCookieHeaders.$anonfun.cookieParts" title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]">cookieParts</a>.<span title="(f: String =&gt; (String, String))(implicit bf: scala.collection.generic.CanBuildFrom[Array[String],(String, String),Array[(String, String)]])Array[(String, String)]">map</span> <span title="(xs: Array[(String, String)])scala.collection.mutable.ArrayOps[(String, String)]" class="delimiter">{</span> <a title="String" id="play.core.server.common.ServerResultUtils.splitSetCookieHeaders.$anonfun.$anonfun.cookiePart">cookiePart</a> =&gt;
            <a href="../../../../../play/play/api/http/StandardValues.scala.html#play.api.http;HeaderNames.SET_COOKIE" title="(x: String)ArrowAssoc[String]">SET_COOKIE</a> <span title="(y: String)(String, String)">-&gt;</span> <a href="#play.core.server.common.ServerResultUtils.splitSetCookieHeaders.$anonfun.$anonfun.cookiePart" title="String">cookiePart</a>
          <span class="delimiter">}</span>
        <span class="keyword">case</span> <span class="delimiter">(</span><a title="String" id="play.core.server.common.ServerResultUtils.splitSetCookieHeaders.$anonfun.name">name</a>, <span title="String">value</span><span class="delimiter">)</span> =&gt;
          <span title="(elems: (String, String)*)Seq[(String, String)]">Seq</span><span class="delimiter">(</span><span title="(_1: String, _2: String)(String, String)" class="delimiter">(</span><a href="#play.core.server.common.ServerResultUtils.splitSetCookieHeaders.$anonfun.name" title="String">name</a>, <span title="String">value</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="comment">// No Set-Cookie header so we can just use the headers as they are</span>
      <a href="#play.core.server.common.ServerResultUtils.splitSetCookieHeaders.headers" title="Map[String,String]">headers</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
