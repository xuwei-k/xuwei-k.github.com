<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>actor/akka/pattern/CircuitBreaker.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Copyright (C) 2009-2015 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
package akka.pattern

import java.util.concurrent.atomic.<span class="delimiter">{</span> AtomicInteger, AtomicLong, AtomicBoolean <span class="delimiter">}</span>
import akka.AkkaException
import akka.actor.Scheduler
import akka.util.Unsafe
import scala.util.control.NoStackTrace
import java.util.concurrent.<span class="delimiter">{</span> Callable, CopyOnWriteArrayList <span class="delimiter">}</span>
import scala.concurrent.<span class="delimiter">{</span> ExecutionContext, Future, Promise, Await <span class="delimiter">}</span>
import scala.concurrent.duration._
import scala.concurrent.TimeoutException
import scala.util.control.NonFatal
import scala.util.Success
import akka.dispatch.<a href="../dispatch/Future.scala.html#akka.dispatch.ExecutionContexts" title="akka.dispatch.ExecutionContexts.type">ExecutionContexts</a>.sameThreadExecutionContext

<span class="comment">/**
 * Companion object providing factory methods for Circuit Breaker which runs callbacks in caller's thread
 */</span>
object <a title="akka.pattern.CircuitBreaker.type" id="akka.pattern.CircuitBreaker">CircuitBreaker</a> <a href="#akka.pattern.CircuitBreaker" title="akka.pattern.CircuitBreaker.type" class="delimiter">{</a>

  <span class="comment">/**
   * Create a new CircuitBreaker.
   *
   * Callbacks run in caller's thread when using withSyncCircuitBreaker, and in same ExecutionContext as the passed
   * in Future when using withCircuitBreaker. To use another ExecutionContext for the callbacks you can specify the
   * executor in the constructor.
   *
   * @param scheduler Reference to Akka scheduler
   * @param maxFailures Maximum number of failures before opening the circuit
   * @param callTimeout [[scala.concurrent.duration.FiniteDuration]] of time after which to consider a call a failure
   * @param resetTimeout [[scala.concurrent.duration.FiniteDuration]] of time after which to attempt to close the circuit
   */</span>
  def <a title="(scheduler: akka.actor.Scheduler, maxFailures: Int, callTimeout: scala.concurrent.duration.FiniteDuration, resetTimeout: scala.concurrent.duration.FiniteDuration)akka.pattern.CircuitBreaker" id="akka.pattern.CircuitBreaker.apply">apply</a><span class="delimiter">(</span><a title="akka.actor.Scheduler" id="akka.pattern.CircuitBreaker.apply.scheduler">scheduler</a>: <a href="../actor/Scheduler.scala.html#akka.actor;Scheduler" title="akka.actor.Scheduler">Scheduler</a>, <a title="Int" id="akka.pattern.CircuitBreaker.apply.maxFailures">maxFailures</a>: <span title="Int">Int</span>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.pattern.CircuitBreaker.apply.callTimeout">callTimeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.pattern.CircuitBreaker.apply.resetTimeout">resetTimeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span>: <a href="#akka.pattern;CircuitBreaker" title="akka.pattern.CircuitBreaker">CircuitBreaker</a> =
    new <a href="#akka.pattern;CircuitBreaker" title="akka.pattern.CircuitBreaker">CircuitBreaker</a><span class="delimiter">(</span><a href="#akka.pattern.CircuitBreaker.apply.scheduler" title="akka.actor.Scheduler">scheduler</a>, <a href="#akka.pattern.CircuitBreaker.apply.maxFailures" title="Int">maxFailures</a>, <a href="#akka.pattern.CircuitBreaker.apply.callTimeout" title="scala.concurrent.duration.FiniteDuration">callTimeout</a>, <a href="#akka.pattern.CircuitBreaker.apply.resetTimeout" title="scala.concurrent.duration.FiniteDuration">resetTimeout</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="../dispatch/Future.scala.html#akka.dispatch.ExecutionContexts.sameThreadExecutionContext" title="akka.dispatch.ExecutionContexts.sameThreadExecutionContext.type">sameThreadExecutionContext</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Java API: Create a new CircuitBreaker.
   *
   * Callbacks run in caller's thread when using withSyncCircuitBreaker, and in same ExecutionContext as the passed
   * in Future when using withCircuitBreaker. To use another ExecutionContext for the callbacks you can specify the
   * executor in the constructor.
   *
   * @param scheduler Reference to Akka scheduler
   * @param maxFailures Maximum number of failures before opening the circuit
   * @param callTimeout [[scala.concurrent.duration.FiniteDuration]] of time after which to consider a call a failure
   * @param resetTimeout [[scala.concurrent.duration.FiniteDuration]] of time after which to attempt to close the circuit
   */</span>
  def <a title="(scheduler: akka.actor.Scheduler, maxFailures: Int, callTimeout: scala.concurrent.duration.FiniteDuration, resetTimeout: scala.concurrent.duration.FiniteDuration)akka.pattern.CircuitBreaker" id="akka.pattern.CircuitBreaker.create">create</a><span class="delimiter">(</span><a title="akka.actor.Scheduler" id="akka.pattern.CircuitBreaker.create.scheduler">scheduler</a>: <a href="../actor/Scheduler.scala.html#akka.actor;Scheduler" title="akka.actor.Scheduler">Scheduler</a>, <a title="Int" id="akka.pattern.CircuitBreaker.create.maxFailures">maxFailures</a>: <span title="Int">Int</span>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.pattern.CircuitBreaker.create.callTimeout">callTimeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.pattern.CircuitBreaker.create.resetTimeout">resetTimeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span>: <a href="#akka.pattern;CircuitBreaker" title="akka.pattern.CircuitBreaker">CircuitBreaker</a> =
    <a href="#akka.pattern.CircuitBreaker.apply" title="(scheduler: akka.actor.Scheduler, maxFailures: Int, callTimeout: scala.concurrent.duration.FiniteDuration, resetTimeout: scala.concurrent.duration.FiniteDuration)akka.pattern.CircuitBreaker">apply</a><span class="delimiter">(</span><a href="#akka.pattern.CircuitBreaker.create.scheduler" title="akka.actor.Scheduler">scheduler</a>, <a href="#akka.pattern.CircuitBreaker.create.maxFailures" title="Int">maxFailures</a>, <a href="#akka.pattern.CircuitBreaker.create.callTimeout" title="scala.concurrent.duration.FiniteDuration">callTimeout</a>, <a href="#akka.pattern.CircuitBreaker.create.resetTimeout" title="scala.concurrent.duration.FiniteDuration">resetTimeout</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Provides circuit breaker functionality to provide stability when working with &quot;dangerous&quot; operations, e.g. calls to
 * remote systems
 *
 * Transitions through three states:
 * - In *Closed* state, calls pass through until the `maxFailures` count is reached.  This causes the circuit breaker
 * to open.  Both exceptions and calls exceeding `callTimeout` are considered failures.
 * - In *Open* state, calls fail-fast with an exception.  After `resetTimeout`, circuit breaker transitions to
 * half-open state.
 * - In *Half-Open* state, the first call will be allowed through, if it succeeds the circuit breaker will reset to
 * closed state.  If it fails, the circuit breaker will re-open to open state.  All calls beyond the first that
 * execute while the first is running will fail-fast with an exception.
 *
 *
 * @param scheduler Reference to Akka scheduler
 * @param maxFailures Maximum number of failures before opening the circuit
 * @param callTimeout [[scala.concurrent.duration.FiniteDuration]] of time after which to consider a call a failure
 * @param resetTimeout [[scala.concurrent.duration.FiniteDuration]] of time after which to attempt to close the circuit
 * @param executor [[scala.concurrent.ExecutionContext]] used for execution of state transition listeners
 */</span>
class <a title="class CircuitBreaker extends akka.pattern.AbstractCircuitBreaker" id="akka.pattern;CircuitBreaker">CircuitBreaker</a><a href="#akka.pattern;CircuitBreaker" title="akka.pattern.CircuitBreaker" class="delimiter">(</a><a title="akka.actor.Scheduler" id="akka.pattern;CircuitBreaker.scheduler">scheduler</a>: <a href="../actor/Scheduler.scala.html#akka.actor;Scheduler" title="akka.actor.Scheduler">Scheduler</a>, <a title="Int" id="akka.pattern;CircuitBreaker.maxFailures">maxFailures</a>: <span title="Int">Int</span>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.pattern;CircuitBreaker.callTimeout">callTimeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.pattern;CircuitBreaker.resetTimeout">resetTimeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="scala.concurrent.ExecutionContext" id="akka.pattern;CircuitBreaker.executor">executor</a>: <span title="scala.concurrent.ExecutionContext">ExecutionContext</span><span class="delimiter">)</span> extends <a href="AbstractCircuitBreaker.java.html#akka.pattern;AbstractCircuitBreaker" title="akka.pattern.AbstractCircuitBreaker">AbstractCircuitBreaker</a> <span class="delimiter">{</span>

  def this<span class="delimiter">(</span><a title="scala.concurrent.ExecutionContext" id="akka.pattern;CircuitBreaker.<init>(2a90ac4ed3).executor">executor</a>: <span title="scala.concurrent.ExecutionContext">ExecutionContext</span>, <a title="akka.actor.Scheduler" id="akka.pattern;CircuitBreaker.<init>(2a90ac4ed3).scheduler">scheduler</a>: <a href="../actor/Scheduler.scala.html#akka.actor;Scheduler" title="akka.actor.Scheduler">Scheduler</a>, <a title="Int" id="akka.pattern;CircuitBreaker.<init>(2a90ac4ed3).maxFailures">maxFailures</a>: <span title="Int">Int</span>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.pattern;CircuitBreaker.<init>(2a90ac4ed3).callTimeout">callTimeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.pattern;CircuitBreaker.<init>(2a90ac4ed3).resetTimeout">resetTimeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span> = <span title="Unit" class="delimiter">{</span>
    this<span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.<init>(2a90ac4ed3).scheduler" title="akka.actor.Scheduler">scheduler</a>, <a href="#akka.pattern;CircuitBreaker.<init>(2a90ac4ed3).maxFailures" title="Int">maxFailures</a>, <a href="#akka.pattern;CircuitBreaker.<init>(2a90ac4ed3).callTimeout" title="scala.concurrent.duration.FiniteDuration">callTimeout</a>, <a href="#akka.pattern;CircuitBreaker.<init>(2a90ac4ed3).resetTimeout" title="scala.concurrent.duration.FiniteDuration">resetTimeout</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.<init>(2a90ac4ed3).executor" title="scala.concurrent.ExecutionContext">executor</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Holds reference to current state of CircuitBreaker - *access only via helper methods*
   */</span>
  @volatile
  private<span class="delimiter">[</span>this<span class="delimiter">]</span> var <a title="CircuitBreaker.this.State" id="akka.pattern;CircuitBreaker._currentStateDoNotCallMeDirectly">_currentStateDoNotCallMeDirectly</a>: <a href="#akka.pattern;CircuitBreaker;State" title="CircuitBreaker.this.State">State</a> = <a href="#akka.pattern;CircuitBreaker.Closed.readResolve" title="CircuitBreaker.this.Closed.type">Closed</a>

  <span class="comment">/**
   * Helper method for access to underlying state via Unsafe
   *
   * @param oldState Previous state on transition
   * @param newState Next state on transition
   * @return Whether the previous state matched correctly
   */</span>
  @inline
  private<span class="delimiter">[</span>this<span class="delimiter">]</span> def <a title="(oldState: CircuitBreaker.this.State, newState: CircuitBreaker.this.State)Boolean" id="akka.pattern;CircuitBreaker.swapState">swapState</a><span class="delimiter">(</span><a title="CircuitBreaker.this.State" id="akka.pattern;CircuitBreaker.swapState.oldState">oldState</a>: <a href="#akka.pattern;CircuitBreaker;State" title="CircuitBreaker.this.State">State</a>, <a title="CircuitBreaker.this.State" id="akka.pattern;CircuitBreaker.swapState.newState">newState</a>: <a href="#akka.pattern;CircuitBreaker;State" title="CircuitBreaker.this.State">State</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="../util/Unsafe.java.html#akka.util.Unsafe" title="akka.util.Unsafe.type">Unsafe</a>.<a href="../util/Unsafe.java.html#akka.util.Unsafe.instance" title="sun.misc.Unsafe">instance</a>.<span title="(x$1: Any, x$2: Long, x$3: Any, x$4: Any)Boolean">compareAndSwapObject</span><span class="delimiter">(</span>this, <a href="AbstractCircuitBreaker.java.html#akka.pattern.AbstractCircuitBreaker" title="akka.pattern.AbstractCircuitBreaker.type">AbstractCircuitBreaker</a>.<a href="AbstractCircuitBreaker.java.html#akka.pattern.AbstractCircuitBreaker.stateOffset" title="Long">stateOffset</a>, <a href="#akka.pattern;CircuitBreaker.swapState.oldState" title="CircuitBreaker.this.State">oldState</a>, <a href="#akka.pattern;CircuitBreaker.swapState.newState" title="CircuitBreaker.this.State">newState</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Helper method for accessing underlying state via Unsafe
   *
   * @return Reference to current state
   */</span>
  @inline
  private<span class="delimiter">[</span>this<span class="delimiter">]</span> def <a title="=&gt; CircuitBreaker.this.State" id="akka.pattern;CircuitBreaker.currentState">currentState</a>: <a href="#akka.pattern;CircuitBreaker;State" title="CircuitBreaker.this.State">State</a> =
    <a href="../util/Unsafe.java.html#akka.util.Unsafe" title="akka.util.Unsafe.type">Unsafe</a>.<a href="../util/Unsafe.java.html#akka.util.Unsafe.instance" title="sun.misc.Unsafe">instance</a>.<span title="(x$1: Any, x$2: Long)Object">getObjectVolatile</span><span class="delimiter">(</span>this, <a href="AbstractCircuitBreaker.java.html#akka.pattern.AbstractCircuitBreaker" title="akka.pattern.AbstractCircuitBreaker.type">AbstractCircuitBreaker</a>.<a href="AbstractCircuitBreaker.java.html#akka.pattern.AbstractCircuitBreaker.stateOffset" title="Long">stateOffset</a><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="CircuitBreaker.this.State" class="delimiter">[</span><a href="#akka.pattern;CircuitBreaker;State" title="CircuitBreaker.this.State">State</a><span class="delimiter">]</span>

  <span class="comment">/**
   * Wraps invocations of asynchronous calls that need to be protected
   *
   * @param body Call needing protected
   * @return [[scala.concurrent.Future]] containing the call result or a
   *   `scala.concurrent.TimeoutException` if the call timed out
   *
   */</span>
  def <a title="[T](body: =&gt; scala.concurrent.Future[T])scala.concurrent.Future[T]" id="akka.pattern;CircuitBreaker.withCircuitBreaker">withCircuitBreaker</a><span class="delimiter">[</span><a title="" id="akka.pattern;CircuitBreaker.withCircuitBreaker;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scala.concurrent.Future[T]" id="akka.pattern;CircuitBreaker.withCircuitBreaker.body">body</a>: ⇒ Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scala.concurrent.Future[T]">Future</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#akka.pattern;CircuitBreaker.currentState" title="=&gt; CircuitBreaker.this.State">currentState</a>.<a href="#akka.pattern;CircuitBreaker;State.invoke" title="(body: =&gt; scala.concurrent.Future[T])scala.concurrent.Future[T]">invoke</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.withCircuitBreaker.body" title="=&gt; scala.concurrent.Future[T]">body</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Java API for [[#withCircuitBreaker]]
   *
   * @param body Call needing protected
   * @return [[scala.concurrent.Future]] containing the call result or a
   *   `scala.concurrent.TimeoutException` if the call timed out
   */</span>
  def <a title="[T](body: java.util.concurrent.Callable[scala.concurrent.Future[T]])scala.concurrent.Future[T]" id="akka.pattern;CircuitBreaker.callWithCircuitBreaker">callWithCircuitBreaker</a><span class="delimiter">[</span><a title="" id="akka.pattern;CircuitBreaker.callWithCircuitBreaker;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="java.util.concurrent.Callable[scala.concurrent.Future[T]]" id="akka.pattern;CircuitBreaker.callWithCircuitBreaker.body">body</a>: <span title="java.util.concurrent.Callable[scala.concurrent.Future[T]]">Callable</span><span class="delimiter">[</span>Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scala.concurrent.Future[T]">Future</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#akka.pattern;CircuitBreaker.withCircuitBreaker" title="(body: =&gt; scala.concurrent.Future[T])scala.concurrent.Future[T]">withCircuitBreaker</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.callWithCircuitBreaker.body" title="java.util.concurrent.Callable[scala.concurrent.Future[T]]">body</a>.<span title="()scala.concurrent.Future[T]">call</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Wraps invocations of synchronous calls that need to be protected
   *
   * Calls are run in caller's thread. Because of the synchronous nature of
   * this call the  `scala.concurrent.TimeoutException` will only be thrown
   * after the body has completed.
   *
   * Throws java.util.concurrent.TimeoutException if the call timed out.
   *
   * @param body Call needing protected
   * @return The result of the call
   */</span>
  def <a title="[T](body: =&gt; T)T" id="akka.pattern;CircuitBreaker.withSyncCircuitBreaker">withSyncCircuitBreaker</a><span class="delimiter">[</span><a title="" id="akka.pattern;CircuitBreaker.withSyncCircuitBreaker;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; T" id="akka.pattern;CircuitBreaker.withSyncCircuitBreaker.body">body</a>: ⇒ T<span class="delimiter">)</span>: <a href="#akka.pattern;CircuitBreaker.withSyncCircuitBreaker;T" title="T">T</a> =
    <span title="scala.concurrent.Await.type">Await</span>.<span title="(awaitable: scala.concurrent.Awaitable[T], atMost: scala.concurrent.duration.Duration)T">result</span><span class="delimiter">(</span>
      <a href="#akka.pattern;CircuitBreaker.withCircuitBreaker" title="(body: =&gt; scala.concurrent.Future[T])scala.concurrent.Future[T]">withCircuitBreaker</a><span class="delimiter">(</span>try <span title="scala.concurrent.Future.type">Future</span>.<span title="(result: T)scala.concurrent.Future[T]">successful</span><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.withSyncCircuitBreaker.body" title="=&gt; T">body</a><span class="delimiter">)</span> catch <span class="delimiter">{</span> case <a href="#akka.pattern;CircuitBreaker.withSyncCircuitBreaker.<unapply-selector>" title="(t: Throwable)Option[Throwable]">NonFatal</a><span class="delimiter">(</span><a title="Throwable" id="akka.pattern;CircuitBreaker.withSyncCircuitBreaker.t">t</a><span class="delimiter">)</span> ⇒ <span title="scala.concurrent.Future.type">Future</span>.<span title="(exception: Throwable)scala.concurrent.Future[Nothing]">failed</span><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.withSyncCircuitBreaker.t" title="Throwable">t</a><span class="delimiter">)</span> <span class="delimiter">}</span><span class="delimiter">)</span>,
      <a href="#akka.pattern;CircuitBreaker.callTimeout" title="scala.concurrent.duration.FiniteDuration">callTimeout</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Java API for [[#withSyncCircuitBreaker]]. Throws [[java.util.concurrent.TimeoutException]] if the call timed out.
   *
   * @param body Call needing protected
   * @return The result of the call
   */</span>
  def <a title="[T](body: java.util.concurrent.Callable[T])T" id="akka.pattern;CircuitBreaker.callWithSyncCircuitBreaker">callWithSyncCircuitBreaker</a><span class="delimiter">[</span><a title="" id="akka.pattern;CircuitBreaker.callWithSyncCircuitBreaker;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="java.util.concurrent.Callable[T]" id="akka.pattern;CircuitBreaker.callWithSyncCircuitBreaker.body">body</a>: <span title="java.util.concurrent.Callable[T]">Callable</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.pattern;CircuitBreaker.callWithSyncCircuitBreaker;T" title="T">T</a> = <a href="#akka.pattern;CircuitBreaker.withSyncCircuitBreaker" title="(body: =&gt; T)T">withSyncCircuitBreaker</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.callWithSyncCircuitBreaker.body" title="java.util.concurrent.Callable[T]">body</a>.<span title="()T">call</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Adds a callback to execute when circuit breaker opens
   *
   * The callback is run in the [[scala.concurrent.ExecutionContext]] supplied in the constructor.
   *
   * @param callback Handler to be invoked on state change
   * @return CircuitBreaker for fluent usage
   */</span>
  def <a title="(callback: =&gt; Unit)akka.pattern.CircuitBreaker" id="akka.pattern;CircuitBreaker.onOpen(5d19f085f5)">onOpen</a><span class="delimiter">(</span><a title="=&gt; Unit" id="akka.pattern;CircuitBreaker.onOpen(5d19f085f5).callback">callback</a>: ⇒ Unit<span class="delimiter">)</span>: <a href="#akka.pattern;CircuitBreaker" title="akka.pattern.CircuitBreaker">CircuitBreaker</a> = <a href="#akka.pattern;CircuitBreaker.onOpen(6bbe58732c)" title="(callback: Runnable)akka.pattern.CircuitBreaker">onOpen</a><span class="delimiter">(</span>new <a title="&lt;$anon: Runnable&gt; extends Object with Runnable" id="akka.pattern;CircuitBreaker.onOpen(5d19f085f5);$anon">Runnable</a> <span class="delimiter">{</span> def <a title="()Unit" id="akka.pattern;CircuitBreaker.onOpen(5d19f085f5);$anon.run">run</a> = <a href="#akka.pattern;CircuitBreaker.onOpen(5d19f085f5).callback" title="=&gt; Unit">callback</a> <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Java API for onOpen
   *
   * @param callback Handler to be invoked on state change
   * @return CircuitBreaker for fluent usage
   */</span>
  def <a title="(callback: Runnable)akka.pattern.CircuitBreaker" id="akka.pattern;CircuitBreaker.onOpen(6bbe58732c)">onOpen</a><span class="delimiter">(</span><a title="Runnable" id="akka.pattern;CircuitBreaker.onOpen(6bbe58732c).callback">callback</a>: <span title="Runnable">Runnable</span><span class="delimiter">)</span>: <a href="#akka.pattern;CircuitBreaker" title="akka.pattern.CircuitBreaker">CircuitBreaker</a> = <span class="delimiter">{</span>
    <a href="#akka.pattern;CircuitBreaker.Open.readResolve" title="CircuitBreaker.this.Open.type">Open</a> <a href="#akka.pattern;CircuitBreaker;State.addListener" title="(listener: Runnable)Unit">addListener</a> <a href="#akka.pattern;CircuitBreaker.onOpen(6bbe58732c).callback" title="Runnable">callback</a>
    this
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Adds a callback to execute when circuit breaker transitions to half-open
   *
   * The callback is run in the [[scala.concurrent.ExecutionContext]] supplied in the constructor.
   *
   * @param callback Handler to be invoked on state change
   * @return CircuitBreaker for fluent usage
   */</span>
  def <a title="(callback: =&gt; Unit)akka.pattern.CircuitBreaker" id="akka.pattern;CircuitBreaker.onHalfOpen(5d19f085f5)">onHalfOpen</a><span class="delimiter">(</span><a title="=&gt; Unit" id="akka.pattern;CircuitBreaker.onHalfOpen(5d19f085f5).callback">callback</a>: ⇒ Unit<span class="delimiter">)</span>: <a href="#akka.pattern;CircuitBreaker" title="akka.pattern.CircuitBreaker">CircuitBreaker</a> = <a href="#akka.pattern;CircuitBreaker.onHalfOpen(6bbe58732c)" title="(callback: Runnable)akka.pattern.CircuitBreaker">onHalfOpen</a><span class="delimiter">(</span>new <a title="&lt;$anon: Runnable&gt; extends Object with Runnable" id="akka.pattern;CircuitBreaker.onHalfOpen(5d19f085f5);$anon">Runnable</a> <span class="delimiter">{</span> def <a title="()Unit" id="akka.pattern;CircuitBreaker.onHalfOpen(5d19f085f5);$anon.run">run</a> = <a href="#akka.pattern;CircuitBreaker.onHalfOpen(5d19f085f5).callback" title="=&gt; Unit">callback</a> <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="comment">/**
   * JavaAPI for onHalfOpen
   *
   * @param callback Handler to be invoked on state change
   * @return CircuitBreaker for fluent usage
   */</span>
  def <a title="(callback: Runnable)akka.pattern.CircuitBreaker" id="akka.pattern;CircuitBreaker.onHalfOpen(6bbe58732c)">onHalfOpen</a><span class="delimiter">(</span><a title="Runnable" id="akka.pattern;CircuitBreaker.onHalfOpen(6bbe58732c).callback">callback</a>: <span title="Runnable">Runnable</span><span class="delimiter">)</span>: <a href="#akka.pattern;CircuitBreaker" title="akka.pattern.CircuitBreaker">CircuitBreaker</a> = <span class="delimiter">{</span>
    <a href="#akka.pattern;CircuitBreaker.HalfOpen.readResolve" title="CircuitBreaker.this.HalfOpen.type">HalfOpen</a> <a href="#akka.pattern;CircuitBreaker;State.addListener" title="(listener: Runnable)Unit">addListener</a> <a href="#akka.pattern;CircuitBreaker.onHalfOpen(6bbe58732c).callback" title="Runnable">callback</a>
    this
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Adds a callback to execute when circuit breaker state closes
   *
   * The callback is run in the [[scala.concurrent.ExecutionContext]] supplied in the constructor.
   *
   * @param callback Handler to be invoked on state change
   * @return CircuitBreaker for fluent usage
   */</span>
  def <a title="(callback: =&gt; Unit)akka.pattern.CircuitBreaker" id="akka.pattern;CircuitBreaker.onClose(5d19f085f5)">onClose</a><span class="delimiter">(</span><a title="=&gt; Unit" id="akka.pattern;CircuitBreaker.onClose(5d19f085f5).callback">callback</a>: ⇒ Unit<span class="delimiter">)</span>: <a href="#akka.pattern;CircuitBreaker" title="akka.pattern.CircuitBreaker">CircuitBreaker</a> = <a href="#akka.pattern;CircuitBreaker.onClose(6bbe58732c)" title="(callback: Runnable)akka.pattern.CircuitBreaker">onClose</a><span class="delimiter">(</span>new <a title="&lt;$anon: Runnable&gt; extends Object with Runnable" id="akka.pattern;CircuitBreaker.onClose(5d19f085f5);$anon">Runnable</a> <span class="delimiter">{</span> def <a title="()Unit" id="akka.pattern;CircuitBreaker.onClose(5d19f085f5);$anon.run">run</a> = <a href="#akka.pattern;CircuitBreaker.onClose(5d19f085f5).callback" title="=&gt; Unit">callback</a> <span class="delimiter">}</span><span class="delimiter">)</span>

  <span class="comment">/**
   * JavaAPI for onClose
   *
   * @param callback Handler to be invoked on state change
   * @return CircuitBreaker for fluent usage
   */</span>
  def <a title="(callback: Runnable)akka.pattern.CircuitBreaker" id="akka.pattern;CircuitBreaker.onClose(6bbe58732c)">onClose</a><span class="delimiter">(</span><a title="Runnable" id="akka.pattern;CircuitBreaker.onClose(6bbe58732c).callback">callback</a>: <span title="Runnable">Runnable</span><span class="delimiter">)</span>: <a href="#akka.pattern;CircuitBreaker" title="akka.pattern.CircuitBreaker">CircuitBreaker</a> = <span class="delimiter">{</span>
    <a href="#akka.pattern;CircuitBreaker.Closed.readResolve" title="CircuitBreaker.this.Closed.type">Closed</a> <a href="#akka.pattern;CircuitBreaker;State.addListener" title="(listener: Runnable)Unit">addListener</a> <a href="#akka.pattern;CircuitBreaker.onClose(6bbe58732c).callback" title="Runnable">callback</a>
    this
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Retrieves current failure count.
   *
   * @return count
   */</span>
  private<span class="delimiter">[</span>akka<span class="delimiter">]</span> def <a title="=&gt; Int" id="akka.pattern;CircuitBreaker.currentFailureCount">currentFailureCount</a>: <span title="Int">Int</span> = <a href="#akka.pattern;CircuitBreaker.Closed.readResolve" title="CircuitBreaker.this.Closed.type">Closed</a>.<span title="()Int">get</span>

  <span class="comment">/**
   * Implements consistent transition between states. Throws IllegalStateException if an invalid transition is attempted.
   *
   * @param fromState State being transitioning from
   * @param toState State being transitioning from
   */</span>
  private def <a title="(fromState: CircuitBreaker.this.State, toState: CircuitBreaker.this.State)Unit" id="akka.pattern;CircuitBreaker.transition">transition</a><span class="delimiter">(</span><a title="CircuitBreaker.this.State" id="akka.pattern;CircuitBreaker.transition.fromState">fromState</a>: <a href="#akka.pattern;CircuitBreaker;State" title="CircuitBreaker.this.State">State</a>, <a title="CircuitBreaker.this.State" id="akka.pattern;CircuitBreaker.transition.toState">toState</a>: <a href="#akka.pattern;CircuitBreaker;State" title="CircuitBreaker.this.State">State</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    if <span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.swapState" title="(oldState: CircuitBreaker.this.State, newState: CircuitBreaker.this.State)Boolean">swapState</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.transition.fromState" title="CircuitBreaker.this.State">fromState</a>, <a href="#akka.pattern;CircuitBreaker.transition.toState" title="CircuitBreaker.this.State">toState</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#akka.pattern;CircuitBreaker.transition.toState" title="CircuitBreaker.this.State">toState</a>.<a href="#akka.pattern;CircuitBreaker;State.enter" title="()Unit">enter</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="comment">// else some other thread already swapped state</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Trips breaker to an open state.  This is valid from Closed or Half-Open states.
   *
   * @param fromState State we're coming from (Closed or Half-Open)
   */</span>
  private def <a title="(fromState: CircuitBreaker.this.State)Unit" id="akka.pattern;CircuitBreaker.tripBreaker">tripBreaker</a><span class="delimiter">(</span><a title="CircuitBreaker.this.State" id="akka.pattern;CircuitBreaker.tripBreaker.fromState">fromState</a>: <a href="#akka.pattern;CircuitBreaker;State" title="CircuitBreaker.this.State">State</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.pattern;CircuitBreaker.transition" title="(fromState: CircuitBreaker.this.State, toState: CircuitBreaker.this.State)Unit">transition</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.tripBreaker.fromState" title="CircuitBreaker.this.State">fromState</a>, <a href="#akka.pattern;CircuitBreaker.Open.readResolve" title="CircuitBreaker.this.Open.type">Open</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Resets breaker to a closed state.  This is valid from an Half-Open state only.
   *
   */</span>
  private def <a title="()Unit" id="akka.pattern;CircuitBreaker.resetBreaker">resetBreaker</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.pattern;CircuitBreaker.transition" title="(fromState: CircuitBreaker.this.State, toState: CircuitBreaker.this.State)Unit">transition</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.HalfOpen.readResolve" title="CircuitBreaker.this.HalfOpen.type">HalfOpen</a>, <a href="#akka.pattern;CircuitBreaker.Closed.readResolve" title="CircuitBreaker.this.Closed.type">Closed</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Attempts to reset breaker by transitioning to a half-open state.  This is valid from an Open state only.
   *
   */</span>
  private def <a title="()Unit" id="akka.pattern;CircuitBreaker.attemptReset">attemptReset</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.pattern;CircuitBreaker.transition" title="(fromState: CircuitBreaker.this.State, toState: CircuitBreaker.this.State)Unit">transition</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.Open.readResolve" title="CircuitBreaker.this.Open.type">Open</a>, <a href="#akka.pattern;CircuitBreaker.HalfOpen.readResolve" title="CircuitBreaker.this.HalfOpen.type">HalfOpen</a><span class="delimiter">)</span>

  private val <a title="scala.concurrent.Future[Nothing]" id="akka.pattern;CircuitBreaker.timeoutFuture">timeoutFuture</a> = <span title="scala.concurrent.Future.type">Future</span>.<span title="(exception: Throwable)scala.concurrent.Future[Nothing]">failed</span><span class="delimiter">(</span>new <a title="&lt;$anon: concurrent.TimeoutException with scala.util.control.NoStackTrace&gt; extends concurrent.TimeoutException with scala.util.control.NoStackTrace" id="akka.pattern;CircuitBreaker.timeoutFuture;$anon">TimeoutException</a><span class="delimiter">(</span><span title="String(&quot;Circuit Breaker Timed out.&quot;)" class="string">&quot;Circuit Breaker Timed out.&quot;</span><span class="delimiter">)</span> with <span title="scala.util.control.NoStackTrace">NoStackTrace</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Internal state abstraction
   */</span>
  private sealed trait <a title="trait State extends AnyRef" id="akka.pattern;CircuitBreaker;State">State</a> <span title="Unit" class="delimiter">{</span>
    private val <a title="java.util.concurrent.CopyOnWriteArrayList[Runnable]" id="akka.pattern;CircuitBreaker;State.listeners">listeners</a> = new <span title="java.util.concurrent.CopyOnWriteArrayList[Runnable]">CopyOnWriteArrayList</span><span class="delimiter">[</span>Runnable<span class="delimiter">]</span>

    <span class="comment">/**
     * Add a listener function which is invoked on state entry
     *
     * @param listener listener implementation
     */</span>
    def <a title="(listener: Runnable)Unit" id="akka.pattern;CircuitBreaker;State.addListener">addListener</a><span class="delimiter">(</span><a title="Runnable" id="akka.pattern;CircuitBreaker;State.addListener.listener">listener</a>: <span title="Runnable">Runnable</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.pattern;CircuitBreaker;State.listeners" title="=&gt; java.util.concurrent.CopyOnWriteArrayList[Runnable]">listeners</a> <span title="(x$1: Runnable)Boolean">add</span> <a href="#akka.pattern;CircuitBreaker;State.addListener.listener" title="Runnable">listener</a>

    <span class="comment">/**
     * Test for whether listeners exist
     *
     * @return whether listeners exist
     */</span>
    private def <a title="=&gt; Boolean" id="akka.pattern;CircuitBreaker;State.hasListeners">hasListeners</a>: <span title="Boolean">Boolean</span> = <span title="=&gt; Boolean">!</span><a href="#akka.pattern;CircuitBreaker;State.listeners" title="=&gt; java.util.concurrent.CopyOnWriteArrayList[Runnable]">listeners</a>.<span title="()Boolean">isEmpty</span>

    <span class="comment">/**
     * Notifies the listeners of the transition event via a Future executed in implicit parameter ExecutionContext
     *
     * @return Promise which executes listener in supplied [[scala.concurrent.ExecutionContext]]
     */</span>
    protected def <a title="()Unit" id="akka.pattern;CircuitBreaker;State.notifyTransitionListeners">notifyTransitionListeners</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      if <span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker;State.hasListeners" title="=&gt; Boolean">hasListeners</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        val <a title="java.util.Iterator[Runnable]" id="akka.pattern;CircuitBreaker;State.notifyTransitionListeners.iterator">iterator</a> = <a href="#akka.pattern;CircuitBreaker;State.listeners" title="=&gt; java.util.concurrent.CopyOnWriteArrayList[Runnable]">listeners</a>.<span title="()java.util.Iterator[Runnable]">iterator</span>
        while <span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker;State.notifyTransitionListeners.iterator" title="java.util.Iterator[Runnable]">iterator</a>.<span title="()Boolean">hasNext</span><span class="delimiter">)</span> <a href="#akka.pattern;CircuitBreaker;State.notifyTransitionListeners.while$1" title="()Unit" class="delimiter">{</a>
          val <a title="Runnable" id="akka.pattern;CircuitBreaker;State.notifyTransitionListeners.listener">listener</a> = <a href="#akka.pattern;CircuitBreaker;State.notifyTransitionListeners.iterator" title="java.util.Iterator[Runnable]">iterator</a>.<span title="()Runnable">next</span>
          <a href="#akka.pattern;CircuitBreaker.executor" title="scala.concurrent.ExecutionContext">executor</a>.<span title="(runnable: Runnable)Unit">execute</span><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker;State.notifyTransitionListeners.listener" title="Runnable">listener</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Shared implementation of call across all states.  Thrown exception or execution of the call beyond the allowed
     * call timeout is counted as a failed call, otherwise a successful call
     *
     * @param body Implementation of the call
     * @return Future containing the result of the call
     */</span>
    def <a title="[T](body: =&gt; scala.concurrent.Future[T])scala.concurrent.Future[T]" id="akka.pattern;CircuitBreaker;State.callThrough">callThrough</a><span class="delimiter">[</span><a title="" id="akka.pattern;CircuitBreaker;State.callThrough;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scala.concurrent.Future[T]" id="akka.pattern;CircuitBreaker;State.callThrough.body">body</a>: ⇒ Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scala.concurrent.Future[T]">Future</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>

      def <a title="[U](value: =&gt; scala.concurrent.Future[U])scala.concurrent.Future[U]" id="akka.pattern;CircuitBreaker;State.callThrough.materialize">materialize</a><span class="delimiter">[</span><a title="" id="akka.pattern;CircuitBreaker;State.callThrough.materialize;U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scala.concurrent.Future[U]" id="akka.pattern;CircuitBreaker;State.callThrough.materialize.value">value</a>: ⇒ Future<span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scala.concurrent.Future[U]">Future</span><span class="delimiter">[</span>U<span class="delimiter">]</span> = try <a href="#akka.pattern;CircuitBreaker;State.callThrough.materialize.value" title="=&gt; scala.concurrent.Future[U]">value</a> catch <span class="delimiter">{</span> case <a href="#akka.pattern;CircuitBreaker;State.callThrough.materialize.<unapply-selector>" title="(t: Throwable)Option[Throwable]">NonFatal</a><span class="delimiter">(</span><a title="Throwable" id="akka.pattern;CircuitBreaker;State.callThrough.materialize.t">t</a><span class="delimiter">)</span> ⇒ <span title="scala.concurrent.Future.type">Future</span>.<span title="(exception: Throwable)scala.concurrent.Future[Nothing]">failed</span><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker;State.callThrough.materialize.t" title="Throwable">t</a><span class="delimiter">)</span> <span class="delimiter">}</span>

      if <span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.callTimeout" title="scala.concurrent.duration.FiniteDuration">callTimeout</a> <span title="(x$1: Any)Boolean">==</span> <span title="scala.concurrent.duration.Duration.type">Duration</span>.<span title="=&gt; scala.concurrent.duration.FiniteDuration">Zero</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#akka.pattern;CircuitBreaker;State.callThrough.materialize" title="(value: =&gt; scala.concurrent.Future[T])scala.concurrent.Future[T]">materialize</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker;State.callThrough.body" title="=&gt; scala.concurrent.Future[T]">body</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span class="delimiter">{</span>
        val <a title="scala.concurrent.Promise[T]" id="akka.pattern;CircuitBreaker;State.callThrough.p">p</a> = <span title="[T]()scala.concurrent.Promise[T]">Promise</span><span title="()scala.concurrent.Promise[T]" class="delimiter">[</span><a href="#akka.pattern;CircuitBreaker;State.callThrough;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>

        implicit val <a title="akka.dispatch.ExecutionContexts.sameThreadExecutionContext.type" id="akka.pattern;CircuitBreaker;State.callThrough.ec">ec</a> = <a href="../dispatch/Future.scala.html#akka.dispatch.ExecutionContexts.sameThreadExecutionContext" title="akka.dispatch.ExecutionContexts.sameThreadExecutionContext.type">sameThreadExecutionContext</a>
        <a href="#akka.pattern;CircuitBreaker;State.callThrough.p" title="scala.concurrent.Promise[T]">p</a>.<span title="=&gt; scala.concurrent.Future[T]">future</span>.<span title="(f: scala.util.Try[T] =&gt; Unit)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</span> <a href="#akka.pattern;CircuitBreaker;State.callThrough.$anonfun.x0$1" title="Unit" class="delimiter">{</a>
          case <a title="scala.util.Success[_]" id="akka.pattern;CircuitBreaker;State.callThrough.$anonfun.s">s</a>: <span title="scala.util.Success[_]">Success</span><span class="delimiter">[</span>_<span class="delimiter">]</span> ⇒ <a href="#akka.pattern;CircuitBreaker;State.callSucceeds" title="()Unit">callSucceeds</a><span class="delimiter">(</span><span class="delimiter">)</span>
          case _             ⇒ <a href="#akka.pattern;CircuitBreaker;State.callFails" title="()Unit">callFails</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>

        val <a title="akka.actor.Cancellable" id="akka.pattern;CircuitBreaker;State.callThrough.timeout">timeout</a> = <a href="#akka.pattern;CircuitBreaker.scheduler" title="akka.actor.Scheduler">scheduler</a>.<a href="../actor/Scheduler.scala.html#akka.actor;Scheduler.scheduleOnce(066d40b78a)" title="(delay: scala.concurrent.duration.FiniteDuration)(f: =&gt; Unit)(implicit executor: scala.concurrent.ExecutionContext)akka.actor.Cancellable">scheduleOnce</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.callTimeout" title="scala.concurrent.duration.FiniteDuration">callTimeout</a><span class="delimiter">)</span> <a href="#akka.pattern;CircuitBreaker;State.callThrough.ec" title="akka.dispatch.ExecutionContexts.sameThreadExecutionContext.type" class="delimiter">{</a>
          <a href="#akka.pattern;CircuitBreaker;State.callThrough.p" title="scala.concurrent.Promise[T]">p</a> <span title="(other: scala.concurrent.Future[T])p.type">tryCompleteWith</span> <a href="#akka.pattern;CircuitBreaker.timeoutFuture" title="=&gt; scala.concurrent.Future[Nothing]">timeoutFuture</a>
        <span class="delimiter">}</span>

        <a href="#akka.pattern;CircuitBreaker;State.callThrough.materialize" title="(value: =&gt; scala.concurrent.Future[T])scala.concurrent.Future[T]">materialize</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker;State.callThrough.body" title="=&gt; scala.concurrent.Future[T]">body</a><span class="delimiter">)</span>.<span title="(f: scala.util.Try[T] =&gt; Boolean)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</span> <a href="#akka.pattern;CircuitBreaker;State.callThrough.ec" title="akka.dispatch.ExecutionContexts.sameThreadExecutionContext.type" class="delimiter">{</a> <a title="scala.util.Try[T]" id="akka.pattern;CircuitBreaker;State.callThrough.$anonfun.result">result</a> ⇒
          <a href="#akka.pattern;CircuitBreaker;State.callThrough.p" title="scala.concurrent.Promise[T]">p</a> <span title="(result: scala.util.Try[T])Boolean">tryComplete</span> <a href="#akka.pattern;CircuitBreaker;State.callThrough.$anonfun.result" title="scala.util.Try[T]">result</a>
          <a href="#akka.pattern;CircuitBreaker;State.callThrough.timeout" title="akka.actor.Cancellable">timeout</a>.<a href="../actor/Scheduler.scala.html#akka.actor;Cancellable.cancel" title="()Boolean">cancel</a>
        <span class="delimiter">}</span>
        <a href="#akka.pattern;CircuitBreaker;State.callThrough.p" title="scala.concurrent.Promise[T]">p</a>.<span title="=&gt; scala.concurrent.Future[T]">future</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Abstract entry point for all states
     *
     * @param body Implementation of the call that needs protected
     * @return Future containing result of protected call
     */</span>
    def <a title="[T](body: =&gt; scala.concurrent.Future[T])scala.concurrent.Future[T]" id="akka.pattern;CircuitBreaker;State.invoke">invoke</a><span class="delimiter">[</span><a title="" id="akka.pattern;CircuitBreaker;State.invoke;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scala.concurrent.Future[T]" id="akka.pattern;CircuitBreaker;State.invoke.body">body</a>: ⇒ Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scala.concurrent.Future[T]">Future</span><span class="delimiter">[</span>T<span class="delimiter">]</span>

    <span class="comment">/**
     * Invoked when call succeeds
     *
     */</span>
    def <a title="()Unit" id="akka.pattern;CircuitBreaker;State.callSucceeds">callSucceeds</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span>

    <span class="comment">/**
     * Invoked when call fails
     *
     */</span>
    def <a title="()Unit" id="akka.pattern;CircuitBreaker;State.callFails">callFails</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span>

    <span class="comment">/**
     * Invoked on the transitioned-to state during transition.  Notifies listeners after invoking subclass template
     * method _enter
     *
     */</span>
    final def <a title="()Unit" id="akka.pattern;CircuitBreaker;State.enter">enter</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
      <a href="#akka.pattern;CircuitBreaker;State._enter" title="()Unit">_enter</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#akka.pattern;CircuitBreaker;State.notifyTransitionListeners" title="()Unit">notifyTransitionListeners</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Template method for concrete traits
     *
     */</span>
    def <a title="()Unit" id="akka.pattern;CircuitBreaker;State._enter">_enter</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Concrete implementation of Closed state
   */</span>
  private object <a title="CircuitBreaker.this.Closed.type" id="akka.pattern;CircuitBreaker.Closed.readResolve">Closed</a> extends <span title="java.util.concurrent.atomic.AtomicInteger">AtomicInteger</span> with <a href="#akka.pattern;CircuitBreaker;State" title="CircuitBreaker.this.State">State</a> <span class="delimiter">{</span>

    <span class="comment">/**
     * Implementation of invoke, which simply attempts the call
     *
     * @param body Implementation of the call that needs protected
     * @return Future containing result of protected call
     */</span>
    override def <a title="[T](body: =&gt; scala.concurrent.Future[T])scala.concurrent.Future[T]" id="akka.pattern;CircuitBreaker.Closed.invoke">invoke</a><span class="delimiter">[</span><a title="" id="akka.pattern;CircuitBreaker.Closed.invoke;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scala.concurrent.Future[T]" id="akka.pattern;CircuitBreaker.Closed.invoke.body">body</a>: ⇒ Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scala.concurrent.Future[T]">Future</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#akka.pattern;CircuitBreaker;State.callThrough" title="(body: =&gt; scala.concurrent.Future[T])scala.concurrent.Future[T]">callThrough</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.Closed.invoke.body" title="=&gt; scala.concurrent.Future[T]">body</a><span class="delimiter">)</span>

    <span class="comment">/**
     * On successful call, the failure count is reset to 0
     *
     * @return
     */</span>
    override def <a title="()Unit" id="akka.pattern;CircuitBreaker.Closed.callSucceeds">callSucceeds</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span title="(x$1: Int)Unit">set</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>

    <span class="comment">/**
     * On failed call, the failure count is incremented.  The count is checked against the configured maxFailures, and
     * the breaker is tripped if we have reached maxFailures.
     *
     * @return
     */</span>
    override def <a title="()Unit" id="akka.pattern;CircuitBreaker.Closed.callFails">callFails</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = if <span class="delimiter">(</span><span title="()Int">incrementAndGet</span><span class="delimiter">(</span><span class="delimiter">)</span> <span title="(x: Int)Boolean">==</span> <a href="#akka.pattern;CircuitBreaker.maxFailures" title="Int">maxFailures</a><span class="delimiter">)</span> <a href="#akka.pattern;CircuitBreaker.tripBreaker" title="(fromState: CircuitBreaker.this.State)Unit">tripBreaker</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.Closed.readResolve" title="CircuitBreaker.this.Closed.type">Closed</a><span class="delimiter">)</span>

    <span class="comment">/**
     * On entry of this state, failure count is reset.
     *
     * @return
     */</span>
    override def <a title="()Unit" id="akka.pattern;CircuitBreaker.Closed._enter">_enter</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span title="(x$1: Int)Unit">set</span><span class="delimiter">(</span><span title="Int(0)" class="int">0</span><span class="delimiter">)</span>

    <span class="comment">/**
     * Override for more descriptive toString
     *
     * @return
     */</span>
    override def <a title="()String" id="akka.pattern;CircuitBreaker.Closed.toString">toString</a>: <span title="String">String</span> = <span title="String(&quot;Closed with failure count = &quot;)" class="string">&quot;Closed with failure count = &quot;</span> <span title="(x$1: Any)String">+</span> <span title="()Int">get</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Concrete implementation of half-open state
   */</span>
  private object <a title="CircuitBreaker.this.HalfOpen.type" id="akka.pattern;CircuitBreaker.HalfOpen.readResolve">HalfOpen</a> extends <span title="java.util.concurrent.atomic.AtomicBoolean">AtomicBoolean</span><span class="delimiter">(</span>true<span class="delimiter">)</span> with <a href="#akka.pattern;CircuitBreaker;State" title="CircuitBreaker.this.State">State</a> <span class="delimiter">{</span>

    <span class="comment">/**
     * Allows a single call through, during which all other callers fail-fast.  If the call fails, the breaker reopens.
     * If the call succeeds the breaker closes.
     *
     * @param body Implementation of the call that needs protected
     * @return Future containing result of protected call
     */</span>
    override def <a title="[T](body: =&gt; scala.concurrent.Future[T])scala.concurrent.Future[T]" id="akka.pattern;CircuitBreaker.HalfOpen.invoke">invoke</a><span class="delimiter">[</span><a title="" id="akka.pattern;CircuitBreaker.HalfOpen.invoke;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scala.concurrent.Future[T]" id="akka.pattern;CircuitBreaker.HalfOpen.invoke.body">body</a>: ⇒ Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scala.concurrent.Future[T]">Future</span><span class="delimiter">[</span>T<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><span title="(x$1: Boolean, x$2: Boolean)Boolean">compareAndSet</span><span class="delimiter">(</span>true, false<span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.pattern;CircuitBreaker;State.callThrough" title="(body: =&gt; scala.concurrent.Future[T])scala.concurrent.Future[T]">callThrough</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.HalfOpen.invoke.body" title="=&gt; scala.concurrent.Future[T]">body</a><span class="delimiter">)</span> else <span title="scala.concurrent.Promise.type">Promise</span>.<span title="[T](exception: Throwable)scala.concurrent.Promise[T]">failed</span><span title="(exception: Throwable)scala.concurrent.Promise[T]" class="delimiter">[</span><a href="#akka.pattern;CircuitBreaker.HalfOpen.invoke;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span>new <a href="#akka.pattern.CircuitBreakerOpenException.readResolve" title="akka.pattern.CircuitBreakerOpenException">CircuitBreakerOpenException</a><span class="delimiter">(</span><span title="implicit scala.concurrent.duration.package.DurationInt : (n: Int)concurrent.duration.DurationInt" class="int">0</span>.<span title="=&gt; scala.concurrent.duration.FiniteDuration">seconds</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; scala.concurrent.Future[T]">future</span>

    <span class="comment">/**
     * Reset breaker on successful call.
     *
     * @return
     */</span>
    override def <a title="()Unit" id="akka.pattern;CircuitBreaker.HalfOpen.callSucceeds">callSucceeds</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.pattern;CircuitBreaker.resetBreaker" title="()Unit">resetBreaker</a><span class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/**
     * Reopen breaker on failed call.
     *
     * @return
     */</span>
    override def <a title="()Unit" id="akka.pattern;CircuitBreaker.HalfOpen.callFails">callFails</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.pattern;CircuitBreaker.tripBreaker" title="(fromState: CircuitBreaker.this.State)Unit">tripBreaker</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.HalfOpen.readResolve" title="CircuitBreaker.this.HalfOpen.type">HalfOpen</a><span class="delimiter">)</span>

    <span class="comment">/**
     * On entry, guard should be reset for that first call to get in
     *
     * @return
     */</span>
    override def <a title="()Unit" id="akka.pattern;CircuitBreaker.HalfOpen._enter">_enter</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span title="(x$1: Boolean)Unit">set</span><span class="delimiter">(</span>true<span class="delimiter">)</span>

    <span class="comment">/**
     * Override for more descriptive toString
     *
     * @return
     */</span>
    override def <a title="()String" id="akka.pattern;CircuitBreaker.HalfOpen.toString">toString</a>: <span title="String">String</span> = <span title="String(&quot;Half-Open currently testing call for success = &quot;)" class="string">&quot;Half-Open currently testing call for success = &quot;</span> <span title="(x$1: Any)String">+</span> <span title="()Boolean">get</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Concrete implementation of Open state
   */</span>
  private object <a title="CircuitBreaker.this.Open.type" id="akka.pattern;CircuitBreaker.Open.readResolve">Open</a> extends <span title="java.util.concurrent.atomic.AtomicLong">AtomicLong</span> with <a href="#akka.pattern;CircuitBreaker;State" title="CircuitBreaker.this.State">State</a> <span class="delimiter">{</span>

    <span class="comment">/**
     * Fail-fast on any invocation
     *
     * @param body Implementation of the call that needs protected
     * @return Future containing result of protected call
     */</span>
    override def <a title="[T](body: =&gt; scala.concurrent.Future[T])scala.concurrent.Future[T]" id="akka.pattern;CircuitBreaker.Open.invoke">invoke</a><span class="delimiter">[</span><a title="" id="akka.pattern;CircuitBreaker.Open.invoke;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="=&gt; scala.concurrent.Future[T]" id="akka.pattern;CircuitBreaker.Open.invoke.body">body</a>: ⇒ Future<span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="scala.concurrent.Future[T]">Future</span><span class="delimiter">[</span>T<span class="delimiter">]</span> =
      <span title="scala.concurrent.Promise.type">Promise</span>.<span title="[T](exception: Throwable)scala.concurrent.Promise[T]">failed</span><span title="(exception: Throwable)scala.concurrent.Promise[T]" class="delimiter">[</span><a href="#akka.pattern;CircuitBreaker.Open.invoke;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span>new <a href="#akka.pattern.CircuitBreakerOpenException.readResolve" title="akka.pattern.CircuitBreakerOpenException">CircuitBreakerOpenException</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.Open.remainingDuration" title="()scala.concurrent.duration.FiniteDuration">remainingDuration</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="=&gt; scala.concurrent.Future[T]">future</span>

    <span class="comment">/**
     * Calculate remaining duration until reset to inform the caller in case a backoff algorithm is useful
     *
     * @return duration to when the breaker will attempt a reset by transitioning to half-open
     */</span>
    private def <a title="()scala.concurrent.duration.FiniteDuration" id="akka.pattern;CircuitBreaker.Open.remainingDuration">remainingDuration</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span> = <span class="delimiter">{</span>
      val diff = <span title="System.type">System</span>.<span title="()Long">nanoTime</span><span class="delimiter">(</span><span class="delimiter">)</span> <a title="Long" id="akka.pattern;CircuitBreaker.Open.remainingDuration.diff">-</a> <span title="()Long">get</span>
      if <span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.Open.remainingDuration.diff" title="Long">diff</a> <span title="(x: Long)Boolean">&lt;=</span> <span title="Long(0L)" class="long">0L</span><span class="delimiter">)</span> <span title="scala.concurrent.duration.Duration.type">Duration</span>.<span title="=&gt; scala.concurrent.duration.FiniteDuration">Zero</span>
      else <a href="#akka.pattern;CircuitBreaker.Open.remainingDuration.diff" title="implicit scala.concurrent.duration.package.DurationLong : (n: Long)concurrent.duration.DurationLong">diff</a>.<span title="=&gt; scala.concurrent.duration.FiniteDuration">nanos</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * No-op for open, calls are never executed so cannot succeed or fail
     *
     * @return
     */</span>
    override def <a title="()Unit" id="akka.pattern;CircuitBreaker.Open.callSucceeds">callSucceeds</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/**
     * No-op for open, calls are never executed so cannot succeed or fail
     *
     * @return
     */</span>
    override def <a title="()Unit" id="akka.pattern;CircuitBreaker.Open.callFails">callFails</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>

    <span class="comment">/**
     * On entering this state, schedule an attempted reset via [[akka.actor.Scheduler]] and store the entry time to
     * calculate remaining time before attempted reset.
     *
     * @return
     */</span>
    override def <a title="()Unit" id="akka.pattern;CircuitBreaker.Open._enter">_enter</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
      <span title="(x$1: Long)Unit">set</span><span class="delimiter">(</span><span title="System.type">System</span>.<span title="()Long">nanoTime</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#akka.pattern;CircuitBreaker.scheduler" title="akka.actor.Scheduler">scheduler</a>.<a href="../actor/Scheduler.scala.html#akka.actor;Scheduler.scheduleOnce(066d40b78a)" title="(delay: scala.concurrent.duration.FiniteDuration)(f: =&gt; Unit)(implicit executor: scala.concurrent.ExecutionContext)akka.actor.Cancellable">scheduleOnce</a><span class="delimiter">(</span><a href="#akka.pattern;CircuitBreaker.resetTimeout" title="scala.concurrent.duration.FiniteDuration">resetTimeout</a><span class="delimiter">)</span> <a href="#akka.pattern;CircuitBreaker.executor" title="scala.concurrent.ExecutionContext" class="delimiter">{</a>
        <a href="#akka.pattern;CircuitBreaker.attemptReset" title="()Unit">attemptReset</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Override for more descriptive toString
     *
     * @return
     */</span>
    override def <a title="()String" id="akka.pattern;CircuitBreaker.Open.toString">toString</a>: <span title="String">String</span> = <span title="String(&quot;Open&quot;)" class="string">&quot;Open&quot;</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * Exception thrown when Circuit Breaker is open.
 *
 * @param remainingDuration Stores remaining time before attempting a reset.  Zero duration means the breaker is
 *                          currently in half-open state.
 * @param message Defaults to &quot;Circuit Breaker is open; calls are failing fast&quot;
 */</span>
class <a title="class CircuitBreakerOpenException extends akka.AkkaException with scala.util.control.NoStackTrace" id="akka.pattern.CircuitBreakerOpenException.readResolve">CircuitBreakerOpenException</a><a href="#akka.pattern.CircuitBreakerOpenException.readResolve" title="akka.pattern.CircuitBreakerOpenException" class="delimiter">(</a>
  val <a title="scala.concurrent.duration.FiniteDuration" id="akka.pattern;CircuitBreakerOpenException.remainingDuration">remainingDuration</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>,
  <a title="String" id="akka.pattern.CircuitBreakerOpenException.<init>$default$2">message</a>: <span title="String">String</span> = <span title="String(&quot;Circuit Breaker is open; calls are failing fast&quot;)" class="string">&quot;Circuit Breaker is open; calls are failing fast&quot;</span><span class="delimiter">)</span>
  extends <a href="../AkkaException.scala.html#akka;AkkaException" title="akka.AkkaException">AkkaException</a><span class="delimiter">(</span><a href="#akka.pattern.CircuitBreakerOpenException.<init>$default$2" title="String">message</a><span class="delimiter">)</span> with <span title="scala.util.control.NoStackTrace">NoStackTrace</span>

        </pre>
    </body>
</html>
