<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>actor/akka/util/SubclassifiedIndex.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Copyright (C) 2009-2015 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
package akka.util

import scala.collection.immutable

<span class="comment">/**
 * Typeclass which describes a classification hierarchy. Observe the contract between `isEqual` and `isSubclass`!
 */</span>
trait <a title="trait Subclassification[K] extends AnyRef" id="akka.util;Subclassification">Subclassification</a><span class="delimiter">[</span><a title="" id="akka.util;Subclassification;K">K</a><span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="comment">/**
   * True if and only if x and y are of the same class.
   */</span>
  def <a title="(x: K, y: K)Boolean" id="akka.util;Subclassification.isEqual">isEqual</a><span class="delimiter">(</span><a title="K" id="akka.util;Subclassification.isEqual.x">x</a>: <a href="#akka.util;Subclassification;K" title="K">K</a>, <a title="K" id="akka.util;Subclassification.isEqual.y">y</a>: <a href="#akka.util;Subclassification;K" title="K">K</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span>
  <span class="comment">/**
   * True if and only if x is a subclass of y; equal classes must be considered sub-classes!
   */</span>
  def <a title="(x: K, y: K)Boolean" id="akka.util;Subclassification.isSubclass">isSubclass</a><span class="delimiter">(</span><a title="K" id="akka.util;Subclassification.isSubclass.x">x</a>: <a href="#akka.util;Subclassification;K" title="K">K</a>, <a title="K" id="akka.util;Subclassification.isSubclass.y">y</a>: <a href="#akka.util;Subclassification;K" title="K">K</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span>
<span class="delimiter">}</span>

private<span class="delimiter">[</span>akka<span class="delimiter">]</span> object <a title="akka.util.SubclassifiedIndex.type" id="akka.util.SubclassifiedIndex">SubclassifiedIndex</a> <a href="#akka.util.SubclassifiedIndex" title="akka.util.SubclassifiedIndex.type" class="delimiter">{</a>

  class <a title="class Nonroot[K, V] extends akka.util.SubclassifiedIndex[K,V]" id="akka.util.SubclassifiedIndex;Nonroot">Nonroot</a><span class="delimiter">[</span><a title="" id="akka.util.SubclassifiedIndex;Nonroot;K">K</a>, <a title="" id="akka.util.SubclassifiedIndex;Nonroot;V">V</a><span class="delimiter">]</span><a href="#akka.util.SubclassifiedIndex;Nonroot" title="akka.util.SubclassifiedIndex.Nonroot[K,V]" class="delimiter">(</a>override val <a title="akka.util.SubclassifiedIndex[K,V]" id="akka.util.SubclassifiedIndex;Nonroot.root">root</a>: <a href="#akka.util;SubclassifiedIndex" title="akka.util.SubclassifiedIndex[K,V]">SubclassifiedIndex</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span>, val <a title="K" id="akka.util.SubclassifiedIndex;Nonroot.key">key</a>: <a href="#akka.util.SubclassifiedIndex;Nonroot;K" title="K">K</a>, <a title="Set[V]" id="akka.util.SubclassifiedIndex;Nonroot._values">_values</a>: <span title="Set[V]">Set</span><span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="akka.util.Subclassification[K]" id="akka.util.SubclassifiedIndex;Nonroot.sc">sc</a>: <a href="#akka.util;Subclassification" title="akka.util.Subclassification[K]">Subclassification</a><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span> extends <a href="#akka.util;SubclassifiedIndex" title="akka.util.SubclassifiedIndex[K,V]">SubclassifiedIndex</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot._values" title="Set[V]">_values</a><span class="delimiter">)</span> <span class="delimiter">{</span>

    override def <a title="(key: K, value: V)Nonroot.this.Changes" id="akka.util.SubclassifiedIndex;Nonroot.innerAddValue">innerAddValue</a><span class="delimiter">(</span><a title="K" id="akka.util.SubclassifiedIndex;Nonroot.innerAddValue.key">key</a>: <a href="#akka.util.SubclassifiedIndex;Nonroot;K" title="K">K</a>, <a title="V" id="akka.util.SubclassifiedIndex;Nonroot.innerAddValue.value">value</a>: <a href="#akka.util.SubclassifiedIndex;Nonroot;V" title="V">V</a><span class="delimiter">)</span>: <span title="Nonroot.this.Changes">Changes</span> = <span class="delimiter">{</span>
      <span class="comment">// break the recursion on super when key is found and transition to recursive add-to-set</span>
      if <span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.sc" title="akka.util.Subclassification[K]">sc</a>.<a href="#akka.util;Subclassification.isEqual" title="(x: K, y: K)Boolean">isEqual</a><span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.innerAddValue.key" title="K">key</a>, this.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.util.SubclassifiedIndex;Nonroot.addValue(0c96b8536c)" title="(value: V)Nonroot.this.Changes">addValue</a><span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.innerAddValue.value" title="V">value</a><span class="delimiter">)</span> else super.<a href="#akka.util;SubclassifiedIndex.innerAddValue" title="(key: K, value: V)Nonroot.this.Changes">innerAddValue</a><span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.innerAddValue.key" title="K">key</a>, <a href="#akka.util.SubclassifiedIndex;Nonroot.innerAddValue.value" title="V">value</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    private def <a title="(value: V)Nonroot.this.Changes" id="akka.util.SubclassifiedIndex;Nonroot.addValue(0c96b8536c)">addValue</a><span class="delimiter">(</span><a title="V" id="akka.util.SubclassifiedIndex;Nonroot.addValue(0c96b8536c).value">value</a>: <a href="#akka.util.SubclassifiedIndex;Nonroot;V" title="V">V</a><span class="delimiter">)</span>: <span title="Nonroot.this.Changes">Changes</span> = <span class="delimiter">{</span>
      val kids = <a href="#akka.util;SubclassifiedIndex.subkeys_=" title="=&gt; scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subkeys</a> <a title="scala.collection.immutable.Vector[(K, Set[V])]" id="akka.util.SubclassifiedIndex;Nonroot.addValue(0c96b8536c).kids">flatMap</a> <span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.addValue(0c96b8536c).kids.$anonfun.x$1" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">_</a> <a href="#akka.util.SubclassifiedIndex;Nonroot.addValue(0c96b8536c)" title="(value: V)scala.collection.immutable.Seq[(K, Set[V])]">addValue</a> <a href="#akka.util.SubclassifiedIndex;Nonroot.addValue(0c96b8536c).value" title="V">value</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.values" title="=&gt; Set[V]">values</a> <span title="(elem: V)Boolean">contains</span> <a href="#akka.util.SubclassifiedIndex;Nonroot.addValue(0c96b8536c).value" title="V">value</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#akka.util;SubclassifiedIndex.values" title="(x$1: Set[V])Unit">values</a> <span title="(elem: V)scala.collection.immutable.Set[V]">+=</span> <a href="#akka.util.SubclassifiedIndex;Nonroot.addValue(0c96b8536c).value" title="V">value</a>
        <a href="#akka.util.SubclassifiedIndex;Nonroot.addValue(0c96b8536c).kids" title="scala.collection.immutable.Vector[(K, Set[V])]">kids</a> <span title="(elem: (K, Set[V]))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[(K, Set[V])],(K, Set[V]),Nonroot.this.Changes])Nonroot.this.Changes">:+</span> <span class="delimiter">(</span><span title="(_1: K, _2: scala.collection.immutable.Set[V])(K, scala.collection.immutable.Set[V])" class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a>, <span title="(elems: V*)scala.collection.immutable.Set[V]">Set</span><span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.addValue(0c96b8536c).value" title="V">value</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <a href="#akka.util.SubclassifiedIndex;Nonroot.addValue(0c96b8536c).kids" title="scala.collection.immutable.Vector[(K, Set[V])]">kids</a>
    <span class="delimiter">}</span>

    <span class="comment">// this will return the keys and values to be removed from the cache</span>
    override def <a title="(key: K, value: V)Nonroot.this.Changes" id="akka.util.SubclassifiedIndex;Nonroot.innerRemoveValue">innerRemoveValue</a><span class="delimiter">(</span><a title="K" id="akka.util.SubclassifiedIndex;Nonroot.innerRemoveValue.key">key</a>: <a href="#akka.util.SubclassifiedIndex;Nonroot;K" title="K">K</a>, <a title="V" id="akka.util.SubclassifiedIndex;Nonroot.innerRemoveValue.value">value</a>: <a href="#akka.util.SubclassifiedIndex;Nonroot;V" title="V">V</a><span class="delimiter">)</span>: <span title="Nonroot.this.Changes">Changes</span> = <span class="delimiter">{</span>
      <span class="comment">// break the recursion on super when key is found and transition to recursive remove-from-set</span>
      if <span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.sc" title="akka.util.Subclassification[K]">sc</a>.<a href="#akka.util;Subclassification.isEqual" title="(x: K, y: K)Boolean">isEqual</a><span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.innerRemoveValue.key" title="K">key</a>, this.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.util.SubclassifiedIndex;Nonroot.removeValue(0c96b8536c)" title="(value: V)Nonroot.this.Changes">removeValue</a><span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.innerRemoveValue.value" title="V">value</a><span class="delimiter">)</span> else super.<a href="#akka.util;SubclassifiedIndex.innerRemoveValue" title="(key: K, value: V)Nonroot.this.Changes">innerRemoveValue</a><span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.innerRemoveValue.key" title="K">key</a>, <a href="#akka.util.SubclassifiedIndex;Nonroot.innerRemoveValue.value" title="V">value</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    override def <a title="(value: V)Nonroot.this.Changes" id="akka.util.SubclassifiedIndex;Nonroot.removeValue(0c96b8536c)">removeValue</a><span class="delimiter">(</span><a title="V" id="akka.util.SubclassifiedIndex;Nonroot.removeValue(0c96b8536c).value">value</a>: <a href="#akka.util.SubclassifiedIndex;Nonroot;V" title="V">V</a><span class="delimiter">)</span>: <span title="Nonroot.this.Changes">Changes</span> = <span class="delimiter">{</span>
      val kids = <a href="#akka.util;SubclassifiedIndex.subkeys_=" title="=&gt; scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subkeys</a> <a title="scala.collection.immutable.Vector[(K, Set[V])]" id="akka.util.SubclassifiedIndex;Nonroot.removeValue(0c96b8536c).kids">flatMap</a> <span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.removeValue(0c96b8536c).kids.$anonfun.x$2" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">_</a> <a href="#akka.util.SubclassifiedIndex;Nonroot.removeValue(0c96b8536c)" title="(value: V)scala.collection.immutable.Seq[(K, Set[V])]">removeValue</a> <a href="#akka.util.SubclassifiedIndex;Nonroot.removeValue(0c96b8536c).value" title="V">value</a><span class="delimiter">)</span>
      if <span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.values" title="=&gt; Set[V]">values</a> <span title="(elem: V)Boolean">contains</span> <a href="#akka.util.SubclassifiedIndex;Nonroot.removeValue(0c96b8536c).value" title="V">value</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#akka.util;SubclassifiedIndex.values" title="(x$1: Set[V])Unit">values</a> <span title="(elem: V)scala.collection.immutable.Set[V]">-=</span> <a href="#akka.util.SubclassifiedIndex;Nonroot.removeValue(0c96b8536c).value" title="V">value</a>
        <a href="#akka.util.SubclassifiedIndex;Nonroot.removeValue(0c96b8536c).kids" title="scala.collection.immutable.Vector[(K, Set[V])]">kids</a> <span title="(elem: (K, Set[V]))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[(K, Set[V])],(K, Set[V]),Nonroot.this.Changes])Nonroot.this.Changes">:+</span> <span class="delimiter">(</span><span title="(_1: K, _2: scala.collection.immutable.Set[V])(K, scala.collection.immutable.Set[V])" class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a>, <span title="(elems: V*)scala.collection.immutable.Set[V]">Set</span><span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.removeValue(0c96b8536c).value" title="V">value</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <a href="#akka.util.SubclassifiedIndex;Nonroot.removeValue(0c96b8536c).kids" title="scala.collection.immutable.Vector[(K, Set[V])]">kids</a>
    <span class="delimiter">}</span>

    override def <a title="(key: K)Set[V]" id="akka.util.SubclassifiedIndex;Nonroot.innerFindValues">innerFindValues</a><span class="delimiter">(</span><a title="K" id="akka.util.SubclassifiedIndex;Nonroot.innerFindValues.key">key</a>: <a href="#akka.util.SubclassifiedIndex;Nonroot;K" title="K">K</a><span class="delimiter">)</span>: <span title="Set[V]">Set</span><span class="delimiter">[</span>V<span class="delimiter">]</span> =
      if <span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.sc" title="akka.util.Subclassification[K]">sc</a>.<a href="#akka.util;Subclassification.isEqual" title="(x: K, y: K)Boolean">isEqual</a><span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.innerFindValues.key" title="K">key</a>, this.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.util;SubclassifiedIndex.values" title="=&gt; Set[V]">values</a> else super.<a href="#akka.util;SubclassifiedIndex.innerFindValues" title="(key: K)Set[V]">innerFindValues</a><span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex;Nonroot.innerFindValues.key" title="K">key</a><span class="delimiter">)</span>

    override def <a title="()String" id="akka.util.SubclassifiedIndex;Nonroot.toString">toString</a> = <a href="#akka.util;SubclassifiedIndex.subkeys_=" title="=&gt; scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subkeys</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;Nonroot(&quot;)" class="string">&quot;Nonroot(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.util;SubclassifiedIndex.values" title="=&gt; Set[V]">values</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;,\n&quot;)" class="string">&quot;,\n&quot;</span>, <span title="String(&quot;,\n&quot;)" class="string">&quot;,\n&quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private<span class="delimiter">[</span>SubclassifiedIndex<span class="delimiter">]</span> def <a title="[K, V]=&gt; Map[K,Set[V]]" id="akka.util.SubclassifiedIndex.emptyMergeMap">emptyMergeMap</a><span class="delimiter">[</span><a title="" id="akka.util.SubclassifiedIndex.emptyMergeMap;K">K</a>, <a title="" id="akka.util.SubclassifiedIndex.emptyMergeMap;V">V</a><span class="delimiter">]</span> = <a href="#akka.util.SubclassifiedIndex.internalEmptyMergeMap" title="scala.collection.immutable.Map[AnyRef,Set[AnyRef]]">internalEmptyMergeMap</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Map[K,Set[V]]" class="delimiter">[</span><span title="Map[K,Set[V]]">Map</span><span class="delimiter">[</span>K, Set<span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
  private<span class="delimiter">[</span>this<span class="delimiter">]</span> val <a title="scala.collection.immutable.Map[AnyRef,Set[AnyRef]]" id="akka.util.SubclassifiedIndex.internalEmptyMergeMap">internalEmptyMergeMap</a> = <span title="[A, B](elems: (A, B)*)scala.collection.immutable.Map[A,B]">Map</span><span title="(elems: (AnyRef, Set[AnyRef])*)scala.collection.immutable.Map[AnyRef,Set[AnyRef]]" class="delimiter">[</span><span title="AnyRef">AnyRef</span>, <span title="Set[AnyRef]">Set</span><span class="delimiter">[</span>AnyRef<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="(d: Set[AnyRef])scala.collection.immutable.Map[AnyRef,Set[AnyRef]]">withDefaultValue</span><span class="delimiter">(</span><span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: AnyRef*)scala.collection.immutable.Set[AnyRef]" class="delimiter">[</span><span title="AnyRef">AnyRef</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Mutable index which respects sub-class relationships between keys:
 *
 *  - adding a key inherits from super-class
 *  - adding values applies to all sub-classes
 *  - removing values applies to all sub-classes
 *
 * Currently this class is only used to keep the tree and return changed key-
 * value-sets upon modification, since looking up the keys in an external
 * cache, e.g. HashMap, is faster than tree traversal which must use linear
 * scan at each level. Therefore, no value traversals are published.
 */</span>
private<span class="delimiter">[</span>akka<span class="delimiter">]</span> class <a title="class SubclassifiedIndex[K, V] extends AnyRef" id="akka.util;SubclassifiedIndex">SubclassifiedIndex</a><span class="delimiter">[</span><a title="" id="akka.util;SubclassifiedIndex;K">K</a>, <a title="" id="akka.util;SubclassifiedIndex;V">V</a><span class="delimiter">]</span> private <span class="delimiter">(</span>protected var <a title="Set[V]" id="akka.util;SubclassifiedIndex.values">values</a>: <span title="Set[V]">Set</span><span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="akka.util.Subclassification[K]" id="akka.util;SubclassifiedIndex.sc">sc</a>: <a href="#akka.util;Subclassification" title="akka.util.Subclassification[K]">Subclassification</a><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

  import <a href="#akka.util.SubclassifiedIndex" title="akka.util.SubclassifiedIndex.type">SubclassifiedIndex</a>._

  type <a title="scala.collection.immutable.Seq[(K, Set[V])]" id="akka.util;SubclassifiedIndex;Changes">Changes</a> = immutable.<span title="scala.collection.immutable.Seq[(K, Set[V])]">Seq</span><span class="delimiter">[</span><span class="delimiter">(</span>K, Set<span class="delimiter">[</span>V<span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">]</span>

  protected var <a title="scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]" id="akka.util;SubclassifiedIndex.subkeys_=">subkeys</a> = <span title="=&gt; collection.immutable.Vector.type">Vector</span>.<span title="[A]=&gt; scala.collection.immutable.Vector[A]">empty</span><span title="scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]" class="delimiter">[</span><a href="#akka.util.SubclassifiedIndex;Nonroot" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">Nonroot</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span>

  def this<span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span>implicit <a title="akka.util.Subclassification[K]" id="akka.util;SubclassifiedIndex.<init>(023c07cb85).sc">sc</a>: <a href="#akka.util;Subclassification" title="akka.util.Subclassification[K]">Subclassification</a><span class="delimiter">[</span>K<span class="delimiter">]</span><span class="delimiter">)</span> = this<span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Set.type">Set</span>.<span title="scala.collection.immutable.Set[V]">empty</span><span class="delimiter">)</span>

  protected val <a title="akka.util.SubclassifiedIndex[K,V]" id="akka.util;SubclassifiedIndex.root">root</a> = this

  <span class="comment">/**
   * Add key to this index which inherits its value set from the most specific
   * super-class which is known.
   *
   * @return the diff that should be added to the cache
   */</span>
  def <a title="(key: K)SubclassifiedIndex.this.Changes" id="akka.util;SubclassifiedIndex.addKey">addKey</a><span class="delimiter">(</span><a title="K" id="akka.util;SubclassifiedIndex.addKey.key">key</a>: <a href="#akka.util;SubclassifiedIndex;K" title="K">K</a><span class="delimiter">)</span>: <span title="SubclassifiedIndex.this.Changes">Changes</span> = <a href="#akka.util;SubclassifiedIndex.mergeChangesByKey" title="(changes: SubclassifiedIndex.this.Changes)SubclassifiedIndex.this.Changes">mergeChangesByKey</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerAddKey" title="(key: K)SubclassifiedIndex.this.Changes">innerAddKey</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.addKey.key" title="K">key</a><span class="delimiter">)</span><span class="delimiter">)</span>

  protected def <a title="(key: K)SubclassifiedIndex.this.Changes" id="akka.util;SubclassifiedIndex.innerAddKey">innerAddKey</a><span class="delimiter">(</span><a title="K" id="akka.util;SubclassifiedIndex.innerAddKey.key">key</a>: <a href="#akka.util;SubclassifiedIndex;K" title="K">K</a><span class="delimiter">)</span>: <span title="SubclassifiedIndex.this.Changes">Changes</span> = <span class="delimiter">{</span>
    var <a title="Boolean" id="akka.util;SubclassifiedIndex.innerAddKey.found">found</a> = false
    val ch = <a href="#akka.util;SubclassifiedIndex.subkeys_=" title="=&gt; scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subkeys</a> <a title="scala.collection.immutable.Vector[(K, Set[V])]" id="akka.util;SubclassifiedIndex.innerAddKey.ch">flatMap</a> <span class="delimiter">{</span> <a title="akka.util.SubclassifiedIndex.Nonroot[K,V]" id="akka.util;SubclassifiedIndex.innerAddKey.ch.$anonfun.n">n</a> ⇒
      if <span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.sc" title="akka.util.Subclassification[K]">sc</a>.<a href="#akka.util;Subclassification.isEqual" title="(x: K, y: K)Boolean">isEqual</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerAddKey.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.innerAddKey.ch.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#akka.util;SubclassifiedIndex.innerAddKey.found" title="Boolean">found</a> = true
        <span title="scala.collection.immutable.Nil.type">Nil</span>
      <span class="delimiter">}</span> else if <span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.sc" title="akka.util.Subclassification[K]">sc</a>.<a href="#akka.util;Subclassification.isSubclass" title="(x: K, y: K)Boolean">isSubclass</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerAddKey.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.innerAddKey.ch.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#akka.util;SubclassifiedIndex.innerAddKey.found" title="Boolean">found</a> = true
        <a href="#akka.util;SubclassifiedIndex.innerAddKey.ch.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util;SubclassifiedIndex.innerAddKey" title="(key: K)n.Changes">innerAddKey</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerAddKey.key" title="K">key</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="delimiter">}</span>
    if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#akka.util;SubclassifiedIndex.innerAddKey.found" title="Boolean">found</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#akka.util;SubclassifiedIndex.integrate" title="(n: akka.util.SubclassifiedIndex.Nonroot[K,V])SubclassifiedIndex.this.Changes">integrate</a><span class="delimiter">(</span>new <a href="#akka.util.SubclassifiedIndex;Nonroot" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">Nonroot</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.root" title="=&gt; akka.util.SubclassifiedIndex[K,V]">root</a>, <a href="#akka.util;SubclassifiedIndex.innerAddKey.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.values" title="=&gt; Set[V]">values</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(elem: (K, Set[V]))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Seq[(K, Set[V])],(K, Set[V]),SubclassifiedIndex.this.Changes])SubclassifiedIndex.this.Changes">:+</span> <span class="delimiter">(</span><span title="(_1: K, _2: Set[V])(K, Set[V])" class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerAddKey.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.values" title="=&gt; Set[V]">values</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <a href="#akka.util;SubclassifiedIndex.innerAddKey.ch" title="scala.collection.immutable.Vector[(K, Set[V])]">ch</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Add value to all keys which are subclasses of the given key. If the key
   * is not known yet, it is inserted as if using addKey.
   *
   * @return the diff that should be added to the cache
   */</span>
  def <a title="(key: K, value: V)SubclassifiedIndex.this.Changes" id="akka.util;SubclassifiedIndex.addValue">addValue</a><span class="delimiter">(</span><a title="K" id="akka.util;SubclassifiedIndex.addValue.key">key</a>: <a href="#akka.util;SubclassifiedIndex;K" title="K">K</a>, <a title="V" id="akka.util;SubclassifiedIndex.addValue.value">value</a>: <a href="#akka.util;SubclassifiedIndex;V" title="V">V</a><span class="delimiter">)</span>: <span title="SubclassifiedIndex.this.Changes">Changes</span> = <a href="#akka.util;SubclassifiedIndex.mergeChangesByKey" title="(changes: SubclassifiedIndex.this.Changes)SubclassifiedIndex.this.Changes">mergeChangesByKey</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerAddValue" title="(key: K, value: V)SubclassifiedIndex.this.Changes">innerAddValue</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.addValue.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.addValue.value" title="V">value</a><span class="delimiter">)</span><span class="delimiter">)</span>

  protected def <a title="(key: K, value: V)SubclassifiedIndex.this.Changes" id="akka.util;SubclassifiedIndex.innerAddValue">innerAddValue</a><span class="delimiter">(</span><a title="K" id="akka.util;SubclassifiedIndex.innerAddValue.key">key</a>: <a href="#akka.util;SubclassifiedIndex;K" title="K">K</a>, <a title="V" id="akka.util;SubclassifiedIndex.innerAddValue.value">value</a>: <a href="#akka.util;SubclassifiedIndex;V" title="V">V</a><span class="delimiter">)</span>: <span title="SubclassifiedIndex.this.Changes">Changes</span> = <span class="delimiter">{</span>
    var <a title="Boolean" id="akka.util;SubclassifiedIndex.innerAddValue.found">found</a> = false
    val ch = <a href="#akka.util;SubclassifiedIndex.subkeys_=" title="=&gt; scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subkeys</a> <a title="scala.collection.immutable.Vector[(K, Set[V])]" id="akka.util;SubclassifiedIndex.innerAddValue.ch">flatMap</a> <span class="delimiter">{</span> <a title="akka.util.SubclassifiedIndex.Nonroot[K,V]" id="akka.util;SubclassifiedIndex.innerAddValue.ch.$anonfun.n">n</a> ⇒
      if <span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.sc" title="akka.util.Subclassification[K]">sc</a>.<a href="#akka.util;Subclassification.isSubclass" title="(x: K, y: K)Boolean">isSubclass</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerAddValue.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.innerAddValue.ch.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#akka.util;SubclassifiedIndex.innerAddValue.found" title="Boolean">found</a> = true
        <a href="#akka.util;SubclassifiedIndex.innerAddValue.ch.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.innerAddValue" title="(key: K, value: V)n.Changes">innerAddValue</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerAddValue.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.innerAddValue.value" title="V">value</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="delimiter">}</span>
    if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#akka.util;SubclassifiedIndex.innerAddValue.found" title="Boolean">found</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val v = <a href="#akka.util;SubclassifiedIndex.values" title="=&gt; Set[V]">values</a> <a title="scala.collection.immutable.Set[V]" id="akka.util;SubclassifiedIndex.innerAddValue.v">+</a> <a href="#akka.util;SubclassifiedIndex.innerAddValue.value" title="V">value</a>
      val <a title="akka.util.SubclassifiedIndex.Nonroot[K,V]" id="akka.util;SubclassifiedIndex.innerAddValue.n">n</a> = new <a href="#akka.util.SubclassifiedIndex;Nonroot" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">Nonroot</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.root" title="=&gt; akka.util.SubclassifiedIndex[K,V]">root</a>, <a href="#akka.util;SubclassifiedIndex.innerAddValue.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.innerAddValue.v" title="scala.collection.immutable.Set[V]">v</a><span class="delimiter">)</span>
      <a href="#akka.util;SubclassifiedIndex.integrate" title="(n: akka.util.SubclassifiedIndex.Nonroot[K,V])SubclassifiedIndex.this.Changes">integrate</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerAddValue.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[(K, Set[V])])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Seq[(K, Set[V])],(K, Set[V]),scala.collection.immutable.Seq[(K, Set[V])]])scala.collection.immutable.Seq[(K, Set[V])]">++</span> <a href="#akka.util;SubclassifiedIndex.innerAddValue.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.innerAddValue" title="(key: K, value: V)n.Changes">innerAddValue</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerAddValue.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.innerAddValue.value" title="V">value</a><span class="delimiter">)</span> <span title="(elem: (K, Set[V]))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Seq[(K, Set[V])],(K, Set[V]),SubclassifiedIndex.this.Changes])SubclassifiedIndex.this.Changes">:+</span> <span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerAddValue.key" title="(self: K)ArrowAssoc[K]">key</a> <span title="(y: scala.collection.immutable.Set[V])(K, scala.collection.immutable.Set[V])">-&gt;</span> <a href="#akka.util;SubclassifiedIndex.innerAddValue.v" title="scala.collection.immutable.Set[V]">v</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <a href="#akka.util;SubclassifiedIndex.innerAddValue.ch" title="scala.collection.immutable.Vector[(K, Set[V])]">ch</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Remove value from all keys which are subclasses of the given key.
   *
   * @return the complete changes that should be updated in the cache
   */</span>
  def <a title="(key: K, value: V)SubclassifiedIndex.this.Changes" id="akka.util;SubclassifiedIndex.removeValue(ead4d5783e)">removeValue</a><span class="delimiter">(</span><a title="K" id="akka.util;SubclassifiedIndex.removeValue(ead4d5783e).key">key</a>: <a href="#akka.util;SubclassifiedIndex;K" title="K">K</a>, <a title="V" id="akka.util;SubclassifiedIndex.removeValue(ead4d5783e).value">value</a>: <a href="#akka.util;SubclassifiedIndex;V" title="V">V</a><span class="delimiter">)</span>: <span title="SubclassifiedIndex.this.Changes">Changes</span> =
    <span class="comment">// the reason for not using the values in the returned diff is that we need to</span>
    <span class="comment">// go through the whole tree to find all values for the &quot;changed&quot; keys in other</span>
    <span class="comment">// parts of the tree as well, since new nodes might have been created</span>
    <a href="#akka.util;SubclassifiedIndex.mergeChangesByKey" title="(changes: SubclassifiedIndex.this.Changes)SubclassifiedIndex.this.Changes">mergeChangesByKey</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerRemoveValue" title="(key: K, value: V)SubclassifiedIndex.this.Changes">innerRemoveValue</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.removeValue(ead4d5783e).key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.removeValue(ead4d5783e).value" title="V">value</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(f: ((K, Set[V])) =&gt; (K, Set[V]))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Seq[(K, Set[V])],(K, Set[V]),SubclassifiedIndex.this.Changes])SubclassifiedIndex.this.Changes">map</span> <a href="#akka.util;SubclassifiedIndex.removeValue(ead4d5783e).$anonfun.x0$1" title="(K, Set[V])" class="delimiter">{</a>
      case <span class="delimiter">(</span><a title="K" id="akka.util;SubclassifiedIndex.removeValue(ead4d5783e).$anonfun.k">k</a>, _<span class="delimiter">)</span> ⇒ <span title="(_1: K, _2: Set[V])(K, Set[V])" class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.removeValue(ead4d5783e).$anonfun.k" title="K">k</a>, <a href="#akka.util;SubclassifiedIndex.findValues" title="(key: K)Set[V]">findValues</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.removeValue(ead4d5783e).$anonfun.k" title="K">k</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="comment">// this will return the keys and values to be removed from the cache</span>
  protected def <a title="(key: K, value: V)SubclassifiedIndex.this.Changes" id="akka.util;SubclassifiedIndex.innerRemoveValue">innerRemoveValue</a><span class="delimiter">(</span><a title="K" id="akka.util;SubclassifiedIndex.innerRemoveValue.key">key</a>: <a href="#akka.util;SubclassifiedIndex;K" title="K">K</a>, <a title="V" id="akka.util;SubclassifiedIndex.innerRemoveValue.value">value</a>: <a href="#akka.util;SubclassifiedIndex;V" title="V">V</a><span class="delimiter">)</span>: <span title="SubclassifiedIndex.this.Changes">Changes</span> = <span class="delimiter">{</span>
    var <a title="Boolean" id="akka.util;SubclassifiedIndex.innerRemoveValue.found">found</a> = false
    val ch = <a href="#akka.util;SubclassifiedIndex.subkeys_=" title="=&gt; scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subkeys</a> <a title="scala.collection.immutable.Vector[(K, Set[V])]" id="akka.util;SubclassifiedIndex.innerRemoveValue.ch">flatMap</a> <span class="delimiter">{</span> <a title="akka.util.SubclassifiedIndex.Nonroot[K,V]" id="akka.util;SubclassifiedIndex.innerRemoveValue.ch.$anonfun.n">n</a> ⇒
      if <span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.sc" title="akka.util.Subclassification[K]">sc</a>.<a href="#akka.util;Subclassification.isSubclass" title="(x: K, y: K)Boolean">isSubclass</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerRemoveValue.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.innerRemoveValue.ch.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#akka.util;SubclassifiedIndex.innerRemoveValue.found" title="Boolean">found</a> = true
        <a href="#akka.util;SubclassifiedIndex.innerRemoveValue.ch.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.innerRemoveValue" title="(key: K, value: V)n.Changes">innerRemoveValue</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerRemoveValue.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.innerRemoveValue.value" title="V">value</a><span class="delimiter">)</span>
      <span class="delimiter">}</span> else <span title="scala.collection.immutable.Nil.type">Nil</span>
    <span class="delimiter">}</span>
    if <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#akka.util;SubclassifiedIndex.innerRemoveValue.found" title="Boolean">found</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      val <a title="akka.util.SubclassifiedIndex.Nonroot[K,V]" id="akka.util;SubclassifiedIndex.innerRemoveValue.n">n</a> = new <a href="#akka.util.SubclassifiedIndex;Nonroot" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">Nonroot</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.root" title="=&gt; akka.util.SubclassifiedIndex[K,V]">root</a>, <a href="#akka.util;SubclassifiedIndex.innerRemoveValue.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.values" title="=&gt; Set[V]">values</a><span class="delimiter">)</span>
      <a href="#akka.util;SubclassifiedIndex.integrate" title="(n: akka.util.SubclassifiedIndex.Nonroot[K,V])SubclassifiedIndex.this.Changes">integrate</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerRemoveValue.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[(K, Set[V])])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Seq[(K, Set[V])],(K, Set[V]),SubclassifiedIndex.this.Changes])SubclassifiedIndex.this.Changes">++</span> <a href="#akka.util;SubclassifiedIndex.innerRemoveValue.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.removeValue(0c96b8536c)" title="(value: V)n.Changes">removeValue</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerRemoveValue.value" title="V">value</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> else <a href="#akka.util;SubclassifiedIndex.innerRemoveValue.ch" title="scala.collection.immutable.Vector[(K, Set[V])]">ch</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Remove value from all keys in the index.
   *
   * @return the diff that should be removed from the cache
   */</span>
  def <a title="(value: V)SubclassifiedIndex.this.Changes" id="akka.util;SubclassifiedIndex.removeValue(e0a34702a8)">removeValue</a><span class="delimiter">(</span><a title="V" id="akka.util;SubclassifiedIndex.removeValue(e0a34702a8).value">value</a>: <a href="#akka.util;SubclassifiedIndex;V" title="V">V</a><span class="delimiter">)</span>: <span title="SubclassifiedIndex.this.Changes">Changes</span> = <a href="#akka.util;SubclassifiedIndex.mergeChangesByKey" title="(changes: SubclassifiedIndex.this.Changes)SubclassifiedIndex.this.Changes">mergeChangesByKey</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.subkeys_=" title="=&gt; scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subkeys</a> <span title="(f: akka.util.SubclassifiedIndex.Nonroot[K,V] =&gt; scala.collection.GenTraversableOnce[(K, Set[V])])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]],(K, Set[V]),SubclassifiedIndex.this.Changes])SubclassifiedIndex.this.Changes">flatMap</span> <span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.removeValue(e0a34702a8).$anonfun.x$3" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">_</a> <a href="#akka.util.SubclassifiedIndex;Nonroot.removeValue(0c96b8536c)" title="(value: V)scala.collection.immutable.Seq[(K, Set[V])]">removeValue</a> <a href="#akka.util;SubclassifiedIndex.removeValue(e0a34702a8).value" title="V">value</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Find all values for a given key in the index.
   */</span>
  protected final def <a title="(key: K)Set[V]" id="akka.util;SubclassifiedIndex.findValues">findValues</a><span class="delimiter">(</span><a title="K" id="akka.util;SubclassifiedIndex.findValues.key">key</a>: <a href="#akka.util;SubclassifiedIndex;K" title="K">K</a><span class="delimiter">)</span>: <span title="Set[V]">Set</span><span class="delimiter">[</span>V<span class="delimiter">]</span> = <a href="#akka.util;SubclassifiedIndex.root" title="=&gt; akka.util.SubclassifiedIndex[K,V]">root</a>.<a href="#akka.util;SubclassifiedIndex.innerFindValues" title="(key: K)Set[V]">innerFindValues</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.findValues.key" title="K">key</a><span class="delimiter">)</span>
  protected def <a title="(key: K)Set[V]" id="akka.util;SubclassifiedIndex.innerFindValues">innerFindValues</a><span class="delimiter">(</span><a title="K" id="akka.util;SubclassifiedIndex.innerFindValues.key">key</a>: <a href="#akka.util;SubclassifiedIndex;K" title="K">K</a><span class="delimiter">)</span>: <span title="Set[V]">Set</span><span class="delimiter">[</span>V<span class="delimiter">]</span> =
    <span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Set.type">Set</span>.<span title="[A]=&gt; scala.collection.immutable.Set[A]">empty</span><span title="scala.collection.immutable.Set[V]" class="delimiter">[</span><a href="#akka.util;SubclassifiedIndex;V" title="V">V</a><span class="delimiter">]</span> <a href="#akka.util;SubclassifiedIndex.innerFindValues.x$4" title="(z: scala.collection.immutable.Set[V])(op: (scala.collection.immutable.Set[V], akka.util.SubclassifiedIndex.Nonroot[K,V]) =&gt; scala.collection.immutable.Set[V])scala.collection.immutable.Set[V]">/:</a> <a href="#akka.util;SubclassifiedIndex.subkeys_=" title="=&gt; scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subkeys</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="scala.collection.immutable.Set[V]" id="akka.util;SubclassifiedIndex.innerFindValues.$anonfun.s">s</a>, <a title="akka.util.SubclassifiedIndex.Nonroot[K,V]" id="akka.util;SubclassifiedIndex.innerFindValues.$anonfun.n">n</a><span class="delimiter">)</span> ⇒
      if <span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.sc" title="akka.util.Subclassification[K]">sc</a>.<a href="#akka.util;Subclassification.isSubclass" title="(x: K, y: K)Boolean">isSubclass</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerFindValues.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.innerFindValues.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#akka.util;SubclassifiedIndex.innerFindValues.$anonfun.s" title="scala.collection.immutable.Set[V]">s</a> <span title="(elems: scala.collection.GenTraversableOnce[V])scala.collection.immutable.Set[V]">++</span> <a href="#akka.util;SubclassifiedIndex.innerFindValues.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.innerFindValues" title="(key: K)Set[V]">innerFindValues</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerFindValues.key" title="K">key</a><span class="delimiter">)</span>
      else
        <a href="#akka.util;SubclassifiedIndex.innerFindValues.$anonfun.s" title="scala.collection.immutable.Set[V]">s</a>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Find all subkeys of a given key in the index excluding some subkeys.
   */</span>
  protected final def <a title="(key: K, except: Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]])Set[K]" id="akka.util;SubclassifiedIndex.findSubKeysExcept">findSubKeysExcept</a><span class="delimiter">(</span><a title="K" id="akka.util;SubclassifiedIndex.findSubKeysExcept.key">key</a>: <a href="#akka.util;SubclassifiedIndex;K" title="K">K</a>, <a title="Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]" id="akka.util;SubclassifiedIndex.findSubKeysExcept.except">except</a>: <span title="Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">Vector</span><span class="delimiter">[</span>Nonroot<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Set[K]">Set</span><span class="delimiter">[</span>K<span class="delimiter">]</span> = <a href="#akka.util;SubclassifiedIndex.root" title="=&gt; akka.util.SubclassifiedIndex[K,V]">root</a>.<a href="#akka.util;SubclassifiedIndex.innerFindSubKeys" title="(key: K, except: Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]])Set[K]">innerFindSubKeys</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.findSubKeysExcept.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.findSubKeysExcept.except" title="Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">except</a><span class="delimiter">)</span>
  protected def <a title="(key: K, except: Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]])Set[K]" id="akka.util;SubclassifiedIndex.innerFindSubKeys">innerFindSubKeys</a><span class="delimiter">(</span><a title="K" id="akka.util;SubclassifiedIndex.innerFindSubKeys.key">key</a>: <a href="#akka.util;SubclassifiedIndex;K" title="K">K</a>, <a title="Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]" id="akka.util;SubclassifiedIndex.innerFindSubKeys.except">except</a>: <span title="Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">Vector</span><span class="delimiter">[</span>Nonroot<span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Set[K]">Set</span><span class="delimiter">[</span>K<span class="delimiter">]</span> =
    <span class="delimiter">(</span><span title="=&gt; scala.collection.immutable.Set.type">Set</span>.<span title="[A]=&gt; scala.collection.immutable.Set[A]">empty</span><span title="scala.collection.immutable.Set[K]" class="delimiter">[</span><a href="#akka.util;SubclassifiedIndex;K" title="K">K</a><span class="delimiter">]</span> <a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.x$5" title="(z: scala.collection.immutable.Set[K])(op: (scala.collection.immutable.Set[K], akka.util.SubclassifiedIndex.Nonroot[K,V]) =&gt; scala.collection.immutable.Set[K])scala.collection.immutable.Set[K]">/:</a> <a href="#akka.util;SubclassifiedIndex.subkeys_=" title="=&gt; scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subkeys</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="delimiter">(</span><a title="scala.collection.immutable.Set[K]" id="akka.util;SubclassifiedIndex.innerFindSubKeys.$anonfun.s">s</a>, <a title="akka.util.SubclassifiedIndex.Nonroot[K,V]" id="akka.util;SubclassifiedIndex.innerFindSubKeys.$anonfun.n">n</a><span class="delimiter">)</span> ⇒
      if <span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.sc" title="akka.util.Subclassification[K]">sc</a>.<a href="#akka.util;Subclassification.isEqual" title="(x: K, y: K)Boolean">isEqual</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.$anonfun.s" title="scala.collection.immutable.Set[K]">s</a>
      else <a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util;SubclassifiedIndex.innerFindSubKeys" title="(key: K, except: Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]])Set[K]">innerFindSubKeys</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.except" title="Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">except</a><span class="delimiter">)</span> <span title="(elems: scala.collection.GenTraversableOnce[K])scala.collection.immutable.Set[K]">++</span> <span class="delimiter">{</span>
        if <span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.sc" title="akka.util.Subclassification[K]">sc</a>.<a href="#akka.util;Subclassification.isSubclass" title="(x: K, y: K)Boolean">isSubclass</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a>, <a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.key" title="K">key</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.except" title="Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">except</a>.<span title="(p: akka.util.SubclassifiedIndex.Nonroot[K,V] =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a title="akka.util.SubclassifiedIndex.Nonroot[K,V]" id="akka.util;SubclassifiedIndex.innerFindSubKeys.$anonfun.$anonfun.e">e</a> ⇒ <a href="#akka.util;SubclassifiedIndex.sc" title="akka.util.Subclassification[K]">sc</a>.<a href="#akka.util;Subclassification.isEqual" title="(x: K, y: K)Boolean">isEqual</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.key" title="K">key</a>, <a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.$anonfun.$anonfun.e" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">e</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.$anonfun.s" title="scala.collection.immutable.Set[K]">s</a> <span title="(elem: K)scala.collection.immutable.Set[K]">+</span> <a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a>
        else
          <a href="#akka.util;SubclassifiedIndex.innerFindSubKeys.$anonfun.s" title="scala.collection.immutable.Set[K]">s</a>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  override def <a title="()String" id="akka.util;SubclassifiedIndex.toString">toString</a> = <a href="#akka.util;SubclassifiedIndex.subkeys_=" title="=&gt; scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subkeys</a>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;SubclassifiedIndex(&quot;)" class="string">&quot;SubclassifiedIndex(&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.util;SubclassifiedIndex.values" title="=&gt; Set[V]">values</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;,\n&quot;)" class="string">&quot;,\n&quot;</span>, <span title="String(&quot;,\n&quot;)" class="string">&quot;,\n&quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Add new Nonroot below this node and check all existing nodes for subclass relationship.
   * Also needs to find subkeys in other parts of the tree to compensate for multiple inheritance.
   */</span>
  private def <a title="(n: akka.util.SubclassifiedIndex.Nonroot[K,V])SubclassifiedIndex.this.Changes" id="akka.util;SubclassifiedIndex.integrate">integrate</a><span class="delimiter">(</span><a title="akka.util.SubclassifiedIndex.Nonroot[K,V]" id="akka.util;SubclassifiedIndex.integrate.n">n</a>: <a href="#akka.util.SubclassifiedIndex;Nonroot" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">Nonroot</a><span class="delimiter">[</span>K, V<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="SubclassifiedIndex.this.Changes">Changes</span> = <span class="delimiter">{</span>
    val <a href="#akka.util;SubclassifiedIndex.integrate.subsub" title="(_1: scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]], _2: scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]])(scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]], scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]])" class="delimiter">(</a><a href="#akka.util;SubclassifiedIndex.integrate.x$6" title="scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]" id="akka.util;SubclassifiedIndex.integrate.subsub">subsub</a>, <a href="#akka.util;SubclassifiedIndex.integrate.x$6" title="scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]" id="akka.util;SubclassifiedIndex.integrate.sub">sub</a><span class="delimiter">)</span> = <a href="#akka.util;SubclassifiedIndex.subkeys_=" title="=&gt; scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subkeys</a> <span title="(scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]], scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]])">partition</span> <span class="delimiter">(</span><a title="akka.util.SubclassifiedIndex.Nonroot[K,V]" id="akka.util;SubclassifiedIndex.integrate.x$6.$anonfun.k">k</a> ⇒ <a href="#akka.util;SubclassifiedIndex.sc" title="akka.util.Subclassification[K]">sc</a>.<a href="#akka.util;Subclassification.isSubclass" title="(x: K, y: K)Boolean">isSubclass</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.integrate.x$6.$anonfun.k" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">k</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a>, <a href="#akka.util;SubclassifiedIndex.integrate.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#akka.util;SubclassifiedIndex.subkeys_=" title="(x$1: scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]])Unit">subkeys</a> = <a href="#akka.util;SubclassifiedIndex.integrate.sub" title="scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">sub</a> <span title="(elem: akka.util.SubclassifiedIndex.Nonroot[K,V])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]],akka.util.SubclassifiedIndex.Nonroot[K,V],scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]])scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">:+</span> <a href="#akka.util;SubclassifiedIndex.integrate.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>
    <a href="#akka.util;SubclassifiedIndex.integrate.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util;SubclassifiedIndex.subkeys_=" title="(x$1: scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]])Unit">subkeys</a> = if <span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.integrate.subsub" title="scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subsub</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span> <a href="#akka.util;SubclassifiedIndex.integrate.subsub" title="scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subsub</a> else <a href="#akka.util;SubclassifiedIndex.integrate.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util;SubclassifiedIndex.subkeys_=" title="=&gt; scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subkeys</a>
    <a href="#akka.util;SubclassifiedIndex.integrate.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util;SubclassifiedIndex.subkeys_=" title="(x$1: scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]])Unit">subkeys</a> <span title="(that: scala.collection.GenTraversableOnce[akka.util.SubclassifiedIndex.Nonroot[K,V]])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]],akka.util.SubclassifiedIndex.Nonroot[K,V],scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]])scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">++=</span> <a href="#akka.util;SubclassifiedIndex.findSubKeysExcept" title="(key: K, except: Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]])Set[K]">findSubKeysExcept</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.integrate.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a>, <a href="#akka.util;SubclassifiedIndex.integrate.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util;SubclassifiedIndex.subkeys_=" title="=&gt; scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subkeys</a><span class="delimiter">)</span>.<span title="(f: K =&gt; akka.util.SubclassifiedIndex.Nonroot[K,V])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[K],akka.util.SubclassifiedIndex.Nonroot[K,V],scala.collection.immutable.Set[akka.util.SubclassifiedIndex.Nonroot[K,V]]])scala.collection.immutable.Set[akka.util.SubclassifiedIndex.Nonroot[K,V]]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set.Coll,akka.util.SubclassifiedIndex.Nonroot[K,V],scala.collection.immutable.Set[akka.util.SubclassifiedIndex.Nonroot[K,V]]]" class="delimiter">(</span><a title="K" id="akka.util;SubclassifiedIndex.integrate.$anonfun.k">k</a> ⇒ new <a href="#akka.util.SubclassifiedIndex;Nonroot" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">Nonroot</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.root" title="=&gt; akka.util.SubclassifiedIndex[K,V]">root</a>, <a href="#akka.util;SubclassifiedIndex.integrate.$anonfun.k" title="K">k</a>, <a href="#akka.util;SubclassifiedIndex.values" title="=&gt; Set[V]">values</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <a href="#akka.util;SubclassifiedIndex.integrate.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util;SubclassifiedIndex.subkeys_=" title="=&gt; scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]]">subkeys</a>.<span title="(f: akka.util.SubclassifiedIndex.Nonroot[K,V] =&gt; (K, scala.collection.immutable.Set[V]))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector[akka.util.SubclassifiedIndex.Nonroot[K,V]],(K, scala.collection.immutable.Set[V]),SubclassifiedIndex.this.Changes])SubclassifiedIndex.this.Changes">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.Vector.Coll,(K, scala.collection.immutable.Set[V]),scala.collection.immutable.Vector[(K, scala.collection.immutable.Set[V])]]" class="delimiter">(</span><a title="akka.util.SubclassifiedIndex.Nonroot[K,V]" id="akka.util;SubclassifiedIndex.integrate.$anonfun.n">n</a> ⇒ <span title="(_1: K, _2: scala.collection.immutable.Set[V])(K, scala.collection.immutable.Set[V])" class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.integrate.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util.SubclassifiedIndex;Nonroot.key" title="=&gt; K">key</a>, <a href="#akka.util;SubclassifiedIndex.integrate.$anonfun.n" title="akka.util.SubclassifiedIndex.Nonroot[K,V]">n</a>.<a href="#akka.util;SubclassifiedIndex.values" title="=&gt; Set[V]">values</a>.<span title="scala.collection.immutable.Set[V]">toSet</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  private def <a title="(changes: SubclassifiedIndex.this.Changes)SubclassifiedIndex.this.Changes" id="akka.util;SubclassifiedIndex.mergeChangesByKey">mergeChangesByKey</a><span class="delimiter">(</span><a title="SubclassifiedIndex.this.Changes" id="akka.util;SubclassifiedIndex.mergeChangesByKey.changes">changes</a>: <span title="SubclassifiedIndex.this.Changes">Changes</span><span class="delimiter">)</span>: <span title="SubclassifiedIndex.this.Changes">Changes</span> =
    <span class="delimiter">(</span><a href="#akka.util.SubclassifiedIndex.emptyMergeMap" title="[K, V]=&gt; Map[K,Set[V]]">emptyMergeMap</a><span title="Map[K,Set[V]]" class="delimiter">[</span><a href="#akka.util;SubclassifiedIndex;K" title="K">K</a>, <a href="#akka.util;SubclassifiedIndex;V" title="V">V</a><span class="delimiter">]</span> <a href="#akka.util;SubclassifiedIndex.mergeChangesByKey.x$7" title="(z: Map[K,Set[V]])(op: (Map[K,Set[V]], (K, Set[V])) =&gt; Map[K,Set[V]])Map[K,Set[V]]">/:</a> <a href="#akka.util;SubclassifiedIndex.mergeChangesByKey.changes" title="SubclassifiedIndex.this.Changes">changes</a><span class="delimiter">)</span> <a href="#akka.util;SubclassifiedIndex.mergeChangesByKey.$anonfun.x0$2" title="Map[K,Set[V]]" class="delimiter">{</a>
      case <span class="delimiter">(</span><a title="Map[K,Set[V]]" id="akka.util;SubclassifiedIndex.mergeChangesByKey.$anonfun.m">m</a>, <span class="delimiter">(</span><a title="K" id="akka.util;SubclassifiedIndex.mergeChangesByKey.$anonfun.k">k</a>, <a title="Set[V]" id="akka.util;SubclassifiedIndex.mergeChangesByKey.$anonfun.s">s</a><span class="delimiter">)</span><span class="delimiter">)</span> ⇒ <a href="#akka.util;SubclassifiedIndex.mergeChangesByKey.$anonfun.m" title="Map[K,Set[V]]">m</a>.<span title="(key: K, value: Set[V])scala.collection.immutable.Map[K,Set[V]]">updated</span><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.mergeChangesByKey.$anonfun.k" title="K">k</a>, <a href="#akka.util;SubclassifiedIndex.mergeChangesByKey.$anonfun.m" title="(key: K)Set[V]">m</a><span class="delimiter">(</span><a href="#akka.util;SubclassifiedIndex.mergeChangesByKey.$anonfun.k" title="K">k</a><span class="delimiter">)</span> <span title="(elems: scala.collection.GenTraversableOnce[V])scala.collection.immutable.Set[V]">++</span> <a href="#akka.util;SubclassifiedIndex.mergeChangesByKey.$anonfun.s" title="Set[V]">s</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>.<span title="[Col[_]](implicit cbf: scala.collection.generic.CanBuildFrom[Nothing,(K, Set[V]),Col[(K, Set[V])]])Col[(K, Set[V])]">to</span><span title="(implicit cbf: scala.collection.generic.CanBuildFrom[Nothing,(K, Set[V]),scala.collection.immutable.Seq[(K, Set[V])]])scala.collection.immutable.Seq[(K, Set[V])]" class="delimiter">[</span>immutable.<span title="scala.collection.immutable.Seq">Seq</span><span class="delimiter">]</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
