<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>actor/akka/io/Tcp.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Copyright (C) 2009-2014 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>

<span class="keyword">package</span> akka.io

<span class="keyword">import</span> java.net.InetSocketAddress
<span class="keyword">import</span> java.net.Socket
<span class="keyword">import</span> akka.io.<a href="Inet.scala.html#akka.io.Inet" title="akka.io.Inet.type">Inet</a>._
<span class="keyword">import</span> com.typesafe.config.Config
<span class="keyword">import</span> scala.concurrent.duration._
<span class="keyword">import</span> scala.collection.immutable
<span class="keyword">import</span> scala.collection.<span title="scala.collection.JavaConverters.type">JavaConverters</span>._
<span class="keyword">import</span> akka.util.ByteString
<span class="keyword">import</span> akka.util.<a href="../util/Helpers.scala.html#akka.util.Helpers" title="akka.util.Helpers.type">Helpers</a>.Requiring
<span class="keyword">import</span> akka.actor._
<span class="keyword">import</span> java.lang.<span class="delimiter">{</span> Iterable ⇒ JIterable <span class="delimiter">}</span>

<span class="comment">/**
 * TCP Extension for Akka’s IO layer.
 *
 * For a full description of the design and philosophy behind this IO
 * implementation please refer to &lt;a href=&quot;http://doc.akka.io/&quot;&gt;the Akka online documentation&lt;/a&gt;.
 *
 * In order to open an outbound connection send a [[Tcp.Connect]] message
 * to the [[TcpExt#manager]].
 *
 * In order to start listening for inbound connetions send a [[Tcp.Bind]]
 * message to the [[TcpExt#manager]].
 *
 * The Java API for generating TCP commands is available at [[TcpMessage]].
 */</span>
<span class="keyword">object</span> <a title="akka.io.Tcp.type" id="akka.io.Tcp">Tcp</a> <a href="#akka.io.Tcp" title="akka.io.Tcp.type" class="keyword">extends</a> <a href="../actor/Extension.scala.html#akka.actor;ExtensionId" title="akka.actor.ExtensionId[akka.io.TcpExt]">ExtensionId</a><span class="delimiter">[</span>TcpExt<span class="delimiter">]</span> <span class="keyword">with</span> <a href="../actor/Extension.scala.html#akka.actor;ExtensionIdProvider" title="akka.actor.ExtensionIdProvider">ExtensionIdProvider</a> <span class="delimiter">{</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()akka.io.Tcp.type" id="akka.io.Tcp.lookup">lookup</a> = <a href="#akka.io.Tcp" title="akka.io.Tcp.type">Tcp</a>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="(system: akka.actor.ExtendedActorSystem)akka.io.TcpExt" id="akka.io.Tcp.createExtension">createExtension</a><span class="delimiter">(</span><a title="akka.actor.ExtendedActorSystem" id="akka.io.Tcp.createExtension.system">system</a>: <a href="../actor/ActorSystem.scala.html#akka.actor;ExtendedActorSystem" title="akka.actor.ExtendedActorSystem">ExtendedActorSystem</a><span class="delimiter">)</span>: <a href="#akka.io;TcpExt" title="akka.io.TcpExt">TcpExt</a> = <span title="akka.io.TcpExt" class="keyword">new</span> <a href="#akka.io;TcpExt" title="akka.io.TcpExt">TcpExt</a><span class="delimiter">(</span><a href="#akka.io.Tcp.createExtension.system" title="akka.actor.ExtendedActorSystem">system</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Java API: retrieve the Tcp extension for the given system.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="(system: akka.actor.ActorSystem)akka.io.TcpExt" id="akka.io.Tcp.get">get</a><span class="delimiter">(</span><a title="akka.actor.ActorSystem" id="akka.io.Tcp.get.system">system</a>: <a href="../actor/ActorSystem.scala.html#akka.actor;ActorSystem" title="akka.actor.ActorSystem">ActorSystem</a><span class="delimiter">)</span>: <a href="#akka.io;TcpExt" title="akka.io.TcpExt">TcpExt</a> = <span class="keyword">super</span>.<a href="../actor/Extension.scala.html#akka.actor;ExtensionId.get" title="(system: akka.actor.ActorSystem)akka.io.TcpExt">get</a><span class="delimiter">(</span><a href="#akka.io.Tcp.get.system" title="akka.actor.ActorSystem">system</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Scala API: this object contains all applicable socket options for TCP.
   *
   * For the Java API see [[TcpSO]].
   */</span>
  <span class="keyword">object</span> <a title="akka.io.Tcp.SO.type" id="akka.io.Tcp.SO">SO</a> <a href="#akka.io.Tcp.SO" title="akka.io.Tcp.SO.type" class="keyword">extends</a> Inet.<a href="Inet.scala.html#akka.io.Inet;SoForwarders" title="akka.io.Inet.SoForwarders">SoForwarders</a> <span class="delimiter">{</span>

    <span class="comment">// general socket options</span>

    <span class="comment">/**
     * [[akka.io.Inet.SocketOption]] to enable or disable SO_KEEPALIVE
     *
     * For more information see [[java.net.Socket.setKeepAlive]]
     */</span>
    <span class="keyword">case class</span> <a title="class KeepAlive extends AnyRef with akka.io.Inet.SocketOption with Product with Serializable" id="akka.io.Tcp.SO.KeepAlive.readResolve">KeepAlive</a><a href="#akka.io.Tcp.SO.KeepAlive.readResolve" title="Product" class="delimiter">(</a><a title="Boolean" id="akka.io.Tcp.SO;KeepAlive.on">on</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="Inet.scala.html#akka.io.Inet;SocketOption" title="akka.io.Inet.SocketOption">SocketOption</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="(s: java.net.Socket)Unit" id="akka.io.Tcp.SO;KeepAlive.afterConnect">afterConnect</a><span class="delimiter">(</span><a title="java.net.Socket" id="akka.io.Tcp.SO;KeepAlive.afterConnect.s">s</a>: <span title="java.net.Socket">Socket</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.io.Tcp.SO;KeepAlive.afterConnect.s" title="java.net.Socket">s</a>.<span title="(x$1: Boolean)Unit">setKeepAlive</span><span class="delimiter">(</span><a href="#akka.io.Tcp.SO;KeepAlive.on" title="=&gt; Boolean">on</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * [[akka.io.Inet.SocketOption]] to enable or disable OOBINLINE (receipt
     * of TCP urgent data) By default, this option is disabled and TCP urgent
     * data is silently discarded.
     *
     * For more information see [[java.net.Socket.setOOBInline]]
     */</span>
    <span class="keyword">case class</span> <a title="class OOBInline extends AnyRef with akka.io.Inet.SocketOption with Product with Serializable" id="akka.io.Tcp.SO.OOBInline.readResolve">OOBInline</a><a href="#akka.io.Tcp.SO.OOBInline.readResolve" title="Product" class="delimiter">(</a><a title="Boolean" id="akka.io.Tcp.SO;OOBInline.on">on</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="Inet.scala.html#akka.io.Inet;SocketOption" title="akka.io.Inet.SocketOption">SocketOption</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="(s: java.net.Socket)Unit" id="akka.io.Tcp.SO;OOBInline.afterConnect">afterConnect</a><span class="delimiter">(</span><a title="java.net.Socket" id="akka.io.Tcp.SO;OOBInline.afterConnect.s">s</a>: <span title="java.net.Socket">Socket</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.io.Tcp.SO;OOBInline.afterConnect.s" title="java.net.Socket">s</a>.<span title="(x$1: Boolean)Unit">setOOBInline</span><span class="delimiter">(</span><a href="#akka.io.Tcp.SO;OOBInline.on" title="=&gt; Boolean">on</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">// SO_LINGER is handled by the Close code</span>

    <span class="comment">/**
     * [[akka.io.Inet.SocketOption]] to enable or disable TCP_NODELAY
     * (disable or enable Nagle's algorithm)
     *
     * Please note, that TCP_NODELAY is enabled by default.
     *
     * For more information see [[java.net.Socket.setTcpNoDelay]]
     */</span>
    <span class="keyword">case class</span> <a title="class TcpNoDelay extends AnyRef with akka.io.Inet.SocketOption with Product with Serializable" id="akka.io.Tcp.SO.TcpNoDelay.readResolve">TcpNoDelay</a><a href="#akka.io.Tcp.SO.TcpNoDelay.readResolve" title="Product" class="delimiter">(</a><a title="Boolean" id="akka.io.Tcp.SO;TcpNoDelay.on">on</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="Inet.scala.html#akka.io.Inet;SocketOption" title="akka.io.Inet.SocketOption">SocketOption</a> <span class="delimiter">{</span>
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="(s: java.net.Socket)Unit" id="akka.io.Tcp.SO;TcpNoDelay.afterConnect">afterConnect</a><span class="delimiter">(</span><a title="java.net.Socket" id="akka.io.Tcp.SO;TcpNoDelay.afterConnect.s">s</a>: <span title="java.net.Socket">Socket</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.io.Tcp.SO;TcpNoDelay.afterConnect.s" title="java.net.Socket">s</a>.<span title="(x$1: Boolean)Unit">setTcpNoDelay</span><span class="delimiter">(</span><a href="#akka.io.Tcp.SO;TcpNoDelay.on" title="=&gt; Boolean">on</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

  <span class="delimiter">}</span>

  <span class="comment">/**
   * The common interface for [[Command]] and [[Event]].
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Message extends AnyRef with akka.actor.NoSerializationVerificationNeeded" id="akka.io.Tcp;Message">Message</a> <span class="keyword">extends</span> <a href="../actor/Actor.scala.html#akka.actor;NoSerializationVerificationNeeded" title="akka.actor.NoSerializationVerificationNeeded">NoSerializationVerificationNeeded</a>

  <span class="comment">/// COMMANDS</span>

  <span class="comment">/**
   * This is the common trait for all commands understood by TCP actors.
   */</span>
  <span class="keyword">trait</span> <a title="trait Command extends AnyRef with akka.io.Tcp.Message with akka.io.SelectionHandler.HasFailureMessage" id="akka.io.Tcp;Command">Command</a> <span title="Unit" class="keyword">extends</span> <a href="#akka.io.Tcp;Message" title="akka.io.Tcp.Message">Message</a> <span class="keyword">with</span> SelectionHandler.<a href="SelectionHandler.scala.html#akka.io.SelectionHandler;HasFailureMessage" title="akka.io.SelectionHandler.HasFailureMessage">HasFailureMessage</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="=&gt; akka.io.Tcp.CommandFailed" id="akka.io.Tcp;Command.failureMessage">failureMessage</a> = <a href="#akka.io.Tcp.CommandFailed.readResolve" title="(cmd: akka.io.Tcp.Command)akka.io.Tcp.CommandFailed">CommandFailed</a><span class="delimiter">(</span><a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command" class="keyword">this</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * The Connect message is sent to the TCP manager actor, which is obtained via
   * [[TcpExt#manager]]. Either the manager replies with a [[CommandFailed]]
   * or the actor handling the new connection replies with a [[Connected]]
   * message.
   *
   * @param remoteAddress is the address to connect to
   * @param localAddress optionally specifies a specific address to bind to
   * @param options Please refer to the [[SO]] object for a list of all supported options.
   */</span>
  <span class="keyword">case class</span> <a title="class Connect extends AnyRef with akka.io.Tcp.Command with Product with Serializable" id="akka.io.Tcp.Connect.readResolve">Connect</a><a href="#akka.io.Tcp.Connect.readResolve" title="Product" class="delimiter">(</a><a title="java.net.InetSocketAddress" id="akka.io.Tcp;Connect.remoteAddress">remoteAddress</a>: <span title="java.net.InetSocketAddress">InetSocketAddress</span>,
                     <a title="Option[java.net.InetSocketAddress]" id="akka.io.Tcp.Connect.apply$default$2">localAddress</a>: <span title="Option[java.net.InetSocketAddress]">Option</span><span class="delimiter">[</span>InetSocketAddress<span class="delimiter">]</span> = <span title="None.type">None</span>,
                     <a title="scala.collection.immutable.Traversable[akka.io.Inet.SocketOption]" id="akka.io.Tcp.Connect.apply$default$3">options</a>: immutable.<span title="scala.collection.immutable.Traversable[akka.io.Inet.SocketOption]">Traversable</span><span class="delimiter">[</span>SocketOption<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>,
                     <a title="Option[scala.concurrent.duration.FiniteDuration]" id="akka.io.Tcp.Connect.apply$default$4">timeout</a>: <span title="Option[scala.concurrent.duration.FiniteDuration]">Option</span><span class="delimiter">[</span>FiniteDuration<span class="delimiter">]</span> = <span title="None.type">None</span>,
                     <a title="Boolean" id="akka.io.Tcp.Connect.apply$default$5">pullMode</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a>

  <span class="comment">/**
   * The Bind message is send to the TCP manager actor, which is obtained via
   * [[TcpExt#manager]] in order to bind to a listening socket. The manager
   * replies either with a [[CommandFailed]] or the actor handling the listen
   * socket replies with a [[Bound]] message. If the local port is set to 0 in
   * the Bind message, then the [[Bound]] message should be inspected to find
   * the actual port which was bound to.
   *
   * @param handler The actor which will receive all incoming connection requests
   *                in the form of [[Connected]] messages.
   *
   * @param localAddress The socket address to bind to; use port zero for
   *                automatic assignment (i.e. an ephemeral port, see [[Bound]])
   *
   * @param backlog This specifies the number of unaccepted connections the O/S
   *                kernel will hold for this port before refusing connections.
   *
   * @param options Please refer to the [[SO]] object for a list of all supported options.
   */</span>
  <span class="keyword">case class</span> <a title="class Bind extends AnyRef with akka.io.Tcp.Command with Product with Serializable" id="akka.io.Tcp.Bind.readResolve">Bind</a><a href="#akka.io.Tcp.Bind.readResolve" title="Product" class="delimiter">(</a><a title="akka.actor.ActorRef" id="akka.io.Tcp;Bind.handler">handler</a>: <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a>,
                  <a title="java.net.InetSocketAddress" id="akka.io.Tcp;Bind.localAddress">localAddress</a>: <span title="java.net.InetSocketAddress">InetSocketAddress</span>,
                  <a title="Int" id="akka.io.Tcp.Bind.apply$default$3">backlog</a>: <span title="Int">Int</span> = <span title="Int(100)" class="int">100</span>,
                  <a title="scala.collection.immutable.Traversable[akka.io.Inet.SocketOption]" id="akka.io.Tcp.Bind.apply$default$4">options</a>: immutable.<span title="scala.collection.immutable.Traversable[akka.io.Inet.SocketOption]">Traversable</span><span class="delimiter">[</span>SocketOption<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>,
                  <a title="Boolean" id="akka.io.Tcp.Bind.apply$default$5">pullMode</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a>

  <span class="comment">/**
   * This message must be sent to a TCP connection actor after receiving the
   * [[Connected]] message. The connection will not read any data from the
   * socket until this message is received, because this message defines the
   * actor which will receive all inbound data.
   *
   * @param handler The actor which will receive all incoming data and which
   *                will be informed when the connection is closed.
   *
   * @param keepOpenOnPeerClosed If this is set to true then the connection
   *                is not automatically closed when the peer closes its half,
   *                requiring an explicit [[Closed]] from our side when finished.
   *
   * @param useResumeWriting If this is set to true then the connection actor
   *                will refuse all further writes after issuing a [[CommandFailed]]
   *                notification until [[ResumeWriting]] is received. This can
   *                be used to implement NACK-based write backpressure.
   */</span>
  <span class="keyword">case class</span> <a title="class Register extends AnyRef with akka.io.Tcp.Command with Product with Serializable" id="akka.io.Tcp.Register.readResolve">Register</a><a href="#akka.io.Tcp.Register.readResolve" title="Product" class="delimiter">(</a><a title="akka.actor.ActorRef" id="akka.io.Tcp;Register.handler">handler</a>: <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a>, <a title="Boolean" id="akka.io.Tcp.Register.apply$default$2">keepOpenOnPeerClosed</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>, <a title="Boolean" id="akka.io.Tcp.Register.apply$default$3">useResumeWriting</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(true)" class="keyword">true</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a>

  <span class="comment">/**
   * In order to close down a listening socket, send this message to that socket’s
   * actor (that is the actor which previously had sent the [[Bound]] message). The
   * listener socket actor will reply with a [[Unbound]] message.
   */</span>
  <span class="keyword">case object</span> <a href="#akka.io.Tcp.Unbind.productElement.x$1" title="akka.io.Tcp.Unbind.type" id="akka.io.Tcp.Unbind.readResolve">Unbind</a> <span title="Product" class="keyword">extends</span> <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a>

  <span class="comment">/**
   * Common interface for all commands which aim to close down an open connection.
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait CloseCommand extends AnyRef with akka.io.Tcp.Command" id="akka.io.Tcp;CloseCommand">CloseCommand</a> <span class="keyword">extends</span> <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> <span class="delimiter">{</span>
    <span class="comment">/**
     * The corresponding event which is sent as an acknowledgment once the
     * close operation is finished.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; akka.io.Tcp.ConnectionClosed" id="akka.io.Tcp;CloseCommand.event">event</a>: <a href="#akka.io.Tcp;ConnectionClosed" title="akka.io.Tcp.ConnectionClosed">ConnectionClosed</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A normal close operation will first flush pending writes and then close the
   * socket. The sender of this command and the registered handler for incoming
   * data will both be notified once the socket is closed using a [[Closed]]
   * message.
   */</span>
  <span class="keyword">case object</span> <a href="#akka.io.Tcp.Close.productElement.x$1" title="akka.io.Tcp.Close.type" id="akka.io.Tcp.Close.readResolve">Close</a> <span title="Product" class="keyword">extends</span> <a href="#akka.io.Tcp;CloseCommand" title="akka.io.Tcp.CloseCommand">CloseCommand</a> <span class="delimiter">{</span>
    <span class="comment">/**
     * The corresponding event which is sent as an acknowledgment once the
     * close operation is finished.
     */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; akka.io.Tcp.Closed.type" id="akka.io.Tcp.Close.event">event</a> = <a href="#akka.io.Tcp.Closed.readResolve" title="akka.io.Tcp.Closed.type">Closed</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A confirmed close operation will flush pending writes and half-close the
   * connection, waiting for the peer to close the other half. The sender of this
   * command and the registered handler for incoming data will both be notified
   * once the socket is closed using a [[ConfirmedClosed]] message.
   */</span>
  <span class="keyword">case object</span> <a href="#akka.io.Tcp.ConfirmedClose.productElement.x$1" title="akka.io.Tcp.ConfirmedClose.type" id="akka.io.Tcp.ConfirmedClose.readResolve">ConfirmedClose</a> <span title="Product" class="keyword">extends</span> <a href="#akka.io.Tcp;CloseCommand" title="akka.io.Tcp.CloseCommand">CloseCommand</a> <span class="delimiter">{</span>
    <span class="comment">/**
     * The corresponding event which is sent as an acknowledgment once the
     * close operation is finished.
     */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; akka.io.Tcp.ConfirmedClosed.type" id="akka.io.Tcp.ConfirmedClose.event">event</a> = <a href="#akka.io.Tcp.ConfirmedClosed.readResolve" title="akka.io.Tcp.ConfirmedClosed.type">ConfirmedClosed</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * An abort operation will not flush pending writes and will issue a TCP ABORT
   * command to the O/S kernel which should result in a TCP_RST packet being sent
   * to the peer. The sender of this command and the registered handler for
   * incoming data will both be notified once the socket is closed using a
   * [[Aborted]] message.
   */</span>
  <span class="keyword">case object</span> <a href="#akka.io.Tcp.Abort.productElement.x$1" title="akka.io.Tcp.Abort.type" id="akka.io.Tcp.Abort.readResolve">Abort</a> <span title="Product" class="keyword">extends</span> <a href="#akka.io.Tcp;CloseCommand" title="akka.io.Tcp.CloseCommand">CloseCommand</a> <span class="delimiter">{</span>
    <span class="comment">/**
     * The corresponding event which is sent as an acknowledgment once the
     * close operation is finished.
     */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; akka.io.Tcp.Aborted.type" id="akka.io.Tcp.Abort.event">event</a> = <a href="#akka.io.Tcp.Aborted.readResolve" title="akka.io.Tcp.Aborted.type">Aborted</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Each [[WriteCommand]] can optionally request a positive acknowledgment to be sent
   * to the commanding actor. If such notification is not desired the [[WriteCommand#ack]]
   * must be set to an instance of this class. The token contained within can be used
   * to recognize which write failed when receiving a [[CommandFailed]] message.
   */</span>
  <span class="keyword">case class</span> <a title="class NoAck extends AnyRef with akka.io.Tcp.Event with Product with Serializable" id="akka.io.Tcp;NoAck">NoAck</a><a href="#akka.io.Tcp;NoAck" title="Product" class="delimiter">(</a><a title="Any" id="akka.io.Tcp;NoAck.token">token</a>: <span title="Any">Any</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#akka.io.Tcp;Event" title="akka.io.Tcp.Event">Event</a>

  <span class="comment">/**
   * Default [[NoAck]] instance which is used when no acknowledgment information is
   * explicitly provided. Its “token” is `null`.
   */</span>
  <span class="keyword">object</span> <a title="akka.io.Tcp.NoAck.type" id="akka.io.Tcp.NoAck.readResolve">NoAck</a> <a href="#akka.io.Tcp.NoAck.readResolve" title="akka.io.Tcp.NoAck.type" class="keyword">extends</a> <a href="#akka.io.Tcp;NoAck" title="akka.io.Tcp.NoAck">NoAck</a><span class="delimiter">(</span><span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Common interface for all write commands, currently [[Write]], [[WriteFile]] and [[CompoundWrite]].
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class WriteCommand extends AnyRef with akka.io.Tcp.Command" id="akka.io.Tcp;WriteCommand">WriteCommand</a> <a href="#akka.io.Tcp;WriteCommand" title="akka.io.Tcp.WriteCommand" class="keyword">extends</a> <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> <span class="delimiter">{</span>
    <span class="comment">/**
     * Prepends this command with another `Write` or `WriteFile` to form
     * a `CompoundWrite`.
     */</span>
    <span class="keyword">def</span> <a title="(other: akka.io.Tcp.SimpleWriteCommand)akka.io.Tcp.CompoundWrite" id="akka.io.Tcp;WriteCommand.+:">+:</a><span class="delimiter">(</span><a title="akka.io.Tcp.SimpleWriteCommand" id="akka.io.Tcp;WriteCommand.+:.other">other</a>: <a href="#akka.io.Tcp;SimpleWriteCommand" title="akka.io.Tcp.SimpleWriteCommand">SimpleWriteCommand</a><span class="delimiter">)</span>: <a href="#akka.io.Tcp.CompoundWrite.readResolve" title="akka.io.Tcp.CompoundWrite">CompoundWrite</a> = <a href="#akka.io.Tcp.CompoundWrite.readResolve" title="(head: akka.io.Tcp.SimpleWriteCommand, tailCommand: akka.io.Tcp.WriteCommand)akka.io.Tcp.CompoundWrite">CompoundWrite</a><span class="delimiter">(</span><a href="#akka.io.Tcp;WriteCommand.+:.other" title="akka.io.Tcp.SimpleWriteCommand">other</a>, <a href="#akka.io.Tcp;WriteCommand" title="akka.io.Tcp.WriteCommand" class="keyword">this</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Prepends this command with a number of other writes.
     * The first element of the given Iterable becomes the first sub write of a potentially
     * created `CompoundWrite`.
     */</span>
    <span class="keyword">def</span> <a title="(writes: Iterable[akka.io.Tcp.WriteCommand])akka.io.Tcp.WriteCommand" id="akka.io.Tcp;WriteCommand.++:">++:</a><span class="delimiter">(</span><a title="Iterable[akka.io.Tcp.WriteCommand]" id="akka.io.Tcp;WriteCommand.++:.writes">writes</a>: <span title="Iterable[akka.io.Tcp.WriteCommand]">Iterable</span><span class="delimiter">[</span>WriteCommand<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.io.Tcp;WriteCommand" title="akka.io.Tcp.WriteCommand">WriteCommand</a> =
      <a href="#akka.io.Tcp;WriteCommand.++:.writes" title="Iterable[akka.io.Tcp.WriteCommand]">writes</a>.<span title="(z: akka.io.Tcp.WriteCommand)(op: (akka.io.Tcp.WriteCommand, akka.io.Tcp.WriteCommand) =&gt; akka.io.Tcp.WriteCommand)akka.io.Tcp.WriteCommand">foldRight</span><span class="delimiter">(</span><a href="#akka.io.Tcp;WriteCommand" title="akka.io.Tcp.WriteCommand" class="keyword">this</a><span class="delimiter">)</span> <a href="#akka.io.Tcp;WriteCommand.++:.$anonfun.x0$1" title="akka.io.Tcp.WriteCommand" class="delimiter">{</a>
        <span class="keyword">case</span> <span class="delimiter">(</span><span title="akka.io.Tcp.SimpleWriteCommand">a</span>: <a href="#akka.io.Tcp;SimpleWriteCommand" title="akka.io.Tcp.SimpleWriteCommand">SimpleWriteCommand</a>, <span title="akka.io.Tcp.WriteCommand">b</span><span class="delimiter">)</span> ⇒ <span title="akka.io.Tcp.SimpleWriteCommand">a</span> <a href="#akka.io.Tcp;WriteCommand.+:" title="(other: akka.io.Tcp.SimpleWriteCommand)akka.io.Tcp.CompoundWrite">+:</a> <span title="akka.io.Tcp.WriteCommand">b</span>
        <span class="keyword">case</span> <span class="delimiter">(</span><span title="akka.io.Tcp.CompoundWrite">a</span>: <a href="#akka.io.Tcp.CompoundWrite.readResolve" title="akka.io.Tcp.CompoundWrite">CompoundWrite</a>, <span title="akka.io.Tcp.WriteCommand">b</span><span class="delimiter">)</span>      ⇒ <span title="akka.io.Tcp.CompoundWrite">a</span> <a href="#akka.io.Tcp;WriteCommand.++:" title="(writes: Iterable[akka.io.Tcp.WriteCommand])akka.io.Tcp.WriteCommand">++:</a> <span title="akka.io.Tcp.WriteCommand">b</span>
      <span class="delimiter">}</span>

    <span class="comment">/**
     * Java API: prepends this command with another `Write` or `WriteFile` to form
     * a `CompoundWrite`.
     */</span>
    <span class="keyword">def</span> <a title="(that: akka.io.Tcp.SimpleWriteCommand)akka.io.Tcp.CompoundWrite" id="akka.io.Tcp;WriteCommand.prepend(803471290f)">prepend</a><span class="delimiter">(</span><a title="akka.io.Tcp.SimpleWriteCommand" id="akka.io.Tcp;WriteCommand.prepend(803471290f).that">that</a>: <a href="#akka.io.Tcp;SimpleWriteCommand" title="akka.io.Tcp.SimpleWriteCommand">SimpleWriteCommand</a><span class="delimiter">)</span>: <a href="#akka.io.Tcp.CompoundWrite.readResolve" title="akka.io.Tcp.CompoundWrite">CompoundWrite</a> = <a href="#akka.io.Tcp;WriteCommand.prepend(803471290f).that" title="akka.io.Tcp.SimpleWriteCommand">that</a> <a href="#akka.io.Tcp;WriteCommand.+:" title="(other: akka.io.Tcp.SimpleWriteCommand)akka.io.Tcp.CompoundWrite">+:</a> <a href="#akka.io.Tcp;WriteCommand" title="WriteCommand.this.type" class="keyword">this</a>

    <span class="comment">/**
     * Java API: prepends this command with a number of other writes.
     * The first element of the given Iterable becomes the first sub write of a potentially
     * created `CompoundWrite`.
     */</span>
    <span class="keyword">def</span> <a title="(writes: Iterable[akka.io.Tcp.WriteCommand])akka.io.Tcp.WriteCommand" id="akka.io.Tcp;WriteCommand.prepend(2915b0e021)">prepend</a><span class="delimiter">(</span><a title="Iterable[akka.io.Tcp.WriteCommand]" id="akka.io.Tcp;WriteCommand.prepend(2915b0e021).writes">writes</a>: <span title="Iterable[akka.io.Tcp.WriteCommand]">JIterable</span><span class="delimiter">[</span>WriteCommand<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.io.Tcp;WriteCommand" title="akka.io.Tcp.WriteCommand">WriteCommand</a> = <a href="#akka.io.Tcp;WriteCommand.prepend(2915b0e021).writes" title="(i: Iterable[akka.io.Tcp.WriteCommand])scala.collection.convert.Decorators.AsScala[Iterable[akka.io.Tcp.WriteCommand]]">writes</a>.<span title="=&gt; Iterable[akka.io.Tcp.WriteCommand]">asScala</span> <a href="#akka.io.Tcp;WriteCommand.++:" title="(writes: Iterable[akka.io.Tcp.WriteCommand])akka.io.Tcp.WriteCommand">++:</a> <a href="#akka.io.Tcp;WriteCommand" title="WriteCommand.this.type" class="keyword">this</a>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="akka.io.Tcp.WriteCommand.type" id="akka.io.Tcp.WriteCommand">WriteCommand</a> <a href="#akka.io.Tcp.WriteCommand" title="akka.io.Tcp.WriteCommand.type" class="delimiter">{</a>
    <span class="comment">/**
     * Combines the given number of write commands into one atomic `WriteCommand`.
     */</span>
    <span class="keyword">def</span> <a title="(writes: Iterable[akka.io.Tcp.WriteCommand])akka.io.Tcp.WriteCommand" id="akka.io.Tcp.WriteCommand.apply">apply</a><span class="delimiter">(</span><a title="Iterable[akka.io.Tcp.WriteCommand]" id="akka.io.Tcp.WriteCommand.apply.writes">writes</a>: <span title="Iterable[akka.io.Tcp.WriteCommand]">Iterable</span><span class="delimiter">[</span>WriteCommand<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.io.Tcp;WriteCommand" title="akka.io.Tcp.WriteCommand">WriteCommand</a> = <a href="#akka.io.Tcp.WriteCommand.apply.writes" title="Iterable[akka.io.Tcp.WriteCommand]">writes</a> <a href="#akka.io.Tcp;WriteCommand.++:" title="(writes: Iterable[akka.io.Tcp.WriteCommand])akka.io.Tcp.WriteCommand">++:</a> <a href="#akka.io.Tcp.Write.readResolve" title="akka.io.Tcp.Write.type">Write</a>.<a href="#akka.io.Tcp.Write.empty" title="=&gt; akka.io.Tcp.Write">empty</a>

    <span class="comment">/**
     * Java API: combines the given number of write commands into one atomic `WriteCommand`.
     */</span>
    <span class="keyword">def</span> <a title="(writes: Iterable[akka.io.Tcp.WriteCommand])akka.io.Tcp.WriteCommand" id="akka.io.Tcp.WriteCommand.create">create</a><span class="delimiter">(</span><a title="Iterable[akka.io.Tcp.WriteCommand]" id="akka.io.Tcp.WriteCommand.create.writes">writes</a>: <span title="Iterable[akka.io.Tcp.WriteCommand]">JIterable</span><span class="delimiter">[</span>WriteCommand<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#akka.io.Tcp;WriteCommand" title="akka.io.Tcp.WriteCommand">WriteCommand</a> = <a href="#akka.io.Tcp.WriteCommand.apply" title="(writes: Iterable[akka.io.Tcp.WriteCommand])akka.io.Tcp.WriteCommand">apply</a><span class="delimiter">(</span><a href="#akka.io.Tcp.WriteCommand.create.writes" title="(i: Iterable[akka.io.Tcp.WriteCommand])scala.collection.convert.Decorators.AsScala[Iterable[akka.io.Tcp.WriteCommand]]">writes</a>.<span title="=&gt; Iterable[akka.io.Tcp.WriteCommand]">asScala</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Common supertype of [[Write]] and [[WriteFile]].
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class SimpleWriteCommand extends akka.io.Tcp.WriteCommand" id="akka.io.Tcp;SimpleWriteCommand">SimpleWriteCommand</a> <a href="#akka.io.Tcp;SimpleWriteCommand" title="akka.io.Tcp.SimpleWriteCommand" class="keyword">extends</a> <a href="#akka.io.Tcp;WriteCommand" title="akka.io.Tcp.WriteCommand">WriteCommand</a> <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#akka.io.Tcp;SimpleWriteCommand.ack" title="=&gt; akka.io.Tcp.Event">ack</a> <span title="(x$1: AnyRef)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span>, <span title="String(&quot;ack must be non-null. Use NoAck if you don\'t want acks.&quot;)" class="string">&quot;ack must be non-null. Use NoAck if you don't want acks.&quot;</span><span class="delimiter">)</span>

    <span class="comment">/**
     * The acknowledgment token associated with this write command.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; akka.io.Tcp.Event" id="akka.io.Tcp;SimpleWriteCommand.ack">ack</a>: <a href="#akka.io.Tcp;Event" title="akka.io.Tcp.Event">Event</a>

    <span class="comment">/**
     * An acknowledgment is only sent if this write command “wants an ack”, which is
     * equivalent to the [[#ack]] token not being a of type [[NoAck]].
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.io.Tcp;SimpleWriteCommand.wantsAck">wantsAck</a>: <span title="Boolean">Boolean</span> = <span title="=&gt; Boolean">!</span><a href="#akka.io.Tcp;SimpleWriteCommand.ack" title="=&gt; akka.io.Tcp.Event">ack</a>.<span title="[T0]=&gt; Boolean">isInstanceOf</span><span title="Boolean" class="delimiter">[</span><a href="#akka.io.Tcp;NoAck" title="akka.io.Tcp.NoAck">NoAck</a><span class="delimiter">]</span>

    <span class="comment">/**
     * Java API: appends this command with another `WriteCommand` to form a `CompoundWrite`.
     */</span>
    <span class="keyword">def</span> <a title="(that: akka.io.Tcp.WriteCommand)akka.io.Tcp.CompoundWrite" id="akka.io.Tcp;SimpleWriteCommand.append">append</a><span class="delimiter">(</span><a title="akka.io.Tcp.WriteCommand" id="akka.io.Tcp;SimpleWriteCommand.append.that">that</a>: <a href="#akka.io.Tcp;WriteCommand" title="akka.io.Tcp.WriteCommand">WriteCommand</a><span class="delimiter">)</span>: <a href="#akka.io.Tcp.CompoundWrite.readResolve" title="akka.io.Tcp.CompoundWrite">CompoundWrite</a> = <a href="#akka.io.Tcp;SimpleWriteCommand" title="akka.io.Tcp.SimpleWriteCommand" class="keyword">this</a> <a href="#akka.io.Tcp;WriteCommand.+:" title="(other: akka.io.Tcp.SimpleWriteCommand)akka.io.Tcp.CompoundWrite">+:</a> <a href="#akka.io.Tcp;SimpleWriteCommand.append.that" title="akka.io.Tcp.WriteCommand">that</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Write data to the TCP connection. If no ack is needed use the special
   * `NoAck` object. The connection actor will reply with a [[CommandFailed]]
   * message if the write could not be enqueued. If [[WriteCommand#wantsAck]]
   * returns true, the connection actor will reply with the supplied [[WriteCommand#ack]]
   * token once the write has been successfully enqueued to the O/S kernel.
   * &lt;b&gt;Note that this does not in any way guarantee that the data will be
   * or have been sent!&lt;/b&gt; Unfortunately there is no way to determine whether
   * a particular write has been sent by the O/S.
   */</span>
  <span class="keyword">case class</span> <a title="class Write extends akka.io.Tcp.SimpleWriteCommand with Product with Serializable" id="akka.io.Tcp;Write">Write</a><a href="#akka.io.Tcp;Write" title="Product" class="delimiter">(</a><a title="akka.util.ByteString" id="akka.io.Tcp;Write.data">data</a>: <a href="../util/ByteString.scala.html#akka.util;ByteString" title="akka.util.ByteString">ByteString</a>, <a title="akka.io.Tcp.Event" id="akka.io.Tcp;Write.ack">ack</a>: <a href="#akka.io.Tcp;Event" title="akka.io.Tcp.Event">Event</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#akka.io.Tcp;SimpleWriteCommand" title="akka.io.Tcp.SimpleWriteCommand">SimpleWriteCommand</a>
  <span class="keyword">object</span> <a title="akka.io.Tcp.Write.type" id="akka.io.Tcp.Write.readResolve">Write</a> <a href="#akka.io.Tcp.Write.readResolve" title="akka.io.Tcp.Write.type" class="delimiter">{</a>
    <span class="comment">/**
     * The empty Write doesn't write anything and isn't acknowledged.
     * It will, however, be denied and sent back with `CommandFailed` if the
     * connection isn't currently ready to send any data (because another WriteCommand
     * is still pending).
     */</span>
    <span class="keyword">val</span> <a title="akka.io.Tcp.Write" id="akka.io.Tcp.Write.empty">empty</a>: <a href="#akka.io.Tcp;Write" title="akka.io.Tcp.Write">Write</a> = <a href="#akka.io.Tcp;Write" title="(data: akka.util.ByteString, ack: akka.io.Tcp.Event)akka.io.Tcp.Write">Write</a><span class="delimiter">(</span><a href="../util/ByteString.scala.html#akka.util.ByteString" title="akka.util.ByteString.type">ByteString</a>.<a href="../util/ByteString.scala.html#akka.util.ByteString.empty" title="=&gt; akka.util.ByteString">empty</a>, <a href="#akka.io.Tcp.NoAck.readResolve" title="akka.io.Tcp.NoAck.type">NoAck</a><span class="delimiter">)</span>

    <span class="comment">/**
     * Create a new unacknowledged Write command with the given data.
     */</span>
    <span class="keyword">def</span> <a title="(data: akka.util.ByteString)akka.io.Tcp.Write" id="akka.io.Tcp.Write.apply(428038e449)">apply</a><span class="delimiter">(</span><a title="akka.util.ByteString" id="akka.io.Tcp.Write.apply(428038e449).data">data</a>: <a href="../util/ByteString.scala.html#akka.util;ByteString" title="akka.util.ByteString">ByteString</a><span class="delimiter">)</span>: <a href="#akka.io.Tcp;Write" title="akka.io.Tcp.Write">Write</a> =
      <span title="akka.io.Tcp.Write" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.io.Tcp.Write.apply(428038e449).data" title="akka.util.ByteString">data</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#akka.io.Tcp.Write.empty" title="=&gt; akka.io.Tcp.Write">empty</a> <span class="keyword">else</span> <a href="#akka.io.Tcp;Write" title="(data: akka.util.ByteString, ack: akka.io.Tcp.Event)akka.io.Tcp.Write">Write</a><span class="delimiter">(</span><a href="#akka.io.Tcp.Write.apply(428038e449).data" title="akka.util.ByteString">data</a>, <a href="#akka.io.Tcp.NoAck.readResolve" title="akka.io.Tcp.NoAck.type">NoAck</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Write `count` bytes starting at `position` from file at `filePath` to the connection.
   * The count must be &gt; 0. The connection actor will reply with a [[CommandFailed]]
   * message if the write could not be enqueued. If [[WriteCommand#wantsAck]]
   * returns true, the connection actor will reply with the supplied [[WriteCommand#ack]]
   * token once the write has been successfully enqueued to the O/S kernel.
   * &lt;b&gt;Note that this does not in any way guarantee that the data will be
   * or have been sent!&lt;/b&gt; Unfortunately there is no way to determine whether
   * a particular write has been sent by the O/S.
   */</span>
  <span class="keyword">case class</span> <a title="class WriteFile extends akka.io.Tcp.SimpleWriteCommand with Product with Serializable" id="akka.io.Tcp.WriteFile.readResolve">WriteFile</a><a href="#akka.io.Tcp.WriteFile.readResolve" title="Product" class="delimiter">(</a><a title="String" id="akka.io.Tcp;WriteFile.filePath">filePath</a>: <span title="String">String</span>, <a title="Long" id="akka.io.Tcp;WriteFile.position">position</a>: <span title="Long">Long</span>, <a title="Long" id="akka.io.Tcp;WriteFile.count">count</a>: <span title="Long">Long</span>, <a title="akka.io.Tcp.Event" id="akka.io.Tcp;WriteFile.ack">ack</a>: <a href="#akka.io.Tcp;Event" title="akka.io.Tcp.Event">Event</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#akka.io.Tcp;SimpleWriteCommand" title="akka.io.Tcp.SimpleWriteCommand">SimpleWriteCommand</a> <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#akka.io.Tcp;WriteFile.position" title="=&gt; Long">position</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span>, <span title="String(&quot;WriteFile.position must be &gt;= 0&quot;)" class="string">&quot;WriteFile.position must be &gt;= 0&quot;</span><span class="delimiter">)</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#akka.io.Tcp;WriteFile.count" title="=&gt; Long">count</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span>, <span title="String(&quot;WriteFile.count must be &gt; 0&quot;)" class="string">&quot;WriteFile.count must be &gt; 0&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * A write command which aggregates two other write commands. Using this construct
   * you can chain a number of [[Write]] and/or [[WriteFile]] commands together in a way
   * that allows them to be handled as a single write which gets written out to the
   * network as quickly as possible.
   * If the sub commands contain `ack` requests they will be honored as soon as the
   * respective write has been written completely.
   */</span>
  <span class="keyword">case class</span> <a title="class CompoundWrite extends akka.io.Tcp.WriteCommand with scala.collection.immutable.Iterable[akka.io.Tcp.SimpleWriteCommand] with Product with Serializable" id="akka.io.Tcp.CompoundWrite.readResolve">CompoundWrite</a><a href="#akka.io.Tcp.CompoundWrite.readResolve" title="Product" class="delimiter">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a title="akka.io.Tcp.SimpleWriteCommand" id="akka.io.Tcp;CompoundWrite.head">head</a>: <a href="#akka.io.Tcp;SimpleWriteCommand" title="akka.io.Tcp.SimpleWriteCommand">SimpleWriteCommand</a>, <a title="akka.io.Tcp.WriteCommand" id="akka.io.Tcp;CompoundWrite.tailCommand">tailCommand</a>: <a href="#akka.io.Tcp;WriteCommand" title="akka.io.Tcp.WriteCommand">WriteCommand</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#akka.io.Tcp;WriteCommand" title="akka.io.Tcp.WriteCommand">WriteCommand</a>
    <span class="keyword">with</span> immutable.<span title="scala.collection.immutable.Iterable[akka.io.Tcp.SimpleWriteCommand]">Iterable</span><span class="delimiter">[</span>SimpleWriteCommand<span class="delimiter">]</span> <span class="delimiter">{</span>

    <span class="keyword">def</span> <a title="=&gt; Iterator[akka.io.Tcp.SimpleWriteCommand]" id="akka.io.Tcp;CompoundWrite.iterator">iterator</a>: <span title="Iterator[akka.io.Tcp.SimpleWriteCommand]">Iterator</span><span class="delimiter">[</span>SimpleWriteCommand<span class="delimiter">]</span> =
      <a href="#akka.io.Tcp;CompoundWrite.iterator;$anon" title="Iterator[akka.io.Tcp.SimpleWriteCommand]{}" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Iterator[akka.io.Tcp.SimpleWriteCommand]" id="akka.io.Tcp;CompoundWrite.iterator;$anon">Iterator</a><span class="delimiter">[</span>SimpleWriteCommand<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">var</span> <a title="akka.io.Tcp.WriteCommand" id="akka.io.Tcp;CompoundWrite.iterator;$anon.current">current</a>: <a href="#akka.io.Tcp;WriteCommand" title="akka.io.Tcp.WriteCommand">WriteCommand</a> = <a href="#akka.io.Tcp.CompoundWrite.readResolve" title="akka.io.Tcp.CompoundWrite">CompoundWrite</a>.<span class="keyword">this</span>
        <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.io.Tcp;CompoundWrite.iterator;$anon.hasNext">hasNext</a>: <span title="Boolean">Boolean</span> = <a href="#akka.io.Tcp;CompoundWrite.iterator;$anon.current" title="akka.io.Tcp.WriteCommand">current</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span>
        <span class="keyword">def</span> <a title="()akka.io.Tcp.SimpleWriteCommand" id="akka.io.Tcp;CompoundWrite.iterator;$anon.next">next</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.io.Tcp;SimpleWriteCommand" title="akka.io.Tcp.SimpleWriteCommand">SimpleWriteCommand</a> =
          <a href="#akka.io.Tcp;CompoundWrite.iterator;$anon.current" title="akka.io.Tcp.WriteCommand">current</a> <span title="akka.io.Tcp.SimpleWriteCommand" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <span title="Null(null)" class="keyword">null</span>                  ⇒ <span title="=&gt; collection.Iterator.type">Iterator</span>.<span title="=&gt; Iterator[Nothing]">empty</span>.<span title="()Nothing">next</span><span class="delimiter">(</span><span class="delimiter">)</span>
            <span class="keyword">case</span> CompoundWrite<span class="delimiter">(</span><a title="akka.io.Tcp.SimpleWriteCommand" id="akka.io.Tcp;CompoundWrite.iterator;$anon.next.h">h</a>, <a title="akka.io.Tcp.WriteCommand" id="akka.io.Tcp;CompoundWrite.iterator;$anon.next.t">t</a><span class="delimiter">)</span>   ⇒ <span class="delimiter">{</span> <a href="#akka.io.Tcp;CompoundWrite.iterator;$anon.current" title="akka.io.Tcp.WriteCommand">current</a> = <a href="#akka.io.Tcp;CompoundWrite.iterator;$anon.next.t" title="akka.io.Tcp.WriteCommand">t</a>; <a href="#akka.io.Tcp;CompoundWrite.iterator;$anon.next.h" title="akka.io.Tcp.SimpleWriteCommand">h</a> <span class="delimiter">}</span>
            <span class="keyword">case</span> <a title="akka.io.Tcp.SimpleWriteCommand" id="akka.io.Tcp;CompoundWrite.iterator;$anon.next.x">x</a>: <a href="#akka.io.Tcp;SimpleWriteCommand" title="akka.io.Tcp.SimpleWriteCommand">SimpleWriteCommand</a> ⇒ <span class="delimiter">{</span> <a href="#akka.io.Tcp;CompoundWrite.iterator;$anon.current" title="akka.io.Tcp.WriteCommand">current</a> = <span title="Null(null)" class="keyword">null</span>; <a href="#akka.io.Tcp;CompoundWrite.iterator;$anon.next.x" title="akka.io.Tcp.SimpleWriteCommand">x</a> <span class="delimiter">}</span>
          <span class="delimiter">}</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * When `useResumeWriting` is in effect as was indicated in the [[Register]] message
   * then this command needs to be sent to the connection actor in order to re-enable
   * writing after a [[CommandFailed]] event. All [[WriteCommand]] processed by the
   * connection actor between the first [[CommandFailed]] and subsequent reception of
   * this message will also be rejected with [[CommandFailed]].
   */</span>
  <span class="keyword">case object</span> <a href="#akka.io.Tcp.ResumeWriting.productElement.x$1" title="akka.io.Tcp.ResumeWriting.type" id="akka.io.Tcp.ResumeWriting.readResolve">ResumeWriting</a> <span title="Product" class="keyword">extends</span> <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a>

  <span class="comment">/**
   * Sending this command to the connection actor will disable reading from the TCP
   * socket. TCP flow-control will then propagate backpressure to the sender side
   * as buffers fill up on either end. To re-enable reading send [[ResumeReading]].
   */</span>
  <span class="keyword">case object</span> <a href="#akka.io.Tcp.SuspendReading.productElement.x$1" title="akka.io.Tcp.SuspendReading.type" id="akka.io.Tcp.SuspendReading.readResolve">SuspendReading</a> <span title="Product" class="keyword">extends</span> <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a>

  <span class="comment">/**
   * This command needs to be sent to the connection actor after a [[SuspendReading]]
   * command in order to resume reading from the socket.
   */</span>
  <span class="keyword">case object</span> <a href="#akka.io.Tcp.ResumeReading.productElement.x$1" title="akka.io.Tcp.ResumeReading.type" id="akka.io.Tcp.ResumeReading.readResolve">ResumeReading</a> <span title="Product" class="keyword">extends</span> <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a>

  <span class="comment">/**
   * This message enables the accepting of the next connection if read throttling is enabled
   * for connection actors.
   * @param batchSize The number of connections to accept before waiting for the next resume command
   */</span>
  <span class="keyword">case class</span> <a title="class ResumeAccepting extends AnyRef with akka.io.Tcp.Command with Product with Serializable" id="akka.io.Tcp.ResumeAccepting.readResolve">ResumeAccepting</a><a href="#akka.io.Tcp.ResumeAccepting.readResolve" title="Product" class="delimiter">(</a><a title="Int" id="akka.io.Tcp;ResumeAccepting.batchSize">batchSize</a>: <span title="Int">Int</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a>

  <span class="comment">/// EVENTS</span>
  <span class="comment">/**
   * Common interface for all events generated by the TCP layer actors.
   */</span>
  <span class="keyword">trait</span> <a title="trait Event extends AnyRef with akka.io.Tcp.Message" id="akka.io.Tcp;Event">Event</a> <span class="keyword">extends</span> <a href="#akka.io.Tcp;Message" title="akka.io.Tcp.Message">Message</a>

  <span class="comment">/**
   * Whenever data are read from a socket they will be transferred within this
   * class to the handler actor which was designated in the [[Register]] message.
   */</span>
  <span class="keyword">case class</span> <a title="class Received extends AnyRef with akka.io.Tcp.Event with Product with Serializable" id="akka.io.Tcp.Received.readResolve">Received</a><a href="#akka.io.Tcp.Received.readResolve" title="Product" class="delimiter">(</a><a title="akka.util.ByteString" id="akka.io.Tcp;Received.data">data</a>: <a href="../util/ByteString.scala.html#akka.util;ByteString" title="akka.util.ByteString">ByteString</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#akka.io.Tcp;Event" title="akka.io.Tcp.Event">Event</a>

  <span class="comment">/**
   * The connection actor sends this message either to the sender of a [[Connect]]
   * command (for outbound) or to the handler for incoming connections designated
   * in the [[Bind]] message. The connection is characterized by the `remoteAddress`
   * and `localAddress` TCP endpoints.
   */</span>
  <span class="keyword">case class</span> <a title="class Connected extends AnyRef with akka.io.Tcp.Event with Product with Serializable" id="akka.io.Tcp.Connected.readResolve">Connected</a><a href="#akka.io.Tcp.Connected.readResolve" title="Product" class="delimiter">(</a><a title="java.net.InetSocketAddress" id="akka.io.Tcp;Connected.remoteAddress">remoteAddress</a>: <span title="java.net.InetSocketAddress">InetSocketAddress</span>, <a title="java.net.InetSocketAddress" id="akka.io.Tcp;Connected.localAddress">localAddress</a>: <span title="java.net.InetSocketAddress">InetSocketAddress</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#akka.io.Tcp;Event" title="akka.io.Tcp.Event">Event</a>

  <span class="comment">/**
   * Whenever a command cannot be completed, the queried actor will reply with
   * this message, wrapping the original command which failed.
   */</span>
  <span class="keyword">case class</span> <a title="class CommandFailed extends AnyRef with akka.io.Tcp.Event with Product with Serializable" id="akka.io.Tcp.CommandFailed.readResolve">CommandFailed</a><a href="#akka.io.Tcp.CommandFailed.readResolve" title="Product" class="delimiter">(</a><a title="akka.io.Tcp.Command" id="akka.io.Tcp;CommandFailed.cmd">cmd</a>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#akka.io.Tcp;Event" title="akka.io.Tcp.Event">Event</a>

  <span class="comment">/**
   * When `useResumeWriting` is in effect as indicated in the [[Register]] message,
   * the [[ResumeWriting]] command will be acknowledged by this message type, upon
   * which it is safe to send at least one write. This means that all writes preceding
   * the first [[CommandFailed]] message have been enqueued to the O/S kernel at this
   * point.
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait WritingResumed extends AnyRef with akka.io.Tcp.Event" id="akka.io.Tcp;WritingResumed">WritingResumed</a> <span class="keyword">extends</span> <a href="#akka.io.Tcp;Event" title="akka.io.Tcp.Event">Event</a>
  <span class="keyword">case object</span> <a href="#akka.io.Tcp.WritingResumed.productElement.x$1" title="akka.io.Tcp.WritingResumed.type" id="akka.io.Tcp.WritingResumed.readResolve">WritingResumed</a> <span title="Product" class="keyword">extends</span> <a href="#akka.io.Tcp;WritingResumed" title="akka.io.Tcp.WritingResumed">WritingResumed</a>

  <span class="comment">/**
   * The sender of a [[Bind]] command will—in case of success—receive confirmation
   * in this form. If the bind address indicated a 0 port number, then the contained
   * `localAddress` can be used to find out which port was automatically assigned.
   */</span>
  <span class="keyword">case class</span> <a title="class Bound extends AnyRef with akka.io.Tcp.Event with Product with Serializable" id="akka.io.Tcp.Bound.readResolve">Bound</a><a href="#akka.io.Tcp.Bound.readResolve" title="Product" class="delimiter">(</a><a title="java.net.InetSocketAddress" id="akka.io.Tcp;Bound.localAddress">localAddress</a>: <span title="java.net.InetSocketAddress">InetSocketAddress</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#akka.io.Tcp;Event" title="akka.io.Tcp.Event">Event</a>

  <span class="comment">/**
   * The sender of an [[Unbind]] command will receive confirmation through this
   * message once the listening socket has been closed.
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Unbound extends AnyRef with akka.io.Tcp.Event" id="akka.io.Tcp;Unbound">Unbound</a> <span class="keyword">extends</span> <a href="#akka.io.Tcp;Event" title="akka.io.Tcp.Event">Event</a>
  <span class="keyword">case object</span> <a href="#akka.io.Tcp.Unbound.productElement.x$1" title="akka.io.Tcp.Unbound.type" id="akka.io.Tcp.Unbound.readResolve">Unbound</a> <span title="Product" class="keyword">extends</span> <a href="#akka.io.Tcp;Unbound" title="akka.io.Tcp.Unbound">Unbound</a>

  <span class="comment">/**
   * This is the common interface for all events which indicate that a connection
   * has been closed or half-closed.
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait ConnectionClosed extends AnyRef with akka.io.Tcp.Event" id="akka.io.Tcp;ConnectionClosed">ConnectionClosed</a> <span title="Unit" class="keyword">extends</span> <a href="#akka.io.Tcp;Event" title="akka.io.Tcp.Event">Event</a> <span class="delimiter">{</span>
    <span class="comment">/**
     * `true` iff the connection has been closed in response to an [[Abort]] command.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.io.Tcp;ConnectionClosed.isAborted">isAborted</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="comment">/**
     * `true` iff the connection has been fully closed in response to a
     * [[ConfirmedClose]] command.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.io.Tcp;ConnectionClosed.isConfirmed">isConfirmed</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="comment">/**
     * `true` iff the connection has been closed by the peer; in case
     * `keepOpenOnPeerClosed` is in effect as per the [[Register]] command,
     * this connection’s reading half is now closed.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.io.Tcp;ConnectionClosed.isPeerClosed">isPeerClosed</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="comment">/**
     * `true` iff the connection has been closed due to an IO error.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.io.Tcp;ConnectionClosed.isErrorClosed">isErrorClosed</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="comment">/**
     * If `isErrorClosed` returns true, then the error condition can be
     * retrieved by this method.
     */</span>
    <span class="keyword">def</span> <a title="=&gt; String" id="akka.io.Tcp;ConnectionClosed.getErrorCause">getErrorCause</a>: <span title="String">String</span> = <span title="Null(null)" class="keyword">null</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * The connection has been closed normally in response to a [[Close]] command.
   */</span>
  <span class="keyword">case object</span> <a href="#akka.io.Tcp.Closed.productElement.x$1" title="akka.io.Tcp.Closed.type" id="akka.io.Tcp.Closed.readResolve">Closed</a> <span title="Product" class="keyword">extends</span> <a href="#akka.io.Tcp;ConnectionClosed" title="akka.io.Tcp.ConnectionClosed">ConnectionClosed</a>
  <span class="comment">/**
   * The connection has been aborted in response to an [[Abort]] command.
   */</span>
  <span class="keyword">case object</span> <a href="#akka.io.Tcp.Aborted.productElement.x$1" title="akka.io.Tcp.Aborted.type" id="akka.io.Tcp.Aborted.readResolve">Aborted</a> <span title="Product" class="keyword">extends</span> <a href="#akka.io.Tcp;ConnectionClosed" title="akka.io.Tcp.ConnectionClosed">ConnectionClosed</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.io.Tcp.Aborted.isAborted">isAborted</a> = <span title="Boolean(true)" class="keyword">true</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * The connection has been half-closed by us and then half-close by the peer
   * in response to a [[ConfirmedClose]] command.
   */</span>
  <span class="keyword">case object</span> <a href="#akka.io.Tcp.ConfirmedClosed.productElement.x$1" title="akka.io.Tcp.ConfirmedClosed.type" id="akka.io.Tcp.ConfirmedClosed.readResolve">ConfirmedClosed</a> <span title="Product" class="keyword">extends</span> <a href="#akka.io.Tcp;ConnectionClosed" title="akka.io.Tcp.ConnectionClosed">ConnectionClosed</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.io.Tcp.ConfirmedClosed.isConfirmed">isConfirmed</a> = <span title="Boolean(true)" class="keyword">true</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * The peer has closed its writing half of the connection.
   */</span>
  <span class="keyword">case object</span> <a href="#akka.io.Tcp.PeerClosed.productElement.x$1" title="akka.io.Tcp.PeerClosed.type" id="akka.io.Tcp.PeerClosed.readResolve">PeerClosed</a> <span title="Product" class="keyword">extends</span> <a href="#akka.io.Tcp;ConnectionClosed" title="akka.io.Tcp.ConnectionClosed">ConnectionClosed</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.io.Tcp.PeerClosed.isPeerClosed">isPeerClosed</a> = <span title="Boolean(true)" class="keyword">true</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * The connection has been closed due to an IO error.
   */</span>
  <span class="keyword">case class</span> <a title="class ErrorClosed extends AnyRef with akka.io.Tcp.ConnectionClosed with Product with Serializable" id="akka.io.Tcp.ErrorClosed.readResolve">ErrorClosed</a><a href="#akka.io.Tcp.ErrorClosed.readResolve" title="Product" class="delimiter">(</a><a title="String" id="akka.io.Tcp;ErrorClosed.cause">cause</a>: <span title="String">String</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#akka.io.Tcp;ConnectionClosed" title="akka.io.Tcp.ConnectionClosed">ConnectionClosed</a> <span class="delimiter">{</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.io.Tcp;ErrorClosed.isErrorClosed">isErrorClosed</a> = <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; String" id="akka.io.Tcp;ErrorClosed.getErrorCause">getErrorCause</a> = <a href="#akka.io.Tcp;ErrorClosed.cause" title="=&gt; String">cause</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="keyword">class</span> <a title="class TcpExt extends AnyRef with akka.io.IO.Extension" id="akka.io;TcpExt">TcpExt</a><a href="#akka.io;TcpExt" title="akka.io.TcpExt" class="delimiter">(</a><a title="akka.actor.ExtendedActorSystem" id="akka.io;TcpExt.system">system</a>: <a href="../actor/ActorSystem.scala.html#akka.actor;ExtendedActorSystem" title="akka.actor.ExtendedActorSystem">ExtendedActorSystem</a><span class="delimiter">)</span> <span class="keyword">extends</span> IO.<a href="IO.scala.html#akka.io.IO;Extension" title="akka.io.IO.Extension">Extension</a> <span class="delimiter">{</span>

  <span class="keyword">val</span> <a title="TcpExt.this.Settings" id="akka.io;TcpExt.Settings">Settings</a> = <span title="TcpExt.this.Settings" class="keyword">new</span> <a href="#akka.io;TcpExt;Settings" title="TcpExt.this.Settings">Settings</a><span class="delimiter">(</span><a href="#akka.io;TcpExt.system" title="akka.actor.ExtendedActorSystem">system</a>.<a href="../actor/ActorSystem.scala.html#akka.actor;ActorSystem.settings" title="=&gt; akka.actor.ActorSystem.Settings">settings</a>.<a href="../actor/ActorSystem.scala.html#akka.actor.ActorSystem;Settings.config" title="=&gt; com.typesafe.config.Config">config</a>.<span title="(x$1: String)com.typesafe.config.Config">getConfig</span><span class="delimiter">(</span><span title="String(&quot;akka.io.tcp&quot;)" class="string">&quot;akka.io.tcp&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="keyword">class</span> <a title="class Settings extends akka.io.SelectionHandlerSettings" id="akka.io;TcpExt;Settings">Settings</a> <a href="#akka.io;TcpExt;Settings" title="TcpExt.this.Settings" class="keyword">private</a><span class="delimiter">[</span>TcpExt<span class="delimiter">]</span> <span class="delimiter">(</span><a title="com.typesafe.config.Config" id="akka.io;TcpExt;Settings._config">_config</a>: <span title="com.typesafe.config.Config">Config</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="SelectionHandler.scala.html#akka.io;SelectionHandlerSettings" title="akka.io.SelectionHandlerSettings">SelectionHandlerSettings</a><span class="delimiter">(</span><a href="#akka.io;TcpExt;Settings._config" title="com.typesafe.config.Config">_config</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">import</span> akka.util.<a href="../util/Helpers.scala.html#akka.util.Helpers" title="akka.util.Helpers.type">Helpers</a>.ConfigOps
    <span class="keyword">import</span> <a href="#akka.io;TcpExt;Settings._config" title="com.typesafe.config.Config">_config</a>._

    <span class="keyword">val</span> <a title="Int" id="akka.io;TcpExt;Settings.NrOfSelectors">NrOfSelectors</a>: <span title="Int">Int</span> = <a href="#akka.io;TcpExt;Settings._config" title="(x$1: String)Int">getInt</a><a href="../util/Helpers.scala.html#akka.util.Helpers.Requiring(1ee601cfa2)" title="(value: Int)akka.util.Helpers.Requiring[Int]" class="delimiter">(</a><span title="String(&quot;nr-of-selectors&quot;)" class="string">&quot;nr-of-selectors&quot;</span><span class="delimiter">)</span> <a href="../util/Helpers.scala.html#akka.util.Helpers;Requiring.requiring(734662848f)" title="(cond: Int =&gt; Boolean, msg: =&gt; Any)Int">requiring</a> <span class="delimiter">(</span><a href="#akka.io;TcpExt;Settings.NrOfSelectors.$anonfun.x$7" title="Int">_</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span>, <span title="String(&quot;nr-of-selectors must be &gt; 0&quot;)" class="string">&quot;nr-of-selectors must be &gt; 0&quot;</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="Int" id="akka.io;TcpExt;Settings.BatchAcceptLimit">BatchAcceptLimit</a>: <span title="Int">Int</span> = <a href="#akka.io;TcpExt;Settings._config" title="(x$1: String)Int">getInt</a><a href="../util/Helpers.scala.html#akka.util.Helpers.Requiring(1ee601cfa2)" title="(value: Int)akka.util.Helpers.Requiring[Int]" class="delimiter">(</a><span title="String(&quot;batch-accept-limit&quot;)" class="string">&quot;batch-accept-limit&quot;</span><span class="delimiter">)</span> <a href="../util/Helpers.scala.html#akka.util.Helpers;Requiring.requiring(734662848f)" title="(cond: Int =&gt; Boolean, msg: =&gt; Any)Int">requiring</a> <span class="delimiter">(</span><a href="#akka.io;TcpExt;Settings.BatchAcceptLimit.$anonfun.x$8" title="Int">_</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span>, <span title="String(&quot;batch-accept-limit must be &gt; 0&quot;)" class="string">&quot;batch-accept-limit must be &gt; 0&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Int" id="akka.io;TcpExt;Settings.DirectBufferSize">DirectBufferSize</a>: <span title="Int">Int</span> = <a href="#akka.io;TcpExt;Settings.getIntBytes" title="(path: String)Int">getIntBytes</a><span class="delimiter">(</span><span title="String(&quot;direct-buffer-size&quot;)" class="string">&quot;direct-buffer-size&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Int" id="akka.io;TcpExt;Settings.MaxDirectBufferPoolSize">MaxDirectBufferPoolSize</a>: <span title="Int">Int</span> = <a href="#akka.io;TcpExt;Settings._config" title="(x$1: String)Int">getInt</a><span class="delimiter">(</span><span title="String(&quot;direct-buffer-pool-limit&quot;)" class="string">&quot;direct-buffer-pool-limit&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="scala.concurrent.duration.Duration" id="akka.io;TcpExt;Settings.RegisterTimeout">RegisterTimeout</a>: <span title="scala.concurrent.duration.Duration">Duration</span> = <a href="#akka.io;TcpExt;Settings._config" title="(x$1: String)String">getString</a><span class="delimiter">(</span><span title="String(&quot;register-timeout&quot;)" class="string">&quot;register-timeout&quot;</span><span class="delimiter">)</span> <span title="scala.concurrent.duration.Duration" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="String(&quot;infinite&quot;)" class="string">&quot;infinite&quot;</span> ⇒ <span title="scala.concurrent.duration.Duration.type">Duration</span>.<span title="=&gt; scala.concurrent.duration.Duration.Infinite">Undefined</span>
      <span class="keyword">case</span> <a title="String" id="akka.io;TcpExt;Settings.RegisterTimeout.x">x</a>          ⇒ <a href="../util/Helpers.scala.html#akka.util.Helpers.ConfigOps(7001b1cdb7)" title="implicit akka.util.Helpers.ConfigOps : (config: com.typesafe.config.Config)akka.util.Helpers.ConfigOps">_config</a>.<a href="../util/Helpers.scala.html#akka.util.Helpers;ConfigOps.getMillisDuration" title="(path: String)scala.concurrent.duration.FiniteDuration">getMillisDuration</a><span class="delimiter">(</span><span title="String(&quot;register-timeout&quot;)" class="string">&quot;register-timeout&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="Int" id="akka.io;TcpExt;Settings.ReceivedMessageSizeLimit">ReceivedMessageSizeLimit</a>: <span title="Int">Int</span> = <a href="#akka.io;TcpExt;Settings._config" title="(x$1: String)String">getString</a><span class="delimiter">(</span><span title="String(&quot;max-received-message-size&quot;)" class="string">&quot;max-received-message-size&quot;</span><span class="delimiter">)</span> <span title="Int" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="String(&quot;unlimited&quot;)" class="string">&quot;unlimited&quot;</span> ⇒ Int.<span title="Int(2147483647)">MaxValue</span>
      <span class="keyword">case</span> <a title="String" id="akka.io;TcpExt;Settings.ReceivedMessageSizeLimit.x">x</a>           ⇒ <a href="#akka.io;TcpExt;Settings.getIntBytes" title="(path: String)Int">getIntBytes</a><span class="delimiter">(</span><span title="String(&quot;received-message-size-limit&quot;)" class="string">&quot;received-message-size-limit&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="String" id="akka.io;TcpExt;Settings.ManagementDispatcher">ManagementDispatcher</a>: <span title="String">String</span> = <a href="#akka.io;TcpExt;Settings._config" title="(x$1: String)String">getString</a><span class="delimiter">(</span><span title="String(&quot;management-dispatcher&quot;)" class="string">&quot;management-dispatcher&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="String" id="akka.io;TcpExt;Settings.FileIODispatcher">FileIODispatcher</a>: <span title="String">String</span> = <a href="#akka.io;TcpExt;Settings._config" title="(x$1: String)String">getString</a><span class="delimiter">(</span><span title="String(&quot;file-io-dispatcher&quot;)" class="string">&quot;file-io-dispatcher&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Int" id="akka.io;TcpExt;Settings.TransferToLimit">TransferToLimit</a>: <span title="Int">Int</span> = <a href="#akka.io;TcpExt;Settings._config" title="(x$1: String)String">getString</a><span class="delimiter">(</span><span title="String(&quot;file-io-transferTo-limit&quot;)" class="string">&quot;file-io-transferTo-limit&quot;</span><span class="delimiter">)</span> <span title="Int" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="String(&quot;unlimited&quot;)" class="string">&quot;unlimited&quot;</span> ⇒ Int.<span title="Int(2147483647)">MaxValue</span>
      <span class="keyword">case</span> _           ⇒ <a href="#akka.io;TcpExt;Settings.getIntBytes" title="(path: String)Int">getIntBytes</a><span class="delimiter">(</span><span title="String(&quot;file-io-transferTo-limit&quot;)" class="string">&quot;file-io-transferTo-limit&quot;</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="Int" id="akka.io;TcpExt;Settings.MaxChannelsPerSelector">MaxChannelsPerSelector</a>: <span title="Int">Int</span> = <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="SelectionHandler.scala.html#akka.io;SelectionHandlerSettings.MaxChannels" title="=&gt; Int">MaxChannels</a> <span title="(x: Int)Boolean">==</span> -<span title="Int(-1)" class="int">1</span><span class="delimiter">)</span> -<span title="Int(-1)" class="int">1</span> <span class="keyword">else</span> math.<span title="(x: Int, y: Int)Int">max</span><span class="delimiter">(</span><a href="SelectionHandler.scala.html#akka.io;SelectionHandlerSettings.MaxChannels" title="=&gt; Int">MaxChannels</a> <span title="(x: Int)Int">/</span> <a href="#akka.io;TcpExt;Settings.NrOfSelectors" title="=&gt; Int">NrOfSelectors</a>, <span title="Int(1)" class="int">1</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="Int" id="akka.io;TcpExt;Settings.FinishConnectRetries">FinishConnectRetries</a>: <span title="Int">Int</span> = <a href="#akka.io;TcpExt;Settings._config" title="(x$1: String)Int">getInt</a><a href="../util/Helpers.scala.html#akka.util.Helpers.Requiring(1ee601cfa2)" title="(value: Int)akka.util.Helpers.Requiring[Int]" class="delimiter">(</a><span title="String(&quot;finish-connect-retries&quot;)" class="string">&quot;finish-connect-retries&quot;</span><span class="delimiter">)</span> <a href="../util/Helpers.scala.html#akka.util.Helpers;Requiring.requiring(734662848f)" title="(cond: Int =&gt; Boolean, msg: =&gt; Any)Int">requiring</a> <span class="delimiter">(</span><a href="#akka.io;TcpExt;Settings.FinishConnectRetries.$anonfun.x$9" title="Int">_</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span>,
      <span title="String(&quot;finish-connect-retries must be &gt; 0&quot;)" class="string">&quot;finish-connect-retries must be &gt; 0&quot;</span><span class="delimiter">)</span>

    <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(path: String)Int" id="akka.io;TcpExt;Settings.getIntBytes">getIntBytes</a><span class="delimiter">(</span><a title="String" id="akka.io;TcpExt;Settings.getIntBytes.path">path</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Int">Int</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Long" id="akka.io;TcpExt;Settings.getIntBytes.size">size</a> = <a href="#akka.io;TcpExt;Settings._config" title="(x$1: String)Long">getBytes</a><span class="delimiter">(</span><a href="#akka.io;TcpExt;Settings.getIntBytes.path" title="String">path</a><span class="delimiter">)</span>
      <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#akka.io;TcpExt;Settings.getIntBytes.size" title="implicit scala.Predef.Long2long : (x: Long)Long">size</a> <span title="(x: Int)Boolean">&lt;</span> Int.<span title="Int(2147483647)">MaxValue</span>, <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;&quot;)">$</span><a href="#akka.io;TcpExt;Settings.getIntBytes.path" title="String">path</a><span title="String(&quot; must be &lt; 2 GiB&quot;)" class="string"> must be &lt; 2 GiB&quot;</span><span class="delimiter">)</span>
      <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#akka.io;TcpExt;Settings.getIntBytes.size" title="implicit scala.Predef.Long2long : (x: Long)Long">size</a> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span>, <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;&quot;)">$</span><a href="#akka.io;TcpExt;Settings.getIntBytes.path" title="String">path</a><span title="String(&quot; must be non-negative&quot;)" class="string"> must be non-negative&quot;</span><span class="delimiter">)</span>
      <a href="#akka.io;TcpExt;Settings.getIntBytes.size" title="implicit scala.Predef.Long2long : (x: Long)Long">size</a>.<span title="=&gt; Int">toInt</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   *
   */</span>
  <span class="keyword">val</span> <a title="akka.actor.ActorRef" id="akka.io;TcpExt.manager">manager</a>: <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a> = <span class="delimiter">{</span>
    <a href="#akka.io;TcpExt.system" title="akka.actor.ExtendedActorSystem">system</a>.<a href="../actor/ActorSystem.scala.html#akka.actor;ExtendedActorSystem.systemActorOf" title="(props: akka.actor.Props, name: String)akka.actor.ActorRef">systemActorOf</a><span class="delimiter">(</span>
      props = <a href="../actor/Props.scala.html#akka.actor.Props.apply(0870a176b3)" title="(clazz: Class[_], args: Any*)akka.actor.Props">Props</a><span class="delimiter">(</span>classOf<span title="Class[akka.io.TcpManager](classOf[akka.io.TcpManager])" class="delimiter">[</span>TcpManager<span class="delimiter">]</span>, <a href="#akka.io;TcpExt" title="akka.io.TcpExt" class="keyword">this</a><span class="delimiter">)</span>.<a href="../actor/Props.scala.html#akka.actor;Props.withDispatcher" title="(d: String)akka.actor.Props">withDispatcher</a><span class="delimiter">(</span><a href="#akka.io;TcpExt.Settings" title="=&gt; TcpExt.this.Settings">Settings</a>.<a href="#akka.io;TcpExt;Settings.ManagementDispatcher" title="=&gt; String">ManagementDispatcher</a><span class="delimiter">)</span>.<a href="../actor/Props.scala.html#akka.actor;Props.withDeploy" title="(d: akka.actor.Deploy)akka.actor.Props">withDeploy</a><span class="delimiter">(</span><a href="../actor/Deployer.scala.html#akka.actor.Deploy" title="akka.actor.Deploy.type">Deploy</a>.<a href="../actor/Deployer.scala.html#akka.actor.Deploy.local" title="=&gt; akka.actor.Deploy">local</a><span class="delimiter">)</span>,
      name = <span title="String(&quot;IO-TCP&quot;)" class="string">&quot;IO-TCP&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Java API: retrieve a reference to the manager actor.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; akka.actor.ActorRef" id="akka.io;TcpExt.getManager">getManager</a>: <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a> = <a href="#akka.io;TcpExt.manager" title="=&gt; akka.actor.ActorRef">manager</a>

  <span class="keyword">val</span> <a title="akka.io.BufferPool" id="akka.io;TcpExt.bufferPool">bufferPool</a>: <a href="DirectByteBufferPool.scala.html#akka.io;BufferPool" title="akka.io.BufferPool">BufferPool</a> = <span title="akka.io.DirectByteBufferPool" class="keyword">new</span> <a href="DirectByteBufferPool.scala.html#akka.io;DirectByteBufferPool" title="akka.io.DirectByteBufferPool">DirectByteBufferPool</a><span class="delimiter">(</span><a href="#akka.io;TcpExt.Settings" title="=&gt; TcpExt.this.Settings">Settings</a>.<a href="#akka.io;TcpExt;Settings.DirectBufferSize" title="=&gt; Int">DirectBufferSize</a>, <a href="#akka.io;TcpExt.Settings" title="=&gt; TcpExt.this.Settings">Settings</a>.<a href="#akka.io;TcpExt;Settings.MaxDirectBufferPoolSize" title="=&gt; Int">MaxDirectBufferPoolSize</a><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="akka.dispatch.MessageDispatcher" id="akka.io;TcpExt.fileIoDispatcher">fileIoDispatcher</a> = <a href="#akka.io;TcpExt.system" title="akka.actor.ExtendedActorSystem">system</a>.<a href="../actor/ActorSystem.scala.html#akka.actor;ActorSystem.dispatchers" title="=&gt; akka.dispatch.Dispatchers">dispatchers</a>.<a href="../dispatch/Dispatchers.scala.html#akka.dispatch;Dispatchers.lookup" title="(id: String)akka.dispatch.MessageDispatcher">lookup</a><span class="delimiter">(</span><a href="#akka.io;TcpExt.Settings" title="=&gt; TcpExt.this.Settings">Settings</a>.<a href="#akka.io;TcpExt;Settings.FileIODispatcher" title="=&gt; String">FileIODispatcher</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Java API for accessing socket options.
 */</span>
<span class="keyword">object</span> <a title="akka.io.TcpSO.type" id="akka.io.TcpSO">TcpSO</a> <a href="#akka.io.TcpSO" title="akka.io.TcpSO.type" class="keyword">extends</a> <a href="Inet.scala.html#akka.io.Inet;SoJavaFactories" title="akka.io.Inet.SoJavaFactories">SoJavaFactories</a> <span class="delimiter">{</span>
  <span class="keyword">import</span> <a href="#akka.io.Tcp" title="akka.io.Tcp.type">Tcp</a>.<a href="#akka.io.Tcp.SO" title="akka.io.Tcp.SO.type">SO</a>._

  <span class="comment">/**
   * [[akka.io.Inet.SocketOption]] to enable or disable SO_KEEPALIVE
   *
   * For more information see [[java.net.Socket.setKeepAlive]]
   */</span>
  <span class="keyword">def</span> <a title="(on: Boolean)akka.io.Tcp.SO.KeepAlive" id="akka.io.TcpSO.keepAlive">keepAlive</a><span class="delimiter">(</span><a title="Boolean" id="akka.io.TcpSO.keepAlive.on">on</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> = <a href="#akka.io.Tcp.SO.KeepAlive.readResolve" title="(on: Boolean)akka.io.Tcp.SO.KeepAlive">KeepAlive</a><span class="delimiter">(</span><a href="#akka.io.TcpSO.keepAlive.on" title="Boolean">on</a><span class="delimiter">)</span>

  <span class="comment">/**
   * [[akka.io.Inet.SocketOption]] to enable or disable OOBINLINE (receipt
   * of TCP urgent data) By default, this option is disabled and TCP urgent
   * data is silently discarded.
   *
   * For more information see [[java.net.Socket.setOOBInline]]
   */</span>
  <span class="keyword">def</span> <a title="(on: Boolean)akka.io.Tcp.SO.OOBInline" id="akka.io.TcpSO.oobInline">oobInline</a><span class="delimiter">(</span><a title="Boolean" id="akka.io.TcpSO.oobInline.on">on</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> = <a href="#akka.io.Tcp.SO.OOBInline.readResolve" title="(on: Boolean)akka.io.Tcp.SO.OOBInline">OOBInline</a><span class="delimiter">(</span><a href="#akka.io.TcpSO.oobInline.on" title="Boolean">on</a><span class="delimiter">)</span>

  <span class="comment">/**
   * [[akka.io.Inet.SocketOption]] to enable or disable TCP_NODELAY
   * (disable or enable Nagle's algorithm)
   *
   * Please note, that TCP_NODELAY is enabled by default.
   *
   * For more information see [[java.net.Socket.setTcpNoDelay]]
   */</span>
  <span class="keyword">def</span> <a title="(on: Boolean)akka.io.Tcp.SO.TcpNoDelay" id="akka.io.TcpSO.tcpNoDelay">tcpNoDelay</a><span class="delimiter">(</span><a title="Boolean" id="akka.io.TcpSO.tcpNoDelay.on">on</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span> = <a href="#akka.io.Tcp.SO.TcpNoDelay.readResolve" title="(on: Boolean)akka.io.Tcp.SO.TcpNoDelay">TcpNoDelay</a><span class="delimiter">(</span><a href="#akka.io.TcpSO.tcpNoDelay.on" title="Boolean">on</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="akka.io.TcpMessage.type" id="akka.io.TcpMessage">TcpMessage</a> <a href="#akka.io.TcpMessage" title="akka.io.TcpMessage.type" class="delimiter">{</a>
  <span class="keyword">import</span> <span title="language.type">language</span>.implicitConversions
  <span class="keyword">import</span> <a href="#akka.io.Tcp" title="akka.io.Tcp.type">Tcp</a>._

  <span class="comment">/**
   * The Connect message is sent to the TCP manager actor, which is obtained via
   * [[TcpExt#getManager]]. Either the manager replies with a [[Tcp.CommandFailed]]
   * or the actor handling the new connection replies with a [[Tcp.Connected]]
   * message.
   *
   * @param remoteAddress is the address to connect to
   * @param localAddress optionally specifies a specific address to bind to
   * @param options Please refer to [[TcpSO]] for a list of all supported options.
   * @param timeout is the desired connection timeout, `null` means &quot;no timeout&quot;
   * @param pullMode enables pull based reading from the connection
   */</span>
  <span class="keyword">def</span> <a title="(remoteAddress: java.net.InetSocketAddress, localAddress: java.net.InetSocketAddress, options: Iterable[akka.io.Inet.SocketOption], timeout: scala.concurrent.duration.FiniteDuration, pullMode: Boolean)akka.io.Tcp.Command" id="akka.io.TcpMessage.connect(56a9fd07ed)">connect</a><span class="delimiter">(</span><a title="java.net.InetSocketAddress" id="akka.io.TcpMessage.connect(56a9fd07ed).remoteAddress">remoteAddress</a>: <span title="java.net.InetSocketAddress">InetSocketAddress</span>,
              <a title="java.net.InetSocketAddress" id="akka.io.TcpMessage.connect(56a9fd07ed).localAddress">localAddress</a>: <span title="java.net.InetSocketAddress">InetSocketAddress</span>,
              <a title="Iterable[akka.io.Inet.SocketOption]" id="akka.io.TcpMessage.connect(56a9fd07ed).options">options</a>: <span title="Iterable[akka.io.Inet.SocketOption]">JIterable</span><span class="delimiter">[</span>SocketOption<span class="delimiter">]</span>,
              <a title="scala.concurrent.duration.FiniteDuration" id="akka.io.TcpMessage.connect(56a9fd07ed).timeout">timeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>,
              <a title="Boolean" id="akka.io.TcpMessage.connect(56a9fd07ed).pullMode">pullMode</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp.Connect.readResolve" title="(remoteAddress: java.net.InetSocketAddress, localAddress: Option[java.net.InetSocketAddress], options: scala.collection.immutable.Traversable[akka.io.Inet.SocketOption], timeout: Option[scala.concurrent.duration.FiniteDuration], pullMode: Boolean)akka.io.Tcp.Connect">Connect</a><span class="delimiter">(</span><a href="#akka.io.TcpMessage.connect(56a9fd07ed).remoteAddress" title="java.net.InetSocketAddress">remoteAddress</a>, <span title="(x: java.net.InetSocketAddress)Option[java.net.InetSocketAddress]">Option</span><span class="delimiter">(</span><a href="#akka.io.TcpMessage.connect(56a9fd07ed).localAddress" title="java.net.InetSocketAddress">localAddress</a><span class="delimiter">)</span>, <a href="#akka.io.TcpMessage.fromJava" title="(coll: Iterable[akka.io.Inet.SocketOption])scala.collection.immutable.Traversable[akka.io.Inet.SocketOption]">options</a>, <span title="(x: scala.concurrent.duration.FiniteDuration)Option[scala.concurrent.duration.FiniteDuration]">Option</span><span class="delimiter">(</span><a href="#akka.io.TcpMessage.connect(56a9fd07ed).timeout" title="scala.concurrent.duration.FiniteDuration">timeout</a><span class="delimiter">)</span>, <a href="#akka.io.TcpMessage.connect(56a9fd07ed).pullMode" title="Boolean">pullMode</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Connect to the given `remoteAddress` without binding to a local address and without
   * specifying options.
   */</span>
  <span class="keyword">def</span> <a title="(remoteAddress: java.net.InetSocketAddress)akka.io.Tcp.Command" id="akka.io.TcpMessage.connect(b027e2369b)">connect</a><span class="delimiter">(</span><a title="java.net.InetSocketAddress" id="akka.io.TcpMessage.connect(b027e2369b).remoteAddress">remoteAddress</a>: <span title="java.net.InetSocketAddress">InetSocketAddress</span><span class="delimiter">)</span>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp.Connect.readResolve" title="(remoteAddress: java.net.InetSocketAddress, localAddress: Option[java.net.InetSocketAddress], options: scala.collection.immutable.Traversable[akka.io.Inet.SocketOption], timeout: Option[scala.concurrent.duration.FiniteDuration], pullMode: Boolean)akka.io.Tcp.Connect">Connect</a><span class="delimiter">(</span><a href="#akka.io.TcpMessage.connect(b027e2369b).remoteAddress" title="java.net.InetSocketAddress">remoteAddress</a>, <span title="None.type">None</span>, <span title="scala.collection.immutable.Nil.type">Nil</span>, <span title="None.type">None</span>, pullMode = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>

  <span class="comment">/**
   * The Bind message is send to the TCP manager actor, which is obtained via
   * [[TcpExt#getManager]] in order to bind to a listening socket. The manager
   * replies either with a [[Tcp.CommandFailed]] or the actor handling the listen
   * socket replies with a [[Tcp.Bound]] message. If the local port is set to 0 in
   * the Bind message, then the [[Tcp.Bound]] message should be inspected to find
   * the actual port which was bound to.
   *
   * @param handler The actor which will receive all incoming connection requests
   *                in the form of [[Tcp.Connected]] messages.
   *
   * @param localAddress The socket address to bind to; use port zero for
   *                automatic assignment (i.e. an ephemeral port, see [[Bound]])
   *
   * @param backlog This specifies the number of unaccepted connections the O/S
   *                kernel will hold for this port before refusing connections.
   *
   * @param options Please refer to [[TcpSO]] for a list of all supported options.
   *
   * @param pullMode enables pull based accepting and of connections and pull
   *                 based reading from the accepted connections.
   */</span>
  <span class="keyword">def</span> <a title="(handler: akka.actor.ActorRef, endpoint: java.net.InetSocketAddress, backlog: Int, options: Iterable[akka.io.Inet.SocketOption], pullMode: Boolean)akka.io.Tcp.Command" id="akka.io.TcpMessage.bind(b7e954fd7d)">bind</a><span class="delimiter">(</span><a title="akka.actor.ActorRef" id="akka.io.TcpMessage.bind(b7e954fd7d).handler">handler</a>: <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a>,
           <a title="java.net.InetSocketAddress" id="akka.io.TcpMessage.bind(b7e954fd7d).endpoint">endpoint</a>: <span title="java.net.InetSocketAddress">InetSocketAddress</span>,
           <a title="Int" id="akka.io.TcpMessage.bind(b7e954fd7d).backlog">backlog</a>: <span title="Int">Int</span>,
           <a title="Iterable[akka.io.Inet.SocketOption]" id="akka.io.TcpMessage.bind(b7e954fd7d).options">options</a>: <span title="Iterable[akka.io.Inet.SocketOption]">JIterable</span><span class="delimiter">[</span>SocketOption<span class="delimiter">]</span>,
           <a title="Boolean" id="akka.io.TcpMessage.bind(b7e954fd7d).pullMode">pullMode</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp.Bind.readResolve" title="(handler: akka.actor.ActorRef, localAddress: java.net.InetSocketAddress, backlog: Int, options: scala.collection.immutable.Traversable[akka.io.Inet.SocketOption], pullMode: Boolean)akka.io.Tcp.Bind">Bind</a><span class="delimiter">(</span><a href="#akka.io.TcpMessage.bind(b7e954fd7d).handler" title="akka.actor.ActorRef">handler</a>, <a href="#akka.io.TcpMessage.bind(b7e954fd7d).endpoint" title="java.net.InetSocketAddress">endpoint</a>, <a href="#akka.io.TcpMessage.bind(b7e954fd7d).backlog" title="Int">backlog</a>, <a href="#akka.io.TcpMessage.fromJava" title="(coll: Iterable[akka.io.Inet.SocketOption])scala.collection.immutable.Traversable[akka.io.Inet.SocketOption]">options</a>, <a href="#akka.io.TcpMessage.bind(b7e954fd7d).pullMode" title="Boolean">pullMode</a><span class="delimiter">)</span>
  <span class="comment">/**
   * Open a listening socket without specifying options.
   */</span>
  <span class="keyword">def</span> <a title="(handler: akka.actor.ActorRef, endpoint: java.net.InetSocketAddress, backlog: Int)akka.io.Tcp.Command" id="akka.io.TcpMessage.bind(43d71775de)">bind</a><span class="delimiter">(</span><a title="akka.actor.ActorRef" id="akka.io.TcpMessage.bind(43d71775de).handler">handler</a>: <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a>,
           <a title="java.net.InetSocketAddress" id="akka.io.TcpMessage.bind(43d71775de).endpoint">endpoint</a>: <span title="java.net.InetSocketAddress">InetSocketAddress</span>,
           <a title="Int" id="akka.io.TcpMessage.bind(43d71775de).backlog">backlog</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp.Bind.readResolve" title="(handler: akka.actor.ActorRef, localAddress: java.net.InetSocketAddress, backlog: Int, options: scala.collection.immutable.Traversable[akka.io.Inet.SocketOption], pullMode: Boolean)akka.io.Tcp.Bind">Bind</a><span class="delimiter">(</span><a href="#akka.io.TcpMessage.bind(43d71775de).handler" title="akka.actor.ActorRef">handler</a>, <a href="#akka.io.TcpMessage.bind(43d71775de).endpoint" title="java.net.InetSocketAddress">endpoint</a>, <a href="#akka.io.TcpMessage.bind(43d71775de).backlog" title="Int">backlog</a>, <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span>

  <span class="comment">/**
   * This message must be sent to a TCP connection actor after receiving the
   * [[Tcp.Connected]] message. The connection will not read any data from the
   * socket until this message is received, because this message defines the
   * actor which will receive all inbound data.
   *
   * @param handler The actor which will receive all incoming data and which
   *                will be informed when the connection is closed.
   *
   * @param keepOpenOnPeerClosed If this is set to true then the connection
   *                is not automatically closed when the peer closes its half,
   *                requiring an explicit [[Tcp.Closed]] from our side when finished.
   *
   * @param useResumeWriting If this is set to true then the connection actor
   *                will refuse all further writes after issuing a [[Tcp.CommandFailed]]
   *                notification until [[Tcp.ResumeWriting]] is received. This can
   *                be used to implement NACK-based write backpressure.
   */</span>
  <span class="keyword">def</span> <a title="(handler: akka.actor.ActorRef, keepOpenOnPeerClosed: Boolean, useResumeWriting: Boolean)akka.io.Tcp.Command" id="akka.io.TcpMessage.register(045e06acda)">register</a><span class="delimiter">(</span><a title="akka.actor.ActorRef" id="akka.io.TcpMessage.register(045e06acda).handler">handler</a>: <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a>, <a title="Boolean" id="akka.io.TcpMessage.register(045e06acda).keepOpenOnPeerClosed">keepOpenOnPeerClosed</a>: <span title="Boolean">Boolean</span>, <a title="Boolean" id="akka.io.TcpMessage.register(045e06acda).useResumeWriting">useResumeWriting</a>: <span title="Boolean">Boolean</span><span class="delimiter">)</span>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> =
    <a href="#akka.io.Tcp.Register.readResolve" title="(handler: akka.actor.ActorRef, keepOpenOnPeerClosed: Boolean, useResumeWriting: Boolean)akka.io.Tcp.Register">Register</a><span class="delimiter">(</span><a href="#akka.io.TcpMessage.register(045e06acda).handler" title="akka.actor.ActorRef">handler</a>, <a href="#akka.io.TcpMessage.register(045e06acda).keepOpenOnPeerClosed" title="Boolean">keepOpenOnPeerClosed</a>, <a href="#akka.io.TcpMessage.register(045e06acda).useResumeWriting" title="Boolean">useResumeWriting</a><span class="delimiter">)</span>
  <span class="comment">/**
   * The same as `register(handler, false, false)`.
   */</span>
  <span class="keyword">def</span> <a title="(handler: akka.actor.ActorRef)akka.io.Tcp.Command" id="akka.io.TcpMessage.register(5b10b02fd0)">register</a><span class="delimiter">(</span><a title="akka.actor.ActorRef" id="akka.io.TcpMessage.register(5b10b02fd0).handler">handler</a>: <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a><span class="delimiter">)</span>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp.Register.readResolve" title="(handler: akka.actor.ActorRef, keepOpenOnPeerClosed: Boolean, useResumeWriting: Boolean)akka.io.Tcp.Register">Register</a><span class="delimiter">(</span><a href="#akka.io.TcpMessage.register(5b10b02fd0).handler" title="akka.actor.ActorRef">handler</a><span class="delimiter">)</span>

  <span class="comment">/**
   * In order to close down a listening socket, send this message to that socket’s
   * actor (that is the actor which previously had sent the [[Tcp.Bound]] message). The
   * listener socket actor will reply with a [[Tcp.Unbound]] message.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; akka.io.Tcp.Command" id="akka.io.TcpMessage.unbind">unbind</a>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp.Unbind.readResolve" title="akka.io.Tcp.Unbind.type">Unbind</a>

  <span class="comment">/**
   * A normal close operation will first flush pending writes and then close the
   * socket. The sender of this command and the registered handler for incoming
   * data will both be notified once the socket is closed using a [[Tcp.Closed]]
   * message.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; akka.io.Tcp.Command" id="akka.io.TcpMessage.close">close</a>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp.Close.readResolve" title="akka.io.Tcp.Close.type">Close</a>

  <span class="comment">/**
   * A confirmed close operation will flush pending writes and half-close the
   * connection, waiting for the peer to close the other half. The sender of this
   * command and the registered handler for incoming data will both be notified
   * once the socket is closed using a [[Tcp.ConfirmedClosed]] message.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; akka.io.Tcp.Command" id="akka.io.TcpMessage.confirmedClose">confirmedClose</a>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp.ConfirmedClose.readResolve" title="akka.io.Tcp.ConfirmedClose.type">ConfirmedClose</a>

  <span class="comment">/**
   * An abort operation will not flush pending writes and will issue a TCP ABORT
   * command to the O/S kernel which should result in a TCP_RST packet being sent
   * to the peer. The sender of this command and the registered handler for
   * incoming data will both be notified once the socket is closed using a
   * [[Tcp.Aborted]] message.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; akka.io.Tcp.Command" id="akka.io.TcpMessage.abort">abort</a>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp.Abort.readResolve" title="akka.io.Tcp.Abort.type">Abort</a>

  <span class="comment">/**
   * Each [[Tcp.WriteCommand]] can optionally request a positive acknowledgment to be sent
   * to the commanding actor. If such notification is not desired the [[Tcp.WriteCommand#ack]]
   * must be set to an instance of this class. The token contained within can be used
   * to recognize which write failed when receiving a [[Tcp.CommandFailed]] message.
   */</span>
  <span class="keyword">def</span> <a title="(token: AnyRef)akka.io.Tcp.NoAck" id="akka.io.TcpMessage.noAck(bf80952801)">noAck</a><span class="delimiter">(</span><a title="AnyRef" id="akka.io.TcpMessage.noAck(bf80952801).token">token</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>: <a href="#akka.io.Tcp;NoAck" title="akka.io.Tcp.NoAck">NoAck</a> = <a href="#akka.io.Tcp;NoAck" title="(token: Any)akka.io.Tcp.NoAck">NoAck</a><span class="delimiter">(</span><a href="#akka.io.TcpMessage.noAck(bf80952801).token" title="AnyRef">token</a><span class="delimiter">)</span>
  <span class="comment">/**
   * Default [[Tcp.NoAck]] instance which is used when no acknowledgment information is
   * explicitly provided. Its “token” is `null`.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; akka.io.Tcp.NoAck" id="akka.io.TcpMessage.noAck(d162071c04)">noAck</a>: <a href="#akka.io.Tcp;NoAck" title="akka.io.Tcp.NoAck">NoAck</a> = <a href="#akka.io.Tcp.NoAck.readResolve" title="akka.io.Tcp.NoAck.type">NoAck</a>

  <span class="comment">/**
   * Write data to the TCP connection. If no ack is needed use the special
   * `NoAck` object. The connection actor will reply with a [[Tcp.CommandFailed]]
   * message if the write could not be enqueued. If [[Tcp.WriteCommand#wantsAck]]
   * returns true, the connection actor will reply with the supplied [[Tcp.WriteCommand#ack]]
   * token once the write has been successfully enqueued to the O/S kernel.
   * &lt;b&gt;Note that this does not in any way guarantee that the data will be
   * or have been sent!&lt;/b&gt; Unfortunately there is no way to determine whether
   * a particular write has been sent by the O/S.
   */</span>
  <span class="keyword">def</span> <a title="(data: akka.util.ByteString, ack: akka.io.Tcp.Event)akka.io.Tcp.Command" id="akka.io.TcpMessage.write(8c31c3a000)">write</a><span class="delimiter">(</span><a title="akka.util.ByteString" id="akka.io.TcpMessage.write(8c31c3a000).data">data</a>: <a href="../util/ByteString.scala.html#akka.util;ByteString" title="akka.util.ByteString">ByteString</a>, <a title="akka.io.Tcp.Event" id="akka.io.TcpMessage.write(8c31c3a000).ack">ack</a>: <a href="#akka.io.Tcp;Event" title="akka.io.Tcp.Event">Event</a><span class="delimiter">)</span>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp;Write" title="(data: akka.util.ByteString, ack: akka.io.Tcp.Event)akka.io.Tcp.Write">Write</a><span class="delimiter">(</span><a href="#akka.io.TcpMessage.write(8c31c3a000).data" title="akka.util.ByteString">data</a>, <a href="#akka.io.TcpMessage.write(8c31c3a000).ack" title="akka.io.Tcp.Event">ack</a><span class="delimiter">)</span>
  <span class="comment">/**
   * The same as `write(data, noAck())`.
   */</span>
  <span class="keyword">def</span> <a title="(data: akka.util.ByteString)akka.io.Tcp.Command" id="akka.io.TcpMessage.write(05921f6120)">write</a><span class="delimiter">(</span><a title="akka.util.ByteString" id="akka.io.TcpMessage.write(05921f6120).data">data</a>: <a href="../util/ByteString.scala.html#akka.util;ByteString" title="akka.util.ByteString">ByteString</a><span class="delimiter">)</span>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp.Write.apply(428038e449)" title="(data: akka.util.ByteString)akka.io.Tcp.Write">Write</a><span class="delimiter">(</span><a href="#akka.io.TcpMessage.write(05921f6120).data" title="akka.util.ByteString">data</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Write `count` bytes starting at `position` from file at `filePath` to the connection.
   * The count must be &gt; 0. The connection actor will reply with a [[Tcp.CommandFailed]]
   * message if the write could not be enqueued. If [[Tcp.WriteCommand#wantsAck]]
   * returns true, the connection actor will reply with the supplied [[Tcp.WriteCommand#ack]]
   * token once the write has been successfully enqueued to the O/S kernel.
   * &lt;b&gt;Note that this does not in any way guarantee that the data will be
   * or have been sent!&lt;/b&gt; Unfortunately there is no way to determine whether
   * a particular write has been sent by the O/S.
   */</span>
  <span class="keyword">def</span> <a title="(filePath: String, position: Long, count: Long, ack: akka.io.Tcp.Event)akka.io.Tcp.Command" id="akka.io.TcpMessage.writeFile">writeFile</a><span class="delimiter">(</span><a title="String" id="akka.io.TcpMessage.writeFile.filePath">filePath</a>: <span title="String">String</span>, <a title="Long" id="akka.io.TcpMessage.writeFile.position">position</a>: <span title="Long">Long</span>, <a title="Long" id="akka.io.TcpMessage.writeFile.count">count</a>: <span title="Long">Long</span>, <a title="akka.io.Tcp.Event" id="akka.io.TcpMessage.writeFile.ack">ack</a>: <a href="#akka.io.Tcp;Event" title="akka.io.Tcp.Event">Event</a><span class="delimiter">)</span>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> =
    <a href="#akka.io.Tcp.WriteFile.readResolve" title="(filePath: String, position: Long, count: Long, ack: akka.io.Tcp.Event)akka.io.Tcp.WriteFile">WriteFile</a><span class="delimiter">(</span><a href="#akka.io.TcpMessage.writeFile.filePath" title="String">filePath</a>, <a href="#akka.io.TcpMessage.writeFile.position" title="Long">position</a>, <a href="#akka.io.TcpMessage.writeFile.count" title="Long">count</a>, <a href="#akka.io.TcpMessage.writeFile.ack" title="akka.io.Tcp.Event">ack</a><span class="delimiter">)</span>

  <span class="comment">/**
   * When `useResumeWriting` is in effect as was indicated in the [[Tcp.Register]] message
   * then this command needs to be sent to the connection actor in order to re-enable
   * writing after a [[Tcp.CommandFailed]] event. All [[Tcp.WriteCommand]] processed by the
   * connection actor between the first [[Tcp.CommandFailed]] and subsequent reception of
   * this message will also be rejected with [[Tcp.CommandFailed]].
   */</span>
  <span class="keyword">def</span> <a title="=&gt; akka.io.Tcp.Command" id="akka.io.TcpMessage.resumeWriting">resumeWriting</a>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp.ResumeWriting.readResolve" title="akka.io.Tcp.ResumeWriting.type">ResumeWriting</a>

  <span class="comment">/**
   * Sending this command to the connection actor will disable reading from the TCP
   * socket. TCP flow-control will then propagate backpressure to the sender side
   * as buffers fill up on either end. To re-enable reading send [[Tcp.ResumeReading]].
   */</span>
  <span class="keyword">def</span> <a title="=&gt; akka.io.Tcp.Command" id="akka.io.TcpMessage.suspendReading">suspendReading</a>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp.SuspendReading.readResolve" title="akka.io.Tcp.SuspendReading.type">SuspendReading</a>

  <span class="comment">/**
   * This command needs to be sent to the connection actor after a [[Tcp.SuspendReading]]
   * command in order to resume reading from the socket.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; akka.io.Tcp.Command" id="akka.io.TcpMessage.resumeReading">resumeReading</a>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp.ResumeReading.readResolve" title="akka.io.Tcp.ResumeReading.type">ResumeReading</a>

  <span class="comment">/**
   * This message enables the accepting of the next connection if pull reading is enabled
   * for connection actors.
   * @param batchSize The number of connections to accept before waiting for the next resume command
   */</span>
  <span class="keyword">def</span> <a title="(batchSize: Int)akka.io.Tcp.Command" id="akka.io.TcpMessage.resumeAccepting">resumeAccepting</a><span class="delimiter">(</span><a title="Int" id="akka.io.TcpMessage.resumeAccepting.batchSize">batchSize</a>: <span title="Int">Int</span><span class="delimiter">)</span>: <a href="#akka.io.Tcp;Command" title="akka.io.Tcp.Command">Command</a> = <a href="#akka.io.Tcp.ResumeAccepting.readResolve" title="(batchSize: Int)akka.io.Tcp.ResumeAccepting">ResumeAccepting</a><span class="delimiter">(</span><a href="#akka.io.TcpMessage.resumeAccepting.batchSize" title="Int">batchSize</a><span class="delimiter">)</span>

  <span class="keyword">implicit</span> <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T](coll: Iterable[T])scala.collection.immutable.Traversable[T]" id="akka.io.TcpMessage.fromJava">fromJava</a><span class="delimiter">[</span><a title="" id="akka.io.TcpMessage.fromJava;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterable[T]" id="akka.io.TcpMessage.fromJava.coll">coll</a>: <span title="Iterable[T]">JIterable</span><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: immutable.<span title="scala.collection.immutable.Traversable[T]">Traversable</span><span class="delimiter">[</span>T<span class="delimiter">]</span> = <span class="delimiter">{</span>
    akka.japi.<a href="../japi/JavaAPI.scala.html#akka.japi.Util" title="akka.japi.Util.type">Util</a>.<a href="../japi/JavaAPI.scala.html#akka.japi.Util.immutableSeq(42d3e3f9ec)" title="(iterable: Iterable[T])scala.collection.immutable.Seq[T]">immutableSeq</a><span class="delimiter">(</span><a href="#akka.io.TcpMessage.fromJava.coll" title="Iterable[T]">coll</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
