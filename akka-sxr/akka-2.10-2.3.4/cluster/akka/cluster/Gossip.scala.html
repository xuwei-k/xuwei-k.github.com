<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>cluster/akka/cluster/Gossip.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Copyright (C) 2009-2014 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>

<span class="keyword">package</span> akka.cluster

<span class="keyword">import</span> scala.collection.immutable
<span class="keyword">import</span> <a href="Member.scala.html#akka.cluster.MemberStatus" title="akka.cluster.MemberStatus.type">MemberStatus</a>._
<span class="keyword">import</span> akka.cluster.protobuf.ClusterMessageSerializer
<span class="keyword">import</span> scala.concurrent.duration.Deadline

<span class="comment">/**
 * INTERNAL API
 */</span>
<span class="keyword">private</span><span class="delimiter">[</span>cluster<span class="delimiter">]</span> <span class="keyword">object</span> <a title="akka.cluster.Gossip.type" id="akka.cluster.Gossip.readResolve">Gossip</a> <a href="#akka.cluster.Gossip.readResolve" title="akka.cluster.Gossip.type" class="delimiter">{</a>
  <span class="keyword">val</span> <a title="scala.collection.immutable.SortedSet[akka.cluster.Member]" id="akka.cluster.Gossip.emptyMembers">emptyMembers</a>: immutable.<span title="scala.collection.immutable.SortedSet[akka.cluster.Member]">SortedSet</span><span class="delimiter">[</span>Member<span class="delimiter">]</span> = immutable.<span title="scala.collection.immutable.SortedSet.type">SortedSet</span>.<a href="Member.scala.html#akka.cluster.Member.ordering" title="(implicit ord: Ordering[akka.cluster.Member])scala.collection.immutable.SortedSet[akka.cluster.Member]">empty</a>
  <span class="keyword">val</span> <a title="akka.cluster.Gossip" id="akka.cluster.Gossip.empty">empty</a>: <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip">Gossip</a> = <a href="#akka.cluster;Gossip.copy$default$2" title="akka.cluster.Gossip" class="keyword">new</a> <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip">Gossip</a><span class="delimiter">(</span><a href="#akka.cluster.Gossip.readResolve" title="akka.cluster.Gossip.type">Gossip</a>.<a href="#akka.cluster.Gossip.emptyMembers" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">emptyMembers</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(members: scala.collection.immutable.SortedSet[akka.cluster.Member])akka.cluster.Gossip" id="akka.cluster.Gossip.apply(8c093627a6)">apply</a><span class="delimiter">(</span><a title="scala.collection.immutable.SortedSet[akka.cluster.Member]" id="akka.cluster.Gossip.apply(8c093627a6).members">members</a>: immutable.<span title="scala.collection.immutable.SortedSet[akka.cluster.Member]">SortedSet</span><span class="delimiter">[</span>Member<span class="delimiter">]</span><span class="delimiter">)</span> =
    <span title="akka.cluster.Gossip" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster.Gossip.apply(8c093627a6).members" title="scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <a href="#akka.cluster.Gossip.empty" title="=&gt; akka.cluster.Gossip">empty</a> <span class="keyword">else</span> <a href="#akka.cluster.Gossip.empty" title="=&gt; akka.cluster.Gossip">empty</a>.<a href="#akka.cluster;Gossip.equals" title="(members: scala.collection.immutable.SortedSet[akka.cluster.Member], overview: akka.cluster.GossipOverview, version: akka.cluster.VectorClock)akka.cluster.Gossip">copy</a><span class="delimiter">(</span>members = <a href="#akka.cluster.Gossip.apply(8c093627a6).members" title="scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a><span class="delimiter">)</span>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Set[akka.cluster.MemberStatus]" id="akka.cluster.Gossip.leaderMemberStatus">leaderMemberStatus</a> = <span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: akka.cluster.MemberStatus*)scala.collection.immutable.Set[akka.cluster.MemberStatus]" class="delimiter">[</span><a href="Member.scala.html#akka.cluster;MemberStatus" title="akka.cluster.MemberStatus">MemberStatus</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Member.scala.html#akka.cluster.MemberStatus.Up" title="akka.cluster.MemberStatus.Up.type">Up</a>, <a href="Member.scala.html#akka.cluster.MemberStatus.Leaving" title="akka.cluster.MemberStatus.Leaving.type">Leaving</a><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.immutable.Set[akka.cluster.MemberStatus]" id="akka.cluster.Gossip.convergenceMemberStatus">convergenceMemberStatus</a> = <span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: akka.cluster.MemberStatus*)scala.collection.immutable.Set[akka.cluster.MemberStatus]" class="delimiter">[</span><a href="Member.scala.html#akka.cluster;MemberStatus" title="akka.cluster.MemberStatus">MemberStatus</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Member.scala.html#akka.cluster.MemberStatus.Up" title="akka.cluster.MemberStatus.Up.type">Up</a>, <a href="Member.scala.html#akka.cluster.MemberStatus.Leaving" title="akka.cluster.MemberStatus.Leaving.type">Leaving</a><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="scala.collection.immutable.Set[akka.cluster.MemberStatus]" id="akka.cluster.Gossip.convergenceSkipUnreachableWithMemberStatus">convergenceSkipUnreachableWithMemberStatus</a> = <span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: akka.cluster.MemberStatus*)scala.collection.immutable.Set[akka.cluster.MemberStatus]" class="delimiter">[</span><a href="Member.scala.html#akka.cluster;MemberStatus" title="akka.cluster.MemberStatus">MemberStatus</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Member.scala.html#akka.cluster.MemberStatus.Down" title="akka.cluster.MemberStatus.Down.type">Down</a>, <a href="Member.scala.html#akka.cluster.MemberStatus.Exiting" title="akka.cluster.MemberStatus.Exiting.type">Exiting</a><span class="delimiter">)</span>
  <span class="keyword">val</span> <a title="scala.collection.immutable.Set[akka.cluster.MemberStatus]" id="akka.cluster.Gossip.removeUnreachableWithMemberStatus">removeUnreachableWithMemberStatus</a> = <span title="[A](elems: A*)scala.collection.immutable.Set[A]">Set</span><span title="(elems: akka.cluster.MemberStatus*)scala.collection.immutable.Set[akka.cluster.MemberStatus]" class="delimiter">[</span><a href="Member.scala.html#akka.cluster;MemberStatus" title="akka.cluster.MemberStatus">MemberStatus</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="Member.scala.html#akka.cluster.MemberStatus.Down" title="akka.cluster.MemberStatus.Down.type">Down</a>, <a href="Member.scala.html#akka.cluster.MemberStatus.Exiting" title="akka.cluster.MemberStatus.Exiting.type">Exiting</a><span class="delimiter">)</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * INTERNAL API
 *
 * Represents the state of the cluster; cluster ring membership, ring convergence -
 * all versioned by a vector clock.
 *
 * When a node is joining the `Member`, with status `Joining`, is added to `members`.
 * If the joining node was downed it is moved from `overview.unreachable` (status `Down`)
 * to `members` (status `Joining`). It cannot rejoin if not first downed.
 *
 * When convergence is reached the leader change status of `members` from `Joining`
 * to `Up`.
 *
 * When failure detector consider a node as unavailable it will be moved from
 * `members` to `overview.unreachable`.
 *
 * When a node is downed, either manually or automatically, its status is changed to `Down`.
 * It is also removed from `overview.seen` table. The node will reside as `Down` in the
 * `overview.unreachable` set until joining again and it will then go through the normal
 * joining procedure.
 *
 * When a `Gossip` is received the version (vector clock) is used to determine if the
 * received `Gossip` is newer or older than the current local `Gossip`. The received `Gossip`
 * and local `Gossip` is merged in case of conflicting version, i.e. vector clocks without
 * same history.
 *
 * When a node is told by the user to leave the cluster the leader will move it to `Leaving`
 * and then rebalance and repartition the cluster and start hand-off by migrating the actors
 * from the leaving node to the new partitions. Once this process is complete the leader will
 * move the node to the `Exiting` state and once a convergence is complete move the node to
 * `Removed` by removing it from the `members` set and sending a `Removed` command to the
 * removed node telling it to shut itself down.
 */</span>
@SerialVersionUID<span class="delimiter">(</span><span class="long">1L</span><span class="delimiter">)</span>
<span class="keyword">private</span><span class="delimiter">[</span>cluster<span class="delimiter">]</span> <span class="keyword">case class</span> <a title="(members: scala.collection.immutable.SortedSet[akka.cluster.Member], overview: akka.cluster.GossipOverview, version: akka.cluster.VectorClock)akka.cluster.Gossip" id="akka.cluster;Gossip.equals">Gossip</a><a href="#akka.cluster;Gossip.equals" title="Product" class="delimiter">(</a>
  <a title="scala.collection.immutable.SortedSet[akka.cluster.Member]" id="akka.cluster;Gossip.copy$default$1">members</a>: immutable.<span title="scala.collection.immutable.SortedSet[akka.cluster.Member]">SortedSet</span><span class="delimiter">[</span>Member<span class="delimiter">]</span>, <span class="comment">// sorted set of members with their status, sorted by address</span>
  <a title="=&gt; akka.cluster.GossipOverview" id="akka.cluster;Gossip.copy$default$2">overview</a>: <a href="#akka.cluster.GossipOverview.readResolve" title="akka.cluster.GossipOverview">GossipOverview</a> = <a href="#akka.cluster.GossipOverview.readResolve" title="(seen: Set[akka.cluster.UniqueAddress], reachability: akka.cluster.Reachability)akka.cluster.GossipOverview">GossipOverview</a><span class="delimiter">(</span><span class="delimiter">)</span>,
  <a title="=&gt; akka.cluster.VectorClock" id="akka.cluster;Gossip.copy$default$3">version</a>: <a href="VectorClock.scala.html#akka.cluster;VectorClock" title="akka.cluster.VectorClock">VectorClock</a> = <a href="VectorClock.scala.html#akka.cluster;VectorClock" title="(versions: scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long])akka.cluster.VectorClock">VectorClock</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="comment">// vector clock version</span>

  <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="Cluster.scala.html#akka.cluster.Cluster" title="akka.cluster.Cluster.type">Cluster</a>.<a href="Cluster.scala.html#akka.cluster.Cluster.isAssertInvariantsEnabled" title="=&gt; Boolean">isAssertInvariantsEnabled</a><span class="delimiter">)</span> <a href="#akka.cluster;Gossip.assertInvariants" title="()Unit">assertInvariants</a><span class="delimiter">(</span><span class="delimiter">)</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Unit" id="akka.cluster;Gossip.assertInvariants">assertInvariants</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>

    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a>.<span title="(p: akka.cluster.Member =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#akka.cluster;Gossip.assertInvariants.$anonfun.x$1" title="akka.cluster.Member">_</a>.<a href="Member.scala.html#akka.cluster;Member.status" title="=&gt; akka.cluster.MemberStatus">status</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Member.scala.html#akka.cluster.MemberStatus.Removed" title="akka.cluster.MemberStatus.Removed.type">Removed</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)IllegalArgumentException" class="keyword">new</span> <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Live members must have status [&quot;)">Live members must have status [$</span><span class="delimiter">{</span><a href="Member.scala.html#akka.cluster.MemberStatus.Removed" title="akka.cluster.MemberStatus.Removed.type">Removed</a><span class="delimiter">}</span><span title="String(&quot;], &quot;)" class="string">], &quot;</span> <span title="(x$1: Any)String">+</span>
        <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;got [&quot;)">got [$</span><span class="delimiter">{</span><a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a>.<span title="(p: akka.cluster.Member =&gt; Boolean)scala.collection.immutable.SortedSet[akka.cluster.Member]">filter</span><span class="delimiter">(</span><a href="#akka.cluster;Gossip.assertInvariants.$anonfun.x$2" title="akka.cluster.Member">_</a>.<a href="Member.scala.html#akka.cluster;Member.status" title="=&gt; akka.cluster.MemberStatus">status</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="Member.scala.html#akka.cluster.MemberStatus.Removed" title="akka.cluster.MemberStatus.Removed.type">Removed</a><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;]&quot;)" class="string">]&quot;</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="scala.collection.immutable.Set[akka.cluster.UniqueAddress]" id="akka.cluster;Gossip.assertInvariants.inReachabilityButNotMember">inReachabilityButNotMember</a> = <a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a>.<a href="#akka.cluster.GossipOverview.apply$default$2" title="=&gt; akka.cluster.Reachability">reachability</a>.<a href="Reachability.scala.html#akka.cluster;Reachability.allObservers" title="=&gt; Set[akka.cluster.UniqueAddress]">allObservers</a> <span title="(xs: scala.collection.GenTraversableOnce[akka.cluster.UniqueAddress])scala.collection.immutable.Set[akka.cluster.UniqueAddress]">--</span> <a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a>.<span title="(f: akka.cluster.Member =&gt; akka.cluster.UniqueAddress)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.SortedSet[akka.cluster.Member],akka.cluster.UniqueAddress,scala.collection.GenTraversableOnce[akka.cluster.UniqueAddress]])scala.collection.GenTraversableOnce[akka.cluster.UniqueAddress]">map</span><span title="(implicit ord: Ordering[akka.cluster.UniqueAddress])scala.collection.generic.CanBuildFrom[scala.collection.immutable.SortedSet.Coll,akka.cluster.UniqueAddress,scala.collection.immutable.SortedSet[akka.cluster.UniqueAddress]]" class="delimiter">(</span><a href="#akka.cluster;Gossip.assertInvariants.inReachabilityButNotMember.$anonfun.x$3" title="akka.cluster.Member">_</a>.<a href="Member.scala.html#akka.cluster;Member.uniqueAddress" title="=&gt; akka.cluster.UniqueAddress">uniqueAddress</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;Gossip.assertInvariants.inReachabilityButNotMember" title="scala.collection.immutable.Set[akka.cluster.UniqueAddress]">inReachabilityButNotMember</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)IllegalArgumentException" class="keyword">new</span> <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Nodes not part of cluster in reachability table, got [%s]&quot;</span>
        <span title="(args: Any*)String">format</span> <a href="#akka.cluster;Gossip.assertInvariants.inReachabilityButNotMember" title="scala.collection.immutable.Set[akka.cluster.UniqueAddress]">inReachabilityButNotMember</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="scala.collection.immutable.Set[akka.cluster.UniqueAddress]" id="akka.cluster;Gossip.assertInvariants.seenButNotMember">seenButNotMember</a> = <a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a>.<a href="#akka.cluster.GossipOverview.apply$default$1" title="=&gt; Set[akka.cluster.UniqueAddress]">seen</a> <span title="(xs: scala.collection.GenTraversableOnce[akka.cluster.UniqueAddress])scala.collection.immutable.Set[akka.cluster.UniqueAddress]">--</span> <a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a>.<span title="(f: akka.cluster.Member =&gt; akka.cluster.UniqueAddress)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.SortedSet[akka.cluster.Member],akka.cluster.UniqueAddress,scala.collection.GenTraversableOnce[akka.cluster.UniqueAddress]])scala.collection.GenTraversableOnce[akka.cluster.UniqueAddress]">map</span><span title="(implicit ord: Ordering[akka.cluster.UniqueAddress])scala.collection.generic.CanBuildFrom[scala.collection.immutable.SortedSet.Coll,akka.cluster.UniqueAddress,scala.collection.immutable.SortedSet[akka.cluster.UniqueAddress]]" class="delimiter">(</span><a href="#akka.cluster;Gossip.assertInvariants.seenButNotMember.$anonfun.x$4" title="akka.cluster.Member">_</a>.<a href="Member.scala.html#akka.cluster;Member.uniqueAddress" title="=&gt; akka.cluster.UniqueAddress">uniqueAddress</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;Gossip.assertInvariants.seenButNotMember" title="scala.collection.immutable.Set[akka.cluster.UniqueAddress]">seenButNotMember</a>.<span title="=&gt; Boolean">nonEmpty</span><span class="delimiter">)</span>
      <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)IllegalArgumentException" class="keyword">new</span> <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Nodes not part of cluster have marked the Gossip as seen, got [%s]&quot;</span>
        <span title="(args: Any*)String">format</span> <a href="#akka.cluster;Gossip.assertInvariants.seenButNotMember" title="scala.collection.immutable.Set[akka.cluster.UniqueAddress]">seenButNotMember</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  @transient <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="Map[akka.cluster.UniqueAddress,akka.cluster.Member]" id="akka.cluster;Gossip.membersMap">membersMap</a>: <span title="Map[akka.cluster.UniqueAddress,akka.cluster.Member]">Map</span><span class="delimiter">[</span>UniqueAddress, Member<span class="delimiter">]</span> =
    <a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a>.<span title="(f: akka.cluster.Member =&gt; (akka.cluster.UniqueAddress, akka.cluster.Member))(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.SortedSet[akka.cluster.Member],(akka.cluster.UniqueAddress, akka.cluster.Member),Map[akka.cluster.UniqueAddress,akka.cluster.Member]])Map[akka.cluster.UniqueAddress,akka.cluster.Member]">map</span><span class="delimiter">(</span><a title="akka.cluster.Member" id="akka.cluster;Gossip.membersMap.$anonfun.m">m</a> ⇒ <a href="#akka.cluster;Gossip.membersMap.$anonfun.m" title="akka.cluster.Member">m</a>.<a href="Member.scala.html#akka.cluster;Member.uniqueAddress" title="(x: akka.cluster.UniqueAddress)ArrowAssoc[akka.cluster.UniqueAddress]">uniqueAddress</a> <span title="(y: akka.cluster.Member)(akka.cluster.UniqueAddress, akka.cluster.Member)">-&gt;</span> <a href="#akka.cluster;Gossip.membersMap.$anonfun.m" title="akka.cluster.Member">m</a><span class="delimiter">)</span><span class="delimiter">(</span>collection.<span title="(implicit b: scala.collection.generic.CanBuildFrom[Nothing,(akka.cluster.UniqueAddress, akka.cluster.Member),Map[akka.cluster.UniqueAddress,akka.cluster.Member]])scala.collection.generic.CanBuildFrom[scala.collection.immutable.SortedSet[akka.cluster.Member],(akka.cluster.UniqueAddress, akka.cluster.Member),Map[akka.cluster.UniqueAddress,akka.cluster.Member]]">breakOut</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Increments the version for this 'Node'.
   */</span>
  <span class="keyword">def</span> <a title="(node: akka.cluster.VectorClock.Node)akka.cluster.Gossip" id="akka.cluster;Gossip.:+(12703368c8)">:+</a><span class="delimiter">(</span><a title="akka.cluster.VectorClock.Node" id="akka.cluster;Gossip.:+(12703368c8).node">node</a>: VectorClock.<span title="akka.cluster.VectorClock.Node">Node</span><span class="delimiter">)</span>: <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip">Gossip</a> = <a href="#akka.cluster;Gossip.copy$default$1" title="scala.collection.immutable.SortedSet[akka.cluster.Member]" id="akka.cluster;Gossip.:+(12703368c8).x$11">copy</a><span class="delimiter">(</span>version = <a href="#akka.cluster;Gossip.copy$default$3" title="=&gt; akka.cluster.VectorClock">version</a> <a href="VectorClock.scala.html#akka.cluster;VectorClock.:+" title="akka.cluster.VectorClock" id="akka.cluster;Gossip.:+(12703368c8).x$9">:+</a> <a href="#akka.cluster;Gossip.:+(12703368c8).node" title="akka.cluster.VectorClock.Node">node</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Adds a member to the member node ring.
   */</span>
  <span class="keyword">def</span> <a title="(member: akka.cluster.Member)akka.cluster.Gossip" id="akka.cluster;Gossip.:+(e653a20b72)">:+</a><span class="delimiter">(</span><a title="akka.cluster.Member" id="akka.cluster;Gossip.:+(e653a20b72).member">member</a>: <a href="Member.scala.html#akka.cluster;Member" title="akka.cluster.Member">Member</a><span class="delimiter">)</span>: <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip">Gossip</a> = <span class="delimiter">{</span>
    <span title="akka.cluster.Gossip" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a> <span title="(elem: akka.cluster.Member)Boolean">contains</span> <a href="#akka.cluster;Gossip.:+(e653a20b72).member" title="akka.cluster.Member">member</a><span class="delimiter">)</span> <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip" class="keyword">this</a>
    <span class="keyword">else</span> <a href="#akka.cluster;Gossip.equals" title="Gossip.this.type" class="keyword">this</a> <a href="#akka.cluster;Gossip.equals" title="(members: scala.collection.immutable.SortedSet[akka.cluster.Member], overview: akka.cluster.GossipOverview, version: akka.cluster.VectorClock)akka.cluster.Gossip">copy</a> <span class="delimiter">(</span>members = <a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a> <span title="(elem: akka.cluster.Member)scala.collection.immutable.SortedSet[akka.cluster.Member]">+</span> <a href="#akka.cluster;Gossip.:+(e653a20b72).member" title="akka.cluster.Member">member</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Marks the gossip as seen by this node (address) by updating the address entry in the 'gossip.overview.seen'
   */</span>
  <span class="keyword">def</span> <a title="(node: akka.cluster.UniqueAddress)akka.cluster.Gossip" id="akka.cluster;Gossip.seen">seen</a><span class="delimiter">(</span><a title="akka.cluster.UniqueAddress" id="akka.cluster;Gossip.seen.node">node</a>: <a href="Member.scala.html#akka.cluster;UniqueAddress" title="akka.cluster.UniqueAddress">UniqueAddress</a><span class="delimiter">)</span>: <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip">Gossip</a> = <span class="delimiter">{</span>
    <span title="akka.cluster.Gossip" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;Gossip.seenByNode" title="(node: akka.cluster.UniqueAddress)Boolean">seenByNode</a><span class="delimiter">(</span><a href="#akka.cluster;Gossip.seen.node" title="akka.cluster.UniqueAddress">node</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip" class="keyword">this</a>
    <span class="keyword">else</span> <a href="#akka.cluster;Gossip.equals" title="Gossip.this.type" class="keyword">this</a> <a href="#akka.cluster;Gossip.copy$default$1" title="scala.collection.immutable.SortedSet[akka.cluster.Member]" id="akka.cluster;Gossip.seen.x$14">copy</a> <span class="delimiter">(</span>overview = <a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a> <a href="#akka.cluster.GossipOverview.readResolve" title="akka.cluster.GossipOverview" id="akka.cluster;Gossip.seen.x$12">copy</a> <span class="delimiter">(</span>seen = <a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a>.<a href="#akka.cluster.GossipOverview.apply$default$1" title="=&gt; Set[akka.cluster.UniqueAddress]">seen</a> <span title="(elem: akka.cluster.UniqueAddress)scala.collection.immutable.Set[akka.cluster.UniqueAddress]">+</span> <a href="#akka.cluster;Gossip.seen.node" title="akka.cluster.UniqueAddress">node</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Marks the gossip as seen by only this node (address) by replacing the 'gossip.overview.seen'
   */</span>
  <span class="keyword">def</span> <a title="(node: akka.cluster.UniqueAddress)akka.cluster.Gossip" id="akka.cluster;Gossip.onlySeen">onlySeen</a><span class="delimiter">(</span><a title="akka.cluster.UniqueAddress" id="akka.cluster;Gossip.onlySeen.node">node</a>: <a href="Member.scala.html#akka.cluster;UniqueAddress" title="akka.cluster.UniqueAddress">UniqueAddress</a><span class="delimiter">)</span>: <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip">Gossip</a> = <span class="delimiter">{</span>
    <a href="#akka.cluster;Gossip.equals" title="Gossip.this.type" class="keyword">this</a> <a href="#akka.cluster;Gossip.copy$default$1" title="scala.collection.immutable.SortedSet[akka.cluster.Member]" id="akka.cluster;Gossip.onlySeen.x$17">copy</a> <span class="delimiter">(</span>overview = <a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a> <a href="#akka.cluster.GossipOverview.readResolve" title="akka.cluster.GossipOverview" id="akka.cluster;Gossip.onlySeen.x$15">copy</a> <span class="delimiter">(</span>seen = <span title="(elems: akka.cluster.UniqueAddress*)scala.collection.immutable.Set[akka.cluster.UniqueAddress]">Set</span><span class="delimiter">(</span><a href="#akka.cluster;Gossip.onlySeen.node" title="akka.cluster.UniqueAddress">node</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * The nodes that have seen the current version of the Gossip.
   */</span>
  <span class="keyword">def</span> <a title="=&gt; Set[akka.cluster.UniqueAddress]" id="akka.cluster;Gossip.seenBy">seenBy</a>: <span title="Set[akka.cluster.UniqueAddress]">Set</span><span class="delimiter">[</span>UniqueAddress<span class="delimiter">]</span> = <a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a>.<a href="#akka.cluster.GossipOverview.apply$default$1" title="=&gt; Set[akka.cluster.UniqueAddress]">seen</a>

  <span class="comment">/**
   * Has this Gossip been seen by this node.
   */</span>
  <span class="keyword">def</span> <a title="(node: akka.cluster.UniqueAddress)Boolean" id="akka.cluster;Gossip.seenByNode">seenByNode</a><span class="delimiter">(</span><a title="akka.cluster.UniqueAddress" id="akka.cluster;Gossip.seenByNode.node">node</a>: <a href="Member.scala.html#akka.cluster;UniqueAddress" title="akka.cluster.UniqueAddress">UniqueAddress</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a>.<a href="#akka.cluster.GossipOverview.apply$default$1" title="(elem: akka.cluster.UniqueAddress)Boolean">seen</a><span class="delimiter">(</span><a href="#akka.cluster;Gossip.seenByNode.node" title="akka.cluster.UniqueAddress">node</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Merges the seen table of two Gossip instances.
   */</span>
  <span class="keyword">def</span> <a title="(that: akka.cluster.Gossip)akka.cluster.Gossip" id="akka.cluster;Gossip.mergeSeen">mergeSeen</a><span class="delimiter">(</span><a title="akka.cluster.Gossip" id="akka.cluster;Gossip.mergeSeen.that">that</a>: <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip">Gossip</a><span class="delimiter">)</span>: <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip">Gossip</a> =
    <a href="#akka.cluster;Gossip.equals" title="Gossip.this.type" class="keyword">this</a> <a href="#akka.cluster;Gossip.copy$default$1" title="scala.collection.immutable.SortedSet[akka.cluster.Member]" id="akka.cluster;Gossip.mergeSeen.x$20">copy</a> <span class="delimiter">(</span>overview = <a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a> <a href="#akka.cluster.GossipOverview.readResolve" title="akka.cluster.GossipOverview" id="akka.cluster;Gossip.mergeSeen.x$18">copy</a> <span class="delimiter">(</span>seen = <a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a>.<a href="#akka.cluster.GossipOverview.apply$default$1" title="=&gt; Set[akka.cluster.UniqueAddress]">seen</a> <span title="(elems: scala.collection.GenTraversableOnce[akka.cluster.UniqueAddress])scala.collection.immutable.Set[akka.cluster.UniqueAddress]">++</span> <a href="#akka.cluster;Gossip.mergeSeen.that" title="akka.cluster.Gossip">that</a>.<a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a>.<a href="#akka.cluster.GossipOverview.apply$default$1" title="=&gt; Set[akka.cluster.UniqueAddress]">seen</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Merges two Gossip instances including membership tables, and the VectorClock histories.
   */</span>
  <span class="keyword">def</span> <a title="(that: akka.cluster.Gossip)akka.cluster.Gossip" id="akka.cluster;Gossip.merge">merge</a><span class="delimiter">(</span><a title="akka.cluster.Gossip" id="akka.cluster;Gossip.merge.that">that</a>: <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip">Gossip</a><span class="delimiter">)</span>: <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip">Gossip</a> = <span class="delimiter">{</span>
    <span class="keyword">import</span> <a href="Member.scala.html#akka.cluster.Member" title="akka.cluster.Member.type">Member</a>.ordering

    <span class="comment">// 1. merge vector clocks</span>
    <span class="keyword">val</span> <a title="akka.cluster.VectorClock" id="akka.cluster;Gossip.merge.mergedVClock">mergedVClock</a> = <a href="#akka.cluster;Gossip.equals" title="Gossip.this.type" class="keyword">this</a>.<a href="#akka.cluster;Gossip.copy$default$3" title="=&gt; akka.cluster.VectorClock">version</a> <a href="VectorClock.scala.html#akka.cluster;VectorClock.merge" title="(that: akka.cluster.VectorClock)akka.cluster.VectorClock">merge</a> <a href="#akka.cluster;Gossip.merge.that" title="akka.cluster.Gossip">that</a>.<a href="#akka.cluster;Gossip.copy$default$3" title="=&gt; akka.cluster.VectorClock">version</a>

    <span class="comment">// 2. merge members by selecting the single Member with highest MemberStatus out of the Member groups</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.SortedSet[akka.cluster.Member]" id="akka.cluster;Gossip.merge.mergedMembers">mergedMembers</a> = <a href="#akka.cluster.Gossip.readResolve" title="akka.cluster.Gossip.type">Gossip</a>.<a href="#akka.cluster.Gossip.emptyMembers" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">emptyMembers</a> <span title="(elems: scala.collection.GenTraversableOnce[akka.cluster.Member])scala.collection.immutable.SortedSet[akka.cluster.Member]">++</span> <a href="Member.scala.html#akka.cluster.Member" title="akka.cluster.Member.type">Member</a>.<a href="Member.scala.html#akka.cluster.Member.pickHighestPriority" title="(a: Set[akka.cluster.Member], b: Set[akka.cluster.Member])Set[akka.cluster.Member]">pickHighestPriority</a><span class="delimiter">(</span><a href="#akka.cluster;Gossip.equals" title="Gossip.this.type" class="keyword">this</a>.<a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a>, <a href="#akka.cluster;Gossip.merge.that" title="akka.cluster.Gossip">that</a>.<a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a><span class="delimiter">)</span>

    <span class="comment">// 3. merge reachability table by picking records with highest version</span>
    <span class="keyword">val</span> <a title="akka.cluster.Reachability" id="akka.cluster;Gossip.merge.mergedReachability">mergedReachability</a> = <a href="#akka.cluster;Gossip.equals" title="Gossip.this.type" class="keyword">this</a>.<a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a>.<a href="#akka.cluster.GossipOverview.apply$default$2" title="=&gt; akka.cluster.Reachability">reachability</a>.<a href="Reachability.scala.html#akka.cluster;Reachability.merge" title="(allowed: scala.collection.immutable.Set[akka.cluster.UniqueAddress], other: akka.cluster.Reachability)akka.cluster.Reachability">merge</a><span class="delimiter">(</span><a href="#akka.cluster;Gossip.merge.mergedMembers" title="scala.collection.immutable.SortedSet[akka.cluster.Member]">mergedMembers</a>.<span title="(f: akka.cluster.Member =&gt; akka.cluster.UniqueAddress)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.SortedSet[akka.cluster.Member],akka.cluster.UniqueAddress,scala.collection.immutable.Set[akka.cluster.UniqueAddress]])scala.collection.immutable.Set[akka.cluster.UniqueAddress]">map</span><span title="(implicit ord: Ordering[akka.cluster.UniqueAddress])scala.collection.generic.CanBuildFrom[scala.collection.immutable.SortedSet.Coll,akka.cluster.UniqueAddress,scala.collection.immutable.SortedSet[akka.cluster.UniqueAddress]]" class="delimiter">(</span><a href="#akka.cluster;Gossip.merge.mergedReachability.$anonfun.x$5" title="akka.cluster.Member">_</a>.<a href="Member.scala.html#akka.cluster;Member.uniqueAddress" title="=&gt; akka.cluster.UniqueAddress">uniqueAddress</a><span class="delimiter">)</span>,
      <a href="#akka.cluster;Gossip.merge.that" title="akka.cluster.Gossip">that</a>.<a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a>.<a href="#akka.cluster.GossipOverview.apply$default$2" title="=&gt; akka.cluster.Reachability">reachability</a><span class="delimiter">)</span>

    <span class="comment">// 4. Nobody can have seen this new gossip yet</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.Set[akka.cluster.UniqueAddress]" id="akka.cluster;Gossip.merge.mergedSeen">mergedSeen</a> = <span title="=&gt; scala.collection.immutable.Set.type">Set</span>.<span title="[A]=&gt; scala.collection.immutable.Set[A]">empty</span><span title="scala.collection.immutable.Set[akka.cluster.UniqueAddress]" class="delimiter">[</span><a href="Member.scala.html#akka.cluster;UniqueAddress" title="akka.cluster.UniqueAddress">UniqueAddress</a><span class="delimiter">]</span>

    <a href="#akka.cluster;Gossip.equals" title="(members: scala.collection.immutable.SortedSet[akka.cluster.Member], overview: akka.cluster.GossipOverview, version: akka.cluster.VectorClock)akka.cluster.Gossip">Gossip</a><span class="delimiter">(</span><a href="#akka.cluster;Gossip.merge.mergedMembers" title="scala.collection.immutable.SortedSet[akka.cluster.Member]">mergedMembers</a>, <a href="#akka.cluster.GossipOverview.readResolve" title="(seen: Set[akka.cluster.UniqueAddress], reachability: akka.cluster.Reachability)akka.cluster.GossipOverview">GossipOverview</a><span class="delimiter">(</span><a href="#akka.cluster;Gossip.merge.mergedSeen" title="scala.collection.immutable.Set[akka.cluster.UniqueAddress]">mergedSeen</a>, <a href="#akka.cluster;Gossip.merge.mergedReachability" title="akka.cluster.Reachability">mergedReachability</a><span class="delimiter">)</span>, <a href="#akka.cluster;Gossip.merge.mergedVClock" title="akka.cluster.VectorClock">mergedVClock</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Checks if we have a cluster convergence. If there are any unreachable nodes then we can't have a convergence -
   * waiting for user to act (issuing DOWN) or leader to act (issuing DOWN through auto-down).
   *
   * @return true if convergence have been reached and false if not
   */</span>
  <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.cluster;Gossip.convergence">convergence</a>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
    <span class="comment">// First check that:</span>
    <span class="comment">//   1. we don't have any members that are unreachable, or</span>
    <span class="comment">//   2. all unreachable members in the set have status DOWN or EXITING</span>
    <span class="comment">// Else we can't continue to check for convergence</span>
    <span class="comment">// When that is done we check that all members with a convergence</span>
    <span class="comment">// status is in the seen table and has the latest vector clock</span>
    <span class="comment">// version</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.Set[akka.cluster.Member]" id="akka.cluster;Gossip.convergence.unreachable">unreachable</a> = <a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a>.<a href="#akka.cluster.GossipOverview.apply$default$2" title="=&gt; akka.cluster.Reachability">reachability</a>.<a href="Reachability.scala.html#akka.cluster;Reachability.allUnreachableOrTerminated" title="=&gt; Set[akka.cluster.UniqueAddress]">allUnreachableOrTerminated</a> <span title="(f: akka.cluster.UniqueAddress =&gt; akka.cluster.Member)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.Set[akka.cluster.UniqueAddress],akka.cluster.Member,scala.collection.immutable.Set[akka.cluster.Member]])scala.collection.immutable.Set[akka.cluster.Member]">map</span> <a href="#akka.cluster;Gossip.member" title="(node: akka.cluster.UniqueAddress)akka.cluster.Member">member</a>
    <a href="#akka.cluster;Gossip.convergence.unreachable" title="scala.collection.immutable.Set[akka.cluster.Member]">unreachable</a>.<span title="(p: akka.cluster.Member =&gt; Boolean)Boolean">forall</span><span class="delimiter">(</span><span title="akka.cluster.Member">m</span> ⇒ <a href="#akka.cluster.Gossip.readResolve" title="akka.cluster.Gossip.type">Gossip</a>.<a href="#akka.cluster.Gossip.convergenceSkipUnreachableWithMemberStatus" title="(elem: akka.cluster.MemberStatus)Boolean">convergenceSkipUnreachableWithMemberStatus</a><span class="delimiter">(</span><span title="akka.cluster.Member">m</span>.<a href="Member.scala.html#akka.cluster;Member.status" title="=&gt; akka.cluster.MemberStatus">status</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span>
      <span title="=&gt; Boolean">!</span><a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a>.<span title="(p: akka.cluster.Member =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><span title="akka.cluster.Member">m</span> ⇒ <a href="#akka.cluster.Gossip.readResolve" title="akka.cluster.Gossip.type">Gossip</a>.<a href="#akka.cluster.Gossip.convergenceMemberStatus" title="(elem: akka.cluster.MemberStatus)Boolean">convergenceMemberStatus</a><span class="delimiter">(</span><span title="akka.cluster.Member">m</span>.<a href="Member.scala.html#akka.cluster;Member.status" title="=&gt; akka.cluster.MemberStatus">status</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="=&gt; Boolean">!</span><a href="#akka.cluster;Gossip.seenByNode" title="(node: akka.cluster.UniqueAddress)Boolean">seenByNode</a><span class="delimiter">(</span><span title="akka.cluster.Member">m</span>.<a href="Member.scala.html#akka.cluster;Member.uniqueAddress" title="=&gt; akka.cluster.UniqueAddress">uniqueAddress</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(node: akka.cluster.UniqueAddress)Boolean" id="akka.cluster;Gossip.isLeader">isLeader</a><span class="delimiter">(</span><a title="akka.cluster.UniqueAddress" id="akka.cluster;Gossip.isLeader.node">node</a>: <a href="Member.scala.html#akka.cluster;UniqueAddress" title="akka.cluster.UniqueAddress">UniqueAddress</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#akka.cluster;Gossip.leader" title="=&gt; Option[akka.cluster.UniqueAddress]">leader</a> <span title="(x$1: AnyRef)Boolean">==</span> <span title="(x: akka.cluster.UniqueAddress)Some[akka.cluster.UniqueAddress]">Some</span><span class="delimiter">(</span><a href="#akka.cluster;Gossip.isLeader.node" title="akka.cluster.UniqueAddress">node</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="=&gt; Option[akka.cluster.UniqueAddress]" id="akka.cluster;Gossip.leader">leader</a>: <span title="Option[akka.cluster.UniqueAddress]">Option</span><span class="delimiter">[</span>UniqueAddress<span class="delimiter">]</span> = <a href="#akka.cluster;Gossip.leaderOf" title="(mbrs: scala.collection.immutable.SortedSet[akka.cluster.Member])Option[akka.cluster.UniqueAddress]">leaderOf</a><span class="delimiter">(</span><a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(role: String)Option[akka.cluster.UniqueAddress]" id="akka.cluster;Gossip.roleLeader">roleLeader</a><span class="delimiter">(</span><a title="String" id="akka.cluster;Gossip.roleLeader.role">role</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Option[akka.cluster.UniqueAddress]">Option</span><span class="delimiter">[</span>UniqueAddress<span class="delimiter">]</span> = <a href="#akka.cluster;Gossip.leaderOf" title="(mbrs: scala.collection.immutable.SortedSet[akka.cluster.Member])Option[akka.cluster.UniqueAddress]">leaderOf</a><span class="delimiter">(</span><a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a>.<span title="(p: akka.cluster.Member =&gt; Boolean)scala.collection.immutable.SortedSet[akka.cluster.Member]">filter</span><span class="delimiter">(</span><a href="#akka.cluster;Gossip.roleLeader.$anonfun.x$6" title="akka.cluster.Member">_</a>.<a href="Member.scala.html#akka.cluster;Member.hasRole" title="(role: String)Boolean">hasRole</a><span class="delimiter">(</span><a href="#akka.cluster;Gossip.roleLeader.role" title="String">role</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(mbrs: scala.collection.immutable.SortedSet[akka.cluster.Member])Option[akka.cluster.UniqueAddress]" id="akka.cluster;Gossip.leaderOf">leaderOf</a><span class="delimiter">(</span><a title="scala.collection.immutable.SortedSet[akka.cluster.Member]" id="akka.cluster;Gossip.leaderOf.mbrs">mbrs</a>: immutable.<span title="scala.collection.immutable.SortedSet[akka.cluster.Member]">SortedSet</span><span class="delimiter">[</span>Member<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Option[akka.cluster.UniqueAddress]">Option</span><span class="delimiter">[</span>UniqueAddress<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="scala.collection.immutable.SortedSet[akka.cluster.Member]" id="akka.cluster;Gossip.leaderOf.reachableMembers">reachableMembers</a> =
      <span title="scala.collection.immutable.SortedSet[akka.cluster.Member]" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a>.<a href="#akka.cluster.GossipOverview.apply$default$2" title="=&gt; akka.cluster.Reachability">reachability</a>.<a href="Reachability.scala.html#akka.cluster;Reachability.isAllReachable" title="=&gt; Boolean">isAllReachable</a><span class="delimiter">)</span> <a href="#akka.cluster;Gossip.leaderOf.mbrs" title="scala.collection.immutable.SortedSet[akka.cluster.Member]">mbrs</a>
      <span class="keyword">else</span> <a href="#akka.cluster;Gossip.leaderOf.mbrs" title="scala.collection.immutable.SortedSet[akka.cluster.Member]">mbrs</a>.<span title="(p: akka.cluster.Member =&gt; Boolean)scala.collection.immutable.SortedSet[akka.cluster.Member]">filter</span><span class="delimiter">(</span><a title="akka.cluster.Member" id="akka.cluster;Gossip.leaderOf.reachableMembers.$anonfun.m">m</a> ⇒ <a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a>.<a href="#akka.cluster.GossipOverview.apply$default$2" title="=&gt; akka.cluster.Reachability">reachability</a>.<a href="Reachability.scala.html#akka.cluster;Reachability.isReachable(d151f48ba5)" title="(node: akka.cluster.UniqueAddress)Boolean">isReachable</a><span class="delimiter">(</span><a href="#akka.cluster;Gossip.leaderOf.reachableMembers.$anonfun.m" title="akka.cluster.Member">m</a>.<a href="Member.scala.html#akka.cluster;Member.uniqueAddress" title="=&gt; akka.cluster.UniqueAddress">uniqueAddress</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span title="Option[akka.cluster.UniqueAddress]" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;Gossip.leaderOf.reachableMembers" title="scala.collection.immutable.SortedSet[akka.cluster.Member]">reachableMembers</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span title="None.type">None</span>
    <span class="keyword">else</span> <a href="#akka.cluster;Gossip.leaderOf.reachableMembers" title="scala.collection.immutable.SortedSet[akka.cluster.Member]">reachableMembers</a>.<span title="(p: akka.cluster.Member =&gt; Boolean)Option[akka.cluster.Member]">find</span><span class="delimiter">(</span><a title="akka.cluster.Member" id="akka.cluster;Gossip.leaderOf.$anonfun.m">m</a> ⇒ <a href="#akka.cluster.Gossip.readResolve" title="akka.cluster.Gossip.type">Gossip</a>.<a href="#akka.cluster.Gossip.leaderMemberStatus" title="(elem: akka.cluster.MemberStatus)Boolean">leaderMemberStatus</a><span class="delimiter">(</span><a href="#akka.cluster;Gossip.leaderOf.$anonfun.m" title="akka.cluster.Member">m</a>.<a href="Member.scala.html#akka.cluster;Member.status" title="=&gt; akka.cluster.MemberStatus">status</a><span class="delimiter">)</span><span class="delimiter">)</span>.
      <span title="(alternative: =&gt; Option[akka.cluster.Member])Option[akka.cluster.Member]">orElse</span><span class="delimiter">(</span><span title="(x: akka.cluster.Member)Some[akka.cluster.Member]">Some</span><span class="delimiter">(</span><a href="#akka.cluster;Gossip.leaderOf.reachableMembers" title="scala.collection.immutable.SortedSet[akka.cluster.Member]">reachableMembers</a>.<span title="(implicit cmp: Ordering[akka.cluster.Member])akka.cluster.Member">min</span><span class="delimiter">(</span><a href="Member.scala.html#akka.cluster.Member" title="akka.cluster.Member.type">Member</a>.<a href="Member.scala.html#akka.cluster.Member.leaderStatusOrdering" title="=&gt; Ordering[akka.cluster.Member]">leaderStatusOrdering</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>.<span title="(f: akka.cluster.Member =&gt; akka.cluster.UniqueAddress)Option[akka.cluster.UniqueAddress]">map</span><span class="delimiter">(</span><a href="#akka.cluster;Gossip.leaderOf.$anonfun.x$7" title="akka.cluster.Member">_</a>.<a href="Member.scala.html#akka.cluster;Member.uniqueAddress" title="=&gt; akka.cluster.UniqueAddress">uniqueAddress</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="=&gt; Set[String]" id="akka.cluster;Gossip.allRoles">allRoles</a>: <span title="Set[String]">Set</span><span class="delimiter">[</span>String<span class="delimiter">]</span> = <a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a>.<span title="(f: akka.cluster.Member =&gt; scala.collection.GenTraversableOnce[String])(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.SortedSet[akka.cluster.Member],String,Set[String]])Set[String]">flatMap</span><span title="(implicit ord: Ordering[String])scala.collection.generic.CanBuildFrom[scala.collection.immutable.SortedSet.Coll,String,scala.collection.immutable.SortedSet[String]]" class="delimiter">(</span><a href="#akka.cluster;Gossip.allRoles.$anonfun.x$8" title="akka.cluster.Member">_</a>.<a href="Member.scala.html#akka.cluster;Member.roles" title="=&gt; Set[String]">roles</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.cluster;Gossip.isSingletonCluster">isSingletonCluster</a>: <span title="Boolean">Boolean</span> = <a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a>.<span title="=&gt; Int">size</span> <span title="(x: Int)Boolean">==</span> <span title="Int(1)" class="int">1</span>

  <span class="keyword">def</span> <a title="(node: akka.cluster.UniqueAddress)akka.cluster.Member" id="akka.cluster;Gossip.member">member</a><span class="delimiter">(</span><a title="akka.cluster.UniqueAddress" id="akka.cluster;Gossip.member.node">node</a>: <a href="Member.scala.html#akka.cluster;UniqueAddress" title="akka.cluster.UniqueAddress">UniqueAddress</a><span class="delimiter">)</span>: <a href="Member.scala.html#akka.cluster;Member" title="akka.cluster.Member">Member</a> = <span class="delimiter">{</span>
    <a href="#akka.cluster;Gossip.membersMap" title="=&gt; Map[akka.cluster.UniqueAddress,akka.cluster.Member]">membersMap</a>.<span title="(key: akka.cluster.UniqueAddress, default: =&gt; akka.cluster.Member)akka.cluster.Member">getOrElse</span><span class="delimiter">(</span><a href="#akka.cluster;Gossip.member.node" title="akka.cluster.UniqueAddress">node</a>,
      <a href="Member.scala.html#akka.cluster.Member" title="akka.cluster.Member.type">Member</a>.<a href="Member.scala.html#akka.cluster.Member.removed" title="(node: akka.cluster.UniqueAddress)akka.cluster.Member">removed</a><span class="delimiter">(</span><a href="#akka.cluster;Gossip.member.node" title="akka.cluster.UniqueAddress">node</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="comment">// placeholder for removed member</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(node: akka.cluster.UniqueAddress)Boolean" id="akka.cluster;Gossip.hasMember">hasMember</a><span class="delimiter">(</span><a title="akka.cluster.UniqueAddress" id="akka.cluster;Gossip.hasMember.node">node</a>: <a href="Member.scala.html#akka.cluster;UniqueAddress" title="akka.cluster.UniqueAddress">UniqueAddress</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#akka.cluster;Gossip.membersMap" title="=&gt; Map[akka.cluster.UniqueAddress,akka.cluster.Member]">membersMap</a>.<span title="(key: akka.cluster.UniqueAddress)Boolean">contains</span><span class="delimiter">(</span><a href="#akka.cluster;Gossip.hasMember.node" title="akka.cluster.UniqueAddress">node</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="=&gt; akka.cluster.Member" id="akka.cluster;Gossip.youngestMember">youngestMember</a>: <a href="Member.scala.html#akka.cluster;Member" title="akka.cluster.Member">Member</a> = <span class="delimiter">{</span>
    <span title="(requirement: Boolean, message: =&gt; Any)Unit">require</span><span class="delimiter">(</span><a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a>.<span title="=&gt; Boolean">nonEmpty</span>, <span title="String(&quot;No youngest when no members&quot;)" class="string">&quot;No youngest when no members&quot;</span><span class="delimiter">)</span>
    <a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a>.<span title="(f: akka.cluster.Member =&gt; Int)(implicit cmp: Ordering[Int])akka.cluster.Member">maxBy</span><span title="scala.math.Ordering.Int.type" class="delimiter">(</span><a title="akka.cluster.Member" id="akka.cluster;Gossip.youngestMember.$anonfun.m">m</a> ⇒ <span title="Int" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;Gossip.youngestMember.$anonfun.m" title="akka.cluster.Member">m</a>.<a href="Member.scala.html#akka.cluster;Member.upNumber" title="=&gt; Int">upNumber</a> <span title="(x: Int)Boolean">==</span> Int.<span title="Int(2147483647)">MaxValue</span><span class="delimiter">)</span> <span title="Int(0)" class="int">0</span> <span class="keyword">else</span> <a href="#akka.cluster;Gossip.youngestMember.$anonfun.m" title="akka.cluster.Member">m</a>.<a href="Member.scala.html#akka.cluster;Member.upNumber" title="=&gt; Int">upNumber</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="akka.cluster;Gossip.toString">toString</a> =
    <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Gossip(members = [&quot;)">Gossip(members = [$</span><span class="delimiter">{</span><a href="#akka.cluster;Gossip.copy$default$1" title="=&gt; scala.collection.immutable.SortedSet[akka.cluster.Member]">members</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;], overview = &quot;)">], overview = $</span><span class="delimiter">{</span><a href="#akka.cluster;Gossip.copy$default$2" title="=&gt; akka.cluster.GossipOverview">overview</a><span class="delimiter">}</span><span title="String(&quot;, version = &quot;)">, version = $</span><span class="delimiter">{</span><a href="#akka.cluster;Gossip.copy$default$3" title="=&gt; akka.cluster.VectorClock">version</a><span class="delimiter">}</span><span title="String(&quot;)&quot;)" class="string">)&quot;</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * INTERNAL API
 * Represents the overview of the cluster, holds the cluster convergence table and set with unreachable nodes.
 */</span>
@SerialVersionUID<span class="delimiter">(</span><span class="long">1L</span><span class="delimiter">)</span>
<span class="keyword">private</span><span class="delimiter">[</span>cluster<span class="delimiter">]</span> <span class="keyword">case class</span> <a title="class GossipOverview extends AnyRef with Product with Serializable" id="akka.cluster.GossipOverview.readResolve">GossipOverview</a><a href="#akka.cluster.GossipOverview.readResolve" title="Product" class="delimiter">(</a>
  <a title="Set[akka.cluster.UniqueAddress]" id="akka.cluster.GossipOverview.apply$default$1">seen</a>: <span title="Set[akka.cluster.UniqueAddress]">Set</span><span class="delimiter">[</span>UniqueAddress<span class="delimiter">]</span> = <span title="=&gt; scala.collection.immutable.Set.type">Set</span>.<span title="scala.collection.immutable.Set[akka.cluster.UniqueAddress]">empty</span>,
  <a title="akka.cluster.Reachability" id="akka.cluster.GossipOverview.apply$default$2">reachability</a>: <a href="Reachability.scala.html#akka.cluster;Reachability" title="akka.cluster.Reachability">Reachability</a> = <a href="Reachability.scala.html#akka.cluster.Reachability" title="akka.cluster.Reachability.type">Reachability</a>.<a href="Reachability.scala.html#akka.cluster.Reachability.empty" title="=&gt; akka.cluster.Reachability">empty</a><span class="delimiter">)</span> <span class="delimiter">{</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="akka.cluster;GossipOverview.toString">toString</a> =
    <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;GossipOverview(reachability = [&quot;)">GossipOverview(reachability = [$</span><a href="#akka.cluster.GossipOverview.apply$default$2" title="=&gt; akka.cluster.Reachability">reachability</a><span title="String(&quot;], seen = [&quot;)">], seen = [$</span><span class="delimiter">{</span><a href="#akka.cluster.GossipOverview.apply$default$1" title="=&gt; Set[akka.cluster.UniqueAddress]">seen</a>.<span title="(sep: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span><span class="delimiter">)</span><span class="delimiter">}</span><span title="String(&quot;])&quot;)" class="string">])&quot;</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="akka.cluster.GossipEnvelope.type" id="akka.cluster.GossipEnvelope.readResolve">GossipEnvelope</a> <a href="#akka.cluster.GossipEnvelope.readResolve" title="akka.cluster.GossipEnvelope.type" class="delimiter">{</a>
  <span class="keyword">def</span> <a title="(from: akka.cluster.UniqueAddress, to: akka.cluster.UniqueAddress, gossip: akka.cluster.Gossip)akka.cluster.GossipEnvelope" id="akka.cluster.GossipEnvelope.apply(86e4d87bb5)">apply</a><span class="delimiter">(</span><a title="akka.cluster.UniqueAddress" id="akka.cluster.GossipEnvelope.apply(86e4d87bb5).from">from</a>: <a href="Member.scala.html#akka.cluster;UniqueAddress" title="akka.cluster.UniqueAddress">UniqueAddress</a>, <a title="akka.cluster.UniqueAddress" id="akka.cluster.GossipEnvelope.apply(86e4d87bb5).to">to</a>: <a href="Member.scala.html#akka.cluster;UniqueAddress" title="akka.cluster.UniqueAddress">UniqueAddress</a>, <a title="akka.cluster.Gossip" id="akka.cluster.GossipEnvelope.apply(86e4d87bb5).gossip">gossip</a>: <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip">Gossip</a><span class="delimiter">)</span>: <a href="#akka.cluster;GossipEnvelope" title="akka.cluster.GossipEnvelope">GossipEnvelope</a> =
    <span title="akka.cluster.GossipEnvelope" class="keyword">new</span> <a href="#akka.cluster;GossipEnvelope" title="akka.cluster.GossipEnvelope">GossipEnvelope</a><span class="delimiter">(</span><a href="#akka.cluster.GossipEnvelope.apply(86e4d87bb5).from" title="akka.cluster.UniqueAddress">from</a>, <a href="#akka.cluster.GossipEnvelope.apply(86e4d87bb5).to" title="akka.cluster.UniqueAddress">to</a>, <a href="#akka.cluster.GossipEnvelope.apply(86e4d87bb5).gossip" title="akka.cluster.Gossip">gossip</a>, <span title="Null(null)" class="keyword">null</span>, <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(from: akka.cluster.UniqueAddress, to: akka.cluster.UniqueAddress, serDeadline: scala.concurrent.duration.Deadline, ser: () =&gt; akka.cluster.Gossip)akka.cluster.GossipEnvelope" id="akka.cluster.GossipEnvelope.apply(27602cb266)">apply</a><span class="delimiter">(</span><a title="akka.cluster.UniqueAddress" id="akka.cluster.GossipEnvelope.apply(27602cb266).from">from</a>: <a href="Member.scala.html#akka.cluster;UniqueAddress" title="akka.cluster.UniqueAddress">UniqueAddress</a>, <a title="akka.cluster.UniqueAddress" id="akka.cluster.GossipEnvelope.apply(27602cb266).to">to</a>: <a href="Member.scala.html#akka.cluster;UniqueAddress" title="akka.cluster.UniqueAddress">UniqueAddress</a>, <a title="scala.concurrent.duration.Deadline" id="akka.cluster.GossipEnvelope.apply(27602cb266).serDeadline">serDeadline</a>: <span title="scala.concurrent.duration.Deadline">Deadline</span>, <a title="() =&gt; akka.cluster.Gossip" id="akka.cluster.GossipEnvelope.apply(27602cb266).ser">ser</a>: <span class="delimiter">(</span><span class="delimiter">)</span> ⇒ Gossip<span class="delimiter">)</span>: <a href="#akka.cluster;GossipEnvelope" title="akka.cluster.GossipEnvelope">GossipEnvelope</a> =
    <span title="akka.cluster.GossipEnvelope" class="keyword">new</span> <a href="#akka.cluster;GossipEnvelope" title="akka.cluster.GossipEnvelope">GossipEnvelope</a><span class="delimiter">(</span><a href="#akka.cluster.GossipEnvelope.apply(27602cb266).from" title="akka.cluster.UniqueAddress">from</a>, <a href="#akka.cluster.GossipEnvelope.apply(27602cb266).to" title="akka.cluster.UniqueAddress">to</a>, <span title="Null(null)" class="keyword">null</span>, <a href="#akka.cluster.GossipEnvelope.apply(27602cb266).serDeadline" title="scala.concurrent.duration.Deadline">serDeadline</a>, <a href="#akka.cluster.GossipEnvelope.apply(27602cb266).ser" title="() =&gt; akka.cluster.Gossip">ser</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * INTERNAL API
 * Envelope adding a sender and receiver address to the gossip.
 * The reason for including the receiver address is to be able to
 * ignore messages that were intended for a previous incarnation of
 * the node with same host:port. The `uid` in the `UniqueAddress` is
 * different in that case.
 */</span>
@SerialVersionUID<span class="delimiter">(</span><span class="long">2L</span><span class="delimiter">)</span>
<span class="keyword">private</span><span class="delimiter">[</span>cluster<span class="delimiter">]</span> <span class="keyword">class</span> <a title="class GossipEnvelope extends AnyRef with akka.cluster.ClusterMessage" id="akka.cluster;GossipEnvelope">GossipEnvelope</a> <a href="#akka.cluster;GossipEnvelope" title="akka.cluster.GossipEnvelope" class="keyword">private</a> <span class="delimiter">(</span>
  <span class="keyword">val</span> <a title="akka.cluster.UniqueAddress" id="akka.cluster;GossipEnvelope.from">from</a>: <a href="Member.scala.html#akka.cluster;UniqueAddress" title="akka.cluster.UniqueAddress">UniqueAddress</a>,
  <span class="keyword">val</span> <a title="akka.cluster.UniqueAddress" id="akka.cluster;GossipEnvelope.to">to</a>: <a href="Member.scala.html#akka.cluster;UniqueAddress" title="akka.cluster.UniqueAddress">UniqueAddress</a>,
  @volatile <span class="keyword">var</span> <a title="akka.cluster.Gossip" id="akka.cluster;GossipEnvelope.g">g</a>: <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip">Gossip</a>,
  <a title="scala.concurrent.duration.Deadline" id="akka.cluster;GossipEnvelope.serDeadline">serDeadline</a>: <span title="scala.concurrent.duration.Deadline">Deadline</span>,
  @transient @volatile <span class="keyword">var</span> <a title="() =&gt; akka.cluster.Gossip" id="akka.cluster;GossipEnvelope.ser">ser</a>: <span class="delimiter">(</span><span class="delimiter">)</span> ⇒ Gossip<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="ClusterDaemon.scala.html#akka.cluster;ClusterMessage" title="akka.cluster.ClusterMessage">ClusterMessage</a> <span class="delimiter">{</span>

  <span class="keyword">def</span> <a title="=&gt; akka.cluster.Gossip" id="akka.cluster;GossipEnvelope.gossip">gossip</a>: <a href="#akka.cluster;Gossip.equals" title="akka.cluster.Gossip">Gossip</a> = <span class="delimiter">{</span>
    <a href="#akka.cluster;GossipEnvelope.deserialize" title="()Unit">deserialize</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#akka.cluster;GossipEnvelope.g" title="=&gt; akka.cluster.Gossip">g</a>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Unit" id="akka.cluster;GossipEnvelope.deserialize">deserialize</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#akka.cluster;GossipEnvelope.g" title="=&gt; akka.cluster.Gossip">g</a> <span title="(x$1: AnyRef)Boolean">eq</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#akka.cluster;GossipEnvelope.ser" title="=&gt; () =&gt; akka.cluster.Gossip">ser</a> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;GossipEnvelope.serDeadline" title="scala.concurrent.duration.Deadline">serDeadline</a>.<span title="()Boolean">hasTimeLeft</span><span class="delimiter">)</span>
        <a href="#akka.cluster;GossipEnvelope.g" title="(x$1: akka.cluster.Gossip)Unit">g</a> = <a href="#akka.cluster;GossipEnvelope.ser" title="()akka.cluster.Gossip">ser</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">else</span>
        <a href="#akka.cluster;GossipEnvelope.g" title="(x$1: akka.cluster.Gossip)Unit">g</a> = <a href="#akka.cluster.Gossip.readResolve" title="akka.cluster.Gossip.type">Gossip</a>.<a href="#akka.cluster.Gossip.empty" title="=&gt; akka.cluster.Gossip">empty</a>
      <a href="#akka.cluster;GossipEnvelope.ser" title="(x$1: () =&gt; akka.cluster.Gossip)Unit">ser</a> = <span title="Null(null)" class="keyword">null</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  @throws<span class="delimiter">(</span>classOf<span class="delimiter">[</span>java.io.ObjectStreamException<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="()AnyRef" id="akka.cluster;GossipEnvelope.writeReplace">writeReplace</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="AnyRef">AnyRef</span> = <span class="delimiter">{</span>
    <a href="#akka.cluster;GossipEnvelope.deserialize" title="()Unit">deserialize</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <a href="#akka.cluster;GossipEnvelope" title="akka.cluster.GossipEnvelope" class="keyword">this</a>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * INTERNAL API
 * When there are no known changes to the node ring a `GossipStatus`
 * initiates a gossip chat between two members. If the receiver has a newer
 * version it replies with a `GossipEnvelope`. If receiver has older version
 * it replies with its `GossipStatus`. Same versions ends the chat immediately.
 */</span>
@SerialVersionUID<span class="delimiter">(</span><span class="long">1L</span><span class="delimiter">)</span>
<span class="keyword">private</span><span class="delimiter">[</span>cluster<span class="delimiter">]</span> <span class="keyword">case class</span> <a title="class GossipStatus extends AnyRef with akka.cluster.ClusterMessage with Product with Serializable" id="akka.cluster.GossipStatus.readResolve">GossipStatus</a><a href="#akka.cluster.GossipStatus.readResolve" title="Product" class="delimiter">(</a><a title="akka.cluster.UniqueAddress" id="akka.cluster;GossipStatus.from">from</a>: <a href="Member.scala.html#akka.cluster;UniqueAddress" title="akka.cluster.UniqueAddress">UniqueAddress</a>, <a title="akka.cluster.VectorClock" id="akka.cluster;GossipStatus.version">version</a>: <a href="VectorClock.scala.html#akka.cluster;VectorClock" title="akka.cluster.VectorClock">VectorClock</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="ClusterDaemon.scala.html#akka.cluster;ClusterMessage" title="akka.cluster.ClusterMessage">ClusterMessage</a>

        </pre>
    </body>
</html>
