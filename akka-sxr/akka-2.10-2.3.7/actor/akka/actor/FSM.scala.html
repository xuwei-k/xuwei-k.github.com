<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>actor/akka/actor/FSM.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Copyright (C) 2009-2014 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
<span class="keyword">package</span> akka.actor

<span class="keyword">import</span> <span title="language.type">language</span>.implicitConversions
<span class="keyword">import</span> scala.concurrent.duration.Duration
<span class="keyword">import</span> scala.collection.mutable
<span class="keyword">import</span> akka.routing.<span class="delimiter">{</span> Deafen, Listen, Listeners <span class="delimiter">}</span>
<span class="keyword">import</span> scala.concurrent.duration.FiniteDuration

<span class="keyword">object</span> <a title="akka.actor.FSM.type" id="akka.actor.FSM">FSM</a> <a href="#akka.actor.FSM" title="akka.actor.FSM.type" class="delimiter">{</a>

  <span class="comment">/**
   * A partial function value which does not match anything and can be used to
   * “reset” `whenUnhandled` and `onTermination` handlers.
   *
   * {{{
   * onTermination(FSM.NullFunction)
   * }}}
   */</span>
  <span class="keyword">object</span> <a title="akka.actor.FSM.NullFunction.type" id="akka.actor.FSM.NullFunction">NullFunction</a> <a href="#akka.actor.FSM.NullFunction" title="akka.actor.FSM.NullFunction.type" class="keyword">extends</a> <span title="PartialFunction[Any,Nothing]">PartialFunction</span><span class="delimiter">[</span>Any, Nothing<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(o: Any)Boolean" id="akka.actor.FSM.NullFunction.isDefinedAt">isDefinedAt</a><span class="delimiter">(</span><a title="Any" id="akka.actor.FSM.NullFunction.isDefinedAt.o">o</a>: <span title="Any">Any</span><span class="delimiter">)</span> = <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">def</span> <a title="(o: Any)Nothing" id="akka.actor.FSM.NullFunction.apply">apply</a><span class="delimiter">(</span><a title="Any" id="akka.actor.FSM.NullFunction.apply.o">o</a>: <span title="Any">Any</span><span class="delimiter">)</span> = sys.<span title="(message: String)Nothing">error</span><span class="delimiter">(</span><span title="String(&quot;undefined&quot;)" class="string">&quot;undefined&quot;</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Message type which is sent directly to the subscribed actor in
   * [[akka.actor.FSM.SubscribeTransitionCallBack]] before sending any
   * [[akka.actor.FSM.Transition]] messages.
   */</span>
  <span class="keyword">case class</span> <a href="#akka.actor.FSM;CurrentState.productElement.x$1" title="class CurrentState[S] extends AnyRef with Product with Serializable" id="akka.actor.FSM.CurrentState.readResolve">CurrentState</a><span class="delimiter">[</span><a title="" id="akka.actor.FSM;CurrentState;S">S</a><span class="delimiter">]</span><a href="#akka.actor.FSM.CurrentState.readResolve" title="Product" class="delimiter">(</a><a title="akka.actor.ActorRef" id="akka.actor.FSM;CurrentState.fsmRef">fsmRef</a>: <a href="ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a>, <a title="S" id="akka.actor.FSM;CurrentState.state">state</a>: <a href="#akka.actor.FSM;CurrentState;S" title="S">S</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Message type which is used to communicate transitions between states to
   * all subscribed listeners (use [[akka.actor.FSM.SubscribeTransitionCallBack]]).
   */</span>
  <span class="keyword">case class</span> <a href="#akka.actor.FSM;Transition.productElement.x$1" title="class Transition[S] extends AnyRef with Product with Serializable" id="akka.actor.FSM.Transition.readResolve">Transition</a><span class="delimiter">[</span><a title="" id="akka.actor.FSM;Transition;S">S</a><span class="delimiter">]</span><a href="#akka.actor.FSM.Transition.readResolve" title="Product" class="delimiter">(</a><a title="akka.actor.ActorRef" id="akka.actor.FSM;Transition.fsmRef">fsmRef</a>: <a href="ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a>, <a title="S" id="akka.actor.FSM;Transition.from">from</a>: <a href="#akka.actor.FSM;Transition;S" title="S">S</a>, <a title="S" id="akka.actor.FSM;Transition.to">to</a>: <a href="#akka.actor.FSM;Transition;S" title="S">S</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Send this to an [[akka.actor.FSM]] to request first the [[FSM.CurrentState]]
   * and then a series of [[FSM.Transition]] updates. Cancel the subscription
   * using [[FSM.UnsubscribeTransitionCallBack]].
   */</span>
  <span class="keyword">case class</span> <a title="class SubscribeTransitionCallBack extends AnyRef with Product with Serializable" id="akka.actor.FSM.SubscribeTransitionCallBack.readResolve">SubscribeTransitionCallBack</a><a href="#akka.actor.FSM.SubscribeTransitionCallBack.readResolve" title="Product" class="delimiter">(</a><a title="akka.actor.ActorRef" id="akka.actor.FSM;SubscribeTransitionCallBack.actorRef">actorRef</a>: <a href="ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Unsubscribe from [[akka.actor.FSM.Transition]] notifications which was
   * effected by sending the corresponding [[akka.actor.FSM.SubscribeTransitionCallBack]].
   */</span>
  <span class="keyword">case class</span> <a title="class UnsubscribeTransitionCallBack extends AnyRef with Product with Serializable" id="akka.actor.FSM.UnsubscribeTransitionCallBack.readResolve">UnsubscribeTransitionCallBack</a><a href="#akka.actor.FSM.UnsubscribeTransitionCallBack.readResolve" title="Product" class="delimiter">(</a><a title="akka.actor.ActorRef" id="akka.actor.FSM;UnsubscribeTransitionCallBack.actorRef">actorRef</a>: <a href="ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Reason why this [[akka.actor.FSM]] is shutting down.
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Reason extends AnyRef" id="akka.actor.FSM;Reason">Reason</a>

  <span class="comment">/**
   * Default reason if calling `stop()`.
   */</span>
  <span class="keyword">case object</span> <a href="#akka.actor.FSM.Normal.productElement.x$1" title="akka.actor.FSM.Normal.type" id="akka.actor.FSM.Normal.readResolve">Normal</a> <span title="Product" class="keyword">extends</span> <a href="#akka.actor.FSM;Reason" title="akka.actor.FSM.Reason">Reason</a>

  <span class="comment">/**
   * Reason given when someone was calling `system.stop(fsm)` from outside;
   * also applies to `Stop` supervision directive.
   */</span>
  <span class="keyword">case object</span> <a href="#akka.actor.FSM.Shutdown.productElement.x$1" title="akka.actor.FSM.Shutdown.type" id="akka.actor.FSM.Shutdown.readResolve">Shutdown</a> <span title="Product" class="keyword">extends</span> <a href="#akka.actor.FSM;Reason" title="akka.actor.FSM.Reason">Reason</a>

  <span class="comment">/**
   * Signifies that the [[akka.actor.FSM]] is shutting itself down because of
   * an error, e.g. if the state to transition into does not exist. You can use
   * this to communicate a more precise cause to the [[akka.actor.FSM.onTermination]] block.
   */</span>
  <span class="keyword">case class</span> <a title="class Failure extends AnyRef with akka.actor.FSM.Reason with Product with Serializable" id="akka.actor.FSM.Failure.readResolve">Failure</a><a href="#akka.actor.FSM.Failure.readResolve" title="Product" class="delimiter">(</a><a title="Any" id="akka.actor.FSM;Failure.cause">cause</a>: <span title="Any">Any</span><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#akka.actor.FSM;Reason" title="akka.actor.FSM.Reason">Reason</a>

  <span class="comment">/**
   * This case object is received in case of a state timeout.
   */</span>
  <span class="keyword">case object</span> <a href="#akka.actor.FSM.StateTimeout.productElement.x$1" title="akka.actor.FSM.StateTimeout.type" id="akka.actor.FSM.StateTimeout.readResolve">StateTimeout</a>

  <span class="comment">/**
   * INTERNAL API
   */</span>
  <span class="keyword">private</span> <span class="keyword">case class</span> <a title="class TimeoutMarker extends AnyRef with Product with Serializable" id="akka.actor.FSM.TimeoutMarker.readResolve">TimeoutMarker</a><a href="#akka.actor.FSM.TimeoutMarker.readResolve" title="Product" class="delimiter">(</a><a title="Long" id="akka.actor.FSM;TimeoutMarker.generation">generation</a>: <span title="Long">Long</span><span class="delimiter">)</span>

  <span class="comment">/**
   * INTERNAL API
   */</span>
  <span class="comment">// FIXME: what about the cancellable?</span>
  <span class="keyword">private</span><span class="delimiter">[</span>akka<span class="delimiter">]</span> <span class="keyword">case class</span> <a title="class Timer extends AnyRef with akka.actor.NoSerializationVerificationNeeded with Product with Serializable" id="akka.actor.FSM.Timer.readResolve">Timer</a><a href="#akka.actor.FSM.Timer.readResolve" title="Product" class="delimiter">(</a><a title="String" id="akka.actor.FSM;Timer.name">name</a>: <span title="String">String</span>, <a title="Any" id="akka.actor.FSM;Timer.msg">msg</a>: <span title="Any">Any</span>, <a title="Boolean" id="akka.actor.FSM;Timer.repeat">repeat</a>: <span title="Boolean">Boolean</span>, <a title="Int" id="akka.actor.FSM;Timer.generation">generation</a>: <span title="Int">Int</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="akka.actor.ActorContext" id="akka.actor.FSM;Timer.context">context</a>: <a href="ActorCell.scala.html#akka.actor;ActorContext" title="akka.actor.ActorContext">ActorContext</a><span class="delimiter">)</span>
    <span class="keyword">extends</span> <a href="Actor.scala.html#akka.actor;NoSerializationVerificationNeeded" title="akka.actor.NoSerializationVerificationNeeded">NoSerializationVerificationNeeded</a> <span class="delimiter">{</span>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Option[akka.actor.Cancellable]" id="akka.actor.FSM;Timer.ref_=">ref</a>: <span title="Option[akka.actor.Cancellable]">Option</span><span class="delimiter">[</span>Cancellable<span class="delimiter">]</span> = _
    <span class="keyword">private</span> <span class="keyword">val</span> <a title="akka.actor.Scheduler" id="akka.actor.FSM;Timer.scheduler">scheduler</a> = <a href="#akka.actor.FSM;Timer.context" title="akka.actor.ActorContext">context</a>.<a href="ActorCell.scala.html#akka.actor;ActorContext.system" title="=&gt; akka.actor.ActorSystem">system</a>.<a href="ActorSystem.scala.html#akka.actor;ActorSystem.scheduler" title="=&gt; akka.actor.Scheduler">scheduler</a>
    <span class="keyword">private</span> <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scala.concurrent.ExecutionContextExecutor" id="akka.actor.FSM;Timer.executionContext">executionContext</a> = <a href="#akka.actor.FSM;Timer.context" title="akka.actor.ActorContext">context</a>.<a href="ActorCell.scala.html#akka.actor;ActorContext.dispatcher" title="=&gt; scala.concurrent.ExecutionContextExecutor">dispatcher</a>

    <span class="keyword">def</span> <a title="(actor: akka.actor.ActorRef, timeout: scala.concurrent.duration.FiniteDuration)Unit" id="akka.actor.FSM;Timer.schedule">schedule</a><span class="delimiter">(</span><a title="akka.actor.ActorRef" id="akka.actor.FSM;Timer.schedule.actor">actor</a>: <a href="ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.actor.FSM;Timer.schedule.timeout">timeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
      <a href="#akka.actor.FSM;Timer.ref_=" title="(x$1: Option[akka.actor.Cancellable])Unit">ref</a> = <span title="(x: akka.actor.Cancellable)Some[akka.actor.Cancellable]">Some</span><span class="delimiter">(</span>
        <span title="akka.actor.Cancellable" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor.FSM;Timer.repeat" title="=&gt; Boolean">repeat</a><span class="delimiter">)</span> <a href="#akka.actor.FSM;Timer.scheduler" title="=&gt; akka.actor.Scheduler">scheduler</a>.<a href="Scheduler.scala.html#akka.actor;Scheduler.schedule(abf8206fc2)" title="(initialDelay: scala.concurrent.duration.FiniteDuration, interval: scala.concurrent.duration.FiniteDuration, receiver: akka.actor.ActorRef, message: Any)(implicit executor: scala.concurrent.ExecutionContext, implicit sender: akka.actor.ActorRef)akka.actor.Cancellable">schedule</a><a href="#akka.actor.FSM;Timer.executionContext" title="scala.concurrent.ExecutionContextExecutor" id="akka.actor.FSM;Timer.schedule.x$8" class="delimiter">(</a><a href="#akka.actor.FSM;Timer.schedule.timeout" title="scala.concurrent.duration.FiniteDuration" id="akka.actor.FSM;Timer.schedule.x$3">timeout</a>, <a href="#akka.actor.FSM;Timer.schedule.timeout" title="scala.concurrent.duration.FiniteDuration" id="akka.actor.FSM;Timer.schedule.x$4">timeout</a>, <a href="#akka.actor.FSM;Timer.schedule.actor" title="akka.actor.ActorRef" id="akka.actor.FSM;Timer.schedule.x$5">actor</a>, <a href="#akka.actor.FSM.Timer.readResolve" title="akka.actor.FSM.Timer" id="akka.actor.FSM;Timer.schedule.x$6" class="keyword">this</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <a href="#akka.actor.FSM;Timer.scheduler" title="=&gt; akka.actor.Scheduler">scheduler</a>.<a href="Scheduler.scala.html#akka.actor;Scheduler.scheduleOnce(a2d55b51db)" title="(delay: scala.concurrent.duration.FiniteDuration, receiver: akka.actor.ActorRef, message: Any)(implicit executor: scala.concurrent.ExecutionContext, implicit sender: akka.actor.ActorRef)akka.actor.Cancellable">scheduleOnce</a><a href="#akka.actor.FSM;Timer.executionContext" title="scala.concurrent.ExecutionContextExecutor" id="akka.actor.FSM;Timer.schedule.x$13" class="delimiter">(</a><a href="#akka.actor.FSM;Timer.schedule.timeout" title="scala.concurrent.duration.FiniteDuration" id="akka.actor.FSM;Timer.schedule.x$9">timeout</a>, <a href="#akka.actor.FSM;Timer.schedule.actor" title="akka.actor.ActorRef" id="akka.actor.FSM;Timer.schedule.x$10">actor</a>, <a href="#akka.actor.FSM.Timer.readResolve" title="akka.actor.FSM.Timer" id="akka.actor.FSM;Timer.schedule.x$11" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="()Unit" id="akka.actor.FSM;Timer.cancel">cancel</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor.FSM;Timer.ref_=" title="=&gt; Option[akka.actor.Cancellable]">ref</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#akka.actor.FSM;Timer.ref_=" title="=&gt; Option[akka.actor.Cancellable]">ref</a>.<span title="=&gt; akka.actor.Cancellable">get</span>.<a href="Scheduler.scala.html#akka.actor;Cancellable.cancel" title="()Boolean">cancel</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#akka.actor.FSM;Timer.ref_=" title="(x$1: Option[akka.actor.Cancellable])Unit">ref</a> = <span title="None.type">None</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * This extractor is just convenience for matching a (S, S) pair, including a
   * reminder what the new state is.
   */</span>
  <span class="keyword">object</span> <a title="akka.actor.FSM.-&gt;.type" id="akka.actor.FSM.->">-&gt;</a> <a href="#akka.actor.FSM.->" title="akka.actor.FSM.-&gt;.type" class="delimiter">{</a>
    <span class="keyword">def</span> <a title="[S](in: (S, S))Some[(S, S)]" id="akka.actor.FSM.->.unapply">unapply</a><span class="delimiter">[</span><a title="" id="akka.actor.FSM.->.unapply;S">S</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="(S, S)" id="akka.actor.FSM.->.unapply.in">in</a>: <span title="(S, S)" class="delimiter">(</span>S, S<span class="delimiter">)</span><span class="delimiter">)</span> = <span title="(x: (S, S))Some[(S, S)]">Some</span><span class="delimiter">(</span><a href="#akka.actor.FSM.->.unapply.in" title="(S, S)">in</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Log Entry of the [[akka.actor.LoggingFSM]], can be obtained by calling `getLog`.
   */</span>
  <span class="keyword">case class</span> <a href="#akka.actor.FSM;LogEntry.productElement.x$1" title="class LogEntry[S, D] extends AnyRef with Product with Serializable" id="akka.actor.FSM.LogEntry.readResolve">LogEntry</a><span class="delimiter">[</span><a title="" id="akka.actor.FSM;LogEntry;S">S</a>, <a title="" id="akka.actor.FSM;LogEntry;D">D</a><span class="delimiter">]</span><a href="#akka.actor.FSM.LogEntry.readResolve" title="Product" class="delimiter">(</a><a title="S" id="akka.actor.FSM;LogEntry.stateName">stateName</a>: <a href="#akka.actor.FSM;LogEntry;S" title="S">S</a>, <a title="D" id="akka.actor.FSM;LogEntry.stateData">stateData</a>: <a href="#akka.actor.FSM;LogEntry;D" title="D">D</a>, <a title="Any" id="akka.actor.FSM;LogEntry.event">event</a>: <span title="Any">Any</span><span class="delimiter">)</span>

  <span class="comment">/**
   * This captures all of the managed state of the [[akka.actor.FSM]]: the state
   * name, the state data, possibly custom timeout, stop reason and replies
   * accumulated while processing the last message.
   */</span>
  <span class="keyword">case class</span> <a href="#akka.actor.FSM;State.productElement.x$1" title="class State[S, D] extends AnyRef with Product with Serializable" id="akka.actor.FSM.State.readResolve">State</a><span class="delimiter">[</span><a title="" id="akka.actor.FSM.State.apply$default$5;S">S</a>, <a title="" id="akka.actor.FSM.State.apply$default$5;D">D</a><span class="delimiter">]</span><a href="#akka.actor.FSM.State.readResolve" title="Product" class="delimiter">(</a><a title="S" id="akka.actor.FSM;State.stateName">stateName</a>: <a href="#akka.actor.FSM.State.apply$default$5;S" title="S">S</a>, <a title="D" id="akka.actor.FSM;State.stateData">stateData</a>: <a href="#akka.actor.FSM.State.apply$default$5;D" title="D">D</a>, <a title="Option[scala.concurrent.duration.FiniteDuration]" id="akka.actor.FSM.State.apply$default$3">timeout</a>: <span title="Option[scala.concurrent.duration.FiniteDuration]">Option</span><span class="delimiter">[</span>FiniteDuration<span class="delimiter">]</span> = <span title="None.type">None</span>, <a title="Option[akka.actor.FSM.Reason]" id="akka.actor.FSM.State.apply$default$4">stopReason</a>: <span title="Option[akka.actor.FSM.Reason]">Option</span><span class="delimiter">[</span>Reason<span class="delimiter">]</span> = <span title="None.type">None</span>, <a title="List[Any]" id="akka.actor.FSM.State.apply$default$5">replies</a>: <span title="List[Any]">List</span><span class="delimiter">[</span>Any<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span><span class="delimiter">)</span> <span class="delimiter">{</span>

    <span class="comment">/**
     * Modify state transition descriptor to include a state timeout for the
     * next state. This timeout overrides any default timeout set for the next
     * state.
     *
     * Use Duration.Inf to deactivate an existing timeout.
     */</span>
    <span class="keyword">def</span> <a title="(timeout: scala.concurrent.duration.Duration)akka.actor.FSM.State[S,D]" id="akka.actor.FSM;State.forMax">forMax</a><span class="delimiter">(</span><a title="scala.concurrent.duration.Duration" id="akka.actor.FSM;State.forMax.timeout">timeout</a>: <span title="scala.concurrent.duration.Duration">Duration</span><span class="delimiter">)</span>: <a href="#akka.actor.FSM.State.readResolve" title="akka.actor.FSM.State[S,D]">State</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> = <a href="#akka.actor.FSM;State.forMax.timeout" title="scala.concurrent.duration.Duration">timeout</a> <span title="akka.actor.FSM.State[S,D]" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <a title="scala.concurrent.duration.FiniteDuration" id="akka.actor.FSM;State.forMax.f">f</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span> ⇒ <a href="#akka.actor.FSM;State.stateName" title="S" id="akka.actor.FSM;State.forMax.x$18">copy</a><span class="delimiter">(</span>timeout = <span title="(x: scala.concurrent.duration.FiniteDuration)Some[scala.concurrent.duration.FiniteDuration]">Some</span><a title="Some[scala.concurrent.duration.FiniteDuration]" id="akka.actor.FSM;State.forMax.x$14" class="delimiter">(</a><a href="#akka.actor.FSM;State.forMax.f" title="scala.concurrent.duration.FiniteDuration">f</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">case</span> _                 ⇒ <a href="#akka.actor.FSM;State.stateName" title="S" id="akka.actor.FSM;State.forMax.x$23">copy</a><span class="delimiter">(</span>timeout = <a title="None.type" id="akka.actor.FSM;State.forMax.x$19">None</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Send reply to sender of the current message, if available.
     *
     * @return this state transition descriptor
     */</span>
    <span class="keyword">def</span> <a title="(replyValue: Any)akka.actor.FSM.State[S,D]" id="akka.actor.FSM;State.replying">replying</a><span class="delimiter">(</span><a title="Any" id="akka.actor.FSM;State.replying.replyValue">replyValue</a>: <span title="Any">Any</span><span class="delimiter">)</span>: <a href="#akka.actor.FSM.State.readResolve" title="akka.actor.FSM.State[S,D]">State</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#akka.actor.FSM;State.stateName" title="S" id="akka.actor.FSM;State.replying.x$28">copy</a><span class="delimiter">(</span>replies = <a href="#akka.actor.FSM;State.replying.replyValue" title="Any">replyValue</a> <a href="#akka.actor.FSM;State.replying.x$24.x$1" title="List[Any]" id="akka.actor.FSM;State.replying.x$24">::</a> <a href="#akka.actor.FSM.State.apply$default$5" title="=&gt; List[Any]">replies</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * Modify state transition descriptor with new state data. The data will be
     * set when transitioning to the new state.
     */</span>
    <span class="keyword">def</span> <a title="(nextStateDate: D)akka.actor.FSM.State[S,D]" id="akka.actor.FSM;State.using">using</a><span class="delimiter">(</span><a title="D" id="akka.actor.FSM;State.using.nextStateDate">nextStateDate</a>: <a href="#akka.actor.FSM.State.apply$default$5;D" title="D">D</a><span class="delimiter">)</span>: <a href="#akka.actor.FSM.State.readResolve" title="akka.actor.FSM.State[S,D]">State</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#akka.actor.FSM;State.stateName" title="S" id="akka.actor.FSM;State.using.x$33">copy</a><span class="delimiter">(</span>stateData = <a href="#akka.actor.FSM;State.using.nextStateDate" title="D" id="akka.actor.FSM;State.using.x$29">nextStateDate</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="comment">/**
     * INTERNAL API.
     */</span>
    <span class="keyword">private</span><span class="delimiter">[</span>akka<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(reason: akka.actor.FSM.Reason)akka.actor.FSM.State[S,D]" id="akka.actor.FSM;State.withStopReason">withStopReason</a><span class="delimiter">(</span><a title="akka.actor.FSM.Reason" id="akka.actor.FSM;State.withStopReason.reason">reason</a>: <a href="#akka.actor.FSM;Reason" title="akka.actor.FSM.Reason">Reason</a><span class="delimiter">)</span>: <a href="#akka.actor.FSM.State.readResolve" title="akka.actor.FSM.State[S,D]">State</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> = <span class="delimiter">{</span>
      <a href="#akka.actor.FSM;State.stateName" title="S" id="akka.actor.FSM;State.withStopReason.x$38">copy</a><span class="delimiter">(</span>stopReason = <span title="(x: akka.actor.FSM.Reason)Some[akka.actor.FSM.Reason]">Some</span><a title="Some[akka.actor.FSM.Reason]" id="akka.actor.FSM;State.withStopReason.x$34" class="delimiter">(</a><a href="#akka.actor.FSM;State.withStopReason.reason" title="akka.actor.FSM.Reason">reason</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  <span class="comment">/**
   * All messages sent to the [[akka.actor.FSM]] will be wrapped inside an
   * `Event`, which allows pattern matching to extract both state and data.
   */</span>
  <span class="keyword">case class</span> <a href="#akka.actor.FSM;Event.productElement.x$1" title="class Event[D] extends AnyRef with akka.actor.NoSerializationVerificationNeeded with Product with Serializable" id="akka.actor.FSM.Event.readResolve">Event</a><span class="delimiter">[</span><a title="" id="akka.actor.FSM;Event;D">D</a><span class="delimiter">]</span><a href="#akka.actor.FSM.Event.readResolve" title="Product" class="delimiter">(</a><a title="Any" id="akka.actor.FSM;Event.event">event</a>: <span title="Any">Any</span>, <a title="D" id="akka.actor.FSM;Event.stateData">stateData</a>: <a href="#akka.actor.FSM;Event;D" title="D">D</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="Actor.scala.html#akka.actor;NoSerializationVerificationNeeded" title="akka.actor.NoSerializationVerificationNeeded">NoSerializationVerificationNeeded</a>

  <span class="comment">/**
   * Case class representing the state of the [[akka.actor.FSM]] whithin the
   * `onTermination` block.
   */</span>
  <span class="keyword">case class</span> <a href="#akka.actor.FSM;StopEvent.productElement.x$1" title="class StopEvent[S, D] extends AnyRef with akka.actor.NoSerializationVerificationNeeded with Product with Serializable" id="akka.actor.FSM.StopEvent.readResolve">StopEvent</a><span class="delimiter">[</span><a title="" id="akka.actor.FSM;StopEvent;S">S</a>, <a title="" id="akka.actor.FSM;StopEvent;D">D</a><span class="delimiter">]</span><a href="#akka.actor.FSM.StopEvent.readResolve" title="Product" class="delimiter">(</a><a title="akka.actor.FSM.Reason" id="akka.actor.FSM;StopEvent.reason">reason</a>: <a href="#akka.actor.FSM;Reason" title="akka.actor.FSM.Reason">Reason</a>, <a title="S" id="akka.actor.FSM;StopEvent.currentState">currentState</a>: <a href="#akka.actor.FSM;StopEvent;S" title="S">S</a>, <a title="D" id="akka.actor.FSM;StopEvent.stateData">stateData</a>: <a href="#akka.actor.FSM;StopEvent;D" title="D">D</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="Actor.scala.html#akka.actor;NoSerializationVerificationNeeded" title="akka.actor.NoSerializationVerificationNeeded">NoSerializationVerificationNeeded</a>

<span class="delimiter">}</span>

<span class="comment">/**
 * Finite State Machine actor trait. Use as follows:
 *
 * &lt;pre&gt;
 *   object A {
 *     trait State
 *     case class One extends State
 *     case class Two extends State
 *
 *     case class Data(i : Int)
 *   }
 *
 *   class A extends Actor with FSM[A.State, A.Data] {
 *     import A._
 *
 *     startWith(One, Data(42))
 *     when(One) {
 *         case Event(SomeMsg, Data(x)) =&gt; ...
 *         case Ev(SomeMsg) =&gt; ... // convenience when data not needed
 *     }
 *     when(Two, stateTimeout = 5 seconds) { ... }
 *     initialize()
 *   }
 * &lt;/pre&gt;
 *
 * Within the partial function the following values are returned for effecting
 * state transitions:
 *
 *  - &lt;code&gt;stay&lt;/code&gt; for staying in the same state
 *  - &lt;code&gt;stay using Data(...)&lt;/code&gt; for staying in the same state, but with
 *    different data
 *  - &lt;code&gt;stay forMax 5.millis&lt;/code&gt; for staying with a state timeout; can be
 *    combined with &lt;code&gt;using&lt;/code&gt;
 *  - &lt;code&gt;goto(...)&lt;/code&gt; for changing into a different state; also supports
 *    &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;forMax&lt;/code&gt;
 *  - &lt;code&gt;stop&lt;/code&gt; for terminating this FSM actor
 *
 * Each of the above also supports the method &lt;code&gt;replying(AnyRef)&lt;/code&gt; for
 * sending a reply before changing state.
 *
 * While changing state, custom handlers may be invoked which are registered
 * using &lt;code&gt;onTransition&lt;/code&gt;. This is meant to enable concentrating
 * different concerns in different places; you may choose to use
 * &lt;code&gt;when&lt;/code&gt; for describing the properties of a state, including of
 * course initiating transitions, but you can describe the transitions using
 * &lt;code&gt;onTransition&lt;/code&gt; to avoid having to duplicate that code among
 * multiple paths which lead to a transition:
 *
 * &lt;pre&gt;
 * onTransition {
 *   case Active -&amp;gt; _ =&amp;gt; cancelTimer(&quot;activeTimer&quot;)
 * }
 * &lt;/pre&gt;
 *
 * Multiple such blocks are supported and all of them will be called, not only
 * the first matching one.
 *
 * Another feature is that other actors may subscribe for transition events by
 * sending a &lt;code&gt;SubscribeTransitionCallback&lt;/code&gt; message to this actor.
 * Stopping a listener without unregistering will not remove the listener from the
 * subscription list; use &lt;code&gt;UnsubscribeTransitionCallback&lt;/code&gt; before stopping
 * the listener.
 *
 * State timeouts set an upper bound to the time which may pass before another
 * message is received in the current state. If no external message is
 * available, then upon expiry of the timeout a StateTimeout message is sent.
 * Note that this message will only be received in the state for which the
 * timeout was set and that any message received will cancel the timeout
 * (possibly to be started again by the next transition).
 *
 * Another feature is the ability to install and cancel single-shot as well as
 * repeated timers which arrange for the sending of a user-specified message:
 *
 * &lt;pre&gt;
 *   setTimer(&quot;tock&quot;, TockMsg, 1 second, true) // repeating
 *   setTimer(&quot;lifetime&quot;, TerminateMsg, 1 hour, false) // single-shot
 *   cancelTimer(&quot;tock&quot;)
 *   isTimerActive(&quot;tock&quot;)
 * &lt;/pre&gt;
 */</span>
<span title="AnyRef" class="keyword">trait</span> <a title="trait FSM[S, D] extends AnyRef with akka.actor.Actor with akka.routing.Listeners with akka.actor.ActorLogging" id="akka.actor;FSM">FSM</a><span class="delimiter">[</span><a title="" id="akka.actor;FSM;S">S</a>, <a title="" id="akka.actor;FSM;D">D</a><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="Actor.scala.html#akka.actor;Actor" title="akka.actor.Actor">Actor</a> <span class="keyword">with</span> <a href="../routing/Listeners.scala.html#akka.routing;Listeners" title="akka.routing.Listeners">Listeners</a> <span class="keyword">with</span> <a href="Actor.scala.html#akka.actor;ActorLogging" title="akka.actor.ActorLogging">ActorLogging</a> <span class="delimiter">{</span>

  <span class="keyword">import</span> <a href="#akka.actor.FSM" title="akka.actor.FSM.type">FSM</a>._

  <span class="keyword">type</span> <a title="akka.actor.FSM.State[S,D]" id="akka.actor;FSM;State">State</a> = FSM.<a href="#akka.actor.FSM.State.readResolve" title="akka.actor.FSM.State[S,D]">State</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="akka.actor.FSM.Event[D]" id="akka.actor;FSM;Event">Event</a> = FSM.<a href="#akka.actor.FSM.Event.readResolve" title="akka.actor.FSM.Event[D]">Event</a><span class="delimiter">[</span>D<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="akka.actor.FSM.StopEvent[S,D]" id="akka.actor;FSM;StopEvent">StopEvent</a> = FSM.<a href="#akka.actor.FSM.StopEvent.readResolve" title="akka.actor.FSM.StopEvent[S,D]">StopEvent</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="PartialFunction[FSM.this.Event,FSM.this.State]" id="akka.actor;FSM;StateFunction">StateFunction</a> = scala.<span title="PartialFunction[FSM.this.Event,FSM.this.State]">PartialFunction</span><span class="delimiter">[</span>Event, State<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="Option[scala.concurrent.duration.FiniteDuration]" id="akka.actor;FSM;Timeout">Timeout</a> = <span title="Option[scala.concurrent.duration.FiniteDuration]">Option</span><span class="delimiter">[</span>FiniteDuration<span class="delimiter">]</span>
  <span class="keyword">type</span> <a title="PartialFunction[(S, S),Unit]" id="akka.actor;FSM;TransitionHandler">TransitionHandler</a> = <span title="PartialFunction[(S, S),Unit]">PartialFunction</span><span class="delimiter">[</span><span class="delimiter">(</span>S, S<span class="delimiter">)</span>, Unit<span class="delimiter">]</span>

  <span class="comment">/*
   * “import” so that these are visible without an import
   */</span>
  <span class="keyword">val</span> <a title="akka.actor.FSM.Event.type" id="akka.actor;FSM.Event">Event</a>: FSM.Event.<span class="keyword">type</span> = <a href="#akka.actor.FSM" title="akka.actor.FSM.type">FSM</a>.<a href="#akka.actor.FSM.Event.readResolve" title="akka.actor.FSM.Event.type">Event</a>
  <span class="keyword">val</span> <a title="akka.actor.FSM.StopEvent.type" id="akka.actor;FSM.StopEvent">StopEvent</a>: FSM.StopEvent.<span class="keyword">type</span> = <a href="#akka.actor.FSM" title="akka.actor.FSM.type">FSM</a>.<a href="#akka.actor.FSM.StopEvent.readResolve" title="akka.actor.FSM.StopEvent.type">StopEvent</a>

  <span class="comment">/**
   * This extractor is just convenience for matching a (S, S) pair, including a
   * reminder what the new state is.
   */</span>
  <span class="keyword">val</span> <a title="akka.actor.FSM.-&gt;.type" id="akka.actor;FSM.->">-&gt;</a> = <a href="#akka.actor.FSM" title="akka.actor.FSM.type">FSM</a>.<a href="#akka.actor.FSM.->" title="akka.actor.FSM.-&gt;.type">-&gt;</a>

  <span class="comment">/**
   * This case object is received in case of a state timeout.
   */</span>
  <span class="keyword">val</span> <a title="akka.actor.FSM.StateTimeout.type" id="akka.actor;FSM.StateTimeout">StateTimeout</a> = <a href="#akka.actor.FSM" title="akka.actor.FSM.type">FSM</a>.<a href="#akka.actor.FSM.StateTimeout.readResolve" title="akka.actor.FSM.StateTimeout.type">StateTimeout</a>

  <span class="comment">/**
   * ****************************************
   *                 DSL
   * ****************************************
   */</span>

  <span class="comment">/**
   * Insert a new StateFunction at the end of the processing chain for the
   * given state. If the stateTimeout parameter is set, entering this state
   * without a differing explicit timeout setting will trigger a StateTimeout
   * event; the same is true when using #stay.
   *
   * @param stateName designator for the state
   * @param stateTimeout default state timeout for this state
   * @param stateFunction partial function describing response to input
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(stateName: S, stateTimeout: scala.concurrent.duration.FiniteDuration)(stateFunction: FSM.this.StateFunction)Unit" id="akka.actor;FSM.when">when</a><span class="delimiter">(</span><a title="S" id="akka.actor;FSM.when.stateName">stateName</a>: <a href="#akka.actor;FSM;S" title="S">S</a>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.actor;FSM.when$default$2">stateTimeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span> = <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="FSM.this.StateFunction" id="akka.actor;FSM.when.stateFunction">stateFunction</a>: <span title="FSM.this.StateFunction">StateFunction</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.actor;FSM.register" title="(name: S, function: FSM.this.StateFunction, timeout: FSM.this.Timeout)Unit">register</a><span class="delimiter">(</span><a href="#akka.actor;FSM.when.stateName" title="S">stateName</a>, <a href="#akka.actor;FSM.when.stateFunction" title="FSM.this.StateFunction">stateFunction</a>, <span title="(x: scala.concurrent.duration.FiniteDuration)Option[scala.concurrent.duration.FiniteDuration]">Option</span><span class="delimiter">(</span><a href="#akka.actor;FSM.when$default$2" title="scala.concurrent.duration.FiniteDuration">stateTimeout</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Set initial state. Call this method from the constructor before the [[#initialize]] method.
   * If different state is needed after a restart this method, followed by [[#initialize]], can
   * be used in the actor life cycle hooks [[akka.actor.Actor#preStart]] and [[akka.actor.Actor#postRestart]].
   *
   * @param stateName initial state designator
   * @param stateData initial state data
   * @param timeout state timeout for the initial state, overriding the default timeout for that state
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(stateName: S, stateData: D, timeout: FSM.this.Timeout)Unit" id="akka.actor;FSM.startWith">startWith</a><span class="delimiter">(</span><a title="S" id="akka.actor;FSM.startWith.stateName">stateName</a>: <a href="#akka.actor;FSM;S" title="S">S</a>, <a title="D" id="akka.actor;FSM.startWith.stateData">stateData</a>: <a href="#akka.actor;FSM;D" title="D">D</a>, <a title="FSM.this.Timeout" id="akka.actor;FSM.startWith$default$3">timeout</a>: <span title="FSM.this.Timeout">Timeout</span> = <span title="None.type">None</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.actor;FSM.currentState_=" title="(x$1: FSM.this.State)Unit">currentState</a> = <a href="#akka.actor.FSM" title="akka.actor.FSM.type">FSM</a>.<a href="#akka.actor.FSM.State.readResolve" title="(stateName: S, stateData: D, timeout: Option[scala.concurrent.duration.FiniteDuration], stopReason: Option[akka.actor.FSM.Reason], replies: List[Any])akka.actor.FSM.State[S,D]">State</a><span class="delimiter">(</span><a href="#akka.actor;FSM.startWith.stateName" title="S">stateName</a>, <a href="#akka.actor;FSM.startWith.stateData" title="D">stateData</a>, <a href="#akka.actor;FSM.startWith$default$3" title="FSM.this.Timeout">timeout</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Produce transition to other state. Return this from a state function in
   * order to effect the transition.
   *
   * @param nextStateName state designator for the next state
   * @return state transition descriptor
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(nextStateName: S)FSM.this.State" id="akka.actor;FSM.goto">goto</a><span class="delimiter">(</span><a title="S" id="akka.actor;FSM.goto.nextStateName">nextStateName</a>: <a href="#akka.actor;FSM;S" title="S">S</a><span class="delimiter">)</span>: <a href="#akka.actor.FSM.State.readResolve" title="FSM.this.State">State</a> = <a href="#akka.actor.FSM" title="akka.actor.FSM.type">FSM</a>.<a href="#akka.actor.FSM.State.readResolve" title="(stateName: S, stateData: D, timeout: Option[scala.concurrent.duration.FiniteDuration], stopReason: Option[akka.actor.FSM.Reason], replies: List[Any])akka.actor.FSM.State[S,D]">State</a><span class="delimiter">(</span><a href="#akka.actor;FSM.goto.nextStateName" title="S">nextStateName</a>, <a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateData" title="=&gt; D">stateData</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Produce &quot;empty&quot; transition descriptor. Return this from a state function
   * when no state change is to be effected.
   *
   * @return descriptor for staying in current state
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="()FSM.this.State" id="akka.actor;FSM.stay">stay</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.actor.FSM.State.readResolve" title="FSM.this.State">State</a> = <a href="#akka.actor;FSM.goto" title="(nextStateName: S)FSM.this.State">goto</a><span class="delimiter">(</span><a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a><span class="delimiter">)</span> <span class="comment">// cannot directly use currentState because of the timeout field</span>

  <span class="comment">/**
   * Produce change descriptor to stop this FSM actor with reason &quot;Normal&quot;.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="()FSM.this.State" id="akka.actor;FSM.stop(65b4a2ce7c)">stop</a><span class="delimiter">(</span><span class="delimiter">)</span>: <a href="#akka.actor.FSM.State.readResolve" title="FSM.this.State">State</a> = <a href="#akka.actor;FSM.stop(56d0504ea6)" title="(reason: akka.actor.FSM.Reason)FSM.this.State">stop</a><span class="delimiter">(</span><a href="#akka.actor.FSM.Normal.readResolve" title="akka.actor.FSM.Normal.type">Normal</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Produce change descriptor to stop this FSM actor including specified reason.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(reason: akka.actor.FSM.Reason)FSM.this.State" id="akka.actor;FSM.stop(56d0504ea6)">stop</a><span class="delimiter">(</span><a title="akka.actor.FSM.Reason" id="akka.actor;FSM.stop(56d0504ea6).reason">reason</a>: <a href="#akka.actor.FSM;Reason" title="akka.actor.FSM.Reason">Reason</a><span class="delimiter">)</span>: <a href="#akka.actor.FSM.State.readResolve" title="FSM.this.State">State</a> = <a href="#akka.actor;FSM.stop(0e3dcf2dd4)" title="(reason: akka.actor.FSM.Reason, stateData: D)FSM.this.State">stop</a><span class="delimiter">(</span><a href="#akka.actor;FSM.stop(56d0504ea6).reason" title="akka.actor.FSM.Reason">reason</a>, <a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateData" title="=&gt; D">stateData</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Produce change descriptor to stop this FSM actor including specified reason.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(reason: akka.actor.FSM.Reason, stateData: D)FSM.this.State" id="akka.actor;FSM.stop(0e3dcf2dd4)">stop</a><span class="delimiter">(</span><a title="akka.actor.FSM.Reason" id="akka.actor;FSM.stop(0e3dcf2dd4).reason">reason</a>: <a href="#akka.actor.FSM;Reason" title="akka.actor.FSM.Reason">Reason</a>, <a title="D" id="akka.actor;FSM.stop(0e3dcf2dd4).stateData">stateData</a>: <a href="#akka.actor;FSM;D" title="D">D</a><span class="delimiter">)</span>: <a href="#akka.actor.FSM.State.readResolve" title="FSM.this.State">State</a> = <a href="#akka.actor;FSM.stay" title="()FSM.this.State">stay</a> <a href="#akka.actor.FSM;State.using" title="(nextStateDate: D)akka.actor.FSM.State[S,D]">using</a> <a href="#akka.actor;FSM.stop(0e3dcf2dd4).stateData" title="D">stateData</a> <a href="#akka.actor.FSM;State.withStopReason" title="(reason: akka.actor.FSM.Reason)akka.actor.FSM.State[S,D]">withStopReason</a> <span class="delimiter">(</span><a href="#akka.actor;FSM.stop(0e3dcf2dd4).reason" title="akka.actor.FSM.Reason">reason</a><span class="delimiter">)</span>

  <span class="keyword">final</span> <span class="keyword">class</span> <a title="class TransformHelper extends AnyRef" id="akka.actor;FSM;TransformHelper">TransformHelper</a><a href="#akka.actor;FSM;TransformHelper" title="FSM.this.TransformHelper" class="delimiter">(</a><a title="FSM.this.StateFunction" id="akka.actor;FSM;TransformHelper.func">func</a>: <span title="FSM.this.StateFunction">StateFunction</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(andThen: PartialFunction[FSM.this.State,FSM.this.State])FSM.this.StateFunction" id="akka.actor;FSM;TransformHelper.using">using</a><span class="delimiter">(</span><a title="PartialFunction[FSM.this.State,FSM.this.State]" id="akka.actor;FSM;TransformHelper.using.andThen">andThen</a>: <span title="PartialFunction[FSM.this.State,FSM.this.State]">PartialFunction</span><span class="delimiter">[</span>State, State<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="FSM.this.StateFunction">StateFunction</span> =
      <a href="#akka.actor;FSM;TransformHelper.func" title="FSM.this.StateFunction">func</a> <span title="(k: FSM.this.State =&gt; FSM.this.State)PartialFunction[FSM.this.Event,FSM.this.State]">andThen</span> <span class="delimiter">(</span><a href="#akka.actor;FSM;TransformHelper.using.andThen" title="PartialFunction[FSM.this.State,FSM.this.State]">andThen</a> <span title="(that: PartialFunction[FSM.this.State,FSM.this.State])PartialFunction[FSM.this.State,FSM.this.State]">orElse</span> <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[FSM.this.State,FSM.this.State] with Serializable" id="akka.actor;FSM;TransformHelper.using;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a> <span class="keyword">case</span> <a title="FSM.this.State" id="akka.actor;FSM;TransformHelper.using;$anonfun.isDefinedAt.x">x</a> ⇒ <a href="#akka.actor;FSM;TransformHelper.using;$anonfun.isDefinedAt.x" title="FSM.this.State">x</a> <span class="delimiter">}</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(func: FSM.this.StateFunction)FSM.this.TransformHelper" id="akka.actor;FSM.transform">transform</a><span class="delimiter">(</span><a title="FSM.this.StateFunction" id="akka.actor;FSM.transform.func">func</a>: <span title="FSM.this.StateFunction">StateFunction</span><span class="delimiter">)</span>: <a href="#akka.actor;FSM;TransformHelper" title="FSM.this.TransformHelper">TransformHelper</a> = <span title="FSM.this.TransformHelper" class="keyword">new</span> <a href="#akka.actor;FSM;TransformHelper" title="FSM.this.TransformHelper">TransformHelper</a><span class="delimiter">(</span><a href="#akka.actor;FSM.transform.func" title="FSM.this.StateFunction">func</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Schedule named timer to deliver message after given delay, possibly repeating.
   * Any existing timer with the same name will automatically be canceled before
   * adding the new timer.
   * @param name identifier to be used with cancelTimer()
   * @param msg message to be delivered
   * @param timeout delay of first message delivery and between subsequent messages
   * @param repeat send once if false, scheduleAtFixedRate if true
   * @return current state descriptor
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(name: String, msg: Any, timeout: scala.concurrent.duration.FiniteDuration, repeat: Boolean)Unit" id="akka.actor;FSM.setTimer">setTimer</a><span class="delimiter">(</span><a title="String" id="akka.actor;FSM.setTimer.name">name</a>: <span title="String">String</span>, <a title="Any" id="akka.actor;FSM.setTimer.msg">msg</a>: <span title="Any">Any</span>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.actor;FSM.setTimer.timeout">timeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>, <a title="Boolean" id="akka.actor;FSM.setTimer$default$4">repeat</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.debugEvent" title="=&gt; Boolean">debugEvent</a><span class="delimiter">)</span>
      <a href="Actor.scala.html#akka.actor;ActorLogging.log" title="=&gt; akka.event.LoggingAdapter">log</a>.<a href="../event/Logging.scala.html#akka.event;LoggingAdapter.debug(cc2e600322)" title="(message: String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;setting &quot;)" class="string">&quot;setting &quot;</span> <span title="(x$1: Any)String">+</span> <span class="delimiter">(</span><span title="Any" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.setTimer$default$4" title="Boolean">repeat</a><span class="delimiter">)</span> <span title="String(&quot;repeating &quot;)" class="string">&quot;repeating &quot;</span> <span class="keyword">else</span> <span title="String(&quot;&quot;)" class="string">&quot;&quot;</span><span class="delimiter">)</span> <span title="(x$1: Any)String">+</span> <span title="String(&quot;timer \'&quot;)" class="string">&quot;timer '&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.actor;FSM.setTimer.name" title="String">name</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\'/&quot;)" class="string">&quot;'/&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.actor;FSM.setTimer.timeout" title="scala.concurrent.duration.FiniteDuration">timeout</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;: &quot;)" class="string">&quot;: &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.actor;FSM.setTimer.msg" title="Any">msg</a><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.timers" title="=&gt; scala.collection.mutable.Map[String,akka.actor.FSM.Timer]">timers</a> <span title="(key: String)Boolean">contains</span> <a href="#akka.actor;FSM.setTimer.name" title="String">name</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#akka.actor;FSM.timers" title="(key: String)akka.actor.FSM.Timer">timers</a><span class="delimiter">(</span><a href="#akka.actor;FSM.setTimer.name" title="String">name</a><span class="delimiter">)</span>.<a href="#akka.actor.FSM;Timer.cancel" title="()Unit">cancel</a>
    <span class="delimiter">}</span>
    <span class="keyword">val</span> <a title="akka.actor.FSM.Timer" id="akka.actor;FSM.setTimer.timer">timer</a> = <a href="#akka.actor.FSM.Timer.readResolve" title="(name: String, msg: Any, repeat: Boolean, generation: Int)(context: akka.actor.ActorContext)akka.actor.FSM.Timer">Timer</a><span class="delimiter">(</span><a href="#akka.actor;FSM.setTimer.name" title="String">name</a>, <a href="#akka.actor;FSM.setTimer.msg" title="Any">msg</a>, <a href="#akka.actor;FSM.setTimer$default$4" title="Boolean">repeat</a>, <a href="#akka.actor;FSM.timerGen" title="=&gt; Iterator[Int]">timerGen</a>.<span title="()Int">next</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="Actor.scala.html#akka.actor;Actor.context" title="=&gt; akka.actor.ActorContext">context</a><span class="delimiter">)</span>
    <a href="#akka.actor;FSM.setTimer.timer" title="akka.actor.FSM.Timer">timer</a>.<a href="#akka.actor.FSM;Timer.schedule" title="(actor: akka.actor.ActorRef, timeout: scala.concurrent.duration.FiniteDuration)Unit">schedule</a><span class="delimiter">(</span><a href="Actor.scala.html#akka.actor;Actor.self" title="=&gt; akka.actor.ActorRef">self</a>, <a href="#akka.actor;FSM.setTimer.timeout" title="scala.concurrent.duration.FiniteDuration">timeout</a><span class="delimiter">)</span>
    <a href="#akka.actor;FSM.timers" title="(key: String, value: akka.actor.FSM.Timer)Unit">timers</a><span class="delimiter">(</span><a href="#akka.actor;FSM.setTimer.name" title="String">name</a><span class="delimiter">)</span> = <a href="#akka.actor;FSM.setTimer.timer" title="akka.actor.FSM.Timer">timer</a>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Cancel named timer, ensuring that the message is not subsequently delivered (no race).
   * @param name of the timer to cancel
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(name: String)Unit" id="akka.actor;FSM.cancelTimer">cancelTimer</a><span class="delimiter">(</span><a title="String" id="akka.actor;FSM.cancelTimer.name">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.debugEvent" title="=&gt; Boolean">debugEvent</a><span class="delimiter">)</span>
      <a href="Actor.scala.html#akka.actor;ActorLogging.log" title="=&gt; akka.event.LoggingAdapter">log</a>.<a href="../event/Logging.scala.html#akka.event;LoggingAdapter.debug(cc2e600322)" title="(message: String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;canceling timer \'&quot;)" class="string">&quot;canceling timer '&quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.actor;FSM.cancelTimer.name" title="String">name</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot;\'&quot;)" class="string">&quot;'&quot;</span><span class="delimiter">)</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.timers" title="=&gt; scala.collection.mutable.Map[String,akka.actor.FSM.Timer]">timers</a> <span title="(key: String)Boolean">contains</span> <a href="#akka.actor;FSM.cancelTimer.name" title="String">name</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#akka.actor;FSM.timers" title="(key: String)akka.actor.FSM.Timer">timers</a><span class="delimiter">(</span><a href="#akka.actor;FSM.cancelTimer.name" title="String">name</a><span class="delimiter">)</span>.<a href="#akka.actor.FSM;Timer.cancel" title="()Unit">cancel</a>
      <a href="#akka.actor;FSM.timers" title="=&gt; scala.collection.mutable.Map[String,akka.actor.FSM.Timer]">timers</a> <span title="(key: String)FSM.this.timers.type">-=</span> <a href="#akka.actor;FSM.cancelTimer.name" title="String">name</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Inquire whether the named timer is still active. Returns true unless the
   * timer does not exist, has previously been canceled or if it was a
   * single-shot timer whose message was already received.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(name: String)Boolean" id="akka.actor;FSM.isTimerActive">isTimerActive</a><span class="delimiter">(</span><a title="String" id="akka.actor;FSM.isTimerActive.name">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#akka.actor;FSM.timers" title="=&gt; scala.collection.mutable.Map[String,akka.actor.FSM.Timer]">timers</a> <span title="(key: String)Boolean">contains</span> <a href="#akka.actor;FSM.isTimerActive.name" title="String">name</a>

  <span class="comment">/**
   * Set state timeout explicitly. This method can safely be used from within a
   * state handler.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(state: S, timeout: FSM.this.Timeout)Unit" id="akka.actor;FSM.setStateTimeout">setStateTimeout</a><span class="delimiter">(</span><a title="S" id="akka.actor;FSM.setStateTimeout.state">state</a>: <a href="#akka.actor;FSM;S" title="S">S</a>, <a title="FSM.this.Timeout" id="akka.actor;FSM.setStateTimeout.timeout">timeout</a>: <span title="FSM.this.Timeout">Timeout</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.actor;FSM.stateTimeouts" title="(key: S, value: Option[scala.concurrent.duration.FiniteDuration])Unit">stateTimeouts</a><span class="delimiter">(</span><a href="#akka.actor;FSM.setStateTimeout.state" title="S">state</a><span class="delimiter">)</span> = <a href="#akka.actor;FSM.setStateTimeout.timeout" title="FSM.this.Timeout">timeout</a>

  <span class="comment">/**
   * INTERNAL API, used for testing.
   */</span>
  <span class="keyword">private</span><span class="delimiter">[</span>akka<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.actor;FSM.isStateTimerActive">isStateTimerActive</a> = <a href="#akka.actor;FSM.timeoutFuture_=" title="=&gt; Option[akka.actor.Cancellable]">timeoutFuture</a>.<span title="=&gt; Boolean">isDefined</span>

  <span class="comment">/**
   * Set handler which is called upon each state transition, i.e. not when
   * staying in the same state. This may use the pair extractor defined in the
   * FSM companion object like so:
   *
   * &lt;pre&gt;
   * onTransition {
   *   case Old -&amp;gt; New =&amp;gt; doSomething
   * }
   * &lt;/pre&gt;
   *
   * It is also possible to supply a 2-ary function object:
   *
   * &lt;pre&gt;
   * onTransition(handler _)
   *
   * private def handler(from: S, to: S) { ... }
   * &lt;/pre&gt;
   *
   * The underscore is unfortunately necessary to enable the nicer syntax shown
   * above (it uses the implicit conversion total2pf under the hood).
   *
   * &lt;b&gt;Multiple handlers may be installed, and every one of them will be
   * called, not only the first one matching.&lt;/b&gt;
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(transitionHandler: FSM.this.TransitionHandler)Unit" id="akka.actor;FSM.onTransition">onTransition</a><span class="delimiter">(</span><a title="FSM.this.TransitionHandler" id="akka.actor;FSM.onTransition.transitionHandler">transitionHandler</a>: <span title="FSM.this.TransitionHandler">TransitionHandler</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.actor;FSM.transitionEvent_=" title="(x$1: List[FSM.this.TransitionHandler])Unit">transitionEvent</a> <span title="(elem: FSM.this.TransitionHandler)(implicit bf: scala.collection.generic.CanBuildFrom[List[FSM.this.TransitionHandler],FSM.this.TransitionHandler,List[FSM.this.TransitionHandler]])List[FSM.this.TransitionHandler]">:+=</span> <a href="#akka.actor;FSM.onTransition.transitionHandler" title="FSM.this.TransitionHandler">transitionHandler</a>

  <span class="comment">/**
   * Convenience wrapper for using a total function instead of a partial
   * function literal. To be used with onTransition.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="implicit akka.actor.FSM.total2pf : (transitionHandler: (S, S) =&gt; Unit)FSM.this.TransitionHandler" id="akka.actor;FSM.total2pf">total2pf</a><span class="delimiter">(</span><a title="(S, S) =&gt; Unit" id="akka.actor;FSM.total2pf.transitionHandler">transitionHandler</a>: <span class="delimiter">(</span>S, S<span class="delimiter">)</span> ⇒ Unit<span class="delimiter">)</span>: <span title="FSM.this.TransitionHandler">TransitionHandler</span> =
    <a href="#akka.actor;FSM.total2pf;$anon" title="FSM.this.TransitionHandler" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with FSM.this.TransitionHandler" id="akka.actor;FSM.total2pf;$anon">TransitionHandler</a> <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(in: (S, S))Boolean" id="akka.actor;FSM.total2pf;$anon.isDefinedAt">isDefinedAt</a><span class="delimiter">(</span><a title="(S, S)" id="akka.actor;FSM.total2pf;$anon.isDefinedAt.in">in</a>: <span title="(S, S)" class="delimiter">(</span>S, S<span class="delimiter">)</span><span class="delimiter">)</span> = <span title="Boolean(true)" class="keyword">true</span>
      <span class="keyword">def</span> <a title="(in: (S, S))Unit" id="akka.actor;FSM.total2pf;$anon.apply">apply</a><span class="delimiter">(</span><a title="(S, S)" id="akka.actor;FSM.total2pf;$anon.apply.in">in</a>: <span title="(S, S)" class="delimiter">(</span>S, S<span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <a href="#akka.actor;FSM.total2pf.transitionHandler" title="(v1: S, v2: S)Unit">transitionHandler</a><span class="delimiter">(</span><a href="#akka.actor;FSM.total2pf;$anon.apply.in" title="(S, S)">in</a>.<span title="=&gt; S">_1</span>, <a href="#akka.actor;FSM.total2pf;$anon.apply.in" title="(S, S)">in</a>.<span title="=&gt; S">_2</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    <span class="delimiter">}</span>

  <span class="comment">/**
   * Set handler which is called upon termination of this FSM actor. Calling
   * this method again will overwrite the previous contents.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(terminationHandler: PartialFunction[FSM.this.StopEvent,Unit])Unit" id="akka.actor;FSM.onTermination">onTermination</a><span class="delimiter">(</span><a title="PartialFunction[FSM.this.StopEvent,Unit]" id="akka.actor;FSM.onTermination.terminationHandler">terminationHandler</a>: <span title="PartialFunction[FSM.this.StopEvent,Unit]">PartialFunction</span><span class="delimiter">[</span>StopEvent, Unit<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.actor;FSM.terminateEvent_=" title="(x$1: PartialFunction[FSM.this.StopEvent,Unit])Unit">terminateEvent</a> = <a href="#akka.actor;FSM.onTermination.terminationHandler" title="PartialFunction[FSM.this.StopEvent,Unit]">terminationHandler</a>

  <span class="comment">/**
   * Set handler which is called upon reception of unhandled messages. Calling
   * this method again will overwrite the previous contents.
   *
   * The current state may be queried using ``stateName``.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(stateFunction: FSM.this.StateFunction)Unit" id="akka.actor;FSM.whenUnhandled">whenUnhandled</a><span class="delimiter">(</span><a title="FSM.this.StateFunction" id="akka.actor;FSM.whenUnhandled.stateFunction">stateFunction</a>: <span title="FSM.this.StateFunction">StateFunction</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.actor;FSM.handleEvent_=" title="(x$1: FSM.this.StateFunction)Unit">handleEvent</a> = <a href="#akka.actor;FSM.whenUnhandled.stateFunction" title="FSM.this.StateFunction">stateFunction</a> <span title="(that: PartialFunction[FSM.this.Event,FSM.this.State])PartialFunction[FSM.this.Event,FSM.this.State]">orElse</span> <a href="#akka.actor;FSM.handleEventDefault" title="=&gt; FSM.this.StateFunction">handleEventDefault</a>

  <span class="comment">/**
   * Verify existence of initial state and setup timers. This should be the
   * last call within the constructor, or [[akka.actor.Actor#preStart]] and
   * [[akka.actor.Actor#postRestart]]
   *
   * @see [[#startWith]]
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="()Unit" id="akka.actor;FSM.initialize">initialize</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.actor;FSM.makeTransition" title="(nextState: FSM.this.State)Unit">makeTransition</a><span class="delimiter">(</span><a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Return current state name (i.e. object of type S)
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; S" id="akka.actor;FSM.stateName">stateName</a>: <a href="#akka.actor;FSM;S" title="S">S</a> = <a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a>

  <span class="comment">/**
   * Return current state data (i.e. object of type D)
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; D" id="akka.actor;FSM.stateData">stateData</a>: <a href="#akka.actor;FSM;D" title="D">D</a> = <a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateData" title="=&gt; D">stateData</a>

  <span class="comment">/**
   * Return next state data (available in onTransition handlers)
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="=&gt; D" id="akka.actor;FSM.nextStateData">nextStateData</a> = <a href="#akka.actor;FSM.nextState_=" title="=&gt; FSM.this.State">nextState</a> <span title="D" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Null(null)" class="keyword">null</span> ⇒ <span title="Nothing" class="keyword">throw</span> <span title="(x$1: String)IllegalStateException" class="keyword">new</span> <span title="IllegalStateException">IllegalStateException</span><span class="delimiter">(</span><span title="String(&quot;nextStateData is only available during onTransition&quot;)" class="string">&quot;nextStateData is only available during onTransition&quot;</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="FSM.this.State" id="akka.actor;FSM.nextStateData.x">x</a>    ⇒ <a href="#akka.actor;FSM.nextStateData.x" title="FSM.this.State">x</a>.<a href="#akka.actor.FSM;State.stateData" title="=&gt; D">stateData</a>
  <span class="delimiter">}</span>

  <span class="comment">/*
   * ****************************************************************
   *                PRIVATE IMPLEMENTATION DETAILS
   * ****************************************************************
   */</span>

  <span class="keyword">private</span><span class="delimiter">[</span>akka<span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.actor;FSM.debugEvent">debugEvent</a>: <span title="Boolean">Boolean</span> = <span title="Boolean(false)" class="keyword">false</span>

  <span class="comment">/*
   * FSM State data and current timeout handling
   */</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="FSM.this.State" id="akka.actor;FSM.currentState_=">currentState</a>: <a href="#akka.actor.FSM.State.readResolve" title="FSM.this.State">State</a> = _
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Option[akka.actor.Cancellable]" id="akka.actor;FSM.timeoutFuture_=">timeoutFuture</a>: <span title="Option[akka.actor.Cancellable]">Option</span><span class="delimiter">[</span>Cancellable<span class="delimiter">]</span> = <span title="None.type">None</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="FSM.this.State" id="akka.actor;FSM.nextState_=">nextState</a>: <a href="#akka.actor.FSM.State.readResolve" title="FSM.this.State">State</a> = _
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Long" id="akka.actor;FSM.generation_=">generation</a>: <span title="Long">Long</span> = <span title="Long(0L)" class="long">0L</span>

  <span class="comment">/*
   * Timer handling
   */</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.Map[String,akka.actor.FSM.Timer]" id="akka.actor;FSM.timers">timers</a> = mutable.<span title="[A, B](elems: (A, B)*)scala.collection.mutable.Map[A,B]">Map</span><span title="(elems: (String, akka.actor.FSM.Timer)*)scala.collection.mutable.Map[String,akka.actor.FSM.Timer]" class="delimiter">[</span><span title="String">String</span>, <a href="#akka.actor.FSM.Timer.readResolve" title="akka.actor.FSM.Timer">Timer</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="Iterator[Int]" id="akka.actor;FSM.timerGen">timerGen</a> = <span title="=&gt; collection.Iterator.type">Iterator</span> <span title="(start: Int)Iterator[Int]">from</span> <span title="Int(0)" class="int">0</span>

  <span class="comment">/*
   * State definitions
   */</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.Map[S,PartialFunction[akka.actor.FSM.Event[D],akka.actor.FSM.State[S,D]]]" id="akka.actor;FSM.stateFunctions">stateFunctions</a> = mutable.<span title="[A, B](elems: (A, B)*)scala.collection.mutable.Map[A,B]">Map</span><span title="(elems: (S, FSM.this.StateFunction)*)scala.collection.mutable.Map[S,FSM.this.StateFunction]" class="delimiter">[</span><a href="#akka.actor;FSM;S" title="S">S</a>, <span title="FSM.this.StateFunction">StateFunction</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.Map[S,Option[scala.concurrent.duration.FiniteDuration]]" id="akka.actor;FSM.stateTimeouts">stateTimeouts</a> = mutable.<span title="[A, B](elems: (A, B)*)scala.collection.mutable.Map[A,B]">Map</span><span title="(elems: (S, FSM.this.Timeout)*)scala.collection.mutable.Map[S,FSM.this.Timeout]" class="delimiter">[</span><a href="#akka.actor;FSM;S" title="S">S</a>, <span title="FSM.this.Timeout">Timeout</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(name: S, function: FSM.this.StateFunction, timeout: FSM.this.Timeout)Unit" id="akka.actor;FSM.register">register</a><span class="delimiter">(</span><a title="S" id="akka.actor;FSM.register.name">name</a>: <a href="#akka.actor;FSM;S" title="S">S</a>, <a title="FSM.this.StateFunction" id="akka.actor;FSM.register.function">function</a>: <span title="FSM.this.StateFunction">StateFunction</span>, <a title="FSM.this.Timeout" id="akka.actor;FSM.register.timeout">timeout</a>: <span title="FSM.this.Timeout">Timeout</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.stateFunctions" title="=&gt; scala.collection.mutable.Map[S,PartialFunction[akka.actor.FSM.Event[D],akka.actor.FSM.State[S,D]]]">stateFunctions</a> <span title="(key: S)Boolean">contains</span> <a href="#akka.actor;FSM.register.name" title="S">name</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#akka.actor;FSM.stateFunctions" title="(key: S, value: PartialFunction[akka.actor.FSM.Event[D],akka.actor.FSM.State[S,D]])Unit">stateFunctions</a><span class="delimiter">(</span><a href="#akka.actor;FSM.register.name" title="S">name</a><span class="delimiter">)</span> = <a href="#akka.actor;FSM.stateFunctions" title="(key: S)PartialFunction[akka.actor.FSM.Event[D],akka.actor.FSM.State[S,D]]">stateFunctions</a><span class="delimiter">(</span><a href="#akka.actor;FSM.register.name" title="S">name</a><span class="delimiter">)</span> <span title="(that: PartialFunction[akka.actor.FSM.Event[D],akka.actor.FSM.State[S,D]])PartialFunction[akka.actor.FSM.Event[D],akka.actor.FSM.State[S,D]]">orElse</span> <a href="#akka.actor;FSM.register.function" title="FSM.this.StateFunction">function</a>
      <a href="#akka.actor;FSM.stateTimeouts" title="(key: S, value: Option[scala.concurrent.duration.FiniteDuration])Unit">stateTimeouts</a><span class="delimiter">(</span><a href="#akka.actor;FSM.register.name" title="S">name</a><span class="delimiter">)</span> = <a href="#akka.actor;FSM.register.timeout" title="FSM.this.Timeout">timeout</a> <span title="(alternative: =&gt; Option[scala.concurrent.duration.FiniteDuration])Option[scala.concurrent.duration.FiniteDuration]">orElse</span> <a href="#akka.actor;FSM.stateTimeouts" title="(key: S)Option[scala.concurrent.duration.FiniteDuration]">stateTimeouts</a><span class="delimiter">(</span><a href="#akka.actor;FSM.register.name" title="S">name</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#akka.actor;FSM.stateFunctions" title="(key: S, value: PartialFunction[akka.actor.FSM.Event[D],akka.actor.FSM.State[S,D]])Unit">stateFunctions</a><span class="delimiter">(</span><a href="#akka.actor;FSM.register.name" title="S">name</a><span class="delimiter">)</span> = <a href="#akka.actor;FSM.register.function" title="FSM.this.StateFunction">function</a>
      <a href="#akka.actor;FSM.stateTimeouts" title="(key: S, value: Option[scala.concurrent.duration.FiniteDuration])Unit">stateTimeouts</a><span class="delimiter">(</span><a href="#akka.actor;FSM.register.name" title="S">name</a><span class="delimiter">)</span> = <a href="#akka.actor;FSM.register.timeout" title="FSM.this.Timeout">timeout</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/*
   * unhandled event handler
   */</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="FSM.this.StateFunction" id="akka.actor;FSM.handleEventDefault">handleEventDefault</a>: <span title="FSM.this.StateFunction">StateFunction</span> = <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[FSM.this.Event,FSM.this.State] with Serializable" id="akka.actor;FSM.handleEventDefault;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
    <span class="keyword">case</span> Event<span class="delimiter">(</span><a title="Any" id="akka.actor;FSM.handleEventDefault;$anonfun.isDefinedAt.value">value</a>, <a title="D" id="akka.actor;FSM.handleEventDefault;$anonfun.isDefinedAt.stateData">stateData</a><span class="delimiter">)</span> ⇒
      <a href="Actor.scala.html#akka.actor;ActorLogging.log" title="=&gt; akka.event.LoggingAdapter">log</a>.<a href="../event/Logging.scala.html#akka.event;LoggingAdapter.warning(cc2e600322)" title="(message: String)Unit">warning</a><span class="delimiter">(</span><span title="String(&quot;unhandled event &quot;)" class="string">&quot;unhandled event &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.actor;FSM.handleEventDefault;$anonfun.isDefinedAt.value" title="Any">value</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; in state &quot;)" class="string">&quot; in state &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.actor;FSM.stateName" title="=&gt; S">stateName</a><span class="delimiter">)</span>
      <a href="#akka.actor;FSM.stay" title="()FSM.this.State">stay</a>
  <span class="delimiter">}</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="FSM.this.StateFunction" id="akka.actor;FSM.handleEvent_=">handleEvent</a>: <span title="FSM.this.StateFunction">StateFunction</span> = <a href="#akka.actor;FSM.handleEventDefault" title="=&gt; FSM.this.StateFunction">handleEventDefault</a>

  <span class="comment">/*
   * termination handling
   */</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="PartialFunction[FSM.this.StopEvent,Unit]" id="akka.actor;FSM.terminateEvent_=">terminateEvent</a>: <span title="PartialFunction[FSM.this.StopEvent,Unit]">PartialFunction</span><span class="delimiter">[</span>StopEvent, Unit<span class="delimiter">]</span> = <a href="#akka.actor.FSM.NullFunction" title="akka.actor.FSM.NullFunction.type">NullFunction</a>

  <span class="comment">/*
   * transition handling
   */</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="List[FSM.this.TransitionHandler]" id="akka.actor;FSM.transitionEvent_=">transitionEvent</a>: <span title="List[FSM.this.TransitionHandler]">List</span><span class="delimiter">[</span>TransitionHandler<span class="delimiter">]</span> = <span title="scala.collection.immutable.Nil.type">Nil</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(prev: S, next: S)Unit" id="akka.actor;FSM.handleTransition">handleTransition</a><span class="delimiter">(</span><a title="S" id="akka.actor;FSM.handleTransition.prev">prev</a>: <a href="#akka.actor;FSM;S" title="S">S</a>, <a title="S" id="akka.actor;FSM.handleTransition.next">next</a>: <a href="#akka.actor;FSM;S" title="S">S</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="(S, S)" id="akka.actor;FSM.handleTransition.tuple">tuple</a> = <span title="(_1: S, _2: S)(S, S)" class="delimiter">(</span><a href="#akka.actor;FSM.handleTransition.prev" title="S">prev</a>, <a href="#akka.actor;FSM.handleTransition.next" title="S">next</a><span class="delimiter">)</span>
    <span class="keyword">for</span> <span class="delimiter">(</span><a title="FSM.this.TransitionHandler" id="akka.actor;FSM.handleTransition.$anonfun.te">te</a> ← <a href="#akka.actor;FSM.transitionEvent_=" title="(f: FSM.this.TransitionHandler =&gt; Unit)Unit">transitionEvent</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.handleTransition.$anonfun.te" title="FSM.this.TransitionHandler">te</a>.<span title="(x: (S, S))Boolean">isDefinedAt</span><span class="delimiter">(</span><a href="#akka.actor;FSM.handleTransition.tuple" title="(S, S)">tuple</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.actor;FSM.handleTransition.$anonfun.te" title="(v1: (S, S))Unit">te</a><span class="delimiter">(</span><a href="#akka.actor;FSM.handleTransition.tuple" title="(S, S)">tuple</a><span class="delimiter">)</span> <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/*
   * *******************************************
   *       Main actor receive() method
   * *******************************************
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; FSM.this.Receive" id="akka.actor;FSM.receive">receive</a>: <span title="FSM.this.Receive">Receive</span> = <a title="anonymous class $anonfun extends scala.runtime.AbstractPartialFunction[Any,Unit] with Serializable" id="akka.actor;FSM.receive;$anonfun.isDefinedAt.defaultCase$" class="delimiter">{</a>
    <span class="keyword">case</span> TimeoutMarker<span class="delimiter">(</span><span title="Long">gen</span><span class="delimiter">)</span> ⇒
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.generation_=" title="=&gt; Long">generation</a> <span title="(x: Long)Boolean">==</span> <span title="Long">gen</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#akka.actor;FSM.processMsg" title="(value: Any, source: AnyRef)Unit">processMsg</a><span class="delimiter">(</span><a href="#akka.actor;FSM.StateTimeout" title="=&gt; akka.actor.FSM.StateTimeout.type">StateTimeout</a>, <span title="String(&quot;state timeout&quot;)" class="string">&quot;state timeout&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> <a title="akka.actor.FSM.Timer" id="akka.actor;FSM.receive;$anonfun.isDefinedAt.t">t</a> @ Timer<span class="delimiter">(</span><a title="String" id="akka.actor;FSM.receive;$anonfun.isDefinedAt.name">name</a>, <a title="Any" id="akka.actor;FSM.receive;$anonfun.isDefinedAt.msg">msg</a>, <a title="Boolean" id="akka.actor;FSM.receive;$anonfun.isDefinedAt.repeat">repeat</a>, <span title="Int">gen</span><span class="delimiter">)</span> ⇒
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#akka.actor;FSM.timers" title="=&gt; scala.collection.mutable.Map[String,akka.actor.FSM.Timer]">timers</a> <span title="(key: String)Boolean">contains</span> <a href="#akka.actor;FSM.receive;$anonfun.isDefinedAt.name" title="String">name</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.timers" title="(key: String)akka.actor.FSM.Timer">timers</a><span class="delimiter">(</span><a href="#akka.actor;FSM.receive;$anonfun.isDefinedAt.name" title="String">name</a><span class="delimiter">)</span>.<a href="#akka.actor.FSM;Timer.generation" title="=&gt; Int">generation</a> <span title="(x: Int)Boolean">==</span> <span title="Int">gen</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.timeoutFuture_=" title="=&gt; Option[akka.actor.Cancellable]">timeoutFuture</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#akka.actor;FSM.timeoutFuture_=" title="=&gt; Option[akka.actor.Cancellable]">timeoutFuture</a>.<span title="=&gt; akka.actor.Cancellable">get</span>.<a href="Scheduler.scala.html#akka.actor;Cancellable.cancel" title="()Boolean">cancel</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#akka.actor;FSM.timeoutFuture_=" title="(x$1: Option[akka.actor.Cancellable])Unit">timeoutFuture</a> = <span title="None.type">None</span>
        <span class="delimiter">}</span>
        <a href="#akka.actor;FSM.generation_=" title="(x$1: Long)Unit">generation</a> <span title="(x: Int)Long">+=</span> <span title="Int(1)" class="int">1</span>
        <span title="Any" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#akka.actor;FSM.receive;$anonfun.isDefinedAt.repeat" title="Boolean">repeat</a><span class="delimiter">)</span> <span class="delimiter">{</span>
          <a href="#akka.actor;FSM.timers" title="=&gt; scala.collection.mutable.Map[String,akka.actor.FSM.Timer]">timers</a> <span title="(key: String)FSM.this.timers.type">-=</span> <a href="#akka.actor;FSM.receive;$anonfun.isDefinedAt.name" title="String">name</a>
        <span class="delimiter">}</span>
        <a href="#akka.actor;FSM.processMsg" title="(value: Any, source: AnyRef)Unit">processMsg</a><span class="delimiter">(</span><a href="#akka.actor;FSM.receive;$anonfun.isDefinedAt.msg" title="Any">msg</a>, <a href="#akka.actor;FSM.receive;$anonfun.isDefinedAt.t" title="akka.actor.FSM.Timer">t</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> SubscribeTransitionCallBack<span class="delimiter">(</span><span title="akka.actor.ActorRef">actorRef</span><span class="delimiter">)</span> ⇒
      <span class="comment">// TODO Use context.watch(actor) and receive Terminated(actor) to clean up list</span>
      <a href="../routing/Listeners.scala.html#akka.routing;Listeners.listeners" title="=&gt; java.util.Set[akka.actor.ActorRef]">listeners</a>.<span title="(x$1: akka.actor.ActorRef)Boolean">add</span><span class="delimiter">(</span><span title="akka.actor.ActorRef">actorRef</span><span class="delimiter">)</span>
      <span class="comment">// send current state back as reference point</span>
      <a href="package.scala.html#akka.actor.package.actorRef2Scala" title="implicit akka.actor.package.actorRef2Scala : (ref: akka.actor.ActorRef)akka.actor.ScalaActorRef">actorRef</a> <a href="ActorRef.scala.html#akka.actor;ScalaActorRef.!" title="(message: Any)(implicit sender: akka.actor.ActorRef)Unit">!</a> <a href="#akka.actor.FSM.CurrentState.readResolve" title="(fsmRef: akka.actor.ActorRef, state: S)akka.actor.FSM.CurrentState[S]">CurrentState</a><span class="delimiter">(</span><a href="Actor.scala.html#akka.actor;Actor.self" title="=&gt; akka.actor.ActorRef">self</a>, <a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a><span class="delimiter">)</span>
    <span class="keyword">case</span> Listen<span class="delimiter">(</span><span title="akka.actor.ActorRef">actorRef</span><span class="delimiter">)</span> ⇒
      <span class="comment">// TODO Use context.watch(actor) and receive Terminated(actor) to clean up list</span>
      <a href="../routing/Listeners.scala.html#akka.routing;Listeners.listeners" title="=&gt; java.util.Set[akka.actor.ActorRef]">listeners</a>.<span title="(x$1: akka.actor.ActorRef)Boolean">add</span><span class="delimiter">(</span><span title="akka.actor.ActorRef">actorRef</span><span class="delimiter">)</span>
      <span class="comment">// send current state back as reference point</span>
      <a href="package.scala.html#akka.actor.package.actorRef2Scala" title="implicit akka.actor.package.actorRef2Scala : (ref: akka.actor.ActorRef)akka.actor.ScalaActorRef">actorRef</a> <a href="ActorRef.scala.html#akka.actor;ScalaActorRef.!" title="(message: Any)(implicit sender: akka.actor.ActorRef)Unit">!</a> <a href="#akka.actor.FSM.CurrentState.readResolve" title="(fsmRef: akka.actor.ActorRef, state: S)akka.actor.FSM.CurrentState[S]">CurrentState</a><span class="delimiter">(</span><a href="Actor.scala.html#akka.actor;Actor.self" title="=&gt; akka.actor.ActorRef">self</a>, <a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a><span class="delimiter">)</span>
    <span class="keyword">case</span> UnsubscribeTransitionCallBack<span class="delimiter">(</span><span title="akka.actor.ActorRef">actorRef</span><span class="delimiter">)</span> ⇒
      <a href="../routing/Listeners.scala.html#akka.routing;Listeners.listeners" title="=&gt; java.util.Set[akka.actor.ActorRef]">listeners</a>.<span title="(x$1: Any)Boolean">remove</span><span title="Unit" class="delimiter">(</span><span title="akka.actor.ActorRef">actorRef</span><span class="delimiter">)</span>
    <span class="keyword">case</span> Deafen<span class="delimiter">(</span><span title="akka.actor.ActorRef">actorRef</span><span class="delimiter">)</span> ⇒
      <a href="../routing/Listeners.scala.html#akka.routing;Listeners.listeners" title="=&gt; java.util.Set[akka.actor.ActorRef]">listeners</a>.<span title="(x$1: Any)Boolean">remove</span><span title="Unit" class="delimiter">(</span><span title="akka.actor.ActorRef">actorRef</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="Any" id="akka.actor;FSM.receive;$anonfun.isDefinedAt.value">value</a> ⇒ <span title="Boolean(true)" class="delimiter">{</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.timeoutFuture_=" title="=&gt; Option[akka.actor.Cancellable]">timeoutFuture</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#akka.actor;FSM.timeoutFuture_=" title="=&gt; Option[akka.actor.Cancellable]">timeoutFuture</a>.<span title="=&gt; akka.actor.Cancellable">get</span>.<a href="Scheduler.scala.html#akka.actor;Cancellable.cancel" title="()Boolean">cancel</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <a href="#akka.actor;FSM.timeoutFuture_=" title="(x$1: Option[akka.actor.Cancellable])Unit">timeoutFuture</a> = <span title="None.type">None</span>
      <span class="delimiter">}</span>
      <a href="#akka.actor;FSM.generation_=" title="(x$1: Long)Unit">generation</a> <span title="(x: Int)Long">+=</span> <span title="Int(1)" class="int">1</span>
      <a href="#akka.actor;FSM.processMsg" title="(value: Any, source: AnyRef)Unit">processMsg</a><span class="delimiter">(</span><a href="#akka.actor;FSM.receive;$anonfun.isDefinedAt.value" title="Any">value</a>, <a href="Actor.scala.html#akka.actor;Actor.sender" title="()akka.actor.ActorRef">sender</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(value: Any, source: AnyRef)Unit" id="akka.actor;FSM.processMsg">processMsg</a><span class="delimiter">(</span><a title="Any" id="akka.actor;FSM.processMsg.value">value</a>: <span title="Any">Any</span>, <a title="AnyRef" id="akka.actor;FSM.processMsg.source">source</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="akka.actor.FSM.Event[D]" id="akka.actor;FSM.processMsg.event">event</a> = <a href="#akka.actor.FSM.Event.readResolve" title="(event: Any, stateData: D)akka.actor.FSM.Event[D]">Event</a><span class="delimiter">(</span><a href="#akka.actor;FSM.processMsg.value" title="Any">value</a>, <a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateData" title="=&gt; D">stateData</a><span class="delimiter">)</span>
    <a href="#akka.actor;FSM.processEvent" title="(event: FSM.this.Event, source: AnyRef)Unit">processEvent</a><span class="delimiter">(</span><a href="#akka.actor;FSM.processMsg.event" title="akka.actor.FSM.Event[D]">event</a>, <a href="#akka.actor;FSM.processMsg.source" title="AnyRef">source</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span>akka<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(event: FSM.this.Event, source: AnyRef)Unit" id="akka.actor;FSM.processEvent">processEvent</a><span class="delimiter">(</span><a title="FSM.this.Event" id="akka.actor;FSM.processEvent.event">event</a>: <a href="#akka.actor.FSM.Event.readResolve" title="FSM.this.Event">Event</a>, <a title="AnyRef" id="akka.actor;FSM.processEvent.source">source</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="PartialFunction[akka.actor.FSM.Event[D],akka.actor.FSM.State[S,D]]" id="akka.actor;FSM.processEvent.stateFunc">stateFunc</a> = <a href="#akka.actor;FSM.stateFunctions" title="(key: S)PartialFunction[akka.actor.FSM.Event[D],akka.actor.FSM.State[S,D]]">stateFunctions</a><span class="delimiter">(</span><a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="akka.actor.FSM.State[S,D]" id="akka.actor;FSM.processEvent.nextState">nextState</a> = <span title="akka.actor.FSM.State[S,D]" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.processEvent.stateFunc" title="PartialFunction[akka.actor.FSM.Event[D],akka.actor.FSM.State[S,D]]">stateFunc</a> <span title="(x: akka.actor.FSM.Event[D])Boolean">isDefinedAt</span> <a href="#akka.actor;FSM.processEvent.event" title="FSM.this.Event">event</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#akka.actor;FSM.processEvent.stateFunc" title="(v1: akka.actor.FSM.Event[D])akka.actor.FSM.State[S,D]">stateFunc</a><span class="delimiter">(</span><a href="#akka.actor;FSM.processEvent.event" title="FSM.this.Event">event</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span class="comment">// handleEventDefault ensures that this is always defined</span>
      <a href="#akka.actor;FSM.handleEvent_=" title="(v1: FSM.this.Event)FSM.this.State">handleEvent</a><span class="delimiter">(</span><a href="#akka.actor;FSM.processEvent.event" title="FSM.this.Event">event</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#akka.actor;FSM.applyState" title="(nextState: FSM.this.State)Unit">applyState</a><span class="delimiter">(</span><a href="#akka.actor;FSM.processEvent.nextState" title="akka.actor.FSM.State[S,D]">nextState</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span>akka<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(nextState: FSM.this.State)Unit" id="akka.actor;FSM.applyState">applyState</a><span class="delimiter">(</span><a title="FSM.this.State" id="akka.actor;FSM.applyState.nextState">nextState</a>: <a href="#akka.actor.FSM.State.readResolve" title="FSM.this.State">State</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <a href="#akka.actor;FSM.applyState.nextState" title="FSM.this.State">nextState</a>.<a href="#akka.actor.FSM.State.apply$default$4" title="=&gt; Option[akka.actor.FSM.Reason]">stopReason</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="None.type">None</span> ⇒ <a href="#akka.actor;FSM.makeTransition" title="(nextState: FSM.this.State)Unit">makeTransition</a><span class="delimiter">(</span><a href="#akka.actor;FSM.applyState.nextState" title="FSM.this.State">nextState</a><span class="delimiter">)</span>
      <span class="keyword">case</span> _ ⇒
        <a href="#akka.actor;FSM.applyState.nextState" title="FSM.this.State">nextState</a>.<a href="#akka.actor.FSM.State.apply$default$5" title="=&gt; List[Any]">replies</a>.<span title="=&gt; List[Any]">reverse</span> <span title="(f: Any =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="Any" id="akka.actor;FSM.applyState.$anonfun.r">r</a> ⇒ <a href="Actor.scala.html#akka.actor;Actor.sender" title="()akka.actor.ActorRef">sender</a><a href="package.scala.html#akka.actor.package.actorRef2Scala" title="implicit akka.actor.package.actorRef2Scala : (ref: akka.actor.ActorRef)akka.actor.ScalaActorRef" class="delimiter">(</a><span class="delimiter">)</span> <a href="ActorRef.scala.html#akka.actor;ScalaActorRef.!" title="(message: Any)(implicit sender: akka.actor.ActorRef)Unit">!</a> <a href="#akka.actor;FSM.applyState.$anonfun.r" title="Any">r</a> <span class="delimiter">}</span>
        <a href="#akka.actor;FSM.terminate" title="(nextState: FSM.this.State)Unit">terminate</a><span class="delimiter">(</span><a href="#akka.actor;FSM.applyState.nextState" title="FSM.this.State">nextState</a><span class="delimiter">)</span>
        <a href="Actor.scala.html#akka.actor;Actor.context" title="=&gt; akka.actor.ActorContext">context</a>.<a href="ActorRefProvider.scala.html#akka.actor;ActorRefFactory.stop" title="(actor: akka.actor.ActorRef)Unit">stop</a><span class="delimiter">(</span><a href="Actor.scala.html#akka.actor;Actor.self" title="=&gt; akka.actor.ActorRef">self</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span>akka<span class="delimiter">]</span> <span class="keyword">def</span> <a title="(nextState: FSM.this.State)Unit" id="akka.actor;FSM.makeTransition">makeTransition</a><span class="delimiter">(</span><a title="FSM.this.State" id="akka.actor;FSM.makeTransition.nextState">nextState</a>: <a href="#akka.actor.FSM.State.readResolve" title="FSM.this.State">State</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#akka.actor;FSM.stateFunctions" title="=&gt; scala.collection.mutable.Map[S,PartialFunction[akka.actor.FSM.Event[D],akka.actor.FSM.State[S,D]]]">stateFunctions</a>.<span title="(key: S)Boolean">contains</span><span class="delimiter">(</span><a href="#akka.actor;FSM.makeTransition.nextState" title="FSM.this.State">nextState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#akka.actor;FSM.terminate" title="(nextState: FSM.this.State)Unit">terminate</a><span class="delimiter">(</span><a href="#akka.actor;FSM.stay" title="()FSM.this.State">stay</a> <a href="#akka.actor.FSM;State.withStopReason" title="(reason: akka.actor.FSM.Reason)akka.actor.FSM.State[S,D]">withStopReason</a> <a href="#akka.actor.FSM.Failure.readResolve" title="(cause: Any)akka.actor.FSM.Failure">Failure</a><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;Next state %s does not exist&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><a href="#akka.actor;FSM.makeTransition.nextState" title="FSM.this.State">nextState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#akka.actor;FSM.makeTransition.nextState" title="FSM.this.State">nextState</a>.<a href="#akka.actor.FSM.State.apply$default$5" title="=&gt; List[Any]">replies</a>.<span title="=&gt; List[Any]">reverse</span> <span title="(f: Any =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="Any" id="akka.actor;FSM.makeTransition.$anonfun.r">r</a> ⇒ <a href="Actor.scala.html#akka.actor;Actor.sender" title="()akka.actor.ActorRef">sender</a><a href="package.scala.html#akka.actor.package.actorRef2Scala" title="implicit akka.actor.package.actorRef2Scala : (ref: akka.actor.ActorRef)akka.actor.ScalaActorRef" class="delimiter">(</a><span class="delimiter">)</span> <a href="ActorRef.scala.html#akka.actor;ScalaActorRef.!" title="(message: Any)(implicit sender: akka.actor.ActorRef)Unit">!</a> <a href="#akka.actor;FSM.makeTransition.$anonfun.r" title="Any">r</a> <span class="delimiter">}</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#akka.actor;FSM.makeTransition.nextState" title="FSM.this.State">nextState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#akka.actor;FSM" title="FSM.this.type" class="keyword">this</a>.<a href="#akka.actor;FSM.nextState_=" title="(x$1: FSM.this.State)Unit">nextState</a> = <a href="#akka.actor;FSM.makeTransition.nextState" title="FSM.this.State">nextState</a>
        <a href="#akka.actor;FSM.handleTransition" title="(prev: S, next: S)Unit">handleTransition</a><span class="delimiter">(</span><a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a>, <a href="#akka.actor;FSM.makeTransition.nextState" title="FSM.this.State">nextState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a><span class="delimiter">)</span>
        <a href="../routing/Listeners.scala.html#akka.routing;Listeners.gossip" title="(msg: Any)(implicit sender: akka.actor.ActorRef)Unit">gossip</a><a href="Actor.scala.html#akka.actor;Actor.self" title="=&gt; akka.actor.ActorRef" class="delimiter">(</a><a href="#akka.actor.FSM.Transition.readResolve" title="(fsmRef: akka.actor.ActorRef, from: S, to: S)akka.actor.FSM.Transition[S]">Transition</a><span class="delimiter">(</span><a href="Actor.scala.html#akka.actor;Actor.self" title="=&gt; akka.actor.ActorRef">self</a>, <a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a>, <a href="#akka.actor;FSM.makeTransition.nextState" title="FSM.this.State">nextState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#akka.actor;FSM" title="FSM.this.type" class="keyword">this</a>.<a href="#akka.actor;FSM.nextState_=" title="(x$1: FSM.this.State)Unit">nextState</a> = <span title="Null(null)" class="keyword">null</span>
      <span class="delimiter">}</span>
      <a href="#akka.actor;FSM.currentState_=" title="(x$1: FSM.this.State)Unit">currentState</a> = <a href="#akka.actor;FSM.makeTransition.nextState" title="FSM.this.State">nextState</a>
      <span class="keyword">val</span> <a title="Option[scala.concurrent.duration.FiniteDuration]" id="akka.actor;FSM.makeTransition.timeout">timeout</a> = <span title="Option[scala.concurrent.duration.FiniteDuration]" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM.State.apply$default$3" title="=&gt; Option[scala.concurrent.duration.FiniteDuration]">timeout</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM.State.apply$default$3" title="=&gt; Option[scala.concurrent.duration.FiniteDuration]">timeout</a> <span class="keyword">else</span> <a href="#akka.actor;FSM.stateTimeouts" title="(key: S)Option[scala.concurrent.duration.FiniteDuration]">stateTimeouts</a><span class="delimiter">(</span><a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.makeTransition.timeout" title="Option[scala.concurrent.duration.FiniteDuration]">timeout</a>.<span title="=&gt; Boolean">isDefined</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="scala.concurrent.duration.FiniteDuration" id="akka.actor;FSM.makeTransition.t">t</a> = <a href="#akka.actor;FSM.makeTransition.timeout" title="Option[scala.concurrent.duration.FiniteDuration]">timeout</a>.<span title="=&gt; scala.concurrent.duration.FiniteDuration">get</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.makeTransition.t" title="scala.concurrent.duration.FiniteDuration">t</a>.<span title="()Boolean">isFinite</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#akka.actor;FSM.makeTransition.t" title="scala.concurrent.duration.FiniteDuration">t</a>.<span title="=&gt; Long">length</span> <span title="(x: Int)Boolean">&gt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
          <span class="keyword">import</span> <a href="Actor.scala.html#akka.actor;Actor.context" title="=&gt; akka.actor.ActorContext">context</a>.dispatcher
          <a href="#akka.actor;FSM.timeoutFuture_=" title="(x$1: Option[akka.actor.Cancellable])Unit">timeoutFuture</a> = <span title="(x: akka.actor.Cancellable)Some[akka.actor.Cancellable]">Some</span><span class="delimiter">(</span><a href="Actor.scala.html#akka.actor;Actor.context" title="=&gt; akka.actor.ActorContext">context</a>.<a href="ActorCell.scala.html#akka.actor;ActorContext.system" title="=&gt; akka.actor.ActorSystem">system</a>.<a href="ActorSystem.scala.html#akka.actor;ActorSystem.scheduler" title="=&gt; akka.actor.Scheduler">scheduler</a>.<a href="Scheduler.scala.html#akka.actor;Scheduler.scheduleOnce(a2d55b51db)" title="(delay: scala.concurrent.duration.FiniteDuration, receiver: akka.actor.ActorRef, message: Any)(implicit executor: scala.concurrent.ExecutionContext, implicit sender: akka.actor.ActorRef)akka.actor.Cancellable">scheduleOnce</a><a href="ActorCell.scala.html#akka.actor;ActorContext.dispatcher" title="=&gt; scala.concurrent.ExecutionContextExecutor" class="delimiter">(</a><a href="#akka.actor;FSM.makeTransition.t" title="scala.concurrent.duration.FiniteDuration">t</a>, <a href="Actor.scala.html#akka.actor;Actor.self" title="=&gt; akka.actor.ActorRef">self</a>, <a href="#akka.actor.FSM.TimeoutMarker.readResolve" title="(generation: Long)akka.actor.FSM.TimeoutMarker">TimeoutMarker</a><span class="delimiter">(</span><a href="#akka.actor;FSM.generation_=" title="=&gt; Long">generation</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Call `onTermination` hook; if you want to retain this behavior when
   * overriding make sure to call `super.postStop()`.
   *
   * Please note that this method is called by default from `preRestart()`,
   * so override that one if `onTermination` shall not be called during
   * restart.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()Unit" id="akka.actor;FSM.postStop">postStop</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <span class="comment">/*
     * setting this instance’s state to terminated does no harm during restart
     * since the new instance will initialize fresh using startWith()
     */</span>
    <a href="#akka.actor;FSM.terminate" title="(nextState: FSM.this.State)Unit">terminate</a><span class="delimiter">(</span><a href="#akka.actor;FSM.stay" title="()FSM.this.State">stay</a> <a href="#akka.actor.FSM;State.withStopReason" title="(reason: akka.actor.FSM.Reason)akka.actor.FSM.State[S,D]">withStopReason</a> <a href="#akka.actor.FSM.Shutdown.readResolve" title="akka.actor.FSM.Shutdown.type">Shutdown</a><span class="delimiter">)</span>
    <a href="#akka.actor;FSM" title="akka.actor.FSM[S,D]" class="keyword">super</a>.<a href="Actor.scala.html#akka.actor;Actor.postStop" title="()Unit">postStop</a><span class="delimiter">(</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(nextState: FSM.this.State)Unit" id="akka.actor;FSM.terminate">terminate</a><span class="delimiter">(</span><a title="FSM.this.State" id="akka.actor;FSM.terminate.nextState">nextState</a>: <a href="#akka.actor.FSM.State.readResolve" title="FSM.this.State">State</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM.State.apply$default$4" title="=&gt; Option[akka.actor.FSM.Reason]">stopReason</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="akka.actor.FSM.Reason" id="akka.actor;FSM.terminate.reason">reason</a> = <a href="#akka.actor;FSM.terminate.nextState" title="FSM.this.State">nextState</a>.<a href="#akka.actor.FSM.State.apply$default$4" title="=&gt; Option[akka.actor.FSM.Reason]">stopReason</a>.<span title="=&gt; akka.actor.FSM.Reason">get</span>
      <a href="#akka.actor;FSM.logTermination" title="(reason: akka.actor.FSM.Reason)Unit">logTermination</a><span class="delimiter">(</span><a href="#akka.actor;FSM.terminate.reason" title="akka.actor.FSM.Reason">reason</a><span class="delimiter">)</span>
      <span class="keyword">for</span> <span class="delimiter">(</span><a title="akka.actor.FSM.Timer" id="akka.actor;FSM.terminate.$anonfun.timer">timer</a> ← <a href="#akka.actor;FSM.timers" title="=&gt; scala.collection.mutable.Map[String,akka.actor.FSM.Timer]">timers</a>.<span title="(f: akka.actor.FSM.Timer =&gt; Unit)Unit">values</span><span class="delimiter">)</span> <a href="#akka.actor;FSM.terminate.$anonfun.timer" title="akka.actor.FSM.Timer">timer</a>.<a href="#akka.actor.FSM;Timer.cancel" title="()Unit">cancel</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#akka.actor;FSM.timers" title="=&gt; scala.collection.mutable.Map[String,akka.actor.FSM.Timer]">timers</a>.<span title="()Unit">clear</span><span class="delimiter">(</span><span class="delimiter">)</span>
      <a href="#akka.actor;FSM.currentState_=" title="(x$1: FSM.this.State)Unit">currentState</a> = <a href="#akka.actor;FSM.terminate.nextState" title="FSM.this.State">nextState</a>

      <span class="keyword">val</span> <a title="akka.actor.FSM.StopEvent[S,D]" id="akka.actor;FSM.terminate.stopEvent">stopEvent</a> = <a href="#akka.actor.FSM.StopEvent.readResolve" title="(reason: akka.actor.FSM.Reason, currentState: S, stateData: D)akka.actor.FSM.StopEvent[S,D]">StopEvent</a><span class="delimiter">(</span><a href="#akka.actor;FSM.terminate.reason" title="akka.actor.FSM.Reason">reason</a>, <a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateName" title="=&gt; S">stateName</a>, <a href="#akka.actor;FSM.currentState_=" title="=&gt; FSM.this.State">currentState</a>.<a href="#akka.actor.FSM;State.stateData" title="=&gt; D">stateData</a><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;FSM.terminateEvent_=" title="=&gt; PartialFunction[FSM.this.StopEvent,Unit]">terminateEvent</a>.<span title="(x: FSM.this.StopEvent)Boolean">isDefinedAt</span><span class="delimiter">(</span><a href="#akka.actor;FSM.terminate.stopEvent" title="akka.actor.FSM.StopEvent[S,D]">stopEvent</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#akka.actor;FSM.terminateEvent_=" title="(v1: FSM.this.StopEvent)Unit">terminateEvent</a><span class="delimiter">(</span><a href="#akka.actor;FSM.terminate.stopEvent" title="akka.actor.FSM.StopEvent[S,D]">stopEvent</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * By default [[FSM.Failure]] is logged at error level and other reason
   * types are not logged. It is possible to override this behavior.
   */</span>
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="(reason: akka.actor.FSM.Reason)Unit" id="akka.actor;FSM.logTermination">logTermination</a><span class="delimiter">(</span><a title="akka.actor.FSM.Reason" id="akka.actor;FSM.logTermination.reason">reason</a>: <a href="#akka.actor.FSM;Reason" title="akka.actor.FSM.Reason">Reason</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.actor;FSM.logTermination.reason" title="akka.actor.FSM.Reason">reason</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> Failure<span class="delimiter">(</span><a title="Throwable" id="akka.actor;FSM.logTermination.ex">ex</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span> ⇒ <a href="Actor.scala.html#akka.actor;ActorLogging.log" title="=&gt; akka.event.LoggingAdapter">log</a>.<a href="../event/Logging.scala.html#akka.event;LoggingAdapter.error(de736aeaab)" title="(cause: Throwable, message: String)Unit">error</a><span class="delimiter">(</span><a href="#akka.actor;FSM.logTermination.ex" title="Throwable">ex</a>, <span title="String(&quot;terminating due to Failure&quot;)" class="string">&quot;terminating due to Failure&quot;</span><span class="delimiter">)</span>
    <span class="keyword">case</span> Failure<span class="delimiter">(</span><a title="AnyRef" id="akka.actor;FSM.logTermination.msg">msg</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>   ⇒ <a href="Actor.scala.html#akka.actor;ActorLogging.log" title="=&gt; akka.event.LoggingAdapter">log</a>.<a href="../event/Logging.scala.html#akka.event;LoggingAdapter.error(cc2e600322)" title="(message: String)Unit">error</a><span class="delimiter">(</span><a href="#akka.actor;FSM.logTermination.msg" title="AnyRef">msg</a>.<span title="()String">toString</span><span class="delimiter">)</span>
    <span class="keyword">case</span> _                      ⇒
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Stackable trait for [[akka.actor.FSM]] which adds a rolling event log and
 * debug logging capabilities (analogous to [[akka.event.LoggingReceive]]).
 *
 * @since 1.2
 */</span>
<span class="keyword">trait</span> <a title="trait LoggingFSM[S, D] extends AnyRef with akka.actor.FSM[S,D]" id="akka.actor;LoggingFSM">LoggingFSM</a><span class="delimiter">[</span><a title="" id="akka.actor;LoggingFSM;S">S</a>, <a title="" id="akka.actor;LoggingFSM;D">D</a><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="#akka.actor;FSM" title="akka.actor.FSM[S,D]">FSM</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">this</span>: Actor ⇒

  <span class="keyword">import</span> <a href="#akka.actor.FSM" title="akka.actor.FSM.type">FSM</a>._

  <span class="keyword">def</span> <a title="=&gt; Int" id="akka.actor;LoggingFSM.logDepth">logDepth</a>: <span title="Int">Int</span> = <span title="Int(0)" class="int">0</span>

  <span class="keyword">private</span><span class="delimiter">[</span>akka<span class="delimiter">]</span> <span class="keyword">override</span> <span class="keyword">val</span> <a title="Boolean" id="akka.actor;LoggingFSM.debugEvent">debugEvent</a> = <a href="Actor.scala.html#akka.actor;Actor.context" title="=&gt; akka.actor.ActorContext">context</a>.<a href="ActorCell.scala.html#akka.actor;ActorContext.system" title="=&gt; akka.actor.ActorSystem">system</a>.<a href="ActorSystem.scala.html#akka.actor;ActorSystem.settings" title="=&gt; akka.actor.ActorSystem.Settings">settings</a>.<a href="ActorSystem.scala.html#akka.actor.ActorSystem;Settings.FsmDebugEvent" title="=&gt; Boolean">FsmDebugEvent</a>

  <span class="keyword">private</span> <span class="keyword">val</span> <a title="Array[LoggingFSM.this.Event]" id="akka.actor;LoggingFSM.events">events</a> = <span title="Array[LoggingFSM.this.Event]" class="keyword">new</span> <span title="Array[LoggingFSM.this.Event]">Array</span><span class="delimiter">[</span>Event<span class="delimiter">]</span><span class="delimiter">(</span><a href="#akka.actor;LoggingFSM.logDepth" title="=&gt; Int">logDepth</a><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="Array[AnyRef]" id="akka.actor;LoggingFSM.states">states</a> = <span title="Array[AnyRef]" class="keyword">new</span> <span title="Array[AnyRef]">Array</span><span class="delimiter">[</span>AnyRef<span class="delimiter">]</span><span class="delimiter">(</span><a href="#akka.actor;LoggingFSM.logDepth" title="=&gt; Int">logDepth</a><span class="delimiter">)</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="akka.actor;LoggingFSM.pos_=">pos</a> = <span title="Int(0)" class="int">0</span>
  <span class="keyword">private</span> <span class="keyword">var</span> <a title="Boolean" id="akka.actor;LoggingFSM.full_=">full</a> = <span title="Boolean(false)" class="keyword">false</span>

  <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Unit" id="akka.actor;LoggingFSM.advance">advance</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Int" id="akka.actor;LoggingFSM.advance.n">n</a> = <a href="#akka.actor;LoggingFSM.pos_=" title="=&gt; Int">pos</a> <span title="(x: Int)Int">+</span> <span title="Int(1)" class="int">1</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;LoggingFSM.advance.n" title="Int">n</a> <span title="(x: Int)Boolean">==</span> <a href="#akka.actor;LoggingFSM.logDepth" title="=&gt; Int">logDepth</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#akka.actor;LoggingFSM.full_=" title="(x$1: Boolean)Unit">full</a> = <span title="Boolean(true)" class="keyword">true</span>
      <a href="#akka.actor;LoggingFSM.pos_=" title="(x$1: Int)Unit">pos</a> = <span title="Int(0)" class="int">0</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <a href="#akka.actor;LoggingFSM.pos_=" title="(x$1: Int)Unit">pos</a> = <a href="#akka.actor;LoggingFSM.advance.n" title="Int">n</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">private</span><span class="delimiter">[</span>akka<span class="delimiter">]</span> <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="(event: LoggingFSM.this.Event, source: AnyRef)Unit" id="akka.actor;LoggingFSM.processEvent">processEvent</a><span class="delimiter">(</span><a title="LoggingFSM.this.Event" id="akka.actor;LoggingFSM.processEvent.event">event</a>: <a href="#akka.actor.FSM.Event.readResolve" title="LoggingFSM.this.Event">Event</a>, <a title="AnyRef" id="akka.actor;LoggingFSM.processEvent.source">source</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;LoggingFSM.debugEvent" title="=&gt; Boolean">debugEvent</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="String" id="akka.actor;LoggingFSM.processEvent.srcstr">srcstr</a> = <a href="#akka.actor;LoggingFSM.processEvent.source" title="AnyRef">source</a> <span title="String" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a title="String" id="akka.actor;LoggingFSM.processEvent.srcstr.s">s</a>: <span title="String">String</span>            ⇒ <a href="#akka.actor;LoggingFSM.processEvent.srcstr.s" title="String">s</a>
        <span class="keyword">case</span> Timer<span class="delimiter">(</span><a title="String" id="akka.actor;LoggingFSM.processEvent.srcstr.name">name</a>, _, _, _<span class="delimiter">)</span> ⇒ <span title="String(&quot;timer &quot;)" class="string">&quot;timer &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.actor;LoggingFSM.processEvent.srcstr.name" title="String">name</a>
        <span class="keyword">case</span> <a title="akka.actor.ActorRef" id="akka.actor;LoggingFSM.processEvent.srcstr.a">a</a>: <a href="ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a>          ⇒ <a href="#akka.actor;LoggingFSM.processEvent.srcstr.a" title="akka.actor.ActorRef">a</a>.<a href="ActorRef.scala.html#akka.actor;ActorRef.toString" title="()String">toString</a>
        <span class="keyword">case</span> _                    ⇒ <span title="String(&quot;unknown&quot;)" class="string">&quot;unknown&quot;</span>
      <span class="delimiter">}</span>
      <a href="Actor.scala.html#akka.actor;ActorLogging.log" title="=&gt; akka.event.LoggingAdapter">log</a>.<a href="../event/Logging.scala.html#akka.event;LoggingAdapter.debug(cc2e600322)" title="(message: String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;processing &quot;)" class="string">&quot;processing &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.actor;LoggingFSM.processEvent.event" title="LoggingFSM.this.Event">event</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; from &quot;)" class="string">&quot; from &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.actor;LoggingFSM.processEvent.srcstr" title="String">srcstr</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;LoggingFSM.logDepth" title="=&gt; Int">logDepth</a> <span title="(x: Int)Boolean">&gt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
      <a href="#akka.actor;LoggingFSM.states" title="(i: Int, x: AnyRef)Unit">states</a><span class="delimiter">(</span><a href="#akka.actor;LoggingFSM.pos_=" title="=&gt; Int">pos</a><span class="delimiter">)</span> = <a href="#akka.actor;FSM.stateName" title="=&gt; S">stateName</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="AnyRef" class="delimiter">[</span><span title="AnyRef">AnyRef</span><span class="delimiter">]</span>
      <a href="#akka.actor;LoggingFSM.events" title="(i: Int, x: LoggingFSM.this.Event)Unit">events</a><span class="delimiter">(</span><a href="#akka.actor;LoggingFSM.pos_=" title="=&gt; Int">pos</a><span class="delimiter">)</span> = <a href="#akka.actor;LoggingFSM.processEvent.event" title="LoggingFSM.this.Event">event</a>
      <a href="#akka.actor;LoggingFSM.advance" title="()Unit">advance</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a title="S" id="akka.actor;LoggingFSM.processEvent.oldState">oldState</a> = <a href="#akka.actor;FSM.stateName" title="=&gt; S">stateName</a>
    <a href="#akka.actor;LoggingFSM" title="actor extends akka.actor.LoggingFSM[S,D] with akka.actor.Actor" class="keyword">super</a>.<a href="#akka.actor;FSM.processEvent" title="(event: LoggingFSM.this.Event, source: AnyRef)Unit">processEvent</a><span class="delimiter">(</span><a href="#akka.actor;LoggingFSM.processEvent.event" title="LoggingFSM.this.Event">event</a>, <a href="#akka.actor;LoggingFSM.processEvent.source" title="AnyRef">source</a><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="S" id="akka.actor;LoggingFSM.processEvent.newState">newState</a> = <a href="#akka.actor;FSM.stateName" title="=&gt; S">stateName</a>

    <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;LoggingFSM.debugEvent" title="=&gt; Boolean">debugEvent</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <a href="#akka.actor;LoggingFSM.processEvent.oldState" title="S">oldState</a> <span title="(x$1: Any)Boolean">!=</span> <a href="#akka.actor;LoggingFSM.processEvent.newState" title="S">newState</a><span class="delimiter">)</span>
      <a href="Actor.scala.html#akka.actor;ActorLogging.log" title="=&gt; akka.event.LoggingAdapter">log</a>.<a href="../event/Logging.scala.html#akka.event;LoggingAdapter.debug(cc2e600322)" title="(message: String)Unit">debug</a><span class="delimiter">(</span><span title="String(&quot;transition &quot;)" class="string">&quot;transition &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.actor;LoggingFSM.processEvent.oldState" title="S">oldState</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; -&gt; &quot;)" class="string">&quot; -&gt; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.actor;LoggingFSM.processEvent.newState" title="S">newState</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Retrieve current rolling log in oldest-first order. The log is filled with
   * each incoming event before processing by the user supplied state handler.
   * The log entries are lost when this actor is restarted.
   */</span>
  <span class="keyword">protected</span> <span class="keyword">def</span> <a title="=&gt; IndexedSeq[akka.actor.FSM.LogEntry[S,D]]" id="akka.actor;LoggingFSM.getLog">getLog</a>: <span title="IndexedSeq[akka.actor.FSM.LogEntry[S,D]]">IndexedSeq</span><span class="delimiter">[</span>LogEntry<span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Array[akka.actor.FSM.LogEntry[S,D]]" id="akka.actor;LoggingFSM.getLog.log">log</a> = <a href="#akka.actor;LoggingFSM.events" title="(xs: Array[LoggingFSM.this.Event])scala.collection.mutable.ArrayOps[LoggingFSM.this.Event]">events</a> <span title="(xs: Array[(LoggingFSM.this.Event, AnyRef)])scala.collection.mutable.ArrayOps[(LoggingFSM.this.Event, AnyRef)]">zip</span> <a href="#akka.actor;LoggingFSM.states" title="(xs: Array[AnyRef])scala.collection.mutable.WrappedArray[AnyRef]">states</a> <span title="(xs: Array[(LoggingFSM.this.Event, AnyRef)])scala.collection.mutable.ArrayOps[(LoggingFSM.this.Event, AnyRef)]">filter</span> <span class="delimiter">(</span><a href="#akka.actor;LoggingFSM.getLog.log.$anonfun.x$2" title="(LoggingFSM.this.Event, AnyRef)">_</a>.<span title="=&gt; LoggingFSM.this.Event">_1</span> <span title="(x$1: AnyRef)Boolean">ne</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="(f: ((LoggingFSM.this.Event, AnyRef)) =&gt; akka.actor.FSM.LogEntry[S,D])(implicit bf: scala.collection.generic.CanBuildFrom[Array[(LoggingFSM.this.Event, AnyRef)],akka.actor.FSM.LogEntry[S,D],Array[akka.actor.FSM.LogEntry[S,D]]])Array[akka.actor.FSM.LogEntry[S,D]]">map</span> <span class="delimiter">(</span><a title="(LoggingFSM.this.Event, AnyRef)" id="akka.actor;LoggingFSM.getLog.log.$anonfun.x">x</a> ⇒ <a href="#akka.actor.FSM.LogEntry.readResolve" title="(stateName: S, stateData: D, event: Any)akka.actor.FSM.LogEntry[S,D]">LogEntry</a><span class="delimiter">(</span><a href="#akka.actor;LoggingFSM.getLog.log.$anonfun.x" title="(LoggingFSM.this.Event, AnyRef)">x</a>.<span title="=&gt; AnyRef">_2</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="S" class="delimiter">[</span><a href="#akka.actor;LoggingFSM;S" title="S">S</a><span class="delimiter">]</span>, <a href="#akka.actor;LoggingFSM.getLog.log.$anonfun.x" title="(LoggingFSM.this.Event, AnyRef)">x</a>.<span title="=&gt; LoggingFSM.this.Event">_1</span>.<a href="#akka.actor.FSM;Event.stateData" title="=&gt; D">stateData</a>, <a href="#akka.actor;LoggingFSM.getLog.log.$anonfun.x" title="(LoggingFSM.this.Event, AnyRef)">x</a>.<span title="=&gt; LoggingFSM.this.Event">_1</span>.<a href="#akka.actor.FSM;Event.event" title="=&gt; Any">event</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span title="IndexedSeq[akka.actor.FSM.LogEntry[S,D]]" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.actor;LoggingFSM.full_=" title="=&gt; Boolean">full</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span title="(elems: Nothing*)IndexedSeq[Nothing]">IndexedSeq</span><span class="delimiter">(</span><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[akka.actor.FSM.LogEntry[S,D]])(implicit bf: scala.collection.generic.CanBuildFrom[IndexedSeq[Nothing],akka.actor.FSM.LogEntry[S,D],IndexedSeq[akka.actor.FSM.LogEntry[S,D]]])IndexedSeq[akka.actor.FSM.LogEntry[S,D]]">++</span> <a href="#akka.actor;LoggingFSM.getLog.log" title="(xs: Array[akka.actor.FSM.LogEntry[S,D]])scala.collection.mutable.ArrayOps[akka.actor.FSM.LogEntry[S,D]]">log</a>.<span title="(n: Int)Array[akka.actor.FSM.LogEntry[S,D]]">drop</span><span title="(xs: Array[akka.actor.FSM.LogEntry[S,D]])scala.collection.mutable.ArrayOps[akka.actor.FSM.LogEntry[S,D]]" class="delimiter">(</span><a href="#akka.actor;LoggingFSM.pos_=" title="=&gt; Int">pos</a><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[akka.actor.FSM.LogEntry[S,D]])(implicit bf: scala.collection.generic.CanBuildFrom[IndexedSeq[akka.actor.FSM.LogEntry[S,D]],akka.actor.FSM.LogEntry[S,D],IndexedSeq[akka.actor.FSM.LogEntry[S,D]]])IndexedSeq[akka.actor.FSM.LogEntry[S,D]]">++</span> <a href="#akka.actor;LoggingFSM.getLog.log" title="(xs: Array[akka.actor.FSM.LogEntry[S,D]])scala.collection.mutable.ArrayOps[akka.actor.FSM.LogEntry[S,D]]">log</a>.<span title="(n: Int)Array[akka.actor.FSM.LogEntry[S,D]]">take</span><span title="(xs: Array[akka.actor.FSM.LogEntry[S,D]])scala.collection.mutable.ArrayOps[akka.actor.FSM.LogEntry[S,D]]" class="delimiter">(</span><a href="#akka.actor;LoggingFSM.pos_=" title="=&gt; Int">pos</a><span class="delimiter">)</span>
    <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
      <span title="(elems: Nothing*)IndexedSeq[Nothing]">IndexedSeq</span><span class="delimiter">(</span><span class="delimiter">)</span> <span title="(that: scala.collection.GenTraversableOnce[akka.actor.FSM.LogEntry[S,D]])(implicit bf: scala.collection.generic.CanBuildFrom[IndexedSeq[Nothing],akka.actor.FSM.LogEntry[S,D],IndexedSeq[akka.actor.FSM.LogEntry[S,D]]])IndexedSeq[akka.actor.FSM.LogEntry[S,D]]">++</span> <a href="#akka.actor;LoggingFSM.getLog.log" title="(xs: Array[akka.actor.FSM.LogEntry[S,D]])scala.collection.mutable.ArrayOps[akka.actor.FSM.LogEntry[S,D]]">log</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * Java API: compatible with lambda expressions
 *
 * This is an EXPERIMENTAL feature and is subject to change until it has received more real world testing.
 */</span>
<span class="keyword">object</span> <a title="akka.actor.AbstractFSM.type" id="akka.actor.AbstractFSM">AbstractFSM</a> <a href="#akka.actor.AbstractFSM" title="akka.actor.AbstractFSM.type" class="delimiter">{</a>
  <span class="comment">/**
   * A partial function value which does not match anything and can be used to
   * “reset” `whenUnhandled` and `onTermination` handlers.
   *
   * {{{
   * onTermination(FSM.NullFunction())
   * }}}
   */</span>
  <span class="keyword">def</span> <a title="[S, D]=&gt; PartialFunction[S,D]" id="akka.actor.AbstractFSM.NullFunction">NullFunction</a><span class="delimiter">[</span><a title="" id="akka.actor.AbstractFSM.NullFunction;S">S</a>, <a title="" id="akka.actor.AbstractFSM.NullFunction;D">D</a><span class="delimiter">]</span>: <span title="PartialFunction[S,D]">PartialFunction</span><span class="delimiter">[</span>S, D<span class="delimiter">]</span> = <a href="#akka.actor.FSM" title="akka.actor.FSM.type">FSM</a>.<a href="#akka.actor.FSM.NullFunction" title="akka.actor.FSM.NullFunction.type">NullFunction</a>
<span class="delimiter">}</span>

<span class="comment">/**
 * Java API: compatible with lambda expressions
 *
 * Finite State Machine actor abstract base class.
 *
 * This is an EXPERIMENTAL feature and is subject to change until it has received more real world testing.
 */</span>
<span title="AnyRef" class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AbstractFSM[S, D] extends AnyRef with akka.actor.FSM[S,D]" id="akka.actor;AbstractFSM">AbstractFSM</a><span class="delimiter">[</span><a title="" id="akka.actor;AbstractFSM;S">S</a>, <a title="" id="akka.actor;AbstractFSM;D">D</a><span class="delimiter">]</span> <a href="#akka.actor;AbstractFSM" title="akka.actor.AbstractFSM[S,D]" class="keyword">extends</a> <a href="#akka.actor;FSM" title="akka.actor.FSM[S,D]">FSM</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> <span class="delimiter">{</span>
  <span class="keyword">import</span> akka.japi.pf._
  <span class="keyword">import</span> akka.japi.pf.<a href="../japi/pf/FI.java.html#akka.japi.pf.FI" title="akka.japi.pf.FI.type">FI</a>._
  <span class="keyword">import</span> java.util.<span class="delimiter">{</span> List ⇒ JList <span class="delimiter">}</span>
  <span class="keyword">import</span> <a href="#akka.actor.FSM" title="akka.actor.FSM.type">FSM</a>._

  <span class="comment">/**
   * Insert a new StateFunction at the end of the processing chain for the
   * given state.
   *
   * @param stateName designator for the state
   * @param stateFunction partial function describing response to input
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(stateName: S)(stateFunction: AbstractFSM.this.StateFunction)Unit" id="akka.actor;AbstractFSM.when(4bfce7af4c)">when</a><span class="delimiter">(</span><a title="S" id="akka.actor;AbstractFSM.when(4bfce7af4c).stateName">stateName</a>: <a href="#akka.actor;AbstractFSM;S" title="S">S</a><span class="delimiter">)</span><span class="delimiter">(</span><a title="AbstractFSM.this.StateFunction" id="akka.actor;AbstractFSM.when(4bfce7af4c).stateFunction">stateFunction</a>: <span title="AbstractFSM.this.StateFunction">StateFunction</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.actor;FSM.when" title="(stateName: S, stateTimeout: scala.concurrent.duration.FiniteDuration)(stateFunction: AbstractFSM.this.StateFunction)Unit">when</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.when(4bfce7af4c).stateName" title="S">stateName</a>, <span title="Null(null)" class="keyword">null</span>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.when(4bfce7af4c).stateFunction" title="AbstractFSM.this.StateFunction">stateFunction</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Insert a new StateFunction at the end of the processing chain for the
   * given state.
   *
   * @param stateName designator for the state
   * @param stateFunctionBuilder partial function builder describing response to input
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(stateName: S, stateFunctionBuilder: akka.japi.pf.FSMStateFunctionBuilder[S,D])Unit" id="akka.actor;AbstractFSM.when(df83047e31)">when</a><span class="delimiter">(</span><a title="S" id="akka.actor;AbstractFSM.when(df83047e31).stateName">stateName</a>: <a href="#akka.actor;AbstractFSM;S" title="S">S</a>, <a title="akka.japi.pf.FSMStateFunctionBuilder[S,D]" id="akka.actor;AbstractFSM.when(df83047e31).stateFunctionBuilder">stateFunctionBuilder</a>: <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.actor;AbstractFSM.when(f5cbb4a417)" title="(stateName: S, stateTimeout: scala.concurrent.duration.FiniteDuration, stateFunctionBuilder: akka.japi.pf.FSMStateFunctionBuilder[S,D])Unit">when</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.when(df83047e31).stateName" title="S">stateName</a>, <span title="Null(null)" class="keyword">null</span>, <a href="#akka.actor;AbstractFSM.when(df83047e31).stateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">stateFunctionBuilder</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Insert a new StateFunction at the end of the processing chain for the
   * given state. If the stateTimeout parameter is set, entering this state
   * without a differing explicit timeout setting will trigger a StateTimeout
   * event; the same is true when using #stay.
   *
   * @param stateName designator for the state
   * @param stateTimeout default state timeout for this state
   * @param stateFunctionBuilder partial function builder describing response to input
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(stateName: S, stateTimeout: scala.concurrent.duration.FiniteDuration, stateFunctionBuilder: akka.japi.pf.FSMStateFunctionBuilder[S,D])Unit" id="akka.actor;AbstractFSM.when(f5cbb4a417)">when</a><span class="delimiter">(</span><a title="S" id="akka.actor;AbstractFSM.when(f5cbb4a417).stateName">stateName</a>: <a href="#akka.actor;AbstractFSM;S" title="S">S</a>,
                 <a title="scala.concurrent.duration.FiniteDuration" id="akka.actor;AbstractFSM.when(f5cbb4a417).stateTimeout">stateTimeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>,
                 <a title="akka.japi.pf.FSMStateFunctionBuilder[S,D]" id="akka.actor;AbstractFSM.when(f5cbb4a417).stateFunctionBuilder">stateFunctionBuilder</a>: <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.actor;FSM.when" title="(stateName: S, stateTimeout: scala.concurrent.duration.FiniteDuration)(stateFunction: AbstractFSM.this.StateFunction)Unit">when</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.when(f5cbb4a417).stateName" title="S">stateName</a>, <a href="#akka.actor;AbstractFSM.when(f5cbb4a417).stateTimeout" title="scala.concurrent.duration.FiniteDuration">stateTimeout</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.when(f5cbb4a417).stateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">stateFunctionBuilder</a>.<a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder.build" title="()PartialFunction[akka.actor.FSM.Event[D],akka.actor.FSM.State[S,D]]">build</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Set initial state. Call this method from the constructor before the [[#initialize]] method.
   * If different state is needed after a restart this method, followed by [[#initialize]], can
   * be used in the actor life cycle hooks [[akka.actor.Actor#preStart]] and [[akka.actor.Actor#postRestart]].
   *
   * @param stateName initial state designator
   * @param stateData initial state data
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(stateName: S, stateData: D)Unit" id="akka.actor;AbstractFSM.startWith(c530885bc6)">startWith</a><span class="delimiter">(</span><a title="S" id="akka.actor;AbstractFSM.startWith(c530885bc6).stateName">stateName</a>: <a href="#akka.actor;AbstractFSM;S" title="S">S</a>, <a title="D" id="akka.actor;AbstractFSM.startWith(c530885bc6).stateData">stateData</a>: <a href="#akka.actor;AbstractFSM;D" title="D">D</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.actor;AbstractFSM.startWith(14eae88c32)" title="(stateName: S, stateData: D, timeout: scala.concurrent.duration.FiniteDuration)Unit">startWith</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.startWith(c530885bc6).stateName" title="S">stateName</a>, <a href="#akka.actor;AbstractFSM.startWith(c530885bc6).stateData" title="D">stateData</a>, <span title="Null(null)" class="keyword">null</span>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Set initial state. Call this method from the constructor before the [[#initialize]] method.
   * If different state is needed after a restart this method, followed by [[#initialize]], can
   * be used in the actor life cycle hooks [[akka.actor.Actor#preStart]] and [[akka.actor.Actor#postRestart]].
   *
   * @param stateName initial state designator
   * @param stateData initial state data
   * @param timeout state timeout for the initial state, overriding the default timeout for that state
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(stateName: S, stateData: D, timeout: scala.concurrent.duration.FiniteDuration)Unit" id="akka.actor;AbstractFSM.startWith(14eae88c32)">startWith</a><span class="delimiter">(</span><a title="S" id="akka.actor;AbstractFSM.startWith(14eae88c32).stateName">stateName</a>: <a href="#akka.actor;AbstractFSM;S" title="S">S</a>, <a title="D" id="akka.actor;AbstractFSM.startWith(14eae88c32).stateData">stateData</a>: <a href="#akka.actor;AbstractFSM;D" title="D">D</a>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.actor;AbstractFSM.startWith(14eae88c32).timeout">timeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.actor;FSM.startWith" title="(stateName: S, stateData: D, timeout: AbstractFSM.this.Timeout)Unit">startWith</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.startWith(14eae88c32).stateName" title="S">stateName</a>, <a href="#akka.actor;AbstractFSM.startWith(14eae88c32).stateData" title="D">stateData</a>, <span title="(x: scala.concurrent.duration.FiniteDuration)Option[scala.concurrent.duration.FiniteDuration]">Option</span><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.startWith(14eae88c32).timeout" title="scala.concurrent.duration.FiniteDuration">timeout</a><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Add a handler which is called upon each state transition, i.e. not when
   * staying in the same state.
   *
   * &lt;b&gt;Multiple handlers may be installed, and every one of them will be
   * called, not only the first one matching.&lt;/b&gt;
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(transitionHandlerBuilder: akka.japi.pf.FSMTransitionHandlerBuilder[S])Unit" id="akka.actor;AbstractFSM.onTransition(0280503f6f)">onTransition</a><span class="delimiter">(</span><a title="akka.japi.pf.FSMTransitionHandlerBuilder[S]" id="akka.actor;AbstractFSM.onTransition(0280503f6f).transitionHandlerBuilder">transitionHandlerBuilder</a>: <a href="../japi/pf/FSMTransitionHandlerBuilder.java.html#akka.japi.pf;FSMTransitionHandlerBuilder" title="akka.japi.pf.FSMTransitionHandlerBuilder[S]">FSMTransitionHandlerBuilder</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.actor;FSM.onTransition" title="(transitionHandler: AbstractFSM.this.TransitionHandler)Unit">onTransition</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.onTransition(0280503f6f).transitionHandlerBuilder" title="akka.japi.pf.FSMTransitionHandlerBuilder[S]">transitionHandlerBuilder</a>.<a href="../japi/pf/FSMTransitionHandlerBuilder.java.html#akka.japi.pf;FSMTransitionHandlerBuilder.build" title="()PartialFunction[(S, S),scala.runtime.BoxedUnit]">build</a><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="AbstractFSM.this.TransitionHandler" class="delimiter">[</span><span title="AbstractFSM.this.TransitionHandler">TransitionHandler</span><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Add a handler which is called upon each state transition, i.e. not when
   * staying in the same state.
   *
   * &lt;b&gt;Multiple handlers may be installed, and every one of them will be
   * called, not only the first one matching.&lt;/b&gt;
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(transitionHandler: akka.japi.pf.FI.UnitApply2[S,S])Unit" id="akka.actor;AbstractFSM.onTransition(8516211d31)">onTransition</a><span class="delimiter">(</span><a title="akka.japi.pf.FI.UnitApply2[S,S]" id="akka.actor;AbstractFSM.onTransition(8516211d31).transitionHandler">transitionHandler</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;UnitApply2" title="akka.japi.pf.FI.UnitApply2[S,S]">UnitApply2</a><span class="delimiter">[</span>S, S<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.actor;AbstractFSM.onTransition(8516211d31)" title="(transitionHandler: akka.japi.pf.FI.UnitApply2[S,S])Unit">onTransition</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.onTransition(8516211d31).transitionHandler" title="akka.japi.pf.FI.UnitApply2[S,S]">transitionHandler</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Set handler which is called upon reception of unhandled messages. Calling
   * this method again will overwrite the previous contents.
   *
   * The current state may be queried using ``stateName``.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(stateFunctionBuilder: akka.japi.pf.FSMStateFunctionBuilder[S,D])Unit" id="akka.actor;AbstractFSM.whenUnhandled(c1ed2067f0)">whenUnhandled</a><span class="delimiter">(</span><a title="akka.japi.pf.FSMStateFunctionBuilder[S,D]" id="akka.actor;AbstractFSM.whenUnhandled(c1ed2067f0).stateFunctionBuilder">stateFunctionBuilder</a>: <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.actor;FSM.whenUnhandled" title="(stateFunction: AbstractFSM.this.StateFunction)Unit">whenUnhandled</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.whenUnhandled(c1ed2067f0).stateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">stateFunctionBuilder</a>.<a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder.build" title="()PartialFunction[akka.actor.FSM.Event[D],akka.actor.FSM.State[S,D]]">build</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Set handler which is called upon termination of this FSM actor. Calling
   * this method again will overwrite the previous contents.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(stopBuilder: akka.japi.pf.FSMStopBuilder[S,D])Unit" id="akka.actor;AbstractFSM.onTermination(5a85aeb462)">onTermination</a><span class="delimiter">(</span><a title="akka.japi.pf.FSMStopBuilder[S,D]" id="akka.actor;AbstractFSM.onTermination(5a85aeb462).stopBuilder">stopBuilder</a>: <a href="../japi/pf/FSMStopBuilder.java.html#akka.japi.pf;FSMStopBuilder" title="akka.japi.pf.FSMStopBuilder[S,D]">FSMStopBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.actor;FSM.onTermination" title="(terminationHandler: PartialFunction[AbstractFSM.this.StopEvent,Unit])Unit">onTermination</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.onTermination(5a85aeb462).stopBuilder" title="akka.japi.pf.FSMStopBuilder[S,D]">stopBuilder</a>.<a href="../japi/pf/FSMStopBuilder.java.html#akka.japi.pf;FSMStopBuilder.build" title="()PartialFunction[akka.actor.FSM.StopEvent[S,D],scala.runtime.BoxedUnit]">build</a><span class="delimiter">(</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="PartialFunction[AbstractFSM.this.StopEvent,Unit]" class="delimiter">[</span><span title="PartialFunction[AbstractFSM.this.StopEvent,Unit]">PartialFunction</span><span class="delimiter">[</span>StopEvent, Unit<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMStateFunctionBuilder]] with the first case statement set.
   *
   * A case statement that matches on an event and data type and a predicate.
   *
   * @param eventType  the event type to match on
   * @param dataType  the data type to match on
   * @param predicate  a predicate to evaluate on the matched types
   * @param apply  an action to apply to the event and state data if there is a match
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[ET, DT &lt;: D](eventType: Class[ET], dataType: Class[DT], predicate: akka.japi.pf.FI.TypedPredicate2[ET,DT], apply: akka.japi.pf.FI.Apply2[ET,DT,AbstractFSM.this.State])akka.japi.pf.FSMStateFunctionBuilder[S,D]" id="akka.actor;AbstractFSM.matchEvent(036af456c9)">matchEvent</a><span class="delimiter">[</span><a title="" id="akka.actor;AbstractFSM.matchEvent(036af456c9);ET">ET</a>, <a title=" &lt;: D" id="akka.actor;AbstractFSM.matchEvent(036af456c9);DT">DT</a> &lt;: D<span class="delimiter">]</span><span class="delimiter">(</span><a title="Class[ET]" id="akka.actor;AbstractFSM.matchEvent(036af456c9).eventType">eventType</a>: <span title="Class[ET]">Class</span><span class="delimiter">[</span>ET<span class="delimiter">]</span>, <a title="Class[DT]" id="akka.actor;AbstractFSM.matchEvent(036af456c9).dataType">dataType</a>: <span title="Class[DT]">Class</span><span class="delimiter">[</span>DT<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.TypedPredicate2[ET,DT]" id="akka.actor;AbstractFSM.matchEvent(036af456c9).predicate">predicate</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;TypedPredicate2" title="akka.japi.pf.FI.TypedPredicate2[ET,DT]">TypedPredicate2</a><span class="delimiter">[</span>ET, DT<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.Apply2[ET,DT,AbstractFSM.this.State]" id="akka.actor;AbstractFSM.matchEvent(036af456c9).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;Apply2" title="akka.japi.pf.FI.Apply2[ET,DT,AbstractFSM.this.State]">Apply2</a><span class="delimiter">[</span>ET, DT, State<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMStateFunctionBuilder[S,D]" class="keyword">new</span> <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder.event(fe7f714914)" title="(eventType: Class[ET], dataType: Class[DT], predicate: akka.japi.pf.FI.TypedPredicate2[ET,DT], apply: akka.japi.pf.FI.Apply2[ET,DT,akka.actor.FSM.State[S,D]])akka.japi.pf.FSMStateFunctionBuilder[S,D]">event</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchEvent(036af456c9).eventType" title="Class[ET]">eventType</a>, <a href="#akka.actor;AbstractFSM.matchEvent(036af456c9).dataType" title="Class[DT]">dataType</a>, <a href="#akka.actor;AbstractFSM.matchEvent(036af456c9).predicate" title="akka.japi.pf.FI.TypedPredicate2[ET,DT]">predicate</a>, <a href="#akka.actor;AbstractFSM.matchEvent(036af456c9).apply" title="akka.japi.pf.FI.Apply2[ET,DT,AbstractFSM.this.State]">apply</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMStateFunctionBuilder]] with the first case statement set.
   *
   * A case statement that matches on an event and data type.
   *
   * @param eventType  the event type to match on
   * @param dataType  the data type to match on
   * @param apply  an action to apply to the event and state data if there is a match
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[ET, DT &lt;: D](eventType: Class[ET], dataType: Class[DT], apply: akka.japi.pf.FI.Apply2[ET,DT,AbstractFSM.this.State])akka.japi.pf.FSMStateFunctionBuilder[S,D]" id="akka.actor;AbstractFSM.matchEvent(958b869ad1)">matchEvent</a><span class="delimiter">[</span><a title="" id="akka.actor;AbstractFSM.matchEvent(958b869ad1);ET">ET</a>, <a title=" &lt;: D" id="akka.actor;AbstractFSM.matchEvent(958b869ad1);DT">DT</a> &lt;: D<span class="delimiter">]</span><span class="delimiter">(</span><a title="Class[ET]" id="akka.actor;AbstractFSM.matchEvent(958b869ad1).eventType">eventType</a>: <span title="Class[ET]">Class</span><span class="delimiter">[</span>ET<span class="delimiter">]</span>, <a title="Class[DT]" id="akka.actor;AbstractFSM.matchEvent(958b869ad1).dataType">dataType</a>: <span title="Class[DT]">Class</span><span class="delimiter">[</span>DT<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.Apply2[ET,DT,AbstractFSM.this.State]" id="akka.actor;AbstractFSM.matchEvent(958b869ad1).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;Apply2" title="akka.japi.pf.FI.Apply2[ET,DT,AbstractFSM.this.State]">Apply2</a><span class="delimiter">[</span>ET, DT, State<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMStateFunctionBuilder[S,D]" class="keyword">new</span> <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder.event(d293a0d366)" title="(eventType: Class[ET], dataType: Class[DT], apply: akka.japi.pf.FI.Apply2[ET,DT,akka.actor.FSM.State[S,D]])akka.japi.pf.FSMStateFunctionBuilder[S,D]">event</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchEvent(958b869ad1).eventType" title="Class[ET]">eventType</a>, <a href="#akka.actor;AbstractFSM.matchEvent(958b869ad1).dataType" title="Class[DT]">dataType</a>, <a href="#akka.actor;AbstractFSM.matchEvent(958b869ad1).apply" title="akka.japi.pf.FI.Apply2[ET,DT,AbstractFSM.this.State]">apply</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMStateFunctionBuilder]] with the first case statement set.
   *
   * A case statement that matches if the event type and predicate matches.
   *
   * @param eventType  the event type to match on
   * @param predicate  a predicate that will be evaluated on the data and the event
   * @param apply  an action to apply to the event and state data if there is a match
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[ET](eventType: Class[ET], predicate: akka.japi.pf.FI.TypedPredicate2[ET,D], apply: akka.japi.pf.FI.Apply2[ET,D,AbstractFSM.this.State])akka.japi.pf.FSMStateFunctionBuilder[S,D]" id="akka.actor;AbstractFSM.matchEvent(66d571b53d)">matchEvent</a><span class="delimiter">[</span><a title="" id="akka.actor;AbstractFSM.matchEvent(66d571b53d);ET">ET</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Class[ET]" id="akka.actor;AbstractFSM.matchEvent(66d571b53d).eventType">eventType</a>: <span title="Class[ET]">Class</span><span class="delimiter">[</span>ET<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.TypedPredicate2[ET,D]" id="akka.actor;AbstractFSM.matchEvent(66d571b53d).predicate">predicate</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;TypedPredicate2" title="akka.japi.pf.FI.TypedPredicate2[ET,D]">TypedPredicate2</a><span class="delimiter">[</span>ET, D<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.Apply2[ET,D,AbstractFSM.this.State]" id="akka.actor;AbstractFSM.matchEvent(66d571b53d).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;Apply2" title="akka.japi.pf.FI.Apply2[ET,D,AbstractFSM.this.State]">Apply2</a><span class="delimiter">[</span>ET, D, State<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMStateFunctionBuilder[S,D]" class="keyword">new</span> <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder.event(d4cf244082)" title="(eventType: Class[ET], predicate: akka.japi.pf.FI.TypedPredicate2[ET,D], apply: akka.japi.pf.FI.Apply2[ET,D,akka.actor.FSM.State[S,D]])akka.japi.pf.FSMStateFunctionBuilder[S,D]">event</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchEvent(66d571b53d).eventType" title="Class[ET]">eventType</a>, <a href="#akka.actor;AbstractFSM.matchEvent(66d571b53d).predicate" title="akka.japi.pf.FI.TypedPredicate2[ET,D]">predicate</a>, <a href="#akka.actor;AbstractFSM.matchEvent(66d571b53d).apply" title="akka.japi.pf.FI.Apply2[ET,D,AbstractFSM.this.State]">apply</a><span class="delimiter">)</span>;

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMStateFunctionBuilder]] with the first case statement set.
   *
   * A case statement that matches if the event type matches.
   *
   * @param eventType  the event type to match on
   * @param apply  an action to apply to the event and state data if there is a match
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[ET](eventType: Class[ET], apply: akka.japi.pf.FI.Apply2[ET,D,AbstractFSM.this.State])akka.japi.pf.FSMStateFunctionBuilder[S,D]" id="akka.actor;AbstractFSM.matchEvent(8b3e60ce59)">matchEvent</a><span class="delimiter">[</span><a title="" id="akka.actor;AbstractFSM.matchEvent(8b3e60ce59);ET">ET</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Class[ET]" id="akka.actor;AbstractFSM.matchEvent(8b3e60ce59).eventType">eventType</a>: <span title="Class[ET]">Class</span><span class="delimiter">[</span>ET<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.Apply2[ET,D,AbstractFSM.this.State]" id="akka.actor;AbstractFSM.matchEvent(8b3e60ce59).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;Apply2" title="akka.japi.pf.FI.Apply2[ET,D,AbstractFSM.this.State]">Apply2</a><span class="delimiter">[</span>ET, D, State<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMStateFunctionBuilder[S,D]" class="keyword">new</span> <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder.event(7af9eb9072)" title="(eventType: Class[ET], apply: akka.japi.pf.FI.Apply2[ET,D,akka.actor.FSM.State[S,D]])akka.japi.pf.FSMStateFunctionBuilder[S,D]">event</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchEvent(8b3e60ce59).eventType" title="Class[ET]">eventType</a>, <a href="#akka.actor;AbstractFSM.matchEvent(8b3e60ce59).apply" title="akka.japi.pf.FI.Apply2[ET,D,AbstractFSM.this.State]">apply</a><span class="delimiter">)</span>;

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMStateFunctionBuilder]] with the first case statement set.
   *
   * A case statement that matches if the predicate matches.
   *
   * @param predicate  a predicate that will be evaluated on the data and the event
   * @param apply  an action to apply to the event and state data if there is a match
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(predicate: akka.japi.pf.FI.TypedPredicate2[AnyRef,D], apply: akka.japi.pf.FI.Apply2[AnyRef,D,AbstractFSM.this.State])akka.japi.pf.FSMStateFunctionBuilder[S,D]" id="akka.actor;AbstractFSM.matchEvent(46403adf66)">matchEvent</a><span class="delimiter">(</span><a title="akka.japi.pf.FI.TypedPredicate2[AnyRef,D]" id="akka.actor;AbstractFSM.matchEvent(46403adf66).predicate">predicate</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;TypedPredicate2" title="akka.japi.pf.FI.TypedPredicate2[AnyRef,D]">TypedPredicate2</a><span class="delimiter">[</span>AnyRef, D<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.Apply2[AnyRef,D,AbstractFSM.this.State]" id="akka.actor;AbstractFSM.matchEvent(46403adf66).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;Apply2" title="akka.japi.pf.FI.Apply2[AnyRef,D,AbstractFSM.this.State]">Apply2</a><span class="delimiter">[</span>AnyRef, D, State<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMStateFunctionBuilder[S,D]" class="keyword">new</span> <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder.event(b8cebda0ec)" title="(predicate: akka.japi.pf.FI.TypedPredicate2[Object,D], apply: akka.japi.pf.FI.Apply2[Object,D,akka.actor.FSM.State[S,D]])akka.japi.pf.FSMStateFunctionBuilder[S,D]">event</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchEvent(46403adf66).predicate" title="akka.japi.pf.FI.TypedPredicate2[AnyRef,D]">predicate</a>, <a href="#akka.actor;AbstractFSM.matchEvent(46403adf66).apply" title="akka.japi.pf.FI.Apply2[AnyRef,D,AbstractFSM.this.State]">apply</a><span class="delimiter">)</span>;

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMStateFunctionBuilder]] with the first case statement set.
   *
   * A case statement that matches on the data type and if any of the event types
   * in the list match or any of the event instances in the list compares equal.
   *
   * @param eventMatches  a list of types or instances to match against
   * @param dataType  the data type to match on
   * @param apply  an action to apply to the event and state data if there is a match
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[DT &lt;: D](eventMatches: java.util.List[AnyRef], dataType: Class[DT], apply: akka.japi.pf.FI.Apply2[AnyRef,DT,AbstractFSM.this.State])akka.japi.pf.FSMStateFunctionBuilder[S,D]" id="akka.actor;AbstractFSM.matchEvent(e646638082)">matchEvent</a><span class="delimiter">[</span><a title=" &lt;: D" id="akka.actor;AbstractFSM.matchEvent(e646638082);DT">DT</a> &lt;: D<span class="delimiter">]</span><span class="delimiter">(</span><a title="java.util.List[AnyRef]" id="akka.actor;AbstractFSM.matchEvent(e646638082).eventMatches">eventMatches</a>: <span title="java.util.List[AnyRef]">JList</span><span class="delimiter">[</span>AnyRef<span class="delimiter">]</span>, <a title="Class[DT]" id="akka.actor;AbstractFSM.matchEvent(e646638082).dataType">dataType</a>: <span title="Class[DT]">Class</span><span class="delimiter">[</span>DT<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.Apply2[AnyRef,DT,AbstractFSM.this.State]" id="akka.actor;AbstractFSM.matchEvent(e646638082).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;Apply2" title="akka.japi.pf.FI.Apply2[AnyRef,DT,AbstractFSM.this.State]">Apply2</a><span class="delimiter">[</span>AnyRef, DT, State<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMStateFunctionBuilder[S,D]" class="keyword">new</span> <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder.event(d4a03c499b)" title="(eventMatches: java.util.List[Object], dataType: Class[DT], apply: akka.japi.pf.FI.Apply2[Object,DT,akka.actor.FSM.State[S,D]])akka.japi.pf.FSMStateFunctionBuilder[S,D]">event</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchEvent(e646638082).eventMatches" title="java.util.List[AnyRef]">eventMatches</a>, <a href="#akka.actor;AbstractFSM.matchEvent(e646638082).dataType" title="Class[DT]">dataType</a>, <a href="#akka.actor;AbstractFSM.matchEvent(e646638082).apply" title="akka.japi.pf.FI.Apply2[AnyRef,DT,AbstractFSM.this.State]">apply</a><span class="delimiter">)</span>;

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMStateFunctionBuilder]] with the first case statement set.
   *
   * A case statement that matches if any of the event types in the list match or any
   * of the event instances in the list compares equal.
   *
   * @param eventMatches  a list of types or instances to match against
   * @param apply  an action to apply to the event and state data if there is a match
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(eventMatches: java.util.List[AnyRef], apply: akka.japi.pf.FI.Apply2[AnyRef,D,AbstractFSM.this.State])akka.japi.pf.FSMStateFunctionBuilder[S,D]" id="akka.actor;AbstractFSM.matchEvent(0e4c5b0131)">matchEvent</a><span class="delimiter">(</span><a title="java.util.List[AnyRef]" id="akka.actor;AbstractFSM.matchEvent(0e4c5b0131).eventMatches">eventMatches</a>: <span title="java.util.List[AnyRef]">JList</span><span class="delimiter">[</span>AnyRef<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.Apply2[AnyRef,D,AbstractFSM.this.State]" id="akka.actor;AbstractFSM.matchEvent(0e4c5b0131).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;Apply2" title="akka.japi.pf.FI.Apply2[AnyRef,D,AbstractFSM.this.State]">Apply2</a><span class="delimiter">[</span>AnyRef, D, State<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMStateFunctionBuilder[S,D]" class="keyword">new</span> <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder.event(0738a8d094)" title="(eventMatches: java.util.List[Object], apply: akka.japi.pf.FI.Apply2[Object,D,akka.actor.FSM.State[S,D]])akka.japi.pf.FSMStateFunctionBuilder[S,D]">event</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchEvent(0e4c5b0131).eventMatches" title="java.util.List[AnyRef]">eventMatches</a>, <a href="#akka.actor;AbstractFSM.matchEvent(0e4c5b0131).apply" title="akka.japi.pf.FI.Apply2[AnyRef,D,AbstractFSM.this.State]">apply</a><span class="delimiter">)</span>;

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMStateFunctionBuilder]] with the first case statement set.
   *
   * A case statement that matches on the data type and if the event compares equal.
   *
   * @param event  an event to compare equal against
   * @param dataType  the data type to match on
   * @param apply  an action to apply to the event and state data if there is a match
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[E, DT &lt;: D](event: E, dataType: Class[DT], apply: akka.japi.pf.FI.Apply2[E,DT,AbstractFSM.this.State])akka.japi.pf.FSMStateFunctionBuilder[S,D]" id="akka.actor;AbstractFSM.matchEventEquals(fa40ee423b)">matchEventEquals</a><span class="delimiter">[</span><a title="" id="akka.actor;AbstractFSM.matchEventEquals(fa40ee423b);E">E</a>, <a title=" &lt;: D" id="akka.actor;AbstractFSM.matchEventEquals(fa40ee423b);DT">DT</a> &lt;: D<span class="delimiter">]</span><span class="delimiter">(</span><a title="E" id="akka.actor;AbstractFSM.matchEventEquals(fa40ee423b).event">event</a>: <a href="#akka.actor;AbstractFSM.matchEventEquals(fa40ee423b);E" title="E">E</a>, <a title="Class[DT]" id="akka.actor;AbstractFSM.matchEventEquals(fa40ee423b).dataType">dataType</a>: <span title="Class[DT]">Class</span><span class="delimiter">[</span>DT<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.Apply2[E,DT,AbstractFSM.this.State]" id="akka.actor;AbstractFSM.matchEventEquals(fa40ee423b).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;Apply2" title="akka.japi.pf.FI.Apply2[E,DT,AbstractFSM.this.State]">Apply2</a><span class="delimiter">[</span>E, DT, State<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMStateFunctionBuilder[S,D]" class="keyword">new</span> <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder.eventEquals(ce268858fc)" title="(event: E, dataType: Class[DT], apply: akka.japi.pf.FI.Apply2[E,DT,akka.actor.FSM.State[S,D]])akka.japi.pf.FSMStateFunctionBuilder[S,D]">eventEquals</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchEventEquals(fa40ee423b).event" title="E">event</a>, <a href="#akka.actor;AbstractFSM.matchEventEquals(fa40ee423b).dataType" title="Class[DT]">dataType</a>, <a href="#akka.actor;AbstractFSM.matchEventEquals(fa40ee423b).apply" title="akka.japi.pf.FI.Apply2[E,DT,AbstractFSM.this.State]">apply</a><span class="delimiter">)</span>;

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMStateFunctionBuilder]] with the first case statement set.
   *
   * A case statement that matches if the event compares equal.
   *
   * @param event  an event to compare equal against
   * @param apply  an action to apply to the event and state data if there is a match
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[E](event: E, apply: akka.japi.pf.FI.Apply2[E,D,AbstractFSM.this.State])akka.japi.pf.FSMStateFunctionBuilder[S,D]" id="akka.actor;AbstractFSM.matchEventEquals(ffad27af27)">matchEventEquals</a><span class="delimiter">[</span><a title="" id="akka.actor;AbstractFSM.matchEventEquals(ffad27af27);E">E</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="E" id="akka.actor;AbstractFSM.matchEventEquals(ffad27af27).event">event</a>: <a href="#akka.actor;AbstractFSM.matchEventEquals(ffad27af27);E" title="E">E</a>, <a title="akka.japi.pf.FI.Apply2[E,D,AbstractFSM.this.State]" id="akka.actor;AbstractFSM.matchEventEquals(ffad27af27).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;Apply2" title="akka.japi.pf.FI.Apply2[E,D,AbstractFSM.this.State]">Apply2</a><span class="delimiter">[</span>E, D, State<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMStateFunctionBuilder[S,D]" class="keyword">new</span> <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder.eventEquals(c37914ba18)" title="(event: E, apply: akka.japi.pf.FI.Apply2[E,D,akka.actor.FSM.State[S,D]])akka.japi.pf.FSMStateFunctionBuilder[S,D]">eventEquals</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchEventEquals(ffad27af27).event" title="E">event</a>, <a href="#akka.actor;AbstractFSM.matchEventEquals(ffad27af27).apply" title="akka.japi.pf.FI.Apply2[E,D,AbstractFSM.this.State]">apply</a><span class="delimiter">)</span>;

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMStateFunctionBuilder]] with the first case statement set.
   *
   * A case statement that matches on any type of event.
   *
   * @param apply  an action to apply to the event and state data if there is a match
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(apply: akka.japi.pf.FI.Apply2[AnyRef,D,AbstractFSM.this.State])akka.japi.pf.FSMStateFunctionBuilder[S,D]" id="akka.actor;AbstractFSM.matchAnyEvent">matchAnyEvent</a><span class="delimiter">(</span><a title="akka.japi.pf.FI.Apply2[AnyRef,D,AbstractFSM.this.State]" id="akka.actor;AbstractFSM.matchAnyEvent.apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;Apply2" title="akka.japi.pf.FI.Apply2[AnyRef,D,AbstractFSM.this.State]">Apply2</a><span class="delimiter">[</span>AnyRef, D, State<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMStateFunctionBuilder[S,D]" class="keyword">new</span> <a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder" title="akka.japi.pf.FSMStateFunctionBuilder[S,D]">FSMStateFunctionBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMStateFunctionBuilder.java.html#akka.japi.pf;FSMStateFunctionBuilder.anyEvent" title="(apply: akka.japi.pf.FI.Apply2[Object,D,akka.actor.FSM.State[S,D]])akka.japi.pf.FSMStateFunctionBuilder[S,D]">anyEvent</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchAnyEvent.apply" title="akka.japi.pf.FI.Apply2[AnyRef,D,AbstractFSM.this.State]">apply</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMTransitionHandlerBuilder]] with the first case statement set.
   *
   * A case statement that matches on a from state and a to state.
   *
   * @param fromState  the from state to match on
   * @param toState  the to state to match on
   * @param apply  an action to apply when the states match
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(fromState: S, toState: S, apply: akka.japi.pf.FI.UnitApplyVoid)akka.japi.pf.FSMTransitionHandlerBuilder[S]" id="akka.actor;AbstractFSM.matchState(79eef81ea0)">matchState</a><span class="delimiter">(</span><a title="S" id="akka.actor;AbstractFSM.matchState(79eef81ea0).fromState">fromState</a>: <a href="#akka.actor;AbstractFSM;S" title="S">S</a>, <a title="S" id="akka.actor;AbstractFSM.matchState(79eef81ea0).toState">toState</a>: <a href="#akka.actor;AbstractFSM;S" title="S">S</a>, <a title="akka.japi.pf.FI.UnitApplyVoid" id="akka.actor;AbstractFSM.matchState(79eef81ea0).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;UnitApplyVoid" title="akka.japi.pf.FI.UnitApplyVoid">UnitApplyVoid</a><span class="delimiter">)</span>: <a href="../japi/pf/FSMTransitionHandlerBuilder.java.html#akka.japi.pf;FSMTransitionHandlerBuilder" title="akka.japi.pf.FSMTransitionHandlerBuilder[S]">FSMTransitionHandlerBuilder</a><span class="delimiter">[</span>S<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMTransitionHandlerBuilder[S]" class="keyword">new</span> <a href="../japi/pf/FSMTransitionHandlerBuilder.java.html#akka.japi.pf;FSMTransitionHandlerBuilder" title="akka.japi.pf.FSMTransitionHandlerBuilder[S]">FSMTransitionHandlerBuilder</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMTransitionHandlerBuilder.java.html#akka.japi.pf;FSMTransitionHandlerBuilder.state(79eef81ea0)" title="(fromState: S, toState: S, apply: akka.japi.pf.FI.UnitApplyVoid)akka.japi.pf.FSMTransitionHandlerBuilder[S]">state</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchState(79eef81ea0).fromState" title="S">fromState</a>, <a href="#akka.actor;AbstractFSM.matchState(79eef81ea0).toState" title="S">toState</a>, <a href="#akka.actor;AbstractFSM.matchState(79eef81ea0).apply" title="akka.japi.pf.FI.UnitApplyVoid">apply</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMTransitionHandlerBuilder]] with the first case statement set.
   *
   * A case statement that matches on a from state and a to state.
   *
   * @param fromState  the from state to match on
   * @param toState  the to state to match on
   * @param apply  an action to apply when the states match
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(fromState: S, toState: S, apply: akka.japi.pf.FI.UnitApply2[S,S])akka.japi.pf.FSMTransitionHandlerBuilder[S]" id="akka.actor;AbstractFSM.matchState(f1c9a514b0)">matchState</a><span class="delimiter">(</span><a title="S" id="akka.actor;AbstractFSM.matchState(f1c9a514b0).fromState">fromState</a>: <a href="#akka.actor;AbstractFSM;S" title="S">S</a>, <a title="S" id="akka.actor;AbstractFSM.matchState(f1c9a514b0).toState">toState</a>: <a href="#akka.actor;AbstractFSM;S" title="S">S</a>, <a title="akka.japi.pf.FI.UnitApply2[S,S]" id="akka.actor;AbstractFSM.matchState(f1c9a514b0).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;UnitApply2" title="akka.japi.pf.FI.UnitApply2[S,S]">UnitApply2</a><span class="delimiter">[</span>S, S<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/FSMTransitionHandlerBuilder.java.html#akka.japi.pf;FSMTransitionHandlerBuilder" title="akka.japi.pf.FSMTransitionHandlerBuilder[S]">FSMTransitionHandlerBuilder</a><span class="delimiter">[</span>S<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMTransitionHandlerBuilder[S]" class="keyword">new</span> <a href="../japi/pf/FSMTransitionHandlerBuilder.java.html#akka.japi.pf;FSMTransitionHandlerBuilder" title="akka.japi.pf.FSMTransitionHandlerBuilder[S]">FSMTransitionHandlerBuilder</a><span class="delimiter">[</span>S<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMTransitionHandlerBuilder.java.html#akka.japi.pf;FSMTransitionHandlerBuilder.state(f1c9a514b0)" title="(fromState: S, toState: S, apply: akka.japi.pf.FI.UnitApply2[S,S])akka.japi.pf.FSMTransitionHandlerBuilder[S]">state</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchState(f1c9a514b0).fromState" title="S">fromState</a>, <a href="#akka.actor;AbstractFSM.matchState(f1c9a514b0).toState" title="S">toState</a>, <a href="#akka.actor;AbstractFSM.matchState(f1c9a514b0).apply" title="akka.japi.pf.FI.UnitApply2[S,S]">apply</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMStopBuilder]] with the first case statement set.
   *
   * A case statement that matches on an [[FSM.Reason]].
   *
   * @param reason  the reason for the termination
   * @param apply  an action to apply to the event and state data if there is a match
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(reason: akka.actor.FSM.Reason, apply: akka.japi.pf.FI.UnitApply2[S,D])akka.japi.pf.FSMStopBuilder[S,D]" id="akka.actor;AbstractFSM.matchStop(f1c81c013e)">matchStop</a><span class="delimiter">(</span><a title="akka.actor.FSM.Reason" id="akka.actor;AbstractFSM.matchStop(f1c81c013e).reason">reason</a>: <a href="#akka.actor.FSM;Reason" title="akka.actor.FSM.Reason">Reason</a>, <a title="akka.japi.pf.FI.UnitApply2[S,D]" id="akka.actor;AbstractFSM.matchStop(f1c81c013e).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;UnitApply2" title="akka.japi.pf.FI.UnitApply2[S,D]">UnitApply2</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/FSMStopBuilder.java.html#akka.japi.pf;FSMStopBuilder" title="akka.japi.pf.FSMStopBuilder[S,D]">FSMStopBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMStopBuilder[S,D]" class="keyword">new</span> <a href="../japi/pf/FSMStopBuilder.java.html#akka.japi.pf;FSMStopBuilder" title="akka.japi.pf.FSMStopBuilder[S,D]">FSMStopBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMStopBuilder.java.html#akka.japi.pf;FSMStopBuilder.stop(f1c81c013e)" title="(reason: akka.actor.FSM.Reason, apply: akka.japi.pf.FI.UnitApply2[S,D])akka.japi.pf.FSMStopBuilder[S,D]">stop</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchStop(f1c81c013e).reason" title="akka.actor.FSM.Reason">reason</a>, <a href="#akka.actor;AbstractFSM.matchStop(f1c81c013e).apply" title="akka.japi.pf.FI.UnitApply2[S,D]">apply</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMStopBuilder]] with the first case statement set.
   *
   * A case statement that matches on a reason type.
   *
   * @param reasonType  the reason type to match on
   * @param apply  an action to apply to the reason, event and state data if there is a match
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[RT &lt;: akka.actor.FSM.Reason](reasonType: Class[RT], apply: akka.japi.pf.FI.UnitApply3[RT,S,D])akka.japi.pf.FSMStopBuilder[S,D]" id="akka.actor;AbstractFSM.matchStop(58e4049ba4)">matchStop</a><span class="delimiter">[</span><a title=" &lt;: akka.actor.FSM.Reason" id="akka.actor;AbstractFSM.matchStop(58e4049ba4);RT">RT</a> &lt;: Reason<span class="delimiter">]</span><span class="delimiter">(</span><a title="Class[RT]" id="akka.actor;AbstractFSM.matchStop(58e4049ba4).reasonType">reasonType</a>: <span title="Class[RT]">Class</span><span class="delimiter">[</span>RT<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.UnitApply3[RT,S,D]" id="akka.actor;AbstractFSM.matchStop(58e4049ba4).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;UnitApply3" title="akka.japi.pf.FI.UnitApply3[RT,S,D]">UnitApply3</a><span class="delimiter">[</span>RT, S, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/FSMStopBuilder.java.html#akka.japi.pf;FSMStopBuilder" title="akka.japi.pf.FSMStopBuilder[S,D]">FSMStopBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMStopBuilder[S,D]" class="keyword">new</span> <a href="../japi/pf/FSMStopBuilder.java.html#akka.japi.pf;FSMStopBuilder" title="akka.japi.pf.FSMStopBuilder[S,D]">FSMStopBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMStopBuilder.java.html#akka.japi.pf;FSMStopBuilder.stop(9ff3f2f8eb)" title="(reasonType: Class[RT], apply: akka.japi.pf.FI.UnitApply3[RT,S,D])akka.japi.pf.FSMStopBuilder[S,D]">stop</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchStop(58e4049ba4).reasonType" title="Class[RT]">reasonType</a>, <a href="#akka.actor;AbstractFSM.matchStop(58e4049ba4).apply" title="akka.japi.pf.FI.UnitApply3[RT,S,D]">apply</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Create an [[akka.japi.pf.FSMStopBuilder]] with the first case statement set.
   *
   * A case statement that matches on a reason type and a predicate.
   *
   * @param reasonType  the reason type to match on
   * @param apply  an action to apply to the reason, event and state data if there is a match
   * @param predicate  a predicate that will be evaluated on the reason if the type matches
   * @return the builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[RT &lt;: akka.actor.FSM.Reason](reasonType: Class[RT], predicate: akka.japi.pf.FI.TypedPredicate[RT], apply: akka.japi.pf.FI.UnitApply3[RT,S,D])akka.japi.pf.FSMStopBuilder[S,D]" id="akka.actor;AbstractFSM.matchStop(e86978e4b0)">matchStop</a><span class="delimiter">[</span><a title=" &lt;: akka.actor.FSM.Reason" id="akka.actor;AbstractFSM.matchStop(e86978e4b0);RT">RT</a> &lt;: Reason<span class="delimiter">]</span><span class="delimiter">(</span><a title="Class[RT]" id="akka.actor;AbstractFSM.matchStop(e86978e4b0).reasonType">reasonType</a>: <span title="Class[RT]">Class</span><span class="delimiter">[</span>RT<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.TypedPredicate[RT]" id="akka.actor;AbstractFSM.matchStop(e86978e4b0).predicate">predicate</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;TypedPredicate" title="akka.japi.pf.FI.TypedPredicate[RT]">TypedPredicate</a><span class="delimiter">[</span>RT<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.UnitApply3[RT,S,D]" id="akka.actor;AbstractFSM.matchStop(e86978e4b0).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;UnitApply3" title="akka.japi.pf.FI.UnitApply3[RT,S,D]">UnitApply3</a><span class="delimiter">[</span>RT, S, D<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/FSMStopBuilder.java.html#akka.japi.pf;FSMStopBuilder" title="akka.japi.pf.FSMStopBuilder[S,D]">FSMStopBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> =
    <span title="akka.japi.pf.FSMStopBuilder[S,D]" class="keyword">new</span> <a href="../japi/pf/FSMStopBuilder.java.html#akka.japi.pf;FSMStopBuilder" title="akka.japi.pf.FSMStopBuilder[S,D]">FSMStopBuilder</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>.<a href="../japi/pf/FSMStopBuilder.java.html#akka.japi.pf;FSMStopBuilder.stop(327c6abafe)" title="(reasonType: Class[RT], predicate: akka.japi.pf.FI.TypedPredicate[RT], apply: akka.japi.pf.FI.UnitApply3[RT,S,D])akka.japi.pf.FSMStopBuilder[S,D]">stop</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchStop(e86978e4b0).reasonType" title="Class[RT]">reasonType</a>, <a href="#akka.actor;AbstractFSM.matchStop(e86978e4b0).predicate" title="akka.japi.pf.FI.TypedPredicate[RT]">predicate</a>, <a href="#akka.actor;AbstractFSM.matchStop(e86978e4b0).apply" title="akka.japi.pf.FI.UnitApply3[RT,S,D]">apply</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Create a [[akka.japi.pf.UnitPFBuilder]] with the first case statement set.
   *
   * @param dataType  a type to match the argument against
   * @param apply  an action to apply to the argument if the type matches
   * @return a builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[DT &lt;: D](dataType: Class[DT], apply: akka.japi.pf.FI.UnitApply[DT])akka.japi.pf.UnitPFBuilder[D]" id="akka.actor;AbstractFSM.matchData(cb90b3184d)">matchData</a><span class="delimiter">[</span><a title=" &lt;: D" id="akka.actor;AbstractFSM.matchData(cb90b3184d);DT">DT</a> &lt;: D<span class="delimiter">]</span><span class="delimiter">(</span><a title="Class[DT]" id="akka.actor;AbstractFSM.matchData(cb90b3184d).dataType">dataType</a>: <span title="Class[DT]">Class</span><span class="delimiter">[</span>DT<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.UnitApply[DT]" id="akka.actor;AbstractFSM.matchData(cb90b3184d).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;UnitApply" title="akka.japi.pf.FI.UnitApply[DT]">UnitApply</a><span class="delimiter">[</span>DT<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/UnitPFBuilder.java.html#akka.japi.pf;UnitPFBuilder" title="akka.japi.pf.UnitPFBuilder[D]">UnitPFBuilder</a><span class="delimiter">[</span>D<span class="delimiter">]</span> =
    <a href="../japi/pf/UnitMatch.java.html#akka.japi.pf.UnitMatch" title="akka.japi.pf.UnitMatch.type">UnitMatch</a>.<a href="../japi/pf/UnitMatch.java.html#akka.japi.pf.UnitMatch.match(235cde1a73)" title="(type: Class[DT], apply: akka.japi.pf.FI.UnitApply[DT])akka.japi.pf.UnitPFBuilder[D]">`match`</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchData(cb90b3184d).dataType" title="Class[DT]">dataType</a>, <a href="#akka.actor;AbstractFSM.matchData(cb90b3184d).apply" title="akka.japi.pf.FI.UnitApply[DT]">apply</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Create a [[akka.japi.pf.UnitPFBuilder]] with the first case statement set.
   *
   * @param dataType  a type to match the argument against
   * @param predicate  a predicate that will be evaluated on the argument if the type matches
   * @param apply  an action to apply to the argument if the type and predicate matches
   * @return a builder with the case statement added
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="[DT &lt;: D](dataType: Class[DT], predicate: akka.japi.pf.FI.TypedPredicate[DT], apply: akka.japi.pf.FI.UnitApply[DT])akka.japi.pf.UnitPFBuilder[D]" id="akka.actor;AbstractFSM.matchData(b45a48fd4e)">matchData</a><span class="delimiter">[</span><a title=" &lt;: D" id="akka.actor;AbstractFSM.matchData(b45a48fd4e);DT">DT</a> &lt;: D<span class="delimiter">]</span><span class="delimiter">(</span><a title="Class[DT]" id="akka.actor;AbstractFSM.matchData(b45a48fd4e).dataType">dataType</a>: <span title="Class[DT]">Class</span><span class="delimiter">[</span>DT<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.TypedPredicate[DT]" id="akka.actor;AbstractFSM.matchData(b45a48fd4e).predicate">predicate</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;TypedPredicate" title="akka.japi.pf.FI.TypedPredicate[DT]">TypedPredicate</a><span class="delimiter">[</span>DT<span class="delimiter">]</span>, <a title="akka.japi.pf.FI.UnitApply[DT]" id="akka.actor;AbstractFSM.matchData(b45a48fd4e).apply">apply</a>: <a href="../japi/pf/FI.java.html#akka.japi.pf.FI;UnitApply" title="akka.japi.pf.FI.UnitApply[DT]">UnitApply</a><span class="delimiter">[</span>DT<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="../japi/pf/UnitPFBuilder.java.html#akka.japi.pf;UnitPFBuilder" title="akka.japi.pf.UnitPFBuilder[D]">UnitPFBuilder</a><span class="delimiter">[</span>D<span class="delimiter">]</span> =
    <a href="../japi/pf/UnitMatch.java.html#akka.japi.pf.UnitMatch" title="akka.japi.pf.UnitMatch.type">UnitMatch</a>.<a href="../japi/pf/UnitMatch.java.html#akka.japi.pf.UnitMatch.match(8578eb12fe)" title="(type: Class[DT], predicate: akka.japi.pf.FI.TypedPredicate[DT], apply: akka.japi.pf.FI.UnitApply[DT])akka.japi.pf.UnitPFBuilder[D]">`match`</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.matchData(b45a48fd4e).dataType" title="Class[DT]">dataType</a>, <a href="#akka.actor;AbstractFSM.matchData(b45a48fd4e).predicate" title="akka.japi.pf.FI.TypedPredicate[DT]">predicate</a>, <a href="#akka.actor;AbstractFSM.matchData(b45a48fd4e).apply" title="akka.japi.pf.FI.UnitApply[DT]">apply</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Produce transition to other state. Return this from a state function in
   * order to effect the transition.
   *
   * @param nextStateName state designator for the next state
   * @return state transition descriptor
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(nextStateName: S)AbstractFSM.this.State" id="akka.actor;AbstractFSM.goTo">goTo</a><span class="delimiter">(</span><a title="S" id="akka.actor;AbstractFSM.goTo.nextStateName">nextStateName</a>: <a href="#akka.actor;AbstractFSM;S" title="S">S</a><span class="delimiter">)</span>: <a href="#akka.actor.FSM.State.readResolve" title="AbstractFSM.this.State">State</a> = <a href="#akka.actor;FSM.goto" title="(nextStateName: S)AbstractFSM.this.State">goto</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.goTo.nextStateName" title="S">nextStateName</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Schedule named timer to deliver message after given delay, possibly repeating.
   * Any existing timer with the same name will automatically be canceled before
   * adding the new timer.
   * @param name identifier to be used with cancelTimer()
   * @param msg message to be delivered
   * @param timeout delay of first message delivery and between subsequent messages
   * @return current state descriptor
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <a title="(name: String, msg: Any, timeout: scala.concurrent.duration.FiniteDuration)Unit" id="akka.actor;AbstractFSM.setTimer(fb356e7892)">setTimer</a><span class="delimiter">(</span><a title="String" id="akka.actor;AbstractFSM.setTimer(fb356e7892).name">name</a>: <span title="String">String</span>, <a title="Any" id="akka.actor;AbstractFSM.setTimer(fb356e7892).msg">msg</a>: <span title="Any">Any</span>, <a title="scala.concurrent.duration.FiniteDuration" id="akka.actor;AbstractFSM.setTimer(fb356e7892).timeout">timeout</a>: <span title="scala.concurrent.duration.FiniteDuration">FiniteDuration</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> =
    <a href="#akka.actor;FSM.setTimer" title="(name: String, msg: Any, timeout: scala.concurrent.duration.FiniteDuration, repeat: Boolean)Unit">setTimer</a><span class="delimiter">(</span><a href="#akka.actor;AbstractFSM.setTimer(fb356e7892).name" title="String">name</a>, <a href="#akka.actor;AbstractFSM.setTimer(fb356e7892).msg" title="Any">msg</a>, <a href="#akka.actor;AbstractFSM.setTimer(fb356e7892).timeout" title="scala.concurrent.duration.FiniteDuration">timeout</a>, <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span>;

  <span class="comment">/**
   * Default reason if calling `stop()`.
   */</span>
  <span class="keyword">val</span> <a title="akka.actor.FSM.Reason" id="akka.actor;AbstractFSM.Normal">Normal</a>: FSM.<a href="#akka.actor.FSM;Reason" title="akka.actor.FSM.Reason">Reason</a> = <a href="#akka.actor.FSM" title="akka.actor.FSM.type">FSM</a>.<a href="#akka.actor.FSM.Normal.readResolve" title="akka.actor.FSM.Normal.type">Normal</a>

  <span class="comment">/**
   * Reason given when someone was calling `system.stop(fsm)` from outside;
   * also applies to `Stop` supervision directive.
   */</span>
  <span class="keyword">val</span> <a title="akka.actor.FSM.Reason" id="akka.actor;AbstractFSM.Shutdown">Shutdown</a>: FSM.<a href="#akka.actor.FSM;Reason" title="akka.actor.FSM.Reason">Reason</a> = <a href="#akka.actor.FSM" title="akka.actor.FSM.type">FSM</a>.<a href="#akka.actor.FSM.Shutdown.readResolve" title="akka.actor.FSM.Shutdown.type">Shutdown</a>
<span class="delimiter">}</span>

<span class="comment">/**
 * Java API: compatible with lambda expressions
 *
 * Finite State Machine actor abstract base class.
 *
 * This is an EXPERIMENTAL feature and is subject to change until it has received more real world testing.
 */</span>
<span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class AbstractLoggingFSM[S, D] extends akka.actor.AbstractFSM[S,D] with akka.actor.LoggingFSM[S,D]" id="akka.actor;AbstractLoggingFSM">AbstractLoggingFSM</a><span class="delimiter">[</span><a title="" id="akka.actor;AbstractLoggingFSM;S">S</a>, <a title="" id="akka.actor;AbstractLoggingFSM;D">D</a><span class="delimiter">]</span> <a href="#akka.actor;AbstractLoggingFSM" title="akka.actor.AbstractLoggingFSM[S,D]" class="keyword">extends</a> <a href="#akka.actor;AbstractFSM" title="akka.actor.AbstractFSM[S,D]">AbstractFSM</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span> <span class="keyword">with</span> <a href="#akka.actor;LoggingFSM" title="akka.actor.LoggingFSM[S,D]">LoggingFSM</a><span class="delimiter">[</span>S, D<span class="delimiter">]</span>

        </pre>
    </body>
</html>
