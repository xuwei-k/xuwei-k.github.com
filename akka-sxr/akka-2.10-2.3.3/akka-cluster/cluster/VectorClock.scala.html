<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>akka-cluster/cluster/VectorClock.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Copyright (C) 2009-2014 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>

<span class="keyword">package</span> akka.cluster

<span class="keyword">import</span> akka.AkkaException

<span class="keyword">import</span> <span title="System.type">System</span>.<span class="delimiter">{</span> currentTimeMillis ⇒ newTimestamp <span class="delimiter">}</span>
<span class="keyword">import</span> java.security.MessageDigest
<span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong
<span class="keyword">import</span> scala.collection.immutable.TreeMap
<span class="keyword">import</span> scala.annotation.tailrec

<span class="comment">/**
 * VectorClock module with helper classes and methods.
 *
 * Based on code from the 'vlock' VectorClock library by Coda Hale.
 */</span>
<span class="keyword">private</span><span class="delimiter">[</span>cluster<span class="delimiter">]</span> <span class="keyword">object</span> <a title="akka.cluster.VectorClock.type" id="akka.cluster.VectorClock.readResolve">VectorClock</a> <a href="#akka.cluster.VectorClock.readResolve" title="akka.cluster.VectorClock.type" class="delimiter">{</a>

  <span class="comment">/**
   * Hash representation of a versioned node name.
   */</span>
  <span class="keyword">type</span> <a title="String" id="akka.cluster.VectorClock;Node">Node</a> = <span title="String">String</span>

  <span class="keyword">object</span> <a title="akka.cluster.VectorClock.Node.type" id="akka.cluster.VectorClock.Node">Node</a> <a href="#akka.cluster.VectorClock.Node" title="akka.cluster.VectorClock.Node.type" class="delimiter">{</a>

    <span class="keyword">def</span> <a title="(name: String)akka.cluster.VectorClock.Node" id="akka.cluster.VectorClock.Node.apply">apply</a><span class="delimiter">(</span><a title="String" id="akka.cluster.VectorClock.Node.apply.name">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="akka.cluster.VectorClock.Node">Node</span> = <a href="#akka.cluster.VectorClock.Node.hash" title="(name: String)String">hash</a><span class="delimiter">(</span><a href="#akka.cluster.VectorClock.Node.apply.name" title="String">name</a><span class="delimiter">)</span>

    <span class="keyword">def</span> <a title="(hash: String)akka.cluster.VectorClock.Node" id="akka.cluster.VectorClock.Node.fromHash">fromHash</a><span class="delimiter">(</span><a title="String" id="akka.cluster.VectorClock.Node.fromHash.hash">hash</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="akka.cluster.VectorClock.Node">Node</span> = <a href="#akka.cluster.VectorClock.Node.fromHash.hash" title="String">hash</a>

    <span class="keyword">private</span> <span class="keyword">def</span> <a title="(name: String)String" id="akka.cluster.VectorClock.Node.hash">hash</a><span class="delimiter">(</span><a title="String" id="akka.cluster.VectorClock.Node.hash.name">name</a>: <span title="String">String</span><span class="delimiter">)</span>: <span title="String">String</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="java.security.MessageDigest" id="akka.cluster.VectorClock.Node.hash.digester">digester</a> = <span title="java.security.MessageDigest.type">MessageDigest</span>.<span title="(x$1: String)java.security.MessageDigest">getInstance</span><span class="delimiter">(</span><span title="String(&quot;MD5&quot;)" class="string">&quot;MD5&quot;</span><span class="delimiter">)</span>
      <a href="#akka.cluster.VectorClock.Node.hash.digester" title="java.security.MessageDigest">digester</a> <span title="(x$1: Array[Byte])Unit">update</span> <a href="#akka.cluster.VectorClock.Node.hash.name" title="String">name</a>.<span title="(x$1: String)Array[Byte]">getBytes</span><span class="delimiter">(</span><span title="String(&quot;UTF-8&quot;)" class="string">&quot;UTF-8&quot;</span><span class="delimiter">)</span>
      <a href="#akka.cluster.VectorClock.Node.hash.digester" title="java.security.MessageDigest">digester</a>.<span title="implicit scala.Predef.byteArrayOps : (xs: Array[Byte])scala.collection.mutable.ArrayOps[Byte]">digest</span>.<span title="(f: Byte =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[Array[Byte],String,Array[String]])Array[String]">map</span> <span title="(xs: Array[String])scala.collection.mutable.ArrayOps[String]" class="delimiter">{</span> <a title="Byte" id="akka.cluster.VectorClock.Node.hash.$anonfun.h">h</a> ⇒ <span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;%02x&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><span title="Int(255)" class="int">0xFF</span> <span title="(x: Byte)Int">&amp;</span> <a href="#akka.cluster.VectorClock.Node.hash.$anonfun.h" title="Byte">h</a><span class="delimiter">)</span> <span class="delimiter">}</span>.<span title="=&gt; String">mkString</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="akka.cluster.VectorClock.Timestamp.type" id="akka.cluster.VectorClock.Timestamp">Timestamp</a> <a href="#akka.cluster.VectorClock.Timestamp" title="akka.cluster.VectorClock.Timestamp.type" class="delimiter">{</a>
    <span class="keyword">final</span> <span class="keyword">val</span> <a title="Long(0L)" id="akka.cluster.VectorClock.Timestamp.Zero">Zero</a> = <span title="Long(0L)" class="long">0L</span>
    <span class="keyword">final</span> <span class="keyword">val</span> <a title="Long(-9223372036854775808L)" id="akka.cluster.VectorClock.Timestamp.EndMarker">EndMarker</a> = Long.<span title="Long(-9223372036854775808L)">MinValue</span>
  <span class="delimiter">}</span>

  <span class="keyword">sealed</span> <span class="keyword">trait</span> <a title="trait Ordering extends AnyRef" id="akka.cluster.VectorClock;Ordering">Ordering</a>
  <span class="keyword">case object</span> <a href="#akka.cluster.VectorClock.After.productElement.x$1" title="akka.cluster.VectorClock.After.type" id="akka.cluster.VectorClock.After.readResolve">After</a> <span title="Product" class="keyword">extends</span> <a href="#akka.cluster.VectorClock;Ordering" title="akka.cluster.VectorClock.Ordering">Ordering</a>
  <span class="keyword">case object</span> <a href="#akka.cluster.VectorClock.Before.productElement.x$1" title="akka.cluster.VectorClock.Before.type" id="akka.cluster.VectorClock.Before.readResolve">Before</a> <span title="Product" class="keyword">extends</span> <a href="#akka.cluster.VectorClock;Ordering" title="akka.cluster.VectorClock.Ordering">Ordering</a>
  <span class="keyword">case object</span> <a href="#akka.cluster.VectorClock.Same.productElement.x$1" title="akka.cluster.VectorClock.Same.type" id="akka.cluster.VectorClock.Same.readResolve">Same</a> <span title="Product" class="keyword">extends</span> <a href="#akka.cluster.VectorClock;Ordering" title="akka.cluster.VectorClock.Ordering">Ordering</a>
  <span class="keyword">case object</span> <a href="#akka.cluster.VectorClock.Concurrent.productElement.x$1" title="akka.cluster.VectorClock.Concurrent.type" id="akka.cluster.VectorClock.Concurrent.readResolve">Concurrent</a> <span title="Product" class="keyword">extends</span> <a href="#akka.cluster.VectorClock;Ordering" title="akka.cluster.VectorClock.Ordering">Ordering</a>
  <span class="comment">/**
   * Marker to ensure that we do a full order comparison instead of bailing out early.
   */</span>
  <span class="keyword">private</span> <span class="keyword">case object</span> <a href="#akka.cluster.VectorClock.FullOrder.productElement.x$1" title="akka.cluster.VectorClock.FullOrder.type" id="akka.cluster.VectorClock.FullOrder.readResolve">FullOrder</a> <span title="Product" class="keyword">extends</span> <a href="#akka.cluster.VectorClock;Ordering" title="akka.cluster.VectorClock.Ordering">Ordering</a>

  <span class="comment">/**
   * Marker to signal that we have reached the end of a vector clock.
   */</span>
  <span class="keyword">private</span> <span class="keyword">val</span> <a title="(akka.cluster.VectorClock.Node, Long)" id="akka.cluster.VectorClock.cmpEndMarker">cmpEndMarker</a> = <span title="(_1: akka.cluster.VectorClock.Node, _2: Long)(akka.cluster.VectorClock.Node, Long)" class="delimiter">(</span><a href="#akka.cluster.VectorClock.readResolve" title="akka.cluster.VectorClock.type">VectorClock</a>.<a href="#akka.cluster.VectorClock.Node.apply" title="(name: String)akka.cluster.VectorClock.Node">Node</a><span class="delimiter">(</span><span title="String(&quot;endmarker&quot;)" class="string">&quot;endmarker&quot;</span><span class="delimiter">)</span>, Timestamp.<span title="Long(-9223372036854775808L)">EndMarker</span><span class="delimiter">)</span>

<span class="delimiter">}</span>

<span class="comment">/**
 * Representation of a Vector-based clock (counting clock), inspired by Lamport logical clocks.
 * {{{
 * Reference:
 *    1) Leslie Lamport (1978). &quot;Time, clocks, and the ordering of events in a distributed system&quot;. Communications of the ACM 21 (7): 558-565.
 *    2) Friedemann Mattern (1988). &quot;Virtual Time and Global States of Distributed Systems&quot;. Workshop on Parallel and Distributed Algorithms: pp. 215-226
 * }}}
 *
 * Based on code from the 'vlock' VectorClock library by Coda Hale.
 */</span>
@SerialVersionUID<span class="delimiter">(</span><span class="long">1L</span><span class="delimiter">)</span>
<span class="keyword">case class</span> <a title="(versions: scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long])akka.cluster.VectorClock" id="akka.cluster;VectorClock.equals">VectorClock</a><a href="#akka.cluster;VectorClock.equals" title="Product" class="delimiter">(</a>
  <a title="scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]" id="akka.cluster;VectorClock.copy$default$1">versions</a>: <span title="scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">TreeMap</span><span class="delimiter">[</span>VectorClock.Node, Long<span class="delimiter">]</span> = <span title="scala.collection.immutable.TreeMap.type">TreeMap</span>.<span title="[A, B](implicit ord: Ordering[A])scala.collection.immutable.TreeMap[A,B]">empty</span><span title="(implicit ord: Ordering[akka.cluster.VectorClock.Node])scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]" class="delimiter">[</span>VectorClock.<span title="akka.cluster.VectorClock.Node">Node</span>, <span title="Long">Long</span><span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">{</span>

  <span class="keyword">import</span> <a href="#akka.cluster.VectorClock.readResolve" title="akka.cluster.VectorClock.type">VectorClock</a>._

  <span class="comment">/**
   * Increment the version for the node passed as argument. Returns a new VectorClock.
   */</span>
  <span class="keyword">def</span> <a title="(node: akka.cluster.VectorClock.Node)akka.cluster.VectorClock" id="akka.cluster;VectorClock.:+">:+</a><span class="delimiter">(</span><a title="akka.cluster.VectorClock.Node" id="akka.cluster;VectorClock.:+.node">node</a>: <span title="akka.cluster.VectorClock.Node">Node</span><span class="delimiter">)</span>: <a href="#akka.cluster;VectorClock.equals" title="akka.cluster.VectorClock">VectorClock</a> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="Long" id="akka.cluster;VectorClock.:+.currentTimestamp">currentTimestamp</a> = <a href="#akka.cluster;VectorClock.copy$default$1" title="=&gt; scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">versions</a>.<span title="(key: akka.cluster.VectorClock.Node, default: =&gt; Long)Long">getOrElse</span><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.:+.node" title="akka.cluster.VectorClock.Node">node</a>, Timestamp.<span title="Long(0L)">Zero</span><span class="delimiter">)</span>
    <a href="#akka.cluster;VectorClock.equals" title="(versions: scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long])akka.cluster.VectorClock">copy</a><span class="delimiter">(</span>versions = <a href="#akka.cluster;VectorClock.copy$default$1" title="=&gt; scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">versions</a>.<span title="(key: akka.cluster.VectorClock.Node, value: Long)scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">updated</span><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.:+.node" title="akka.cluster.VectorClock.Node">node</a>, <a href="#akka.cluster;VectorClock.:+.currentTimestamp" title="Long">currentTimestamp</a> <span title="(x: Int)Long">+</span> <span title="Int(1)" class="int">1</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Returns true if &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;that&lt;/code&gt; are concurrent else false.
   */</span>
  <span class="keyword">def</span> <a title="(that: akka.cluster.VectorClock)Boolean" id="akka.cluster;VectorClock.<>">&lt;&gt;</a><span class="delimiter">(</span><a title="akka.cluster.VectorClock" id="akka.cluster;VectorClock.<>.that">that</a>: <a href="#akka.cluster;VectorClock.equals" title="akka.cluster.VectorClock">VectorClock</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#akka.cluster;VectorClock.compareOnlyTo" title="(that: akka.cluster.VectorClock, order: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering">compareOnlyTo</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.<>.that" title="akka.cluster.VectorClock">that</a>, <a href="#akka.cluster.VectorClock.Concurrent.readResolve" title="akka.cluster.VectorClock.Concurrent.type">Concurrent</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.Concurrent.readResolve" title="akka.cluster.VectorClock.Concurrent.type">Concurrent</a>

  <span class="comment">/**
   * Returns true if &lt;code&gt;this&lt;/code&gt; is before &lt;code&gt;that&lt;/code&gt; else false.
   */</span>
  <span class="keyword">def</span> <a title="(that: akka.cluster.VectorClock)Boolean" id="akka.cluster;VectorClock.<">&lt;</a><span class="delimiter">(</span><a title="akka.cluster.VectorClock" id="akka.cluster;VectorClock.<.that">that</a>: <a href="#akka.cluster;VectorClock.equals" title="akka.cluster.VectorClock">VectorClock</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#akka.cluster;VectorClock.compareOnlyTo" title="(that: akka.cluster.VectorClock, order: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering">compareOnlyTo</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.<.that" title="akka.cluster.VectorClock">that</a>, <a href="#akka.cluster.VectorClock.Before.readResolve" title="akka.cluster.VectorClock.Before.type">Before</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.Before.readResolve" title="akka.cluster.VectorClock.Before.type">Before</a>

  <span class="comment">/**
   * Returns true if &lt;code&gt;this&lt;/code&gt; is after &lt;code&gt;that&lt;/code&gt; else false.
   */</span>
  <span class="keyword">def</span> <a title="(that: akka.cluster.VectorClock)Boolean" id="akka.cluster;VectorClock.>">&gt;</a><span class="delimiter">(</span><a title="akka.cluster.VectorClock" id="akka.cluster;VectorClock.>.that">that</a>: <a href="#akka.cluster;VectorClock.equals" title="akka.cluster.VectorClock">VectorClock</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#akka.cluster;VectorClock.compareOnlyTo" title="(that: akka.cluster.VectorClock, order: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering">compareOnlyTo</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.>.that" title="akka.cluster.VectorClock">that</a>, <a href="#akka.cluster.VectorClock.After.readResolve" title="akka.cluster.VectorClock.After.type">After</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.After.readResolve" title="akka.cluster.VectorClock.After.type">After</a>

  <span class="comment">/**
   * Returns true if this VectorClock has the same history as the 'that' VectorClock else false.
   */</span>
  <span class="keyword">def</span> <a title="(that: akka.cluster.VectorClock)Boolean" id="akka.cluster;VectorClock.==(f9995ab41c)">==</a><span class="delimiter">(</span><a title="akka.cluster.VectorClock" id="akka.cluster;VectorClock.==(f9995ab41c).that">that</a>: <a href="#akka.cluster;VectorClock.equals" title="akka.cluster.VectorClock">VectorClock</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#akka.cluster;VectorClock.compareOnlyTo" title="(that: akka.cluster.VectorClock, order: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering">compareOnlyTo</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.==(f9995ab41c).that" title="akka.cluster.VectorClock">that</a>, <a href="#akka.cluster.VectorClock.Same.readResolve" title="akka.cluster.VectorClock.Same.type">Same</a><span class="delimiter">)</span> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.Same.readResolve" title="akka.cluster.VectorClock.Same.type">Same</a>

  <span class="comment">/**
   * Vector clock comparison according to the semantics described by compareTo, with the ability to bail
   * out early if the we can't reach the Ordering that we are looking for.
   *
   * The ordering always starts with Same and can then go to Same, Before or After
   * If we're on After we can only go to After or Concurrent
   * If we're on Before we can only go to Before or Concurrent
   * If we go to Concurrent we exit the loop immediately
   *
   * If you send in the ordering FullOrder, you will get a full comparison.
   */</span>
  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="(that: akka.cluster.VectorClock, order: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering" id="akka.cluster;VectorClock.compareOnlyTo">compareOnlyTo</a><span class="delimiter">(</span><a title="akka.cluster.VectorClock" id="akka.cluster;VectorClock.compareOnlyTo.that">that</a>: <a href="#akka.cluster;VectorClock.equals" title="akka.cluster.VectorClock">VectorClock</a>, <a title="akka.cluster.VectorClock.Ordering" id="akka.cluster;VectorClock.compareOnlyTo.order">order</a>: <a href="#akka.cluster.VectorClock;Ordering" title="akka.cluster.VectorClock.Ordering">Ordering</a><span class="delimiter">)</span>: <a href="#akka.cluster.VectorClock;Ordering" title="akka.cluster.VectorClock.Ordering">Ordering</a> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[T](iter: Iterator[T], default: T)T" id="akka.cluster;VectorClock.compareOnlyTo.nextOrElse">nextOrElse</a><span class="delimiter">[</span><a title="" id="akka.cluster;VectorClock.compareOnlyTo.nextOrElse;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="Iterator[T]" id="akka.cluster;VectorClock.compareOnlyTo.nextOrElse.iter">iter</a>: <span title="Iterator[T]">Iterator</span><span class="delimiter">[</span>T<span class="delimiter">]</span>, <a title="T" id="akka.cluster;VectorClock.compareOnlyTo.nextOrElse.default">default</a>: <a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse;T" title="T">T</a><span class="delimiter">)</span>: <a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse;T" title="T">T</a> = <span title="T" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse.iter" title="Iterator[T]">iter</a>.<span title="=&gt; Boolean">hasNext</span><span class="delimiter">)</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse.iter" title="Iterator[T]">iter</a>.<span title="()T">next</span><span class="delimiter">(</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse.default" title="T">default</a>

    <span class="keyword">def</span> <a title="(i1: Iterator[(akka.cluster.VectorClock.Node, Long)], i2: Iterator[(akka.cluster.VectorClock.Node, Long)], requestedOrder: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering" id="akka.cluster;VectorClock.compareOnlyTo.compare">compare</a><span class="delimiter">(</span><a title="Iterator[(akka.cluster.VectorClock.Node, Long)]" id="akka.cluster;VectorClock.compareOnlyTo.compare.i1">i1</a>: <span title="Iterator[(akka.cluster.VectorClock.Node, Long)]">Iterator</span><span class="delimiter">[</span><span class="delimiter">(</span>Node, Long<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="Iterator[(akka.cluster.VectorClock.Node, Long)]" id="akka.cluster;VectorClock.compareOnlyTo.compare.i2">i2</a>: <span title="Iterator[(akka.cluster.VectorClock.Node, Long)]">Iterator</span><span class="delimiter">[</span><span class="delimiter">(</span>Node, Long<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="akka.cluster.VectorClock.Ordering" id="akka.cluster;VectorClock.compareOnlyTo.compare.requestedOrder">requestedOrder</a>: <a href="#akka.cluster.VectorClock;Ordering" title="akka.cluster.VectorClock.Ordering">Ordering</a><span class="delimiter">)</span>: <a href="#akka.cluster.VectorClock;Ordering" title="akka.cluster.VectorClock.Ordering">Ordering</a> = <span class="delimiter">{</span>
      @tailrec
      <span class="keyword">def</span> <a title="(nt1: (akka.cluster.VectorClock.Node, Long), nt2: (akka.cluster.VectorClock.Node, Long), currentOrder: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering" id="akka.cluster;VectorClock.compareOnlyTo.compare.compareNext">compareNext</a><span class="delimiter">(</span><a title="(akka.cluster.VectorClock.Node, Long)" id="akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nt1">nt1</a>: <span title="(akka.cluster.VectorClock.Node, Long)" class="delimiter">(</span>Node, Long<span class="delimiter">)</span>, <a title="(akka.cluster.VectorClock.Node, Long)" id="akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nt2">nt2</a>: <span title="(akka.cluster.VectorClock.Node, Long)" class="delimiter">(</span>Node, Long<span class="delimiter">)</span>, <a title="akka.cluster.VectorClock.Ordering" id="akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.currentOrder">currentOrder</a>: <a href="#akka.cluster.VectorClock;Ordering" title="akka.cluster.VectorClock.Ordering">Ordering</a><span class="delimiter">)</span>: <a href="#akka.cluster.VectorClock;Ordering" title="akka.cluster.VectorClock.Ordering">Ordering</a> =
        <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.requestedOrder" title="akka.cluster.VectorClock.Ordering">requestedOrder</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#akka.cluster.VectorClock.FullOrder.readResolve" title="akka.cluster.VectorClock.FullOrder.type">FullOrder</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.currentOrder" title="akka.cluster.VectorClock.Ordering">currentOrder</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#akka.cluster.VectorClock.Same.readResolve" title="akka.cluster.VectorClock.Same.type">Same</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.currentOrder" title="akka.cluster.VectorClock.Ordering">currentOrder</a> <span title="(x$1: AnyRef)Boolean">ne</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.requestedOrder" title="akka.cluster.VectorClock.Ordering">requestedOrder</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.currentOrder" title="akka.cluster.VectorClock.Ordering">currentOrder</a>
        <span class="keyword">else</span> <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nt1" title="(akka.cluster.VectorClock.Node, Long)">nt1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.cmpEndMarker" title="=&gt; (akka.cluster.VectorClock.Node, Long)">cmpEndMarker</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nt2" title="(akka.cluster.VectorClock.Node, Long)">nt2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.cmpEndMarker" title="=&gt; (akka.cluster.VectorClock.Node, Long)">cmpEndMarker</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.currentOrder" title="akka.cluster.VectorClock.Ordering">currentOrder</a>
        <span class="comment">// i1 is empty but i2 is not, so i1 can only be Before</span>
        <span class="keyword">else</span> <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nt1" title="(akka.cluster.VectorClock.Node, Long)">nt1</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.cmpEndMarker" title="=&gt; (akka.cluster.VectorClock.Node, Long)">cmpEndMarker</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.currentOrder" title="akka.cluster.VectorClock.Ordering">currentOrder</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.After.readResolve" title="akka.cluster.VectorClock.After.type">After</a><span class="delimiter">)</span> <a href="#akka.cluster.VectorClock.Concurrent.readResolve" title="akka.cluster.VectorClock.Concurrent.type">Concurrent</a> <span class="keyword">else</span> <a href="#akka.cluster.VectorClock.Before.readResolve" title="akka.cluster.VectorClock.Before.type">Before</a> <span class="delimiter">}</span>
        <span class="comment">// i2 is empty but i1 is not, so i1 can only be After</span>
        <span class="keyword">else</span> <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nt2" title="(akka.cluster.VectorClock.Node, Long)">nt2</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.cmpEndMarker" title="=&gt; (akka.cluster.VectorClock.Node, Long)">cmpEndMarker</a><span class="delimiter">)</span> <span class="delimiter">{</span> <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.currentOrder" title="akka.cluster.VectorClock.Ordering">currentOrder</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.Before.readResolve" title="akka.cluster.VectorClock.Before.type">Before</a><span class="delimiter">)</span> <a href="#akka.cluster.VectorClock.Concurrent.readResolve" title="akka.cluster.VectorClock.Concurrent.type">Concurrent</a> <span class="keyword">else</span> <a href="#akka.cluster.VectorClock.After.readResolve" title="akka.cluster.VectorClock.After.type">After</a> <span class="delimiter">}</span>
        <span class="keyword">else</span> <span class="delimiter">{</span>
          <span class="comment">// compare the nodes</span>
          <span class="keyword">val</span> <a title="Int" id="akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nc">nc</a> = <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nt1" title="(akka.cluster.VectorClock.Node, Long)">nt1</a>.<span title="=&gt; akka.cluster.VectorClock.Node">_1</span> <span title="(x$1: String)Int">compareTo</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nt2" title="(akka.cluster.VectorClock.Node, Long)">nt2</a>.<span title="=&gt; akka.cluster.VectorClock.Node">_1</span>
          <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nc" title="Int">nc</a> <span title="(x: Int)Boolean">==</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="comment">// both nodes exist compare the timestamps</span>
            <span class="comment">// same timestamp so just continue with the next nodes</span>
            <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nt1" title="(akka.cluster.VectorClock.Node, Long)">nt1</a>.<span title="=&gt; Long">_2</span> <span title="(x: Long)Boolean">==</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nt2" title="(akka.cluster.VectorClock.Node, Long)">nt2</a>.<span title="=&gt; Long">_2</span><span class="delimiter">)</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext" title="(nt1: (akka.cluster.VectorClock.Node, Long), nt2: (akka.cluster.VectorClock.Node, Long), currentOrder: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering">compareNext</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse" title="(iter: Iterator[(akka.cluster.VectorClock.Node, Long)], default: (akka.cluster.VectorClock.Node, Long))(akka.cluster.VectorClock.Node, Long)">nextOrElse</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.i1" title="Iterator[(akka.cluster.VectorClock.Node, Long)]">i1</a>, <a href="#akka.cluster.VectorClock.cmpEndMarker" title="=&gt; (akka.cluster.VectorClock.Node, Long)">cmpEndMarker</a><span class="delimiter">)</span>, <a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse" title="(iter: Iterator[(akka.cluster.VectorClock.Node, Long)], default: (akka.cluster.VectorClock.Node, Long))(akka.cluster.VectorClock.Node, Long)">nextOrElse</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.i2" title="Iterator[(akka.cluster.VectorClock.Node, Long)]">i2</a>, <a href="#akka.cluster.VectorClock.cmpEndMarker" title="=&gt; (akka.cluster.VectorClock.Node, Long)">cmpEndMarker</a><span class="delimiter">)</span>, <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.currentOrder" title="akka.cluster.VectorClock.Ordering">currentOrder</a><span class="delimiter">)</span>
            <span class="keyword">else</span> <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nt1" title="(akka.cluster.VectorClock.Node, Long)">nt1</a>.<span title="=&gt; Long">_2</span> <span title="(x: Long)Boolean">&lt;</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nt2" title="(akka.cluster.VectorClock.Node, Long)">nt2</a>.<span title="=&gt; Long">_2</span><span class="delimiter">)</span> <span class="delimiter">{</span>
              <span class="comment">// t1 is less than t2, so i1 can only be Before</span>
              <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.currentOrder" title="akka.cluster.VectorClock.Ordering">currentOrder</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.After.readResolve" title="akka.cluster.VectorClock.After.type">After</a><span class="delimiter">)</span> <a href="#akka.cluster.VectorClock.Concurrent.readResolve" title="akka.cluster.VectorClock.Concurrent.type">Concurrent</a>
              <span class="keyword">else</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext" title="(nt1: (akka.cluster.VectorClock.Node, Long), nt2: (akka.cluster.VectorClock.Node, Long), currentOrder: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering">compareNext</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse" title="(iter: Iterator[(akka.cluster.VectorClock.Node, Long)], default: (akka.cluster.VectorClock.Node, Long))(akka.cluster.VectorClock.Node, Long)">nextOrElse</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.i1" title="Iterator[(akka.cluster.VectorClock.Node, Long)]">i1</a>, <a href="#akka.cluster.VectorClock.cmpEndMarker" title="=&gt; (akka.cluster.VectorClock.Node, Long)">cmpEndMarker</a><span class="delimiter">)</span>, <a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse" title="(iter: Iterator[(akka.cluster.VectorClock.Node, Long)], default: (akka.cluster.VectorClock.Node, Long))(akka.cluster.VectorClock.Node, Long)">nextOrElse</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.i2" title="Iterator[(akka.cluster.VectorClock.Node, Long)]">i2</a>, <a href="#akka.cluster.VectorClock.cmpEndMarker" title="=&gt; (akka.cluster.VectorClock.Node, Long)">cmpEndMarker</a><span class="delimiter">)</span>, <a href="#akka.cluster.VectorClock.Before.readResolve" title="akka.cluster.VectorClock.Before.type">Before</a><span class="delimiter">)</span>
            <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
              <span class="comment">// t2 is less than t1, so i1 can only be After</span>
              <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.currentOrder" title="akka.cluster.VectorClock.Ordering">currentOrder</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.Before.readResolve" title="akka.cluster.VectorClock.Before.type">Before</a><span class="delimiter">)</span> <a href="#akka.cluster.VectorClock.Concurrent.readResolve" title="akka.cluster.VectorClock.Concurrent.type">Concurrent</a>
              <span class="keyword">else</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext" title="(nt1: (akka.cluster.VectorClock.Node, Long), nt2: (akka.cluster.VectorClock.Node, Long), currentOrder: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering">compareNext</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse" title="(iter: Iterator[(akka.cluster.VectorClock.Node, Long)], default: (akka.cluster.VectorClock.Node, Long))(akka.cluster.VectorClock.Node, Long)">nextOrElse</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.i1" title="Iterator[(akka.cluster.VectorClock.Node, Long)]">i1</a>, <a href="#akka.cluster.VectorClock.cmpEndMarker" title="=&gt; (akka.cluster.VectorClock.Node, Long)">cmpEndMarker</a><span class="delimiter">)</span>, <a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse" title="(iter: Iterator[(akka.cluster.VectorClock.Node, Long)], default: (akka.cluster.VectorClock.Node, Long))(akka.cluster.VectorClock.Node, Long)">nextOrElse</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.i2" title="Iterator[(akka.cluster.VectorClock.Node, Long)]">i2</a>, <a href="#akka.cluster.VectorClock.cmpEndMarker" title="=&gt; (akka.cluster.VectorClock.Node, Long)">cmpEndMarker</a><span class="delimiter">)</span>, <a href="#akka.cluster.VectorClock.After.readResolve" title="akka.cluster.VectorClock.After.type">After</a><span class="delimiter">)</span>
            <span class="delimiter">}</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nc" title="Int">nc</a> <span title="(x: Int)Boolean">&lt;</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span> <span class="delimiter">{</span>
            <span class="comment">// this node only exists in i1 so i1 can only be After</span>
            <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.currentOrder" title="akka.cluster.VectorClock.Ordering">currentOrder</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.Before.readResolve" title="akka.cluster.VectorClock.Before.type">Before</a><span class="delimiter">)</span> <a href="#akka.cluster.VectorClock.Concurrent.readResolve" title="akka.cluster.VectorClock.Concurrent.type">Concurrent</a>
            <span class="keyword">else</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext" title="(nt1: (akka.cluster.VectorClock.Node, Long), nt2: (akka.cluster.VectorClock.Node, Long), currentOrder: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering">compareNext</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse" title="(iter: Iterator[(akka.cluster.VectorClock.Node, Long)], default: (akka.cluster.VectorClock.Node, Long))(akka.cluster.VectorClock.Node, Long)">nextOrElse</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.i1" title="Iterator[(akka.cluster.VectorClock.Node, Long)]">i1</a>, <a href="#akka.cluster.VectorClock.cmpEndMarker" title="=&gt; (akka.cluster.VectorClock.Node, Long)">cmpEndMarker</a><span class="delimiter">)</span>, <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nt2" title="(akka.cluster.VectorClock.Node, Long)">nt2</a>, <a href="#akka.cluster.VectorClock.After.readResolve" title="akka.cluster.VectorClock.After.type">After</a><span class="delimiter">)</span>
          <span class="delimiter">}</span> <span class="keyword">else</span> <span class="delimiter">{</span>
            <span class="comment">// this node only exists in i2 so i1 can only be Before</span>
            <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.currentOrder" title="akka.cluster.VectorClock.Ordering">currentOrder</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.After.readResolve" title="akka.cluster.VectorClock.After.type">After</a><span class="delimiter">)</span> <a href="#akka.cluster.VectorClock.Concurrent.readResolve" title="akka.cluster.VectorClock.Concurrent.type">Concurrent</a>
            <span class="keyword">else</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext" title="(nt1: (akka.cluster.VectorClock.Node, Long), nt2: (akka.cluster.VectorClock.Node, Long), currentOrder: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering">compareNext</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext.nt1" title="(akka.cluster.VectorClock.Node, Long)">nt1</a>, <a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse" title="(iter: Iterator[(akka.cluster.VectorClock.Node, Long)], default: (akka.cluster.VectorClock.Node, Long))(akka.cluster.VectorClock.Node, Long)">nextOrElse</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.i2" title="Iterator[(akka.cluster.VectorClock.Node, Long)]">i2</a>, <a href="#akka.cluster.VectorClock.cmpEndMarker" title="=&gt; (akka.cluster.VectorClock.Node, Long)">cmpEndMarker</a><span class="delimiter">)</span>, <a href="#akka.cluster.VectorClock.Before.readResolve" title="akka.cluster.VectorClock.Before.type">Before</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>

      <a href="#akka.cluster;VectorClock.compareOnlyTo.compare.compareNext" title="(nt1: (akka.cluster.VectorClock.Node, Long), nt2: (akka.cluster.VectorClock.Node, Long), currentOrder: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering">compareNext</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse" title="(iter: Iterator[(akka.cluster.VectorClock.Node, Long)], default: (akka.cluster.VectorClock.Node, Long))(akka.cluster.VectorClock.Node, Long)">nextOrElse</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.i1" title="Iterator[(akka.cluster.VectorClock.Node, Long)]">i1</a>, <a href="#akka.cluster.VectorClock.cmpEndMarker" title="=&gt; (akka.cluster.VectorClock.Node, Long)">cmpEndMarker</a><span class="delimiter">)</span>, <a href="#akka.cluster;VectorClock.compareOnlyTo.nextOrElse" title="(iter: Iterator[(akka.cluster.VectorClock.Node, Long)], default: (akka.cluster.VectorClock.Node, Long))(akka.cluster.VectorClock.Node, Long)">nextOrElse</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.compare.i2" title="Iterator[(akka.cluster.VectorClock.Node, Long)]">i2</a>, <a href="#akka.cluster.VectorClock.cmpEndMarker" title="=&gt; (akka.cluster.VectorClock.Node, Long)">cmpEndMarker</a><span class="delimiter">)</span>, <a href="#akka.cluster.VectorClock.Same.readResolve" title="akka.cluster.VectorClock.Same.type">Same</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.equals" title="VectorClock.this.type" class="keyword">this</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.that" title="akka.cluster.VectorClock">that</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.equals" title="VectorClock.this.type" class="keyword">this</a>.<a href="#akka.cluster;VectorClock.copy$default$1" title="=&gt; scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">versions</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.that" title="akka.cluster.VectorClock">that</a>.<a href="#akka.cluster;VectorClock.copy$default$1" title="=&gt; scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">versions</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.cluster.VectorClock.Same.readResolve" title="akka.cluster.VectorClock.Same.type">Same</a>
    <span class="keyword">else</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.compare" title="(i1: Iterator[(akka.cluster.VectorClock.Node, Long)], i2: Iterator[(akka.cluster.VectorClock.Node, Long)], requestedOrder: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering">compare</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.equals" title="VectorClock.this.type" class="keyword">this</a>.<a href="#akka.cluster;VectorClock.copy$default$1" title="=&gt; scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">versions</a>.<span title="=&gt; Iterator[(akka.cluster.VectorClock.Node, Long)]">iterator</span>, <a href="#akka.cluster;VectorClock.compareOnlyTo.that" title="akka.cluster.VectorClock">that</a>.<a href="#akka.cluster;VectorClock.copy$default$1" title="=&gt; scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">versions</a>.<span title="=&gt; Iterator[(akka.cluster.VectorClock.Node, Long)]">iterator</span>, <span title="akka.cluster.VectorClock.Ordering" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareOnlyTo.order" title="akka.cluster.VectorClock.Ordering">order</a> <span title="(x$1: AnyRef)Boolean">eq</span> <a href="#akka.cluster.VectorClock.Concurrent.readResolve" title="akka.cluster.VectorClock.Concurrent.type">Concurrent</a><span class="delimiter">)</span> <a href="#akka.cluster.VectorClock.FullOrder.readResolve" title="akka.cluster.VectorClock.FullOrder.type">FullOrder</a> <span class="keyword">else</span> <a href="#akka.cluster;VectorClock.compareOnlyTo.order" title="akka.cluster.VectorClock.Ordering">order</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Compare two vector clocks. The outcome will be one of the following:
   * &lt;p/&gt;
   * {{{
   *   1. Clock 1 is SAME (==)       as Clock 2 iff for all i c1(i) == c2(i)
   *   2. Clock 1 is BEFORE (&lt;)      Clock 2 iff for all i c1(i) &lt;= c2(i) and there exist a j such that c1(j) &lt; c2(j)
   *   3. Clock 1 is AFTER (&gt;)       Clock 2 iff for all i c1(i) &gt;= c2(i) and there exist a j such that c1(j) &gt; c2(j).
   *   4. Clock 1 is CONCURRENT (&lt;&gt;) to Clock 2 otherwise.
   * }}}
   */</span>
  <span class="keyword">def</span> <a title="(that: akka.cluster.VectorClock)akka.cluster.VectorClock.Ordering" id="akka.cluster;VectorClock.compareTo">compareTo</a><span class="delimiter">(</span><a title="akka.cluster.VectorClock" id="akka.cluster;VectorClock.compareTo.that">that</a>: <a href="#akka.cluster;VectorClock.equals" title="akka.cluster.VectorClock">VectorClock</a><span class="delimiter">)</span>: <a href="#akka.cluster.VectorClock;Ordering" title="akka.cluster.VectorClock.Ordering">Ordering</a> = <span class="delimiter">{</span>
    <a href="#akka.cluster;VectorClock.compareOnlyTo" title="(that: akka.cluster.VectorClock, order: akka.cluster.VectorClock.Ordering)akka.cluster.VectorClock.Ordering">compareOnlyTo</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.compareTo.that" title="akka.cluster.VectorClock">that</a>, <a href="#akka.cluster.VectorClock.FullOrder.readResolve" title="akka.cluster.VectorClock.FullOrder.type">FullOrder</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Merges this VectorClock with another VectorClock. E.g. merges its versioned history.
   */</span>
  <span class="keyword">def</span> <a title="(that: akka.cluster.VectorClock)akka.cluster.VectorClock" id="akka.cluster;VectorClock.merge">merge</a><span class="delimiter">(</span><a title="akka.cluster.VectorClock" id="akka.cluster;VectorClock.merge.that">that</a>: <a href="#akka.cluster;VectorClock.equals" title="akka.cluster.VectorClock">VectorClock</a><span class="delimiter">)</span>: <a href="#akka.cluster;VectorClock.equals" title="akka.cluster.VectorClock">VectorClock</a> = <span class="delimiter">{</span>
    <span class="keyword">var</span> <a title="scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]" id="akka.cluster;VectorClock.merge.mergedVersions">mergedVersions</a> = <a href="#akka.cluster;VectorClock.merge.that" title="akka.cluster.VectorClock">that</a>.<a href="#akka.cluster;VectorClock.copy$default$1" title="=&gt; scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">versions</a>
    <span class="keyword">for</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="akka.cluster.VectorClock.Node" id="akka.cluster;VectorClock.merge.$anonfun.node">node</a>, <a title="Long" id="akka.cluster;VectorClock.merge.$anonfun.time">time</a><span class="delimiter">)</span> ← <a href="#akka.cluster;VectorClock.copy$default$1" title="(f: ((akka.cluster.VectorClock.Node, Long)) =&gt; Unit)Unit">versions</a><span class="delimiter">)</span> <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="Long" id="akka.cluster;VectorClock.merge.$anonfun.mergedVersionsCurrentTime">mergedVersionsCurrentTime</a> = <a href="#akka.cluster;VectorClock.merge.mergedVersions" title="scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">mergedVersions</a>.<span title="(key: akka.cluster.VectorClock.Node, default: =&gt; Long)Long">getOrElse</span><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.merge.$anonfun.node" title="akka.cluster.VectorClock.Node">node</a>, Timestamp.<span title="Long(0L)">Zero</span><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.cluster;VectorClock.merge.$anonfun.time" title="Long">time</a> <span title="(x: Long)Boolean">&gt;</span> <a href="#akka.cluster;VectorClock.merge.$anonfun.mergedVersionsCurrentTime" title="Long">mergedVersionsCurrentTime</a><span class="delimiter">)</span>
        <a href="#akka.cluster;VectorClock.merge.mergedVersions" title="scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">mergedVersions</a> = <a href="#akka.cluster;VectorClock.merge.mergedVersions" title="scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">mergedVersions</a>.<span title="(key: akka.cluster.VectorClock.Node, value: Long)scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">updated</span><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.merge.$anonfun.node" title="akka.cluster.VectorClock.Node">node</a>, <a href="#akka.cluster;VectorClock.merge.$anonfun.time" title="Long">time</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#akka.cluster;VectorClock.equals" title="(versions: scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long])akka.cluster.VectorClock">VectorClock</a><span class="delimiter">(</span><a href="#akka.cluster;VectorClock.merge.mergedVersions" title="scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">mergedVersions</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="akka.cluster;VectorClock.toString">toString</a> = <a href="#akka.cluster;VectorClock.copy$default$1" title="=&gt; scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long]">versions</a>.<span title="(f: ((akka.cluster.VectorClock.Node, Long)) =&gt; String)(implicit bf: scala.collection.generic.CanBuildFrom[scala.collection.immutable.TreeMap[akka.cluster.VectorClock.Node,Long],String,scala.collection.immutable.Iterable[String]])scala.collection.immutable.Iterable[String]">map</span> <a href="#akka.cluster;VectorClock.toString.$anonfun.x0$1" title="String" class="delimiter">{</a> <span class="keyword">case</span> <span class="delimiter">(</span><span class="delimiter">(</span><a title="akka.cluster.VectorClock.Node" id="akka.cluster;VectorClock.toString.$anonfun.n">n</a>, <a title="Long" id="akka.cluster;VectorClock.toString.$anonfun.t">t</a><span class="delimiter">)</span><span class="delimiter">)</span> ⇒ <a href="#akka.cluster;VectorClock.toString.$anonfun.n" title="akka.cluster.VectorClock.Node">n</a> <span title="(x$1: Any)String">+</span> <span title="String(&quot; -&gt; &quot;)" class="string">&quot; -&gt; &quot;</span> <span title="(x$1: Any)String">+</span> <a href="#akka.cluster;VectorClock.toString.$anonfun.t" title="Long">t</a> <span class="delimiter">}</span>.<span title="(start: String, sep: String, end: String)String">mkString</span><span class="delimiter">(</span><span title="String(&quot;VectorClock(&quot;)" class="string">&quot;VectorClock(&quot;</span>, <span title="String(&quot;, &quot;)" class="string">&quot;, &quot;</span>, <span title="String(&quot;)&quot;)" class="string">&quot;)&quot;</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
