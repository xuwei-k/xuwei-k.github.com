<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>akka-actor/pattern/AskSupport.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/**
 * Copyright (C) 2009-2014 Typesafe Inc. &lt;http://www.typesafe.com&gt;
 */</span>
<span class="keyword">package</span> akka.pattern

<span class="keyword">import</span> <span title="language.type">language</span>.implicitConversions

<span class="keyword">import</span> java.util.concurrent.TimeoutException
<span class="keyword">import</span> akka.actor._
<span class="keyword">import</span> akka.dispatch.sysmsg._
<span class="keyword">import</span> scala.annotation.tailrec
<span class="keyword">import</span> scala.util.control.NonFatal
<span class="keyword">import</span> scala.concurrent.<span class="delimiter">{</span> Future, Promise, ExecutionContext <span class="delimiter">}</span>
<span class="keyword">import</span> akka.util.<span class="delimiter">{</span> Timeout, Unsafe <span class="delimiter">}</span>
<span class="keyword">import</span> scala.util.<span class="delimiter">{</span> Success, Failure <span class="delimiter">}</span>

<span class="comment">/**
 * This is what is used to complete a Future that is returned from an ask/? call,
 * when it times out.
 */</span>
<span class="keyword">class</span> <a title="class AskTimeoutException extends java.util.concurrent.TimeoutException" id="akka.pattern;AskTimeoutException">AskTimeoutException</a><a href="#akka.pattern;AskTimeoutException" title="akka.pattern.AskTimeoutException" class="delimiter">(</a><a title="String" id="akka.pattern;AskTimeoutException.message">message</a>: <span title="String">String</span>, <a title="Throwable" id="akka.pattern;AskTimeoutException.cause">cause</a>: <span title="Throwable">Throwable</span><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="java.util.concurrent.TimeoutException">TimeoutException</span><span class="delimiter">(</span><a href="#akka.pattern;AskTimeoutException.message" title="String">message</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="keyword">def</span> <a title="(message: String)akka.pattern.AskTimeoutException" id="akka.pattern;AskTimeoutException.<init>(9b6cbaa318)" class="keyword">this</a><span class="delimiter">(</span><a title="String" id="akka.pattern;AskTimeoutException.<init>(9b6cbaa318).message">message</a>: <span title="String">String</span><span class="delimiter">)</span> = <a href="#akka.pattern;AskTimeoutException" title="AskTimeoutException.this.type" class="keyword">this</a><span class="delimiter">(</span><a href="#akka.pattern;AskTimeoutException.<init>(9b6cbaa318).message" title="String">message</a>, <span title="Null(null)" class="keyword">null</span>: <span title="Throwable">Throwable</span><span class="delimiter">)</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()Throwable" id="akka.pattern;AskTimeoutException.getCause">getCause</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Throwable">Throwable</span> = <a href="#akka.pattern;AskTimeoutException.cause" title="Throwable">cause</a>
<span class="delimiter">}</span>

<span class="comment">/**
 * This object contains implementation details of the “ask” pattern.
 */</span>
<span class="keyword">trait</span> <a title="trait AskSupport extends AnyRef" id="akka.pattern;AskSupport">AskSupport</a> <span title="Unit" class="delimiter">{</span>

  <span class="comment">/**
   * Import this implicit conversion to gain `?` and `ask` methods on
   * [[akka.actor.ActorRef]], which will defer to the
   * `ask(actorRef, message)(timeout)` method defined here.
   *
   * {{{
   * import akka.pattern.ask
   *
   * val future = actor ? message             // =&gt; ask(actor, message)
   * val future = actor ask message           // =&gt; ask(actor, message)
   * val future = actor.ask(message)(timeout) // =&gt; ask(actor, message)(timeout)
   * }}}
   *
   * All of the above use an implicit [[akka.util.Timeout]].
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit akka.pattern.AskSupport.ask : (actorRef: akka.actor.ActorRef)akka.pattern.AskableActorRef" id="akka.pattern;AskSupport.ask(13940b1e32)">ask</a><span class="delimiter">(</span><a title="akka.actor.ActorRef" id="akka.pattern;AskSupport.ask(13940b1e32).actorRef">actorRef</a>: <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a><span class="delimiter">)</span>: <a href="#akka.pattern.AskableActorRef" title="akka.pattern.AskableActorRef">AskableActorRef</a> = <span title="akka.pattern.AskableActorRef" class="keyword">new</span> <a href="#akka.pattern.AskableActorRef" title="akka.pattern.AskableActorRef">AskableActorRef</a><span class="delimiter">(</span><a href="#akka.pattern;AskSupport.ask(13940b1e32).actorRef" title="akka.actor.ActorRef">actorRef</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Sends a message asynchronously and returns a [[scala.concurrent.Future]]
   * holding the eventual reply message; this means that the target actor
   * needs to send the result to the `sender` reference provided. The Future
   * will be completed with an [[akka.pattern.AskTimeoutException]] after the
   * given timeout has expired; this is independent from any timeout applied
   * while awaiting a result for this future (i.e. in
   * `Await.result(..., timeout)`).
   *
   * &lt;b&gt;Warning:&lt;/b&gt;
   * When using future callbacks, inside actors you need to carefully avoid closing over
   * the containing actor’s object, i.e. do not call methods or access mutable state
   * on the enclosing actor from within the callback. This would break the actor
   * encapsulation and may introduce synchronization bugs and race conditions because
   * the callback will be scheduled concurrently to the enclosing actor. Unfortunately
   * there is not yet a way to detect these illegal accesses at compile time.
   *
   * &lt;b&gt;Recommended usage:&lt;/b&gt;
   *
   * {{{
   *   val f = ask(worker, request)(timeout)
   *   f.map { response =&gt;
   *     EnrichedMessage(response)
   *   } pipeTo nextActor
   * }}}
   *
   */</span>
  <span class="keyword">def</span> <a title="(actorRef: akka.actor.ActorRef, message: Any)(implicit timeout: akka.util.Timeout)scala.concurrent.Future[Any]" id="akka.pattern;AskSupport.ask(c201ad9fc9)">ask</a><span class="delimiter">(</span><a title="akka.actor.ActorRef" id="akka.pattern;AskSupport.ask(c201ad9fc9).actorRef">actorRef</a>: <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a>, <a title="Any" id="akka.pattern;AskSupport.ask(c201ad9fc9).message">message</a>: <span title="Any">Any</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="akka.util.Timeout" id="akka.pattern;AskSupport.ask(c201ad9fc9).timeout">timeout</a>: <a href="../util/Timeout.scala.html#akka.util;Timeout" title="akka.util.Timeout">Timeout</a><span class="delimiter">)</span>: <span title="scala.concurrent.Future[Any]">Future</span><span class="delimiter">[</span>Any<span class="delimiter">]</span> = <a href="#akka.pattern;AskSupport.ask(13940b1e32)" title="implicit akka.pattern.AskSupport.ask : (actorRef: akka.actor.ActorRef)akka.pattern.AskableActorRef">actorRef</a> <a href="#akka.pattern;AskableActorRef.?" title="(message: Any)(implicit timeout: akka.util.Timeout)scala.concurrent.Future[Any]">?</a> <a href="#akka.pattern;AskSupport.ask(c201ad9fc9).message" title="Any">message</a>

  <span class="comment">/**
   * Import this implicit conversion to gain `?` and `ask` methods on
   * [[akka.actor.ActorSelection]], which will defer to the
   * `ask(actorSelection, message)(timeout)` method defined here.
   *
   * {{{
   * import akka.pattern.ask
   *
   * val future = selection ? message             // =&gt; ask(selection, message)
   * val future = selection ask message           // =&gt; ask(selection, message)
   * val future = selection.ask(message)(timeout) // =&gt; ask(selection, message)(timeout)
   * }}}
   *
   * All of the above use an implicit [[akka.util.Timeout]].
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit akka.pattern.AskSupport.ask : (actorSelection: akka.actor.ActorSelection)akka.pattern.AskableActorSelection" id="akka.pattern;AskSupport.ask(53426395a0)">ask</a><span class="delimiter">(</span><a title="akka.actor.ActorSelection" id="akka.pattern;AskSupport.ask(53426395a0).actorSelection">actorSelection</a>: <a href="../actor/ActorSelection.scala.html#akka.actor;ActorSelection" title="akka.actor.ActorSelection">ActorSelection</a><span class="delimiter">)</span>: <a href="#akka.pattern.AskableActorSelection" title="akka.pattern.AskableActorSelection">AskableActorSelection</a> = <span title="akka.pattern.AskableActorSelection" class="keyword">new</span> <a href="#akka.pattern.AskableActorSelection" title="akka.pattern.AskableActorSelection">AskableActorSelection</a><span class="delimiter">(</span><a href="#akka.pattern;AskSupport.ask(53426395a0).actorSelection" title="akka.actor.ActorSelection">actorSelection</a><span class="delimiter">)</span>

  <span class="comment">/**
   * Sends a message asynchronously and returns a [[scala.concurrent.Future]]
   * holding the eventual reply message; this means that the target actor
   * needs to send the result to the `sender` reference provided. The Future
   * will be completed with an [[akka.pattern.AskTimeoutException]] after the
   * given timeout has expired; this is independent from any timeout applied
   * while awaiting a result for this future (i.e. in
   * `Await.result(..., timeout)`).
   *
   * &lt;b&gt;Warning:&lt;/b&gt;
   * When using future callbacks, inside actors you need to carefully avoid closing over
   * the containing actor’s object, i.e. do not call methods or access mutable state
   * on the enclosing actor from within the callback. This would break the actor
   * encapsulation and may introduce synchronization bugs and race conditions because
   * the callback will be scheduled concurrently to the enclosing actor. Unfortunately
   * there is not yet a way to detect these illegal accesses at compile time.
   *
   * &lt;b&gt;Recommended usage:&lt;/b&gt;
   *
   * {{{
   *   val f = ask(worker, request)(timeout)
   *   f.map { response =&gt;
   *     EnrichedMessage(response)
   *   } pipeTo nextActor
   * }}}
   *
   */</span>
  <span class="keyword">def</span> <a title="(actorSelection: akka.actor.ActorSelection, message: Any)(implicit timeout: akka.util.Timeout)scala.concurrent.Future[Any]" id="akka.pattern;AskSupport.ask(50fe98dc74)">ask</a><span class="delimiter">(</span><a title="akka.actor.ActorSelection" id="akka.pattern;AskSupport.ask(50fe98dc74).actorSelection">actorSelection</a>: <a href="../actor/ActorSelection.scala.html#akka.actor;ActorSelection" title="akka.actor.ActorSelection">ActorSelection</a>, <a title="Any" id="akka.pattern;AskSupport.ask(50fe98dc74).message">message</a>: <span title="Any">Any</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="akka.util.Timeout" id="akka.pattern;AskSupport.ask(50fe98dc74).timeout">timeout</a>: <a href="../util/Timeout.scala.html#akka.util;Timeout" title="akka.util.Timeout">Timeout</a><span class="delimiter">)</span>: <span title="scala.concurrent.Future[Any]">Future</span><span class="delimiter">[</span>Any<span class="delimiter">]</span> = <a href="#akka.pattern;AskSupport.ask(53426395a0)" title="implicit akka.pattern.AskSupport.ask : (actorSelection: akka.actor.ActorSelection)akka.pattern.AskableActorSelection">actorSelection</a> <a href="#akka.pattern;AskableActorSelection.?" title="(message: Any)(implicit timeout: akka.util.Timeout)scala.concurrent.Future[Any]">?</a> <a href="#akka.pattern;AskSupport.ask(50fe98dc74).message" title="Any">message</a>
<span class="delimiter">}</span>

<span class="comment">/*
 * Implementation class of the “ask” pattern enrichment of ActorRef
 */</span>
<span title="AnyRef" class="keyword">final</span> <span class="keyword">class</span> <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef.hashCode" title="class AskableActorRef extends AnyVal" id="akka.pattern.AskableActorRef">AskableActorRef</a><a href="#akka.pattern.AskableActorRef" title="akka.pattern.AskableActorRef" class="delimiter">(</a><span class="keyword">val</span> <a title="akka.actor.ActorRef" id="akka.pattern;AskableActorRef.actorRef">actorRef</a>: <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="AnyVal">AnyVal</span> <span class="delimiter">{</span>

  <span class="keyword">def</span> <a title="(message: Any)(implicit timeout: akka.util.Timeout)scala.concurrent.Future[Any]" id="akka.pattern;AskableActorRef.ask">ask</a><span class="delimiter">(</span><a title="Any" id="akka.pattern;AskableActorRef.ask.message">message</a>: <span title="Any">Any</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="akka.util.Timeout" id="akka.pattern;AskableActorRef.ask.timeout">timeout</a>: <a href="../util/Timeout.scala.html#akka.util;Timeout" title="akka.util.Timeout">Timeout</a><span class="delimiter">)</span>: <span title="scala.concurrent.Future[Any]">Future</span><span class="delimiter">[</span>Any<span class="delimiter">]</span> = <a href="#akka.pattern;AskableActorRef.actorRef" title="=&gt; akka.actor.ActorRef">actorRef</a> <span title="scala.concurrent.Future[Any]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="akka.actor.InternalActorRef">ref</span>: <a href="../actor/ActorRef.scala.html#akka.actor;InternalActorRef" title="akka.actor.InternalActorRef">InternalActorRef</a> <span class="keyword">if</span> <span title="akka.actor.InternalActorRef">ref</span>.<a href="../actor/ActorRef.scala.html#akka.actor;InternalActorRef.isTerminated" title="=&gt; Boolean">isTerminated</a> ⇒
      <a href="../actor/package.scala.html#akka.actor.package.actorRef2Scala" title="akka.actor.ScalaActorRef" id="akka.pattern;AskableActorRef.ask.qual$1">actorRef</a> <a href="../actor/ActorRef.scala.html#akka.actor;ScalaActorRef.!$default$2" title="akka.actor.ActorRef" id="akka.pattern;AskableActorRef.ask.x$3">!</a> <a href="#akka.pattern;AskableActorRef.ask.message" title="Any" id="akka.pattern;AskableActorRef.ask.x$2">message</a>
      <span title="scala.concurrent.Future.type">Future</span>.<span title="[T](exception: Throwable)scala.concurrent.Future[T]">failed</span><span title="(exception: Throwable)scala.concurrent.Future[Any]" class="delimiter">[</span><span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#akka.pattern;AskTimeoutException.<init>(9b6cbaa318)" title="(message: String)akka.pattern.AskTimeoutException" class="keyword">new</a> <a href="#akka.pattern;AskTimeoutException" title="akka.pattern.AskTimeoutException">AskTimeoutException</a><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Recipient[&quot;)">Recipient[$</span><a href="#akka.pattern;AskableActorRef.actorRef" title="=&gt; akka.actor.ActorRef">actorRef</a><span title="String(&quot;] had already been terminated.&quot;)" class="string">] had already been terminated.&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <span title="akka.actor.InternalActorRef">ref</span>: <a href="../actor/ActorRef.scala.html#akka.actor;InternalActorRef" title="akka.actor.InternalActorRef">InternalActorRef</a> ⇒
      <span title="scala.concurrent.Future[Any]" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.pattern;AskableActorRef.ask.timeout" title="akka.util.Timeout">timeout</a>.<a href="../util/Timeout.scala.html#akka.util;Timeout.duration" title="=&gt; scala.concurrent.duration.FiniteDuration">duration</a>.<span title="=&gt; Long">length</span> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
        <span title="scala.concurrent.Future.type">Future</span>.<span title="[T](exception: Throwable)scala.concurrent.Future[T]">failed</span><span title="(exception: Throwable)scala.concurrent.Future[Any]" class="delimiter">[</span><span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="(x$1: String)IllegalArgumentException" class="keyword">new</span> <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Timeout length must not be negative, question not sent to [&quot;)">Timeout length must not be negative, question not sent to [$</span><a href="#akka.pattern;AskableActorRef.actorRef" title="=&gt; akka.actor.ActorRef">actorRef</a><span title="String(&quot;]&quot;)" class="string">]&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="akka.pattern.PromiseActorRef" id="akka.pattern;AskableActorRef.ask.a">a</a> = <a href="#akka.pattern.PromiseActorRef.apply" title="(provider: akka.actor.ActorRefProvider, timeout: akka.util.Timeout, targetName: String)akka.pattern.PromiseActorRef">PromiseActorRef</a><span class="delimiter">(</span><span title="akka.actor.InternalActorRef">ref</span>.<a href="../actor/ActorRef.scala.html#akka.actor;InternalActorRef.provider" title="=&gt; akka.actor.ActorRefProvider">provider</a>, <a href="#akka.pattern;AskableActorRef.ask.timeout" title="akka.util.Timeout">timeout</a>, targetName = <a href="#akka.pattern;AskableActorRef.actorRef" title="=&gt; akka.actor.ActorRef">actorRef</a>.<a href="../actor/ActorRef.scala.html#akka.actor;ActorRef.toString" title="()String">toString</a><span class="delimiter">)</span>
        <a href="#akka.pattern;AskableActorRef.actorRef" title="=&gt; akka.actor.ActorRef">actorRef</a>.<a href="../actor/ActorRef.scala.html#akka.actor;ActorRef.tell" title="(msg: Any, sender: akka.actor.ActorRef)Unit">tell</a><span class="delimiter">(</span><a href="#akka.pattern;AskableActorRef.ask.message" title="Any">message</a>, <a href="#akka.pattern;AskableActorRef.ask.a" title="akka.pattern.PromiseActorRef">a</a><span class="delimiter">)</span>
        <a href="#akka.pattern;AskableActorRef.ask.a" title="akka.pattern.PromiseActorRef">a</a>.<a href="#akka.pattern;PromiseActorRef.result" title="=&gt; scala.concurrent.Promise[Any]">result</a>.<span title="=&gt; scala.concurrent.Future[Any]">future</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> _ ⇒ <span title="scala.concurrent.Future.type">Future</span>.<span title="[T](exception: Throwable)scala.concurrent.Future[T]">failed</span><span title="(exception: Throwable)scala.concurrent.Future[Any]" class="delimiter">[</span><span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="(x$1: String)IllegalArgumentException" class="keyword">new</span> <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Unsupported recipient ActorRef type, question not sent to [&quot;)">Unsupported recipient ActorRef type, question not sent to [$</span><a href="#akka.pattern;AskableActorRef.actorRef" title="=&gt; akka.actor.ActorRef">actorRef</a><span title="String(&quot;]&quot;)" class="string">]&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(message: Any)(implicit timeout: akka.util.Timeout)scala.concurrent.Future[Any]" id="akka.pattern;AskableActorRef.?">?</a><span class="delimiter">(</span><a title="Any" id="akka.pattern;AskableActorRef.?.message">message</a>: <span title="Any">Any</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="akka.util.Timeout" id="akka.pattern;AskableActorRef.?.timeout">timeout</a>: <a href="../util/Timeout.scala.html#akka.util;Timeout" title="akka.util.Timeout">Timeout</a><span class="delimiter">)</span>: <span title="scala.concurrent.Future[Any]">Future</span><span class="delimiter">[</span>Any<span class="delimiter">]</span> = <a href="#akka.pattern;AskableActorRef.ask" title="(message: Any)(implicit timeout: akka.util.Timeout)scala.concurrent.Future[Any]">ask</a><span class="delimiter">(</span><a href="#akka.pattern;AskableActorRef.?.message" title="Any">message</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#akka.pattern;AskableActorRef.?.timeout" title="akka.util.Timeout">timeout</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/*
 * Implementation class of the “ask” pattern enrichment of ActorSelection
 */</span>
<span class="keyword">final</span> <span class="keyword">class</span> <a href="../actor/ActorSelection.scala.html#akka.actor;ActorSelection.hashCode" title="class AskableActorSelection extends AnyVal" id="akka.pattern.AskableActorSelection">AskableActorSelection</a><a href="#akka.pattern.AskableActorSelection" title="akka.pattern.AskableActorSelection" class="delimiter">(</a><span class="keyword">val</span> <a title="akka.actor.ActorSelection" id="akka.pattern;AskableActorSelection.actorSel">actorSel</a>: <a href="../actor/ActorSelection.scala.html#akka.actor;ActorSelection" title="akka.actor.ActorSelection">ActorSelection</a><span class="delimiter">)</span> <span class="keyword">extends</span> <span title="AnyVal">AnyVal</span> <span class="delimiter">{</span>

  <span class="keyword">def</span> <a title="(message: Any)(implicit timeout: akka.util.Timeout)scala.concurrent.Future[Any]" id="akka.pattern;AskableActorSelection.ask">ask</a><span class="delimiter">(</span><a title="Any" id="akka.pattern;AskableActorSelection.ask.message">message</a>: <span title="Any">Any</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="akka.util.Timeout" id="akka.pattern;AskableActorSelection.ask.timeout">timeout</a>: <a href="../util/Timeout.scala.html#akka.util;Timeout" title="akka.util.Timeout">Timeout</a><span class="delimiter">)</span>: <span title="scala.concurrent.Future[Any]">Future</span><span class="delimiter">[</span>Any<span class="delimiter">]</span> = <a href="#akka.pattern;AskableActorSelection.actorSel" title="=&gt; akka.actor.ActorSelection">actorSel</a>.<a href="../actor/ActorSelection.scala.html#akka.actor;ActorSelection.anchor" title="=&gt; akka.actor.ActorRef">anchor</a> <span title="scala.concurrent.Future[Any]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a title="akka.actor.InternalActorRef" id="akka.pattern;AskableActorSelection.ask.ref">ref</a>: <a href="../actor/ActorRef.scala.html#akka.actor;InternalActorRef" title="akka.actor.InternalActorRef">InternalActorRef</a> ⇒
      <span title="scala.concurrent.Future[Any]" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.pattern;AskableActorSelection.ask.timeout" title="akka.util.Timeout">timeout</a>.<a href="../util/Timeout.scala.html#akka.util;Timeout.duration" title="=&gt; scala.concurrent.duration.FiniteDuration">duration</a>.<span title="=&gt; Long">length</span> <span title="(x: Int)Boolean">&lt;=</span> <span title="Int(0)" class="int">0</span><span class="delimiter">)</span>
        <span title="scala.concurrent.Future.type">Future</span>.<span title="[T](exception: Throwable)scala.concurrent.Future[T]">failed</span><span title="(exception: Throwable)scala.concurrent.Future[Any]" class="delimiter">[</span><span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span>
          <span title="(x$1: String)IllegalArgumentException" class="keyword">new</span> <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Timeout length must not be negative, question not sent to [&quot;)">Timeout length must not be negative, question not sent to [$</span><a href="#akka.pattern;AskableActorSelection.actorSel" title="=&gt; akka.actor.ActorSelection">actorSel</a><span title="String(&quot;]&quot;)" class="string">]&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="akka.pattern.PromiseActorRef" id="akka.pattern;AskableActorSelection.ask.a">a</a> = <a href="#akka.pattern.PromiseActorRef.apply" title="(provider: akka.actor.ActorRefProvider, timeout: akka.util.Timeout, targetName: String)akka.pattern.PromiseActorRef">PromiseActorRef</a><span class="delimiter">(</span><a href="#akka.pattern;AskableActorSelection.ask.ref" title="akka.actor.InternalActorRef">ref</a>.<a href="../actor/ActorRef.scala.html#akka.actor;InternalActorRef.provider" title="=&gt; akka.actor.ActorRefProvider">provider</a>, <a href="#akka.pattern;AskableActorSelection.ask.timeout" title="akka.util.Timeout">timeout</a>, targetName = <a href="#akka.pattern;AskableActorSelection.actorSel" title="=&gt; akka.actor.ActorSelection">actorSel</a>.<a href="../actor/ActorSelection.scala.html#akka.actor;ActorSelection.toString" title="()String">toString</a><span class="delimiter">)</span>
        <a href="#akka.pattern;AskableActorSelection.actorSel" title="=&gt; akka.actor.ActorSelection">actorSel</a>.<a href="../actor/ActorSelection.scala.html#akka.actor;ActorSelection.tell" title="(msg: Any, sender: akka.actor.ActorRef)Unit">tell</a><span class="delimiter">(</span><a href="#akka.pattern;AskableActorSelection.ask.message" title="Any">message</a>, <a href="#akka.pattern;AskableActorSelection.ask.a" title="akka.pattern.PromiseActorRef">a</a><span class="delimiter">)</span>
        <a href="#akka.pattern;AskableActorSelection.ask.a" title="akka.pattern.PromiseActorRef">a</a>.<a href="#akka.pattern;PromiseActorRef.result" title="=&gt; scala.concurrent.Promise[Any]">result</a>.<span title="=&gt; scala.concurrent.Future[Any]">future</span>
      <span class="delimiter">}</span>
    <span class="keyword">case</span> _ ⇒ <span title="scala.concurrent.Future.type">Future</span>.<span title="[T](exception: Throwable)scala.concurrent.Future[T]">failed</span><span title="(exception: Throwable)scala.concurrent.Future[Any]" class="delimiter">[</span><span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><span title="(x$1: String)IllegalArgumentException" class="keyword">new</span> <span title="IllegalArgumentException">IllegalArgumentException</span><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Unsupported recipient ActorRef type, question not sent to [&quot;)">Unsupported recipient ActorRef type, question not sent to [$</span><a href="#akka.pattern;AskableActorSelection.actorSel" title="=&gt; akka.actor.ActorSelection">actorSel</a><span title="String(&quot;]&quot;)" class="string">]&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">def</span> <a title="(message: Any)(implicit timeout: akka.util.Timeout)scala.concurrent.Future[Any]" id="akka.pattern;AskableActorSelection.?">?</a><span class="delimiter">(</span><a title="Any" id="akka.pattern;AskableActorSelection.?.message">message</a>: <span title="Any">Any</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="akka.util.Timeout" id="akka.pattern;AskableActorSelection.?.timeout">timeout</a>: <a href="../util/Timeout.scala.html#akka.util;Timeout" title="akka.util.Timeout">Timeout</a><span class="delimiter">)</span>: <span title="scala.concurrent.Future[Any]">Future</span><span class="delimiter">[</span>Any<span class="delimiter">]</span> = <a href="#akka.pattern;AskableActorSelection.ask" title="(message: Any)(implicit timeout: akka.util.Timeout)scala.concurrent.Future[Any]">ask</a><span class="delimiter">(</span><a href="#akka.pattern;AskableActorSelection.?.message" title="Any">message</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#akka.pattern;AskableActorSelection.?.timeout" title="akka.util.Timeout">timeout</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Akka private optimized representation of the temporary actor spawned to
 * receive the reply to an &quot;ask&quot; operation.
 *
 * INTERNAL API
 */</span>
<span class="keyword">private</span><span class="delimiter">[</span>akka<span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">class</span> <a title="class PromiseActorRef extends akka.actor.InternalActorRef with akka.actor.MinimalActorRef" id="akka.pattern;PromiseActorRef">PromiseActorRef</a> <a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef" class="keyword">private</a> <span class="delimiter">(</span><span class="keyword">val</span> <a title="akka.actor.ActorRefProvider" id="akka.pattern;PromiseActorRef.provider">provider</a>: <a href="../actor/ActorRefProvider.scala.html#akka.actor;ActorRefProvider" title="akka.actor.ActorRefProvider">ActorRefProvider</a>, <span class="keyword">val</span> <a title="scala.concurrent.Promise[Any]" id="akka.pattern;PromiseActorRef.result">result</a>: <span title="scala.concurrent.Promise[Any]">Promise</span><span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="keyword">extends</span> <a href="../actor/ActorRef.scala.html#akka.actor;MinimalActorRef" title="akka.actor.MinimalActorRef">MinimalActorRef</a> <span class="delimiter">{</span>
  <span class="keyword">import</span> <a href="#akka.pattern.PromiseActorRef.readResolve" title="akka.pattern.PromiseActorRef.type">PromiseActorRef</a>._
  <span class="keyword">import</span> <span title="akka.pattern.AbstractPromiseActorRef.type">AbstractPromiseActorRef</span>.stateOffset
  <span class="keyword">import</span> <span title="akka.pattern.AbstractPromiseActorRef.type">AbstractPromiseActorRef</span>.watchedByOffset

  <span class="comment">/**
   * As an optimization for the common (local) case we only register this PromiseActorRef
   * with the provider when the `path` member is actually queried, which happens during
   * serialization (but also during a simple call to `toString`, `equals` or `hashCode`!).
   *
   * Defined states:
   * null                  =&gt; started, path not yet created
   * Registering           =&gt; currently creating temp path and registering it
   * path: ActorPath       =&gt; path is available and was registered
   * StoppedWithPath(path) =&gt; stopped, path available
   * Stopped               =&gt; stopped, path not yet created
   */</span>
  @volatile
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">var</span> <a title="AnyRef" id="akka.pattern;PromiseActorRef._stateDoNotCallMeDirectly">_stateDoNotCallMeDirectly</a>: <span title="AnyRef">AnyRef</span> = _

  @volatile
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">var</span> <a title="Set[akka.actor.ActorRef]" id="akka.pattern;PromiseActorRef._watchedByDoNotCallMeDirectly">_watchedByDoNotCallMeDirectly</a>: <span title="Set[akka.actor.ActorRef]">Set</span><span class="delimiter">[</span>ActorRef<span class="delimiter">]</span> = <a href="../actor/ActorCell.scala.html#akka.actor.ActorCell" title="akka.actor.ActorCell.type">ActorCell</a>.<a href="../actor/ActorCell.scala.html#akka.actor.ActorCell.emptyActorRefSet" title="=&gt; Set[akka.actor.ActorRef]">emptyActorRefSet</a>

  @inline
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; Set[akka.actor.ActorRef]" id="akka.pattern;PromiseActorRef.watchedBy">watchedBy</a>: <span title="Set[akka.actor.ActorRef]">Set</span><span class="delimiter">[</span>ActorRef<span class="delimiter">]</span> = <a href="../util/Unsafe.java.html#akka.util.Unsafe" title="akka.util.Unsafe.type">Unsafe</a>.<a href="../util/Unsafe.java.html#akka.util.Unsafe.instance" title="sun.misc.Unsafe">instance</a>.<span title="(x$1: Any, x$2: Long)Object">getObjectVolatile</span><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef" class="keyword">this</a>, <span title="Long">watchedByOffset</span><span class="delimiter">)</span>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="Set[akka.actor.ActorRef]" class="delimiter">[</span><span title="Set[akka.actor.ActorRef]">Set</span><span class="delimiter">[</span>ActorRef<span class="delimiter">]</span><span class="delimiter">]</span>

  @inline
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(oldWatchedBy: Set[akka.actor.ActorRef], newWatchedBy: Set[akka.actor.ActorRef])Boolean" id="akka.pattern;PromiseActorRef.updateWatchedBy">updateWatchedBy</a><span class="delimiter">(</span><a title="Set[akka.actor.ActorRef]" id="akka.pattern;PromiseActorRef.updateWatchedBy.oldWatchedBy">oldWatchedBy</a>: <span title="Set[akka.actor.ActorRef]">Set</span><span class="delimiter">[</span>ActorRef<span class="delimiter">]</span>, <a title="Set[akka.actor.ActorRef]" id="akka.pattern;PromiseActorRef.updateWatchedBy.newWatchedBy">newWatchedBy</a>: <span title="Set[akka.actor.ActorRef]">Set</span><span class="delimiter">[</span>ActorRef<span class="delimiter">]</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="../util/Unsafe.java.html#akka.util.Unsafe" title="akka.util.Unsafe.type">Unsafe</a>.<a href="../util/Unsafe.java.html#akka.util.Unsafe.instance" title="sun.misc.Unsafe">instance</a>.<span title="(x$1: Any, x$2: Long, x$3: Any, x$4: Any)Boolean">compareAndSwapObject</span><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef" class="keyword">this</a>, <span title="Long">watchedByOffset</span>, <a href="#akka.pattern;PromiseActorRef.updateWatchedBy.oldWatchedBy" title="Set[akka.actor.ActorRef]">oldWatchedBy</a>, <a href="#akka.pattern;PromiseActorRef.updateWatchedBy.newWatchedBy" title="Set[akka.actor.ActorRef]">newWatchedBy</a><span class="delimiter">)</span>

  @tailrec <span class="comment">// Returns false if the Promise is already completed</span>
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="(watcher: akka.actor.ActorRef)Boolean" id="akka.pattern;PromiseActorRef.addWatcher">addWatcher</a><span class="delimiter">(</span><a title="akka.actor.ActorRef" id="akka.pattern;PromiseActorRef.addWatcher.watcher">watcher</a>: <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> = <a href="#akka.pattern;PromiseActorRef.watchedBy" title="=&gt; Set[akka.actor.ActorRef]">watchedBy</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Null(null)" class="keyword">null</span>  ⇒ <span title="Boolean(false)" class="keyword">false</span>
    <span class="keyword">case</span> <a title="Set[akka.actor.ActorRef]" id="akka.pattern;PromiseActorRef.addWatcher.other">other</a> ⇒ <a href="#akka.pattern;PromiseActorRef.updateWatchedBy" title="(oldWatchedBy: Set[akka.actor.ActorRef], newWatchedBy: Set[akka.actor.ActorRef])Boolean">updateWatchedBy</a><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.addWatcher.other" title="Set[akka.actor.ActorRef]">other</a>, <a href="#akka.pattern;PromiseActorRef.addWatcher.other" title="Set[akka.actor.ActorRef]">other</a> <span title="(elem: akka.actor.ActorRef)scala.collection.immutable.Set[akka.actor.ActorRef]">+</span> <a href="#akka.pattern;PromiseActorRef.addWatcher.watcher" title="akka.actor.ActorRef">watcher</a><span class="delimiter">)</span> <span title="(x: Boolean)Boolean">||</span> <a href="#akka.pattern;PromiseActorRef.addWatcher" title="(watcher: akka.actor.ActorRef)Boolean">addWatcher</a><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.addWatcher.watcher" title="akka.actor.ActorRef">watcher</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  @tailrec
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="(watcher: akka.actor.ActorRef)Unit" id="akka.pattern;PromiseActorRef.remWatcher">remWatcher</a><span class="delimiter">(</span><a title="akka.actor.ActorRef" id="akka.pattern;PromiseActorRef.remWatcher.watcher">watcher</a>: <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.pattern;PromiseActorRef.watchedBy" title="=&gt; Set[akka.actor.ActorRef]">watchedBy</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Null(null)" class="keyword">null</span>  ⇒ <span title="Unit" class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">case</span> <a title="Set[akka.actor.ActorRef]" id="akka.pattern;PromiseActorRef.remWatcher.other">other</a> ⇒ <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#akka.pattern;PromiseActorRef.updateWatchedBy" title="(oldWatchedBy: Set[akka.actor.ActorRef], newWatchedBy: Set[akka.actor.ActorRef])Boolean">updateWatchedBy</a><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.remWatcher.other" title="Set[akka.actor.ActorRef]">other</a>, <a href="#akka.pattern;PromiseActorRef.remWatcher.other" title="Set[akka.actor.ActorRef]">other</a> <span title="(elem: akka.actor.ActorRef)scala.collection.immutable.Set[akka.actor.ActorRef]">-</span> <a href="#akka.pattern;PromiseActorRef.remWatcher.watcher" title="akka.actor.ActorRef">watcher</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.pattern;PromiseActorRef.remWatcher" title="(watcher: akka.actor.ActorRef)Unit">remWatcher</a><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.remWatcher.watcher" title="akka.actor.ActorRef">watcher</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  @tailrec
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">final</span> <span class="keyword">def</span> <a title="()Set[akka.actor.ActorRef]" id="akka.pattern;PromiseActorRef.clearWatchers">clearWatchers</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Set[akka.actor.ActorRef]">Set</span><span class="delimiter">[</span>ActorRef<span class="delimiter">]</span> = <a href="#akka.pattern;PromiseActorRef.watchedBy" title="=&gt; Set[akka.actor.ActorRef]">watchedBy</a> <span title="Set[akka.actor.ActorRef]" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Null(null)" class="keyword">null</span>  ⇒ <a href="../actor/ActorCell.scala.html#akka.actor.ActorCell" title="akka.actor.ActorCell.type">ActorCell</a>.<a href="../actor/ActorCell.scala.html#akka.actor.ActorCell.emptyActorRefSet" title="=&gt; Set[akka.actor.ActorRef]">emptyActorRefSet</a>
    <span class="keyword">case</span> <a title="Set[akka.actor.ActorRef]" id="akka.pattern;PromiseActorRef.clearWatchers.other">other</a> ⇒ <span title="Set[akka.actor.ActorRef]" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#akka.pattern;PromiseActorRef.updateWatchedBy" title="(oldWatchedBy: Set[akka.actor.ActorRef], newWatchedBy: Set[akka.actor.ActorRef])Boolean">updateWatchedBy</a><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.clearWatchers.other" title="Set[akka.actor.ActorRef]">other</a>, <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.pattern;PromiseActorRef.clearWatchers" title="()Set[akka.actor.ActorRef]">clearWatchers</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#akka.pattern;PromiseActorRef.clearWatchers.other" title="Set[akka.actor.ActorRef]">other</a>
  <span class="delimiter">}</span>

  @inline
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="=&gt; AnyRef" id="akka.pattern;PromiseActorRef.state">state</a>: <span title="AnyRef">AnyRef</span> = <a href="../util/Unsafe.java.html#akka.util.Unsafe" title="akka.util.Unsafe.type">Unsafe</a>.<a href="../util/Unsafe.java.html#akka.util.Unsafe.instance" title="sun.misc.Unsafe">instance</a>.<span title="(x$1: Any, x$2: Long)Object">getObjectVolatile</span><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef" class="keyword">this</a>, <span title="Long">stateOffset</span><span class="delimiter">)</span>

  @inline
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(oldState: AnyRef, newState: AnyRef)Boolean" id="akka.pattern;PromiseActorRef.updateState">updateState</a><span class="delimiter">(</span><a title="AnyRef" id="akka.pattern;PromiseActorRef.updateState.oldState">oldState</a>: <span title="AnyRef">AnyRef</span>, <a title="AnyRef" id="akka.pattern;PromiseActorRef.updateState.newState">newState</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>: <span title="Boolean">Boolean</span> =
    <a href="../util/Unsafe.java.html#akka.util.Unsafe" title="akka.util.Unsafe.type">Unsafe</a>.<a href="../util/Unsafe.java.html#akka.util.Unsafe.instance" title="sun.misc.Unsafe">instance</a>.<span title="(x$1: Any, x$2: Long, x$3: Any, x$4: Any)Boolean">compareAndSwapObject</span><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef" class="keyword">this</a>, <span title="Long">stateOffset</span>, <a href="#akka.pattern;PromiseActorRef.updateState.oldState" title="AnyRef">oldState</a>, <a href="#akka.pattern;PromiseActorRef.updateState.newState" title="AnyRef">newState</a><span class="delimiter">)</span>

  @inline
  <span class="keyword">private</span><span class="delimiter">[</span><span class="keyword">this</span><span class="delimiter">]</span> <span class="keyword">def</span> <a title="(newState: AnyRef)Unit" id="akka.pattern;PromiseActorRef.setState">setState</a><span class="delimiter">(</span><a title="AnyRef" id="akka.pattern;PromiseActorRef.setState.newState">newState</a>: <span title="AnyRef">AnyRef</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="../util/Unsafe.java.html#akka.util.Unsafe" title="akka.util.Unsafe.type">Unsafe</a>.<a href="../util/Unsafe.java.html#akka.util.Unsafe.instance" title="sun.misc.Unsafe">instance</a>.<span title="(x$1: Any, x$2: Long, x$3: Any)Unit">putObjectVolatile</span><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef" class="keyword">this</a>, <span title="Long">stateOffset</span>, <a href="#akka.pattern;PromiseActorRef.setState.newState" title="AnyRef">newState</a><span class="delimiter">)</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; akka.actor.InternalActorRef" id="akka.pattern;PromiseActorRef.getParent">getParent</a>: <a href="../actor/ActorRef.scala.html#akka.actor;InternalActorRef" title="akka.actor.InternalActorRef">InternalActorRef</a> = <a href="#akka.pattern;PromiseActorRef.provider" title="=&gt; akka.actor.ActorRefProvider">provider</a>.<a href="../actor/ActorRefProvider.scala.html#akka.actor;ActorRefProvider.tempContainer" title="=&gt; akka.actor.InternalActorRef">tempContainer</a>

  <span class="keyword">def</span> <a title="=&gt; scala.concurrent.ExecutionContext" id="akka.pattern;PromiseActorRef.internalCallingThreadExecutionContext">internalCallingThreadExecutionContext</a>: <span title="scala.concurrent.ExecutionContext">ExecutionContext</span> =
    <a href="#akka.pattern;PromiseActorRef.provider" title="=&gt; akka.actor.ActorRefProvider">provider</a>.<a href="../actor/ActorRefProvider.scala.html#akka.actor;ActorRefProvider.guardian" title="=&gt; akka.actor.LocalActorRef">guardian</a>.<a href="../actor/ActorRef.scala.html#akka.actor;LocalActorRef.underlying" title="=&gt; akka.actor.ActorCell">underlying</a>.<a href="../actor/ActorCell.scala.html#akka.actor;ActorCell.systemImpl" title="=&gt; akka.actor.ActorSystemImpl">systemImpl</a>.<a href="../actor/ActorSystem.scala.html#akka.actor;ActorSystemImpl.internalCallingThreadExecutionContext" title="=&gt; scala.concurrent.ExecutionContext">internalCallingThreadExecutionContext</a>

  <span class="comment">/**
   * Contract of this method:
   * Must always return the same ActorPath, which must have
   * been registered if we haven't been stopped yet.
   */</span>
  @tailrec
  <span class="keyword">def</span> <a title="=&gt; akka.actor.ActorPath" id="akka.pattern;PromiseActorRef.path">path</a>: <a href="../actor/ActorPath.scala.html#akka.actor;ActorPath" title="akka.actor.ActorPath">ActorPath</a> = <a href="#akka.pattern;PromiseActorRef.state" title="=&gt; AnyRef">state</a> <span title="akka.actor.ActorPath" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <span title="Null(null)" class="keyword">null</span> ⇒
      <span title="akka.actor.ActorPath" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.updateState" title="(oldState: AnyRef, newState: AnyRef)Boolean">updateState</a><span class="delimiter">(</span><span title="Null(null)" class="keyword">null</span>, <a href="#akka.pattern.PromiseActorRef.Registering.readResolve" title="akka.pattern.PromiseActorRef.Registering.type">Registering</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span class="keyword">var</span> <span title="akka.actor.ActorPath">p</span>: <a href="../actor/ActorPath.scala.html#akka.actor;ActorPath" title="akka.actor.ActorPath">ActorPath</a> = <span title="Null(null)" class="keyword">null</span>
        <span class="keyword">try</span> <span class="delimiter">{</span>
          <span title="akka.actor.ActorPath">p</span> = <a href="#akka.pattern;PromiseActorRef.provider" title="=&gt; akka.actor.ActorRefProvider">provider</a>.<a href="../actor/ActorRefProvider.scala.html#akka.actor;ActorRefProvider.tempPath" title="()akka.actor.ActorPath">tempPath</a><span class="delimiter">(</span><span class="delimiter">)</span>
          <a href="#akka.pattern;PromiseActorRef.provider" title="=&gt; akka.actor.ActorRefProvider">provider</a>.<a href="../actor/ActorRefProvider.scala.html#akka.actor;ActorRefProvider.registerTempActor" title="(actorRef: akka.actor.InternalActorRef, path: akka.actor.ActorPath)Unit">registerTempActor</a><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef" class="keyword">this</a>, <span title="akka.actor.ActorPath">p</span><span class="delimiter">)</span>
          <span title="akka.actor.ActorPath">p</span>
        <span class="delimiter">}</span> <span class="keyword">finally</span> <span class="delimiter">{</span> <a href="#akka.pattern;PromiseActorRef.setState" title="(newState: AnyRef)Unit">setState</a><span class="delimiter">(</span><span title="akka.actor.ActorPath">p</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#akka.pattern;PromiseActorRef.path" title="=&gt; akka.actor.ActorPath">path</a>
    <span class="keyword">case</span> <span title="akka.actor.ActorPath">p</span>: <a href="../actor/ActorPath.scala.html#akka.actor;ActorPath" title="akka.actor.ActorPath">ActorPath</a>       ⇒ <span title="akka.actor.ActorPath">p</span>
    <span class="keyword">case</span> StoppedWithPath<span class="delimiter">(</span><span title="akka.actor.ActorPath">p</span><span class="delimiter">)</span> ⇒ <span title="akka.actor.ActorPath">p</span>
    <span class="keyword">case</span> <a href="#akka.pattern.PromiseActorRef.Stopped.readResolve" title="akka.pattern.PromiseActorRef.Stopped.type">Stopped</a> ⇒
      <span class="comment">// even if we are already stopped we still need to produce a proper path</span>
      <a href="#akka.pattern;PromiseActorRef.updateState" title="(oldState: AnyRef, newState: AnyRef)Boolean">updateState</a><span class="delimiter">(</span><a href="#akka.pattern.PromiseActorRef.Stopped.readResolve" title="akka.pattern.PromiseActorRef.Stopped.type">Stopped</a>, <a href="#akka.pattern.PromiseActorRef.StoppedWithPath.readResolve" title="(path: akka.actor.ActorPath)akka.pattern.PromiseActorRef.StoppedWithPath">StoppedWithPath</a><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.provider" title="=&gt; akka.actor.ActorRefProvider">provider</a>.<a href="../actor/ActorRefProvider.scala.html#akka.actor;ActorRefProvider.tempPath" title="()akka.actor.ActorPath">tempPath</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <a href="#akka.pattern;PromiseActorRef.path" title="=&gt; akka.actor.ActorPath">path</a>
    <span class="keyword">case</span> <a href="#akka.pattern.PromiseActorRef.Registering.readResolve" title="akka.pattern.PromiseActorRef.Registering.type">Registering</a> ⇒ <a href="#akka.pattern;PromiseActorRef.path" title="=&gt; akka.actor.ActorPath">path</a> <span class="comment">// spin until registration is completed</span>
  <span class="delimiter">}</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="(message: Any)(implicit sender: akka.actor.ActorRef)Unit" id="akka.pattern;PromiseActorRef.!">!</a><span class="delimiter">(</span><a title="Any" id="akka.pattern;PromiseActorRef.!$default$2.message">message</a>: <span title="Any">Any</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="akka.actor.ActorRef" id="akka.pattern;PromiseActorRef.!$default$2">sender</a>: <a href="../actor/ActorRef.scala.html#akka.actor;ActorRef" title="akka.actor.ActorRef">ActorRef</a> = <a href="../actor/Actor.scala.html#akka.actor.Actor" title="akka.actor.Actor.type">Actor</a>.<a href="../actor/Actor.scala.html#akka.actor.Actor.noSender" title="=&gt; akka.actor.ActorRef">noSender</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.pattern;PromiseActorRef.state" title="=&gt; AnyRef">state</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#akka.pattern.PromiseActorRef.Stopped.readResolve" title="akka.pattern.PromiseActorRef.Stopped.type">Stopped</a> | _: <a href="#akka.pattern.PromiseActorRef.StoppedWithPath.readResolve" title="akka.pattern.PromiseActorRef.StoppedWithPath">StoppedWithPath</a> ⇒ <a href="#akka.pattern;PromiseActorRef.provider" title="=&gt; akka.actor.ActorRefProvider">provider</a>.<a href="../actor/package.scala.html#akka.actor.package.actorRef2Scala" title="implicit akka.actor.package.actorRef2Scala : (ref: akka.actor.ActorRef)akka.actor.ScalaActorRef">deadLetters</a> <a href="../actor/ActorRef.scala.html#akka.actor;ScalaActorRef.!" title="(message: Any)(implicit sender: akka.actor.ActorRef)Unit">!</a> <a href="#akka.pattern;PromiseActorRef.!$default$2.message" title="Any">message</a>
    <span class="keyword">case</span> _ ⇒
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.!$default$2.message" title="Any">message</a> <span title="(x$1: Any)Boolean">==</span> <span title="Null(null)" class="keyword">null</span><span class="delimiter">)</span> <span title="Nothing" class="keyword">throw</span> <span title="akka.actor.InvalidMessageException" class="keyword">new</span> <a href="../actor/Actor.scala.html#akka.actor;InvalidMessageException" title="akka.actor.InvalidMessageException">InvalidMessageException</a><span class="delimiter">(</span><span title="String(&quot;Message is null&quot;)" class="string">&quot;Message is null&quot;</span><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.result" title="=&gt; scala.concurrent.Promise[Any]">result</a>.<span title="(result: scala.util.Try[Any])Boolean">tryComplete</span><span class="delimiter">(</span>
        <a href="#akka.pattern;PromiseActorRef.!$default$2.message" title="Any">message</a> <span title="scala.util.Try[Any]" class="keyword">match</span> <span class="delimiter">{</span>
          <span class="keyword">case</span> Status.Success<span class="delimiter">(</span><a title="Any" id="akka.pattern;PromiseActorRef.!.r">r</a><span class="delimiter">)</span> ⇒ <span title="(value: Any)scala.util.Success[Any]">Success</span><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.!.r" title="Any">r</a><span class="delimiter">)</span>
          <span class="keyword">case</span> Status.Failure<span class="delimiter">(</span><a title="Throwable" id="akka.pattern;PromiseActorRef.!.f">f</a><span class="delimiter">)</span> ⇒ <span title="(exception: Throwable)scala.util.Failure[Nothing]">Failure</span><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.!.f" title="Throwable">f</a><span class="delimiter">)</span>
          <span class="keyword">case</span> <a title="Any" id="akka.pattern;PromiseActorRef.!.other">other</a>             ⇒ <span title="(value: Any)scala.util.Success[Any]">Success</span><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.!.other" title="Any">other</a><span class="delimiter">)</span>
        <span class="delimiter">}</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.pattern;PromiseActorRef.provider" title="=&gt; akka.actor.ActorRefProvider">provider</a>.<a href="../actor/package.scala.html#akka.actor.package.actorRef2Scala" title="implicit akka.actor.package.actorRef2Scala : (ref: akka.actor.ActorRef)akka.actor.ScalaActorRef">deadLetters</a> <a href="../actor/ActorRef.scala.html#akka.actor;ScalaActorRef.!" title="(message: Any)(implicit sender: akka.actor.ActorRef)Unit">!</a> <a href="#akka.pattern;PromiseActorRef.!$default$2.message" title="Any">message</a>
  <span class="delimiter">}</span>

  <span class="keyword">override</span> <span class="keyword">def</span> <a title="(message: akka.dispatch.sysmsg.SystemMessage)Unit" id="akka.pattern;PromiseActorRef.sendSystemMessage">sendSystemMessage</a><span class="delimiter">(</span><a title="akka.dispatch.sysmsg.SystemMessage" id="akka.pattern;PromiseActorRef.sendSystemMessage.message">message</a>: <a href="../dispatch/sysmsg/SystemMessage.scala.html#akka.dispatch.sysmsg;SystemMessage" title="akka.dispatch.sysmsg.SystemMessage">SystemMessage</a><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <a href="#akka.pattern;PromiseActorRef.sendSystemMessage.message" title="akka.dispatch.sysmsg.SystemMessage">message</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> _: <a href="../dispatch/sysmsg/SystemMessage.scala.html#akka.dispatch.sysmsg;Terminate" title="akka.dispatch.sysmsg.Terminate">Terminate</a>                      ⇒ <a href="#akka.pattern;PromiseActorRef.stop" title="()Unit">stop</a><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">case</span> DeathWatchNotification<span class="delimiter">(</span><a title="akka.actor.ActorRef" id="akka.pattern;PromiseActorRef.sendSystemMessage.a">a</a>, <a title="Boolean" id="akka.pattern;PromiseActorRef.sendSystemMessage.ec">ec</a>, <a title="Boolean" id="akka.pattern;PromiseActorRef.sendSystemMessage.at">at</a><span class="delimiter">)</span> ⇒ <a href="#akka.pattern;PromiseActorRef" title="PromiseActorRef.this.type" class="keyword">this</a>.<a href="#akka.pattern;PromiseActorRef.!" title="(message: Any)(implicit sender: akka.actor.ActorRef)Unit">!</a><a href="#akka.pattern;PromiseActorRef.!$default$2" title="akka.actor.ActorRef" id="akka.pattern;PromiseActorRef.sendSystemMessage.x$5" class="delimiter">(</a><a href="../actor/Actor.scala.html#akka.actor;Terminated" title="(actor: akka.actor.ActorRef)(existenceConfirmed: Boolean, addressTerminated: Boolean)akka.actor.Terminated">Terminated</a><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.sendSystemMessage.a" title="akka.actor.ActorRef">a</a><span class="delimiter">)</span><a title="akka.actor.Terminated" id="akka.pattern;PromiseActorRef.sendSystemMessage.x$4" class="delimiter">(</a>existenceConfirmed = <a href="#akka.pattern;PromiseActorRef.sendSystemMessage.ec" title="Boolean">ec</a>, addressTerminated = <a href="#akka.pattern;PromiseActorRef.sendSystemMessage.at" title="Boolean">at</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> Watch<span class="delimiter">(</span><span title="akka.actor.InternalActorRef">watchee</span>, <span title="akka.actor.InternalActorRef">watcher</span><span class="delimiter">)</span> ⇒
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="akka.actor.InternalActorRef">watchee</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef" class="keyword">this</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="akka.actor.InternalActorRef">watcher</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef" class="keyword">this</a><span class="delimiter">)</span> <span class="delimiter">{</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#akka.pattern;PromiseActorRef.addWatcher" title="(watcher: akka.actor.ActorRef)Boolean">addWatcher</a><span class="delimiter">(</span><span title="akka.actor.InternalActorRef">watcher</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="comment">// ➡➡➡ NEVER SEND THE SAME SYSTEM MESSAGE OBJECT TO TWO ACTORS ⬅⬅⬅</span>
          <span title="akka.actor.InternalActorRef">watcher</span>.<a href="../actor/ActorRef.scala.html#akka.actor;InternalActorRef.sendSystemMessage" title="(message: akka.dispatch.sysmsg.SystemMessage)Unit">sendSystemMessage</a><span class="delimiter">(</span><a href="../dispatch/sysmsg/SystemMessage.scala.html#akka.dispatch.sysmsg;DeathWatchNotification" title="(actor: akka.actor.ActorRef, existenceConfirmed: Boolean, addressTerminated: Boolean)akka.dispatch.sysmsg.DeathWatchNotification">DeathWatchNotification</a><span class="delimiter">(</span><span title="akka.actor.InternalActorRef">watchee</span>, existenceConfirmed = <span title="Boolean(true)" class="keyword">true</span>, addressTerminated = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span> <span class="keyword">else</span> <span title="System.type">System</span>.<span title="java.io.PrintStream">err</span>.<span title="(x$1: String)Unit">println</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;BUG: illegal Watch(%s,%s) for %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><span title="akka.actor.InternalActorRef">watchee</span>, <span title="akka.actor.InternalActorRef">watcher</span>, <a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> Unwatch<span class="delimiter">(</span><span title="akka.actor.ActorRef">watchee</span>, <span title="akka.actor.ActorRef">watcher</span><span class="delimiter">)</span> ⇒
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="akka.actor.ActorRef">watchee</span> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef" class="keyword">this</a> <span title="(x: Boolean)Boolean">&amp;&amp;</span> <span title="akka.actor.ActorRef">watcher</span> <span title="(x$1: AnyRef)Boolean">!=</span> <a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef" class="keyword">this</a><span class="delimiter">)</span> <a href="#akka.pattern;PromiseActorRef.remWatcher" title="(watcher: akka.actor.ActorRef)Unit">remWatcher</a><span class="delimiter">(</span><span title="akka.actor.ActorRef">watcher</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="System.type">System</span>.<span title="java.io.PrintStream">err</span>.<span title="(x$1: String)Unit">println</span><span class="delimiter">(</span><span title="implicit scala.Predef.augmentString : (x: String)scala.collection.immutable.StringOps" class="string">&quot;BUG: illegal Unwatch(%s,%s) for %s&quot;</span>.<span title="(args: Any*)String">format</span><span class="delimiter">(</span><span title="akka.actor.ActorRef">watchee</span>, <span title="akka.actor.ActorRef">watcher</span>, <a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef" class="keyword">this</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">case</span> _ ⇒
  <span class="delimiter">}</span>

  @deprecated<span class="delimiter">(</span><span class="string">&quot;Use context.watch(actor) and receive Terminated(actor)&quot;</span>, <span class="string">&quot;2.2&quot;</span><span class="delimiter">)</span> <span class="keyword">override</span> <span class="keyword">def</span> <a title="=&gt; Boolean" id="akka.pattern;PromiseActorRef.isTerminated">isTerminated</a>: <span title="Boolean">Boolean</span> = <a href="#akka.pattern;PromiseActorRef.state" title="=&gt; AnyRef">state</a> <span title="Boolean" class="keyword">match</span> <span class="delimiter">{</span>
    <span class="keyword">case</span> <a href="#akka.pattern.PromiseActorRef.Stopped.readResolve" title="akka.pattern.PromiseActorRef.Stopped.type">Stopped</a> | _: <a href="#akka.pattern.PromiseActorRef.StoppedWithPath.readResolve" title="akka.pattern.PromiseActorRef.StoppedWithPath">StoppedWithPath</a> ⇒ <span title="Boolean(true)" class="keyword">true</span>
    <span class="keyword">case</span> _                            ⇒ <span title="Boolean(false)" class="keyword">false</span>
  <span class="delimiter">}</span>

  @tailrec
  <span class="keyword">override</span> <span class="keyword">def</span> <a title="()Unit" id="akka.pattern;PromiseActorRef.stop">stop</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="()Unit" id="akka.pattern;PromiseActorRef.stop.ensureCompleted">ensureCompleted</a><span class="delimiter">(</span><span class="delimiter">)</span>: <span title="Unit">Unit</span> = <span class="delimiter">{</span>
      <a href="#akka.pattern;PromiseActorRef.result" title="=&gt; scala.concurrent.Promise[Any]">result</a> <span title="(result: scala.util.Try[Any])Boolean">tryComplete</span> <span title="(exception: Throwable)scala.util.Failure[Nothing]">Failure</span><span class="delimiter">(</span><span title="akka.actor.ActorKilledException" class="keyword">new</span> <a href="../actor/Actor.scala.html#akka.actor;ActorKilledException" title="akka.actor.ActorKilledException">ActorKilledException</a><span class="delimiter">(</span><span title="String(&quot;Stopped&quot;)" class="string">&quot;Stopped&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">val</span> <a title="Set[akka.actor.ActorRef]" id="akka.pattern;PromiseActorRef.stop.ensureCompleted.watchers">watchers</a> = <a href="#akka.pattern;PromiseActorRef.clearWatchers" title="()Set[akka.actor.ActorRef]">clearWatchers</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><span title="=&gt; Boolean">!</span><a href="#akka.pattern;PromiseActorRef.stop.ensureCompleted.watchers" title="Set[akka.actor.ActorRef]">watchers</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> <span class="delimiter">{</span>
        <a href="#akka.pattern;PromiseActorRef.stop.ensureCompleted.watchers" title="Set[akka.actor.ActorRef]">watchers</a> <span title="(f: akka.actor.ActorRef =&gt; Unit)Unit">foreach</span> <span class="delimiter">{</span> <a title="akka.actor.ActorRef" id="akka.pattern;PromiseActorRef.stop.ensureCompleted.$anonfun.watcher">watcher</a> ⇒
          <span class="comment">// ➡➡➡ NEVER SEND THE SAME SYSTEM MESSAGE OBJECT TO TWO ACTORS ⬅⬅⬅</span>
          <a href="#akka.pattern;PromiseActorRef.stop.ensureCompleted.$anonfun.watcher" title="akka.actor.ActorRef">watcher</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="akka.actor.InternalActorRef" class="delimiter">[</span><a href="../actor/ActorRef.scala.html#akka.actor;InternalActorRef" title="akka.actor.InternalActorRef">InternalActorRef</a><span class="delimiter">]</span>
            .<a href="../actor/ActorRef.scala.html#akka.actor;InternalActorRef.sendSystemMessage" title="(message: akka.dispatch.sysmsg.SystemMessage)Unit">sendSystemMessage</a><span class="delimiter">(</span><a href="../dispatch/sysmsg/SystemMessage.scala.html#akka.dispatch.sysmsg;DeathWatchNotification" title="(actor: akka.actor.ActorRef, existenceConfirmed: Boolean, addressTerminated: Boolean)akka.dispatch.sysmsg.DeathWatchNotification">DeathWatchNotification</a><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.stop.ensureCompleted.$anonfun.watcher" title="akka.actor.ActorRef">watcher</a>, existenceConfirmed = <span title="Boolean(true)" class="keyword">true</span>, addressTerminated = <span title="Boolean(false)" class="keyword">false</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
    <a href="#akka.pattern;PromiseActorRef.state" title="=&gt; AnyRef">state</a> <span title="Unit" class="keyword">match</span> <span class="delimiter">{</span>
      <span class="keyword">case</span> <span title="Null(null)" class="keyword">null</span> ⇒ <span class="comment">// if path was never queried nobody can possibly be watching us, so we don't have to publish termination either</span>
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.updateState" title="(oldState: AnyRef, newState: AnyRef)Boolean">updateState</a><span class="delimiter">(</span><span title="Null(null)" class="keyword">null</span>, <a href="#akka.pattern.PromiseActorRef.Stopped.readResolve" title="akka.pattern.PromiseActorRef.Stopped.type">Stopped</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="#akka.pattern;PromiseActorRef.stop.ensureCompleted" title="()Unit">ensureCompleted</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="keyword">else</span> <a href="#akka.pattern;PromiseActorRef.stop" title="()Unit">stop</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a title="akka.actor.ActorPath" id="akka.pattern;PromiseActorRef.stop.p">p</a>: <a href="../actor/ActorPath.scala.html#akka.actor;ActorPath" title="akka.actor.ActorPath">ActorPath</a> ⇒
        <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.updateState" title="(oldState: AnyRef, newState: AnyRef)Boolean">updateState</a><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.stop.p" title="akka.actor.ActorPath">p</a>, <a href="#akka.pattern.PromiseActorRef.StoppedWithPath.readResolve" title="(path: akka.actor.ActorPath)akka.pattern.PromiseActorRef.StoppedWithPath">StoppedWithPath</a><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.stop.p" title="akka.actor.ActorPath">p</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">{</span> <span class="keyword">try</span> <a href="#akka.pattern;PromiseActorRef.stop.ensureCompleted" title="()Unit">ensureCompleted</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="keyword">finally</span> <a href="#akka.pattern;PromiseActorRef.provider" title="=&gt; akka.actor.ActorRefProvider">provider</a>.<a href="../actor/ActorRefProvider.scala.html#akka.actor;ActorRefProvider.unregisterTempActor" title="(path: akka.actor.ActorPath)Unit">unregisterTempActor</a><span class="delimiter">(</span><a href="#akka.pattern;PromiseActorRef.stop.p" title="akka.actor.ActorPath">p</a><span class="delimiter">)</span> <span class="delimiter">}</span> <span class="keyword">else</span> <a href="#akka.pattern;PromiseActorRef.stop" title="()Unit">stop</a><span class="delimiter">(</span><span class="delimiter">)</span>
      <span class="keyword">case</span> <a href="#akka.pattern.PromiseActorRef.Stopped.readResolve" title="akka.pattern.PromiseActorRef.Stopped.type">Stopped</a> | _: <a href="#akka.pattern.PromiseActorRef.StoppedWithPath.readResolve" title="akka.pattern.PromiseActorRef.StoppedWithPath">StoppedWithPath</a> ⇒ <span class="comment">// already stopped</span>
      <span class="keyword">case</span> <a href="#akka.pattern.PromiseActorRef.Registering.readResolve" title="akka.pattern.PromiseActorRef.Registering.type">Registering</a>                  ⇒ <a href="#akka.pattern;PromiseActorRef.stop" title="()Unit">stop</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="comment">// spin until registration is completed before stopping</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * INTERNAL API
 */</span>
<span class="keyword">private</span><span class="delimiter">[</span>akka<span class="delimiter">]</span> <span class="keyword">object</span> <a title="akka.pattern.PromiseActorRef.type" id="akka.pattern.PromiseActorRef.readResolve">PromiseActorRef</a> <a href="#akka.pattern.PromiseActorRef.readResolve" title="akka.pattern.PromiseActorRef.type" class="delimiter">{</a>
  <span class="keyword">private</span> <span class="keyword">case object</span> <a href="#akka.pattern.PromiseActorRef.Registering.productElement.x$1" title="akka.pattern.PromiseActorRef.Registering.type" id="akka.pattern.PromiseActorRef.Registering.readResolve">Registering</a>
  <span class="keyword">private</span> <span class="keyword">case object</span> <a href="#akka.pattern.PromiseActorRef.Stopped.productElement.x$1" title="akka.pattern.PromiseActorRef.Stopped.type" id="akka.pattern.PromiseActorRef.Stopped.readResolve">Stopped</a>
  <span class="keyword">private</span> <span class="keyword">case class</span> <a title="class StoppedWithPath extends AnyRef with Product with Serializable" id="akka.pattern.PromiseActorRef.StoppedWithPath.readResolve">StoppedWithPath</a><a href="#akka.pattern.PromiseActorRef.StoppedWithPath.readResolve" title="Product" class="delimiter">(</a><a title="akka.actor.ActorPath" id="akka.pattern.PromiseActorRef;StoppedWithPath.path">path</a>: <a href="../actor/ActorPath.scala.html#akka.actor;ActorPath" title="akka.actor.ActorPath">ActorPath</a><span class="delimiter">)</span>

  <span class="keyword">def</span> <a title="(provider: akka.actor.ActorRefProvider, timeout: akka.util.Timeout, targetName: String)akka.pattern.PromiseActorRef" id="akka.pattern.PromiseActorRef.apply">apply</a><span class="delimiter">(</span><a title="akka.actor.ActorRefProvider" id="akka.pattern.PromiseActorRef.apply.provider">provider</a>: <a href="../actor/ActorRefProvider.scala.html#akka.actor;ActorRefProvider" title="akka.actor.ActorRefProvider">ActorRefProvider</a>, <a title="akka.util.Timeout" id="akka.pattern.PromiseActorRef.apply.timeout">timeout</a>: <a href="../util/Timeout.scala.html#akka.util;Timeout" title="akka.util.Timeout">Timeout</a>, <a title="String" id="akka.pattern.PromiseActorRef.apply.targetName">targetName</a>: <span title="String">String</span><span class="delimiter">)</span>: <a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef">PromiseActorRef</a> = <span class="delimiter">{</span>
    <span class="keyword">val</span> <a title="scala.concurrent.Promise[Any]" id="akka.pattern.PromiseActorRef.apply.result">result</a> = <span title="[T]()scala.concurrent.Promise[T]">Promise</span><span title="()scala.concurrent.Promise[Any]" class="delimiter">[</span><span title="Any">Any</span><span class="delimiter">]</span><span class="delimiter">(</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="akka.actor.Scheduler" id="akka.pattern.PromiseActorRef.apply.scheduler">scheduler</a> = <a href="#akka.pattern.PromiseActorRef.apply.provider" title="akka.actor.ActorRefProvider">provider</a>.<a href="../actor/ActorRefProvider.scala.html#akka.actor;ActorRefProvider.guardian" title="=&gt; akka.actor.LocalActorRef">guardian</a>.<a href="../actor/ActorRef.scala.html#akka.actor;LocalActorRef.underlying" title="=&gt; akka.actor.ActorCell">underlying</a>.<a href="../actor/ActorCell.scala.html#akka.actor;ActorCell.system" title="=&gt; akka.actor.ActorSystemImpl">system</a>.<a href="../actor/ActorSystem.scala.html#akka.actor;ActorSystemImpl.scheduler" title="=&gt; akka.actor.Scheduler">scheduler</a>
    <span class="keyword">val</span> <a title="akka.pattern.PromiseActorRef" id="akka.pattern.PromiseActorRef.apply.a">a</a> = <span title="akka.pattern.PromiseActorRef" class="keyword">new</span> <a href="#akka.pattern;PromiseActorRef" title="akka.pattern.PromiseActorRef">PromiseActorRef</a><span class="delimiter">(</span><a href="#akka.pattern.PromiseActorRef.apply.provider" title="akka.actor.ActorRefProvider">provider</a>, <a href="#akka.pattern.PromiseActorRef.apply.result" title="scala.concurrent.Promise[Any]">result</a><span class="delimiter">)</span>
    <span class="keyword">implicit</span> <span class="keyword">val</span> <a title="scala.concurrent.ExecutionContext" id="akka.pattern.PromiseActorRef.apply.ec">ec</a> = <a href="#akka.pattern.PromiseActorRef.apply.a" title="akka.pattern.PromiseActorRef">a</a>.<a href="#akka.pattern;PromiseActorRef.internalCallingThreadExecutionContext" title="=&gt; scala.concurrent.ExecutionContext">internalCallingThreadExecutionContext</a>
    <span class="keyword">val</span> <a title="akka.actor.Cancellable" id="akka.pattern.PromiseActorRef.apply.f">f</a> = <a href="#akka.pattern.PromiseActorRef.apply.scheduler" title="akka.actor.Scheduler">scheduler</a>.<a href="../actor/Scheduler.scala.html#akka.actor;Scheduler.scheduleOnce(066d40b78a)" title="(delay: scala.concurrent.duration.FiniteDuration)(f: =&gt; Unit)(implicit executor: scala.concurrent.ExecutionContext)akka.actor.Cancellable">scheduleOnce</a><span class="delimiter">(</span><a href="#akka.pattern.PromiseActorRef.apply.timeout" title="akka.util.Timeout">timeout</a>.<a href="../util/Timeout.scala.html#akka.util;Timeout.duration" title="=&gt; scala.concurrent.duration.FiniteDuration">duration</a><span class="delimiter">)</span> <a href="#akka.pattern.PromiseActorRef.apply.ec" title="scala.concurrent.ExecutionContext" class="delimiter">{</a>
      <a href="#akka.pattern.PromiseActorRef.apply.result" title="scala.concurrent.Promise[Any]">result</a> <span title="(result: scala.util.Try[Any])Boolean">tryComplete</span> <span title="(exception: Throwable)scala.util.Failure[Nothing]">Failure</span><span class="delimiter">(</span><a href="#akka.pattern;AskTimeoutException.<init>(9b6cbaa318)" title="(message: String)akka.pattern.AskTimeoutException" class="keyword">new</a> <a href="#akka.pattern;AskTimeoutException" title="akka.pattern.AskTimeoutException">AskTimeoutException</a><span class="delimiter">(</span><span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Ask timed out on [&quot;)">Ask timed out on [$</span><a href="#akka.pattern.PromiseActorRef.apply.targetName" title="String">targetName</a><span title="String(&quot;] after [&quot;)">] after [$</span><span class="delimiter">{</span><a href="#akka.pattern.PromiseActorRef.apply.timeout" title="akka.util.Timeout">timeout</a>.<a href="../util/Timeout.scala.html#akka.util;Timeout.duration" title="=&gt; scala.concurrent.duration.FiniteDuration">duration</a>.<span title="=&gt; Long">toMillis</span><span class="delimiter">}</span><span title="String(&quot; ms]&quot;)" class="string"> ms]&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
    <a href="#akka.pattern.PromiseActorRef.apply.result" title="scala.concurrent.Promise[Any]">result</a>.<span title="=&gt; scala.concurrent.Future[Any]">future</span> <a href="#akka.pattern.PromiseActorRef.apply.ec" title="(func: scala.util.Try[Any] =&gt; Unit)(implicit executor: scala.concurrent.ExecutionContext)Unit">onComplete</a> <span class="delimiter">{</span> <a title="scala.util.Try[Any]" id="akka.pattern.PromiseActorRef.apply.$anonfun.x$1">_</a> ⇒ <span class="keyword">try</span> <a href="#akka.pattern.PromiseActorRef.apply.a" title="akka.pattern.PromiseActorRef">a</a>.<a href="#akka.pattern;PromiseActorRef.stop" title="()Unit">stop</a><span class="delimiter">(</span><span class="delimiter">)</span> <span class="keyword">finally</span> <a href="#akka.pattern.PromiseActorRef.apply.f" title="akka.actor.Cancellable">f</a>.<a href="../actor/Scheduler.scala.html#akka.actor;Cancellable.cancel" title="()Boolean">cancel</a><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span> <span class="delimiter">}</span>
    <a href="#akka.pattern.PromiseActorRef.apply.a" title="akka.pattern.PromiseActorRef">a</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
