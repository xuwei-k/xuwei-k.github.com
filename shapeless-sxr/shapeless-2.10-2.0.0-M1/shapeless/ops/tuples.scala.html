<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>shapeless/ops/tuples.scala</title>
        <script type="text/javascript" src="../../jquery-all.js"></script>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (c) 2013 Miles Sabin 
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span class="keyword">package</span> shapeless
<span class="keyword">package</span> ops

<span class="keyword">object</span> <a title="shapeless.ops.tuple.type" id="shapeless.ops.tuple">tuple</a> <a href="#shapeless.ops.tuple" title="shapeless.ops.tuple.type" class="delimiter">{</a>
  <span class="keyword">import</span> shapeless.ops.<span class="delimiter">{</span> hlist =&gt; hl <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class witnessing that this tuple is composite and providing access to head and tail. 
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait IsComposite[P] extends AnyRef" id="shapeless.ops.tuple;IsComposite">IsComposite</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;IsComposite;P">P</a><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="" id="shapeless.ops.tuple;IsComposite;H">H</a>
    <span class="keyword">type</span> <a title="" id="shapeless.ops.tuple;IsComposite;T">T</a>
      
    <span class="keyword">def</span> <a title="(p: P)IsComposite.this.H" id="shapeless.ops.tuple;IsComposite.head">head</a><span class="delimiter">(</span><a title="P" id="shapeless.ops.tuple;IsComposite.head.p">p</a> : <a href="#shapeless.ops.tuple;IsComposite;P" title="P">P</a><span class="delimiter">)</span> : <a href="#shapeless.ops.tuple;IsComposite;H" title="IsComposite.this.H">H</a>
    <span class="keyword">def</span> <a title="(p: P)IsComposite.this.T" id="shapeless.ops.tuple;IsComposite.tail">tail</a><span class="delimiter">(</span><a title="P" id="shapeless.ops.tuple;IsComposite.tail.p">p</a> : <a href="#shapeless.ops.tuple;IsComposite;P" title="P">P</a><span class="delimiter">)</span> : <a href="#shapeless.ops.tuple;IsComposite;T" title="IsComposite.this.T">T</a>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.IsComposite.type" id="shapeless.ops.tuple.IsComposite">IsComposite</a> <a href="#shapeless.ops.tuple.IsComposite" title="shapeless.ops.tuple.IsComposite.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="IsComposite[P, H0, T0] extends shapeless.ops.tuple.IsComposite[P]" id="shapeless.ops.tuple.IsComposite;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.IsComposite;Aux;P">P</a>, <a title="" id="shapeless.ops.tuple.IsComposite;Aux;H0">H0</a>, <a title="" id="shapeless.ops.tuple.IsComposite;Aux;T0">T0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.IsComposite;<refinement>" title="IsComposite extends shapeless.ops.tuple.IsComposite[P]">IsComposite</a><span class="delimiter">[</span>P<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> H = H0; <span class="keyword">type</span> T = T0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[P, L &lt;: shapeless.HList, H0, T &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[P,L], implicit isHCons: shapeless.ops.hlist.IsHCons.Aux[L,H0,T], implicit tp: shapeless.ops.hlist.Tupler[T])shapeless.ops.tuple.IsComposite.Aux[P,H0,tp.Out]" id="shapeless.ops.tuple.IsComposite.isComposite">isComposite</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.IsComposite.isComposite;P">P</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.IsComposite.isComposite;L">L</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.IsComposite.isComposite;H0">H0</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.IsComposite.isComposite;T">T</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[P,L]" id="shapeless.ops.tuple.IsComposite.isComposite.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[P,L]">Aux</a><span class="delimiter">[</span>P, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.IsHCons.Aux[L,H0,T]" id="shapeless.ops.tuple.IsComposite.isComposite.isHCons">isHCons</a>: hl.IsHCons.<a href="hlists.scala.html#shapeless.ops.hlist.IsHCons;<refinement>" title="shapeless.ops.hlist.IsHCons.Aux[L,H0,T]">Aux</a><span class="delimiter">[</span>L, H0, T<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[T]" id="shapeless.ops.tuple.IsComposite.isComposite.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[T]">Tupler</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.IsComposite;<refinement>" title="shapeless.ops.tuple.IsComposite.Aux[P,H0,tp.Out]">Aux</a><span class="delimiter">[</span>P, H0, tp.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.IsComposite.isComposite;$anon" title="shapeless.ops.tuple.IsComposite[P]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.IsComposite[P]" id="shapeless.ops.tuple.IsComposite.isComposite;$anon">IsComposite</a><span class="delimiter">[</span>P<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="H0" id="shapeless.ops.tuple.IsComposite.isComposite;$anon;H">H</a> = <a href="#shapeless.ops.tuple.IsComposite.isComposite;H0" title="H0">H0</a>
          <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.IsComposite.isComposite;$anon;T">T</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
          <span class="keyword">def</span> <a title="(p: P)this.H" id="shapeless.ops.tuple.IsComposite.isComposite;$anon.head">head</a><span class="delimiter">(</span><a title="P" id="shapeless.ops.tuple.IsComposite.isComposite;$anon.head.p">p</a>: <a href="#shapeless.ops.tuple.IsComposite.isComposite;P" title="P">P</a><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.IsComposite.isComposite;H0" title="this.H">H</a> = <a href="#shapeless.ops.tuple.IsComposite.isComposite.isHCons" title="shapeless.ops.hlist.IsHCons.Aux[L,H0,T]">isHCons</a>.<a href="hlists.scala.html#shapeless.ops.hlist;IsHCons.head" title="(l: L)isHCons.H">head</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.IsComposite.isComposite.gen" title="shapeless.Generic.Aux[P,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: P)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.IsComposite.isComposite;$anon.head.p" title="P">p</a><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(p: P)this.T" id="shapeless.ops.tuple.IsComposite.isComposite;$anon.tail">tail</a><span class="delimiter">(</span><a title="P" id="shapeless.ops.tuple.IsComposite.isComposite;$anon.tail.p">p</a>: <a href="#shapeless.ops.tuple.IsComposite.isComposite;P" title="P">P</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.T">T</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: T)tp.Out">tp</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.IsComposite.isComposite.isHCons" title="shapeless.ops.hlist.IsHCons.Aux[L,H0,T]">isHCons</a>.<a href="hlists.scala.html#shapeless.ops.hlist;IsHCons.tail" title="(l: L)isHCons.T">tail</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.IsComposite.isComposite.gen" title="shapeless.Generic.Aux[P,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: P)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.IsComposite.isComposite;$anon.tail.p" title="P">p</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting prepending to this tuple.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Prepend[T, U] extends AnyRef with shapeless.DepFn2[T,U]" id="shapeless.ops.tuple;Prepend">Prepend</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Prepend;T">T</a>, <a title="" id="shapeless.ops.tuple;Prepend;U">U</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn2" title="shapeless.DepFn2[T,U]">DepFn2</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Prepend.type" id="shapeless.ops.tuple.Prepend">Prepend</a> <a href="#shapeless.ops.tuple.Prepend" title="shapeless.ops.tuple.Prepend.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="Prepend[T, U, Out0] extends shapeless.ops.tuple.Prepend[T,U]" id="shapeless.ops.tuple.Prepend;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Prepend;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.Prepend;Aux;U">U</a>, <a title="" id="shapeless.ops.tuple.Prepend;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Prepend;<refinement>" title="Prepend extends shapeless.ops.tuple.Prepend[T,U]">Prepend</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L1 &lt;: shapeless.HList, U, L2 &lt;: shapeless.HList, L3 &lt;: shapeless.HList](implicit gent: shapeless.Generic.Aux[T,L1], implicit genu: shapeless.Generic.Aux[U,L2], implicit prepend: shapeless.ops.hlist.Prepend.Aux[L1,L2,L3], implicit tp: shapeless.ops.hlist.Tupler[L3])shapeless.ops.tuple.Prepend.Aux[T,U,tp.Out]" id="shapeless.ops.tuple.Prepend.prepend">prepend</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Prepend.prepend;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Prepend.prepend;L1">L1</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.Prepend.prepend;U">U</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Prepend.prepend;L2">L2</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Prepend.prepend;L3">L3</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.Prepend.prepend.gent">gent</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.Generic.Aux[U,L2]" id="shapeless.ops.tuple.Prepend.prepend.genu">genu</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[U,L2]">Aux</a><span class="delimiter">[</span>U, L2<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Prepend.Aux[L1,L2,L3]" id="shapeless.ops.tuple.Prepend.prepend.prepend">prepend</a>: hl.Prepend.<a href="hlists.scala.html#shapeless.ops.hlist;LowPriorityPrepend;<refinement>" title="shapeless.ops.hlist.Prepend.Aux[L1,L2,L3]">Aux</a><span class="delimiter">[</span>L1, L2, L3<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L3]" id="shapeless.ops.tuple.Prepend.prepend.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L3]">Tupler</a><span class="delimiter">[</span>L3<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Prepend;<refinement>" title="shapeless.ops.tuple.Prepend.Aux[T,U,tp.Out]">Aux</a><span class="delimiter">[</span>T, U, tp.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.Prepend.prepend;$anon" title="shapeless.ops.tuple.Prepend[T,U]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Prepend[T,U]" id="shapeless.ops.tuple.Prepend.prepend;$anon">Prepend</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.Prepend.prepend;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T, u: U)this.Out" id="shapeless.ops.tuple.Prepend.prepend;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Prepend.prepend;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Prepend.prepend;T" title="T">T</a>, <a title="U" id="shapeless.ops.tuple.Prepend.prepend;$anon.apply.u">u</a>: <a href="#shapeless.ops.tuple.Prepend.prepend;U" title="U">U</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L1, u: L2)prepend.Out">prepend</a><a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: prepend.Out)shapeless.syntax.HListOps[prepend.Out]" class="delimiter">(</a><a href="#shapeless.ops.tuple.Prepend.prepend.gent" title="shapeless.Generic.Aux[T,L1]">gent</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gent.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Prepend.prepend;$anon.apply.t" title="T">t</a><span class="delimiter">)</span>, <a href="#shapeless.ops.tuple.Prepend.prepend.genu" title="shapeless.Generic.Aux[U,L2]">genu</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: U)genu.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Prepend.prepend;$anon.apply.u" title="U">u</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../syntax/hlists.scala.html#shapeless.syntax;HListOps.tupled" title="(implicit tupler: shapeless.ops.hlist.Tupler[prepend.Out])tupler.Out">tupled</a>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting reverse prepending to this tuple.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait ReversePrepend[T, U] extends AnyRef with shapeless.DepFn2[T,U]" id="shapeless.ops.tuple;ReversePrepend">ReversePrepend</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;ReversePrepend;T">T</a>, <a title="" id="shapeless.ops.tuple;ReversePrepend;U">U</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn2" title="shapeless.DepFn2[T,U]">DepFn2</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.ReversePrepend.type" id="shapeless.ops.tuple.ReversePrepend">ReversePrepend</a> <a href="#shapeless.ops.tuple.ReversePrepend" title="shapeless.ops.tuple.ReversePrepend.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="ReversePrepend[T, U, Out0] extends shapeless.ops.tuple.ReversePrepend[T,U]" id="shapeless.ops.tuple.ReversePrepend;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ReversePrepend;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.ReversePrepend;Aux;U">U</a>, <a title="" id="shapeless.ops.tuple.ReversePrepend;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.ReversePrepend;<refinement>" title="ReversePrepend extends shapeless.ops.tuple.ReversePrepend[T,U]">ReversePrepend</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L1 &lt;: shapeless.HList, U, L2 &lt;: shapeless.HList, L3 &lt;: shapeless.HList](implicit gent: shapeless.Generic.Aux[T,L1], implicit genu: shapeless.Generic.Aux[U,L2], implicit prepend: shapeless.ops.hlist.ReversePrepend.Aux[L1,L2,L3], implicit tp: shapeless.ops.hlist.Tupler[L3])shapeless.ops.tuple.ReversePrepend.Aux[T,U,tp.Out]" id="shapeless.ops.tuple.ReversePrepend.prepend">prepend</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ReversePrepend.prepend;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ReversePrepend.prepend;L1">L1</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.ReversePrepend.prepend;U">U</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ReversePrepend.prepend;L2">L2</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ReversePrepend.prepend;L3">L3</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.ReversePrepend.prepend.gent">gent</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.Generic.Aux[U,L2]" id="shapeless.ops.tuple.ReversePrepend.prepend.genu">genu</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[U,L2]">Aux</a><span class="delimiter">[</span>U, L2<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ReversePrepend.Aux[L1,L2,L3]" id="shapeless.ops.tuple.ReversePrepend.prepend.prepend">prepend</a>: hl.ReversePrepend.<a href="hlists.scala.html#shapeless.ops.hlist;LowPriorityReversePrepend;<refinement>" title="shapeless.ops.hlist.ReversePrepend.Aux[L1,L2,L3]">Aux</a><span class="delimiter">[</span>L1, L2, L3<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L3]" id="shapeless.ops.tuple.ReversePrepend.prepend.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L3]">Tupler</a><span class="delimiter">[</span>L3<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.ReversePrepend;<refinement>" title="shapeless.ops.tuple.ReversePrepend.Aux[T,U,tp.Out]">Aux</a><span class="delimiter">[</span>T, U, tp.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.ReversePrepend.prepend;$anon" title="shapeless.ops.tuple.ReversePrepend[T,U]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.ReversePrepend[T,U]" id="shapeless.ops.tuple.ReversePrepend.prepend;$anon">ReversePrepend</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.ReversePrepend.prepend;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T, u: U)this.Out" id="shapeless.ops.tuple.ReversePrepend.prepend;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.ReversePrepend.prepend;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.ReversePrepend.prepend;T" title="T">T</a>, <a title="U" id="shapeless.ops.tuple.ReversePrepend.prepend;$anon.apply.u">u</a>: <a href="#shapeless.ops.tuple.ReversePrepend.prepend;U" title="U">U</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L1, u: L2)prepend.Out">prepend</a><a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: prepend.Out)shapeless.syntax.HListOps[prepend.Out]" class="delimiter">(</a><a href="#shapeless.ops.tuple.ReversePrepend.prepend.gent" title="shapeless.Generic.Aux[T,L1]">gent</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gent.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ReversePrepend.prepend;$anon.apply.t" title="T">t</a><span class="delimiter">)</span>, <a href="#shapeless.ops.tuple.ReversePrepend.prepend.genu" title="shapeless.Generic.Aux[U,L2]">genu</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: U)genu.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ReversePrepend.prepend;$anon.apply.u" title="U">u</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../syntax/hlists.scala.html#shapeless.syntax;HListOps.tupled" title="(implicit tupler: shapeless.ops.hlist.Tupler[prepend.Out])tupler.Out">tupled</a>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting access to the ''nth'' element of this tuple. Available only if this tuple has at least
   * ''n'' elements. 
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait At[T, N &lt;: shapeless.Nat] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;At">At</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;At;T">T</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple;At;N">N</a> &lt;: Nat<span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.At.type" id="shapeless.ops.tuple.At">At</a> <a href="#shapeless.ops.tuple.At" title="shapeless.ops.tuple.At.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="At[T, N &lt;: shapeless.Nat, Out0] extends shapeless.ops.tuple.At[T,N]" id="shapeless.ops.tuple.At;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.At;Aux;T">T</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple.At;Aux;N">N</a> &lt;: Nat, <a title="" id="shapeless.ops.tuple.At;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.At;<refinement>" title="At extends shapeless.ops.tuple.At[T,N]">At</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L1 &lt;: shapeless.HList, N &lt;: shapeless.Nat](implicit gen: shapeless.Generic.Aux[T,L1], implicit at: shapeless.ops.hlist.At[L1,N])shapeless.ops.tuple.At.Aux[T,N,at.Out]" id="shapeless.ops.tuple.At.at">at</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.At.at;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.At.at;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple.At.at;N">N</a> &lt;: Nat<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.At.at.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.At[L1,N]" id="shapeless.ops.tuple.At.at.at">at</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;At" title="shapeless.ops.hlist.At[L1,N]">At</a><span class="delimiter">[</span>L1, N<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.At;<refinement>" title="shapeless.ops.tuple.At.Aux[T,N,at.Out]">Aux</a><span class="delimiter">[</span>T, N, at.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.At.at;$anon" title="shapeless.ops.tuple.At[T,N]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.At[T,N]" id="shapeless.ops.tuple.At.at;$anon">At</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="at.Out" id="shapeless.ops.tuple.At.at;$anon;Out">Out</a> = at.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="at.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T)this.Out" id="shapeless.ops.tuple.At.at;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.At.at;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.At.at;T" title="T">T</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L1)at.Out">at</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.At.at.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.At.at;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting access to the last element of this tuple. Available only if this tuple has at least one
   * element.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Last[T] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;Last">Last</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Last;T">T</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Last.type" id="shapeless.ops.tuple.Last">Last</a> <a href="#shapeless.ops.tuple.Last" title="shapeless.ops.tuple.Last.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="Last[T, Out0] extends shapeless.ops.tuple.Last[T]" id="shapeless.ops.tuple.Last;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Last;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.Last;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Last;<refinement>" title="Last extends shapeless.ops.tuple.Last[T]">Last</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L], implicit last: shapeless.ops.hlist.Last[L])shapeless.ops.tuple.Last.Aux[T,last.Out]" id="shapeless.ops.tuple.Last.last">last</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Last.last;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Last.last;L">L</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.Last.last.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Last[L]" id="shapeless.ops.tuple.Last.last.last">last</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Last" title="shapeless.ops.hlist.Last[L]">Last</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Last;<refinement>" title="shapeless.ops.tuple.Last.Aux[T,last.Out]">Aux</a><span class="delimiter">[</span>T, last.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.Last.last;$anon" title="shapeless.ops.tuple.Last[T]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Last[T]" id="shapeless.ops.tuple.Last.last;$anon">Last</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="last.Out" id="shapeless.ops.tuple.Last.last;$anon;Out">Out</a> = last.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="last.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T)this.Out" id="shapeless.ops.tuple.Last.last;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Last.last;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Last.last;T" title="T">T</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.Out">Out</a> = <a href="#shapeless.ops.tuple.Last.last.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: gen.Repr)shapeless.syntax.HListOps[gen.Repr]" class="delimiter">(</a><a href="#shapeless.ops.tuple.Last.last;$anon.apply.t" title="T">t</a><span class="delimiter">)</span>.<a href="../syntax/hlists.scala.html#shapeless.syntax;HListOps.last" title="(implicit last: shapeless.ops.hlist.Last[gen.Repr])last.Out">last</a>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting access to all but the last element of this tuple. Available only if this tuple has at
   * least one element.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Init[T] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;Init">Init</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Init;T">T</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Init.type" id="shapeless.ops.tuple.Init">Init</a> <a href="#shapeless.ops.tuple.Init" title="shapeless.ops.tuple.Init.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="Init[T, Out0] extends shapeless.ops.tuple.Init[T]" id="shapeless.ops.tuple.Init;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Init;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.Init;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Init;<refinement>" title="Init extends shapeless.ops.tuple.Init[T]">Init</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit init: shapeless.ops.hlist.Init.Aux[L1,L2], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.Init.Aux[T,tp.Out]" id="shapeless.ops.tuple.Init.init">init</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Init.init;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Init.init;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Init.init;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.Init.init.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Init.Aux[L1,L2]" id="shapeless.ops.tuple.Init.init.init">init</a>: hl.Init.<a href="hlists.scala.html#shapeless.ops.hlist.Init;<refinement>" title="shapeless.ops.hlist.Init.Aux[L1,L2]">Aux</a><span class="delimiter">[</span>L1, L2<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.Init.init.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Init;<refinement>" title="shapeless.ops.tuple.Init.Aux[T,tp.Out]">Aux</a><span class="delimiter">[</span>T, tp.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.Init.init;$anon" title="shapeless.ops.tuple.Init[T]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Init[T]" id="shapeless.ops.tuple.Init.init;$anon">Init</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.Init.init;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T)this.Out" id="shapeless.ops.tuple.Init.init;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Init.init;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Init.init;T" title="T">T</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L1)init.Out">init</a><a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: init.Out)shapeless.syntax.HListOps[init.Out]" class="delimiter">(</a><a href="#shapeless.ops.tuple.Init.init.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Init.init;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../syntax/hlists.scala.html#shapeless.syntax;HListOps.tupled" title="(implicit tupler: shapeless.ops.hlist.Tupler[init.Out])tupler.Out">tupled</a>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting access to the first element of this tuple of type `U`. Available only if this tuple
   * contains an element of type `U`.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Selector[T, U] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;Selector">Selector</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Selector;T">T</a>, <a title="" id="shapeless.ops.tuple;Selector;U">U</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> <a title="U" id="shapeless.ops.tuple;Selector;Out">Out</a> = <a href="#shapeless.ops.tuple;Selector;U" title="U">U</a> <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Selector.type" id="shapeless.ops.tuple.Selector">Selector</a> <a href="#shapeless.ops.tuple.Selector" title="shapeless.ops.tuple.Selector.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="[T, U]shapeless.ops.tuple.Selector[T,U]" id="shapeless.ops.tuple.Selector;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Selector;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.Selector;Aux;U">U</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple;Selector" title="shapeless.ops.tuple.Selector[T,U]">Selector</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, U](implicit gen: shapeless.Generic.Aux[T,L], implicit selector: shapeless.ops.hlist.Selector[L,U])shapeless.ops.tuple.Selector.Aux[T,U]" id="shapeless.ops.tuple.Selector.select">select</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Selector.select;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Selector.select;L">L</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.Selector.select;U">U</a><span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.Selector.select.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Selector[L,U]" id="shapeless.ops.tuple.Selector.select.selector">selector</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Selector" title="shapeless.ops.hlist.Selector[L,U]">Selector</a><span class="delimiter">[</span>L, U<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple;Selector" title="shapeless.ops.tuple.Selector.Aux[T,U]">Aux</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.Selector.select;$anon" title="shapeless.ops.tuple.Selector[T,U]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Selector[T,U]" id="shapeless.ops.tuple.Selector.select;$anon">Selector</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">def</span> <a title="(t: T)U" id="shapeless.ops.tuple.Selector.select;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Selector.select;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Selector.select;T" title="T">T</a><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Selector.select;U" title="U">U</a> = <a href="#shapeless.ops.tuple.Selector.select.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: gen.Repr)shapeless.syntax.HListOps[gen.Repr]" class="delimiter">(</a><a href="#shapeless.ops.tuple.Selector.select;$anon.apply.t" title="T">t</a><span class="delimiter">)</span>.<a href="../syntax/hlists.scala.html#shapeless.syntax;HListOps.select" title="[U](implicit selector: shapeless.ops.hlist.Selector[gen.Repr,U])U">select</a><a href="#shapeless.ops.tuple.Selector.select.selector" title="(implicit selector: shapeless.ops.hlist.Selector[gen.Repr,U])U" class="delimiter">[</a><a href="#shapeless.ops.tuple.Selector.select;U" title="U">U</a><span class="delimiter">]</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting access to the all elements of this tuple of type `U`.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Filter[T, U] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;Filter">Filter</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Filter;T">T</a>, <a title="" id="shapeless.ops.tuple;Filter;U">U</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Filter.type" id="shapeless.ops.tuple.Filter">Filter</a> <a href="#shapeless.ops.tuple.Filter" title="shapeless.ops.tuple.Filter.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="Filter[T, U, Out0] extends shapeless.ops.tuple.Filter[T,U]" id="shapeless.ops.tuple.Filter;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Filter;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.Filter;Aux;U">U</a>, <a title="" id="shapeless.ops.tuple.Filter;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Filter;<refinement>" title="Filter extends shapeless.ops.tuple.Filter[T,U]">Filter</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L1 &lt;: shapeless.HList, U, L2 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit filter: shapeless.ops.hlist.Filter.Aux[L1,U,L2], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.Filter.Aux[T,U,tp.Out]" id="shapeless.ops.tuple.Filter.filterTuple">filterTuple</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Filter.filterTuple;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Filter.filterTuple;L1">L1</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.Filter.filterTuple;U">U</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Filter.filterTuple;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.Filter.filterTuple.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Filter.Aux[L1,U,L2]" id="shapeless.ops.tuple.Filter.filterTuple.filter">filter</a>: hl.Filter.<a href="hlists.scala.html#shapeless.ops.hlist.Filter;<refinement>" title="shapeless.ops.hlist.Filter.Aux[L1,U,L2]">Aux</a><span class="delimiter">[</span>L1, U, L2<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.Filter.filterTuple.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Filter;<refinement>" title="shapeless.ops.tuple.Filter.Aux[T,U,tp.Out]">Aux</a><span class="delimiter">[</span>T, U, tp.Out<span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Filter.filterTuple;$anon" title="shapeless.ops.tuple.Filter[T,U]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Filter[T,U]" id="shapeless.ops.tuple.Filter.filterTuple;$anon">Filter</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.Filter.filterTuple;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
        <span class="keyword">def</span> <a title="(t: T)this.Out" id="shapeless.ops.tuple.Filter.filterTuple;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Filter.filterTuple;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Filter.filterTuple;T" title="T">T</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L2)tp.Out">tp</a><span class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L1)filter.Out">filter</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Filter.filterTuple.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Filter.filterTuple;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting access to the all elements of this tuple of type different than `U`.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait FilterNot[T, U] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;FilterNot">FilterNot</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;FilterNot;T">T</a>, <a title="" id="shapeless.ops.tuple;FilterNot;U">U</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.FilterNot.type" id="shapeless.ops.tuple.FilterNot">FilterNot</a> <a href="#shapeless.ops.tuple.FilterNot" title="shapeless.ops.tuple.FilterNot.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="FilterNot[T, U, Out0] extends shapeless.ops.tuple.FilterNot[T,U]" id="shapeless.ops.tuple.FilterNot;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.FilterNot;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.FilterNot;Aux;U">U</a>, <a title="" id="shapeless.ops.tuple.FilterNot;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.FilterNot;<refinement>" title="FilterNot extends shapeless.ops.tuple.FilterNot[T,U]">FilterNot</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L1 &lt;: shapeless.HList, U, L2 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit filterNot: shapeless.ops.hlist.FilterNot.Aux[L1,U,L2], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.FilterNot.Aux[T,U,tp.Out]" id="shapeless.ops.tuple.FilterNot.filterNotTuple">filterNotTuple</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.FilterNot.filterNotTuple;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.FilterNot.filterNotTuple;L1">L1</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.FilterNot.filterNotTuple;U">U</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.FilterNot.filterNotTuple;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.FilterNot.filterNotTuple.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.FilterNot.Aux[L1,U,L2]" id="shapeless.ops.tuple.FilterNot.filterNotTuple.filterNot">filterNot</a>: hl.FilterNot.<a href="hlists.scala.html#shapeless.ops.hlist.FilterNot;<refinement>" title="shapeless.ops.hlist.FilterNot.Aux[L1,U,L2]">Aux</a><span class="delimiter">[</span>L1, U, L2<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.FilterNot.filterNotTuple.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.FilterNot;<refinement>" title="shapeless.ops.tuple.FilterNot.Aux[T,U,tp.Out]">Aux</a><span class="delimiter">[</span>T, U, tp.Out<span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.FilterNot.filterNotTuple;$anon" title="shapeless.ops.tuple.FilterNot[T,U]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.FilterNot[T,U]" id="shapeless.ops.tuple.FilterNot.filterNotTuple;$anon">FilterNot</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.FilterNot.filterNotTuple;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
        <span class="keyword">def</span> <a title="(t: T)this.Out" id="shapeless.ops.tuple.FilterNot.filterNotTuple;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.FilterNot.filterNotTuple;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.FilterNot.filterNotTuple;T" title="T">T</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L2)tp.Out">tp</a><span class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L1)filterNot.Out">filterNot</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.FilterNot.filterNotTuple.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.FilterNot.filterNotTuple;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting removal of an element from this tuple. Available only if this tuple contains an
   * element of type `U`.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Remove[T, U] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;Remove">Remove</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Remove;T">T</a>, <a title="" id="shapeless.ops.tuple;Remove;U">U</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Remove.type" id="shapeless.ops.tuple.Remove">Remove</a> <a href="#shapeless.ops.tuple.Remove" title="shapeless.ops.tuple.Remove.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="Remove[T, U, Out0] extends shapeless.ops.tuple.Remove[T,U]" id="shapeless.ops.tuple.Remove;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Remove;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.Remove;Aux;U">U</a>, <a title="" id="shapeless.ops.tuple.Remove;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Remove;<refinement>" title="Remove extends shapeless.ops.tuple.Remove[T,U]">Remove</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L1 &lt;: shapeless.HList, U, L2 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit remove: shapeless.ops.hlist.Remove.Aux[L1,U,(U, L2)], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.Remove.Aux[T,U,(U, tp.Out)]" id="shapeless.ops.tuple.Remove.removeTuple">removeTuple</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Remove.removeTuple;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Remove.removeTuple;L1">L1</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.Remove.removeTuple;U">U</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Remove.removeTuple;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.Remove.removeTuple.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Remove.Aux[L1,U,(U, L2)]" id="shapeless.ops.tuple.Remove.removeTuple.remove">remove</a>: hl.Remove.<a href="hlists.scala.html#shapeless.ops.hlist.Remove;<refinement>" title="shapeless.ops.hlist.Remove.Aux[L1,U,(U, L2)]">Aux</a><span class="delimiter">[</span>L1, U, <span class="delimiter">(</span>U, L2<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.Remove.removeTuple.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Remove;<refinement>" title="shapeless.ops.tuple.Remove.Aux[T,U,(U, tp.Out)]">Aux</a><span class="delimiter">[</span>T, U, <span class="delimiter">(</span>U, tp.Out<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Remove.removeTuple;$anon" title="shapeless.ops.tuple.Remove[T,U]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Remove[T,U]" id="shapeless.ops.tuple.Remove.removeTuple;$anon">Remove</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">type</span> <a title="(U, tp.Out)" id="shapeless.ops.tuple.Remove.removeTuple;$anon;Out">Out</a> = <span title="(U, tp.Out)" class="delimiter">(</span>U, tp.Out<span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="(t: T)(U, tp.Out)" id="shapeless.ops.tuple.Remove.removeTuple;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Remove.removeTuple;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Remove.removeTuple;T" title="T">T</a><span class="delimiter">)</span>: <span title="(U, tp.Out)">Out</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a href="#shapeless.ops.tuple.Remove.removeTuple;$anon.apply.u" title="(U, L2)" class="delimiter">(</a><a href="#shapeless.ops.tuple.Remove.removeTuple;$anon.apply.x$1" title="U" id="shapeless.ops.tuple.Remove.removeTuple;$anon.apply.u">u</a>, <a href="#shapeless.ops.tuple.Remove.removeTuple;$anon.apply.x$1" title="L2" id="shapeless.ops.tuple.Remove.removeTuple;$anon.apply.rem">rem</a><span class="delimiter">)</span> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L1)(U, L2)">remove</a><span title="(U, L2) @unchecked" class="delimiter">(</span><a href="#shapeless.ops.tuple.Remove.removeTuple.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Remove.removeTuple;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span> ; <span title="(_1: U, _2: tp.Out)(U, tp.Out)" class="delimiter">(</span><a href="#shapeless.ops.tuple.Remove.removeTuple;$anon.apply.u" title="U">u</a>, <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L2)tp.Out">tp</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Remove.removeTuple;$anon.apply.rem" title="L2">rem</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting removal of a sublist from this tuple. Available only if this tuple contains a
   * sublist of type `SL`.
   *
   * The elements of `SL` do not have to be contiguous in this tuple.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait RemoveAll[T, S] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;RemoveAll">RemoveAll</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;RemoveAll;T">T</a>, <a title="" id="shapeless.ops.tuple;RemoveAll;S">S</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.RemoveAll.type" id="shapeless.ops.tuple.RemoveAll">RemoveAll</a> <a href="#shapeless.ops.tuple.RemoveAll" title="shapeless.ops.tuple.RemoveAll.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="RemoveAll[T, S, Out0] extends shapeless.ops.tuple.RemoveAll[T,S]" id="shapeless.ops.tuple.RemoveAll;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.RemoveAll;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.RemoveAll;Aux;S">S</a>, <a title="" id="shapeless.ops.tuple.RemoveAll;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.RemoveAll;<refinement>" title="RemoveAll extends shapeless.ops.tuple.RemoveAll[T,S]">RemoveAll</a><span class="delimiter">[</span>T, S<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, ST, SL &lt;: shapeless.HList, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList](implicit gent: shapeless.Generic.Aux[T,L1], implicit gens: shapeless.Generic.Aux[ST,SL], implicit removeAll: shapeless.ops.hlist.RemoveAll.Aux[L1,SL,(SL, L2)], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.RemoveAll.Aux[T,ST,(ST, tp.Out)]" id="shapeless.ops.tuple.RemoveAll.removeAllTuple">removeAllTuple</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.RemoveAll.removeAllTuple;T">T</a>, <a title="" id="shapeless.ops.tuple.RemoveAll.removeAllTuple;ST">ST</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.RemoveAll.removeAllTuple;SL">SL</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.RemoveAll.removeAllTuple;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.RemoveAll.removeAllTuple;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.RemoveAll.removeAllTuple.gent">gent</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.Generic.Aux[ST,SL]" id="shapeless.ops.tuple.RemoveAll.removeAllTuple.gens">gens</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[ST,SL]">Aux</a><span class="delimiter">[</span>ST, SL<span class="delimiter">]</span>,  <a title="shapeless.ops.hlist.RemoveAll.Aux[L1,SL,(SL, L2)]" id="shapeless.ops.tuple.RemoveAll.removeAllTuple.removeAll">removeAll</a>: hl.RemoveAll.<a href="hlists.scala.html#shapeless.ops.hlist.RemoveAll;<refinement>" title="shapeless.ops.hlist.RemoveAll.Aux[L1,SL,(SL, L2)]">Aux</a><span class="delimiter">[</span>L1, SL, <span class="delimiter">(</span>SL, L2<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.RemoveAll.removeAllTuple.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.RemoveAll;<refinement>" title="shapeless.ops.tuple.RemoveAll.Aux[T,ST,(ST, tp.Out)]">Aux</a><span class="delimiter">[</span>T, ST, <span class="delimiter">(</span>ST, tp.Out<span class="delimiter">)</span><span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.RemoveAll.removeAllTuple;$anon" title="shapeless.ops.tuple.RemoveAll[T,ST]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.RemoveAll[T,ST]" id="shapeless.ops.tuple.RemoveAll.removeAllTuple;$anon">RemoveAll</a><span class="delimiter">[</span>T, ST<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="(ST, tp.Out)" id="shapeless.ops.tuple.RemoveAll.removeAllTuple;$anon;Out">Out</a> = <span title="(ST, tp.Out)" class="delimiter">(</span>ST, tp.Out<span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(t: T)(ST, tp.Out)" id="shapeless.ops.tuple.RemoveAll.removeAllTuple;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.RemoveAll.removeAllTuple;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.RemoveAll.removeAllTuple;T" title="T">T</a><span class="delimiter">)</span>: <span title="(ST, tp.Out)">Out</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a href="#shapeless.ops.tuple.RemoveAll.removeAllTuple;$anon.apply.e" title="(SL, L2)" class="delimiter">(</a><a href="#shapeless.ops.tuple.RemoveAll.removeAllTuple;$anon.apply.x$2" title="SL" id="shapeless.ops.tuple.RemoveAll.removeAllTuple;$anon.apply.e">e</a>, <a href="#shapeless.ops.tuple.RemoveAll.removeAllTuple;$anon.apply.x$2" title="L2" id="shapeless.ops.tuple.RemoveAll.removeAllTuple;$anon.apply.rem">rem</a><span class="delimiter">)</span> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L1)(SL, L2)">removeAll</a><span title="(SL, L2) @unchecked" class="delimiter">(</span><a href="#shapeless.ops.tuple.RemoveAll.removeAllTuple.gent" title="shapeless.Generic.Aux[T,L1]">gent</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gent.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.RemoveAll.removeAllTuple;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span> ; <span title="(_1: ST, _2: tp.Out)(ST, tp.Out)" class="delimiter">(</span><a href="#shapeless.ops.tuple.RemoveAll.removeAllTuple.gens" title="shapeless.Generic.Aux[ST,SL]">gens</a>.<a href="../generic.scala.html#shapeless;Generic.from" title="(r: gens.Repr)ST">from</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.RemoveAll.removeAllTuple;$anon.apply.e" title="SL">e</a><span class="delimiter">)</span>, <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L2)tp.Out">tp</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.RemoveAll.removeAllTuple;$anon.apply.rem" title="L2">rem</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting replacement of the first element of type U from this tuple with an element of type V.
   * Available only if this tuple contains an element of type `U`.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Replacer[T, U, V] extends AnyRef with shapeless.DepFn2[T,U]" id="shapeless.ops.tuple;Replacer">Replacer</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Replacer;T">T</a>, <a title="" id="shapeless.ops.tuple;Replacer;U">U</a>, <a title="" id="shapeless.ops.tuple;Replacer;V">V</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn2" title="shapeless.DepFn2[T,U]">DepFn2</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Replacer.type" id="shapeless.ops.tuple.Replacer">Replacer</a> <a href="#shapeless.ops.tuple.Replacer" title="shapeless.ops.tuple.Replacer.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="Replacer[T, U, V, Out0] extends shapeless.ops.tuple.Replacer[T,U,V]" id="shapeless.ops.tuple.Replacer;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Replacer;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.Replacer;Aux;U">U</a>, <a title="" id="shapeless.ops.tuple.Replacer;Aux;V">V</a>, <a title="" id="shapeless.ops.tuple.Replacer;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Replacer;<refinement>" title="Replacer extends shapeless.ops.tuple.Replacer[T,U,V]">Replacer</a><span class="delimiter">[</span>T, U, V<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L1 &lt;: shapeless.HList, U, V, L2 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit replace: shapeless.ops.hlist.Replacer.Aux[L1,V,U,(V, L2)], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.Replacer.Aux[T,U,V,(V, tp.Out)]" id="shapeless.ops.tuple.Replacer.replaceTuple">replaceTuple</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Replacer.replaceTuple;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Replacer.replaceTuple;L1">L1</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.Replacer.replaceTuple;U">U</a>, <a title="" id="shapeless.ops.tuple.Replacer.replaceTuple;V">V</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Replacer.replaceTuple;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.Replacer.replaceTuple.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Replacer.Aux[L1,V,U,(V, L2)]" id="shapeless.ops.tuple.Replacer.replaceTuple.replace">replace</a>: hl.Replacer.<a href="hlists.scala.html#shapeless.ops.hlist.Replacer;<refinement>" title="shapeless.ops.hlist.Replacer.Aux[L1,V,U,(V, L2)]">Aux</a><span class="delimiter">[</span>L1, V, U, <span class="delimiter">(</span>V, L2<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.Replacer.replaceTuple.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Replacer;<refinement>" title="shapeless.ops.tuple.Replacer.Aux[T,U,V,(V, tp.Out)]">Aux</a><span class="delimiter">[</span>T, U, V, <span class="delimiter">(</span>V, tp.Out<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Replacer.replaceTuple;$anon" title="shapeless.ops.tuple.Replacer[T,U,V]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Replacer[T,U,V]" id="shapeless.ops.tuple.Replacer.replaceTuple;$anon">Replacer</a><span class="delimiter">[</span>T, U, V<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">type</span> <a title="(V, tp.Out)" id="shapeless.ops.tuple.Replacer.replaceTuple;$anon;Out">Out</a> = <span title="(V, tp.Out)" class="delimiter">(</span>V, tp.Out<span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="(t: T, u: U)(V, tp.Out)" id="shapeless.ops.tuple.Replacer.replaceTuple;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Replacer.replaceTuple;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Replacer.replaceTuple;T" title="T">T</a>, <a title="U" id="shapeless.ops.tuple.Replacer.replaceTuple;$anon.apply.u">u</a>: <a href="#shapeless.ops.tuple.Replacer.replaceTuple;U" title="U">U</a><span class="delimiter">)</span>: <span title="(V, tp.Out)">Out</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a href="#shapeless.ops.tuple.Replacer.replaceTuple;$anon.apply.v" title="(V, L2)" class="delimiter">(</a><a href="#shapeless.ops.tuple.Replacer.replaceTuple;$anon.apply.x$3" title="V" id="shapeless.ops.tuple.Replacer.replaceTuple;$anon.apply.v">v</a>, <a href="#shapeless.ops.tuple.Replacer.replaceTuple;$anon.apply.x$3" title="L2" id="shapeless.ops.tuple.Replacer.replaceTuple;$anon.apply.rep">rep</a><span class="delimiter">)</span> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L1, u: U)(V, L2)">replace</a><span title="(V, L2) @unchecked" class="delimiter">(</span><a href="#shapeless.ops.tuple.Replacer.replaceTuple.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Replacer.replaceTuple;$anon.apply.t" title="T">t</a><span class="delimiter">)</span>, <a href="#shapeless.ops.tuple.Replacer.replaceTuple;$anon.apply.u" title="U">u</a><span class="delimiter">)</span> ; <span title="(_1: V, _2: tp.Out)(V, tp.Out)" class="delimiter">(</span><a href="#shapeless.ops.tuple.Replacer.replaceTuple;$anon.apply.v" title="V">v</a>, <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L2)tp.Out">tp</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Replacer.replaceTuple;$anon.apply.rep" title="L2">rep</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting replacement of the Nth element of this tuple with an element of type V. Available only if
   * this tuple contains at least N elements.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait ReplaceAt[T, N &lt;: shapeless.Nat, U] extends AnyRef with shapeless.DepFn2[T,U]" id="shapeless.ops.tuple;ReplaceAt">ReplaceAt</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;ReplaceAt;T">T</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple;ReplaceAt;N">N</a> &lt;: Nat, <a title="" id="shapeless.ops.tuple;ReplaceAt;U">U</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn2" title="shapeless.DepFn2[T,U]">DepFn2</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.ReplaceAt.type" id="shapeless.ops.tuple.ReplaceAt">ReplaceAt</a> <a href="#shapeless.ops.tuple.ReplaceAt" title="shapeless.ops.tuple.ReplaceAt.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="ReplaceAt[T, N &lt;: shapeless.Nat, U, Out0] extends shapeless.ops.tuple.ReplaceAt[T,N,U]" id="shapeless.ops.tuple.ReplaceAt;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ReplaceAt;Aux;T">T</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple.ReplaceAt;Aux;N">N</a> &lt;: Nat, <a title="" id="shapeless.ops.tuple.ReplaceAt;Aux;U">U</a>, <a title="" id="shapeless.ops.tuple.ReplaceAt;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.ReplaceAt;<refinement>" title="ReplaceAt extends shapeless.ops.tuple.ReplaceAt[T,N,U]">ReplaceAt</a><span class="delimiter">[</span>T, N, U<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L1 &lt;: shapeless.HList, N &lt;: shapeless.Nat, U, V, L2 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit replaceAt: shapeless.ops.hlist.ReplaceAt.Aux[L1,N,U,(V, L2)], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.ReplaceAt.Aux[T,N,U,(V, tp.Out)]" id="shapeless.ops.tuple.ReplaceAt.replaceTuple">replaceTuple</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ReplaceAt.replaceTuple;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ReplaceAt.replaceTuple;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple.ReplaceAt.replaceTuple;N">N</a> &lt;: Nat, <a title="" id="shapeless.ops.tuple.ReplaceAt.replaceTuple;U">U</a>, <a title="" id="shapeless.ops.tuple.ReplaceAt.replaceTuple;V">V</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ReplaceAt.replaceTuple;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.ReplaceAt.replaceTuple.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ReplaceAt.Aux[L1,N,U,(V, L2)]" id="shapeless.ops.tuple.ReplaceAt.replaceTuple.replaceAt">replaceAt</a>: hl.ReplaceAt.<a href="hlists.scala.html#shapeless.ops.hlist.ReplaceAt;<refinement>" title="shapeless.ops.hlist.ReplaceAt.Aux[L1,N,U,(V, L2)]">Aux</a><span class="delimiter">[</span>L1, N, U, <span class="delimiter">(</span>V, L2<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.ReplaceAt.replaceTuple.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.ReplaceAt;<refinement>" title="shapeless.ops.tuple.ReplaceAt.Aux[T,N,U,(V, tp.Out)]">Aux</a><span class="delimiter">[</span>T, N, U, <span class="delimiter">(</span>V, tp.Out<span class="delimiter">)</span><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon" title="shapeless.ops.tuple.ReplaceAt[T,N,U]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.ReplaceAt[T,N,U]" id="shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon">ReplaceAt</a><span class="delimiter">[</span>T, N, U<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">type</span> <a title="(V, tp.Out)" id="shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon;Out">Out</a> = <span title="(V, tp.Out)" class="delimiter">(</span>V, tp.Out<span class="delimiter">)</span>
        <span class="keyword">def</span> <a title="(t: T, u: U)(V, tp.Out)" id="shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.ReplaceAt.replaceTuple;T" title="T">T</a>, <a title="U" id="shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon.apply.u">u</a>: <a href="#shapeless.ops.tuple.ReplaceAt.replaceTuple;U" title="U">U</a><span class="delimiter">)</span>: <span title="(V, tp.Out)">Out</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a href="#shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon.apply.v" title="(V, L2)" class="delimiter">(</a><a href="#shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon.apply.x$4" title="V" id="shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon.apply.v">v</a>, <a href="#shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon.apply.x$4" title="L2" id="shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon.apply.rep">rep</a><span class="delimiter">)</span> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L1, u: U)(V, L2)">replaceAt</a><span title="(V, L2) @unchecked" class="delimiter">(</span><a href="#shapeless.ops.tuple.ReplaceAt.replaceTuple.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon.apply.t" title="T">t</a><span class="delimiter">)</span>, <a href="#shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon.apply.u" title="U">u</a><span class="delimiter">)</span> ; <span title="(_1: V, _2: tp.Out)(V, tp.Out)" class="delimiter">(</span><a href="#shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon.apply.v" title="V">v</a>, <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L2)tp.Out">tp</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ReplaceAt.replaceTuple;$anon.apply.rep" title="L2">rep</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting retrieval of the first ''n'' elements of this tuple. Available only if this tuple has at
   * least ''n'' elements.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Take[T, N &lt;: shapeless.Nat] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;Take">Take</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Take;T">T</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple;Take;N">N</a> &lt;: Nat<span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Take.type" id="shapeless.ops.tuple.Take">Take</a> <a href="#shapeless.ops.tuple.Take" title="shapeless.ops.tuple.Take.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="Take[T, N &lt;: shapeless.Nat, Out0] extends shapeless.ops.tuple.Take[T,N]" id="shapeless.ops.tuple.Take;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Take;Aux;T">T</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple.Take;Aux;N">N</a> &lt;: Nat, <a title="" id="shapeless.ops.tuple.Take;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Take;<refinement>" title="Take extends shapeless.ops.tuple.Take[T,N]">Take</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L1 &lt;: shapeless.HList, N &lt;: shapeless.Nat, L2 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit take: shapeless.ops.hlist.Take.Aux[L1,N,L2], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.Take.Aux[T,N,tp.Out]" id="shapeless.ops.tuple.Take.tupleTake">tupleTake</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Take.tupleTake;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Take.tupleTake;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple.Take.tupleTake;N">N</a> &lt;: Nat, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Take.tupleTake;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.Take.tupleTake.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Take.Aux[L1,N,L2]" id="shapeless.ops.tuple.Take.tupleTake.take">take</a>: hl.Take.<a href="hlists.scala.html#shapeless.ops.hlist.Take;<refinement>" title="shapeless.ops.hlist.Take.Aux[L1,N,L2]">Aux</a><span class="delimiter">[</span>L1, N, L2<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.Take.tupleTake.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Take;<refinement>" title="shapeless.ops.tuple.Take.Aux[T,N,tp.Out]">Aux</a><span class="delimiter">[</span>T, N, tp.Out<span class="delimiter">]</span> = 
        <a href="#shapeless.ops.tuple.Take.tupleTake;$anon" title="shapeless.ops.tuple.Take[T,N]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Take[T,N]" id="shapeless.ops.tuple.Take.tupleTake;$anon">Take</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.Take.tupleTake;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T)tp.Out" id="shapeless.ops.tuple.Take.tupleTake;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Take.tupleTake;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Take.tupleTake;T" title="T">T</a><span class="delimiter">)</span>: tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L2)tp.Out">tp</a><span class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L1)take.Out">take</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Take.tupleTake.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Take.tupleTake;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting removal of the first ''n'' elements of this tuple. Available only if this tuple has at
   * least ''n'' elements.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Drop[T, N &lt;: shapeless.Nat] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;Drop">Drop</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Drop;T">T</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple;Drop;N">N</a> &lt;: Nat<span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Drop.type" id="shapeless.ops.tuple.Drop">Drop</a> <a href="#shapeless.ops.tuple.Drop" title="shapeless.ops.tuple.Drop.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="Drop[T, N &lt;: shapeless.Nat, Out0] extends shapeless.ops.tuple.Drop[T,N]" id="shapeless.ops.tuple.Drop;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Drop;Aux;T">T</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple.Drop;Aux;N">N</a> &lt;: Nat, <a title="" id="shapeless.ops.tuple.Drop;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Drop;<refinement>" title="Drop extends shapeless.ops.tuple.Drop[T,N]">Drop</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L1 &lt;: shapeless.HList, N &lt;: shapeless.Nat, L2 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit drop: shapeless.ops.hlist.Drop.Aux[L1,N,L2], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.Drop.Aux[T,N,tp.Out]" id="shapeless.ops.tuple.Drop.tupleDrop">tupleDrop</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Drop.tupleDrop;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Drop.tupleDrop;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple.Drop.tupleDrop;N">N</a> &lt;: Nat, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Drop.tupleDrop;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.Drop.tupleDrop.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Drop.Aux[L1,N,L2]" id="shapeless.ops.tuple.Drop.tupleDrop.drop">drop</a>: hl.Drop.<a href="hlists.scala.html#shapeless.ops.hlist.Drop;<refinement>" title="shapeless.ops.hlist.Drop.Aux[L1,N,L2]">Aux</a><span class="delimiter">[</span>L1, N, L2<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.Drop.tupleDrop.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Drop;<refinement>" title="shapeless.ops.tuple.Drop.Aux[T,N,tp.Out]">Aux</a><span class="delimiter">[</span>T, N, tp.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.Drop.tupleDrop;$anon" title="shapeless.ops.tuple.Drop[T,N]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Drop[T,N]" id="shapeless.ops.tuple.Drop.tupleDrop;$anon">Drop</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.Drop.tupleDrop;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T)tp.Out" id="shapeless.ops.tuple.Drop.tupleDrop;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Drop.tupleDrop;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Drop.tupleDrop;T" title="T">T</a><span class="delimiter">)</span>: tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L2)tp.Out">tp</a><span class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L1)drop.Out">drop</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Drop.tupleDrop.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Drop.tupleDrop;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting splitting this tuple at the ''nth'' element returning the prefix and suffix as a pair.
   * Available only if this tuple has at least ''n'' elements.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Split[T, N &lt;: shapeless.Nat] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;Split">Split</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Split;T">T</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple;Split;N">N</a> &lt;: Nat<span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Split.type" id="shapeless.ops.tuple.Split">Split</a> <a href="#shapeless.ops.tuple.Split" title="shapeless.ops.tuple.Split.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="Split[T, N &lt;: shapeless.Nat, Out0] extends shapeless.ops.tuple.Split[T,N]" id="shapeless.ops.tuple.Split;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Split;Aux;T">T</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple.Split;Aux;N">N</a> &lt;: Nat, <a title="" id="shapeless.ops.tuple.Split;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Split;<refinement>" title="Split extends shapeless.ops.tuple.Split[T,N]">Split</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, N &lt;: shapeless.Nat, LP &lt;: shapeless.HList, LS &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L], implicit split: shapeless.ops.hlist.Split.Aux[L,N,(LP, LS)], implicit tpp: shapeless.ops.hlist.Tupler[LP], implicit tps: shapeless.ops.hlist.Tupler[LS])shapeless.ops.tuple.Split.Aux[T,N,(tpp.Out, tps.Out)]" id="shapeless.ops.tuple.Split.tupleSplit">tupleSplit</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Split.tupleSplit;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Split.tupleSplit;L">L</a> &lt;: HList, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple.Split.tupleSplit;N">N</a> &lt;: Nat, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Split.tupleSplit;LP">LP</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Split.tupleSplit;LS">LS</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.Split.tupleSplit.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Split.Aux[L,N,(LP, LS)]" id="shapeless.ops.tuple.Split.tupleSplit.split">split</a>: hl.Split.<a href="hlists.scala.html#shapeless.ops.hlist.Split;<refinement>" title="shapeless.ops.hlist.Split.Aux[L,N,(LP, LS)]">Aux</a><span class="delimiter">[</span>L, N, <span class="delimiter">(</span>LP, LS<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[LP]" id="shapeless.ops.tuple.Split.tupleSplit.tpp">tpp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[LP]">Tupler</a><span class="delimiter">[</span>LP<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[LS]" id="shapeless.ops.tuple.Split.tupleSplit.tps">tps</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[LS]">Tupler</a><span class="delimiter">[</span>LS<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Split;<refinement>" title="shapeless.ops.tuple.Split.Aux[T,N,(tpp.Out, tps.Out)]">Aux</a><span class="delimiter">[</span>T, N, <span class="delimiter">(</span>tpp.Out, tps.Out<span class="delimiter">)</span><span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.Split.tupleSplit;$anon" title="shapeless.ops.tuple.Split[T,N]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Split[T,N]" id="shapeless.ops.tuple.Split.tupleSplit;$anon">Split</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="(tpp.Out, tps.Out)" id="shapeless.ops.tuple.Split.tupleSplit;$anon;Out">Out</a> = <span title="(tpp.Out, tps.Out)" class="delimiter">(</span>tpp.Out, tps.Out<span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(t: T)(tpp.Out, tps.Out)" id="shapeless.ops.tuple.Split.tupleSplit;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Split.tupleSplit;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Split.tupleSplit;T" title="T">T</a><span class="delimiter">)</span>: <span title="(tpp.Out, tps.Out)">Out</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a href="#shapeless.ops.tuple.Split.tupleSplit;$anon.apply.p" title="(LP, LS)" class="delimiter">(</a><a href="#shapeless.ops.tuple.Split.tupleSplit;$anon.apply.x$5" title="LP" id="shapeless.ops.tuple.Split.tupleSplit;$anon.apply.p">p</a>, <a href="#shapeless.ops.tuple.Split.tupleSplit;$anon.apply.x$5" title="LS" id="shapeless.ops.tuple.Split.tupleSplit;$anon.apply.s">s</a><span class="delimiter">)</span> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)(LP, LS)">split</a><span title="(LP, LS) @unchecked" class="delimiter">(</span><a href="#shapeless.ops.tuple.Split.tupleSplit.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Split.tupleSplit;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span> ; <span title="(_1: tpp.Out, _2: tps.Out)(tpp.Out, tps.Out)" class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: LP)tpp.Out">tpp</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Split.tupleSplit;$anon.apply.p" title="LP">p</a><span class="delimiter">)</span>, <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: LS)tps.Out">tps</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Split.tupleSplit;$anon.apply.s" title="LS">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting splitting this tuple at the ''nth'' element returning the reverse prefix and suffix as a
   * pair. Available only if this tuple has at least ''n'' elements.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait ReverseSplit[T, N &lt;: shapeless.Nat] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;ReverseSplit">ReverseSplit</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;ReverseSplit;T">T</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple;ReverseSplit;N">N</a> &lt;: Nat<span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.ReverseSplit.type" id="shapeless.ops.tuple.ReverseSplit">ReverseSplit</a> <a href="#shapeless.ops.tuple.ReverseSplit" title="shapeless.ops.tuple.ReverseSplit.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="ReverseSplit[T, N &lt;: shapeless.Nat, Out0] extends shapeless.ops.tuple.ReverseSplit[T,N]" id="shapeless.ops.tuple.ReverseSplit;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ReverseSplit;Aux;T">T</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple.ReverseSplit;Aux;N">N</a> &lt;: Nat, <a title="" id="shapeless.ops.tuple.ReverseSplit;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.ReverseSplit;<refinement>" title="ReverseSplit extends shapeless.ops.tuple.ReverseSplit[T,N]">ReverseSplit</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, N &lt;: shapeless.Nat, LP &lt;: shapeless.HList, LS &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L], implicit split: shapeless.ops.hlist.ReverseSplit.Aux[L,N,(LP, LS)], implicit tpp: shapeless.ops.hlist.Tupler[LP], implicit tps: shapeless.ops.hlist.Tupler[LS])shapeless.ops.tuple.ReverseSplit.Aux[T,N,(tpp.Out, tps.Out)]" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit">tupleReverseSplit</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;L">L</a> &lt;: HList, <a title=" &lt;: shapeless.Nat" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;N">N</a> &lt;: Nat, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;LP">LP</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;LS">LS</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ReverseSplit.Aux[L,N,(LP, LS)]" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit.split">split</a>: hl.ReverseSplit.<a href="hlists.scala.html#shapeless.ops.hlist.ReverseSplit;<refinement>" title="shapeless.ops.hlist.ReverseSplit.Aux[L,N,(LP, LS)]">Aux</a><span class="delimiter">[</span>L, N, <span class="delimiter">(</span>LP, LS<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[LP]" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit.tpp">tpp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[LP]">Tupler</a><span class="delimiter">[</span>LP<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[LS]" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit.tps">tps</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[LS]">Tupler</a><span class="delimiter">[</span>LS<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.ReverseSplit;<refinement>" title="shapeless.ops.tuple.ReverseSplit.Aux[T,N,(tpp.Out, tps.Out)]">Aux</a><span class="delimiter">[</span>T, N, <span class="delimiter">(</span>tpp.Out, tps.Out<span class="delimiter">)</span><span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;$anon" title="shapeless.ops.tuple.ReverseSplit[T,N]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.ReverseSplit[T,N]" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;$anon">ReverseSplit</a><span class="delimiter">[</span>T, N<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="(tpp.Out, tps.Out)" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;$anon;Out">Out</a> = <span title="(tpp.Out, tps.Out)" class="delimiter">(</span>tpp.Out, tps.Out<span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(t: T)(tpp.Out, tps.Out)" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;T" title="T">T</a><span class="delimiter">)</span>: <span title="(tpp.Out, tps.Out)">Out</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a href="#shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;$anon.apply.p" title="(LP, LS)" class="delimiter">(</a><a href="#shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;$anon.apply.x$6" title="LP" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;$anon.apply.p">p</a>, <a href="#shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;$anon.apply.x$6" title="LS" id="shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;$anon.apply.s">s</a><span class="delimiter">)</span> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)(LP, LS)">split</a><span title="(LP, LS) @unchecked" class="delimiter">(</span><a href="#shapeless.ops.tuple.ReverseSplit.tupleReverseSplit.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span> ; <span title="(_1: tpp.Out, _2: tps.Out)(tpp.Out, tps.Out)" class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: LP)tpp.Out">tpp</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;$anon.apply.p" title="LP">p</a><span class="delimiter">)</span>, <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: LS)tps.Out">tps</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ReverseSplit.tupleReverseSplit;$anon.apply.s" title="LS">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting splitting this tuple at the first occurence of an element of type `U` returning the prefix
   * and suffix as a pair. Available only if this tuple contains an element of type `U`.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait SplitLeft[T, U] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;SplitLeft">SplitLeft</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;SplitLeft;T">T</a>, <a title="" id="shapeless.ops.tuple;SplitLeft;U">U</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.SplitLeft.type" id="shapeless.ops.tuple.SplitLeft">SplitLeft</a> <a href="#shapeless.ops.tuple.SplitLeft" title="shapeless.ops.tuple.SplitLeft.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="SplitLeft[T, U, Out0] extends shapeless.ops.tuple.SplitLeft[T,U]" id="shapeless.ops.tuple.SplitLeft;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.SplitLeft;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.SplitLeft;Aux;U">U</a>, <a title="" id="shapeless.ops.tuple.SplitLeft;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.SplitLeft;<refinement>" title="SplitLeft extends shapeless.ops.tuple.SplitLeft[T,U]">SplitLeft</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, U, LP &lt;: shapeless.HList, LS &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L], implicit split: shapeless.ops.hlist.SplitLeft.Aux[L,U,(LP, LS)], implicit tpp: shapeless.ops.hlist.Tupler[LP], implicit tps: shapeless.ops.hlist.Tupler[LS])shapeless.ops.tuple.SplitLeft.Aux[T,U,(tpp.Out, tps.Out)]" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft">tupleSplitLeft</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft;L">L</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft;U">U</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft;LP">LP</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft;LS">LS</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.SplitLeft.Aux[L,U,(LP, LS)]" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft.split">split</a>: hl.SplitLeft.<a href="hlists.scala.html#shapeless.ops.hlist.SplitLeft;<refinement>" title="shapeless.ops.hlist.SplitLeft.Aux[L,U,(LP, LS)]">Aux</a><span class="delimiter">[</span>L, U, <span class="delimiter">(</span>LP, LS<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[LP]" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft.tpp">tpp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[LP]">Tupler</a><span class="delimiter">[</span>LP<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[LS]" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft.tps">tps</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[LS]">Tupler</a><span class="delimiter">[</span>LS<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.SplitLeft;<refinement>" title="shapeless.ops.tuple.SplitLeft.Aux[T,U,(tpp.Out, tps.Out)]">Aux</a><span class="delimiter">[</span>T, U, <span class="delimiter">(</span>tpp.Out, tps.Out<span class="delimiter">)</span><span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.SplitLeft.tupleSplitLeft;$anon" title="shapeless.ops.tuple.SplitLeft[T,U]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.SplitLeft[T,U]" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft;$anon">SplitLeft</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="(tpp.Out, tps.Out)" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft;$anon;Out">Out</a> = <span title="(tpp.Out, tps.Out)" class="delimiter">(</span>tpp.Out, tps.Out<span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(t: T)(tpp.Out, tps.Out)" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.SplitLeft.tupleSplitLeft;T" title="T">T</a><span class="delimiter">)</span>: <span title="(tpp.Out, tps.Out)">Out</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a href="#shapeless.ops.tuple.SplitLeft.tupleSplitLeft;$anon.apply.p" title="(LP, LS)" class="delimiter">(</a><a href="#shapeless.ops.tuple.SplitLeft.tupleSplitLeft;$anon.apply.x$7" title="LP" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft;$anon.apply.p">p</a>, <a href="#shapeless.ops.tuple.SplitLeft.tupleSplitLeft;$anon.apply.x$7" title="LS" id="shapeless.ops.tuple.SplitLeft.tupleSplitLeft;$anon.apply.s">s</a><span class="delimiter">)</span> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)(LP, LS)">split</a><span title="(LP, LS) @unchecked" class="delimiter">(</span><a href="#shapeless.ops.tuple.SplitLeft.tupleSplitLeft.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.SplitLeft.tupleSplitLeft;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span> ; <span title="(_1: tpp.Out, _2: tps.Out)(tpp.Out, tps.Out)" class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: LP)tpp.Out">tpp</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.SplitLeft.tupleSplitLeft;$anon.apply.p" title="LP">p</a><span class="delimiter">)</span>, <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: LS)tps.Out">tps</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.SplitLeft.tupleSplitLeft;$anon.apply.s" title="LS">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting splitting this tuple at the first occurence of an element of type `U` returning the reverse
   * prefix and suffix as a pair. Available only if this tuple contains an element of type `U`.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait ReverseSplitLeft[T, U] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;ReverseSplitLeft">ReverseSplitLeft</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;ReverseSplitLeft;T">T</a>, <a title="" id="shapeless.ops.tuple;ReverseSplitLeft;U">U</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.ReverseSplitLeft.type" id="shapeless.ops.tuple.ReverseSplitLeft">ReverseSplitLeft</a> <a href="#shapeless.ops.tuple.ReverseSplitLeft" title="shapeless.ops.tuple.ReverseSplitLeft.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="ReverseSplitLeft[T, U, Out0] extends shapeless.ops.tuple.ReverseSplitLeft[T,U]" id="shapeless.ops.tuple.ReverseSplitLeft;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ReverseSplitLeft;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.ReverseSplitLeft;Aux;U">U</a>, <a title="" id="shapeless.ops.tuple.ReverseSplitLeft;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.ReverseSplitLeft;<refinement>" title="ReverseSplitLeft extends shapeless.ops.tuple.ReverseSplitLeft[T,U]">ReverseSplitLeft</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, U, LP &lt;: shapeless.HList, LS &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L], implicit split: shapeless.ops.hlist.ReverseSplitLeft.Aux[L,U,(LP, LS)], implicit tpp: shapeless.ops.hlist.Tupler[LP], implicit tps: shapeless.ops.hlist.Tupler[LS])shapeless.ops.tuple.ReverseSplitLeft.Aux[T,U,(tpp.Out, tps.Out)]" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft">tupleReverseSplitLeft</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;L">L</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;U">U</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;LP">LP</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;LS">LS</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ReverseSplitLeft.Aux[L,U,(LP, LS)]" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft.split">split</a>: hl.ReverseSplitLeft.<a href="hlists.scala.html#shapeless.ops.hlist.ReverseSplitLeft;<refinement>" title="shapeless.ops.hlist.ReverseSplitLeft.Aux[L,U,(LP, LS)]">Aux</a><span class="delimiter">[</span>L, U, <span class="delimiter">(</span>LP, LS<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[LP]" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft.tpp">tpp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[LP]">Tupler</a><span class="delimiter">[</span>LP<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[LS]" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft.tps">tps</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[LS]">Tupler</a><span class="delimiter">[</span>LS<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.ReverseSplitLeft;<refinement>" title="shapeless.ops.tuple.ReverseSplitLeft.Aux[T,U,(tpp.Out, tps.Out)]">Aux</a><span class="delimiter">[</span>T, U, <span class="delimiter">(</span>tpp.Out, tps.Out<span class="delimiter">)</span><span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;$anon" title="shapeless.ops.tuple.ReverseSplitLeft[T,U]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.ReverseSplitLeft[T,U]" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;$anon">ReverseSplitLeft</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="(tpp.Out, tps.Out)" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;$anon;Out">Out</a> = <span title="(tpp.Out, tps.Out)" class="delimiter">(</span>tpp.Out, tps.Out<span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(t: T)(tpp.Out, tps.Out)" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;T" title="T">T</a><span class="delimiter">)</span>: <span title="(tpp.Out, tps.Out)">Out</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a href="#shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;$anon.apply.p" title="(LP, LS)" class="delimiter">(</a><a href="#shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;$anon.apply.x$8" title="LP" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;$anon.apply.p">p</a>, <a href="#shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;$anon.apply.x$8" title="LS" id="shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;$anon.apply.s">s</a><span class="delimiter">)</span> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)(LP, LS)">split</a><span title="(LP, LS) @unchecked" class="delimiter">(</span><a href="#shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span> ; <span title="(_1: tpp.Out, _2: tps.Out)(tpp.Out, tps.Out)" class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: LP)tpp.Out">tpp</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;$anon.apply.p" title="LP">p</a><span class="delimiter">)</span>, <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: LS)tps.Out">tps</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ReverseSplitLeft.tupleReverseSplitLeft;$anon.apply.s" title="LS">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting splitting this tuple at the last occurence of an element of type `U` returning the prefix
   * and suffix as a pair. Available only if this tuple contains an element of type `U`.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait SplitRight[T, U] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;SplitRight">SplitRight</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;SplitRight;T">T</a>, <a title="" id="shapeless.ops.tuple;SplitRight;U">U</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.SplitRight.type" id="shapeless.ops.tuple.SplitRight">SplitRight</a> <a href="#shapeless.ops.tuple.SplitRight" title="shapeless.ops.tuple.SplitRight.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="SplitRight[T, U, Out0] extends shapeless.ops.tuple.SplitRight[T,U]" id="shapeless.ops.tuple.SplitRight;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.SplitRight;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.SplitRight;Aux;U">U</a>, <a title="" id="shapeless.ops.tuple.SplitRight;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.SplitRight;<refinement>" title="SplitRight extends shapeless.ops.tuple.SplitRight[T,U]">SplitRight</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, U, LP &lt;: shapeless.HList, LS &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L], implicit split: shapeless.ops.hlist.SplitRight.Aux[L,U,(LP, LS)], implicit tpp: shapeless.ops.hlist.Tupler[LP], implicit tps: shapeless.ops.hlist.Tupler[LS])shapeless.ops.tuple.SplitRight.Aux[T,U,(tpp.Out, tps.Out)]" id="shapeless.ops.tuple.SplitRight.tupleSplitRight">tupleSplitRight</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.SplitRight.tupleSplitRight;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.SplitRight.tupleSplitRight;L">L</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.SplitRight.tupleSplitRight;U">U</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.SplitRight.tupleSplitRight;LP">LP</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.SplitRight.tupleSplitRight;LS">LS</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.SplitRight.tupleSplitRight.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.SplitRight.Aux[L,U,(LP, LS)]" id="shapeless.ops.tuple.SplitRight.tupleSplitRight.split">split</a>: hl.SplitRight.<a href="hlists.scala.html#shapeless.ops.hlist.SplitRight;<refinement>" title="shapeless.ops.hlist.SplitRight.Aux[L,U,(LP, LS)]">Aux</a><span class="delimiter">[</span>L, U, <span class="delimiter">(</span>LP, LS<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[LP]" id="shapeless.ops.tuple.SplitRight.tupleSplitRight.tpp">tpp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[LP]">Tupler</a><span class="delimiter">[</span>LP<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[LS]" id="shapeless.ops.tuple.SplitRight.tupleSplitRight.tps">tps</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[LS]">Tupler</a><span class="delimiter">[</span>LS<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.SplitRight;<refinement>" title="shapeless.ops.tuple.SplitRight.Aux[T,U,(tpp.Out, tps.Out)]">Aux</a><span class="delimiter">[</span>T, U, <span class="delimiter">(</span>tpp.Out, tps.Out<span class="delimiter">)</span><span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.SplitRight.tupleSplitRight;$anon" title="shapeless.ops.tuple.SplitRight[T,U]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.SplitRight[T,U]" id="shapeless.ops.tuple.SplitRight.tupleSplitRight;$anon">SplitRight</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="(tpp.Out, tps.Out)" id="shapeless.ops.tuple.SplitRight.tupleSplitRight;$anon;Out">Out</a> = <span title="(tpp.Out, tps.Out)" class="delimiter">(</span>tpp.Out, tps.Out<span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(t: T)(tpp.Out, tps.Out)" id="shapeless.ops.tuple.SplitRight.tupleSplitRight;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.SplitRight.tupleSplitRight;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.SplitRight.tupleSplitRight;T" title="T">T</a><span class="delimiter">)</span>: <span title="(tpp.Out, tps.Out)">Out</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a href="#shapeless.ops.tuple.SplitRight.tupleSplitRight;$anon.apply.p" title="(LP, LS)" class="delimiter">(</a><a href="#shapeless.ops.tuple.SplitRight.tupleSplitRight;$anon.apply.x$9" title="LP" id="shapeless.ops.tuple.SplitRight.tupleSplitRight;$anon.apply.p">p</a>, <a href="#shapeless.ops.tuple.SplitRight.tupleSplitRight;$anon.apply.x$9" title="LS" id="shapeless.ops.tuple.SplitRight.tupleSplitRight;$anon.apply.s">s</a><span class="delimiter">)</span> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)(LP, LS)">split</a><span title="(LP, LS) @unchecked" class="delimiter">(</span><a href="#shapeless.ops.tuple.SplitRight.tupleSplitRight.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.SplitRight.tupleSplitRight;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span> ; <span title="(_1: tpp.Out, _2: tps.Out)(tpp.Out, tps.Out)" class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: LP)tpp.Out">tpp</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.SplitRight.tupleSplitRight;$anon.apply.p" title="LP">p</a><span class="delimiter">)</span>, <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: LS)tps.Out">tps</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.SplitRight.tupleSplitRight;$anon.apply.s" title="LS">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting splitting this tuple at the last occurence of an element of type `U` returning the reverse
   * prefix and suffix as a pair. Available only if this tuple contains an element of type `U`.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait ReverseSplitRight[T, U] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;ReverseSplitRight">ReverseSplitRight</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;ReverseSplitRight;T">T</a>, <a title="" id="shapeless.ops.tuple;ReverseSplitRight;U">U</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.ReverseSplitRight.type" id="shapeless.ops.tuple.ReverseSplitRight">ReverseSplitRight</a> <a href="#shapeless.ops.tuple.ReverseSplitRight" title="shapeless.ops.tuple.ReverseSplitRight.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="ReverseSplitRight[T, U, Out0] extends shapeless.ops.tuple.ReverseSplitRight[T,U]" id="shapeless.ops.tuple.ReverseSplitRight;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ReverseSplitRight;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.ReverseSplitRight;Aux;U">U</a>, <a title="" id="shapeless.ops.tuple.ReverseSplitRight;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.ReverseSplitRight;<refinement>" title="ReverseSplitRight extends shapeless.ops.tuple.ReverseSplitRight[T,U]">ReverseSplitRight</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, U, LP &lt;: shapeless.HList, LS &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L], implicit split: shapeless.ops.hlist.ReverseSplitRight.Aux[L,U,(LP, LS)], implicit tpp: shapeless.ops.hlist.Tupler[LP], implicit tps: shapeless.ops.hlist.Tupler[LS])shapeless.ops.tuple.ReverseSplitRight.Aux[T,U,(tpp.Out, tps.Out)]" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight">tupleReverseSplitRight</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;L">L</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;U">U</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;LP">LP</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;LS">LS</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ReverseSplitRight.Aux[L,U,(LP, LS)]" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight.split">split</a>: hl.ReverseSplitRight.<a href="hlists.scala.html#shapeless.ops.hlist.ReverseSplitRight;<refinement>" title="shapeless.ops.hlist.ReverseSplitRight.Aux[L,U,(LP, LS)]">Aux</a><span class="delimiter">[</span>L, U, <span class="delimiter">(</span>LP, LS<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[LP]" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight.tpp">tpp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[LP]">Tupler</a><span class="delimiter">[</span>LP<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[LS]" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight.tps">tps</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[LS]">Tupler</a><span class="delimiter">[</span>LS<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.ReverseSplitRight;<refinement>" title="shapeless.ops.tuple.ReverseSplitRight.Aux[T,U,(tpp.Out, tps.Out)]">Aux</a><span class="delimiter">[</span>T, U, <span class="delimiter">(</span>tpp.Out, tps.Out<span class="delimiter">)</span><span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;$anon" title="shapeless.ops.tuple.ReverseSplitRight[T,U]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.ReverseSplitRight[T,U]" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;$anon">ReverseSplitRight</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="(tpp.Out, tps.Out)" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;$anon;Out">Out</a> = <span title="(tpp.Out, tps.Out)" class="delimiter">(</span>tpp.Out, tps.Out<span class="delimiter">)</span>
          <span class="keyword">def</span> <a title="(t: T)(tpp.Out, tps.Out)" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;T" title="T">T</a><span class="delimiter">)</span>: <span title="(tpp.Out, tps.Out)">Out</span> = <span class="delimiter">{</span> <span class="keyword">val</span> <a href="#shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;$anon.apply.p" title="(LP, LS)" class="delimiter">(</a><a href="#shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;$anon.apply.x$10" title="LP" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;$anon.apply.p">p</a>, <a href="#shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;$anon.apply.x$10" title="LS" id="shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;$anon.apply.s">s</a><span class="delimiter">)</span> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)(LP, LS)">split</a><span title="(LP, LS) @unchecked" class="delimiter">(</span><a href="#shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span> ; <span title="(_1: tpp.Out, _2: tps.Out)(tpp.Out, tps.Out)" class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: LP)tpp.Out">tpp</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;$anon.apply.p" title="LP">p</a><span class="delimiter">)</span>, <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: LS)tps.Out">tps</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ReverseSplitRight.tupleReverseSplitRight;$anon.apply.s" title="LS">s</a><span class="delimiter">)</span><span class="delimiter">)</span> <span class="delimiter">}</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting reversing this tuple.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Reverse[T] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;Reverse">Reverse</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Reverse;T">T</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Reverse.type" id="shapeless.ops.tuple.Reverse">Reverse</a> <a href="#shapeless.ops.tuple.Reverse" title="shapeless.ops.tuple.Reverse.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="Reverse[T, Out0] extends shapeless.ops.tuple.Reverse[T]" id="shapeless.ops.tuple.Reverse;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Reverse;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.Reverse;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Reverse;<refinement>" title="Reverse extends shapeless.ops.tuple.Reverse[T]">Reverse</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList, Out](implicit gen: shapeless.Generic.Aux[T,L1], implicit reverse: shapeless.ops.hlist.Reverse.Aux[L1,L2], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.Reverse.Aux[T,tp.Out]" id="shapeless.ops.tuple.Reverse.tupleReverseAux">tupleReverseAux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Reverse.tupleReverseAux;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Reverse.tupleReverseAux;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Reverse.tupleReverseAux;L2">L2</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.Reverse.tupleReverseAux;Out">Out</a><span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.Reverse.tupleReverseAux.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Reverse.Aux[L1,L2]" id="shapeless.ops.tuple.Reverse.tupleReverseAux.reverse">reverse</a>: hl.Reverse.<a href="hlists.scala.html#shapeless.ops.hlist.Reverse;<refinement>" title="shapeless.ops.hlist.Reverse.Aux[L1,L2]">Aux</a><span class="delimiter">[</span>L1, L2<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.Reverse.tupleReverseAux.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Reverse;<refinement>" title="shapeless.ops.tuple.Reverse.Aux[T,tp.Out]">Aux</a><span class="delimiter">[</span>T, tp.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.Reverse.tupleReverseAux;$anon" title="shapeless.ops.tuple.Reverse[T]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Reverse[T]" id="shapeless.ops.tuple.Reverse.tupleReverseAux;$anon">Reverse</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.Reverse.tupleReverseAux;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T)tp.Out" id="shapeless.ops.tuple.Reverse.tupleReverseAux;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Reverse.tupleReverseAux;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Reverse.tupleReverseAux;T" title="T">T</a><span class="delimiter">)</span>: tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L2)tp.Out">tp</a><span class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L1)reverse.Out">reverse</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Reverse.tupleReverseAux.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Reverse.tupleReverseAux;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting mapping a higher ranked function over this tuple. 
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Mapper[T, P] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;Mapper">Mapper</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Mapper;T">T</a>, <a title="" id="shapeless.ops.tuple;Mapper;P">P</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Mapper.type" id="shapeless.ops.tuple.Mapper">Mapper</a> <a href="#shapeless.ops.tuple.Mapper" title="shapeless.ops.tuple.Mapper.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="Mapper[T, P, Out0] extends shapeless.ops.tuple.Mapper[T,P]" id="shapeless.ops.tuple.Mapper;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Mapper;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.Mapper;Aux;P">P</a>, <a title="" id="shapeless.ops.tuple.Mapper;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Mapper;<refinement>" title="Mapper extends shapeless.ops.tuple.Mapper[T,P]">Mapper</a><span class="delimiter">[</span>T, P<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, P, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit mapper: shapeless.ops.hlist.Mapper.Aux[P,L1,L2], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.Mapper.Aux[T,P,tp.Out]" id="shapeless.ops.tuple.Mapper.mapper">mapper</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Mapper.mapper;T">T</a>, <a title="" id="shapeless.ops.tuple.Mapper.mapper;P">P</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Mapper.mapper;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Mapper.mapper;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.Mapper.mapper.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Mapper.Aux[P,L1,L2]" id="shapeless.ops.tuple.Mapper.mapper.mapper">mapper</a>: hl.Mapper.<a href="hlists.scala.html#shapeless.ops.hlist.Mapper;<refinement>" title="shapeless.ops.hlist.Mapper.Aux[P,L1,L2]">Aux</a><span class="delimiter">[</span>P, L1, L2<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.Mapper.mapper.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Mapper;<refinement>" title="shapeless.ops.tuple.Mapper.Aux[T,P,tp.Out]">Aux</a><span class="delimiter">[</span>T, P, tp.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.Mapper.mapper;$anon" title="shapeless.ops.tuple.Mapper[T,P]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Mapper[T,P]" id="shapeless.ops.tuple.Mapper.mapper;$anon">Mapper</a><span class="delimiter">[</span>T, P<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.Mapper.mapper;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T)tp.Out" id="shapeless.ops.tuple.Mapper.mapper;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Mapper.mapper;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Mapper.mapper;T" title="T">T</a><span class="delimiter">)</span>: tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L2)tp.Out">tp</a><span class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L1)mapper.Out">mapper</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Mapper.mapper.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Mapper.mapper;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting flatmapping a higher ranked function over this tuple. 
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait FlatMapper[T, P] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;FlatMapper">FlatMapper</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;FlatMapper;T">T</a>, <a title="" id="shapeless.ops.tuple;FlatMapper;P">P</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.FlatMapper.type" id="shapeless.ops.tuple.FlatMapper">FlatMapper</a> <a href="#shapeless.ops.tuple.FlatMapper" title="shapeless.ops.tuple.FlatMapper.type" class="delimiter">{</a>
    <span class="keyword">import</span> <a href="../package.scala.html#shapeless.package.poly" title="=&gt; shapeless.PolyDefns.type">poly</a>.Compose
    <span class="keyword">type</span> <a title="FlatMapper[T, P, Out0] extends shapeless.ops.tuple.FlatMapper[T,P]" id="shapeless.ops.tuple.FlatMapper;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.FlatMapper;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.FlatMapper;Aux;P">P</a>, <a title="" id="shapeless.ops.tuple.FlatMapper;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.FlatMapper;<refinement>" title="FlatMapper extends shapeless.ops.tuple.FlatMapper[T,P]">FlatMapper</a><span class="delimiter">[</span>T, P<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, P, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit mapper: shapeless.ops.hlist.FlatMapper.Aux[shapeless.poly.Compose[shapeless.productElements.type,P],L1,L2], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.FlatMapper.Aux[T,P,tp.Out]" id="shapeless.ops.tuple.FlatMapper.mapper">mapper</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.FlatMapper.mapper;T">T</a>, <a title="" id="shapeless.ops.tuple.FlatMapper.mapper;P">P</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.FlatMapper.mapper;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.FlatMapper.mapper;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.FlatMapper.mapper.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.FlatMapper.Aux[shapeless.poly.Compose[shapeless.productElements.type,P],L1,L2]" id="shapeless.ops.tuple.FlatMapper.mapper.mapper">mapper</a>: hl.FlatMapper.<a href="hlists.scala.html#shapeless.ops.hlist.FlatMapper;<refinement>" title="shapeless.ops.hlist.FlatMapper.Aux[shapeless.poly.Compose[shapeless.productElements.type,P],L1,L2]">Aux</a><span class="delimiter">[</span>Compose<span class="delimiter">[</span>productElements.<span class="keyword">type</span>, P<span class="delimiter">]</span>, L1, L2<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.FlatMapper.mapper.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.FlatMapper;<refinement>" title="shapeless.ops.tuple.FlatMapper.Aux[T,P,tp.Out]">Aux</a><span class="delimiter">[</span>T, P, tp.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.FlatMapper.mapper;$anon" title="shapeless.ops.tuple.FlatMapper[T,P]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.FlatMapper[T,P]" id="shapeless.ops.tuple.FlatMapper.mapper;$anon">FlatMapper</a><span class="delimiter">[</span>T, P<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.FlatMapper.mapper;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T)tp.Out" id="shapeless.ops.tuple.FlatMapper.mapper;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.FlatMapper.mapper;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.FlatMapper.mapper;T" title="T">T</a><span class="delimiter">)</span>: tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L2)tp.Out">tp</a><span class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L1)mapper.Out">mapper</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.FlatMapper.mapper.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.FlatMapper.mapper;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting mapping a constant valued function over this tuple. 
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait ConstMapper[T, C] extends AnyRef with shapeless.DepFn2[T,C]" id="shapeless.ops.tuple;ConstMapper">ConstMapper</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;ConstMapper;T">T</a>, <a title="" id="shapeless.ops.tuple;ConstMapper;C">C</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn2" title="shapeless.DepFn2[T,C]">DepFn2</a><span class="delimiter">[</span>T, C<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.ConstMapper.type" id="shapeless.ops.tuple.ConstMapper">ConstMapper</a> <a href="#shapeless.ops.tuple.ConstMapper" title="shapeless.ops.tuple.ConstMapper.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="ConstMapper[T, C, Out0] extends shapeless.ops.tuple.ConstMapper[T,C]" id="shapeless.ops.tuple.ConstMapper;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ConstMapper;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.ConstMapper;Aux;C">C</a>, <a title="" id="shapeless.ops.tuple.ConstMapper;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.ConstMapper;<refinement>" title="ConstMapper extends shapeless.ops.tuple.ConstMapper[T,C]">ConstMapper</a><span class="delimiter">[</span>T, C<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, C, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit mapper: shapeless.ops.hlist.ConstMapper.Aux[C,L1,L2], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.ConstMapper.Aux[T,C,tp.Out]" id="shapeless.ops.tuple.ConstMapper.mapper">mapper</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ConstMapper.mapper;T">T</a>, <a title="" id="shapeless.ops.tuple.ConstMapper.mapper;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ConstMapper.mapper;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ConstMapper.mapper;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.ConstMapper.mapper.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ConstMapper.Aux[C,L1,L2]" id="shapeless.ops.tuple.ConstMapper.mapper.mapper">mapper</a>: hl.ConstMapper.<a href="hlists.scala.html#shapeless.ops.hlist.ConstMapper;<refinement>" title="shapeless.ops.hlist.ConstMapper.Aux[C,L1,L2]">Aux</a><span class="delimiter">[</span>C, L1, L2<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.ConstMapper.mapper.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.ConstMapper;<refinement>" title="shapeless.ops.tuple.ConstMapper.Aux[T,C,tp.Out]">Aux</a><span class="delimiter">[</span>T, C, tp.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.ConstMapper.mapper;$anon" title="shapeless.ops.tuple.ConstMapper[T,C]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.ConstMapper[T,C]" id="shapeless.ops.tuple.ConstMapper.mapper;$anon">ConstMapper</a><span class="delimiter">[</span>T, C<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.ConstMapper.mapper;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T, c: C)tp.Out" id="shapeless.ops.tuple.ConstMapper.mapper;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.ConstMapper.mapper;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.ConstMapper.mapper;T" title="T">T</a>, <a title="C" id="shapeless.ops.tuple.ConstMapper.mapper;$anon.apply.c">c</a>: <a href="#shapeless.ops.tuple.ConstMapper.mapper;C" title="C">C</a><span class="delimiter">)</span>: tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L2)tp.Out">tp</a><span class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: C, u: L1)mapper.Out">mapper</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ConstMapper.mapper;$anon.apply.c" title="C">c</a>, <a href="#shapeless.ops.tuple.ConstMapper.mapper.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ConstMapper.mapper;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting mapping a polymorphic function over this tuple and then folding the result using a
   * monomorphic function value. 
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait MapFolder[T, R, P] extends AnyRef" id="shapeless.ops.tuple;MapFolder">MapFolder</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;MapFolder;T">T</a>, <a title="" id="shapeless.ops.tuple;MapFolder;R">R</a>, <a title="" id="shapeless.ops.tuple;MapFolder;P">P</a><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="comment">// Nb. Not a dependent function signature</span>
    <span class="keyword">def</span> <a title="(t: T, in: R, op: (R, R) =&gt; R)R" id="shapeless.ops.tuple;MapFolder.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple;MapFolder.apply.t">t</a>: <a href="#shapeless.ops.tuple;MapFolder;T" title="T">T</a>, <a title="R" id="shapeless.ops.tuple;MapFolder.apply.in">in</a>: <a href="#shapeless.ops.tuple;MapFolder;R" title="R">R</a>, <a title="(R, R) =&gt; R" id="shapeless.ops.tuple;MapFolder.apply.op">op</a>: <span class="delimiter">(</span>R, R<span class="delimiter">)</span> =&gt; R<span class="delimiter">)</span>: <a href="#shapeless.ops.tuple;MapFolder;R" title="R">R</a> 
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.MapFolder.type" id="shapeless.ops.tuple.MapFolder">MapFolder</a> <a href="#shapeless.ops.tuple.MapFolder" title="shapeless.ops.tuple.MapFolder.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, R, P](implicit gen: shapeless.Generic.Aux[T,L], implicit mapper: shapeless.ops.hlist.MapFolder[L,R,P])shapeless.ops.tuple.MapFolder[T,R,P]" id="shapeless.ops.tuple.MapFolder.mapper">mapper</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.MapFolder.mapper;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.MapFolder.mapper;L">L</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.MapFolder.mapper;R">R</a>, <a title="" id="shapeless.ops.tuple.MapFolder.mapper;P">P</a><span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.MapFolder.mapper.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.MapFolder[L,R,P]" id="shapeless.ops.tuple.MapFolder.mapper.mapper">mapper</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;MapFolder" title="shapeless.ops.hlist.MapFolder[L,R,P]">MapFolder</a><span class="delimiter">[</span>L, R, P<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple;MapFolder" title="shapeless.ops.tuple.MapFolder[T,R,P]">MapFolder</a><span class="delimiter">[</span>T, R, P<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.MapFolder.mapper;$anon" title="shapeless.ops.tuple.MapFolder[T,R,P]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.MapFolder[T,R,P]" id="shapeless.ops.tuple.MapFolder.mapper;$anon">MapFolder</a><span class="delimiter">[</span>T, R, P<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">def</span> <a title="(t: T, in: R, op: (R, R) =&gt; R)R" id="shapeless.ops.tuple.MapFolder.mapper;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.MapFolder.mapper;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.MapFolder.mapper;T" title="T">T</a>, <a title="R" id="shapeless.ops.tuple.MapFolder.mapper;$anon.apply.in">in</a>: <a href="#shapeless.ops.tuple.MapFolder.mapper;R" title="R">R</a>, <a title="(R, R) =&gt; R" id="shapeless.ops.tuple.MapFolder.mapper;$anon.apply.op">op</a>: <span class="delimiter">(</span>R, R<span class="delimiter">)</span> =&gt; R<span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.MapFolder.mapper;R" title="R">R</a> = <a href="hlists.scala.html#shapeless.ops.hlist;MapFolder.apply" title="(l: L, in: R, op: (R, R) =&gt; R)R">mapper</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.MapFolder.mapper.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.MapFolder.mapper;$anon.apply.t" title="T">t</a><span class="delimiter">)</span>, <a href="#shapeless.ops.tuple.MapFolder.mapper;$anon.apply.in" title="R">in</a>, <a href="#shapeless.ops.tuple.MapFolder.mapper;$anon.apply.op" title="(R, R) =&gt; R">op</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting left-folding a polymorphic binary function over this tuple.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait LeftFolder[T, U, P] extends AnyRef with shapeless.DepFn2[T,U]" id="shapeless.ops.tuple;LeftFolder">LeftFolder</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;LeftFolder;T">T</a>, <a title="" id="shapeless.ops.tuple;LeftFolder;U">U</a>, <a title="" id="shapeless.ops.tuple;LeftFolder;P">P</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn2" title="shapeless.DepFn2[T,U]">DepFn2</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.LeftFolder.type" id="shapeless.ops.tuple.LeftFolder">LeftFolder</a> <a href="#shapeless.ops.tuple.LeftFolder" title="shapeless.ops.tuple.LeftFolder.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="LeftFolder[T, U, P, Out0] extends shapeless.ops.tuple.LeftFolder[T,U,P]" id="shapeless.ops.tuple.LeftFolder;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.LeftFolder;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.LeftFolder;Aux;U">U</a>, <a title="" id="shapeless.ops.tuple.LeftFolder;Aux;P">P</a>, <a title="" id="shapeless.ops.tuple.LeftFolder;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.LeftFolder;<refinement>" title="LeftFolder extends shapeless.ops.tuple.LeftFolder[T,U,P]">LeftFolder</a><span class="delimiter">[</span>T, U, P<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, U, P](implicit gen: shapeless.Generic.Aux[T,L], implicit folder: shapeless.ops.hlist.LeftFolder[L,U,P])shapeless.ops.tuple.LeftFolder.Aux[T,U,P,folder.Out]" id="shapeless.ops.tuple.LeftFolder.folder">folder</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.LeftFolder.folder;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.LeftFolder.folder;L">L</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.LeftFolder.folder;U">U</a>, <a title="" id="shapeless.ops.tuple.LeftFolder.folder;P">P</a><span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.LeftFolder.folder.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.LeftFolder[L,U,P]" id="shapeless.ops.tuple.LeftFolder.folder.folder">folder</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;LeftFolder" title="shapeless.ops.hlist.LeftFolder[L,U,P]">LeftFolder</a><span class="delimiter">[</span>L, U, P<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.LeftFolder;<refinement>" title="shapeless.ops.tuple.LeftFolder.Aux[T,U,P,folder.Out]">Aux</a><span class="delimiter">[</span>T, U, P, folder.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.LeftFolder.folder;$anon" title="shapeless.ops.tuple.LeftFolder[T,U,P]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.LeftFolder[T,U,P]" id="shapeless.ops.tuple.LeftFolder.folder;$anon">LeftFolder</a><span class="delimiter">[</span>T, U, P<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="folder.Out" id="shapeless.ops.tuple.LeftFolder.folder;$anon;Out">Out</a> = folder.<a href="../package.scala.html#shapeless.package;DepFn2;Out" title="folder.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T, u: U)this.Out" id="shapeless.ops.tuple.LeftFolder.folder;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.LeftFolder.folder;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.LeftFolder.folder;T" title="T">T</a>, <a title="U" id="shapeless.ops.tuple.LeftFolder.folder;$anon.apply.u">u</a>: <a href="#shapeless.ops.tuple.LeftFolder.folder;U" title="U">U</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn2;Out" title="this.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L, u: U)folder.Out">folder</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.LeftFolder.folder.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.LeftFolder.folder;$anon.apply.t" title="T">t</a><span class="delimiter">)</span>, <a href="#shapeless.ops.tuple.LeftFolder.folder;$anon.apply.u" title="U">u</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting right-folding a polymorphic binary function over this tuple.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait RightFolder[T, U, P] extends AnyRef with shapeless.DepFn2[T,U]" id="shapeless.ops.tuple;RightFolder">RightFolder</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;RightFolder;T">T</a>, <a title="" id="shapeless.ops.tuple;RightFolder;U">U</a>, <a title="" id="shapeless.ops.tuple;RightFolder;P">P</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn2" title="shapeless.DepFn2[T,U]">DepFn2</a><span class="delimiter">[</span>T, U<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.RightFolder.type" id="shapeless.ops.tuple.RightFolder">RightFolder</a> <a href="#shapeless.ops.tuple.RightFolder" title="shapeless.ops.tuple.RightFolder.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="RightFolder[T, U, P, Out0] extends shapeless.ops.tuple.RightFolder[T,U,P]" id="shapeless.ops.tuple.RightFolder;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.RightFolder;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.RightFolder;Aux;U">U</a>, <a title="" id="shapeless.ops.tuple.RightFolder;Aux;P">P</a>, <a title="" id="shapeless.ops.tuple.RightFolder;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.RightFolder;<refinement>" title="RightFolder extends shapeless.ops.tuple.RightFolder[T,U,P]">RightFolder</a><span class="delimiter">[</span>T, U, P<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, U, P](implicit gen: shapeless.Generic.Aux[T,L], implicit folder: shapeless.ops.hlist.RightFolder[L,U,P])shapeless.ops.tuple.RightFolder.Aux[T,U,P,folder.Out]" id="shapeless.ops.tuple.RightFolder.folder">folder</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.RightFolder.folder;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.RightFolder.folder;L">L</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.RightFolder.folder;U">U</a>, <a title="" id="shapeless.ops.tuple.RightFolder.folder;P">P</a><span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.RightFolder.folder.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.RightFolder[L,U,P]" id="shapeless.ops.tuple.RightFolder.folder.folder">folder</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;RightFolder" title="shapeless.ops.hlist.RightFolder[L,U,P]">RightFolder</a><span class="delimiter">[</span>L, U, P<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.RightFolder;<refinement>" title="shapeless.ops.tuple.RightFolder.Aux[T,U,P,folder.Out]">Aux</a><span class="delimiter">[</span>T, U, P, folder.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.RightFolder.folder;$anon" title="shapeless.ops.tuple.RightFolder[T,U,P]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.RightFolder[T,U,P]" id="shapeless.ops.tuple.RightFolder.folder;$anon">RightFolder</a><span class="delimiter">[</span>T, U, P<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="folder.Out" id="shapeless.ops.tuple.RightFolder.folder;$anon;Out">Out</a> = folder.<a href="../package.scala.html#shapeless.package;DepFn2;Out" title="folder.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T, u: U)this.Out" id="shapeless.ops.tuple.RightFolder.folder;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.RightFolder.folder;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.RightFolder.folder;T" title="T">T</a>, <a title="U" id="shapeless.ops.tuple.RightFolder.folder;$anon.apply.u">u</a>: <a href="#shapeless.ops.tuple.RightFolder.folder;U" title="U">U</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn2;Out" title="this.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: L, u: U)folder.Out">folder</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.RightFolder.folder.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.RightFolder.folder;$anon.apply.t" title="T">t</a><span class="delimiter">)</span>, <a href="#shapeless.ops.tuple.RightFolder.folder;$anon.apply.u" title="U">u</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Type class supporting left-reducing a polymorphic binary function over this tuple.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait LeftReducer[T, P] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;LeftReducer">LeftReducer</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;LeftReducer;T">T</a>, <a title="" id="shapeless.ops.tuple;LeftReducer;P">P</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.LeftReducer.type" id="shapeless.ops.tuple.LeftReducer">LeftReducer</a> <a href="#shapeless.ops.tuple.LeftReducer" title="shapeless.ops.tuple.LeftReducer.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="LeftReducer[T, P, Out0] extends shapeless.ops.tuple.LeftReducer[T,P]" id="shapeless.ops.tuple.LeftReducer;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.LeftReducer;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.LeftReducer;Aux;P">P</a>, <a title="" id="shapeless.ops.tuple.LeftReducer;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.LeftReducer;<refinement>" title="LeftReducer extends shapeless.ops.tuple.LeftReducer[T,P]">LeftReducer</a><span class="delimiter">[</span>T, P<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, P](implicit gen: shapeless.Generic.Aux[T,L], implicit folder: shapeless.ops.hlist.LeftReducer[L,P])shapeless.ops.tuple.LeftReducer.Aux[T,P,folder.Out]" id="shapeless.ops.tuple.LeftReducer.folder">folder</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.LeftReducer.folder;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.LeftReducer.folder;L">L</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.LeftReducer.folder;P">P</a><span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.LeftReducer.folder.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.LeftReducer[L,P]" id="shapeless.ops.tuple.LeftReducer.folder.folder">folder</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;LeftReducer" title="shapeless.ops.hlist.LeftReducer[L,P]">LeftReducer</a><span class="delimiter">[</span>L, P<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.LeftReducer;<refinement>" title="shapeless.ops.tuple.LeftReducer.Aux[T,P,folder.Out]">Aux</a><span class="delimiter">[</span>T, P, folder.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.LeftReducer.folder;$anon" title="shapeless.ops.tuple.LeftReducer[T,P]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.LeftReducer[T,P]" id="shapeless.ops.tuple.LeftReducer.folder;$anon">LeftReducer</a><span class="delimiter">[</span>T, P<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="folder.Out" id="shapeless.ops.tuple.LeftReducer.folder;$anon;Out">Out</a> = folder.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="folder.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T)this.Out" id="shapeless.ops.tuple.LeftReducer.folder;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.LeftReducer.folder;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.LeftReducer.folder;T" title="T">T</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)folder.Out">folder</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.LeftReducer.folder.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.LeftReducer.folder;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="comment">/**
   * Type class supporting right-reducing a polymorphic binary function over this tuple.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait RightReducer[T, P] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;RightReducer">RightReducer</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;RightReducer;T">T</a>, <a title="" id="shapeless.ops.tuple;RightReducer;P">P</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.RightReducer.type" id="shapeless.ops.tuple.RightReducer">RightReducer</a> <a href="#shapeless.ops.tuple.RightReducer" title="shapeless.ops.tuple.RightReducer.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="RightReducer[T, P, Out0] extends shapeless.ops.tuple.RightReducer[T,P]" id="shapeless.ops.tuple.RightReducer;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.RightReducer;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.RightReducer;Aux;P">P</a>, <a title="" id="shapeless.ops.tuple.RightReducer;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.RightReducer;<refinement>" title="RightReducer extends shapeless.ops.tuple.RightReducer[T,P]">RightReducer</a><span class="delimiter">[</span>T, P<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, P](implicit gen: shapeless.Generic.Aux[T,L], implicit folder: shapeless.ops.hlist.RightReducer[L,P])shapeless.ops.tuple.RightReducer.Aux[T,P,folder.Out]" id="shapeless.ops.tuple.RightReducer.folder">folder</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.RightReducer.folder;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.RightReducer.folder;L">L</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.RightReducer.folder;P">P</a><span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.RightReducer.folder.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.RightReducer[L,P]" id="shapeless.ops.tuple.RightReducer.folder.folder">folder</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;RightReducer" title="shapeless.ops.hlist.RightReducer[L,P]">RightReducer</a><span class="delimiter">[</span>L, P<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.RightReducer;<refinement>" title="shapeless.ops.tuple.RightReducer.Aux[T,P,folder.Out]">Aux</a><span class="delimiter">[</span>T, P, folder.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.RightReducer.folder;$anon" title="shapeless.ops.tuple.RightReducer[T,P]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.RightReducer[T,P]" id="shapeless.ops.tuple.RightReducer.folder;$anon">RightReducer</a><span class="delimiter">[</span>T, P<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="folder.Out" id="shapeless.ops.tuple.RightReducer.folder;$anon;Out">Out</a> = folder.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="folder.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T)this.Out" id="shapeless.ops.tuple.RightReducer.folder;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.RightReducer.folder;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.RightReducer.folder;T" title="T">T</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L)folder.Out">folder</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.RightReducer.folder.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.RightReducer.folder;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting transposing this tuple.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Transposer[T] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;Transposer">Transposer</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Transposer;T">T</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Transposer.type" id="shapeless.ops.tuple.Transposer">Transposer</a> <a href="#shapeless.ops.tuple.Transposer" title="shapeless.ops.tuple.Transposer.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="Transposer[T, Out0] extends shapeless.ops.tuple.Transposer[T]" id="shapeless.ops.tuple.Transposer;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Transposer;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.Transposer;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Transposer;<refinement>" title="Transposer extends shapeless.ops.tuple.Transposer[T]">Transposer</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList, L3 &lt;: shapeless.HList, L4 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit mpe: shapeless.ops.hlist.Mapper.Aux[shapeless.productElements.type,L1,L2], implicit tps: shapeless.ops.hlist.Transposer.Aux[L2,L3], implicit mtp: shapeless.ops.hlist.Mapper.Aux[shapeless.tupled.type,L3,L4], implicit tp: shapeless.ops.hlist.Tupler[L4])shapeless.ops.tuple.Transposer.Aux[T,tp.Out]" id="shapeless.ops.tuple.Transposer.transpose">transpose</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Transposer.transpose;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Transposer.transpose;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Transposer.transpose;L2">L2</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Transposer.transpose;L3">L3</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Transposer.transpose;L4">L4</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span>
        <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.Transposer.transpose.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>,
        <a title="shapeless.ops.hlist.Mapper.Aux[shapeless.productElements.type,L1,L2]" id="shapeless.ops.tuple.Transposer.transpose.mpe">mpe</a>: hl.Mapper.<a href="hlists.scala.html#shapeless.ops.hlist.Mapper;<refinement>" title="shapeless.ops.hlist.Mapper.Aux[shapeless.productElements.type,L1,L2]">Aux</a><span class="delimiter">[</span>productElements.<span class="keyword">type</span>, L1, L2<span class="delimiter">]</span>,
        <a title="shapeless.ops.hlist.Transposer.Aux[L2,L3]" id="shapeless.ops.tuple.Transposer.transpose.tps">tps</a>: hl.Transposer.<a href="hlists.scala.html#shapeless.ops.hlist.Transposer;<refinement>" title="shapeless.ops.hlist.Transposer.Aux[L2,L3]">Aux</a><span class="delimiter">[</span>L2, L3<span class="delimiter">]</span>,
        <a title="shapeless.ops.hlist.Mapper.Aux[shapeless.tupled.type,L3,L4]" id="shapeless.ops.tuple.Transposer.transpose.mtp">mtp</a>: hl.Mapper.<a href="hlists.scala.html#shapeless.ops.hlist.Mapper;<refinement>" title="shapeless.ops.hlist.Mapper.Aux[shapeless.tupled.type,L3,L4]">Aux</a><span class="delimiter">[</span>tupled.<span class="keyword">type</span>, L3, L4<span class="delimiter">]</span>,
        <a title="shapeless.ops.hlist.Tupler[L4]" id="shapeless.ops.tuple.Transposer.transpose.tp">tp</a>:  hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L4]">Tupler</a><span class="delimiter">[</span>L4<span class="delimiter">]</span>
      <span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Transposer;<refinement>" title="shapeless.ops.tuple.Transposer.Aux[T,tp.Out]">Aux</a><span class="delimiter">[</span>T, tp.Out<span class="delimiter">]</span> =
      <a href="#shapeless.ops.tuple.Transposer.transpose;$anon" title="shapeless.ops.tuple.Transposer[T]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Transposer[T]" id="shapeless.ops.tuple.Transposer.transpose;$anon">Transposer</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.Transposer.transpose;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
        <span class="keyword">def</span> <a title="(t: T)this.Out" id="shapeless.ops.tuple.Transposer.transpose;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Transposer.transpose;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Transposer.transpose;T" title="T">T</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.Out">Out</a> = <span class="delimiter">(</span><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Transposer.transpose.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: gen.Repr)shapeless.syntax.HListOps[gen.Repr]" class="delimiter">(</a><a href="#shapeless.ops.tuple.Transposer.transpose;$anon.apply.t" title="T">t</a><span class="delimiter">)</span> <a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: mpe.Out)shapeless.syntax.HListOps[mpe.Out]">map</a> <a href="../conversions.scala.html#shapeless.productElements" title="shapeless.productElements.type">productElements</a><span class="delimiter">)</span>.<a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: tps.Out)shapeless.syntax.HListOps[tps.Out]">transpose</a> <a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: mtp.Out)shapeless.syntax.HListOps[mtp.Out]">map</a> <a href="../conversions.scala.html#shapeless.tupled" title="shapeless.tupled.type">tupled</a><span class="delimiter">)</span>.<a href="../syntax/hlists.scala.html#shapeless.syntax;HListOps.tupled" title="(implicit tupler: shapeless.ops.hlist.Tupler[mtp.Out])tupler.Out">tupled</a>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting zipping this this tuple of monomorphic function values with its argument tuple of
   * correspondingly typed function arguments returning the result of each application as a tuple. Available only if
   * there is evidence that the corresponding function and argument elements have compatible types.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait ZipApply[FT, AT] extends AnyRef with shapeless.DepFn2[FT,AT]" id="shapeless.ops.tuple;ZipApply">ZipApply</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;ZipApply;FT">FT</a>, <a title="" id="shapeless.ops.tuple;ZipApply;AT">AT</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn2" title="shapeless.DepFn2[FT,AT]">DepFn2</a><span class="delimiter">[</span>FT, AT<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.ZipApply.type" id="shapeless.ops.tuple.ZipApply">ZipApply</a> <a href="#shapeless.ops.tuple.ZipApply" title="shapeless.ops.tuple.ZipApply.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="ZipApply[FT, AT, Out0] extends shapeless.ops.tuple.ZipApply[FT,AT]" id="shapeless.ops.tuple.ZipApply;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ZipApply;Aux;FT">FT</a>, <a title="" id="shapeless.ops.tuple.ZipApply;Aux;AT">AT</a>, <a title="" id="shapeless.ops.tuple.ZipApply;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.ZipApply;<refinement>" title="ZipApply extends shapeless.ops.tuple.ZipApply[FT,AT]">ZipApply</a><span class="delimiter">[</span>FT, AT<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[FT, FL &lt;: shapeless.HList, AT, AL &lt;: shapeless.HList, RL &lt;: shapeless.HList](implicit genf: shapeless.Generic.Aux[FT,FL], implicit gena: shapeless.Generic.Aux[AT,AL], implicit zip: shapeless.ops.hlist.ZipApply.Aux[FL,AL,RL], implicit tp: shapeless.ops.hlist.Tupler[RL])shapeless.ops.tuple.ZipApply.Aux[FT,AT,tp.Out]" id="shapeless.ops.tuple.ZipApply.zipApply">zipApply</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ZipApply.zipApply;FT">FT</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ZipApply.zipApply;FL">FL</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.ZipApply.zipApply;AT">AT</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ZipApply.zipApply;AL">AL</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ZipApply.zipApply;RL">RL</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span>
        <a title="shapeless.Generic.Aux[FT,FL]" id="shapeless.ops.tuple.ZipApply.zipApply.genf">genf</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[FT,FL]">Aux</a><span class="delimiter">[</span>FT, FL<span class="delimiter">]</span>,
        <a title="shapeless.Generic.Aux[AT,AL]" id="shapeless.ops.tuple.ZipApply.zipApply.gena">gena</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[AT,AL]">Aux</a><span class="delimiter">[</span>AT, AL<span class="delimiter">]</span>,
        <a title="shapeless.ops.hlist.ZipApply.Aux[FL,AL,RL]" id="shapeless.ops.tuple.ZipApply.zipApply.zip">zip</a>:  hl.ZipApply.<a href="hlists.scala.html#shapeless.ops.hlist.ZipApply;<refinement>" title="shapeless.ops.hlist.ZipApply.Aux[FL,AL,RL]">Aux</a><span class="delimiter">[</span>FL, AL, RL<span class="delimiter">]</span>,
        <a title="shapeless.ops.hlist.Tupler[RL]" id="shapeless.ops.tuple.ZipApply.zipApply.tp">tp</a>:   hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[RL]">Tupler</a><span class="delimiter">[</span>RL<span class="delimiter">]</span>
      <span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.ZipApply;<refinement>" title="shapeless.ops.tuple.ZipApply.Aux[FT,AT,tp.Out]">Aux</a><span class="delimiter">[</span>FT, AT, tp.Out<span class="delimiter">]</span> = 
      <a href="#shapeless.ops.tuple.ZipApply.zipApply;$anon" title="shapeless.ops.tuple.ZipApply[FT,AT]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.ZipApply[FT,AT]" id="shapeless.ops.tuple.ZipApply.zipApply;$anon">ZipApply</a><span class="delimiter">[</span>FT, AT<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.ZipApply.zipApply;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
        <span class="keyword">def</span> <a title="(ft: FT, at: AT)this.Out" id="shapeless.ops.tuple.ZipApply.zipApply;$anon.apply">apply</a><span class="delimiter">(</span><a title="FT" id="shapeless.ops.tuple.ZipApply.zipApply;$anon.apply.ft">ft</a>: <a href="#shapeless.ops.tuple.ZipApply.zipApply;FT" title="FT">FT</a>, <a title="AT" id="shapeless.ops.tuple.ZipApply.zipApply;$anon.apply.at">at</a>: <a href="#shapeless.ops.tuple.ZipApply.zipApply;AT" title="AT">AT</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.Out">Out</a> = <span class="delimiter">(</span><a href="#shapeless.ops.tuple.ZipApply.zipApply.genf" title="shapeless.Generic.Aux[FT,FL]">genf</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: FT)genf.Repr">to</a><a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: genf.Repr)shapeless.syntax.HListOps[genf.Repr]" class="delimiter">(</a><a href="#shapeless.ops.tuple.ZipApply.zipApply;$anon.apply.ft" title="FT">ft</a><span class="delimiter">)</span> <a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: zip.Out)shapeless.syntax.HListOps[zip.Out]">zipApply</a> <a href="#shapeless.ops.tuple.ZipApply.zipApply.gena" title="shapeless.Generic.Aux[AT,AL]">gena</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: AT)gena.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ZipApply.zipApply;$anon.apply.at" title="AT">at</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../syntax/hlists.scala.html#shapeless.syntax;HListOps.tupled" title="(implicit tupler: shapeless.ops.hlist.Tupler[zip.Out])tupler.Out">tupled</a>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting zipping this tuple with a tuple of tuples returning a tuple of tuples with each
   * element of this tuple prepended to the corresponding tuple element of the argument tuple.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait ZipOne[H, T] extends AnyRef with shapeless.DepFn2[H,T]" id="shapeless.ops.tuple;ZipOne">ZipOne</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;ZipOne;H">H</a>, <a title="" id="shapeless.ops.tuple;ZipOne;T">T</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn2" title="shapeless.DepFn2[H,T]">DepFn2</a><span class="delimiter">[</span>H, T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.ZipOne.type" id="shapeless.ops.tuple.ZipOne">ZipOne</a> <a href="#shapeless.ops.tuple.ZipOne" title="shapeless.ops.tuple.ZipOne.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="ZipOne[H, T, Out0] extends shapeless.ops.tuple.ZipOne[H,T]" id="shapeless.ops.tuple.ZipOne;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ZipOne;Aux;H">H</a>, <a title="" id="shapeless.ops.tuple.ZipOne;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.ZipOne;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.ZipOne;<refinement>" title="ZipOne extends shapeless.ops.tuple.ZipOne[H,T]">ZipOne</a><span class="delimiter">[</span>H, T<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[HT, HL &lt;: shapeless.HList, TT, TL &lt;: shapeless.HList, TLL &lt;: shapeless.HList, RLL &lt;: shapeless.HList, RL &lt;: shapeless.HList](implicit genh: shapeless.Generic.Aux[HT,HL], implicit gent: shapeless.Generic.Aux[TT,TL], implicit mpet: shapeless.ops.hlist.Mapper.Aux[shapeless.productElements.type,TL,TLL], implicit zone: shapeless.ops.hlist.ZipOne.Aux[HL,TLL,RLL], implicit mtp: shapeless.ops.hlist.Mapper.Aux[shapeless.tupled.type,RLL,RL], implicit tp: shapeless.ops.hlist.Tupler[RL])shapeless.ops.tuple.ZipOne.Aux[HT,TT,tp.Out]" id="shapeless.ops.tuple.ZipOne.zipOne">zipOne</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ZipOne.zipOne;HT">HT</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ZipOne.zipOne;HL">HL</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.ZipOne.zipOne;TT">TT</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ZipOne.zipOne;TL">TL</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ZipOne.zipOne;TLL">TLL</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ZipOne.zipOne;RLL">RLL</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ZipOne.zipOne;RL">RL</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span>
        <a title="shapeless.Generic.Aux[HT,HL]" id="shapeless.ops.tuple.ZipOne.zipOne.genh">genh</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[HT,HL]">Aux</a><span class="delimiter">[</span>HT, HL<span class="delimiter">]</span>,
        <a title="shapeless.Generic.Aux[TT,TL]" id="shapeless.ops.tuple.ZipOne.zipOne.gent">gent</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[TT,TL]">Aux</a><span class="delimiter">[</span>TT, TL<span class="delimiter">]</span>,
        <a title="shapeless.ops.hlist.Mapper.Aux[shapeless.productElements.type,TL,TLL]" id="shapeless.ops.tuple.ZipOne.zipOne.mpet">mpet</a>: hl.Mapper.<a href="hlists.scala.html#shapeless.ops.hlist.Mapper;<refinement>" title="shapeless.ops.hlist.Mapper.Aux[shapeless.productElements.type,TL,TLL]">Aux</a><span class="delimiter">[</span>productElements.<span class="keyword">type</span>, TL, TLL<span class="delimiter">]</span>,
        <a title="shapeless.ops.hlist.ZipOne.Aux[HL,TLL,RLL]" id="shapeless.ops.tuple.ZipOne.zipOne.zone">zone</a>: hl.ZipOne.<a href="hlists.scala.html#shapeless.ops.hlist.ZipOne;<refinement>" title="shapeless.ops.hlist.ZipOne.Aux[HL,TLL,RLL]">Aux</a><span class="delimiter">[</span>HL, TLL, RLL<span class="delimiter">]</span>,
        <a title="shapeless.ops.hlist.Mapper.Aux[shapeless.tupled.type,RLL,RL]" id="shapeless.ops.tuple.ZipOne.zipOne.mtp">mtp</a>:  hl.Mapper.<a href="hlists.scala.html#shapeless.ops.hlist.Mapper;<refinement>" title="shapeless.ops.hlist.Mapper.Aux[shapeless.tupled.type,RLL,RL]">Aux</a><span class="delimiter">[</span>tupled.<span class="keyword">type</span>, RLL, RL<span class="delimiter">]</span>,
        <a title="shapeless.ops.hlist.Tupler[RL]" id="shapeless.ops.tuple.ZipOne.zipOne.tp">tp</a>:   hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[RL]">Tupler</a><span class="delimiter">[</span>RL<span class="delimiter">]</span>
      <span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.ZipOne;<refinement>" title="shapeless.ops.tuple.ZipOne.Aux[HT,TT,tp.Out]">Aux</a><span class="delimiter">[</span>HT, TT, tp.Out<span class="delimiter">]</span> =
      <a href="#shapeless.ops.tuple.ZipOne.zipOne;$anon" title="shapeless.ops.tuple.ZipOne[HT,TT]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.ZipOne[HT,TT]" id="shapeless.ops.tuple.ZipOne.zipOne;$anon">ZipOne</a><span class="delimiter">[</span>HT, TT<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.ZipOne.zipOne;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
        <span class="keyword">def</span> <a title="(h: HT, t: TT)this.Out" id="shapeless.ops.tuple.ZipOne.zipOne;$anon.apply">apply</a><span class="delimiter">(</span><a title="HT" id="shapeless.ops.tuple.ZipOne.zipOne;$anon.apply.h">h</a>: <a href="#shapeless.ops.tuple.ZipOne.zipOne;HT" title="HT">HT</a>, <a title="TT" id="shapeless.ops.tuple.ZipOne.zipOne;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.ZipOne.zipOne;TT" title="TT">TT</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.Out">Out</a> = <span class="delimiter">(</span><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ZipOne.zipOne.genh" title="shapeless.Generic.Aux[HT,HL]">genh</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: HT)genh.Repr">to</a><a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: genh.Repr)shapeless.syntax.HListOps[genh.Repr]" class="delimiter">(</a><a href="#shapeless.ops.tuple.ZipOne.zipOne;$anon.apply.h" title="HT">h</a><span class="delimiter">)</span> <a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: zone.Out)shapeless.syntax.HListOps[zone.Out]">zipOne</a> <span class="delimiter">(</span><a href="#shapeless.ops.tuple.ZipOne.zipOne.gent" title="shapeless.Generic.Aux[TT,TL]">gent</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: TT)gent.Repr">to</a><a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: gent.Repr)shapeless.syntax.HListOps[gent.Repr]" class="delimiter">(</a><a href="#shapeless.ops.tuple.ZipOne.zipOne;$anon.apply.t" title="TT">t</a><span class="delimiter">)</span> <a href="../syntax/hlists.scala.html#shapeless.syntax;HListOps.map" title="(f: shapeless.Poly)(implicit mapper: shapeless.ops.hlist.Mapper[f.type,gent.Repr])mapper.Out">map</a> <a href="../conversions.scala.html#shapeless.productElements" title="shapeless.productElements.type">productElements</a><span class="delimiter">)</span><span class="delimiter">)</span> <a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: mtp.Out)shapeless.syntax.HListOps[mtp.Out]">map</a> <a href="../conversions.scala.html#shapeless.tupled" title="shapeless.tupled.type">tupled</a><span class="delimiter">)</span>.<a href="../syntax/hlists.scala.html#shapeless.syntax;HListOps.tupled" title="(implicit tupler: shapeless.ops.hlist.Tupler[mtp.Out])tupler.Out">tupled</a>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting zipping a tuple with a constant, resulting in a tuple of tuples of the form
   * ({element from input tuple}, {supplied constant})
   *
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait ZipConst[T, C] extends AnyRef with shapeless.DepFn2[T,C]" id="shapeless.ops.tuple;ZipConst">ZipConst</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;ZipConst;T">T</a>, <a title="" id="shapeless.ops.tuple;ZipConst;C">C</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn2" title="shapeless.DepFn2[T,C]">DepFn2</a><span class="delimiter">[</span>T, C<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.ZipConst.type" id="shapeless.ops.tuple.ZipConst">ZipConst</a> <a href="#shapeless.ops.tuple.ZipConst" title="shapeless.ops.tuple.ZipConst.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="ZipConst[T, C, Out0] extends shapeless.ops.tuple.ZipConst[T,C]" id="shapeless.ops.tuple.ZipConst;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ZipConst;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.ZipConst;Aux;C">C</a>, <a title="" id="shapeless.ops.tuple.ZipConst;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.ZipConst;<refinement>" title="ZipConst extends shapeless.ops.tuple.ZipConst[T,C]">ZipConst</a><span class="delimiter">[</span>T, C<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, C, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit zipper: shapeless.ops.hlist.ZipConst.Aux[C,L1,L2], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.ZipConst.Aux[T,C,tp.Out]" id="shapeless.ops.tuple.ZipConst.zipConst">zipConst</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ZipConst.zipConst;T">T</a>, <a title="" id="shapeless.ops.tuple.ZipConst.zipConst;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ZipConst.zipConst;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ZipConst.zipConst;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
    <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.ZipConst.zipConst.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ZipConst.Aux[C,L1,L2]" id="shapeless.ops.tuple.ZipConst.zipConst.zipper">zipper</a>: hl.ZipConst.<a href="hlists.scala.html#shapeless.ops.hlist.ZipConst;<refinement>" title="shapeless.ops.hlist.ZipConst.Aux[C,L1,L2]">Aux</a><span class="delimiter">[</span>C, L1, L2<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.ZipConst.zipConst.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.ZipConst;<refinement>" title="shapeless.ops.tuple.ZipConst.Aux[T,C,tp.Out]">Aux</a><span class="delimiter">[</span>T, C, tp.Out<span class="delimiter">]</span> =
      <a href="#shapeless.ops.tuple.ZipConst.zipConst;$anon" title="shapeless.ops.tuple.ZipConst[T,C]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.ZipConst[T,C]" id="shapeless.ops.tuple.ZipConst.zipConst;$anon">ZipConst</a><span class="delimiter">[</span>T, C<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.ZipConst.zipConst;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
        <span class="keyword">def</span> <a title="(t: T, c: C)tp.Out" id="shapeless.ops.tuple.ZipConst.zipConst;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.ZipConst.zipConst;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.ZipConst.zipConst;T" title="T">T</a>, <a title="C" id="shapeless.ops.tuple.ZipConst.zipConst;$anon.apply.c">c</a>: <a href="#shapeless.ops.tuple.ZipConst.zipConst;C" title="C">C</a><span class="delimiter">)</span>: tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L2)tp.Out">tp</a><span class="delimiter">(</span><a href="../package.scala.html#shapeless.package;DepFn2.apply" title="(t: C, u: L1)zipper.Out">zipper</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ZipConst.zipConst;$anon.apply.c" title="C">c</a>, <a href="#shapeless.ops.tuple.ZipConst.zipConst.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.ZipConst.zipConst;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting unification of this tuple. 
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Unifier[T] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;Unifier">Unifier</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Unifier;T">T</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Unifier.type" id="shapeless.ops.tuple.Unifier">Unifier</a> <a href="#shapeless.ops.tuple.Unifier" title="shapeless.ops.tuple.Unifier.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="Unifier[T, Out0] extends shapeless.ops.tuple.Unifier[T]" id="shapeless.ops.tuple.Unifier;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Unifier;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.Unifier;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Unifier;<refinement>" title="Unifier extends shapeless.ops.tuple.Unifier[T]">Unifier</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit unifier: shapeless.ops.hlist.Unifier.Aux[L1,L2], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.Unifier.Aux[T,tp.Out]" id="shapeless.ops.tuple.Unifier.unifier">unifier</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Unifier.unifier;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Unifier.unifier;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Unifier.unifier;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.Unifier.unifier.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Unifier.Aux[L1,L2]" id="shapeless.ops.tuple.Unifier.unifier.unifier">unifier</a>: hl.Unifier.<a href="hlists.scala.html#shapeless.ops.hlist.Unifier;<refinement>" title="shapeless.ops.hlist.Unifier.Aux[L1,L2]">Aux</a><span class="delimiter">[</span>L1, L2<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.Unifier.unifier.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Unifier;<refinement>" title="shapeless.ops.tuple.Unifier.Aux[T,tp.Out]">Aux</a><span class="delimiter">[</span>T, tp.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.Unifier.unifier;$anon" title="shapeless.ops.tuple.Unifier[T]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Unifier[T]" id="shapeless.ops.tuple.Unifier.unifier;$anon">Unifier</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.Unifier.unifier;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T)this.Out" id="shapeless.ops.tuple.Unifier.unifier;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Unifier.unifier;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Unifier.unifier;T" title="T">T</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L1)unifier.Out">unifier</a><a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: unifier.Out)shapeless.syntax.HListOps[unifier.Out]" class="delimiter">(</a><a href="#shapeless.ops.tuple.Unifier.unifier.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.Unifier.unifier;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../syntax/hlists.scala.html#shapeless.syntax;HListOps.tupled" title="(implicit tupler: shapeless.ops.hlist.Tupler[unifier.Out])tupler.Out">tupled</a>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting unification of all elements that are subtypes of `B` in this tuple to `B`, with all other
   * elements left unchanged.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait SubtypeUnifier[T, B] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;SubtypeUnifier">SubtypeUnifier</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;SubtypeUnifier;T">T</a>, <a title="" id="shapeless.ops.tuple;SubtypeUnifier;B">B</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.SubtypeUnifier.type" id="shapeless.ops.tuple.SubtypeUnifier">SubtypeUnifier</a> <a href="#shapeless.ops.tuple.SubtypeUnifier" title="shapeless.ops.tuple.SubtypeUnifier.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="SubtypeUnifier[T, B, Out0] extends shapeless.ops.tuple.SubtypeUnifier[T,B]" id="shapeless.ops.tuple.SubtypeUnifier;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.SubtypeUnifier;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.SubtypeUnifier;Aux;B">B</a>, <a title="" id="shapeless.ops.tuple.SubtypeUnifier;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.SubtypeUnifier;<refinement>" title="SubtypeUnifier extends shapeless.ops.tuple.SubtypeUnifier[T,B]">SubtypeUnifier</a><span class="delimiter">[</span>T, B<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, B, L1 &lt;: shapeless.HList, L2 &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L1], implicit unifier: shapeless.ops.hlist.SubtypeUnifier.Aux[L1,B,L2], implicit tp: shapeless.ops.hlist.Tupler[L2])shapeless.ops.tuple.SubtypeUnifier.Aux[T,B,tp.Out]" id="shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier">subtypeUnifier</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier;T">T</a>, <a title="" id="shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier;B">B</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier;L1">L1</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier;L2">L2</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L1]" id="shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L1]">Aux</a><span class="delimiter">[</span>T, L1<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.SubtypeUnifier.Aux[L1,B,L2]" id="shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier.unifier">unifier</a>: hl.SubtypeUnifier.<a href="hlists.scala.html#shapeless.ops.hlist.SubtypeUnifier;<refinement>" title="shapeless.ops.hlist.SubtypeUnifier.Aux[L1,B,L2]">Aux</a><span class="delimiter">[</span>L1, B, L2<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Tupler[L2]" id="shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier.tp">tp</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Tupler" title="shapeless.ops.hlist.Tupler[L2]">Tupler</a><span class="delimiter">[</span>L2<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.SubtypeUnifier;<refinement>" title="shapeless.ops.tuple.SubtypeUnifier.Aux[T,B,tp.Out]">Aux</a><span class="delimiter">[</span>T, B, tp.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier;$anon" title="shapeless.ops.tuple.SubtypeUnifier[T,B]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.SubtypeUnifier[T,B]" id="shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier;$anon">SubtypeUnifier</a><span class="delimiter">[</span>T, B<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="tp.Out" id="shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier;$anon;Out">Out</a> = tp.<a href="../package.scala.html#shapeless.package;DepFn1;Out" title="tp.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T)this.Out" id="shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier;T" title="T">T</a><span class="delimiter">)</span>: <a href="../package.scala.html#shapeless.package;DepFn1;Out" title="this.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn1.apply" title="(t: L1)unifier.Out">unifier</a><a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: unifier.Out)shapeless.syntax.HListOps[unifier.Out]" class="delimiter">(</a><a href="#shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier.gen" title="shapeless.Generic.Aux[T,L1]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.ops.tuple.SubtypeUnifier.subtypeUnifier;$anon.apply.t" title="T">t</a><span class="delimiter">)</span><span class="delimiter">)</span>.<a href="../syntax/hlists.scala.html#shapeless.syntax;HListOps.tupled" title="(implicit tupler: shapeless.ops.hlist.Tupler[unifier.Out])tupler.Out">tupled</a>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting computing the type-level Nat corresponding to the length of this tuple. 
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait Length[T] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;Length">Length</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;Length;T">T</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.Length.type" id="shapeless.ops.tuple.Length">Length</a> <a href="#shapeless.ops.tuple.Length" title="shapeless.ops.tuple.Length.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="Length[T, Out0] extends shapeless.ops.tuple.Length[T]" id="shapeless.ops.tuple.Length;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Length;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.Length;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.Length;<refinement>" title="Length extends shapeless.ops.tuple.Length[T]">Length</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[T,L], implicit length: shapeless.ops.hlist.Length[L])shapeless.ops.tuple.Length.Aux[T,length.Out]" id="shapeless.ops.tuple.Length.length">length</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.Length.length;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.Length.length;L">L</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.Length.length.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.Length[L]" id="shapeless.ops.tuple.Length.length.length">length</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;Length" title="shapeless.ops.hlist.Length[L]">Length</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.Length;<refinement>" title="shapeless.ops.tuple.Length.Aux[T,length.Out]">Aux</a><span class="delimiter">[</span>T, length.Out<span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.Length.length;$anon" title="shapeless.ops.tuple.Length[T]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.Length[T]" id="shapeless.ops.tuple.Length.length;$anon">Length</a><span class="delimiter">[</span>T<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="length.Out" id="shapeless.ops.tuple.Length.length;$anon;Out">Out</a> = length.<a href="hlists.scala.html#shapeless.ops.hlist;Length;Out" title="length.Out">Out</a>
          <span class="keyword">def</span> <a title="(t: T)this.Out" id="shapeless.ops.tuple.Length.length;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.Length.length;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.Length.length;T" title="T">T</a><span class="delimiter">)</span>: <a href="hlists.scala.html#shapeless.ops.hlist;Length;Out" title="this.Out">Out</a> = <a href="../package.scala.html#shapeless.package;DepFn0.apply" title="()length.Out">length</a><span class="delimiter">(</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting conversion of this tuple to a `List` with elements typed as the least upper bound
   * of the types of the elements of this tuple.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait ToList[T, Lub] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;ToList">ToList</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;ToList;T">T</a>, <a title="" id="shapeless.ops.tuple;ToList;Lub">Lub</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.ToList.type" id="shapeless.ops.tuple.ToList">ToList</a> <a href="#shapeless.ops.tuple.ToList" title="shapeless.ops.tuple.ToList.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="ToList[T, Lub, Out0] extends shapeless.ops.tuple.ToList[T,Lub]" id="shapeless.ops.tuple.ToList;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ToList;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.ToList;Aux;Lub">Lub</a>, <a title="" id="shapeless.ops.tuple.ToList;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.ToList;<refinement>" title="ToList extends shapeless.ops.tuple.ToList[T,Lub]">ToList</a><span class="delimiter">[</span>T, Lub<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, Lub](implicit gen: shapeless.Generic.Aux[T,L], implicit toList: shapeless.ops.hlist.ToList[L,Lub])shapeless.ops.tuple.ToList.Aux[T,Lub,List[Lub]]" id="shapeless.ops.tuple.ToList.toList">toList</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ToList.toList;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ToList.toList;L">L</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.ToList.toList;Lub">Lub</a><span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.ToList.toList.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ToList[L,Lub]" id="shapeless.ops.tuple.ToList.toList.toList">toList</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;ToList" title="shapeless.ops.hlist.ToList[L,Lub]">ToList</a><span class="delimiter">[</span>L, Lub<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.ToList;<refinement>" title="shapeless.ops.tuple.ToList.Aux[T,Lub,List[Lub]]">Aux</a><span class="delimiter">[</span>T, Lub, List<span class="delimiter">[</span>Lub<span class="delimiter">]</span><span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.ToList.toList;$anon" title="shapeless.ops.tuple.ToList[T,Lub]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.ToList[T,Lub]" id="shapeless.ops.tuple.ToList.toList;$anon">ToList</a><span class="delimiter">[</span>T, Lub<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="List[Lub]" id="shapeless.ops.tuple.ToList.toList;$anon;Out">Out</a> = <span title="List[Lub]">List</span><span class="delimiter">[</span>Lub<span class="delimiter">]</span>
          <span class="keyword">def</span> <a title="(t: T)this.Out" id="shapeless.ops.tuple.ToList.toList;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.ToList.toList;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.ToList.toList;T" title="T">T</a><span class="delimiter">)</span>: <span title="this.Out">Out</span> = <a href="#shapeless.ops.tuple.ToList.toList.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: gen.Repr)shapeless.syntax.HListOps[gen.Repr]" class="delimiter">(</a><a href="#shapeless.ops.tuple.ToList.toList;$anon.apply.t" title="T">t</a><span class="delimiter">)</span>.<a href="../syntax/hlists.scala.html#shapeless.syntax;HListOps.toList" title="[Lub](implicit toList: shapeless.ops.hlist.ToList[gen.Repr,Lub])List[Lub]">toList</a><a href="#shapeless.ops.tuple.ToList.toList.toList" title="(implicit toList: shapeless.ops.hlist.ToList[gen.Repr,Lub])List[Lub]" class="delimiter">[</a><a href="#shapeless.ops.tuple.ToList.toList;Lub" title="Lub">Lub</a><span class="delimiter">]</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Type class supporting conversion of this tuple to an `Array` with elements typed as the least upper bound
   * of the types of the elements of this tuple.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait ToArray[T, Lub] extends AnyRef with shapeless.DepFn1[T]" id="shapeless.ops.tuple;ToArray">ToArray</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple;ToArray;T">T</a>, <a title="" id="shapeless.ops.tuple;ToArray;Lub">Lub</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="../package.scala.html#shapeless.package;DepFn1" title="shapeless.DepFn1[T]">DepFn1</a><span class="delimiter">[</span>T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.ops.tuple.ToArray.type" id="shapeless.ops.tuple.ToArray">ToArray</a> <a href="#shapeless.ops.tuple.ToArray" title="shapeless.ops.tuple.ToArray.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="ToArray[T, Lub, Out0] extends shapeless.ops.tuple.ToArray[T,Lub]" id="shapeless.ops.tuple.ToArray;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ToArray;Aux;T">T</a>, <a title="" id="shapeless.ops.tuple.ToArray;Aux;Lub">Lub</a>, <a title="" id="shapeless.ops.tuple.ToArray;Aux;Out0">Out0</a><span class="delimiter">]</span> = <a href="#shapeless.ops.tuple.ToArray;<refinement>" title="ToArray extends shapeless.ops.tuple.ToArray[T,Lub]">ToArray</a><span class="delimiter">[</span>T, Lub<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = Out0 <span class="delimiter">}</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, Lub](implicit gen: shapeless.Generic.Aux[T,L], implicit toArray: shapeless.ops.hlist.ToArray[L,Lub])shapeless.ops.tuple.ToArray.Aux[T,Lub,Array[Lub]]" id="shapeless.ops.tuple.ToArray.toArray">toArray</a><span class="delimiter">[</span><a title="" id="shapeless.ops.tuple.ToArray.toArray;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.ops.tuple.ToArray.toArray;L">L</a> &lt;: HList, <a title="" id="shapeless.ops.tuple.ToArray.toArray;Lub">Lub</a><span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[T,L]" id="shapeless.ops.tuple.ToArray.toArray.gen">gen</a>: Generic.<a href="../generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[T,L]">Aux</a><span class="delimiter">[</span>T, L<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ToArray[L,Lub]" id="shapeless.ops.tuple.ToArray.toArray.toArray">toArray</a>: hl.<a href="hlists.scala.html#shapeless.ops.hlist;ToArray" title="shapeless.ops.hlist.ToArray[L,Lub]">ToArray</a><span class="delimiter">[</span>L, Lub<span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless.ops.tuple.ToArray;<refinement>" title="shapeless.ops.tuple.ToArray.Aux[T,Lub,Array[Lub]]">Aux</a><span class="delimiter">[</span>T, Lub, Array<span class="delimiter">[</span>Lub<span class="delimiter">]</span><span class="delimiter">]</span> =
        <a href="#shapeless.ops.tuple.ToArray.toArray;$anon" title="shapeless.ops.tuple.ToArray[T,Lub]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.ops.tuple.ToArray[T,Lub]" id="shapeless.ops.tuple.ToArray.toArray;$anon">ToArray</a><span class="delimiter">[</span>T, Lub<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="Array[Lub]" id="shapeless.ops.tuple.ToArray.toArray;$anon;Out">Out</a> = <span title="Array[Lub]">Array</span><span class="delimiter">[</span>Lub<span class="delimiter">]</span>
          <span class="keyword">def</span> <a title="(t: T)this.Out" id="shapeless.ops.tuple.ToArray.toArray;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless.ops.tuple.ToArray.toArray;$anon.apply.t">t</a>: <a href="#shapeless.ops.tuple.ToArray.toArray;T" title="T">T</a><span class="delimiter">)</span>: <span title="this.Out">Out</span> = <a href="#shapeless.ops.tuple.ToArray.toArray.gen" title="shapeless.Generic.Aux[T,L]">gen</a>.<a href="../generic.scala.html#shapeless;Generic.to" title="(t: T)gen.Repr">to</a><a href="../hlists.scala.html#shapeless.HList.hlistOps" title="(l: gen.Repr)shapeless.syntax.HListOps[gen.Repr]" class="delimiter">(</a><a href="#shapeless.ops.tuple.ToArray.toArray;$anon.apply.t" title="T">t</a><span class="delimiter">)</span>.<a href="../syntax/hlists.scala.html#shapeless.syntax;HListOps.toArray" title="[Lub](implicit toArray: shapeless.ops.hlist.ToArray[gen.Repr,Lub])Array[Lub]">toArray</a><a href="#shapeless.ops.tuple.ToArray.toArray.toArray" title="(implicit toArray: shapeless.ops.hlist.ToArray[gen.Repr,Lub])Array[Lub]" class="delimiter">[</a><a href="#shapeless.ops.tuple.ToArray.toArray;Lub" title="Lub">Lub</a><span class="delimiter">]</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span title="AnyRef" class="delimiter">}</span>

        </pre>
    </body>
</html>
