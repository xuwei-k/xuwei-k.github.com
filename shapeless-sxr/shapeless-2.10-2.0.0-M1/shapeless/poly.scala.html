<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>shapeless/poly.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (c) 2011-13 Miles Sabin 
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span class="keyword">package</span> shapeless

<span class="keyword">import</span> <span title="language.type">language</span>.existentials
<span class="keyword">import</span> <span title="language.type">language</span>.<span title="language.experimental.type">experimental</span>.macros
 
<span class="keyword">import</span> reflect.macros.Context

<span class="comment">// Typically the contents of this object will be imported via val alias `poly` in the shapeless package object.</span>
<span class="keyword">object</span> <a title="shapeless.PolyDefns.type" id="shapeless.PolyDefns">PolyDefns</a> <a href="#shapeless.PolyDefns" title="shapeless.PolyDefns.type" class="keyword">extends</a> <a href="../cases.scala.html#shapeless;Cases" title="shapeless.Cases">Cases</a> <span class="delimiter">{</span>
  <span class="comment">/**
   * Type-specific case of a polymorphic function.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Case[P, L &lt;: shapeless.HList] extends AnyRef" id="shapeless.PolyDefns;Case">Case</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns;Case;P">P</a>, <a title=" &lt;: shapeless.HList" id="shapeless.PolyDefns;Case;L">L</a> &lt;: HList<span class="delimiter">]</span> <a href="#shapeless.PolyDefns;Case" title="shapeless.PolyDefns.Case[P,L]" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="" id="shapeless.PolyDefns;Case;Result">Result</a>
    <span class="keyword">val</span> <a title="=&gt; L =&gt; Case.this.Result" id="shapeless.PolyDefns;Case.value">value</a> : L =&gt; Result
    
    <span class="keyword">def</span> <a title="(t: L)Case.this.Result" id="shapeless.PolyDefns;Case.apply(6d3de82686)">apply</a><span class="delimiter">(</span><a title="L" id="shapeless.PolyDefns;Case.apply(6d3de82686).t">t</a> : <a href="#shapeless.PolyDefns;Case;L" title="L">L</a><span class="delimiter">)</span> = <a href="#shapeless.PolyDefns;Case.value" title="(v1: L)Case.this.Result">value</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns;Case.apply(6d3de82686).t" title="L">t</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="()(implicit ev: =:=[shapeless.HNil,L])Case.this.Result" id="shapeless.PolyDefns;Case.apply(7c1fd49f38)">apply</a><span class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="=:=[shapeless.HNil,L]" id="shapeless.PolyDefns;Case.apply(7c1fd49f38).ev">ev</a>: HNil <span title="=:=[shapeless.HNil,L]">=:=</span> L<span class="delimiter">)</span> = <a href="#shapeless.PolyDefns;Case.value" title="(v1: L)Case.this.Result">value</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns;Case.apply(7c1fd49f38).ev" title="(v1: shapeless.HNil)L">HNil</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[T](t: T)(implicit ev: =:=[shapeless.::[T,shapeless.HNil],L])Case.this.Result" id="shapeless.PolyDefns;Case.apply(9484e74010)">apply</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns;Case.apply(9484e74010);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="shapeless.PolyDefns;Case.apply(9484e74010).t">t</a>: <a href="#shapeless.PolyDefns;Case.apply(9484e74010);T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="=:=[shapeless.::[T,shapeless.HNil],L]" id="shapeless.PolyDefns;Case.apply(9484e74010).ev">ev</a>: <span class="delimiter">(</span>T :: HNil<span class="delimiter">)</span> <span title="=:=[shapeless.::[T,shapeless.HNil],L]">=:=</span> L<span class="delimiter">)</span> = <a href="#shapeless.PolyDefns;Case.value" title="(v1: L)Case.this.Result">value</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns;Case.apply(9484e74010).t" title="T">t</a> <a href="#shapeless.PolyDefns;Case.apply(9484e74010).ev" title="(v1: shapeless.::[T,shapeless.HNil])L">::</a> <a href="hlists.scala.html#shapeless.HNil" title="shapeless.HNil.type">HNil</a><span class="delimiter">)</span>
    <span class="keyword">def</span> <a title="[T, U](t: T, u: U)(implicit ev: =:=[shapeless.::[T,shapeless.::[U,shapeless.HNil]],L])Case.this.Result" id="shapeless.PolyDefns;Case.apply(42bbc93130)">apply</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns;Case.apply(42bbc93130);T">T</a>, <a title="" id="shapeless.PolyDefns;Case.apply(42bbc93130);U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="shapeless.PolyDefns;Case.apply(42bbc93130).t">t</a>: <a href="#shapeless.PolyDefns;Case.apply(42bbc93130);T" title="T">T</a>, <a title="U" id="shapeless.PolyDefns;Case.apply(42bbc93130).u">u</a>: <a href="#shapeless.PolyDefns;Case.apply(42bbc93130);U" title="U">U</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="=:=[shapeless.::[T,shapeless.::[U,shapeless.HNil]],L]" id="shapeless.PolyDefns;Case.apply(42bbc93130).ev">ev</a>: <span class="delimiter">(</span>T :: U :: HNil<span class="delimiter">)</span> <span title="=:=[shapeless.::[T,shapeless.::[U,shapeless.HNil]],L]">=:=</span> L<span class="delimiter">)</span> = <a href="#shapeless.PolyDefns;Case.value" title="(v1: L)Case.this.Result">value</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns;Case.apply(42bbc93130).t" title="T">t</a> <a href="#shapeless.PolyDefns;Case.apply(42bbc93130).ev" title="(v1: shapeless.::[T,shapeless.::[U,shapeless.HNil]])L">::</a> <a href="#shapeless.PolyDefns;Case.apply(42bbc93130).u" title="U">u</a> <a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: shapeless.::[U,shapeless.HNil])shapeless.syntax.HListOps[shapeless.::[U,shapeless.HNil]]">::</a> <a href="hlists.scala.html#shapeless.HNil" title="shapeless.HNil.type">HNil</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="shapeless.PolyDefns.Case.type" id="shapeless.PolyDefns.Case">Case</a> <a href="#shapeless.PolyDefns.Case" title="shapeless.PolyDefns.Case.type" class="keyword">extends</a> <a href="../caseinst.scala.html#shapeless;CaseInst" title="shapeless.CaseInst">CaseInst</a> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="Case[P, L &lt;: shapeless.HList, Result0] extends shapeless.PolyDefns.Case[P,L]" id="shapeless.PolyDefns.Case;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.Case;Aux;P">P</a>, <a title=" &lt;: shapeless.HList" id="shapeless.PolyDefns.Case;Aux;L">L</a> &lt;: HList, <a title="" id="shapeless.PolyDefns.Case;Aux;Result0">Result0</a><span class="delimiter">]</span> = <a href="#shapeless.PolyDefns.Case;<refinement>" title="Case extends shapeless.PolyDefns.Case[P,L]">Case</a><span class="delimiter">[</span>P, L<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Result = Result0 <span class="delimiter">}</span>
    <span class="keyword">type</span> <a title="[P, T]shapeless.PolyDefns.Case.Aux[P,shapeless.::[T,shapeless.HNil],T]" id="shapeless.PolyDefns.Case;Hom">Hom</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.Case;Hom;P">P</a>, <a title="" id="shapeless.PolyDefns.Case;Hom;T">T</a><span class="delimiter">]</span> = <a href="#shapeless.PolyDefns.Case;<refinement>" title="shapeless.PolyDefns.Case.Aux[P,shapeless.::[T,shapeless.HNil],T]">Aux</a><span class="delimiter">[</span>P, T :: HNil, T<span class="delimiter">]</span>
    
    <span class="keyword">def</span> <a title="[P, L &lt;: shapeless.HList, R](v: L =&gt; R)shapeless.PolyDefns.Case.Aux[P,L,R]" id="shapeless.PolyDefns.Case.apply">apply</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.Case.apply;P">P</a>, <a title=" &lt;: shapeless.HList" id="shapeless.PolyDefns.Case.apply;L">L</a> &lt;: HList, <a title="" id="shapeless.PolyDefns.Case.apply;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="L =&gt; R" id="shapeless.PolyDefns.Case.apply.v">v</a> : L =&gt; R<span class="delimiter">)</span>: <a href="#shapeless.PolyDefns.Case;<refinement>" title="shapeless.PolyDefns.Case.Aux[P,L,R]">Aux</a><span class="delimiter">[</span>P, L, R<span class="delimiter">]</span> = <a href="#shapeless.PolyDefns.Case.apply;$anon" title="shapeless.PolyDefns.Case[P,L]{}" class="keyword">new</a> <a title="anonymous class $anon extends shapeless.PolyDefns.Case[P,L]" id="shapeless.PolyDefns.Case.apply;$anon">Case</a><span class="delimiter">[</span>P, L<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="R" id="shapeless.PolyDefns.Case.apply;$anon;Result">Result</a> = <a href="#shapeless.PolyDefns.Case.apply;R" title="R">R</a>
      <span class="keyword">val</span> <a title="L =&gt; R" id="shapeless.PolyDefns.Case.apply;$anon.value">value</a> = <a href="#shapeless.PolyDefns.Case.apply.v" title="L =&gt; R">v</a>
    <span class="delimiter">}</span>

    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[P, L &lt;: shapeless.HList]=&gt; shapeless.PolyDefns.Case[P,L]" id="shapeless.PolyDefns.Case.materializeFromValue">materializeFromValue</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.Case.materializeFromValue;P">P</a>, <a title=" &lt;: shapeless.HList" id="shapeless.PolyDefns.Case.materializeFromValue;L">L</a> &lt;: HList<span class="delimiter">]</span> = macro <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl" title="[P, L &lt;: shapeless.HList](c: scala.reflect.macros.Context)(implicit evidence$1: c.WeakTypeTag[P], implicit evidence$2: c.WeakTypeTag[L])c.Expr[shapeless.PolyDefns.Case[P,L]]">materializeFromValueImpl</a><span title="(c: scala.reflect.macros.Context)(implicit evidence$1: c.WeakTypeTag[P], implicit evidence$2: c.WeakTypeTag[L])c.Expr[shapeless.PolyDefns.Case[P,L]]" class="delimiter">[</span><a href="#shapeless.PolyDefns.Case.materializeFromValue;P" title="P">P</a>, <a href="#shapeless.PolyDefns.Case.materializeFromValue;L" title="L">L</a><span class="delimiter">]</span>

    <span class="keyword">def</span> <a title="[P, L &lt;: shapeless.HList](c: scala.reflect.macros.Context)(implicit evidence$1: c.WeakTypeTag[P], implicit evidence$2: c.WeakTypeTag[L])c.Expr[shapeless.PolyDefns.Case[P,L]]" id="shapeless.PolyDefns.Case.materializeFromValueImpl">materializeFromValueImpl</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.Case.materializeFromValueImpl;P">P</a>: c.WeakTypeTag, <a title=" &lt;: shapeless.HList" id="shapeless.PolyDefns.Case.materializeFromValueImpl;L">L</a> &lt;: HList: c.WeakTypeTag<span class="delimiter">]</span><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="shapeless.PolyDefns.Case.materializeFromValueImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span>: c.<span title="c.Expr[shapeless.PolyDefns.Case[P,L]]">Expr</span><span class="delimiter">[</span>Case<span class="delimiter">[</span>P, L<span class="delimiter">]</span><span class="delimiter">]</span> = <span class="delimiter">{</span>
      <span class="keyword">import</span> <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._

      <span class="keyword">val</span> <a title="c.universe.Type" id="shapeless.PolyDefns.Case.materializeFromValueImpl.pTpe">pTpe</a> = <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.evidence$1" title="(implicit attag: c.universe.WeakTypeTag[P])c.universe.Type" class="delimiter">[</a><a href="#shapeless.PolyDefns.Case.materializeFromValueImpl;P" title="P">P</a><span class="delimiter">]</span>
      <span class="keyword">val</span> <a title="c.universe.Type" id="shapeless.PolyDefns.Case.materializeFromValueImpl.lTpe">lTpe</a> = <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.evidence$2" title="(implicit attag: c.universe.WeakTypeTag[L])c.universe.Type" class="delimiter">[</a><a href="#shapeless.PolyDefns.Case.materializeFromValueImpl;L" title="L">L</a><span class="delimiter">]</span>

      <span class="keyword">val</span> <a title="c.universe.Type" id="shapeless.PolyDefns.Case.materializeFromValueImpl.recTpe">recTpe</a> = <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="[T](implicit attag: c.universe.WeakTypeTag[T])c.universe.Type">weakTypeOf</a><a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="(implicit attag: c.universe.WeakTypeTag[shapeless.PolyDefns.Case[P,L]])c.universe.Type" id="shapeless.PolyDefns.Case.materializeFromValueImpl.recTpe;$typecreator1.apply.$m" class="delimiter">[</a><a href="#shapeless.PolyDefns;Case" title="shapeless.PolyDefns.Case[P,L]">Case</a><span class="delimiter">[</span>P, L<span class="delimiter">]</span><span class="delimiter">]</span>
      <span title="Unit" class="keyword">if</span><span class="delimiter">(</span><a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; List[(c.Type, c.Tree)]">openImplicits</span>.<span title="=&gt; List[(c.Type, c.Tree)]">tail</span>.<span title="(p: ((c.Type, c.Tree)) =&gt; Boolean)Boolean">exists</span><span class="delimiter">(</span><a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.$anonfun.x$4" title="(c.Type, c.Tree)">_</a>.<span title="=&gt; c.Type">_1</span> <span title="(that: c.universe.Type)Boolean">=:=</span> <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.recTpe" title="c.universe.Type">recTpe</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Diverging implicit expansion for Case[&quot;)">Diverging implicit expansion for Case[$</span><a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.pTpe" title="c.universe.Type">pTpe</a><span title="String(&quot;, &quot;)">, $</span><a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.lTpe" title="c.universe.Type">lTpe</a><span title="String(&quot;]&quot;)" class="string">]&quot;</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="c.universe.ClassSymbol" id="shapeless.PolyDefns.Case.materializeFromValueImpl.caseAuxSym">caseAuxSym</a> = <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.universe.Mirror">mirror</span>.<span title="(fullName: String)c.universe.ClassSymbol">staticClass</span><span class="delimiter">(</span><span title="String(&quot;shapeless.PolyDefns.Case&quot;)" class="string">&quot;shapeless.PolyDefns.Case&quot;</span><span class="delimiter">)</span>

      <span class="keyword">val</span> <a title="c.universe.Symbol" id="shapeless.PolyDefns.Case.materializeFromValueImpl.value">value</a> = <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.pTpe" title="c.universe.Type">pTpe</a> <span title="c.universe.Symbol" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="(tpe: c.universe.SingleType)Option[(c.universe.Type, c.universe.Symbol)]">SingleType</a><a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="(x: Any)Option[c.universe.SingleType]" class="delimiter">(</a>_, <a title="c.universe.Symbol" id="shapeless.PolyDefns.Case.materializeFromValueImpl.value.f">f</a><span class="delimiter">)</span> =&gt; <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.value.f" title="c.universe.Symbol">f</a>
        <span class="keyword">case</span> <a title="c.universe.Type" id="shapeless.PolyDefns.Case.materializeFromValueImpl.value.other">other</a>            =&gt; <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;Can only materialize cases from singleton values&quot;)" class="string">&quot;Can only materialize cases from singleton values&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[shapeless.PolyDefns.Case[P,L]])c.Expr[shapeless.PolyDefns.Case[P,L]]" class="delimiter">[</span><a href="#shapeless.PolyDefns;Case" title="shapeless.PolyDefns.Case[P,L]">Case</a><span class="delimiter">[</span>P, L<span class="delimiter">]</span><span class="delimiter">]</span> <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="c.universe.type" id="shapeless.PolyDefns.Case.materializeFromValueImpl;$typecreator2.apply.$m" class="delimiter">{</a>
        <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.value" title="c.universe.Symbol">value</a><span class="delimiter">)</span>, <a href="#shapeless.PolyDefns.Case.materializeFromValueImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;caseUniv&quot;)" class="string">&quot;caseUniv&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">type</span> <a title="[P]shapeless.PolyDefns.Case[P,shapeless.HNil]" id="shapeless.PolyDefns;Case0">Case0</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns;Case0;P">P</a><span class="delimiter">]</span> = <a href="#shapeless.PolyDefns;Case" title="shapeless.PolyDefns.Case[P,shapeless.HNil]">Case</a><span class="delimiter">[</span>P, HNil<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="shapeless.PolyDefns.Case0.type" id="shapeless.PolyDefns.Case0">Case0</a> <a href="#shapeless.PolyDefns.Case0" title="shapeless.PolyDefns.Case0.type" class="delimiter">{</a>
    <span class="keyword">type</span> <a title="[P, T]shapeless.PolyDefns.Case.Aux[P,shapeless.HNil,T]" id="shapeless.PolyDefns.Case0;Aux">Aux</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.Case0;Aux;P">P</a>, <a title="" id="shapeless.PolyDefns.Case0;Aux;T">T</a><span class="delimiter">]</span> = Case.<a href="#shapeless.PolyDefns.Case;<refinement>" title="shapeless.PolyDefns.Case.Aux[P,shapeless.HNil,T]">Aux</a><span class="delimiter">[</span>P, HNil, T<span class="delimiter">]</span>
    <span class="keyword">def</span> <a title="[P, T](v: T)shapeless.PolyDefns.Case0.Aux[P,T]" id="shapeless.PolyDefns.Case0.apply">apply</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.Case0.apply;P">P</a>, <a title="" id="shapeless.PolyDefns.Case0.apply;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="shapeless.PolyDefns.Case0.apply.v">v</a> : <a href="#shapeless.PolyDefns.Case0.apply;T" title="T">T</a><span class="delimiter">)</span>: <a href="#shapeless.PolyDefns.Case;<refinement>" title="shapeless.PolyDefns.Case0.Aux[P,T]">Aux</a><span class="delimiter">[</span>P, T<span class="delimiter">]</span> = <a href="#shapeless.PolyDefns.Case0.apply;$anon" title="shapeless.PolyDefns.Case[P,shapeless.HNil]{}" class="keyword">new</a> <a title="anonymous class $anon extends shapeless.PolyDefns.Case[P,shapeless.HNil]" id="shapeless.PolyDefns.Case0.apply;$anon">Case</a><span class="delimiter">[</span>P, HNil<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="T" id="shapeless.PolyDefns.Case0.apply;$anon;Result">Result</a> = <a href="#shapeless.PolyDefns.Case0.apply;T" title="T">T</a>
      <span class="keyword">val</span> <a title="shapeless.HNil =&gt; T" id="shapeless.PolyDefns.Case0.apply;$anon.value">value</a> = <span class="delimiter">(</span>l : <a href="hlists.scala.html#shapeless;HNil" title="shapeless.HNil">HNil</a><span class="delimiter">)</span> =&gt; <a href="#shapeless.PolyDefns.Case0.apply.v" title="T">v</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Represents the composition of two polymorphic function values.
   *  
   * @author Miles Sabin
   */</span>
  <span class="keyword">class</span> <a title="class Compose[F, G] extends AnyRef with shapeless.Poly" id="shapeless.PolyDefns;Compose">Compose</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns;Compose;F">F</a>, <a title="" id="shapeless.PolyDefns;Compose;G">G</a><span class="delimiter">]</span><a href="#shapeless.PolyDefns;Compose" title="shapeless.PolyDefns.Compose[F,G]" class="delimiter">(</a><a title="F" id="shapeless.PolyDefns;Compose.f">f</a> : <a href="#shapeless.PolyDefns;Compose;F" title="F">F</a>, <a title="G" id="shapeless.PolyDefns;Compose.g">g</a> : <a href="#shapeless.PolyDefns;Compose;G" title="G">G</a><span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#shapeless;Poly" title="shapeless.Poly">Poly</a>

  <span class="keyword">object</span> <a title="shapeless.PolyDefns.Compose.type" id="shapeless.PolyDefns.Compose">Compose</a> <a href="#shapeless.PolyDefns.Compose" title="shapeless.PolyDefns.Compose.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, F &lt;: shapeless.Poly, G &lt;: shapeless.Poly, T, U, V](implicit unpack: shapeless.Unpack2[C,shapeless.PolyDefns.Compose,F,G], implicit cG: shapeless.PolyDefns.Case1.Aux[G,T,U], implicit cF: shapeless.PolyDefns.Case1.Aux[F,U,V])shapeless.PolyDefns.Case[C,shapeless.::[T,shapeless.HNil]]{type Result = V}" id="shapeless.PolyDefns.Compose.composeCase">composeCase</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.Compose.composeCase;C">C</a>, <a title=" &lt;: shapeless.Poly" id="shapeless.PolyDefns.Compose.composeCase;F">F</a> &lt;: Poly, <a title=" &lt;: shapeless.Poly" id="shapeless.PolyDefns.Compose.composeCase;G">G</a> &lt;: Poly, <a title="" id="shapeless.PolyDefns.Compose.composeCase;T">T</a>, <a title="" id="shapeless.PolyDefns.Compose.composeCase;U">U</a>, <a title="" id="shapeless.PolyDefns.Compose.composeCase;V">V</a><span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Unpack2[C,shapeless.PolyDefns.Compose,F,G]" id="shapeless.PolyDefns.Compose.composeCase.unpack">unpack</a>: <a href="typeoperators.scala.html#shapeless;Unpack2" title="shapeless.Unpack2[C,shapeless.PolyDefns.Compose,F,G]">Unpack2</a><span class="delimiter">[</span>C, Compose, F, G<span class="delimiter">]</span>, <a title="shapeless.PolyDefns.Case1.Aux[G,T,U]" id="shapeless.PolyDefns.Compose.composeCase.cG">cG</a> : Case1.<a href="../cases.scala.html#shapeless;Cases.Case1;<refinement>" title="shapeless.PolyDefns.Case1.Aux[G,T,U]">Aux</a><span class="delimiter">[</span>G, T, U<span class="delimiter">]</span>, <a title="shapeless.PolyDefns.Case1.Aux[F,U,V]" id="shapeless.PolyDefns.Compose.composeCase.cF">cF</a> : Case1.<a href="../cases.scala.html#shapeless;Cases.Case1;<refinement>" title="shapeless.PolyDefns.Case1.Aux[F,U,V]">Aux</a><span class="delimiter">[</span>F, U, V<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.PolyDefns.Compose.composeCase;$anon" title="shapeless.PolyDefns.Case[C,shapeless.::[T,shapeless.HNil]]{}" class="keyword">new</a> <a title="anonymous class $anon extends shapeless.PolyDefns.Case[C,shapeless.::[T,shapeless.HNil]]" id="shapeless.PolyDefns.Compose.composeCase;$anon">Case</a><span class="delimiter">[</span>C, T :: HNil<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="V" id="shapeless.PolyDefns.Compose.composeCase;$anon;Result">Result</a> = <a href="#shapeless.PolyDefns.Compose.composeCase;V" title="V">V</a>
      <span class="keyword">val</span> <a title="shapeless.::[T,shapeless.HNil] =&gt; cF.Result" id="shapeless.PolyDefns.Compose.composeCase;$anon.value">value</a> = <span class="delimiter">(</span>t : T <a href="hlists.scala.html#shapeless;::" title="shapeless.::[T,shapeless.HNil]">::</a> HNil<span class="delimiter">)</span> =&gt; <a href="#shapeless.PolyDefns;Case.apply(9484e74010)" title="(t: cG.Result)(implicit ev: =:=[shapeless.::[cG.Result,shapeless.HNil],shapeless.::[U,shapeless.HNil]])cF.Result">cF</a><span title="=:=[shapeless.::[U,shapeless.HNil],shapeless.::[U,shapeless.HNil]]" class="delimiter">(</span><a href="#shapeless.PolyDefns.Compose.composeCase.cG" title="shapeless.PolyDefns.Case1.Aux[G,T,U]">cG</a>.<a href="#shapeless.PolyDefns;Case.value" title="(v1: shapeless.::[T,shapeless.HNil])cG.Result">value</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns.Compose.composeCase;$anon.value.$anonfun.t" title="shapeless.::[T,shapeless.HNil]">t</a><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Base class for lifting a `Function1` to a `Poly1`
   */</span>
  <span class="keyword">class</span> <a title="class -&gt;[T, R] extends AnyRef with shapeless.Poly1" id="shapeless.PolyDefns;->">-&gt;</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns;->;T">T</a>, <a title="" id="shapeless.PolyDefns;->;R">R</a><span class="delimiter">]</span><a href="#shapeless.PolyDefns;->" title="shapeless.PolyDefns.-&gt;[T,R]" class="delimiter">(</a><a title="T =&gt; R" id="shapeless.PolyDefns;->.f">f</a> : T =&gt; R<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="../polyntraits.scala.html#shapeless;Poly1" title="shapeless.Poly1">Poly1</a> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[U &lt;: T]=&gt; -&gt;.this.Case[U]{type Result = R}" id="shapeless.PolyDefns;->.subT">subT</a><span class="delimiter">[</span><a title=" &lt;: T" id="shapeless.PolyDefns;->.subT;U">U</a> &lt;: T<span class="delimiter">]</span> = <a href="../polyntraits.scala.html#shapeless;Poly1.at" title="[A]=&gt; -&gt;.this.CaseBuilder[A]">at</a><a href="../polyntraits.scala.html#shapeless;Poly1;CaseBuilder.apply" title="(fn: U =&gt; R)-&gt;.this.Case[U]{type Result = R}" class="delimiter">[</a><a href="#shapeless.PolyDefns;->.subT;U" title="U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless.PolyDefns;->.f" title="T =&gt; R">f</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait LowPriorityLiftFunction1 extends AnyRef with shapeless.Poly1" id="shapeless.PolyDefns;LowPriorityLiftFunction1">LowPriorityLiftFunction1</a> <span title="Unit" class="keyword">extends</span> <a href="../polyntraits.scala.html#shapeless;Poly1" title="shapeless.Poly1">Poly1</a> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T]=&gt; LowPriorityLiftFunction1.this.Case[T]{type Result = shapeless.HNil}" id="shapeless.PolyDefns;LowPriorityLiftFunction1.default">default</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns;LowPriorityLiftFunction1.default;T">T</a><span class="delimiter">]</span> = <a href="../polyntraits.scala.html#shapeless;Poly1.at" title="[A]=&gt; LowPriorityLiftFunction1.this.CaseBuilder[A]">at</a><a href="../polyntraits.scala.html#shapeless;Poly1;CaseBuilder.apply" title="(fn: T =&gt; shapeless.HNil)LowPriorityLiftFunction1.this.Case[T]{type Result = shapeless.HNil}" class="delimiter">[</a><a href="#shapeless.PolyDefns;LowPriorityLiftFunction1.default;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="shapeless.PolyDefns;LowPriorityLiftFunction1.default.$anonfun.x$5">_</a> =&gt; <a href="hlists.scala.html#shapeless.HNil" title="shapeless.HNil.type">HNil</a> : <a href="hlists.scala.html#shapeless;HNil" title="shapeless.HNil">HNil</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Base class for lifting a `Function1` to a `Poly1` over the universal domain, yielding an `HList` with the result as
   * its only element if the argument is in the original functions domain, `HNil` otherwise. 
   */</span>
  <span class="keyword">class</span> <a title="class &gt;-&gt;[T, R] extends AnyRef with shapeless.PolyDefns.LowPriorityLiftFunction1" id="shapeless.PolyDefns;>->">&gt;-&gt;</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns;>->;T">T</a>, <a title="" id="shapeless.PolyDefns;>->;R">R</a><span class="delimiter">]</span><a href="#shapeless.PolyDefns;>->" title="shapeless.PolyDefns.&gt;-&gt;[T,R]" class="delimiter">(</a><a title="T =&gt; R" id="shapeless.PolyDefns;>->.f">f</a> : T =&gt; R<span class="delimiter">)</span> <span class="keyword">extends</span> <a href="#shapeless.PolyDefns;LowPriorityLiftFunction1" title="shapeless.PolyDefns.LowPriorityLiftFunction1">LowPriorityLiftFunction1</a> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[U &lt;: T]=&gt; &gt;-&gt;.this.Case[U]{type Result = shapeless.::[R,shapeless.HNil]}" id="shapeless.PolyDefns;>->.subT">subT</a><span class="delimiter">[</span><a title=" &lt;: T" id="shapeless.PolyDefns;>->.subT;U">U</a> &lt;: T<span class="delimiter">]</span> = <a href="../polyntraits.scala.html#shapeless;Poly1.at" title="[A]=&gt; &gt;-&gt;.this.CaseBuilder[A]">at</a><a href="../polyntraits.scala.html#shapeless;Poly1;CaseBuilder.apply" title="(fn: U =&gt; shapeless.::[R,shapeless.HNil])&gt;-&gt;.this.Case[U]{type Result = shapeless.::[R,shapeless.HNil]}" class="delimiter">[</a><a href="#shapeless.PolyDefns;>->.subT;U" title="U">U</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless.PolyDefns;>->.f" title="(v1: T)R">f</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns;>->.subT.$anonfun.x$6" title="U">_</a><span class="delimiter">)</span> <a href="hlists.scala.html#shapeless;HNil.::" title="(h: R)shapeless.::[R,shapeless.HNil]">::</a> <a href="hlists.scala.html#shapeless.HNil" title="shapeless.HNil.type">HNil</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait LowPriorityLiftU extends AnyRef with shapeless.Poly" id="shapeless.PolyDefns;LowPriorityLiftU">LowPriorityLiftU</a> <span title="Unit" class="keyword">extends</span> <a href="#shapeless;Poly" title="shapeless.Poly">Poly</a> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[L &lt;: shapeless.HList]=&gt; LowPriorityLiftU.this.ProductCase[L]{type Result = shapeless.HNil; val value: L =&gt; shapeless.HNil.type}" id="shapeless.PolyDefns;LowPriorityLiftU.default">default</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.PolyDefns;LowPriorityLiftU.default;L">L</a> &lt;: HList<span class="delimiter">]</span> = <a href="#shapeless.PolyDefns;LowPriorityLiftU.default;$anon" title="LowPriorityLiftU.this.ProductCase[L]{}" class="keyword">new</a> <a title="anonymous class $anon extends LowPriorityLiftU.this.ProductCase[L]" id="shapeless.PolyDefns;LowPriorityLiftU.default;$anon">ProductCase</a><span class="delimiter">[</span>L<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="shapeless.HNil" id="shapeless.PolyDefns;LowPriorityLiftU.default;$anon;Result">Result</a> = <a href="hlists.scala.html#shapeless;HNil" title="shapeless.HNil">HNil</a>
      <span class="keyword">val</span> <a title="L =&gt; shapeless.HNil.type" id="shapeless.PolyDefns;LowPriorityLiftU.default;$anon.value">value</a> = <span class="delimiter">(</span>l : <a href="#shapeless.PolyDefns;LowPriorityLiftU.default;L" title="L">L</a><span class="delimiter">)</span> =&gt; <a href="hlists.scala.html#shapeless.HNil" title="shapeless.HNil.type">HNil</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Base class for lifting a `Poly` to a `Poly` over the universal domain, yielding an `HList` with the result as it's
   * only element if the argument is in the original functions domain, `HNil` otherwise. 
   */</span>
  <span class="keyword">class</span> <a title="class LiftU[P &lt;: shapeless.Poly] extends AnyRef with shapeless.PolyDefns.LowPriorityLiftU" id="shapeless.PolyDefns;LiftU">LiftU</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Poly" id="shapeless.PolyDefns;LiftU;P">P</a> &lt;: Poly<span class="delimiter">]</span><a href="#shapeless.PolyDefns;LiftU" title="shapeless.PolyDefns.LiftU[P]" class="delimiter">(</a><a title="P" id="shapeless.PolyDefns;LiftU.p">p</a> : <a href="#shapeless.PolyDefns;LiftU;P" title="P">P</a><span class="delimiter">)</span>  <span class="keyword">extends</span> <a href="#shapeless.PolyDefns;LowPriorityLiftU" title="shapeless.PolyDefns.LowPriorityLiftU">LowPriorityLiftU</a> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[L &lt;: shapeless.HList](implicit caseT: shapeless.PolyDefns.Case[P,L])LiftU.this.ProductCase[L]{type Result = shapeless.::[caseT.Result,shapeless.HNil]}" id="shapeless.PolyDefns;LiftU.defined">defined</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.PolyDefns;LiftU.defined;L">L</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.PolyDefns.Case[P,L]" id="shapeless.PolyDefns;LiftU.defined.caseT">caseT</a> : <a href="#shapeless.PolyDefns;Case" title="shapeless.PolyDefns.Case[P,L]">Case</a><span class="delimiter">[</span>P, L<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.PolyDefns;LiftU.defined;$anon" title="LiftU.this.ProductCase[L]{}" class="keyword">new</a> <a title="anonymous class $anon extends LiftU.this.ProductCase[L]" id="shapeless.PolyDefns;LiftU.defined;$anon">ProductCase</a><span class="delimiter">[</span>L<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="shapeless.::[caseT.Result,shapeless.HNil]" id="shapeless.PolyDefns;LiftU.defined;$anon;Result">Result</a> = caseT.Result <a href="hlists.scala.html#shapeless;::" title="shapeless.::[caseT.Result,shapeless.HNil]">::</a> HNil
      <span class="keyword">val</span> <a title="L =&gt; shapeless.::[caseT.Result,shapeless.HNil]" id="shapeless.PolyDefns;LiftU.defined;$anon.value">value</a> = <span class="delimiter">(</span>l : <a href="#shapeless.PolyDefns;LiftU.defined;L" title="L">L</a><span class="delimiter">)</span> =&gt; <a href="#shapeless.PolyDefns;Case.apply(6d3de82686)" title="(t: L)caseT.Result">caseT</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns;LiftU.defined;$anon.value.$anonfun.l" title="L">l</a><span class="delimiter">)</span> <a href="hlists.scala.html#shapeless;HNil.::" title="(h: caseT.Result)shapeless.::[caseT.Result,shapeless.HNil]">::</a> <a href="hlists.scala.html#shapeless.HNil" title="shapeless.HNil.type">HNil</a>
    <span class="delimiter">}</span> 
  <span class="delimiter">}</span>

  <span class="comment">/**
   * Base trait for natural transformations.
   * 
   * @author Miles Sabin
   */</span>
  <span class="keyword">trait</span> <a title="trait ~&gt;[F[_], G[_]] extends AnyRef with shapeless.Poly1" id="shapeless.PolyDefns;~>">~&gt;</a><span class="delimiter">[</span><a title="[_]" id="shapeless.PolyDefns;~>;F">F</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns;~>;F;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="shapeless.PolyDefns;~>;G">G</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns;~>;G;_">_</a><span class="delimiter">]</span><span class="delimiter">]</span> <span title="Unit" class="keyword">extends</span> <a href="../polyntraits.scala.html#shapeless;Poly1" title="shapeless.Poly1">Poly1</a> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[T](f: F[T])G[T]" id="shapeless.PolyDefns;~>.apply(efb2a18dfd)">apply</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns;~>.apply(efb2a18dfd);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="F[T]" id="shapeless.PolyDefns;~>.apply(efb2a18dfd).f">f</a> : <a href="#shapeless.PolyDefns;~>;F" title="F[T]">F</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#shapeless.PolyDefns;~>;G" title="G[T]">G</a><span class="delimiter">[</span>T<span class="delimiter">]</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T]=&gt; ~&gt;.this.Case[F[T]]{type Result = G[T]}" id="shapeless.PolyDefns;~>.caseUniv">caseUniv</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns;~>.caseUniv;T">T</a><span class="delimiter">]</span> = <a href="../polyntraits.scala.html#shapeless;Poly1.at" title="[A]=&gt; ~&gt;.this.CaseBuilder[A]">at</a><a href="../polyntraits.scala.html#shapeless;Poly1;CaseBuilder.apply" title="(fn: F[T] =&gt; G[T])~&gt;.this.Case[F[T]]{type Result = G[T]}" class="delimiter">[</a><a href="#shapeless.PolyDefns;~>;F" title="F[T]">F</a><span class="delimiter">[</span>T<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless.PolyDefns;~>.apply(efb2a18dfd)" title="(f: F[T])G[T]">apply</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns;~>.caseUniv.$anonfun.x$9" title="F[T]">_</a><span class="delimiter">)</span><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="keyword">object</span> <a title="shapeless.PolyDefns.~&gt;.type" id="shapeless.PolyDefns.~>">~&gt;</a> <a href="#shapeless.PolyDefns.~>" title="shapeless.PolyDefns.~&gt;.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[F[_], G[_], T](f: shapeless.PolyDefns.~&gt;[F,G])F[T] =&gt; G[T]" id="shapeless.PolyDefns.~>.inst1">inst1</a><span class="delimiter">[</span><a title="[_]" id="shapeless.PolyDefns.~>.inst1;F">F</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.~>.inst1;F;_">_</a><span class="delimiter">]</span>, <a title="[_]" id="shapeless.PolyDefns.~>.inst1;G">G</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.~>.inst1;G;_">_</a><span class="delimiter">]</span>, <a title="" id="shapeless.PolyDefns.~>.inst1;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="shapeless.PolyDefns.~&gt;[F,G]" id="shapeless.PolyDefns.~>.inst1.f">f</a> : F <a href="#shapeless.PolyDefns;~>" title="shapeless.PolyDefns.~&gt;[F,G]">~&gt;</a> G<span class="delimiter">)</span> : F<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; G<span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#shapeless.PolyDefns;~>.apply(efb2a18dfd)" title="(f: F[T])G[T]">f</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns.~>.inst1.$anonfun.x$10" title="F[T]">_</a><span class="delimiter">)</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[G[_], T](f: shapeless.PolyDefns.~&gt;[shapeless.Id,G])T =&gt; G[T]" id="shapeless.PolyDefns.~>.inst2">inst2</a><span class="delimiter">[</span><a title="[_]" id="shapeless.PolyDefns.~>.inst2;G">G</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.~>.inst2;G;_">_</a><span class="delimiter">]</span>, <a title="" id="shapeless.PolyDefns.~>.inst2;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="shapeless.PolyDefns.~&gt;[shapeless.Id,G]" id="shapeless.PolyDefns.~>.inst2.f">f</a> : Id <a href="#shapeless.PolyDefns;~>" title="shapeless.PolyDefns.~&gt;[shapeless.Id,G]">~&gt;</a> G<span class="delimiter">)</span> : T =&gt; G<span class="delimiter">[</span>T<span class="delimiter">]</span> = <a href="#shapeless.PolyDefns;~>.apply(efb2a18dfd)" title="(f: shapeless.Id[T])G[T]">f</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns.~>.inst2.$anonfun.x$11" title="T">_</a><span class="delimiter">)</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[F[_], T](f: shapeless.PolyDefns.~&gt;[F,shapeless.Id])F[T] =&gt; T" id="shapeless.PolyDefns.~>.inst3">inst3</a><span class="delimiter">[</span><a title="[_]" id="shapeless.PolyDefns.~>.inst3;F">F</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.~>.inst3;F;_">_</a><span class="delimiter">]</span>, <a title="" id="shapeless.PolyDefns.~>.inst3;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="shapeless.PolyDefns.~&gt;[F,shapeless.Id]" id="shapeless.PolyDefns.~>.inst3.f">f</a> : F <a href="#shapeless.PolyDefns;~>" title="shapeless.PolyDefns.~&gt;[F,shapeless.Id]">~&gt;</a> Id<span class="delimiter">)</span> : F<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; T = <a href="#shapeless.PolyDefns;~>.apply(efb2a18dfd)" title="(f: F[T])shapeless.Id[T]">f</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns.~>.inst3.$anonfun.x$12" title="F[T]">_</a><span class="delimiter">)</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T](f: shapeless.PolyDefns.~&gt;[shapeless.Id,shapeless.Id])T =&gt; T" id="shapeless.PolyDefns.~>.inst4">inst4</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.~>.inst4;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="shapeless.PolyDefns.~&gt;[shapeless.Id,shapeless.Id]" id="shapeless.PolyDefns.~>.inst4.f">f</a> : Id <a href="#shapeless.PolyDefns;~>" title="shapeless.PolyDefns.~&gt;[shapeless.Id,shapeless.Id]">~&gt;</a> Id<span class="delimiter">)</span> : T =&gt; T = <a href="#shapeless.PolyDefns;~>.apply(efb2a18dfd)" title="[T](f: shapeless.Id[T])shapeless.Id[T]">f</a><span title="(f: shapeless.Id[T])shapeless.Id[T]" class="delimiter">[</span><a href="#shapeless.PolyDefns.~>.inst4;T" title="T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless.PolyDefns.~>.inst4.$anonfun.x$13" title="T">_</a><span class="delimiter">)</span>  <span class="comment">// Explicit type argument needed here to prevent recursion?</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[F[_], G, T](f: shapeless.PolyDefns.~&gt;[F,[T]G])F[T] =&gt; G" id="shapeless.PolyDefns.~>.inst5">inst5</a><span class="delimiter">[</span><a title="[_]" id="shapeless.PolyDefns.~>.inst5;F">F</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.~>.inst5;F;_">_</a><span class="delimiter">]</span>, <a title="" id="shapeless.PolyDefns.~>.inst5;G">G</a>, <a title="" id="shapeless.PolyDefns.~>.inst5;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="shapeless.PolyDefns.~&gt;[F,[T]G]" id="shapeless.PolyDefns.~>.inst5.f">f</a> : F <a href="#shapeless.PolyDefns;~>" title="shapeless.PolyDefns.~&gt;[F,[T]G]">~&gt;</a> Const<span class="delimiter">[</span>G<span class="delimiter">]</span>#λ<span class="delimiter">)</span> : F<span class="delimiter">[</span>T<span class="delimiter">]</span> =&gt; G = <a href="#shapeless.PolyDefns;~>.apply(efb2a18dfd)" title="(f: F[T])G">f</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns.~>.inst5.$anonfun.x$14" title="F[T]">_</a><span class="delimiter">)</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[G, T](f: shapeless.PolyDefns.~&gt;[shapeless.Id,[T]G])T =&gt; G" id="shapeless.PolyDefns.~>.inst6">inst6</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.~>.inst6;G">G</a>, <a title="" id="shapeless.PolyDefns.~>.inst6;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="shapeless.PolyDefns.~&gt;[shapeless.Id,[T]G]" id="shapeless.PolyDefns.~>.inst6.f">f</a> : Id <a href="#shapeless.PolyDefns;~>" title="shapeless.PolyDefns.~&gt;[shapeless.Id,[T]G]">~&gt;</a> Const<span class="delimiter">[</span>G<span class="delimiter">]</span>#λ<span class="delimiter">)</span> : T =&gt; G = <a href="#shapeless.PolyDefns;~>.apply(efb2a18dfd)" title="(f: shapeless.Id[T])G">f</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns.~>.inst6.$anonfun.x$15" title="T">_</a><span class="delimiter">)</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[F, G](f: shapeless.PolyDefns.~&gt;[[T]F,[T]G])F =&gt; G" id="shapeless.PolyDefns.~>.inst7">inst7</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.~>.inst7;F">F</a>, <a title="" id="shapeless.PolyDefns.~>.inst7;G">G</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="shapeless.PolyDefns.~&gt;[[T]F,[T]G]" id="shapeless.PolyDefns.~>.inst7.f">f</a> : Const<span class="delimiter">[</span>F<span class="delimiter">]</span>#λ <a href="#shapeless.PolyDefns;~>" title="shapeless.PolyDefns.~&gt;[[T]F,[T]G]">~&gt;</a> Const<span class="delimiter">[</span>G<span class="delimiter">]</span>#λ<span class="delimiter">)</span> : F =&gt; G = <a href="#shapeless.PolyDefns;~>.apply(efb2a18dfd)" title="(f: F)G">f</a><span class="delimiter">(</span><a href="#shapeless.PolyDefns.~>.inst7.$anonfun.x$16" title="F">_</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>

  <span class="comment">/** Natural transformation with a constant type constructor on the right hand side. */</span>
  <span class="keyword">type</span> <a title="[F[_], R]shapeless.PolyDefns.~&gt;[F,[T]R]" id="shapeless.PolyDefns;~>>">~&gt;&gt;</a><span class="delimiter">[</span><a title="[_]" id="shapeless.PolyDefns;~>>;F">F</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns;~>>;F;_">_</a><span class="delimiter">]</span>, <a title="" id="shapeless.PolyDefns;~>>;R">R</a><span class="delimiter">]</span> = <a href="#shapeless.PolyDefns;~>" title="shapeless.PolyDefns.~&gt;[F,[T]R]">~&gt;</a><span class="delimiter">[</span>F, Const<span class="delimiter">[</span>R<span class="delimiter">]</span>#λ<span class="delimiter">]</span>

  <span class="comment">/** Polymorphic identity function. */</span>
  <span class="keyword">object</span> <a title="shapeless.PolyDefns.identity.type" id="shapeless.PolyDefns.identity">identity</a> <a href="#shapeless.PolyDefns.identity" title="shapeless.PolyDefns.identity.type" class="keyword">extends</a> <span class="delimiter">(</span>Id <a href="#shapeless.PolyDefns;~>" title="shapeless.PolyDefns.~&gt;[shapeless.Id,shapeless.Id]">~&gt;</a> Id<span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[T](t: T)T" id="shapeless.PolyDefns.identity.apply(bf387de5af)">apply</a><span class="delimiter">[</span><a title="" id="shapeless.PolyDefns.identity.apply(bf387de5af);T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="shapeless.PolyDefns.identity.apply(bf387de5af).t">t</a> : <a href="#shapeless.PolyDefns.identity.apply(bf387de5af);T" title="T">T</a><span class="delimiter">)</span> = <a href="#shapeless.PolyDefns.identity.apply(bf387de5af).t" title="T">t</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Base trait for polymorphic values.
 * 
 * @author Miles Sabin
 */</span>
<span class="keyword">trait</span> <a title="trait Poly extends AnyRef with shapeless.PolyApply" id="shapeless;Poly">Poly</a> <span title="Unit" class="keyword">extends</span> <a href="../polyapply.scala.html#shapeless;PolyApply" title="shapeless.PolyApply">PolyApply</a> <span class="delimiter">{</span>
  <span class="keyword">import</span> <a href="package.scala.html#shapeless.package.poly" title="=&gt; shapeless.PolyDefns.type">poly</a>._

  <span class="keyword">def</span> <a title="(f: shapeless.Poly)shapeless.poly.Compose[Poly.this.type,f.type]" id="shapeless;Poly.compose">compose</a><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless;Poly.compose.f">f</a>: <a href="#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span> = <span title="shapeless.poly.Compose[Poly.this.type,f.type]" class="keyword">new</span> <a href="#shapeless.PolyDefns;Compose" title="shapeless.poly.Compose[Poly.this.type,f.type]">Compose</a><span class="delimiter">[</span><span class="keyword">this</span>.<span class="keyword">type</span>, f.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless;Poly" title="Poly.this.type" class="keyword">this</a>, <a href="#shapeless;Poly.compose.f" title="shapeless.Poly">f</a><span class="delimiter">)</span>
  
  <span class="keyword">def</span> <a title="(f: shapeless.Poly)shapeless.poly.Compose[f.type,Poly.this.type]" id="shapeless;Poly.andThen">andThen</a><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless;Poly.andThen.f">f</a>: <a href="#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span> = <span title="shapeless.poly.Compose[f.type,Poly.this.type]" class="keyword">new</span> <a href="#shapeless.PolyDefns;Compose" title="shapeless.poly.Compose[f.type,Poly.this.type]">Compose</a><span class="delimiter">[</span>f.<span class="keyword">type</span>, <span class="keyword">this</span>.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="#shapeless;Poly.andThen.f" title="shapeless.Poly">f</a>, <a href="#shapeless;Poly" title="Poly.this.type" class="keyword">this</a><span class="delimiter">)</span>

  <span class="comment">/** The type of the case representing this polymorphic function at argument types `L`. */</span>
  <span class="keyword">type</span> <a title="[L &lt;: shapeless.HList]shapeless.poly.Case[Poly.this.type,L]" id="shapeless;Poly;ProductCase">ProductCase</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless;Poly;ProductCase;L">L</a> &lt;: HList<span class="delimiter">]</span> = <a href="#shapeless.PolyDefns;Case" title="shapeless.poly.Case[Poly.this.type,L]">Case</a><span class="delimiter">[</span><span class="keyword">this</span>.<span class="keyword">type</span>, L<span class="delimiter">]</span>
  <span class="keyword">object</span> <a title="Poly.this.ProductCase.type" id="shapeless;Poly.ProductCase">ProductCase</a> <a href="#shapeless;Poly.ProductCase" title="Poly.this.ProductCase.type" class="delimiter">{</a>
    <span class="comment">/** The type of a case of this polymorphic function of the form `L =&gt; R` */</span>
    <span class="keyword">type</span> <a title="ProductCase[L &lt;: shapeless.HList, Result0] extends Poly.this.ProductCase[L]" id="shapeless;Poly.ProductCase;Aux">Aux</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless;Poly.ProductCase;Aux;L">L</a> &lt;: HList, <a title="" id="shapeless;Poly.ProductCase;Aux;Result0">Result0</a><span class="delimiter">]</span> = <a href="#shapeless;Poly.ProductCase;<refinement>" title="ProductCase extends Poly.this.ProductCase[L]">ProductCase</a><span class="delimiter">[</span>L<span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Result = Result0 <span class="delimiter">}</span>
    
    <span class="comment">/** The type of a case of this polymorphic function of the form `T =&gt; T` */</span>
    <span class="keyword">type</span> <a title="[T]shapeless.Poly.ProductCase.Aux[shapeless.::[T,shapeless.HNil],T]" id="shapeless;Poly.ProductCase;Hom">Hom</a><span class="delimiter">[</span><a title="" id="shapeless;Poly.ProductCase;Hom;T">T</a><span class="delimiter">]</span> = <a href="#shapeless;Poly.ProductCase;<refinement>" title="shapeless.Poly.ProductCase.Aux[shapeless.::[T,shapeless.HNil],T]">Aux</a><span class="delimiter">[</span>T :: HNil, T<span class="delimiter">]</span>

    <span class="keyword">def</span> <a title="[L &lt;: shapeless.HList, R](v: L =&gt; R)Poly.this.ProductCase[L]{type Result = R}" id="shapeless;Poly.ProductCase.apply">apply</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless;Poly.ProductCase.apply;L">L</a> &lt;: HList, <a title="" id="shapeless;Poly.ProductCase.apply;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="L =&gt; R" id="shapeless;Poly.ProductCase.apply.v">v</a> : L =&gt; R<span class="delimiter">)</span> = <a href="#shapeless;Poly.ProductCase.apply;$anon" title="Poly.this.ProductCase[L]{}" class="keyword">new</a> <a title="anonymous class $anon extends Poly.this.ProductCase[L]" id="shapeless;Poly.ProductCase.apply;$anon">ProductCase</a><span class="delimiter">[</span>L<span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="R" id="shapeless;Poly.ProductCase.apply;$anon;Result">Result</a> = <a href="#shapeless;Poly.ProductCase.apply;R" title="R">R</a>
      <span class="keyword">val</span> <a title="L =&gt; R" id="shapeless;Poly.ProductCase.apply;$anon.value">value</a> = <a href="#shapeless;Poly.ProductCase.apply.v" title="L =&gt; R">v</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">def</span> <a title="[T, L &lt;: shapeless.HList, R](t: T)(implicit cb: Poly.this.CaseBuilder[T,L,R])Poly.this.ProductCase.Aux[L,R]" id="shapeless;Poly.use">use</a><span class="delimiter">[</span><a title="" id="shapeless;Poly.use;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless;Poly.use;L">L</a> &lt;: HList, <a title="" id="shapeless;Poly.use;R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="shapeless;Poly.use.t">t</a> : <a href="#shapeless;Poly.use;T" title="T">T</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Poly.this.CaseBuilder[T,L,R]" id="shapeless;Poly.use.cb">cb</a>: <a href="#shapeless;Poly;CaseBuilder" title="Poly.this.CaseBuilder[T,L,R]">CaseBuilder</a><span class="delimiter">[</span>T, L, R<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless;Poly;CaseBuilder.apply" title="(t: T)Poly.this.ProductCase.Aux[L,R]">cb</a><span class="delimiter">(</span><a href="#shapeless;Poly.use.t" title="T">t</a><span class="delimiter">)</span>

  <span class="keyword">trait</span> <a title="trait CaseBuilder[T, L &lt;: shapeless.HList, R] extends AnyRef" id="shapeless;Poly;CaseBuilder">CaseBuilder</a><span class="delimiter">[</span><a title="" id="shapeless;Poly;CaseBuilder;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless;Poly;CaseBuilder;L">L</a> &lt;: HList, <a title="" id="shapeless;Poly;CaseBuilder;R">R</a><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="(t: T)Poly.this.ProductCase.Aux[L,R]" id="shapeless;Poly;CaseBuilder.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless;Poly;CaseBuilder.apply.t">t</a>: <a href="#shapeless;Poly;CaseBuilder;T" title="T">T</a><span class="delimiter">)</span>: ProductCase.<a href="#shapeless;Poly.ProductCase;<refinement>" title="Poly.this.ProductCase.Aux[L,R]">Aux</a><span class="delimiter">[</span>L, R<span class="delimiter">]</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait LowPriorityCaseBuilder extends AnyRef" id="shapeless;Poly;LowPriorityCaseBuilder">LowPriorityCaseBuilder</a> <span title="Unit" class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[T]=&gt; Poly.this.CaseBuilder[T,shapeless.HNil,T]" id="shapeless;Poly;LowPriorityCaseBuilder.valueCaseBuilder">valueCaseBuilder</a><span class="delimiter">[</span><a title="" id="shapeless;Poly;LowPriorityCaseBuilder.valueCaseBuilder;T">T</a><span class="delimiter">]</span>: <a href="#shapeless;Poly;CaseBuilder" title="Poly.this.CaseBuilder[T,shapeless.HNil,T]">CaseBuilder</a><span class="delimiter">[</span>T, HNil, T<span class="delimiter">]</span> =
      <a href="#shapeless;Poly;LowPriorityCaseBuilder.valueCaseBuilder;$anon" title="Poly.this.CaseBuilder[T,shapeless.HNil,T]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Poly.this.CaseBuilder[T,shapeless.HNil,T]" id="shapeless;Poly;LowPriorityCaseBuilder.valueCaseBuilder;$anon">CaseBuilder</a><span class="delimiter">[</span>T, HNil, T<span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">def</span> <a title="(t: T)Poly.this.ProductCase[shapeless.HNil]{type Result = T}" id="shapeless;Poly;LowPriorityCaseBuilder.valueCaseBuilder;$anon.apply">apply</a><span class="delimiter">(</span><a title="T" id="shapeless;Poly;LowPriorityCaseBuilder.valueCaseBuilder;$anon.apply.t">t</a>: <a href="#shapeless;Poly;LowPriorityCaseBuilder.valueCaseBuilder;T" title="T">T</a><span class="delimiter">)</span> = <a href="#shapeless;Poly.ProductCase.apply" title="(v: shapeless.HNil =&gt; T)Poly.this.ProductCase[shapeless.HNil]{type Result = T}">ProductCase</a><span class="delimiter">(</span><span class="delimiter">(</span>_: <a href="hlists.scala.html#shapeless;HNil" title="shapeless.HNil">HNil</a><span class="delimiter">)</span> =&gt; <a href="#shapeless;Poly;LowPriorityCaseBuilder.valueCaseBuilder;$anon.apply.t" title="T">t</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">object</span> <a title="Poly.this.CaseBuilder.type" id="shapeless;Poly.CaseBuilder">CaseBuilder</a> <a href="#shapeless;Poly.CaseBuilder" title="Poly.this.CaseBuilder.type" class="keyword">extends</a> <a href="#shapeless;Poly;LowPriorityCaseBuilder" title="Poly.this.LowPriorityCaseBuilder">LowPriorityCaseBuilder</a> <span class="delimiter">{</span>
    <span class="keyword">import</span> ops.<a href="ops/functions.scala.html#shapeless.ops.function" title="shapeless.ops.function.type">function</a>.FnToProduct
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[F, H, T &lt;: shapeless.HList, Result](implicit fntp: shapeless.ops.function.FnToProduct.Aux[F,shapeless.::[H,T] =&gt; Result])Poly.this.CaseBuilder[F,shapeless.::[H,T],Result]" id="shapeless;Poly.CaseBuilder.fnCaseBuilder">fnCaseBuilder</a><span class="delimiter">[</span><a title="" id="shapeless;Poly.CaseBuilder.fnCaseBuilder;F">F</a>, <a title="" id="shapeless;Poly.CaseBuilder.fnCaseBuilder;H">H</a>, <a title=" &lt;: shapeless.HList" id="shapeless;Poly.CaseBuilder.fnCaseBuilder;T">T</a> &lt;: HList, <a title="" id="shapeless;Poly.CaseBuilder.fnCaseBuilder;Result">Result</a><span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.function.FnToProduct.Aux[F,shapeless.::[H,T] =&gt; Result]" id="shapeless;Poly.CaseBuilder.fnCaseBuilder.fntp">fntp</a>: FnToProduct.<a href="../fntoproduct.scala.html#shapeless.ops;FnToProductInstances;<refinement>" title="shapeless.ops.function.FnToProduct.Aux[F,shapeless.::[H,T] =&gt; Result]">Aux</a><span class="delimiter">[</span>F, <span class="delimiter">(</span><span class="delimiter">(</span>H :: T<span class="delimiter">)</span> =&gt; Result<span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span>: <a href="#shapeless;Poly;CaseBuilder" title="Poly.this.CaseBuilder[F,shapeless.::[H,T],Result]">CaseBuilder</a><span class="delimiter">[</span>F, H :: T, Result<span class="delimiter">]</span> =
        <a href="#shapeless;Poly.CaseBuilder.fnCaseBuilder;$anon" title="Poly.this.CaseBuilder[F,shapeless.::[H,T],Result]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with Poly.this.CaseBuilder[F,shapeless.::[H,T],Result]" id="shapeless;Poly.CaseBuilder.fnCaseBuilder;$anon">CaseBuilder</a><span class="delimiter">[</span>F, H :: T, Result<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">def</span> <a title="(f: F)Poly.this.ProductCase[shapeless.::[H,T]]{type Result = Result}" id="shapeless;Poly.CaseBuilder.fnCaseBuilder;$anon.apply">apply</a><span class="delimiter">(</span><a title="F" id="shapeless;Poly.CaseBuilder.fnCaseBuilder;$anon.apply.f">f</a>: <a href="#shapeless;Poly.CaseBuilder.fnCaseBuilder;F" title="F">F</a><span class="delimiter">)</span> = <a href="#shapeless;Poly.ProductCase.apply" title="(v: shapeless.::[H,T] =&gt; Result)Poly.this.ProductCase[shapeless.::[H,T]]{type Result = Result}">ProductCase</a><span class="delimiter">(</span><span class="delimiter">(</span>l : H <a href="hlists.scala.html#shapeless;::" title="shapeless.::[H,T]">::</a> T<span class="delimiter">)</span> =&gt; <a href="package.scala.html#shapeless.package;DepFn1.apply" title="(t: F)shapeless.::[H,T] =&gt; Result">fntp</a><span title="(v1: shapeless.::[H,T])Result" class="delimiter">(</span><a href="#shapeless;Poly.CaseBuilder.fnCaseBuilder;$anon.apply.f" title="F">f</a><span class="delimiter">)</span><span class="delimiter">(</span><a href="#shapeless;Poly.CaseBuilder.fnCaseBuilder;$anon.apply.$anonfun.l" title="shapeless.::[H,T]">l</a><span class="delimiter">)</span><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">def</span> <a title="[L &lt;: shapeless.HList](implicit c: Poly.this.ProductCase[L])Poly.this.ProductCase[L]" id="shapeless;Poly.caseAt">caseAt</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless;Poly.caseAt;L">L</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Poly.this.ProductCase[L]" id="shapeless;Poly.caseAt.c">c</a>: <a href="#shapeless.PolyDefns;Case" title="Poly.this.ProductCase[L]">ProductCase</a><span class="delimiter">[</span>L<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless;Poly.caseAt.c" title="Poly.this.ProductCase[L]">c</a>

  <span class="keyword">def</span> <a title="[R](implicit c: Poly.this.ProductCase.Aux[shapeless.HNil,R])R" id="shapeless;Poly.apply(2f730427bd)">apply</a><span class="delimiter">[</span><a title="" id="shapeless;Poly.apply(2f730427bd);R">R</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Poly.this.ProductCase.Aux[shapeless.HNil,R]" id="shapeless;Poly.apply(2f730427bd).c">c</a> : ProductCase.<a href="#shapeless;Poly.ProductCase;<refinement>" title="Poly.this.ProductCase.Aux[shapeless.HNil,R]">Aux</a><span class="delimiter">[</span>HNil, R<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#shapeless;Poly.apply(2f730427bd);R" title="R">R</a> = <a href="#shapeless.PolyDefns;Case.apply(7c1fd49f38)" title="()(implicit ev: =:=[shapeless.HNil,shapeless.HNil])c.Result">c</a><span title="=:=[shapeless.HNil,shapeless.HNil]" class="delimiter">(</span><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Provides implicit conversions from polymorphic function values to monomorphic function values, eg. for use as
 * arguments to ordinary higher order functions.
 *  
 * @author Miles Sabin
 */</span>
<span class="keyword">object</span> <a title="shapeless.Poly.type" id="shapeless.Poly">Poly</a> <a href="#shapeless.Poly" title="shapeless.Poly.type" class="keyword">extends</a> <a href="../polyinst.scala.html#shapeless;PolyInst" title="shapeless.PolyInst">PolyInst</a> <span class="delimiter">{</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit shapeless.Poly.inst0 : (p: shapeless.Poly)(implicit cse: p.ProductCase[shapeless.HNil])cse.Result" id="shapeless.Poly.inst0">inst0</a><span class="delimiter">(</span><a title="shapeless.Poly" id="shapeless.Poly.inst0.p">p</a>: <a href="#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="p.ProductCase[shapeless.HNil]" id="shapeless.Poly.inst0.cse">cse</a> : p.<a href="#shapeless.PolyDefns;Case" title="p.ProductCase[shapeless.HNil]">ProductCase</a><span class="delimiter">[</span>HNil<span class="delimiter">]</span><span class="delimiter">)</span> : cse.<a href="#shapeless.PolyDefns;Case;Result" title="cse.Result">Result</a> = <a href="#shapeless.PolyDefns;Case.apply(7c1fd49f38)" title="()(implicit ev: =:=[shapeless.HNil,shapeless.HNil])cse.Result">cse</a><span title="=:=[shapeless.HNil,shapeless.HNil]" class="delimiter">(</span><span class="delimiter">)</span>
  
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit shapeless.Poly.apply : (f: Any)shapeless.Poly" id="shapeless.Poly.apply">apply</a><span class="delimiter">(</span><a title="Any" id="shapeless.Poly.apply.f">f</a> : <span title="Any">Any</span><span class="delimiter">)</span> = macro <a href="#shapeless.Poly.liftFnImpl" title="(c: scala.reflect.macros.Context)(f: c.Expr[Any])c.Expr[shapeless.Poly]">liftFnImpl</a>
  
  <span class="keyword">def</span> <a title="(c: scala.reflect.macros.Context)(f: c.Expr[Any])c.Expr[shapeless.Poly]" id="shapeless.Poly.liftFnImpl">liftFnImpl</a><span class="delimiter">(</span><a title="scala.reflect.macros.Context" id="shapeless.Poly.liftFnImpl.c">c</a>: <span title="scala.reflect.macros.Context">Context</span><span class="delimiter">)</span><span class="delimiter">(</span><a title="c.Expr[Any]" id="shapeless.Poly.liftFnImpl.f">f</a>: c.<span title="c.Expr[Any]">Expr</span><span class="delimiter">[</span>Any<span class="delimiter">]</span><span class="delimiter">)</span>: c.<span title="c.Expr[shapeless.Poly]">Expr</span><span class="delimiter">[</span>Poly<span class="delimiter">]</span> = <span class="delimiter">{</span>
    <span class="keyword">import</span> <a href="#shapeless.Poly.liftFnImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; scala.reflect.macros.Universe">universe</span>._
    <span class="keyword">import</span> <a href="#shapeless.Poly.liftFnImpl.c" title="=&gt; c.universe.FlagValues">Flag</a>._
    
    <span class="keyword">val</span> <a title="c.universe.Apply" id="shapeless.Poly.liftFnImpl.pendingSuperCall">pendingSuperCall</a> = <a href="#shapeless.Poly.liftFnImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(qual: c.universe.Tree, mix: c.universe.TypeName)c.universe.Super">Super</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(qual: c.universe.TypeName)c.universe.This">This</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">EMPTY</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="=&gt; c.universe.TypeNamesApi">tpnme</a>.<span title="=&gt; c.universe.tpnme.NameType">EMPTY</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">CONSTRUCTOR</span><span class="delimiter">)</span>, List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="c.universe.TermName" id="shapeless.Poly.liftFnImpl.moduleName">moduleName</a> = <a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="()String">fresh</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="c.universe.ClassSymbol" id="shapeless.Poly.liftFnImpl.anySym">anySym</a> = <a href="#shapeless.Poly.liftFnImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.universe.Mirror">mirror</span>.<span title="(fullName: String)c.universe.ClassSymbol">staticClass</span><span class="delimiter">(</span><span title="String(&quot;scala.Any&quot;)" class="string">&quot;scala.Any&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Type" id="shapeless.Poly.liftFnImpl.anyTpe">anyTpe</a> = <a href="#shapeless.Poly.liftFnImpl.anySym" title="c.universe.ClassSymbol">anySym</a>.<span title="=&gt; c.universe.TypeSymbol">asType</span>.<span title="=&gt; c.universe.Type">toType</span>
    <span class="keyword">val</span> <a title="c.universe.ClassSymbol" id="shapeless.Poly.liftFnImpl.nothingSym">nothingSym</a> = <a href="#shapeless.Poly.liftFnImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.universe.Mirror">mirror</span>.<span title="(fullName: String)c.universe.ClassSymbol">staticClass</span><span class="delimiter">(</span><span title="String(&quot;scala.Nothing&quot;)" class="string">&quot;scala.Nothing&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Type" id="shapeless.Poly.liftFnImpl.nothingTpe">nothingTpe</a> = <a href="#shapeless.Poly.liftFnImpl.nothingSym" title="c.universe.ClassSymbol">nothingSym</a>.<span title="=&gt; c.universe.TypeSymbol">asType</span>.<span title="=&gt; c.universe.Type">toType</span>

    <span class="keyword">val</span> <a title="c.universe.ModuleSymbol" id="shapeless.Poly.liftFnImpl.typeOpsSym">typeOpsSym</a> = <a href="#shapeless.Poly.liftFnImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.universe.Mirror">mirror</span>.<span title="(fullName: String)c.universe.ModuleSymbol">staticPackage</span><span class="delimiter">(</span><span title="String(&quot;shapeless&quot;)" class="string">&quot;shapeless&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.TypeSymbol" id="shapeless.Poly.liftFnImpl.idSym">idSym</a> = <a href="#shapeless.Poly.liftFnImpl.typeOpsSym" title="c.universe.ModuleSymbol" id="shapeless.Poly.liftFnImpl.idSym.qual$1">typeOpsSym</a>.<a title="c.universe.Position" id="shapeless.Poly.liftFnImpl.idSym.x$26">newTypeSymbol</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><a title="c.universe.TypeName" id="shapeless.Poly.liftFnImpl.idSym.x$24" class="delimiter">(</a><span title="String(&quot;Id&quot;)" class="string">&quot;Id&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.TypeSymbol" id="shapeless.Poly.liftFnImpl.constSym">constSym</a> = <a href="#shapeless.Poly.liftFnImpl.typeOpsSym" title="c.universe.ModuleSymbol" id="shapeless.Poly.liftFnImpl.constSym.qual$2">typeOpsSym</a>.<a title="c.universe.Position" id="shapeless.Poly.liftFnImpl.constSym.x$29">newTypeSymbol</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><a title="c.universe.TypeName" id="shapeless.Poly.liftFnImpl.constSym.x$27" class="delimiter">(</a><span title="String(&quot;Const&quot;)" class="string">&quot;Const&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="c.universe.ClassSymbol" id="shapeless.Poly.liftFnImpl.natTSym">natTSym</a> = <a href="#shapeless.Poly.liftFnImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.universe.Mirror">mirror</span>.<span title="(fullName: String)c.universe.ClassSymbol">staticClass</span><span class="delimiter">(</span><span title="String(&quot;shapeless.PolyDefns.$tilde$greater&quot;)" class="string">&quot;shapeless.PolyDefns.$tilde$greater&quot;</span><span class="delimiter">)</span>
    <span class="keyword">val</span> <a title="c.universe.Type" id="shapeless.Poly.liftFnImpl.natTTpe">natTTpe</a> = <a href="#shapeless.Poly.liftFnImpl.natTSym" title="c.universe.ClassSymbol">natTSym</a>.<span title="=&gt; c.universe.ClassSymbol">asClass</span>.<span title="=&gt; c.universe.Type">toTypeConstructor</span>

    <span class="keyword">def</span> <a title="(fSym: c.universe.Symbol, gSym: c.universe.Symbol, targ: c.universe.TypeName, arg: c.universe.TermName, body: c.universe.Tree)c.universe.DefDef" id="shapeless.Poly.liftFnImpl.mkApply">mkApply</a><span class="delimiter">(</span><a title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.mkApply.fSym">fSym</a>: <span title="c.universe.Symbol">Symbol</span>, <a title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.mkApply.gSym">gSym</a>: <span title="c.universe.Symbol">Symbol</span>, <a title="c.universe.TypeName" id="shapeless.Poly.liftFnImpl.mkApply.targ">targ</a>: <span title="c.universe.TypeName">TypeName</span>, <a title="c.universe.TermName" id="shapeless.Poly.liftFnImpl.mkApply.arg">arg</a>: <span title="c.universe.TermName">TermName</span>, <a title="c.universe.Tree" id="shapeless.Poly.liftFnImpl.mkApply.body">body</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">def</span> <a title="(sym: c.universe.Symbol)c.universe.Tree" id="shapeless.Poly.liftFnImpl.mkApply.mkTargRef">mkTargRef</a><span class="delimiter">(</span><a title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.mkApply.mkTargRef.sym">sym</a>: <span title="c.universe.Symbol">Symbol</span><span class="delimiter">)</span> =
        <span title="c.universe.Tree" class="keyword">if</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.mkApply.mkTargRef.sym" title="c.universe.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#shapeless.Poly.liftFnImpl.idSym" title="c.universe.TypeSymbol">idSym</a><span class="delimiter">)</span>
          <a href="#shapeless.Poly.liftFnImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.mkApply.targ" title="c.universe.TypeName">targ</a><span class="delimiter">)</span>
        <span class="keyword">else</span> <span title="c.universe.Tree" class="keyword">if</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.mkApply.mkTargRef.sym" title="c.universe.Symbol">sym</a>.<span title="=&gt; c.universe.TypeSymbol">asType</span>.<span title="=&gt; List[c.universe.Symbol]">typeParams</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
          <a href="#shapeless.Poly.liftFnImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.mkApply.mkTargRef.sym" title="c.universe.Symbol">sym</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>
        <span class="keyword">else</span>
          <a href="#shapeless.Poly.liftFnImpl.c" title="(tpt: c.universe.Tree, args: List[c.universe.Tree])c.universe.AppliedTypeTree">AppliedTypeTree</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.mkApply.mkTargRef.sym" title="c.universe.Symbol">sym</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>, <span title="(xs: c.universe.Ident*)List[c.universe.Ident]">List</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.mkApply.targ" title="c.universe.TypeName">targ</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

      <a href="#shapeless.Poly.liftFnImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.Name, tparams: List[c.universe.TypeDef], vparamss: List[List[c.universe.ValDef]], tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.DefDef">DefDef</a><span class="delimiter">(</span>
        <a href="#shapeless.Poly.liftFnImpl.c" title="()c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;apply&quot;)" class="string">&quot;apply&quot;</span><span class="delimiter">)</span>,
        <span title="(xs: c.universe.TypeDef*)List[c.universe.TypeDef]">List</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TypeName, tparams: List[c.universe.TypeDef], rhs: c.universe.Tree)c.universe.TypeDef">TypeDef</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(flags: c.universe.FlagSet)c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="=&gt; c.universe.FlagSet">PARAM</a><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.mkApply.targ" title="c.universe.TypeName">targ</a>, List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(lo: c.universe.Tree, hi: c.universe.Tree)c.universe.TypeBoundsTree">TypeBoundsTree</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.nothingTpe" title="c.universe.Type">nothingTpe</a><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(tp: c.universe.Type)c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.anyTpe" title="c.universe.Type">anyTpe</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
        <span title="(xs: List[c.universe.ValDef]*)List[List[c.universe.ValDef]]">List</span><span class="delimiter">(</span><span title="(xs: c.universe.ValDef*)List[c.universe.ValDef]">List</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TermName, tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.ValDef">ValDef</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(flags: c.universe.FlagSet)c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="=&gt; c.universe.FlagSet">PARAM</a><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.mkApply.arg" title="c.universe.TermName">arg</a>, <a href="#shapeless.Poly.liftFnImpl.mkApply.mkTargRef" title="(sym: c.universe.Symbol)c.universe.Tree">mkTargRef</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.mkApply.fSym" title="c.universe.Symbol">fSym</a><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="=&gt; c.universe.Tree">EmptyTree</a><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,
        <a href="#shapeless.Poly.liftFnImpl.mkApply.mkTargRef" title="(sym: c.universe.Symbol)c.universe.Tree">mkTargRef</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.mkApply.gSym" title="c.universe.Symbol">gSym</a><span class="delimiter">)</span>,
        <a href="#shapeless.Poly.liftFnImpl.mkApply.body" title="c.universe.Tree">body</a>
      <span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(methodSym: c.universe.MethodSymbol)(c.universe.Symbol, c.universe.Symbol)" id="shapeless.Poly.liftFnImpl.destructureMethod">destructureMethod</a><span class="delimiter">(</span><a title="c.universe.MethodSymbol" id="shapeless.Poly.liftFnImpl.destructureMethod.methodSym">methodSym</a>: <span title="c.universe.MethodSymbol">MethodSymbol</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="keyword">val</span> <a title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.destructureMethod.paramSym">paramSym</a> = <a href="#shapeless.Poly.liftFnImpl.destructureMethod.methodSym" title="c.universe.MethodSymbol">methodSym</a>.<span title="=&gt; List[List[c.universe.Symbol]]">paramss</span> <span title="c.universe.Symbol" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#shapeless.Poly.liftFnImpl.destructureMethod.paramSym.<unapply-selector>" title="(x: List[List[c.universe.Symbol]])Some[List[List[c.universe.Symbol]]]">List</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.destructureMethod.paramSym.<unapply-selector>" title="(x: List[c.universe.Symbol])Some[List[c.universe.Symbol]]">List</a><span class="delimiter">(</span><a title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.destructureMethod.paramSym.ps">ps</a><span class="delimiter">)</span><span class="delimiter">)</span> =&gt; <a href="#shapeless.Poly.liftFnImpl.destructureMethod.paramSym.ps" title="c.universe.Symbol">ps</a>
        <span class="keyword">case</span> _ =&gt; <a href="#shapeless.Poly.liftFnImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="String(&quot;Expression $f has the wrong shape to be converted to a polymorphic function value&quot;)" class="string">&quot;Expression $f has the wrong shape to be converted to a polymorphic function value&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

      <span class="keyword">def</span> <a title="(tpe: c.universe.Type)c.universe.Symbol" id="shapeless.Poly.liftFnImpl.destructureMethod.extractTc">extractTc</a><span class="delimiter">(</span><a title="c.universe.Type" id="shapeless.Poly.liftFnImpl.destructureMethod.extractTc.tpe">tpe</a>: <span title="c.universe.Type">Type</span><span class="delimiter">)</span>: <span title="c.universe.Symbol">Symbol</span> = <span class="delimiter">{</span>
        <span class="keyword">val</span> <a title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.destructureMethod.extractTc.owner">owner</a> = <a href="#shapeless.Poly.liftFnImpl.destructureMethod.extractTc.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Symbol">typeSymbol</span>.<span title="=&gt; c.universe.Symbol">owner</span>
        <span title="c.universe.Symbol" class="keyword">if</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.destructureMethod.extractTc.owner" title="c.universe.Symbol">owner</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#shapeless.Poly.liftFnImpl.destructureMethod.methodSym" title="c.universe.MethodSymbol">methodSym</a><span class="delimiter">)</span> <a href="#shapeless.Poly.liftFnImpl.idSym" title="c.universe.TypeSymbol">idSym</a>
        <span class="keyword">else</span> <a href="#shapeless.Poly.liftFnImpl.destructureMethod.extractTc.tpe" title="c.universe.Type">tpe</a>.<span title="=&gt; c.universe.Type">typeConstructor</span>.<span title="=&gt; c.universe.Symbol">typeSymbol</span>
      <span class="delimiter">}</span>

      <span title="(_1: c.universe.Symbol, _2: c.universe.Symbol)(c.universe.Symbol, c.universe.Symbol)" class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.destructureMethod.extractTc" title="(tpe: c.universe.Type)c.universe.Symbol">extractTc</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.destructureMethod.paramSym" title="c.universe.Symbol">paramSym</a>.<span title="=&gt; c.universe.Type">typeSignature</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.destructureMethod.extractTc" title="(tpe: c.universe.Type)c.universe.Symbol">extractTc</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.destructureMethod.methodSym" title="c.universe.MethodSymbol">methodSym</a>.<span title="=&gt; c.universe.Type">returnType</span><span class="delimiter">)</span><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(tree: c.universe.Tree, internalSyms: List[c.universe.Symbol])c.universe.Tree" id="shapeless.Poly.liftFnImpl.stripSymbolsAndTypes">stripSymbolsAndTypes</a><span class="delimiter">(</span><a title="c.universe.Tree" id="shapeless.Poly.liftFnImpl.stripSymbolsAndTypes.tree">tree</a>: <span title="c.universe.Tree">Tree</span>, <a title="List[c.universe.Symbol]" id="shapeless.Poly.liftFnImpl.stripSymbolsAndTypes.internalSyms">internalSyms</a>: <span title="List[c.universe.Symbol]">List</span><span class="delimiter">[</span>Symbol<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
      <span class="comment">// Adapted from https://github.com/scala/async/blob/master/src/main/scala/scala/async/TransformUtils.scala#L226</span>
      <span class="keyword">final</span> <span class="keyword">class</span> <a title="class StripSymbolsAndTypes extends c.universe.Transformer" id="shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes">StripSymbolsAndTypes</a> <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes" title="StripSymbolsAndTypes" class="keyword">extends</a> <a href="#shapeless.Poly.liftFnImpl.c" title="c.universe.Transformer">Transformer</a> <span class="delimiter">{</span>
        <span class="keyword">override</span> <span class="keyword">def</span> <a title="(tree: c.universe.Tree)c.universe.Tree" id="shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform">transform</a><span class="delimiter">(</span><a title="c.universe.Tree" id="shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.tree">tree</a>: <span title="c.universe.Tree">Tree</span><span class="delimiter">)</span>: <span title="c.universe.Tree">Tree</span> = <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes" title="StripSymbolsAndTypes" class="keyword">super</a>.<span title="(tree: c.universe.Tree)c.universe.Tree">transform</span> <span class="delimiter">{</span>
          <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.tree" title="c.universe.Tree">tree</a> <span title="c.universe.Tree" class="keyword">match</span> <span class="delimiter">{</span>
            <span class="keyword">case</span> <a href="#shapeless.Poly.liftFnImpl.c" title="(typeApply: c.universe.TypeApply)Option[(c.universe.Tree, List[c.universe.Tree])]">TypeApply</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.TypeApply]" class="delimiter">(</a><a title="c.universe.Tree" id="shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.fn">fn</a>, <a title="List[c.universe.Tree]" id="shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.args">args</a><span class="delimiter">)</span> <span class="keyword">if</span> <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.args" title="List[c.universe.Tree]">args</a>.<span title="(f: c.universe.Tree =&gt; c.universe.Tree)(implicit bf: scala.collection.generic.CanBuildFrom[List[c.universe.Tree],c.universe.Tree,List[c.universe.Tree]])List[c.universe.Tree]">map</span><span title="scala.collection.generic.CanBuildFrom[scala.collection.immutable.List.Coll,c.universe.Tree,List[c.universe.Tree]]" class="delimiter">(</span><a title="c.universe.Tree" id="shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.$anonfun.t">t</a> =&gt; <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform" title="(tree: c.universe.Tree)c.universe.Tree">transform</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.$anonfun.t" title="c.universe.Tree">t</a><span class="delimiter">)</span><span class="delimiter">)</span> <span title="(p: c.universe.Tree =&gt; Boolean)Boolean">exists</span> <span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.$anonfun.x$18" title="c.universe.Tree">_</a>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span> =&gt; <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform" title="(tree: c.universe.Tree)c.universe.Tree">transform</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.fn" title="c.universe.Tree">fn</a><span class="delimiter">)</span>
            <span class="keyword">case</span> <a href="#shapeless.Poly.liftFnImpl.c" title="=&gt; c.universe.Tree">EmptyTree</a>  =&gt; <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.tree" title="c.universe.Tree">tree</a>
            <span class="keyword">case</span> _          =&gt;
              <span class="keyword">val</span> <a title="Boolean" id="shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.hasSymbol">hasSymbol</a>: <span title="Boolean">Boolean</span> = <span class="delimiter">{</span>
                <span class="keyword">val</span> <a title="scala.reflect.internal.SymbolTable#Tree" id="shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.hasSymbol.reflectInternalTree">reflectInternalTree</a> = <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.tree" title="c.universe.Tree">tree</a>.<span title="[T0]=&gt; T0">asInstanceOf</span><span title="symtab.Tree" class="delimiter">[</span>symtab.Tree <span title="symtab.Tree forSome { val symtab: scala.reflect.internal.SymbolTable }" class="keyword">forSome</span> <span class="delimiter">{</span> <span class="keyword">val</span> symtab: reflect.internal.SymbolTable <span class="delimiter">}</span><span class="delimiter">]</span>
                <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.hasSymbol.reflectInternalTree" title="scala.reflect.internal.SymbolTable#Tree">reflectInternalTree</a>.<span title="=&gt; Boolean">hasSymbol</span>
              <span class="delimiter">}</span>
              <span class="keyword">val</span> <a title="tree.type" id="shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.dupl">dupl</a> = <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.tree" title="c.universe.Tree">tree</a>.<span title="=&gt; tree.type">duplicate</span>
              <span title="Unit" class="keyword">if</span> <span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.hasSymbol" title="Boolean">hasSymbol</a><span class="delimiter">)</span>
                <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.dupl" title="tree.type">dupl</a>.<span title="(sym: c.universe.Symbol)Unit">symbol</span> = <a href="#shapeless.Poly.liftFnImpl.c" title="=&gt; c.universe.Symbol">NoSymbol</a>
              <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.dupl" title="tree.type">dupl</a>.<span title="(t: c.universe.Type)Unit">tpe</span> = <span title="Null(null)" class="keyword">null</span>
              <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform.dupl" title="tree.type">dupl</a>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
      <span class="delimiter">}</span>

      <span class="delimiter">(</span><span title="StripSymbolsAndTypes" class="keyword">new</span> <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes" title="StripSymbolsAndTypes">StripSymbolsAndTypes</a><span class="delimiter">)</span>.<a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes;StripSymbolsAndTypes.transform" title="(tree: c.universe.Tree)c.universe.Tree">transform</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes.tree" title="c.universe.Tree">tree</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>

    <span class="keyword">val</span> <a href="#shapeless.Poly.liftFnImpl.fSym" title="(c.universe.Symbol, c.universe.Symbol, c.universe.DefDef)" class="delimiter">(</a><a href="#shapeless.Poly.liftFnImpl.x$23" title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.fSym">fSym</a>, <a href="#shapeless.Poly.liftFnImpl.x$23" title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.gSym">gSym</a>, <a href="#shapeless.Poly.liftFnImpl.x$23" title="c.universe.DefDef" id="shapeless.Poly.liftFnImpl.dd">dd</a><span class="delimiter">)</span> = 
      <a href="#shapeless.Poly.liftFnImpl.f" title="c.Expr[Any]">f</a>.<span title="=&gt; c.universe.Tree">tree</span> <span title="(c.universe.Symbol, c.universe.Symbol, c.universe.DefDef)" class="keyword">match</span> <span class="delimiter">{</span>
        <span class="keyword">case</span> <a href="#shapeless.Poly.liftFnImpl.c" title="(block: c.universe.Block)Option[(List[c.universe.Tree], c.universe.Tree)]">Block</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.Block]" class="delimiter">(</a><a href="#shapeless.Poly.liftFnImpl.x$23.<unapply-selector>" title="(x: List[c.universe.Tree])Some[List[c.universe.Tree]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(function: c.universe.Function)Option[(List[c.universe.ValDef], c.universe.Tree)]">Function</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.Function]" class="delimiter">(</a><a href="#shapeless.Poly.liftFnImpl.x$23.<unapply-selector>" title="(x: List[c.universe.ValDef])Some[List[c.universe.ValDef]]">List</a><span class="delimiter">(</span>_<span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(apply: c.universe.Apply)Option[(c.universe.Tree, List[c.universe.Tree])]">Apply</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.Apply]" class="delimiter">(</a><a href="#shapeless.Poly.liftFnImpl.c" title="(typeApply: c.universe.TypeApply)Option[(c.universe.Tree, List[c.universe.Tree])]">TypeApply</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.TypeApply]" class="delimiter">(</a><span title="c.universe.Tree">fun</span>, _<span class="delimiter">)</span>, _<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <span title="c.universe.MethodSymbol">methodSym</span> = <span title="c.universe.Tree">fun</span>.<span title="=&gt; c.universe.Symbol">symbol</span>.<span title="=&gt; c.universe.MethodSymbol">asMethod</span>

          <span class="keyword">val</span> <a href="#shapeless.Poly.liftFnImpl.x$23.x$19.fSym1" title="(c.universe.Symbol, c.universe.Symbol)" class="delimiter">(</a><a href="#shapeless.Poly.liftFnImpl.x$23.x$19" title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.x$23.x$19.fSym1">fSym1</a>, <a href="#shapeless.Poly.liftFnImpl.x$23.x$19" title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.x$23.x$19.gSym1">gSym1</a><span class="delimiter">)</span> = <a href="#shapeless.Poly.liftFnImpl.destructureMethod" title="(methodSym: c.universe.MethodSymbol)(c.universe.Symbol, c.universe.Symbol)">destructureMethod</a><span title="(c.universe.Symbol, c.universe.Symbol) @unchecked" class="delimiter">(</span><span title="c.universe.MethodSymbol">methodSym</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <span title="c.universe.Apply">body</span> = <a href="#shapeless.Poly.liftFnImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.TypeApply">TypeApply</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><span title="c.universe.MethodSymbol">methodSym</span><span class="delimiter">)</span>, <span title="(xs: c.universe.Ident*)List[c.universe.Ident]">List</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;T&quot;)" class="string">&quot;T&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="(xs: c.universe.Ident*)List[c.universe.Ident]">List</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;t&quot;)" class="string">&quot;t&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

          <span title="(_1: c.universe.Symbol, _2: c.universe.Symbol, _3: c.universe.DefDef)(c.universe.Symbol, c.universe.Symbol, c.universe.DefDef)" class="delimiter">(</span><span title="c.universe.Symbol">fSym1</span>, <span title="c.universe.Symbol">gSym1</span>, <a href="#shapeless.Poly.liftFnImpl.mkApply" title="(fSym: c.universe.Symbol, gSym: c.universe.Symbol, targ: c.universe.TypeName, arg: c.universe.TermName, body: c.universe.Tree)c.universe.DefDef">mkApply</a><span class="delimiter">(</span><span title="c.universe.Symbol">fSym1</span>, <span title="c.universe.Symbol">gSym1</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;T&quot;)" class="string">&quot;T&quot;</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;t&quot;)" class="string">&quot;t&quot;</span><span class="delimiter">)</span>, <span title="c.universe.Apply">body</span><span class="delimiter">)</span><span class="delimiter">)</span>

        <span class="keyword">case</span> <a href="#shapeless.Poly.liftFnImpl.c" title="(block: c.universe.Block)Option[(List[c.universe.Tree], c.universe.Tree)]">Block</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.Block]" class="delimiter">(</a><a href="#shapeless.Poly.liftFnImpl.x$23.<unapply-selector>" title="(x: List[c.universe.Tree])Some[List[c.universe.Tree]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(function: c.universe.Function)Option[(List[c.universe.ValDef], c.universe.Tree)]">Function</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.Function]" class="delimiter">(</a><a href="#shapeless.Poly.liftFnImpl.x$23.<unapply-selector>" title="(x: List[c.universe.ValDef])Some[List[c.universe.ValDef]]">List</a><span class="delimiter">(</span>_<span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(apply: c.universe.Apply)Option[(c.universe.Tree, List[c.universe.Tree])]">Apply</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.Apply]" class="delimiter">(</a><span title="c.universe.Tree">fun</span>, _<span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <span title="c.universe.MethodSymbol">methodSym</span> = <span title="c.universe.Tree">fun</span>.<span title="=&gt; c.universe.Symbol">symbol</span>.<span title="=&gt; c.universe.MethodSymbol">asMethod</span>

          <span class="keyword">val</span> <a href="#shapeless.Poly.liftFnImpl.x$23.x$20.fSym1" title="(c.universe.Symbol, c.universe.Symbol)" class="delimiter">(</a><a href="#shapeless.Poly.liftFnImpl.x$23.x$20" title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.x$23.x$20.fSym1">fSym1</a>, <a href="#shapeless.Poly.liftFnImpl.x$23.x$20" title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.x$23.x$20.gSym1">gSym1</a><span class="delimiter">)</span> = <a href="#shapeless.Poly.liftFnImpl.destructureMethod" title="(methodSym: c.universe.MethodSymbol)(c.universe.Symbol, c.universe.Symbol)">destructureMethod</a><span title="(c.universe.Symbol, c.universe.Symbol) @unchecked" class="delimiter">(</span><span title="c.universe.MethodSymbol">methodSym</span><span class="delimiter">)</span>
          <span class="keyword">val</span> <span title="c.universe.Apply">body</span> = <a href="#shapeless.Poly.liftFnImpl.c" title="(fun: c.universe.Tree, args: List[c.universe.Tree])c.universe.Apply">Apply</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><span title="c.universe.MethodSymbol">methodSym</span><span class="delimiter">)</span>, <span title="(xs: c.universe.Ident*)List[c.universe.Ident]">List</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;t&quot;)" class="string">&quot;t&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

          <span title="(_1: c.universe.Symbol, _2: c.universe.Symbol, _3: c.universe.DefDef)(c.universe.Symbol, c.universe.Symbol, c.universe.DefDef)" class="delimiter">(</span><span title="c.universe.Symbol">fSym1</span>, <span title="c.universe.Symbol">gSym1</span>, <a href="#shapeless.Poly.liftFnImpl.mkApply" title="(fSym: c.universe.Symbol, gSym: c.universe.Symbol, targ: c.universe.TypeName, arg: c.universe.TermName, body: c.universe.Tree)c.universe.DefDef">mkApply</a><span class="delimiter">(</span><span title="c.universe.Symbol">fSym1</span>, <span title="c.universe.Symbol">gSym1</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;T&quot;)" class="string">&quot;T&quot;</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;t&quot;)" class="string">&quot;t&quot;</span><span class="delimiter">)</span>, <span title="c.universe.Apply">body</span><span class="delimiter">)</span><span class="delimiter">)</span>

        <span class="keyword">case</span> <a href="#shapeless.Poly.liftFnImpl.c" title="(block: c.universe.Block)Option[(List[c.universe.Tree], c.universe.Tree)]">Block</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.Block]" class="delimiter">(</a><a href="#shapeless.Poly.liftFnImpl.x$23.<unapply-selector>" title="(x: List[c.universe.Tree])Some[List[c.universe.Tree]]">List</a><span class="delimiter">(</span><span title="c.universe.DefDef">df</span> @ <a href="#shapeless.Poly.liftFnImpl.c" title="(defDef: c.universe.DefDef)Option[(c.universe.Modifiers, c.universe.Name, List[c.universe.TypeDef], List[List[c.universe.ValDef]], c.universe.Tree, c.universe.Tree)]">DefDef</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.DefDef]" class="delimiter">(</a><a title="c.universe.Modifiers" id="shapeless.Poly.liftFnImpl.x$23.mods">mods</a>, _, <a href="#shapeless.Poly.liftFnImpl.x$23.<unapply-selector>" title="(x: List[c.universe.TypeDef])Some[List[c.universe.TypeDef]]">List</a><span class="delimiter">(</span><a title="c.universe.TypeDef" id="shapeless.Poly.liftFnImpl.x$23.tp">tp</a><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.x$23.<unapply-selector>" title="(x: List[List[c.universe.ValDef]])Some[List[List[c.universe.ValDef]]]">List</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.x$23.<unapply-selector>" title="(x: List[c.universe.ValDef])Some[List[c.universe.ValDef]]">List</a><span class="delimiter">(</span><span title="c.universe.ValDef">vp</span><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="c.universe.Tree">tpt</span>, <span title="c.universe.Tree">rhs</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(literal: c.universe.Literal)Option[c.universe.Constant]">Literal</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.Literal]" class="delimiter">(</a><a href="#shapeless.Poly.liftFnImpl.c" title="(arg: c.universe.Constant)Option[Any]">Constant</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.Constant]" class="delimiter">(</a><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <span title="c.universe.MethodSymbol">methodSym</span> = <span title="c.universe.DefDef">df</span>.<span title="=&gt; c.universe.Symbol">symbol</span>.<span title="=&gt; c.universe.MethodSymbol">asMethod</span>

          <span class="keyword">val</span> <a href="#shapeless.Poly.liftFnImpl.x$23.x$21.fSym1" title="(c.universe.Symbol, c.universe.Symbol)" class="delimiter">(</a><a href="#shapeless.Poly.liftFnImpl.x$23.x$21" title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.x$23.x$21.fSym1">fSym1</a>, <a href="#shapeless.Poly.liftFnImpl.x$23.x$21" title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.x$23.x$21.gSym1">gSym1</a><span class="delimiter">)</span> = <a href="#shapeless.Poly.liftFnImpl.destructureMethod" title="(methodSym: c.universe.MethodSymbol)(c.universe.Symbol, c.universe.Symbol)">destructureMethod</a><span title="(c.universe.Symbol, c.universe.Symbol) @unchecked" class="delimiter">(</span><span title="c.universe.MethodSymbol">methodSym</span><span class="delimiter">)</span>

          <span class="keyword">val</span> <span title="c.universe.DefDef">body</span> = <a href="#shapeless.Poly.liftFnImpl.mkApply" title="(fSym: c.universe.Symbol, gSym: c.universe.Symbol, targ: c.universe.TypeName, arg: c.universe.TermName, body: c.universe.Tree)c.universe.DefDef">mkApply</a><span class="delimiter">(</span><span title="c.universe.Symbol">fSym1</span>, <span title="c.universe.Symbol">gSym1</span>, <a href="#shapeless.Poly.liftFnImpl.x$23.tp" title="c.universe.TypeDef">tp</a>.<span title="=&gt; c.universe.TypeName">name</span>, <span title="c.universe.ValDef">vp</span>.<span title="=&gt; c.universe.TermName">name</span>, <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes" title="(tree: c.universe.Tree, internalSyms: List[c.universe.Symbol])c.universe.Tree">stripSymbolsAndTypes</a><span class="delimiter">(</span><span title="c.universe.Tree">rhs</span>, List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>

          <span title="(_1: c.universe.Symbol, _2: c.universe.Symbol, _3: c.universe.DefDef)(c.universe.Symbol, c.universe.Symbol, c.universe.DefDef)" class="delimiter">(</span><span title="c.universe.Symbol">fSym1</span>, <span title="c.universe.Symbol">gSym1</span>, <span title="c.universe.DefDef">body</span><span class="delimiter">)</span>

        <span class="keyword">case</span> <a href="#shapeless.Poly.liftFnImpl.c" title="(block: c.universe.Block)Option[(List[c.universe.Tree], c.universe.Tree)]">Block</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.Block]" class="delimiter">(</a><a href="#shapeless.Poly.liftFnImpl.x$23.<unapply-selector>" title="(x: List[c.universe.Tree])Some[List[c.universe.Tree]]">List</a><span class="delimiter">(</span><span title="c.universe.DefDef">df</span> @ <a href="#shapeless.Poly.liftFnImpl.c" title="(defDef: c.universe.DefDef)Option[(c.universe.Modifiers, c.universe.Name, List[c.universe.TypeDef], List[List[c.universe.ValDef]], c.universe.Tree, c.universe.Tree)]">DefDef</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.DefDef]" class="delimiter">(</a>_, _, <a href="#shapeless.Poly.liftFnImpl.x$23.<unapply-selector>" title="(x: List[c.universe.TypeDef])Some[List[c.universe.TypeDef]]">List</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.x$23.<unapply-selector>" title="(x: List[List[c.universe.ValDef]])Some[List[List[c.universe.ValDef]]]">List</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.x$23.<unapply-selector>" title="(x: List[c.universe.ValDef])Some[List[c.universe.ValDef]]">List</a><span class="delimiter">(</span><span title="c.universe.ValDef">vp</span><span class="delimiter">)</span><span class="delimiter">)</span>, <span title="c.universe.Tree">tpt</span>, <span title="c.universe.Tree">rhs</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(literal: c.universe.Literal)Option[c.universe.Constant]">Literal</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.Literal]" class="delimiter">(</a><a href="#shapeless.Poly.liftFnImpl.c" title="(arg: c.universe.Constant)Option[Any]">Constant</a><a href="#shapeless.Poly.liftFnImpl.c" title="(x: Any)Option[c.universe.Constant]" class="delimiter">(</a><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span> =&gt;
          <span class="keyword">val</span> <span title="c.universe.MethodSymbol">methodSym</span> = <span title="c.universe.DefDef">df</span>.<span title="=&gt; c.universe.Symbol">symbol</span>.<span title="=&gt; c.universe.MethodSymbol">asMethod</span>

          <span class="keyword">val</span> <a href="#shapeless.Poly.liftFnImpl.x$23.x$22.fSym1" title="(c.universe.Symbol, c.universe.Symbol)" class="delimiter">(</a><a href="#shapeless.Poly.liftFnImpl.x$23.x$22" title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.x$23.x$22.fSym1">fSym1</a>, <a href="#shapeless.Poly.liftFnImpl.x$23.x$22" title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.x$23.x$22.gSym1">gSym1</a><span class="delimiter">)</span> = <a href="#shapeless.Poly.liftFnImpl.destructureMethod" title="(methodSym: c.universe.MethodSymbol)(c.universe.Symbol, c.universe.Symbol)">destructureMethod</a><span title="(c.universe.Symbol, c.universe.Symbol) @unchecked" class="delimiter">(</span><span title="c.universe.MethodSymbol">methodSym</span><span class="delimiter">)</span>

          <span class="keyword">val</span> <span title="c.universe.DefDef">body</span> = <a href="#shapeless.Poly.liftFnImpl.mkApply" title="(fSym: c.universe.Symbol, gSym: c.universe.Symbol, targ: c.universe.TypeName, arg: c.universe.TermName, body: c.universe.Tree)c.universe.DefDef">mkApply</a><span class="delimiter">(</span><span title="c.universe.Symbol">fSym1</span>, <span title="c.universe.Symbol">gSym1</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;T&quot;)" class="string">&quot;T&quot;</span><span class="delimiter">)</span>, <span title="c.universe.ValDef">vp</span>.<span title="=&gt; c.universe.TermName">name</span>, <a href="#shapeless.Poly.liftFnImpl.stripSymbolsAndTypes" title="(tree: c.universe.Tree, internalSyms: List[c.universe.Symbol])c.universe.Tree">stripSymbolsAndTypes</a><span class="delimiter">(</span><span title="c.universe.Tree">rhs</span>, List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span title="(_1: c.universe.Symbol, _2: c.universe.Symbol, _3: c.universe.DefDef)(c.universe.Symbol, c.universe.Symbol, c.universe.DefDef)" class="delimiter">(</span><span title="c.universe.Symbol">fSym1</span>, <span title="c.universe.Symbol">gSym1</span>, <span title="c.universe.DefDef">body</span><span class="delimiter">)</span>

        <span class="keyword">case</span> _ =&gt;
          <a href="#shapeless.Poly.liftFnImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="(pos: c.Position, msg: String)Nothing">abort</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="=&gt; c.Position">enclosingPosition</span>, <span title="(args: Any*)String">s</span>&quot;<span title="String(&quot;Unable to convert expression &quot;)">Unable to convert expression $</span><a href="#shapeless.Poly.liftFnImpl.f" title="c.Expr[Any]">f</a><span title="String(&quot; to a polymorphic function value&quot;)" class="string"> to a polymorphic function value&quot;</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>

    <span class="keyword">def</span> <a title="(sym: c.universe.Symbol)c.universe.RefTree with c.universe.SymTree with c.universe.NameTree with c.universe.RefTreeApi with c.universe.Tree with c.universe.NameTreeApi" id="shapeless.Poly.liftFnImpl.mkTargTree">mkTargTree</a><span class="delimiter">(</span><a title="c.universe.Symbol" id="shapeless.Poly.liftFnImpl.mkTargTree.sym">sym</a>: <span title="c.universe.Symbol">Symbol</span><span class="delimiter">)</span> =
      <span title="liftFnImpl extends c.universe.RefTree with c.universe.SymTree with c.universe.NameTree with c.universe.RefTreeApi with c.universe.Tree with c.universe.NameTreeApi" class="keyword">if</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.mkTargTree.sym" title="c.universe.Symbol">sym</a> <span title="(x$1: AnyRef)Boolean">==</span> <a href="#shapeless.Poly.liftFnImpl.idSym" title="c.universe.TypeSymbol">idSym</a><span class="delimiter">)</span>
        <a href="#shapeless.Poly.liftFnImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;shapeless&quot;)" class="string">&quot;shapeless&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;Id&quot;)" class="string">&quot;Id&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="keyword">else</span> <span title="liftFnImpl extends c.universe.RefTree with c.universe.SymTree with c.universe.NameTree with c.universe.RefTreeApi with c.universe.Tree with c.universe.NameTreeApi" class="keyword">if</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.mkTargTree.sym" title="c.universe.Symbol">sym</a>.<span title="=&gt; c.universe.TypeSymbol">asType</span>.<span title="=&gt; List[c.universe.Symbol]">typeParams</span>.<span title="=&gt; Boolean">isEmpty</span><span class="delimiter">)</span>
        <a href="#shapeless.Poly.liftFnImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.TypeName)c.universe.SelectFromTypeTree">SelectFromTypeTree</a><span class="delimiter">(</span>
          <a href="#shapeless.Poly.liftFnImpl.c" title="(tpt: c.universe.Tree, args: List[c.universe.Tree])c.universe.AppliedTypeTree">AppliedTypeTree</a><span class="delimiter">(</span>
            <a href="#shapeless.Poly.liftFnImpl.c" title="(qualifier: c.universe.Tree, name: c.universe.Name)c.universe.Select">Select</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TermName">newTermName</a><span class="delimiter">(</span><span title="String(&quot;shapeless&quot;)" class="string">&quot;shapeless&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;Const&quot;)" class="string">&quot;Const&quot;</span><span class="delimiter">)</span><span class="delimiter">)</span>,
            <span title="(xs: c.universe.Ident*)List[c.universe.Ident]">List</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.mkTargTree.sym" title="c.universe.Symbol">sym</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span><span class="delimiter">)</span>
          <span class="delimiter">)</span>,
          <a href="#shapeless.Poly.liftFnImpl.c" title="(s: String)c.universe.TypeName">newTypeName</a><span class="delimiter">(</span><span title="String(&quot;λ&quot;)" class="string">&quot;λ&quot;</span><span class="delimiter">)</span>
        <span class="delimiter">)</span>
      <span class="keyword">else</span>
        <a href="#shapeless.Poly.liftFnImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.mkTargTree.sym" title="c.universe.Symbol">sym</a>.<span title="=&gt; c.universe.Name">name</span><span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="c.universe.AppliedTypeTree" id="shapeless.Poly.liftFnImpl.liftedTypeTree">liftedTypeTree</a> =
      <a href="#shapeless.Poly.liftFnImpl.c" title="(tpt: c.universe.Tree, args: List[c.universe.Tree])c.universe.AppliedTypeTree">AppliedTypeTree</a><span class="delimiter">(</span>
        <a href="#shapeless.Poly.liftFnImpl.c" title="(sym: c.universe.Symbol)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.natTSym" title="c.universe.ClassSymbol">natTSym</a><span class="delimiter">)</span>,
        <span title="(xs: c.universe.RefTree with c.universe.SymTree with c.universe.NameTree with c.universe.RefTreeApi with c.universe.Tree with c.universe.NameTreeApi*)List[c.universe.RefTree with c.universe.SymTree with c.universe.NameTree with c.universe.RefTreeApi with c.universe.Tree with c.universe.NameTreeApi]">List</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.mkTargTree" title="(sym: c.universe.Symbol)c.universe.RefTree with c.universe.SymTree with c.universe.NameTree with c.universe.RefTreeApi with c.universe.Tree with c.universe.NameTreeApi">mkTargTree</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.fSym" title="c.universe.Symbol">fSym</a><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.mkTargTree" title="(sym: c.universe.Symbol)c.universe.RefTree with c.universe.SymTree with c.universe.NameTree with c.universe.RefTreeApi with c.universe.Tree with c.universe.NameTreeApi">mkTargTree</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.gSym" title="c.universe.Symbol">gSym</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">)</span>

    <span class="keyword">val</span> <a title="c.universe.ModuleDef" id="shapeless.Poly.liftFnImpl.moduleDef">moduleDef</a> =
      <a href="#shapeless.Poly.liftFnImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.TermName, impl: c.universe.Template)c.universe.ModuleDef">ModuleDef</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="()c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.moduleName" title="c.universe.TermName">moduleName</a>,
        <a href="#shapeless.Poly.liftFnImpl.c" title="(parents: List[c.universe.Tree], self: c.universe.ValDef, body: List[c.universe.Tree])c.universe.Template">Template</a><span class="delimiter">(</span>
          <span title="(xs: c.universe.AppliedTypeTree*)List[c.universe.AppliedTypeTree]">List</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.liftedTypeTree" title="c.universe.AppliedTypeTree">liftedTypeTree</a><span class="delimiter">)</span>,
          <a href="#shapeless.Poly.liftFnImpl.c" title="=&gt; c.universe.ValDef">emptyValDef</a>,
          <span title="(xs: c.universe.DefDef*)List[c.universe.DefDef]">List</span><span class="delimiter">(</span>
            <a href="#shapeless.Poly.liftFnImpl.c" title="(mods: c.universe.Modifiers, name: c.universe.Name, tparams: List[c.universe.TypeDef], vparamss: List[List[c.universe.ValDef]], tpt: c.universe.Tree, rhs: c.universe.Tree)c.universe.DefDef">DefDef</a><span class="delimiter">(</span>
              <a href="#shapeless.Poly.liftFnImpl.c" title="()c.universe.Modifiers">Modifiers</a><span class="delimiter">(</span><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="=&gt; c.universe.TermNamesApi">nme</a>.<span title="=&gt; c.universe.nme.NameType">CONSTRUCTOR</span>, List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span>,
              <span title="(xs: List[Nothing]*)List[List[Nothing]]">List</span><span class="delimiter">(</span>List<span title="scala.collection.immutable.Nil.type" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span>,
              <a href="#shapeless.Poly.liftFnImpl.c" title="()c.universe.TypeTree">TypeTree</a><span class="delimiter">(</span><span class="delimiter">)</span>,
              <a href="#shapeless.Poly.liftFnImpl.c" title="(stats: List[c.universe.Tree], expr: c.universe.Tree)c.universe.Block">Block</a><span class="delimiter">(</span><span title="(xs: c.universe.Apply*)List[c.universe.Apply]">List</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.pendingSuperCall" title="c.universe.Apply">pendingSuperCall</a><span class="delimiter">)</span>, <a href="#shapeless.Poly.liftFnImpl.c" title="(value: c.universe.Constant)c.universe.Literal">Literal</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.c" title="(value: Any)c.universe.Constant">Constant</a><span class="delimiter">(</span><span title="Unit" class="delimiter">(</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">)</span>,

            <a href="#shapeless.Poly.liftFnImpl.dd" title="c.universe.DefDef">dd</a>
          <span class="delimiter">)</span>
        <span class="delimiter">)</span>
      <span class="delimiter">)</span>

    <a href="#shapeless.Poly.liftFnImpl.c" title="scala.reflect.macros.Context">c</a>.<span title="[T](tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[T])c.Expr[T]">Expr</span><span title="(tree: c.Tree)(implicit evidence$1: c.WeakTypeTag[shapeless.Poly])c.Expr[shapeless.Poly]" class="delimiter">[</span><a href="#shapeless;Poly" title="shapeless.Poly">Poly</a><span class="delimiter">]</span> <a href="#shapeless.Poly.liftFnImpl.c" title="c.universe.type" id="shapeless.Poly.liftFnImpl;$typecreator3.apply.$m" class="delimiter">{</a>
      <a href="#shapeless.Poly.liftFnImpl.c" title="(stats: List[c.universe.Tree], expr: c.universe.Tree)c.universe.Block">Block</a><span class="delimiter">(</span>
        <span title="(xs: c.universe.ModuleDef*)List[c.universe.ModuleDef]">List</span><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.moduleDef" title="c.universe.ModuleDef">moduleDef</a><span class="delimiter">)</span>,
        <a href="#shapeless.Poly.liftFnImpl.c" title="(name: c.universe.Name)c.universe.Ident">Ident</a><span class="delimiter">(</span><a href="#shapeless.Poly.liftFnImpl.moduleName" title="c.universe.TermName">moduleName</a><span class="delimiter">)</span>
      <span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

<span class="comment">/**
 * Trait simplifying the creation of polymorphic values.
 */</span>
<span class="keyword">trait</span> <a title="trait Poly0 extends AnyRef with shapeless.Poly" id="shapeless;Poly0">Poly0</a> <span title="Unit" class="keyword">extends</span> <a href="#shapeless;Poly" title="shapeless.Poly">Poly</a> <span class="delimiter">{</span>
  <span class="keyword">type</span> <a title="[T]Poly0.this.ProductCase.Aux[shapeless.HNil,T]" id="shapeless;Poly0;Case0">Case0</a><span class="delimiter">[</span><a title="" id="shapeless;Poly0;Case0;T">T</a><span class="delimiter">]</span> = ProductCase.<a href="#shapeless;Poly.ProductCase;<refinement>" title="Poly0.this.ProductCase.Aux[shapeless.HNil,T]">Aux</a><span class="delimiter">[</span>HNil, T<span class="delimiter">]</span>
  
  <span class="keyword">def</span> <a title="[T](t: T)Poly0.this.ProductCase[shapeless.HNil]{type Result = T}" id="shapeless;Poly0.at">at</a><span class="delimiter">[</span><a title="" id="shapeless;Poly0.at;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="T" id="shapeless;Poly0.at.t">t</a>: <a href="#shapeless;Poly0.at;T" title="T">T</a><span class="delimiter">)</span> = <a href="#shapeless;Poly0.at;$anon" title="Poly0.this.ProductCase[shapeless.HNil]{}" class="keyword">new</a> <a title="anonymous class $anon extends Poly0.this.ProductCase[shapeless.HNil]" id="shapeless;Poly0.at;$anon">ProductCase</a><span class="delimiter">[</span>HNil<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="T" id="shapeless;Poly0.at;$anon;Result">Result</a> = <a href="#shapeless;Poly0.at;T" title="T">T</a>
    <span class="keyword">val</span> <a title="shapeless.HNil =&gt; T" id="shapeless;Poly0.at;$anon.value">value</a> = <span class="delimiter">(</span>l : <a href="hlists.scala.html#shapeless;HNil" title="shapeless.HNil">HNil</a><span class="delimiter">)</span> =&gt; <a href="#shapeless;Poly0.at.t" title="T">t</a>
  <span class="delimiter">}</span>
<span class="delimiter">}</span>

        </pre>
    </body>
</html>
