<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" ></meta>
        <title>shapeless/zipper.scala</title>
        <script type="text/javascript" src="../jquery-all.js"></script>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style"></link>
    </head>
    <body>
        <pre>
<span class="comment">/*
 * Copyright (c) 2012-13 Miles Sabin 
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span class="keyword">package</span> shapeless

<span class="keyword">import</span> ops.<a href="ops/hlists.scala.html#shapeless.ops.hlist" title="shapeless.ops.hlist.type">hlist</a>.<span class="delimiter">{</span> IsHCons, ReversePrepend, Split, SplitLeft <span class="delimiter">}</span>

<span class="comment">/**
 * Generic Zipper for any type with a representation via `Generic`.
 * 
 * @author Miles Sabin
 */</span>
<span class="keyword">case class</span> <a href="#shapeless;Zipper.productElement.x$1" title="class Zipper[C, L &lt;: shapeless.HList, R &lt;: shapeless.HList, P] extends AnyRef with Product with Serializable" id="shapeless;Zipper">Zipper</a><span class="delimiter">[</span><a title="" id="shapeless;Zipper;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless;Zipper;L">L</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless;Zipper;R">R</a> &lt;: HList, <a title="" id="shapeless;Zipper;P">P</a><span class="delimiter">]</span><a href="#shapeless;Zipper" title="Product" class="delimiter">(</a><a title="L" id="shapeless;Zipper.prefix">prefix</a> : <a href="#shapeless;Zipper;L" title="L">L</a>, <a title="R" id="shapeless;Zipper.suffix">suffix</a> : <a href="#shapeless;Zipper;R" title="R">R</a>, <a title="P" id="shapeless;Zipper.parent">parent</a> : <a href="#shapeless;Zipper;P" title="P">P</a><span class="delimiter">)</span> <span class="delimiter">{</span>
  <span class="keyword">import</span> <a href="#shapeless.Zipper.readResolve" title="shapeless.Zipper.type">Zipper</a>._
  
  <span class="keyword">type</span> <a title="shapeless.Zipper[C,L,R,P]" id="shapeless;Zipper;Self">Self</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]">Zipper</a><span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span>
  
  <span class="comment">/** Move the cursor one place to the right. Available only if not already at the rightmost element. */</span>
  <span class="keyword">def</span> <a title="(implicit right: shapeless.Zipper.Right[Zipper.this.Self])right.Out" id="shapeless;Zipper.right">right</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.Right[Zipper.this.Self]" id="shapeless;Zipper.right.right">right</a> : <a href="#shapeless.Zipper;Right" title="shapeless.Zipper.Right[Zipper.this.Self]">Right</a><span class="delimiter">[</span>Self<span class="delimiter">]</span><span class="delimiter">)</span> : right.<a href="#shapeless.Zipper;ZipperOp0;Out" title="right.Out">Out</a> = <a href="#shapeless.Zipper;ZipperOp0.apply" title="(z: Zipper.this.Self)right.Out">right</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>
  
  <span class="comment">/** Move the cursor one place to the left. Available only if not already at the leftmost element. */</span>
  <span class="keyword">def</span> <a title="(implicit left: shapeless.Zipper.Left[Zipper.this.Self])left.Out" id="shapeless;Zipper.left">left</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.Left[Zipper.this.Self]" id="shapeless;Zipper.left.left">left</a> : <a href="#shapeless.Zipper;Left" title="shapeless.Zipper.Left[Zipper.this.Self]">Left</a><span class="delimiter">[</span>Self<span class="delimiter">]</span><span class="delimiter">)</span> : left.<a href="#shapeless.Zipper;ZipperOp0;Out" title="left.Out">Out</a> = <a href="#shapeless.Zipper;ZipperOp0.apply" title="(z: Zipper.this.Self)left.Out">left</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>

  <span class="comment">/** Moves the cursor to the leftmost position. */</span>
  <span class="keyword">def</span> <a title="(implicit first: shapeless.Zipper.First[Zipper.this.Self])first.Out" id="shapeless;Zipper.first">first</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.First[Zipper.this.Self]" id="shapeless;Zipper.first.first">first</a> : <a href="#shapeless.Zipper;First" title="shapeless.Zipper.First[Zipper.this.Self]">First</a><span class="delimiter">[</span>Self<span class="delimiter">]</span><span class="delimiter">)</span> : first.<a href="#shapeless.Zipper;ZipperOp0;Out" title="first.Out">Out</a> = <a href="#shapeless.Zipper;ZipperOp0.apply" title="(z: Zipper.this.Self)first.Out">first</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>
  
  <span class="comment">/** Moves the cursor to the rightmost position. */</span>
  <span class="keyword">def</span> <a title="(implicit last: shapeless.Zipper.Last[Zipper.this.Self])last.Out" id="shapeless;Zipper.last">last</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.Last[Zipper.this.Self]" id="shapeless;Zipper.last.last">last</a> : <a href="#shapeless.Zipper;Last" title="shapeless.Zipper.Last[Zipper.this.Self]">Last</a><span class="delimiter">[</span>Self<span class="delimiter">]</span><span class="delimiter">)</span> : last.<a href="#shapeless.Zipper;ZipperOp0;Out" title="last.Out">Out</a> = <a href="#shapeless.Zipper;ZipperOp0.apply" title="(z: Zipper.this.Self)last.Out">last</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>
  
  <span class="comment">/** Move the cursor ''n'' places to the right. Requires an explicit type argument. Available only if there are
   * ''n'' places to the right of the cursor. */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat](implicit rightBy: shapeless.Zipper.RightBy[Zipper.this.Self,N])rightBy.Out" id="shapeless;Zipper.rightBy(d829a7bb1c)">rightBy</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless;Zipper.rightBy(d829a7bb1c);N">N</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.RightBy[Zipper.this.Self,N]" id="shapeless;Zipper.rightBy(d829a7bb1c).rightBy">rightBy</a> : <a href="#shapeless.Zipper;RightBy" title="shapeless.Zipper.RightBy[Zipper.this.Self,N]">RightBy</a><span class="delimiter">[</span>Self, N<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Zipper;ZipperOp0Nat.apply" title="(z: Zipper.this.Self)rightBy.Out">rightBy</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>

  <span class="comment">/** Move the cursor ''n'' places to the right. Available only if there are ''n'' places to the right of the cursor. */</span>
  <span class="keyword">def</span> <a title="(n: shapeless.Nat)(implicit rightBy: shapeless.Zipper.RightBy[Zipper.this.Self,n.N])rightBy.Out" id="shapeless;Zipper.rightBy(934ed11b1f)">rightBy</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless;Zipper.rightBy(934ed11b1f).n">n</a>: <a href="nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.RightBy[Zipper.this.Self,n.N]" id="shapeless;Zipper.rightBy(934ed11b1f).rightBy">rightBy</a> : <a href="#shapeless.Zipper;RightBy" title="shapeless.Zipper.RightBy[Zipper.this.Self,n.N]">RightBy</a><span class="delimiter">[</span>Self, n.N<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Zipper;ZipperOp0Nat.apply" title="(z: Zipper.this.Self)rightBy.Out">rightBy</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>

  <span class="comment">/** Move the cursor ''n'' places to the left. Requires an explicit type argument. Available only if there are
   * ''n'' places to the left of the cursor. */</span>
  <span class="keyword">def</span> <a title="[N &lt;: shapeless.Nat](implicit leftBy: shapeless.Zipper.LeftBy[Zipper.this.Self,N])leftBy.Out" id="shapeless;Zipper.leftBy(7356294c16)">leftBy</a><span class="delimiter">[</span><a title=" &lt;: shapeless.Nat" id="shapeless;Zipper.leftBy(7356294c16);N">N</a> &lt;: Nat<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.LeftBy[Zipper.this.Self,N]" id="shapeless;Zipper.leftBy(7356294c16).leftBy">leftBy</a> : <a href="#shapeless.Zipper;LeftBy" title="shapeless.Zipper.LeftBy[Zipper.this.Self,N]">LeftBy</a><span class="delimiter">[</span>Self, N<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Zipper;ZipperOp0Nat.apply" title="(z: Zipper.this.Self)leftBy.Out">leftBy</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>

  <span class="comment">/** Move the cursor ''n'' places to the left. Available only if there are ''n'' places to the right of the cursor. */</span>
  <span class="keyword">def</span> <a title="(n: shapeless.Nat)(implicit leftBy: shapeless.Zipper.LeftBy[Zipper.this.Self,n.N])leftBy.Out" id="shapeless;Zipper.leftBy(0da9da273d)">leftBy</a><span class="delimiter">(</span><a title="shapeless.Nat" id="shapeless;Zipper.leftBy(0da9da273d).n">n</a>: <a href="nat.scala.html#shapeless;Nat" title="shapeless.Nat">Nat</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.LeftBy[Zipper.this.Self,n.N]" id="shapeless;Zipper.leftBy(0da9da273d).leftBy">leftBy</a> : <a href="#shapeless.Zipper;LeftBy" title="shapeless.Zipper.LeftBy[Zipper.this.Self,n.N]">LeftBy</a><span class="delimiter">[</span>Self, n.N<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Zipper;ZipperOp0Nat.apply" title="(z: Zipper.this.Self)leftBy.Out">leftBy</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>

  <span class="comment">/** Move the cursor to the first element of type `T` to the right. Available only if there is an element of type `T`
   * to the right of the cursor.
   */</span>
  <span class="keyword">def</span> <a title="[T](implicit rightTo: shapeless.Zipper.RightTo[Zipper.this.Self,T])rightTo.Out" id="shapeless;Zipper.rightTo">rightTo</a><span class="delimiter">[</span><a title="" id="shapeless;Zipper.rightTo;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.RightTo[Zipper.this.Self,T]" id="shapeless;Zipper.rightTo.rightTo">rightTo</a> : <a href="#shapeless.Zipper;RightTo" title="shapeless.Zipper.RightTo[Zipper.this.Self,T]">RightTo</a><span class="delimiter">[</span>Self, T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Zipper;ZipperOp0T.apply" title="(z: Zipper.this.Self)rightTo.Out">rightTo</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>

  <span class="comment">/** Move the cursor to the first element of type `T` to the left. Available only if there is an element of type `T`
   * to the left of the cursor.
   */</span>
  <span class="keyword">def</span> <a title="[T](implicit leftTo: shapeless.Zipper.LeftTo[Zipper.this.Self,T])leftTo.Out" id="shapeless;Zipper.leftTo">leftTo</a><span class="delimiter">[</span><a title="" id="shapeless;Zipper.leftTo;T">T</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.LeftTo[Zipper.this.Self,T]" id="shapeless;Zipper.leftTo.leftTo">leftTo</a> : <a href="#shapeless.Zipper;LeftTo" title="shapeless.Zipper.LeftTo[Zipper.this.Self,T]">LeftTo</a><span class="delimiter">[</span>Self, T<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Zipper;ZipperOp0T.apply" title="(z: Zipper.this.Self)leftTo.Out">leftTo</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>
  
  <span class="comment">/** Moves the cursor up to the next level. The element at the new cursor position will be updated with the
   * reification of the current level.
   */</span>
  <span class="keyword">def</span> <a title="(implicit up: shapeless.Zipper.Up[Zipper.this.Self])up.Out" id="shapeless;Zipper.up">up</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.Up[Zipper.this.Self]" id="shapeless;Zipper.up.up">up</a> : <a href="#shapeless.Zipper;Up" title="shapeless.Zipper.Up[Zipper.this.Self]">Up</a><span class="delimiter">[</span>Self<span class="delimiter">]</span><span class="delimiter">)</span> : up.<a href="#shapeless.Zipper;ZipperOp0;Out" title="up.Out">Out</a> = <a href="#shapeless.Zipper;ZipperOp0.apply" title="(z: Zipper.this.Self)up.Out">up</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>
  
  <span class="comment">/** Moves the cursor down to the next level, placing it at the first element on the left. Available only if the
   * element current at the cursor has a representation via `Generic`.
   */</span>
  <span class="keyword">def</span> <a title="(implicit down: shapeless.Zipper.Down[Zipper.this.Self])down.Out" id="shapeless;Zipper.down">down</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.Down[Zipper.this.Self]" id="shapeless;Zipper.down.down">down</a> : <a href="#shapeless.Zipper;Down" title="shapeless.Zipper.Down[Zipper.this.Self]">Down</a><span class="delimiter">[</span>Self<span class="delimiter">]</span><span class="delimiter">)</span> : down.<a href="#shapeless.Zipper;ZipperOp0;Out" title="down.Out">Out</a> = <a href="#shapeless.Zipper;ZipperOp0.apply" title="(z: Zipper.this.Self)down.Out">down</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>
  
  <span class="comment">/** Moves the cursor to root of this Zipper. */</span>
  <span class="keyword">def</span> <a title="(implicit root: shapeless.Zipper.Root[Zipper.this.Self])root.Out" id="shapeless;Zipper.root">root</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.Root[Zipper.this.Self]" id="shapeless;Zipper.root.root">root</a> : <a href="#shapeless.Zipper;Root" title="shapeless.Zipper.Root[Zipper.this.Self]">Root</a><span class="delimiter">[</span>Self<span class="delimiter">]</span><span class="delimiter">)</span> : root.<a href="#shapeless.Zipper;ZipperOp0;Out" title="root.Out">Out</a> = <a href="#shapeless.Zipper;ZipperOp0.apply" title="(z: Zipper.this.Self)root.Out">root</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>

  <span class="comment">/** Returns the element at the cursor. Available only if the underlying `HList` is non-empty. */</span>
  <span class="keyword">def</span> <a title="(implicit get: shapeless.Zipper.Get[Zipper.this.Self])get.Out" id="shapeless;Zipper.get">get</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.Get[Zipper.this.Self]" id="shapeless;Zipper.get.get">get</a> : <a href="#shapeless.Zipper;Get" title="shapeless.Zipper.Get[Zipper.this.Self]">Get</a><span class="delimiter">[</span>Self<span class="delimiter">]</span><span class="delimiter">)</span> : get.<a href="#shapeless.Zipper;ZipperOp0;Out" title="get.Out">Out</a> = <a href="#shapeless.Zipper;ZipperOp0.apply" title="(z: Zipper.this.Self)get.Out">get</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>

  <span class="comment">/** Replaces the element at the cursor. Available only if the underlying `HList` is non-empty. */</span>
  <span class="keyword">def</span> <a title="[E](e: E)(implicit put: shapeless.Zipper.Put[Zipper.this.Self,E])put.Out" id="shapeless;Zipper.put">put</a><span class="delimiter">[</span><a title="" id="shapeless;Zipper.put;E">E</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="E" id="shapeless;Zipper.put.e">e</a> : <a href="#shapeless;Zipper.put;E" title="E">E</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.Put[Zipper.this.Self,E]" id="shapeless;Zipper.put.put">put</a> : <a href="#shapeless.Zipper;Put" title="shapeless.Zipper.Put[Zipper.this.Self,E]">Put</a><span class="delimiter">[</span>Self, E<span class="delimiter">]</span><span class="delimiter">)</span> : put.<a href="#shapeless.Zipper;ZipperOp1;Out" title="put.Out">Out</a> = <a href="#shapeless.Zipper;ZipperOp1.apply" title="(z: Zipper.this.Self, t: E)put.Out">put</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a>, <a href="#shapeless;Zipper.put.e" title="E">e</a><span class="delimiter">)</span>

  <span class="comment">/** Inserts a new element to the left of the cursor. */</span>
  <span class="keyword">def</span> <a title="[E](e: E)(implicit insert: shapeless.Zipper.Insert[Zipper.this.Self,E])insert.Out" id="shapeless;Zipper.insert">insert</a><span class="delimiter">[</span><a title="" id="shapeless;Zipper.insert;E">E</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="E" id="shapeless;Zipper.insert.e">e</a> : <a href="#shapeless;Zipper.insert;E" title="E">E</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.Insert[Zipper.this.Self,E]" id="shapeless;Zipper.insert.insert">insert</a> : <a href="#shapeless.Zipper;Insert" title="shapeless.Zipper.Insert[Zipper.this.Self,E]">Insert</a><span class="delimiter">[</span>Self, E<span class="delimiter">]</span><span class="delimiter">)</span> : insert.<a href="#shapeless.Zipper;ZipperOp1;Out" title="insert.Out">Out</a> = <a href="#shapeless.Zipper;ZipperOp1.apply" title="(z: Zipper.this.Self, t: E)insert.Out">insert</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a>, <a href="#shapeless;Zipper.insert.e" title="E">e</a><span class="delimiter">)</span>

  <span class="comment">/** Removes the element at the cursor. Available only if the underlying `HList` is non-empty. */</span>
  <span class="keyword">def</span> <a title="(implicit delete: shapeless.Zipper.Delete[Zipper.this.Self])delete.Out" id="shapeless;Zipper.delete">delete</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.Delete[Zipper.this.Self]" id="shapeless;Zipper.delete.delete">delete</a> : <a href="#shapeless.Zipper;Delete" title="shapeless.Zipper.Delete[Zipper.this.Self]">Delete</a><span class="delimiter">[</span>Self<span class="delimiter">]</span><span class="delimiter">)</span> : delete.<a href="#shapeless.Zipper;ZipperOp0;Out" title="delete.Out">Out</a> = <a href="#shapeless.Zipper;ZipperOp0.apply" title="(z: Zipper.this.Self)delete.Out">delete</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>
  
  <span class="comment">/** Reifies the current level of this `Zipper`. */</span>
  <span class="keyword">def</span> <a title="(implicit reify: shapeless.Zipper.Reify[Zipper.this.Self])reify.Out" id="shapeless;Zipper.reify">reify</a><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Zipper.Reify[Zipper.this.Self]" id="shapeless;Zipper.reify.reify">reify</a> : <a href="#shapeless.Zipper;Reify" title="shapeless.Zipper.Reify[Zipper.this.Self]">Reify</a><span class="delimiter">[</span>Self<span class="delimiter">]</span><span class="delimiter">)</span> : reify.<a href="#shapeless.Zipper;ZipperOp0;Out" title="reify.Out">Out</a> = <a href="#shapeless.Zipper;ZipperOp0.apply" title="(z: Zipper.this.Self)reify.Out">reify</a><span class="delimiter">(</span><a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]" class="keyword">this</a><span class="delimiter">)</span>
<span class="delimiter">}</span>

<span class="keyword">object</span> <a title="shapeless.Zipper.type" id="shapeless.Zipper.readResolve">Zipper</a> <a href="#shapeless.Zipper.readResolve" title="shapeless.Zipper.type" class="delimiter">{</a>
  <span class="keyword">def</span> <a title="[C, CL &lt;: shapeless.HList](c: C)(implicit gen: shapeless.Generic.Aux[C,CL])shapeless.Zipper[C,shapeless.HNil,CL,None.type]" id="shapeless.Zipper.apply(22852c824b)">apply</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.apply(22852c824b);C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.apply(22852c824b);CL">CL</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><a title="C" id="shapeless.Zipper.apply(22852c824b).c">c</a> : <a href="#shapeless.Zipper.apply(22852c824b);C" title="C">C</a><span class="delimiter">)</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[C,CL]" id="shapeless.Zipper.apply(22852c824b).gen">gen</a> : Generic.<a href="generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[C,CL]">Aux</a><span class="delimiter">[</span>C, CL<span class="delimiter">]</span><span class="delimiter">)</span> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,shapeless.HNil,CL,None.type]">Zipper</a><span class="delimiter">[</span>C, HNil, CL, None.<span class="keyword">type</span><span class="delimiter">]</span> =
    <a href="#shapeless;Zipper" title="[C, L &lt;: shapeless.HList, R &lt;: shapeless.HList, P](prefix: L, suffix: R, parent: P)shapeless.Zipper[C,L,R,P]">Zipper</a><span title="(prefix: shapeless.HNil, suffix: CL, parent: None.type)shapeless.Zipper[C,shapeless.HNil,CL,None.type]" class="delimiter">[</span><a href="#shapeless.Zipper.apply(22852c824b);C" title="C">C</a>, <a href="hlists.scala.html#shapeless;HNil" title="shapeless.HNil">HNil</a>, <a href="#shapeless.Zipper.apply(22852c824b);CL" title="CL">CL</a>, None.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">(</span><a href="hlists.scala.html#shapeless.HNil" title="shapeless.HNil.type">HNil</a>, <a href="#shapeless.Zipper.apply(22852c824b).gen" title="shapeless.Generic.Aux[C,CL]">gen</a>.<a href="generic.scala.html#shapeless;Generic.to" title="(t: C)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.Zipper.apply(22852c824b).c" title="C">c</a><span class="delimiter">)</span>, <span title="None.type">None</span><span class="delimiter">)</span>

  <span class="comment">/** Enhances values of any type with a representation via `Generic` with a method supporting conversion to a `Zipper`. */</span>
  <span class="keyword">class</span> <a title="class ToZipper[C] extends AnyRef" id="shapeless.Zipper;ToZipper">ToZipper</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;ToZipper;C">C</a><span class="delimiter">]</span><a href="#shapeless.Zipper;ToZipper" title="shapeless.Zipper.ToZipper[C]" class="delimiter">(</a><a title="C" id="shapeless.Zipper;ToZipper.c">c</a> : <a href="#shapeless.Zipper;ToZipper;C" title="C">C</a><span class="delimiter">)</span> <span class="delimiter">{</span>
    <span class="keyword">def</span> <a title="[CL &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[C,CL])shapeless.Zipper[C,shapeless.HNil,CL,None.type]" id="shapeless.Zipper;ToZipper.toZipper">toZipper</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.Zipper;ToZipper.toZipper;CL">CL</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[C,CL]" id="shapeless.Zipper;ToZipper.toZipper.gen">gen</a> : Generic.<a href="generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[C,CL]">Aux</a><span class="delimiter">[</span>C, CL<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Zipper.apply(22852c824b)" title="(c: C)(implicit gen: shapeless.Generic.Aux[C,CL])shapeless.Zipper[C,shapeless.HNil,CL,None.type]">Zipper</a><a href="#shapeless.Zipper;ToZipper.toZipper.gen" title="shapeless.Generic.Aux[C,CL]" class="delimiter">(</a><a href="#shapeless.Zipper;ToZipper.c" title="C">c</a><span class="delimiter">)</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C](c: C)shapeless.Zipper.ToZipper[C]" id="shapeless.Zipper.toZipper">toZipper</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.toZipper;C">C</a><span class="delimiter">]</span><span class="delimiter">(</span><a title="C" id="shapeless.Zipper.toZipper.c">c</a> : <a href="#shapeless.Zipper.toZipper;C" title="C">C</a><span class="delimiter">)</span> = <span title="shapeless.Zipper.ToZipper[C]" class="keyword">new</span> <a href="#shapeless.Zipper;ToZipper" title="shapeless.Zipper.ToZipper[C]">ToZipper</a><span class="delimiter">(</span><a href="#shapeless.Zipper.toZipper.c" title="C">c</a><span class="delimiter">)</span>

  <span class="keyword">trait</span> <a title="trait ZipperOp0[Z] extends AnyRef" id="shapeless.Zipper;ZipperOp0">ZipperOp0</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;ZipperOp0;Z">Z</a><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="" id="shapeless.Zipper;ZipperOp0;Out">Out</a>
    <span class="keyword">def</span> <a title="(z: Z)ZipperOp0.this.Out" id="shapeless.Zipper;ZipperOp0.apply">apply</a><span class="delimiter">(</span><a title="Z" id="shapeless.Zipper;ZipperOp0.apply.z">z</a> : <a href="#shapeless.Zipper;ZipperOp0;Z" title="Z">Z</a><span class="delimiter">)</span> : <a href="#shapeless.Zipper;ZipperOp0;Out" title="ZipperOp0.this.Out">Out</a>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait ZipperOp1[Z, T] extends AnyRef" id="shapeless.Zipper;ZipperOp1">ZipperOp1</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;ZipperOp1;Z">Z</a>, <a title="" id="shapeless.Zipper;ZipperOp1;T">T</a><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="" id="shapeless.Zipper;ZipperOp1;Out">Out</a>
    <span class="keyword">def</span> <a title="(z: Z, t: T)ZipperOp1.this.Out" id="shapeless.Zipper;ZipperOp1.apply">apply</a><span class="delimiter">(</span><a title="Z" id="shapeless.Zipper;ZipperOp1.apply.z">z</a> : <a href="#shapeless.Zipper;ZipperOp1;Z" title="Z">Z</a>, <a title="T" id="shapeless.Zipper;ZipperOp1.apply.t">t</a> : <a href="#shapeless.Zipper;ZipperOp1;T" title="T">T</a><span class="delimiter">)</span> : <a href="#shapeless.Zipper;ZipperOp1;Out" title="ZipperOp1.this.Out">Out</a>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait ZipperOp0Nat[Z, N &lt;: shapeless.Nat] extends AnyRef" id="shapeless.Zipper;ZipperOp0Nat">ZipperOp0Nat</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;ZipperOp0Nat;Z">Z</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.Zipper;ZipperOp0Nat;N">N</a> &lt;: Nat<span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="" id="shapeless.Zipper;ZipperOp0Nat;Out">Out</a>
    <span class="keyword">def</span> <a title="(z: Z)ZipperOp0Nat.this.Out" id="shapeless.Zipper;ZipperOp0Nat.apply">apply</a><span class="delimiter">(</span><a title="Z" id="shapeless.Zipper;ZipperOp0Nat.apply.z">z</a> : <a href="#shapeless.Zipper;ZipperOp0Nat;Z" title="Z">Z</a><span class="delimiter">)</span> : <a href="#shapeless.Zipper;ZipperOp0Nat;Out" title="ZipperOp0Nat.this.Out">Out</a>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait ZipperOp0T[Z, T] extends AnyRef" id="shapeless.Zipper;ZipperOp0T">ZipperOp0T</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;ZipperOp0T;Z">Z</a>, <a title="" id="shapeless.Zipper;ZipperOp0T;T">T</a><span class="delimiter">]</span> <span class="delimiter">{</span>
    <span class="keyword">type</span> <a title="" id="shapeless.Zipper;ZipperOp0T;Out">Out</a>
    <span class="keyword">def</span> <a title="(z: Z)ZipperOp0T.this.Out" id="shapeless.Zipper;ZipperOp0T.apply">apply</a><span class="delimiter">(</span><a title="Z" id="shapeless.Zipper;ZipperOp0T.apply.z">z</a> : <a href="#shapeless.Zipper;ZipperOp0T;Z" title="Z">Z</a><span class="delimiter">)</span> : <a href="#shapeless.Zipper;ZipperOp0T;Out" title="ZipperOp0T.this.Out">Out</a>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait Right[Z] extends AnyRef with shapeless.Zipper.ZipperOp0[Z]" id="shapeless.Zipper;Right">Right</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;Right;Z">Z</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp0" title="shapeless.Zipper.ZipperOp0[Z]">ZipperOp0</a><span class="delimiter">[</span>Z<span class="delimiter">]</span>
  
  <span class="keyword">object</span> <a title="shapeless.Zipper.Right.type" id="shapeless.Zipper.Right">Right</a> <a href="#shapeless.Zipper.Right" title="shapeless.Zipper.Right.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, L &lt;: shapeless.HList, RH, RT &lt;: shapeless.HList, P]=&gt; shapeless.Zipper.Right[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]{type Out = shapeless.Zipper[C,shapeless.::[RH,L],RT,P]}" id="shapeless.Zipper.Right.right">right</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.Right.right;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Right.right;L">L</a> &lt;: HList, <a title="" id="shapeless.Zipper.Right.right;RH">RH</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Right.right;RT">RT</a> &lt;: HList, <a title="" id="shapeless.Zipper.Right.right;P">P</a><span class="delimiter">]</span> = <a href="#shapeless.Zipper.Right.right;$anon" title="shapeless.Zipper.Right[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.Right[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]" id="shapeless.Zipper.Right.right;$anon">Right</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, RH :: RT, P<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="shapeless.Zipper[C,shapeless.::[RH,L],RT,P]" id="shapeless.Zipper.Right.right;$anon;Out">Out</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[C,shapeless.::[RH,L],RT,P]">Zipper</a><span class="delimiter">[</span>C, RH :: L, RT, P<span class="delimiter">]</span>
      <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,shapeless.::[RH,RT],P])shapeless.Zipper[C,shapeless.::[RH,L],RT,P]" id="shapeless.Zipper.Right.right;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]" id="shapeless.Zipper.Right.right;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">Zipper</a><span class="delimiter">[</span>C, L, RH :: RT, P<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless;Zipper" title="(prefix: shapeless.::[RH,L], suffix: RT, parent: P)shapeless.Zipper[C,shapeless.::[RH,L],RT,P]">Zipper</a><span class="delimiter">(</span><a href="#shapeless.Zipper.Right.right;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="#shapeless;Zipper.suffix" title="=&gt; shapeless.::[RH,RT]">suffix</a>.<a href="hlists.scala.html#shapeless;::.head" title="=&gt; RH">head</a> <a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.::" title="(h: RH)shapeless.::[RH,L]">::</a> <a href="#shapeless.Zipper.Right.right;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: L)shapeless.syntax.HListOps[L]">prefix</a>, <a href="#shapeless.Zipper.Right.right;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="#shapeless;Zipper.suffix" title="=&gt; shapeless.::[RH,RT]">suffix</a>.<a href="hlists.scala.html#shapeless;::.tail" title="=&gt; RT">tail</a>, <a href="#shapeless.Zipper.Right.right;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="#shapeless;Zipper.parent" title="=&gt; P">parent</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait Left[Z] extends AnyRef with shapeless.Zipper.ZipperOp0[Z]" id="shapeless.Zipper;Left">Left</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;Left;Z">Z</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp0" title="shapeless.Zipper.ZipperOp0[Z]">ZipperOp0</a><span class="delimiter">[</span>Z<span class="delimiter">]</span>
  
  <span class="keyword">object</span> <a title="shapeless.Zipper.Left.type" id="shapeless.Zipper.Left">Left</a> <a href="#shapeless.Zipper.Left" title="shapeless.Zipper.Left.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, LH, LT &lt;: shapeless.HList, R &lt;: shapeless.HList, P]=&gt; shapeless.Zipper.Left[shapeless.Zipper[C,shapeless.::[LH,LT],R,P]]{type Out = shapeless.Zipper[C,LT,shapeless.::[LH,R],P]}" id="shapeless.Zipper.Left.left">left</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.Left.left;C">C</a>, <a title="" id="shapeless.Zipper.Left.left;LH">LH</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Left.left;LT">LT</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Left.left;R">R</a> &lt;: HList, <a title="" id="shapeless.Zipper.Left.left;P">P</a><span class="delimiter">]</span> = <a href="#shapeless.Zipper.Left.left;$anon" title="shapeless.Zipper.Left[shapeless.Zipper[C,shapeless.::[LH,LT],R,P]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.Left[shapeless.Zipper[C,shapeless.::[LH,LT],R,P]]" id="shapeless.Zipper.Left.left;$anon">Left</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, LH :: LT, R, P<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="shapeless.Zipper[C,LT,shapeless.::[LH,R],P]" id="shapeless.Zipper.Left.left;$anon;Out">Out</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[C,LT,shapeless.::[LH,R],P]">Zipper</a><span class="delimiter">[</span>C, LT, LH :: R, P<span class="delimiter">]</span>
      <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,shapeless.::[LH,LT],R,P])shapeless.Zipper[C,LT,shapeless.::[LH,R],P]" id="shapeless.Zipper.Left.left;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,shapeless.::[LH,LT],R,P]" id="shapeless.Zipper.Left.left;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,shapeless.::[LH,LT],R,P]">Zipper</a><span class="delimiter">[</span>C, LH :: LT, R, P<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless;Zipper" title="(prefix: LT, suffix: shapeless.::[LH,R], parent: P)shapeless.Zipper[C,LT,shapeless.::[LH,R],P]">Zipper</a><span class="delimiter">(</span><a href="#shapeless.Zipper.Left.left;$anon.apply.z" title="shapeless.Zipper[C,shapeless.::[LH,LT],R,P]">z</a>.<a href="#shapeless;Zipper.prefix" title="=&gt; shapeless.::[LH,LT]">prefix</a>.<a href="hlists.scala.html#shapeless;::.tail" title="=&gt; LT">tail</a>, <a href="#shapeless.Zipper.Left.left;$anon.apply.z" title="shapeless.Zipper[C,shapeless.::[LH,LT],R,P]">z</a>.<a href="#shapeless;Zipper.prefix" title="=&gt; shapeless.::[LH,LT]">prefix</a>.<a href="hlists.scala.html#shapeless;::.head" title="=&gt; LH">head</a> <a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.::" title="(h: LH)shapeless.::[LH,R]">::</a> <a href="#shapeless.Zipper.Left.left;$anon.apply.z" title="shapeless.Zipper[C,shapeless.::[LH,LT],R,P]">z</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: R)shapeless.syntax.HListOps[R]">suffix</a>, <a href="#shapeless.Zipper.Left.left;$anon.apply.z" title="shapeless.Zipper[C,shapeless.::[LH,LT],R,P]">z</a>.<a href="#shapeless;Zipper.parent" title="=&gt; P">parent</a><span class="delimiter">)</span>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait First[Z] extends AnyRef with shapeless.Zipper.ZipperOp0[Z]" id="shapeless.Zipper;First">First</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;First;Z">Z</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp0" title="shapeless.Zipper.ZipperOp0[Z]">ZipperOp0</a><span class="delimiter">[</span>Z<span class="delimiter">]</span>
  
  <span class="keyword">object</span> <a title="shapeless.Zipper.First.type" id="shapeless.Zipper.First">First</a> <a href="#shapeless.Zipper.First" title="shapeless.Zipper.First.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, L &lt;: shapeless.HList, R &lt;: shapeless.HList, RP &lt;: shapeless.HList, P](implicit rp: shapeless.ops.hlist.ReversePrepend.Aux[L,R,RP])shapeless.Zipper.First[shapeless.Zipper[C,L,R,P]]{type Out = shapeless.Zipper[C,shapeless.HNil,RP,P]}" id="shapeless.Zipper.First.first">first</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.First.first;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.First.first;L">L</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.First.first;R">R</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.First.first;RP">RP</a> &lt;: HList, <a title="" id="shapeless.Zipper.First.first;P">P</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ReversePrepend.Aux[L,R,RP]" id="shapeless.Zipper.First.first.rp">rp</a> : ReversePrepend.<a href="ops/hlists.scala.html#shapeless.ops.hlist;LowPriorityReversePrepend;<refinement>" title="shapeless.ops.hlist.ReversePrepend.Aux[L,R,RP]">Aux</a><span class="delimiter">[</span>L, R, RP<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#shapeless.Zipper.First.first;$anon" title="shapeless.Zipper.First[shapeless.Zipper[C,L,R,P]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.First[shapeless.Zipper[C,L,R,P]]" id="shapeless.Zipper.First.first;$anon">First</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">type</span> <a title="shapeless.Zipper[C,shapeless.HNil,RP,P]" id="shapeless.Zipper.First.first;$anon;Out">Out</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[C,shapeless.HNil,RP,P]">Zipper</a><span class="delimiter">[</span>C, HNil, RP, P<span class="delimiter">]</span>
        <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,R,P])shapeless.Zipper[C,shapeless.HNil,rp.Out,P]" id="shapeless.Zipper.First.first;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,R,P]" id="shapeless.Zipper.First.first;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]">Zipper</a><span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless;Zipper" title="(prefix: shapeless.HNil, suffix: rp.Out, parent: P)shapeless.Zipper[C,shapeless.HNil,rp.Out,P]">Zipper</a><span class="delimiter">(</span><a href="hlists.scala.html#shapeless.HNil" title="shapeless.HNil.type">HNil</a>, <a href="#shapeless.Zipper.First.first;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="#shapeless;Zipper.prefix" title="=&gt; L">prefix</a> <a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.reverse_:::" title="(prefix: L)(implicit prepend: shapeless.ops.hlist.ReversePrepend[L,R])prepend.Out">reverse_:::</a> <a href="#shapeless.Zipper.First.first;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: R)shapeless.syntax.HListOps[R]">suffix</a>, <a href="#shapeless.Zipper.First.first;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="#shapeless;Zipper.parent" title="=&gt; P">parent</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait Last[Z] extends AnyRef with shapeless.Zipper.ZipperOp0[Z]" id="shapeless.Zipper;Last">Last</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;Last;Z">Z</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp0" title="shapeless.Zipper.ZipperOp0[Z]">ZipperOp0</a><span class="delimiter">[</span>Z<span class="delimiter">]</span>
  
  <span class="keyword">object</span> <a title="shapeless.Zipper.Last.type" id="shapeless.Zipper.Last">Last</a> <a href="#shapeless.Zipper.Last" title="shapeless.Zipper.Last.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, L &lt;: shapeless.HList, R &lt;: shapeless.HList, RP &lt;: shapeless.HList, P](implicit rp: shapeless.ops.hlist.ReversePrepend.Aux[R,L,RP])shapeless.Zipper.Last[shapeless.Zipper[C,L,R,P]]{type Out = shapeless.Zipper[C,RP,shapeless.HNil,P]}" id="shapeless.Zipper.Last.last">last</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.Last.last;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Last.last;L">L</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Last.last;R">R</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Last.last;RP">RP</a> &lt;: HList, <a title="" id="shapeless.Zipper.Last.last;P">P</a><span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ReversePrepend.Aux[R,L,RP]" id="shapeless.Zipper.Last.last.rp">rp</a> : ReversePrepend.<a href="ops/hlists.scala.html#shapeless.ops.hlist;LowPriorityReversePrepend;<refinement>" title="shapeless.ops.hlist.ReversePrepend.Aux[R,L,RP]">Aux</a><span class="delimiter">[</span>R, L, RP<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#shapeless.Zipper.Last.last;$anon" title="shapeless.Zipper.Last[shapeless.Zipper[C,L,R,P]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.Last[shapeless.Zipper[C,L,R,P]]" id="shapeless.Zipper.Last.last;$anon">Last</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">type</span> <a title="shapeless.Zipper[C,RP,shapeless.HNil,P]" id="shapeless.Zipper.Last.last;$anon;Out">Out</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[C,RP,shapeless.HNil,P]">Zipper</a><span class="delimiter">[</span>C, RP, HNil, P<span class="delimiter">]</span>
        <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,R,P])shapeless.Zipper[C,rp.Out,shapeless.HNil,P]" id="shapeless.Zipper.Last.last;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,R,P]" id="shapeless.Zipper.Last.last;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]">Zipper</a><span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless;Zipper" title="(prefix: rp.Out, suffix: shapeless.HNil, parent: P)shapeless.Zipper[C,rp.Out,shapeless.HNil,P]">Zipper</a><span class="delimiter">(</span><a href="#shapeless.Zipper.Last.last;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="#shapeless;Zipper.suffix" title="=&gt; R">suffix</a> <a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.reverse_:::" title="(prefix: R)(implicit prepend: shapeless.ops.hlist.ReversePrepend[R,L])prepend.Out">reverse_:::</a> <a href="#shapeless.Zipper.Last.last;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: L)shapeless.syntax.HListOps[L]">prefix</a>, <a href="hlists.scala.html#shapeless.HNil" title="shapeless.HNil.type">HNil</a>, <a href="#shapeless.Zipper.Last.last;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="#shapeless;Zipper.parent" title="=&gt; P">parent</a><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait RightBy[Z, N &lt;: shapeless.Nat] extends AnyRef with shapeless.Zipper.ZipperOp0Nat[Z,N]" id="shapeless.Zipper;RightBy">RightBy</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;RightBy;Z">Z</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.Zipper;RightBy;N">N</a> &lt;: Nat<span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp0Nat" title="shapeless.Zipper.ZipperOp0Nat[Z,N]">ZipperOp0Nat</a><span class="delimiter">[</span>Z, N<span class="delimiter">]</span>
  
  <span class="keyword">object</span> <a title="shapeless.Zipper.RightBy.type" id="shapeless.Zipper.RightBy">RightBy</a> <a href="#shapeless.Zipper.RightBy" title="shapeless.Zipper.RightBy.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, L &lt;: shapeless.HList, R &lt;: shapeless.HList, P, N &lt;: shapeless.Nat, LP &lt;: shapeless.HList, RS &lt;: shapeless.HList](implicit split: shapeless.ops.hlist.Split.Aux[R,N,(LP, RS)], implicit reverse: shapeless.ops.hlist.ReversePrepend[LP,L])shapeless.Zipper.RightBy[shapeless.Zipper[C,L,R,P],N]{type Out = shapeless.Zipper[C,reverse.Out,RS,P]}" id="shapeless.Zipper.RightBy.rightBy">rightBy</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.RightBy.rightBy;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.RightBy.rightBy;L">L</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.RightBy.rightBy;R">R</a> &lt;: HList, <a title="" id="shapeless.Zipper.RightBy.rightBy;P">P</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.Zipper.RightBy.rightBy;N">N</a> &lt;: Nat, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.RightBy.rightBy;LP">LP</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.RightBy.rightBy;RS">RS</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Split.Aux[R,N,(LP, RS)]" id="shapeless.Zipper.RightBy.rightBy.split">split</a> : Split.<a href="ops/hlists.scala.html#shapeless.ops.hlist.Split;<refinement>" title="shapeless.ops.hlist.Split.Aux[R,N,(LP, RS)]">Aux</a><span class="delimiter">[</span>R, N, <span class="delimiter">(</span>LP, RS<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ReversePrepend[LP,L]" id="shapeless.Zipper.RightBy.rightBy.reverse">reverse</a> : <a href="ops/hlists.scala.html#shapeless.ops.hlist;ReversePrepend" title="shapeless.ops.hlist.ReversePrepend[LP,L]">ReversePrepend</a><span class="delimiter">[</span>LP, L<span class="delimiter">]</span><span class="delimiter">)</span> =
        <a href="#shapeless.Zipper.RightBy.rightBy;$anon" title="shapeless.Zipper.RightBy[shapeless.Zipper[C,L,R,P],N]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.RightBy[shapeless.Zipper[C,L,R,P],N]" id="shapeless.Zipper.RightBy.rightBy;$anon">RightBy</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span>, N<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="shapeless.Zipper[C,reverse.Out,RS,P]" id="shapeless.Zipper.RightBy.rightBy;$anon;Out">Out</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[C,reverse.Out,RS,P]">Zipper</a><span class="delimiter">[</span>C, reverse.Out, RS, P<span class="delimiter">]</span> 
          <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,R,P])shapeless.Zipper[C,reverse.Out,RS,P]" id="shapeless.Zipper.RightBy.rightBy;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,R,P]" id="shapeless.Zipper.RightBy.rightBy;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]">Zipper</a><span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
            <span class="keyword">val</span> <a href="#shapeless.Zipper.RightBy.rightBy;$anon.apply.p" title="(LP, RS)" class="delimiter">(</a><a href="#shapeless.Zipper.RightBy.rightBy;$anon.apply.x$5" title="LP" id="shapeless.Zipper.RightBy.rightBy;$anon.apply.p">p</a>, <a href="#shapeless.Zipper.RightBy.rightBy;$anon.apply.x$5" title="RS" id="shapeless.Zipper.RightBy.rightBy;$anon.apply.s">s</a><span class="delimiter">)</span> = <a href="#shapeless.Zipper.RightBy.rightBy;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: R)shapeless.syntax.HListOps[R]">suffix</a>.<a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.split(eaf573334c)" title="[N &lt;: shapeless.Nat](implicit split: shapeless.ops.hlist.Split[R,N])split.Out">split</a><a href="#shapeless.Zipper.RightBy.rightBy.split" title="(implicit split: shapeless.ops.hlist.Split[R,N])split.Out" class="delimiter">[</a><a href="#shapeless.Zipper.RightBy.rightBy;N" title="N">N</a><span class="delimiter">]</span>
            <a href="#shapeless;Zipper" title="(prefix: reverse.Out, suffix: RS, parent: P)shapeless.Zipper[C,reverse.Out,RS,P]">Zipper</a><span class="delimiter">(</span><a href="#shapeless.Zipper.RightBy.rightBy;$anon.apply.p" title="LP">p</a> <a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.reverse_:::" title="(prefix: LP)(implicit prepend: shapeless.ops.hlist.ReversePrepend[LP,L])prepend.Out">reverse_:::</a> <a href="#shapeless.Zipper.RightBy.rightBy;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: L)shapeless.syntax.HListOps[L]">prefix</a>, <a href="#shapeless.Zipper.RightBy.rightBy;$anon.apply.s" title="RS">s</a>, <a href="#shapeless.Zipper.RightBy.rightBy;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="#shapeless;Zipper.parent" title="=&gt; P">parent</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait LeftBy[Z, N &lt;: shapeless.Nat] extends AnyRef with shapeless.Zipper.ZipperOp0Nat[Z,N]" id="shapeless.Zipper;LeftBy">LeftBy</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;LeftBy;Z">Z</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.Zipper;LeftBy;N">N</a> &lt;: Nat<span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp0Nat" title="shapeless.Zipper.ZipperOp0Nat[Z,N]">ZipperOp0Nat</a><span class="delimiter">[</span>Z, N<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.Zipper.LeftBy.type" id="shapeless.Zipper.LeftBy">LeftBy</a> <a href="#shapeless.Zipper.LeftBy" title="shapeless.Zipper.LeftBy.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, L &lt;: shapeless.HList, R &lt;: shapeless.HList, P, N &lt;: shapeless.Nat, RP &lt;: shapeless.HList, LS &lt;: shapeless.HList](implicit split: shapeless.ops.hlist.Split.Aux[L,N,(RP, LS)], implicit reverse: shapeless.ops.hlist.ReversePrepend[RP,R])shapeless.Zipper.LeftBy[shapeless.Zipper[C,L,R,P],N]{type Out = shapeless.Zipper[C,LS,reverse.Out,P]}" id="shapeless.Zipper.LeftBy.leftBy">leftBy</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.LeftBy.leftBy;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.LeftBy.leftBy;L">L</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.LeftBy.leftBy;R">R</a> &lt;: HList, <a title="" id="shapeless.Zipper.LeftBy.leftBy;P">P</a>, <a title=" &lt;: shapeless.Nat" id="shapeless.Zipper.LeftBy.leftBy;N">N</a> &lt;: Nat, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.LeftBy.leftBy;RP">RP</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.LeftBy.leftBy;LS">LS</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.Split.Aux[L,N,(RP, LS)]" id="shapeless.Zipper.LeftBy.leftBy.split">split</a> : Split.<a href="ops/hlists.scala.html#shapeless.ops.hlist.Split;<refinement>" title="shapeless.ops.hlist.Split.Aux[L,N,(RP, LS)]">Aux</a><span class="delimiter">[</span>L, N, <span class="delimiter">(</span>RP, LS<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ReversePrepend[RP,R]" id="shapeless.Zipper.LeftBy.leftBy.reverse">reverse</a> : <a href="ops/hlists.scala.html#shapeless.ops.hlist;ReversePrepend" title="shapeless.ops.hlist.ReversePrepend[RP,R]">ReversePrepend</a><span class="delimiter">[</span>RP, R<span class="delimiter">]</span><span class="delimiter">)</span> =
        <a href="#shapeless.Zipper.LeftBy.leftBy;$anon" title="shapeless.Zipper.LeftBy[shapeless.Zipper[C,L,R,P],N]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.LeftBy[shapeless.Zipper[C,L,R,P],N]" id="shapeless.Zipper.LeftBy.leftBy;$anon">LeftBy</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span>, N<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="shapeless.Zipper[C,LS,reverse.Out,P]" id="shapeless.Zipper.LeftBy.leftBy;$anon;Out">Out</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[C,LS,reverse.Out,P]">Zipper</a><span class="delimiter">[</span>C, LS, reverse.Out, P<span class="delimiter">]</span>
          <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,R,P])shapeless.Zipper[C,LS,reverse.Out,P]" id="shapeless.Zipper.LeftBy.leftBy;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,R,P]" id="shapeless.Zipper.LeftBy.leftBy;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]">Zipper</a><span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
            <span class="keyword">val</span> <a href="#shapeless.Zipper.LeftBy.leftBy;$anon.apply.p" title="(RP, LS)" class="delimiter">(</a><a href="#shapeless.Zipper.LeftBy.leftBy;$anon.apply.x$7" title="RP" id="shapeless.Zipper.LeftBy.leftBy;$anon.apply.p">p</a>, <a href="#shapeless.Zipper.LeftBy.leftBy;$anon.apply.x$7" title="LS" id="shapeless.Zipper.LeftBy.leftBy;$anon.apply.s">s</a><span class="delimiter">)</span> = <a href="#shapeless.Zipper.LeftBy.leftBy;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: L)shapeless.syntax.HListOps[L]">prefix</a>.<a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.split(eaf573334c)" title="[N &lt;: shapeless.Nat](implicit split: shapeless.ops.hlist.Split[L,N])split.Out">split</a><a href="#shapeless.Zipper.LeftBy.leftBy.split" title="(implicit split: shapeless.ops.hlist.Split[L,N])split.Out" class="delimiter">[</a><a href="#shapeless.Zipper.LeftBy.leftBy;N" title="N">N</a><span class="delimiter">]</span>
            <a href="#shapeless;Zipper" title="(prefix: LS, suffix: reverse.Out, parent: P)shapeless.Zipper[C,LS,reverse.Out,P]">Zipper</a><span class="delimiter">(</span><a href="#shapeless.Zipper.LeftBy.leftBy;$anon.apply.s" title="LS">s</a>, <a href="#shapeless.Zipper.LeftBy.leftBy;$anon.apply.p" title="RP">p</a> <a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.reverse_:::" title="(prefix: RP)(implicit prepend: shapeless.ops.hlist.ReversePrepend[RP,R])prepend.Out">reverse_:::</a> <a href="#shapeless.Zipper.LeftBy.leftBy;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: R)shapeless.syntax.HListOps[R]">suffix</a>, <a href="#shapeless.Zipper.LeftBy.leftBy;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="#shapeless;Zipper.parent" title="=&gt; P">parent</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait RightTo[Z, T] extends AnyRef with shapeless.Zipper.ZipperOp0T[Z,T]" id="shapeless.Zipper;RightTo">RightTo</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;RightTo;Z">Z</a>, <a title="" id="shapeless.Zipper;RightTo;T">T</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp0T" title="shapeless.Zipper.ZipperOp0T[Z,T]">ZipperOp0T</a><span class="delimiter">[</span>Z, T<span class="delimiter">]</span>
  
  <span class="keyword">object</span> <a title="shapeless.Zipper.RightTo.type" id="shapeless.Zipper.RightTo">RightTo</a> <a href="#shapeless.Zipper.RightTo" title="shapeless.Zipper.RightTo.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, L &lt;: shapeless.HList, R &lt;: shapeless.HList, P, T, LP &lt;: shapeless.HList, RS &lt;: shapeless.HList](implicit split: shapeless.ops.hlist.SplitLeft.Aux[R,T,(LP, RS)], implicit reverse: shapeless.ops.hlist.ReversePrepend[LP,L])shapeless.Zipper.RightTo[shapeless.Zipper[C,L,R,P],T]{type Out = shapeless.Zipper[C,reverse.Out,RS,P]}" id="shapeless.Zipper.RightTo.rightTo">rightTo</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.RightTo.rightTo;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.RightTo.rightTo;L">L</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.RightTo.rightTo;R">R</a> &lt;: HList, <a title="" id="shapeless.Zipper.RightTo.rightTo;P">P</a>, <a title="" id="shapeless.Zipper.RightTo.rightTo;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.RightTo.rightTo;LP">LP</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.RightTo.rightTo;RS">RS</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.SplitLeft.Aux[R,T,(LP, RS)]" id="shapeless.Zipper.RightTo.rightTo.split">split</a> : SplitLeft.<a href="ops/hlists.scala.html#shapeless.ops.hlist.SplitLeft;<refinement>" title="shapeless.ops.hlist.SplitLeft.Aux[R,T,(LP, RS)]">Aux</a><span class="delimiter">[</span>R, T, <span class="delimiter">(</span>LP, RS<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ReversePrepend[LP,L]" id="shapeless.Zipper.RightTo.rightTo.reverse">reverse</a> : <a href="ops/hlists.scala.html#shapeless.ops.hlist;ReversePrepend" title="shapeless.ops.hlist.ReversePrepend[LP,L]">ReversePrepend</a><span class="delimiter">[</span>LP, L<span class="delimiter">]</span><span class="delimiter">)</span> =
        <a href="#shapeless.Zipper.RightTo.rightTo;$anon" title="shapeless.Zipper.RightTo[shapeless.Zipper[C,L,R,P],T]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.RightTo[shapeless.Zipper[C,L,R,P],T]" id="shapeless.Zipper.RightTo.rightTo;$anon">RightTo</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span>, T<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="shapeless.Zipper[C,reverse.Out,RS,P]" id="shapeless.Zipper.RightTo.rightTo;$anon;Out">Out</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[C,reverse.Out,RS,P]">Zipper</a><span class="delimiter">[</span>C, reverse.Out, RS, P<span class="delimiter">]</span>
          <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,R,P])shapeless.Zipper[C,reverse.Out,RS,P]" id="shapeless.Zipper.RightTo.rightTo;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,R,P]" id="shapeless.Zipper.RightTo.rightTo;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]">Zipper</a><span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
            <span class="keyword">val</span> <a href="#shapeless.Zipper.RightTo.rightTo;$anon.apply.p" title="(LP, RS)" class="delimiter">(</a><a href="#shapeless.Zipper.RightTo.rightTo;$anon.apply.x$9" title="LP" id="shapeless.Zipper.RightTo.rightTo;$anon.apply.p">p</a>, <a href="#shapeless.Zipper.RightTo.rightTo;$anon.apply.x$9" title="RS" id="shapeless.Zipper.RightTo.rightTo;$anon.apply.s">s</a><span class="delimiter">)</span> = <a href="#shapeless.Zipper.RightTo.rightTo;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: R)shapeless.syntax.HListOps[R]">suffix</a>.<a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.splitLeft" title="[U](implicit splitLeft: shapeless.ops.hlist.SplitLeft[R,U])splitLeft.Out">splitLeft</a><a href="#shapeless.Zipper.RightTo.rightTo.split" title="(implicit splitLeft: shapeless.ops.hlist.SplitLeft[R,T])splitLeft.Out" class="delimiter">[</a><a href="#shapeless.Zipper.RightTo.rightTo;T" title="T">T</a><span class="delimiter">]</span>
            <a href="#shapeless;Zipper" title="(prefix: reverse.Out, suffix: RS, parent: P)shapeless.Zipper[C,reverse.Out,RS,P]">Zipper</a><span class="delimiter">(</span><a href="#shapeless.Zipper.RightTo.rightTo;$anon.apply.p" title="LP">p</a> <a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.reverse_:::" title="(prefix: LP)(implicit prepend: shapeless.ops.hlist.ReversePrepend[LP,L])prepend.Out">reverse_:::</a> <a href="#shapeless.Zipper.RightTo.rightTo;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: L)shapeless.syntax.HListOps[L]">prefix</a>, <a href="#shapeless.Zipper.RightTo.rightTo;$anon.apply.s" title="RS">s</a>, <a href="#shapeless.Zipper.RightTo.rightTo;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="#shapeless;Zipper.parent" title="=&gt; P">parent</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait LeftTo[Z, T] extends AnyRef with shapeless.Zipper.ZipperOp0T[Z,T]" id="shapeless.Zipper;LeftTo">LeftTo</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;LeftTo;Z">Z</a>, <a title="" id="shapeless.Zipper;LeftTo;T">T</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp0T" title="shapeless.Zipper.ZipperOp0T[Z,T]">ZipperOp0T</a><span class="delimiter">[</span>Z, T<span class="delimiter">]</span>

  <span class="keyword">object</span> <a title="shapeless.Zipper.LeftTo.type" id="shapeless.Zipper.LeftTo">LeftTo</a> <a href="#shapeless.Zipper.LeftTo" title="shapeless.Zipper.LeftTo.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, L &lt;: shapeless.HList, R &lt;: shapeless.HList, P, T, RP &lt;: shapeless.HList, R0 &lt;: shapeless.HList](implicit split: shapeless.ops.hlist.SplitLeft.Aux[L,T,(RP, R0)], implicit reverse: shapeless.ops.hlist.ReversePrepend[RP,R], implicit cons: shapeless.ops.hlist.IsHCons[R0])shapeless.Zipper.LeftTo[shapeless.Zipper[C,L,R,P],T]{type Out = shapeless.Zipper[C,cons.T,shapeless.::[cons.H,reverse.Out],P]}" id="shapeless.Zipper.LeftTo.leftTo">leftTo</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.LeftTo.leftTo;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.LeftTo.leftTo;L">L</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.LeftTo.leftTo;R">R</a> &lt;: HList, <a title="" id="shapeless.Zipper.LeftTo.leftTo;P">P</a>, <a title="" id="shapeless.Zipper.LeftTo.leftTo;T">T</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.LeftTo.leftTo;RP">RP</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.LeftTo.leftTo;R0">R0</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.SplitLeft.Aux[L,T,(RP, R0)]" id="shapeless.Zipper.LeftTo.leftTo.split">split</a> : SplitLeft.<a href="ops/hlists.scala.html#shapeless.ops.hlist.SplitLeft;<refinement>" title="shapeless.ops.hlist.SplitLeft.Aux[L,T,(RP, R0)]">Aux</a><span class="delimiter">[</span>L, T, <span class="delimiter">(</span>RP, R0<span class="delimiter">)</span><span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ReversePrepend[RP,R]" id="shapeless.Zipper.LeftTo.leftTo.reverse">reverse</a> : <a href="ops/hlists.scala.html#shapeless.ops.hlist;ReversePrepend" title="shapeless.ops.hlist.ReversePrepend[RP,R]">ReversePrepend</a><span class="delimiter">[</span>RP, R<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.IsHCons[R0]" id="shapeless.Zipper.LeftTo.leftTo.cons">cons</a> : <a href="ops/hlists.scala.html#shapeless.ops.hlist;IsHCons" title="shapeless.ops.hlist.IsHCons[R0]">IsHCons</a><span class="delimiter">[</span>R0<span class="delimiter">]</span><span class="delimiter">)</span> =
        <a href="#shapeless.Zipper.LeftTo.leftTo;$anon" title="shapeless.Zipper.LeftTo[shapeless.Zipper[C,L,R,P],T]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.LeftTo[shapeless.Zipper[C,L,R,P],T]" id="shapeless.Zipper.LeftTo.leftTo;$anon">LeftTo</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span>, T<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="shapeless.Zipper[C,cons.T,shapeless.::[cons.H,reverse.Out],P]" id="shapeless.Zipper.LeftTo.leftTo;$anon;Out">Out</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[C,cons.T,shapeless.::[cons.H,reverse.Out],P]">Zipper</a><span class="delimiter">[</span>C, cons.T, cons.H :: reverse.Out, P<span class="delimiter">]</span>
          <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,R,P])shapeless.Zipper[C,cons.T,shapeless.::[cons.H,reverse.Out],P]" id="shapeless.Zipper.LeftTo.leftTo;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,R,P]" id="shapeless.Zipper.LeftTo.leftTo;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]">Zipper</a><span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span><span class="delimiter">)</span> = <span class="delimiter">{</span>
            <span class="keyword">val</span> <a href="#shapeless.Zipper.LeftTo.leftTo;$anon.apply.p" title="(RP, R0)" class="delimiter">(</a><a href="#shapeless.Zipper.LeftTo.leftTo;$anon.apply.x$11" title="RP" id="shapeless.Zipper.LeftTo.leftTo;$anon.apply.p">p</a>, <a href="#shapeless.Zipper.LeftTo.leftTo;$anon.apply.x$11" title="R0" id="shapeless.Zipper.LeftTo.leftTo;$anon.apply.s">s</a><span class="delimiter">)</span> = <a href="#shapeless.Zipper.LeftTo.leftTo;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: L)shapeless.syntax.HListOps[L]">prefix</a>.<a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.splitLeft" title="[U](implicit splitLeft: shapeless.ops.hlist.SplitLeft[L,U])splitLeft.Out">splitLeft</a><a href="#shapeless.Zipper.LeftTo.leftTo.split" title="(implicit splitLeft: shapeless.ops.hlist.SplitLeft[L,T])splitLeft.Out" class="delimiter">[</a><a href="#shapeless.Zipper.LeftTo.leftTo;T" title="T">T</a><span class="delimiter">]</span>
            <a href="#shapeless;Zipper" title="(prefix: cons.T, suffix: shapeless.::[cons.H,reverse.Out], parent: P)shapeless.Zipper[C,cons.T,shapeless.::[cons.H,reverse.Out],P]">Zipper</a><span class="delimiter">(</span><a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: R0)shapeless.syntax.HListOps[R0]">s</a>.<a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.tail" title="(implicit c: shapeless.ops.hlist.IsHCons[R0])c.T">tail</a>, <a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: R0)shapeless.syntax.HListOps[R0]">s</a>.<a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.head" title="(implicit c: shapeless.ops.hlist.IsHCons[R0])c.H">head</a> <a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.::" title="(h: cons.H)shapeless.::[cons.H,reverse.Out]">::</a> <span class="delimiter">(</span><a href="#shapeless.Zipper.LeftTo.leftTo;$anon.apply.p" title="RP">p</a> <a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: reverse.Out)shapeless.syntax.HListOps[reverse.Out]">reverse_:::</a> <a href="#shapeless.Zipper.LeftTo.leftTo;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: R)shapeless.syntax.HListOps[R]">suffix</a><span class="delimiter">)</span>, <a href="#shapeless.Zipper.LeftTo.leftTo;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="#shapeless;Zipper.parent" title="=&gt; P">parent</a><span class="delimiter">)</span>
          <span class="delimiter">}</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait Up[Z] extends AnyRef with shapeless.Zipper.ZipperOp0[Z]" id="shapeless.Zipper;Up">Up</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;Up;Z">Z</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp0" title="shapeless.Zipper.ZipperOp0[Z]">ZipperOp0</a><span class="delimiter">[</span>Z<span class="delimiter">]</span>
  
  <span class="keyword">object</span> <a title="shapeless.Zipper.Up.type" id="shapeless.Zipper.Up">Up</a> <a href="#shapeless.Zipper.Up" title="shapeless.Zipper.Up.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, L &lt;: shapeless.HList, R &lt;: shapeless.HList, P](implicit rz: shapeless.Zipper.Reify[shapeless.Zipper[C,L,R,Some[P]]]{type Out = C}, implicit pp: shapeless.Zipper.Put[P,C])shapeless.Zipper.Up[shapeless.Zipper[C,L,R,Some[P]]]{type Out = pp.Out}" id="shapeless.Zipper.Up.up">up</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.Up.up;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Up.up;L">L</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Up.up;R">R</a> &lt;: HList, <a title="" id="shapeless.Zipper.Up.up;P">P</a><span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Up extends shapeless.Zipper.Reify[shapeless.Zipper[C,L,R,Some[P]]]" id="shapeless.Zipper.Up.up.rz">rz</a> : <a href="#shapeless.Zipper.Up;<refinement>" title="Up extends shapeless.Zipper.Reify[shapeless.Zipper[C,L,R,Some[P]]]">Reify</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, R, Some<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = C <span class="delimiter">}</span>, <a title="shapeless.Zipper.Put[P,C]" id="shapeless.Zipper.Up.up.pp">pp</a> : <a href="#shapeless.Zipper;Put" title="shapeless.Zipper.Put[P,C]">Put</a><span class="delimiter">[</span>P, C<span class="delimiter">]</span><span class="delimiter">)</span> =
        <a href="#shapeless.Zipper.Up.up;$anon" title="shapeless.Zipper.Up[shapeless.Zipper[C,L,R,Some[P]]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.Up[shapeless.Zipper[C,L,R,Some[P]]]" id="shapeless.Zipper.Up.up;$anon">Up</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, R, Some<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="pp.Out" id="shapeless.Zipper.Up.up;$anon;Out">Out</a> = pp.<a href="#shapeless.Zipper;ZipperOp1;Out" title="pp.Out">Out</a>
          <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,R,Some[P]])pp.Out" id="shapeless.Zipper.Up.up;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,R,Some[P]]" id="shapeless.Zipper.Up.up;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,Some[P]]">Zipper</a><span class="delimiter">[</span>C, L, R, Some<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Zipper;ZipperOp1.apply" title="(z: P, t: C)pp.Out">pp</a><span class="delimiter">(</span><a href="#shapeless.Zipper.Up.up;$anon.apply.z" title="shapeless.Zipper[C,L,R,Some[P]]">z</a>.<a href="#shapeless;Zipper.parent" title="=&gt; Some[P]">parent</a>.<span title="=&gt; P">get</span>, <a href="#shapeless.Zipper.Up.up;$anon.apply.z" title="shapeless.Zipper[C,L,R,Some[P]]">z</a>.<a href="#shapeless;Zipper.reify" title="(implicit reify: shapeless.Zipper.Reify[z.Self])reify.Out">reify</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait Down[Z] extends AnyRef with shapeless.Zipper.ZipperOp0[Z]" id="shapeless.Zipper;Down">Down</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;Down;Z">Z</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp0" title="shapeless.Zipper.ZipperOp0[Z]">ZipperOp0</a><span class="delimiter">[</span>Z<span class="delimiter">]</span>
  
  <span class="keyword">object</span> <a title="shapeless.Zipper.Down.type" id="shapeless.Zipper.Down">Down</a> <a href="#shapeless.Zipper.Down" title="shapeless.Zipper.Down.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, L &lt;: shapeless.HList, RH, RT &lt;: shapeless.HList, P, RHL &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[RH,RHL])shapeless.Zipper.Down[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]{type Out = shapeless.Zipper[RH,shapeless.HNil,RHL,Some[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]]}" id="shapeless.Zipper.Down.down">down</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.Down.down;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Down.down;L">L</a> &lt;: HList, <a title="" id="shapeless.Zipper.Down.down;RH">RH</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Down.down;RT">RT</a> &lt;: HList, <a title="" id="shapeless.Zipper.Down.down;P">P</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Down.down;RHL">RHL</a> &lt;: HList<span class="delimiter">]</span><span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[RH,RHL]" id="shapeless.Zipper.Down.down.gen">gen</a> : Generic.<a href="generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[RH,RHL]">Aux</a><span class="delimiter">[</span>RH, RHL<span class="delimiter">]</span><span class="delimiter">)</span> =
      <a href="#shapeless.Zipper.Down.down;$anon" title="shapeless.Zipper.Down[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.Down[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]" id="shapeless.Zipper.Down.down;$anon">Down</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, RH :: RT, P<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
        <span class="keyword">type</span> <a title="shapeless.Zipper[RH,shapeless.HNil,RHL,Some[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]]" id="shapeless.Zipper.Down.down;$anon;Out">Out</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[RH,shapeless.HNil,RHL,Some[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]]">Zipper</a><span class="delimiter">[</span>RH, HNil, RHL, Some<span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, RH :: RT, P<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span>
        <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,shapeless.::[RH,RT],P])shapeless.Zipper[RH,shapeless.HNil,gen.Repr,Some[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]]" id="shapeless.Zipper.Down.down;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]" id="shapeless.Zipper.Down.down;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">Zipper</a><span class="delimiter">[</span>C, L, RH :: RT, P<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless;Zipper" title="(prefix: shapeless.HNil, suffix: gen.Repr, parent: Some[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]])shapeless.Zipper[RH,shapeless.HNil,gen.Repr,Some[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]]">Zipper</a><span class="delimiter">(</span><a href="hlists.scala.html#shapeless.HNil" title="shapeless.HNil.type">HNil</a>, <a href="#shapeless.Zipper.Down.down.gen" title="shapeless.Generic.Aux[RH,RHL]">gen</a>.<a href="generic.scala.html#shapeless;Generic.to" title="(t: RH)gen.Repr">to</a><span class="delimiter">(</span><a href="#shapeless.Zipper.Down.down;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="#shapeless;Zipper.suffix" title="=&gt; shapeless.::[RH,RT]">suffix</a>.<a href="hlists.scala.html#shapeless;::.head" title="=&gt; RH">head</a><span class="delimiter">)</span>, <span title="(x: shapeless.Zipper[C,L,shapeless.::[RH,RT],P])Some[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]">Some</span><span class="delimiter">(</span><a href="#shapeless.Zipper.Down.down;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a><span class="delimiter">)</span><span class="delimiter">)</span>
      <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait Root[Z] extends AnyRef with shapeless.Zipper.ZipperOp0[Z]" id="shapeless.Zipper;Root">Root</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;Root;Z">Z</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp0" title="shapeless.Zipper.ZipperOp0[Z]">ZipperOp0</a><span class="delimiter">[</span>Z<span class="delimiter">]</span>
  
  <span class="keyword">object</span> <a title="shapeless.Zipper.Root.type" id="shapeless.Zipper.Root">Root</a> <a href="#shapeless.Zipper.Root" title="shapeless.Zipper.Root.type" class="keyword">extends</a> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, L &lt;: shapeless.HList, R &lt;: shapeless.HList]=&gt; shapeless.Zipper.Root[shapeless.Zipper[C,L,R,None.type]]{type Out = shapeless.Zipper[C,L,R,None.type]}" id="shapeless.Zipper.Root.rootRoot">rootRoot</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.Root.rootRoot;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Root.rootRoot;L">L</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Root.rootRoot;R">R</a> &lt;: HList<span class="delimiter">]</span> = <a href="#shapeless.Zipper.Root.rootRoot;$anon" title="shapeless.Zipper.Root[shapeless.Zipper[C,L,R,None.type]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.Root[shapeless.Zipper[C,L,R,None.type]]" id="shapeless.Zipper.Root.rootRoot;$anon">Root</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, R, None.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="shapeless.Zipper[C,L,R,None.type]" id="shapeless.Zipper.Root.rootRoot;$anon;Out">Out</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,None.type]">Zipper</a><span class="delimiter">[</span>C, L, R, None.<span class="keyword">type</span><span class="delimiter">]</span>
      <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,R,None.type])shapeless.Zipper[C,L,R,None.type]" id="shapeless.Zipper.Root.rootRoot;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,R,None.type]" id="shapeless.Zipper.Root.rootRoot;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,None.type]">Zipper</a><span class="delimiter">[</span>C, L, R, None.<span class="keyword">type</span><span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Zipper.Root.rootRoot;$anon.apply.z" title="shapeless.Zipper[C,L,R,None.type]">z</a>
    <span class="delimiter">}</span>
    
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, L &lt;: shapeless.HList, R &lt;: shapeless.HList, P, U](implicit up: shapeless.Zipper.Up[shapeless.Zipper[C,L,R,Some[P]]]{type Out = U}, implicit pr: shapeless.Zipper.Root[U])shapeless.Zipper.Root[shapeless.Zipper[C,L,R,Some[P]]]{type Out = pr.Out}" id="shapeless.Zipper.Root.nonRootRoot">nonRootRoot</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.Root.nonRootRoot;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Root.nonRootRoot;L">L</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Root.nonRootRoot;R">R</a> &lt;: HList, <a title="" id="shapeless.Zipper.Root.nonRootRoot;P">P</a>, <a title="" id="shapeless.Zipper.Root.nonRootRoot;U">U</a><span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="Root extends shapeless.Zipper.Up[shapeless.Zipper[C,L,R,Some[P]]]" id="shapeless.Zipper.Root.nonRootRoot.up">up</a> : <a href="#shapeless.Zipper.Root;<refinement>" title="Root extends shapeless.Zipper.Up[shapeless.Zipper[C,L,R,Some[P]]]">Up</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, R, Some<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span> <span class="keyword">type</span> Out = U <span class="delimiter">}</span>, <a title="shapeless.Zipper.Root[U]" id="shapeless.Zipper.Root.nonRootRoot.pr">pr</a> : <a href="#shapeless.Zipper;Root" title="shapeless.Zipper.Root[U]">Root</a><span class="delimiter">[</span>U<span class="delimiter">]</span><span class="delimiter">)</span> =
        <a href="#shapeless.Zipper.Root.nonRootRoot;$anon" title="shapeless.Zipper.Root[shapeless.Zipper[C,L,R,Some[P]]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.Root[shapeless.Zipper[C,L,R,Some[P]]]" id="shapeless.Zipper.Root.nonRootRoot;$anon">Root</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, R, Some<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="pr.Out" id="shapeless.Zipper.Root.nonRootRoot;$anon;Out">Out</a> = pr.<a href="#shapeless.Zipper;ZipperOp0;Out" title="pr.Out">Out</a>
          <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,R,Some[P]])pr.Out" id="shapeless.Zipper.Root.nonRootRoot;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,R,Some[P]]" id="shapeless.Zipper.Root.nonRootRoot;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,Some[P]]">Zipper</a><span class="delimiter">[</span>C, L, R, Some<span class="delimiter">[</span>P<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Zipper;ZipperOp0.apply" title="(z: U)pr.Out">pr</a><span class="delimiter">(</span><a href="#shapeless.Zipper.Root.nonRootRoot;$anon.apply.z" title="shapeless.Zipper[C,L,R,Some[P]]">z</a>.<a href="#shapeless;Zipper.up" title="(implicit up: shapeless.Zipper.Up[z.Self])up.Out">up</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait Get[Z] extends AnyRef with shapeless.Zipper.ZipperOp0[Z]" id="shapeless.Zipper;Get">Get</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;Get;Z">Z</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp0" title="shapeless.Zipper.ZipperOp0[Z]">ZipperOp0</a><span class="delimiter">[</span>Z<span class="delimiter">]</span>
  
  <span class="keyword">object</span> <a title="shapeless.Zipper.Get.type" id="shapeless.Zipper.Get">Get</a> <a href="#shapeless.Zipper.Get" title="shapeless.Zipper.Get.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, L &lt;: shapeless.HList, RH, RT &lt;: shapeless.HList, P]=&gt; shapeless.Zipper.Get[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]{type Out = RH}" id="shapeless.Zipper.Get.get">get</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.Get.get;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Get.get;L">L</a> &lt;: HList, <a title="" id="shapeless.Zipper.Get.get;RH">RH</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Get.get;RT">RT</a> &lt;: HList, <a title="" id="shapeless.Zipper.Get.get;P">P</a><span class="delimiter">]</span> = <a href="#shapeless.Zipper.Get.get;$anon" title="shapeless.Zipper.Get[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.Get[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]" id="shapeless.Zipper.Get.get;$anon">Get</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, RH :: RT, P<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
      <span class="keyword">type</span> <a title="RH" id="shapeless.Zipper.Get.get;$anon;Out">Out</a> = <a href="#shapeless.Zipper.Get.get;RH" title="RH">RH</a>
      <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,shapeless.::[RH,RT],P])RH" id="shapeless.Zipper.Get.get;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]" id="shapeless.Zipper.Get.get;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">Zipper</a><span class="delimiter">[</span>C, L, RH :: RT, P<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Zipper.Get.get;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="#shapeless;Zipper.suffix" title="=&gt; shapeless.::[RH,RT]">suffix</a>.<a href="hlists.scala.html#shapeless;::.head" title="=&gt; RH">head</a>
    <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait Put[Z, E] extends AnyRef with shapeless.Zipper.ZipperOp1[Z,E]" id="shapeless.Zipper;Put">Put</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;Put;Z">Z</a>, <a title="" id="shapeless.Zipper;Put;E">E</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp1" title="shapeless.Zipper.ZipperOp1[Z,E]">ZipperOp1</a><span class="delimiter">[</span>Z, E<span class="delimiter">]</span>
  
  <span class="keyword">trait</span> <a title="trait LowPriorityPut extends AnyRef" id="shapeless.Zipper;LowPriorityPut">LowPriorityPut</a> <span title="Unit" class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, L &lt;: shapeless.HList, RH, RT &lt;: shapeless.HList, P, E, CL &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[C,CL], implicit rp: shapeless.ops.hlist.ReversePrepend.Aux[L,shapeless.::[E,RT],CL])shapeless.Zipper.Put[shapeless.Zipper[C,L,shapeless.::[RH,RT],P],E]{type Out = shapeless.Zipper[C,L,shapeless.::[E,RT],P]}" id="shapeless.Zipper;LowPriorityPut.put">put</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;LowPriorityPut.put;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper;LowPriorityPut.put;L">L</a> &lt;: HList, <a title="" id="shapeless.Zipper;LowPriorityPut.put;RH">RH</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper;LowPriorityPut.put;RT">RT</a> &lt;: HList, <a title="" id="shapeless.Zipper;LowPriorityPut.put;P">P</a>, <a title="" id="shapeless.Zipper;LowPriorityPut.put;E">E</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper;LowPriorityPut.put;CL">CL</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[C,CL]" id="shapeless.Zipper;LowPriorityPut.put.gen">gen</a> : Generic.<a href="generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[C,CL]">Aux</a><span class="delimiter">[</span>C, CL<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ReversePrepend.Aux[L,shapeless.::[E,RT],CL]" id="shapeless.Zipper;LowPriorityPut.put.rp">rp</a> : ReversePrepend.<a href="ops/hlists.scala.html#shapeless.ops.hlist;LowPriorityReversePrepend;<refinement>" title="shapeless.ops.hlist.ReversePrepend.Aux[L,shapeless.::[E,RT],CL]">Aux</a><span class="delimiter">[</span>L, E :: RT, CL<span class="delimiter">]</span><span class="delimiter">)</span> =
        <a href="#shapeless.Zipper;LowPriorityPut.put;$anon" title="shapeless.Zipper.Put[shapeless.Zipper[C,L,shapeless.::[RH,RT],P],E]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.Put[shapeless.Zipper[C,L,shapeless.::[RH,RT],P],E]" id="shapeless.Zipper;LowPriorityPut.put;$anon">Put</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, RH :: RT, P<span class="delimiter">]</span>, E<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="shapeless.Zipper[C,L,shapeless.::[E,RT],P]" id="shapeless.Zipper;LowPriorityPut.put;$anon;Out">Out</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,shapeless.::[E,RT],P]">Zipper</a><span class="delimiter">[</span>C, L, E :: RT, P<span class="delimiter">]</span>
          <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,shapeless.::[RH,RT],P], e: E)shapeless.Zipper[C,L,shapeless.::[E,RT],P]" id="shapeless.Zipper;LowPriorityPut.put;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]" id="shapeless.Zipper;LowPriorityPut.put;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">Zipper</a><span class="delimiter">[</span>C, L, RH :: RT, P<span class="delimiter">]</span>, <a title="E" id="shapeless.Zipper;LowPriorityPut.put;$anon.apply.e">e</a> : <a href="#shapeless.Zipper;LowPriorityPut.put;E" title="E">E</a><span class="delimiter">)</span> = <a href="#shapeless;Zipper" title="(prefix: L, suffix: shapeless.::[E,RT], parent: P)shapeless.Zipper[C,L,shapeless.::[E,RT],P]">Zipper</a><span class="delimiter">(</span><a href="#shapeless.Zipper;LowPriorityPut.put;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="#shapeless;Zipper.prefix" title="=&gt; L">prefix</a>, <a href="#shapeless.Zipper;LowPriorityPut.put;$anon.apply.e" title="E">e</a> <a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.::" title="(h: E)shapeless.::[E,RT]">::</a> <a href="#shapeless.Zipper;LowPriorityPut.put;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="#shapeless;Zipper.suffix" title="=&gt; shapeless.::[RH,RT]">suffix</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: RT)shapeless.syntax.HListOps[RT]">tail</a>, <a href="#shapeless.Zipper;LowPriorityPut.put;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="#shapeless;Zipper.parent" title="=&gt; P">parent</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">object</span> <a title="shapeless.Zipper.Put.type" id="shapeless.Zipper.Put">Put</a> <a href="#shapeless.Zipper.Put" title="shapeless.Zipper.Put.type" class="keyword">extends</a> <a href="#shapeless.Zipper;LowPriorityPut" title="shapeless.Zipper.LowPriorityPut">LowPriorityPut</a> <span class="delimiter">{</span>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C &lt;: shapeless.HList, L &lt;: shapeless.HList, RH, RT &lt;: shapeless.HList, P, E, CL &lt;: shapeless.HList](implicit rp: shapeless.ops.hlist.ReversePrepend.Aux[L,shapeless.::[E,RT],CL])shapeless.Zipper.Put[shapeless.Zipper[C,L,shapeless.::[RH,RT],P],E]{type Out = shapeless.Zipper[CL,L,shapeless.::[E,RT],P]}" id="shapeless.Zipper.Put.hlistPut">hlistPut</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Put.hlistPut;C">C</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Put.hlistPut;L">L</a> &lt;: HList, <a title="" id="shapeless.Zipper.Put.hlistPut;RH">RH</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Put.hlistPut;RT">RT</a> &lt;: HList, <a title="" id="shapeless.Zipper.Put.hlistPut;P">P</a>, <a title="" id="shapeless.Zipper.Put.hlistPut;E">E</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Put.hlistPut;CL">CL</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ReversePrepend.Aux[L,shapeless.::[E,RT],CL]" id="shapeless.Zipper.Put.hlistPut.rp">rp</a> : ReversePrepend.<a href="ops/hlists.scala.html#shapeless.ops.hlist;LowPriorityReversePrepend;<refinement>" title="shapeless.ops.hlist.ReversePrepend.Aux[L,shapeless.::[E,RT],CL]">Aux</a><span class="delimiter">[</span>L, E :: RT, CL<span class="delimiter">]</span><span class="delimiter">)</span> =
        <a href="#shapeless.Zipper.Put.hlistPut;$anon" title="shapeless.Zipper.Put[shapeless.Zipper[C,L,shapeless.::[RH,RT],P],E]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.Put[shapeless.Zipper[C,L,shapeless.::[RH,RT],P],E]" id="shapeless.Zipper.Put.hlistPut;$anon">Put</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, RH :: RT, P<span class="delimiter">]</span>, E<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="shapeless.Zipper[CL,L,shapeless.::[E,RT],P]" id="shapeless.Zipper.Put.hlistPut;$anon;Out">Out</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[CL,L,shapeless.::[E,RT],P]">Zipper</a><span class="delimiter">[</span>CL, L, E :: RT, P<span class="delimiter">]</span>
          <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,shapeless.::[RH,RT],P], e: E)shapeless.Zipper[CL,L,shapeless.::[E,RT],P]" id="shapeless.Zipper.Put.hlistPut;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]" id="shapeless.Zipper.Put.hlistPut;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">Zipper</a><span class="delimiter">[</span>C, L, RH :: RT, P<span class="delimiter">]</span>, <a title="E" id="shapeless.Zipper.Put.hlistPut;$anon.apply.e">e</a> : <a href="#shapeless.Zipper.Put.hlistPut;E" title="E">E</a><span class="delimiter">)</span> = <a href="#shapeless;Zipper" title="(prefix: L, suffix: shapeless.::[E,RT], parent: P)shapeless.Zipper[CL,L,shapeless.::[E,RT],P]">Zipper</a><span class="delimiter">(</span><a href="#shapeless.Zipper.Put.hlistPut;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="#shapeless;Zipper.prefix" title="=&gt; L">prefix</a>, <a href="#shapeless.Zipper.Put.hlistPut;$anon.apply.e" title="E">e</a> <a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.::" title="(h: E)shapeless.::[E,RT]">::</a> <a href="#shapeless.Zipper.Put.hlistPut;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="#shapeless;Zipper.suffix" title="=&gt; shapeless.::[RH,RT]">suffix</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: RT)shapeless.syntax.HListOps[RT]">tail</a>, <a href="#shapeless.Zipper.Put.hlistPut;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="#shapeless;Zipper.parent" title="=&gt; P">parent</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>
  
  <span class="keyword">trait</span> <a title="trait Insert[Z, E] extends AnyRef with shapeless.Zipper.ZipperOp1[Z,E]" id="shapeless.Zipper;Insert">Insert</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;Insert;Z">Z</a>, <a title="" id="shapeless.Zipper;Insert;E">E</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp1" title="shapeless.Zipper.ZipperOp1[Z,E]">ZipperOp1</a><span class="delimiter">[</span>Z, E<span class="delimiter">]</span>
  
  <span class="keyword">object</span> <a title="shapeless.Zipper.Insert.type" id="shapeless.Zipper.Insert">Insert</a> <a href="#shapeless.Zipper.Insert" title="shapeless.Zipper.Insert.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C &lt;: shapeless.HList, L &lt;: shapeless.HList, R &lt;: shapeless.HList, P, E, CL &lt;: shapeless.HList](implicit rp: shapeless.ops.hlist.ReversePrepend.Aux[shapeless.::[E,L],R,CL])shapeless.Zipper.Insert[shapeless.Zipper[C,L,R,P],E]{type Out = shapeless.Zipper[CL,shapeless.::[E,L],R,P]}" id="shapeless.Zipper.Insert.hlistInsert">hlistInsert</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Insert.hlistInsert;C">C</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Insert.hlistInsert;L">L</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Insert.hlistInsert;R">R</a> &lt;: HList, <a title="" id="shapeless.Zipper.Insert.hlistInsert;P">P</a>, <a title="" id="shapeless.Zipper.Insert.hlistInsert;E">E</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Insert.hlistInsert;CL">CL</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ReversePrepend.Aux[shapeless.::[E,L],R,CL]" id="shapeless.Zipper.Insert.hlistInsert.rp">rp</a> : ReversePrepend.<a href="ops/hlists.scala.html#shapeless.ops.hlist;LowPriorityReversePrepend;<refinement>" title="shapeless.ops.hlist.ReversePrepend.Aux[shapeless.::[E,L],R,CL]">Aux</a><span class="delimiter">[</span>E :: L, R, CL<span class="delimiter">]</span><span class="delimiter">)</span> =
        <a href="#shapeless.Zipper.Insert.hlistInsert;$anon" title="shapeless.Zipper.Insert[shapeless.Zipper[C,L,R,P],E]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.Insert[shapeless.Zipper[C,L,R,P],E]" id="shapeless.Zipper.Insert.hlistInsert;$anon">Insert</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span>, E<span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="shapeless.Zipper[CL,shapeless.::[E,L],R,P]" id="shapeless.Zipper.Insert.hlistInsert;$anon;Out">Out</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[CL,shapeless.::[E,L],R,P]">Zipper</a><span class="delimiter">[</span>CL, E :: L, R, P<span class="delimiter">]</span>
          <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,R,P], e: E)shapeless.Zipper[CL,shapeless.::[E,L],R,P]" id="shapeless.Zipper.Insert.hlistInsert;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,R,P]" id="shapeless.Zipper.Insert.hlistInsert;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]">Zipper</a><span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span>, <a title="E" id="shapeless.Zipper.Insert.hlistInsert;$anon.apply.e">e</a> : <a href="#shapeless.Zipper.Insert.hlistInsert;E" title="E">E</a><span class="delimiter">)</span> = <a href="#shapeless;Zipper" title="(prefix: shapeless.::[E,L], suffix: R, parent: P)shapeless.Zipper[CL,shapeless.::[E,L],R,P]">Zipper</a><span class="delimiter">(</span><a href="#shapeless.Zipper.Insert.hlistInsert;$anon.apply.e" title="E">e</a> <a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.::" title="(h: E)shapeless.::[E,L]">::</a> <a href="#shapeless.Zipper.Insert.hlistInsert;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: L)shapeless.syntax.HListOps[L]">prefix</a>, <a href="#shapeless.Zipper.Insert.hlistInsert;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="#shapeless;Zipper.suffix" title="=&gt; R">suffix</a>, <a href="#shapeless.Zipper.Insert.hlistInsert;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="#shapeless;Zipper.parent" title="=&gt; P">parent</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait Delete[Z] extends AnyRef with shapeless.Zipper.ZipperOp0[Z]" id="shapeless.Zipper;Delete">Delete</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;Delete;Z">Z</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp0" title="shapeless.Zipper.ZipperOp0[Z]">ZipperOp0</a><span class="delimiter">[</span>Z<span class="delimiter">]</span>
  
  <span class="keyword">object</span> <a title="shapeless.Zipper.Delete.type" id="shapeless.Zipper.Delete">Delete</a> <a href="#shapeless.Zipper.Delete" title="shapeless.Zipper.Delete.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C &lt;: shapeless.HList, L &lt;: shapeless.HList, RH, RT &lt;: shapeless.HList, P, CL &lt;: shapeless.HList](implicit rp: shapeless.ops.hlist.ReversePrepend.Aux[L,RT,CL])shapeless.Zipper.Delete[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]{type Out = shapeless.Zipper[CL,L,RT,P]}" id="shapeless.Zipper.Delete.hlistDelete">hlistDelete</a><span class="delimiter">[</span><a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Delete.hlistDelete;C">C</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Delete.hlistDelete;L">L</a> &lt;: HList, <a title="" id="shapeless.Zipper.Delete.hlistDelete;RH">RH</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Delete.hlistDelete;RT">RT</a> &lt;: HList, <a title="" id="shapeless.Zipper.Delete.hlistDelete;P">P</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Delete.hlistDelete;CL">CL</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.ops.hlist.ReversePrepend.Aux[L,RT,CL]" id="shapeless.Zipper.Delete.hlistDelete.rp">rp</a> : ReversePrepend.<a href="ops/hlists.scala.html#shapeless.ops.hlist;LowPriorityReversePrepend;<refinement>" title="shapeless.ops.hlist.ReversePrepend.Aux[L,RT,CL]">Aux</a><span class="delimiter">[</span>L, RT, CL<span class="delimiter">]</span><span class="delimiter">)</span> =
        <a href="#shapeless.Zipper.Delete.hlistDelete;$anon" title="shapeless.Zipper.Delete[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.Delete[shapeless.Zipper[C,L,shapeless.::[RH,RT],P]]" id="shapeless.Zipper.Delete.hlistDelete;$anon">Delete</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, RH :: RT, P<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="shapeless.Zipper[CL,L,RT,P]" id="shapeless.Zipper.Delete.hlistDelete;$anon;Out">Out</a> = <a href="#shapeless;Zipper" title="shapeless.Zipper[CL,L,RT,P]">Zipper</a><span class="delimiter">[</span>CL, L, RT, P<span class="delimiter">]</span>
          <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,shapeless.::[RH,RT],P])shapeless.Zipper[CL,L,RT,P]" id="shapeless.Zipper.Delete.hlistDelete;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]" id="shapeless.Zipper.Delete.hlistDelete;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">Zipper</a><span class="delimiter">[</span>C, L, RH :: RT, P<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless;Zipper" title="(prefix: L, suffix: RT, parent: P)shapeless.Zipper[CL,L,RT,P]">Zipper</a><span class="delimiter">(</span><a href="#shapeless.Zipper.Delete.hlistDelete;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="#shapeless;Zipper.prefix" title="=&gt; L">prefix</a>, <a href="#shapeless.Zipper.Delete.hlistDelete;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="#shapeless;Zipper.suffix" title="=&gt; shapeless.::[RH,RT]">suffix</a>.<a href="hlists.scala.html#shapeless;::.tail" title="=&gt; RT">tail</a>, <a href="#shapeless.Zipper.Delete.hlistDelete;$anon.apply.z" title="shapeless.Zipper[C,L,shapeless.::[RH,RT],P]">z</a>.<a href="#shapeless;Zipper.parent" title="=&gt; P">parent</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>

  <span class="keyword">trait</span> <a title="trait Reify[Z] extends AnyRef with shapeless.Zipper.ZipperOp0[Z]" id="shapeless.Zipper;Reify">Reify</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper;Reify;Z">Z</a><span class="delimiter">]</span> <span class="keyword">extends</span> <a href="#shapeless.Zipper;ZipperOp0" title="shapeless.Zipper.ZipperOp0[Z]">ZipperOp0</a><span class="delimiter">[</span>Z<span class="delimiter">]</span>
  
  <span class="keyword">object</span> <a title="shapeless.Zipper.Reify.type" id="shapeless.Zipper.Reify">Reify</a> <a href="#shapeless.Zipper.Reify" title="shapeless.Zipper.Reify.type" class="delimiter">{</a>
    <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[C, L &lt;: shapeless.HList, R &lt;: shapeless.HList, P, CL &lt;: shapeless.HList](implicit gen: shapeless.Generic.Aux[C,CL], implicit rp: shapeless.ops.hlist.ReversePrepend.Aux[L,R,CL])shapeless.Zipper.Reify[shapeless.Zipper[C,L,R,P]]{type Out = C}" id="shapeless.Zipper.Reify.reify">reify</a><span class="delimiter">[</span><a title="" id="shapeless.Zipper.Reify.reify;C">C</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Reify.reify;L">L</a> &lt;: HList, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Reify.reify;R">R</a> &lt;: HList, <a title="" id="shapeless.Zipper.Reify.reify;P">P</a>, <a title=" &lt;: shapeless.HList" id="shapeless.Zipper.Reify.reify;CL">CL</a> &lt;: HList<span class="delimiter">]</span>
      <span class="delimiter">(</span><span class="keyword">implicit</span> <a title="shapeless.Generic.Aux[C,CL]" id="shapeless.Zipper.Reify.reify.gen">gen</a> : Generic.<a href="generic.scala.html#shapeless.Generic;<refinement>" title="shapeless.Generic.Aux[C,CL]">Aux</a><span class="delimiter">[</span>C, CL<span class="delimiter">]</span>, <a title="shapeless.ops.hlist.ReversePrepend.Aux[L,R,CL]" id="shapeless.Zipper.Reify.reify.rp">rp</a> : ReversePrepend.<a href="ops/hlists.scala.html#shapeless.ops.hlist;LowPriorityReversePrepend;<refinement>" title="shapeless.ops.hlist.ReversePrepend.Aux[L,R,CL]">Aux</a><span class="delimiter">[</span>L, R, CL<span class="delimiter">]</span><span class="delimiter">)</span> =
        <a href="#shapeless.Zipper.Reify.reify;$anon" title="shapeless.Zipper.Reify[shapeless.Zipper[C,L,R,P]]" class="keyword">new</a> <a title="anonymous class $anon extends AnyRef with shapeless.Zipper.Reify[shapeless.Zipper[C,L,R,P]]" id="shapeless.Zipper.Reify.reify;$anon">Reify</a><span class="delimiter">[</span>Zipper<span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">{</span>
          <span class="keyword">type</span> <a title="C" id="shapeless.Zipper.Reify.reify;$anon;Out">Out</a> = <a href="#shapeless.Zipper.Reify.reify;C" title="C">C</a>
          <span class="keyword">def</span> <a title="(z: shapeless.Zipper[C,L,R,P])C" id="shapeless.Zipper.Reify.reify;$anon.apply">apply</a><span class="delimiter">(</span><a title="shapeless.Zipper[C,L,R,P]" id="shapeless.Zipper.Reify.reify;$anon.apply.z">z</a> : <a href="#shapeless;Zipper" title="shapeless.Zipper[C,L,R,P]">Zipper</a><span class="delimiter">[</span>C, L, R, P<span class="delimiter">]</span><span class="delimiter">)</span> = <a href="#shapeless.Zipper.Reify.reify.gen" title="shapeless.Generic.Aux[C,CL]">gen</a>.<a href="generic.scala.html#shapeless;Generic.from" title="(r: gen.Repr)C">from</a><span class="delimiter">(</span><a href="#shapeless.Zipper.Reify.reify;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="#shapeless;Zipper.prefix" title="=&gt; L">prefix</a> <a href="syntax/hlists.scala.html#shapeless.syntax;HListOps.reverse_:::" title="(prefix: L)(implicit prepend: shapeless.ops.hlist.ReversePrepend[L,R])prepend.Out">reverse_:::</a> <a href="#shapeless.Zipper.Reify.reify;$anon.apply.z" title="shapeless.Zipper[C,L,R,P]">z</a>.<a href="hlists.scala.html#shapeless.HList.hlistOps" title="(l: R)shapeless.syntax.HListOps[R]">suffix</a><span class="delimiter">)</span>
        <span class="delimiter">}</span>
  <span class="delimiter">}</span>
<span title="AnyRef" class="delimiter">}</span>

        </pre>
    </body>
</html>
